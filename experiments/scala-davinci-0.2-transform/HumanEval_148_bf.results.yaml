language: scala
name: HumanEval_148_bf
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1)\n        }\n    \
    \    planets.slice(p1, p2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7a983398.scala:33)\n\tat Problem.main(tmp7a983398.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        if (index1 < index2) {\n            return planets.slice(index1\
    \ + 1, index2)\n        } else {\n            return planets.slice(index2 + 1,\
    \ index1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (start, end) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.bf(String, String)\" is null\n\tat Problem$.main(tmp17vxoo2p.scala:25)\n\
    \tat Problem.main(tmp17vxoo2p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        val minIndex = min(planet1Index, planet2Index)\n        val\
    \ maxIndex = max(planet1Index, planet2Index)\n        planets.slice(minIndex +\
    \ 1, maxIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            List()\n        } else\
    \ {\n            val min = min(index1, index2)\n            val max = max(index1,\
    \ index2)\n            planets.slice(min + 1, max)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpovpdo5dk.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(index1,\
    \ index2)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m\
    \                      Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpovpdo5dk.scala:28:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36mmax\e[0m = max(index1, index2)\n\e[31m\e[31m   |\e[0m              \
    \        ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val start\
    \ = planets.indexOf(planet1)\n        val end = planets.indexOf(planet2)\n   \
    \     if (start == -1 || end == -1) List()\n        else if (start < end) planets.slice(start\
    \ + 1, end)\n        else planets.slice(end + 1, start)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 <\
    \ index2) return planets.slice(index1 + 1, index2)\n        else return planets.slice(index2\
    \ + 1, index1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            if (planet1Index < planet2Index) {\n          \
    \      planets.slice(planet1Index + 1, planet2Index)\n            } else {\n \
    \               planets.slice(planet2Index + 1, planet1Index)\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) return List()\n       \
    \ val minIndex = min(planet1Index, planet2Index)\n        val maxIndex = max(planet1Index,\
    \ planet2Index)\n        planets.slice(minIndex + 1, maxIndex)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            val minIndex = min(planet1Index, planet2Index)\n\
    \            val maxIndex = max(planet1Index, planet2Index)\n            planets.slice(minIndex\
    \ + 1, maxIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       planets.slice(min(p1, p2) + 1, max(p1, p2))\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo1e1h31i.scala:30)\n\tat Problem.main(tmpo1e1h31i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1 < p2)\
    \ (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return planets.slice(p1\
    \ + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        if (planets.contains(planet1)\
    \ && planets.contains(planet2)) {\n            val p1 = planets.indexOf(planet1)\n\
    \            val p2 = planets.indexOf(planet2)\n            val min = min(p1,\
    \ p2)\n            val max = max(p1, p2)\n            val result = planets.slice(min\
    \ + 1, max)\n            result\n        } else {\n            List()\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoxbd6_d6.scala:25:22 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoxbd6_d6.scala:26:22 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) {\n            return List()\n    \
    \    }\n        if (index1 > index2) {\n            return planets.slice(index2,\
    \ index1 + 1)\n        }\n        else {\n            return planets.slice(index1,\
    \ index2 + 1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbp8k5acb.scala:35)\n\tat Problem.main(tmpbp8k5acb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3yapp9zw.scala:25)\n\tat Problem.main(tmp3yapp9zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1)\n        }\n    \
    \    planets.slice(p1, p2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7a983398.scala:33)\n\tat Problem.main(tmp7a983398.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) List()\n        else if (index1 < index2)\
    \ planets.slice(index1 + 1, index2)\n        else planets.slice(index2 + 1, index1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            if (planet1Index < planet2Index) {\n          \
    \      planets.slice(planet1Index + 1, planet2Index)\n            } else {\n \
    \               planets.slice(planet2Index + 1, planet1Index)\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val index1 = planets.indexOf(planet1)\n        val index2\
    \ = planets.indexOf(planet2)\n        if (index1 == -1 || index2 == -1) {\n  \
    \          return List()\n        }\n        if (index1 < index2) {\n        \
    \    return planets.slice(index1 + 1, index2)\n        } else {\n            return\
    \ planets.slice(index2 + 1, index1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 <\
    \ index2) planets.slice(index1 + 1, index2)\n        else planets.slice(index2\
    \ + 1, index1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        if (planet1Index < planet2Index) {\n            return planets.slice(planet1Index\
    \ + 1, planet2Index)\n        } else {\n            return planets.slice(planet2Index\
    \ + 1, planet1Index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val start = min(p1, p2)\n\
    \        val end = max(p1, p2)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val pos1\
    \ = planets.indexOf(planet1)\n        val pos2 = planets.indexOf(planet2)\n  \
    \      if (pos1 == -1 || pos2 == -1) return List()\n        val min = min(pos1,\
    \ pos2)\n        val max = max(pos1, pos2)\n        planets.slice(min + 1, max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvf6lmyna.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(pos1, pos2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvf6lmyna.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(pos1, pos2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyu7i7zhz.scala:25)\n\tat Problem.main(tmpyu7i7zhz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3yapp9zw.scala:25)\n\tat Problem.main(tmp3yapp9zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val start = min(p1, p2)\n\
    \        val end = max(p1, p2)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        val minIndex = min(planet1Index, planet2Index)\n        val\
    \ maxIndex = max(planet1Index, planet2Index)\n        return planets.slice(minIndex\
    \ + 1, maxIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (start, end) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(start + 1, end)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the body of this function\n        List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxlyvmln1.scala:25)\n\tat Problem.main(tmpxlyvmln1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) planets.slice(p2,\
    \ p1)\n        else planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp279x4n3x.scala:30)\n\tat Problem.main(tmp279x4n3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyu7i7zhz.scala:25)\n\tat Problem.main(tmpyu7i7zhz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else planets.slice(min(p1, p2)\
    \ + 1, max(p1, p2))\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Write your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpglc59o_v.scala:25)\n\tat Problem.main(tmpglc59o_v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) List()\n        else if (index1 < index2)\
    \ planets.slice(index1 + 1, index2)\n        else planets.slice(index2 + 1, index1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2,\
    \ p1 + 1)\n        else planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8p5ff76.scala:29)\n\tat Problem.main(tmpg8p5ff76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else {\n            val min = min(p1,\
    \ p2)\n            val max = max(p1, p2)\n            planets.slice(min + 1, max)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4_557v3o.scala:26:22 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4_557v3o.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        var planetList = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        var planet1Index = planetList.indexOf(planet1)\n     \
    \   var planet2Index = planetList.indexOf(planet2)\n        if (planet1Index ==\
    \ -1 || planet2Index == -1) {\n            return List()\n        }\n        if\
    \ (planet1Index > planet2Index) {\n            return planetList.slice(planet2Index,\
    \ planet1Index + 1)\n        }\n        return planetList.slice(planet1Index,\
    \ planet2Index + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_mxvkinp.scala:34)\n\tat Problem.main(tmp_mxvkinp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1_index\
    \ = planets.indexOf(planet1)\n        val planet2_index = planets.indexOf(planet2)\n\
    \        if (planet1_index == -1 || planet2_index == -1) {\n            return\
    \ List()\n        }\n        val min_index = min(planet1_index, planet2_index)\n\
    \        val max_index = max(planet1_index, planet2_index)\n        planets.slice(min_index\
    \ + 1, max_index)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 < 0 || p2 < 0) return List[String]()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe1a_gifn.scala:29)\n\tat Problem.main(tmpe1a_gifn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n        } else\
    \ {\n            return planets.slice(p2 + 1, p1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyu7i7zhz.scala:25)\n\tat Problem.main(tmpyu7i7zhz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val (p1,\
    \ p2) = (planets.indexOf(planet1), planets.indexOf(planet2))\n        if (p1 ==\
    \ -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1, p2 + 1)\n\
    \        else planets.slice(p2, p1 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpru2ownw_.scala:28)\n\tat Problem.main(tmpru2ownw_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 >\
    \ index2) return planets.slice(index2, index1 + 1)\n        planets.slice(index1,\
    \ index2 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4vmz0uo.scala:29)\n\tat Problem.main(tmpr4vmz0uo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n    \
    \    if (i1 == -1 || i2 == -1) List()\n        else if (i1 > i2) planets.slice(i2,\
    \ i1 + 1)\n        else planets.slice(i1, i2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbtovh7h8.scala:29)\n\tat Problem.main(tmpbtovh7h8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 > p2) planets.slice(p2\
    \ + 1, p1)\n        else planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min\
    \ + 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.bf(String, String)\" is null\n\tat Problem$.main(tmp17vxoo2p.scala:25)\n\
    \tat Problem.main(tmp17vxoo2p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val index1\
    \ = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 >\
    \ index2) return planets.slice(index2, index1 + 1)\n        else return planets.slice(index1,\
    \ index2 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpll7uufbk.scala:29)\n\tat Problem.main(tmpll7uufbk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1)\n            return List()\n        if (p1 > p2)\n\
    \            return planets.slice(p2 + 1, p1)\n        else\n            return\
    \ planets.slice(p1 + 1, p2)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.bf(String, String)\" is null\n\tat Problem$.main(tmp17vxoo2p.scala:25)\n\
    \tat Problem.main(tmp17vxoo2p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3yapp9zw.scala:25)\n\tat Problem.main(tmp3yapp9zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n     \
    \   if (p1 > p2) {\n            return planets.slice(p2, p1 + 1)\n        }\n\
    \        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu5wy7fz_.scala:33)\n\tat Problem.main(tmpu5wy7fz_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        (min + 1 until max).map(planets(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n          \
    \  } else {\n                planets.slice(p2 + 1, p1)\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val min = min(p1, p2)\n            val max = max(p1, p2)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplag2c5vc.scala:28:22 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb52bo_3r.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659797980
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            return List()\n\
    \        }\n        val minIndex = min(planet1Index, planet2Index)\n        val\
    \ maxIndex = max(planet1Index, planet2Index)\n        return planets.slice(minIndex\
    \ + 1, maxIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       val start = min(p1, p2)\n            val end = max(p1, p2)\n         \
    \   planets.slice(start + 1, end)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeckhkl9i.scala:29)\n\tat Problem.main(tmpeckhkl9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        val res = planets.slice(min + 1, max)\n\
    \        return res\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa4urlsyi.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa4urlsyi.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // Fill in the code here\n        val planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectzgm6h.scala:29)\n\tat Problem.main(tmpectzgm6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val planet1Index\
    \ = planets.indexOf(planet1)\n        val planet2Index = planets.indexOf(planet2)\n\
    \        if (planet1Index == -1 || planet2Index == -1) {\n            List()\n\
    \        } else {\n            val startIndex = min(planet1Index, planet2Index)\n\
    \            val endIndex = max(planet1Index, planet2Index)\n            planets.slice(startIndex\
    \ + 1, endIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"\
    Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2\
    \ + 1, p1)\n        else return planets.slice(p1 + 1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1)\n        else return planets.slice(p1, p2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe51bqekh.scala:29)\n\tat Problem.main(tmpe51bqekh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        // your code here\n        return List[String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp707olfdq.scala:25)\n\tat Problem.main(tmp707olfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // >>> bf((\"Jupiter\"\
    ), (\"Neptune\"))\n    // (List[String](\"Saturn\", \"Uranus\"))\n    // >>> bf((\"\
    Earth\"), (\"Mercury\"))\n    // (List[String](\"Venus\"))\n    // >>> bf((\"\
    Mercury\"), (\"Uranus\"))\n    // (List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))\n    def bf(planet1 : String, planet2 : String) :\
    \ List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797983
