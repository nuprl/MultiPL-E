name: HumanEval_115_max_fill
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n    // and each 1 in a row represents a single unit of water.\n    // Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  \    // and all buckets have the same capacity.\n    // Your task is to use the\
  \ buckets to empty the wells.\n    // Output the number of times you need to lower\
  \ the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
  \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n  \
  \  // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
  \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n  \
  \  // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    // * 1\
  \ <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) ==\
  \ (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) ==\
  \ (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (9l)) == (2l));\n    }\n\n}\n"
completions: ["        // Fill in the code here\n        0l", "        // Fill your\
    \ code here\n        0l", "        // Your code here\n        0l", "        //\
    \ Fill your code here\n        0l", "        // Fill your code here\n        0l",
  "        // Fill your code here\n        0l", "        // Fill each well with the\
    \ maximum amount of water possible.\n        // The number of times you need to\
    \ lower the buckets is the number of times you need to fill each well.\n     \
    \   // The maximum amount of water possible is the minimum of the capacity and\
    \ the number of 1s in the well.\n        // The number of 1s in the well is the\
    \ sum of the well.\n        // The sum of the well is the sum of the row.\n  \
    \      // The sum of the row is the sum of the list.\n        // The sum of the\
    \ list is the sum of the elements.\n        // The sum of the elements is the\
    \ sum of the elements of the list.\n        // The sum of the elements of the\
    \ list is the sum of the elements of the list.\n        // The sum of the elements\
    \ of the list is the sum of the elements of the list.\n        // The sum of the\
    \ elements of the list is the sum of the elements of the list.\n        // The\
    \ sum of the elements of the list is the sum of the elements of the list.\n  \
    \      // The sum of the elements of the list is the sum of the elements of the\
    \ list.\n        // The sum of the elements of the list is the sum of the elements\
    \ of the list.\n        // The sum of the elements of the list is the sum of the\
    \ elements of the list.\n        // The sum of the elements of the list is the\
    \ sum of the elements of the list.\n        // The sum of the elements of the\
    \ list is the sum of the elements of the list.\n        // The sum of the elements\
    \ of the list is the sum of the elements of the list.\n        // The sum of the\
    \ elements of the list is the sum of the elements of the list.\n        // The\
    \ sum of the elements of the list is the sum of the elements of the list.\n  \
    \      // The sum of the elements of the list is the sum of the elements of the\
    \ list.\n        // The sum of the elements of the list is the sum of the elements\
    \ of the list.\n        // The sum of the elements of the list is the sum of the\
    \ elements of the list.\n        // The sum of the elements of the list is the\
    \ sum of the elements of the list.\n        // The sum of the elements of the\
    \ list is the sum of the elements of the list.\n        // The sum of the elements\
    \ of the", "        // Fill the wells with water\n        // Return the number\
    \ of times you need to lower the buckets\n        // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
    \        // (6l)\n        // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n        // (5l)\n        // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n\
    \        // (0l)\n        // Constraints:\n        // * all wells have the same\
    \ length\n        // * 1 <= grid.length <= 10^2\n        // * 1 <= grid[:,1].length\
    \ <= 10^2\n        // * grid[i][j] -> 0 | 1\n        // * 1 <= capacity <= 10\n\
    \        // * all wells have the same length\n        // * 1 <= grid.length <=\
    \ 10^2\n        // * 1 <= grid[:,1].length <= 10^2\n        // * grid[i][j] ->\
    \ 0 | 1\n        // * 1 <= capacity <= 10\n        // * all wells have the same\
    \ length\n        // * 1 <= grid.length <= 10^2\n        // * 1 <= grid[:,1].length\
    \ <= 10^2\n       ", "        // Fill in the code here\n        0l", "       \
    \ // Fill in the code here\n        0l", "        // Fill your code here\n   \
    \     0l", "        // Fill your code here\n        0l", "        // Fill the\
    \ wells from the bottom up.\n        // For each well, fill it to the capacity.\n\
    \        // If the well is already full, then do nothing.\n        // If the well\
    \ is not full, then fill it to the capacity.\n        // If the well is overfilled,\
    \ then fill it to the capacity.\n        // If the well is underfilled, then fill\
    \ it to the capacity.\n        // If the well is empty, then fill it to the capacity.\n\
    \        // If the well is full, then fill it to the capacity.\n        // If\
    \ the well is empty, then fill it to the capacity.\n        // If the well is\
    \ full, then fill it to the capacity.\n        // If the well is empty, then fill\
    \ it to the capacity.\n        // If the well is full, then fill it to the capacity.\n\
    \        // If the well is empty, then fill it to the capacity.\n        // If\
    \ the well is full, then fill it to the capacity.\n        // If the well is empty,\
    \ then fill it to the capacity.\n        // If the well is full, then fill it\
    \ to the capacity.\n        // If the well is empty, then fill it to the capacity.\n\
    \        // If the well is full, then fill it to the capacity.\n        // If\
    \ the well is empty, then fill it to the capacity.\n        // If the well is\
    \ full, then fill it to the capacity.\n        // If the well is empty, then fill\
    \ it to the capacity.\n        // If the well is full, then fill it to the capacity.\n\
    \        // If the well is empty, then fill it to the capacity.\n        // If\
    \ the well is full, then fill it to the capacity.\n        // If the well is empty,\
    \ then fill it to the capacity.\n        // If the well is full, then fill it\
    \ to the capacity.\n        // If the well is empty, then fill it to the capacity.\n\
    \        // If the well is full, then fill it to the capacity.\n        // If\
    \ the well is empty, then fill it to the capacity.\n        // If the well is\
    \ full, then fill it to the capacity.\n        // If the well is empty, then fill\
    \ it to the capacity.\n        // If the well is full, then fill it to the capacity.\n\
    \        // If the well is", "        // Fill your code here\n        0l", " \
    \       // Fill your code here\n        0l", "        // Fill your code here\n\
    \        0l", "        // Fill your code here\n        0l", "        // Fill your\
    \ code here\n        0l", "        // Fill your code here\n        0l", "    \
    \    // Fill the wells from the bottom up, and keep track of the number of times\
    \ you fill a well.\n        // If a well is already full, then you don't need\
    \ to fill it.\n        // If a well is empty, then you need to fill it.\n    \
    \    // If a well is partially full, then you need to fill it to capacity.\n \
    \       // The total number of times you fill a well is the answer.\n        //\
    \ The time complexity is O(n^2), where n is the number of wells.\n        // The\
    \ space complexity is O(n), where n is the number of wells.\n        var count\
    \ = 0l\n        for (i <- grid.length - 1 to 0 by -1) {\n            for (j <-\
    \ 0 until grid(i).length) {\n                if (grid(i)(j) < capacity) {\n  \
    \                  count += capacity - grid(i)(j)\n                    grid(i)(j)\
    \ = capacity\n                }\n            }\n        }\n        return count"]
stop_tokens:
- "\n    }\n"
