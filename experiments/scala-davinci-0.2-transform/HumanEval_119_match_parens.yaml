name: HumanEval_119_match_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of two strings, both strings consist of open\n    //\
  \ parentheses '(' or close parentheses ')' only.\n    // Your job is to check if\
  \ it is possible to concatenate the two strings in\n    // some order, that the\
  \ resulting string will be good.\n    // A string S is considered to be good if\
  \ and only if all parentheses in S\n    // are balanced. For example: the string\
  \ '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes'\
  \ if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n\
  \    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    //\
  \ >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst\
  \ : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
  ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
  , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
  , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
  , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
  , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\"\
  , \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\",\
  \ \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
  , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
  , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \"\
  )(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"\
  Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\"\
  )));\n    }\n\n}\n"
completions: ["        val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1\
    \ + s2\n        val stack = new Stack[Char]\n        for (c <- s) {\n        \
    \    if (c == '(') stack.push(c)\n            else if (c == ')') {\n         \
    \       if (stack.isEmpty) return \"No\"\n                else stack.pop\n   \
    \         }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "   \
    \     val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n    \
    \    val n = s.length\n        var stack = new Stack[Char]\n        for (i <-\
    \ 0 until n) {\n            val c = s(i)\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      val s = s1 + s2\n        var stack = new Stack[Char]\n        for (c <-\
    \ s) {\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s = lst.mkString\n        val n = s.length\n        val dp = Array.fill(n\
    \ + 1)(0)\n        for (i <- 1 to n) {\n            if (s(i - 1) == '(') dp(i)\
    \ = dp(i - 1) + 1\n            else dp(i) = dp(i - 1) - 1\n            if (dp(i)\
    \ < 0) return \"No\"\n        }\n        if (dp(n) == 0) \"Yes\" else \"No\"",
  "        val str1 = lst(0)\n        val str2 = lst(1)\n        val str = str1 +\
    \ str2\n        val stack = new Stack[Char]\n        for (c <- str) {\n      \
    \      if (c == '(') stack.push(c)\n            else {\n                if (stack.isEmpty)\
    \ return \"No\"\n                else stack.pop\n            }\n        }\n  \
    \      if (stack.isEmpty) \"Yes\" else \"No\"", "        val s1 = lst(0)\n   \
    \     val s2 = lst(1)\n        val s = s1 + s2\n        val stack = new Stack[Char]\n\
    \        for (c <- s) {\n            if (c == '(') stack.push(c)\n           \
    \ else if (c == ')') {\n                if (stack.isEmpty) return \"No\"\n   \
    \             else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val s = lst.mkString\n        val n = s.length\n\
    \        var c = 0\n        for (i <- 0 until n) {\n            if (s(i) == '(')\
    \ c += 1\n            else c -= 1\n            if (c < 0) return \"No\"\n    \
    \    }\n        if (c == 0) \"Yes\" else \"No\"", "        val s1 = lst(0)\n \
    \       val s2 = lst(1)\n        def isGood(s : String) : Boolean = {\n      \
    \      var stack = new Stack[Char]\n            for (c <- s) {\n             \
    \   if (c == '(') stack.push(c)\n                else if (c == ')') {\n      \
    \              if (stack.isEmpty) return false\n                    else stack.pop\n\
    \                }\n            }\n            stack.isEmpty\n        }\n    \
    \    if (isGood(s1 + s2)) \"Yes\"\n        else if (isGood(s2 + s1)) \"Yes\"\n\
    \        else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n   \
    \     val s3 = s1 + s2\n        val s4 = s2 + s1\n        if (isGood(s3)) \"Yes\"\
    \n        else if (isGood(s4)) \"Yes\"\n        else \"No\"", "        val s1\
    \ = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        var stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else {\n                if (stack.isEmpty) return \"No\"\n      \
    \          else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      val s = s1 + s2\n        val stack = new Stack[Char]\n        for (c <-\
    \ s) {\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n  \
    \      val stack = new Stack[Char]\n        for (c <- s) {\n            if (c\
    \ == '(') stack.push(c)\n            else if (c == ')') {\n                if\
    \ (stack.isEmpty) return \"No\"\n                else stack.pop\n            }\n\
    \        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", "        val s1 =\
    \ lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      var stack = new Stack[Char]\n        for (c <- s1) {\n            if (c\
    \ == '(') stack.push(c)\n            else if (stack.isEmpty) return \"No\"\n \
    \           else stack.pop\n        }\n        for (c <- s2) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (stack.isEmpty) return \"No\"\n\
    \            else stack.pop\n        }\n        if (stack.isEmpty) \"Yes\" else\
    \ \"No\"", "        val s = lst.mkString\n        if (s.length % 2 == 1) return\
    \ \"No\"\n        val stack = new Stack[Char]\n        for (c <- s) {\n      \
    \      if (c == '(') stack.push(c)\n            else if (stack.isEmpty) return\
    \ \"No\"\n            else stack.pop\n        }\n        if (stack.isEmpty) \"\
    Yes\" else \"No\"", "        var s1 = lst(0)\n        var s2 = lst(1)\n      \
    \  var s = s1 + s2\n        var stack = new Stack[Char]\n        for (c <- s)\
    \ {\n            if (c == '(') stack.push(c)\n            else if (c == ')') {\n\
    \                if (stack.isEmpty) return \"No\"\n                stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val s1 = lst(0)\n        val s2 = lst(1)\n        val s1_open = s1.count(_\
    \ == '(')\n        val s1_close = s1.count(_ == ')')\n        val s2_open = s2.count(_\
    \ == '(')\n        val s2_close = s2.count(_ == ')')\n        val s1_balance =\
    \ s1_open - s1_close\n        val s2_balance = s2_open - s2_close\n        if\
    \ (s1_balance + s2_balance == 0) \"Yes\"\n        else \"No\"", "        val s1\
    \ = lst(0)\n        val s2 = lst(1)\n        val s = s1 + s2\n        val stack\
    \ = new Stack[Char]\n        for (c <- s) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return \"\
    No\"\n                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ \"Yes\" else \"No\"", "        val s1 = lst(0)\n        val s2 = lst(1)\n  \
    \      val s = s1 + s2\n        val stack = new Stack[Char]\n        for (c <-\
    \ s) {\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return \"No\"\n                else stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) \"Yes\" else \"No\"", " \
    \       val (s1, s2) = (lst(0), lst(1))\n        val (c1, c2) = (s1.count(_ ==\
    \ '('), s1.count(_ == ')'))\n        val (d1, d2) = (s2.count(_ == '('), s2.count(_\
    \ == ')'))\n        if (c1 == c2 && d1 == d2) \"Yes\"\n        else if (c1 ==\
    \ c2 && d1 > d2) \"Yes\"\n        else if (c1 > c2 && d1 == d2) \"Yes\"\n    \
    \    else \"No\""]
stop_tokens:
- "\n    }\n"
