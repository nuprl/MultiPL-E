name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        def primeFibRec(n : Long, a : Long, b : Long, i : Long) : Long\
    \ = {\n            if (i == n) b\n            else {\n                val c =\
    \ a + b\n                if (isPrime(c)) primeFibRec(n, b, c, i + 1)\n       \
    \         else primeFibRec(n, b, c, i)\n            }\n        }\n        primeFibRec(n,\
    \ 1, 2, 1)", "        var i = 0l\n        var j = 1l\n        var k = 0l\n   \
    \     var count = 0l\n        while (count < n) {\n            k = i + j\n   \
    \         if (isPrime(k)) {\n                count += 1\n            }\n     \
    \       i = j\n            j = k\n        }\n        return k", "        var i\
    \ = 1l\n        var j = 1l\n        var k = 1l\n        var count = 1l\n     \
    \   while (count < n) {\n            k = i + j\n            if (isPrime(k)) count\
    \ += 1\n            i = j\n            j = k\n        }\n        k", "       \
    \ def primeFib(n : Long, a : Long, b : Long, c : Long) : Long = {\n          \
    \  if (n == 1) a\n            else if (n == 2) b\n            else if (n == 3)\
    \ c\n            else if (isPrime(c)) primeFib(n - 1, b, c, a + b + c)\n     \
    \       else primeFib(n, a, b, c + a + b)\n        }\n        primeFib(n, 2, 3,\
    \ 5)", "        var i = 1l\n        var j = 1l\n        var k = 2l\n        var\
    \ count = 0l\n        while (count < n) {\n            if (isPrime(k)) count +=\
    \ 1\n            val t = i + j\n            i = j\n            j = k\n       \
    \     k = t\n        }\n        return k", "        var i = 0l\n        var j\
    \ = 1l\n        var k = 0l\n        var count = 0l\n        while (count < n)\
    \ {\n            k = i + j\n            i = j\n            j = k\n           \
    \ if (k.isPrime) count += 1\n        }\n        return k", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs += 3;\n        var\
    \ i = 2;\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2);\n            i += 1;\n        }\n        return fibs(n.toInt - 1);", " \
    \       val primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n\
    \        var i = 0l\n        var p = 0l\n        while (i < n) {\n           \
    \ p = fib.next\n            if (primes.contains(p)) i += 1\n        }\n      \
    \  return p", "        val primes = new PrimeSet(1000000)\n        var i = 1l\n\
    \        var j = 1l\n        var k = 1l\n        var count = 0l\n        while\
    \ (count < n) {\n            k = i + j\n            if (primes.isPrime(k)) count\
    \ += 1\n            i = j\n            j = k\n        }\n        k", "       \
    \ var i = 1l\n        var f = 1l\n        var f1 = 1l\n        var f2 = 2l\n \
    \       var p = 2l\n        while (i < n) {\n            f = f1 + f2\n       \
    \     f1 = f2\n            f2 = f\n            if (f.isPrime) {\n            \
    \    p = f\n                i += 1\n            }\n        }\n        return p",
  "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        fib(2) = 2\n        var i = 3\n        while (i <= n) {\n     \
    \       fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n    \
    \    var p = 2\n        var j = 1\n        while (j < n) {\n            p += 1\n\
    \            while (!isPrime(p)) {\n                p += 1\n            }\n  \
    \          if (fib.contains(p)) {\n                j += 1\n            }\n   \
    \     }\n        p", "        var i = 1l\n        var j = 1l\n        var k =\
    \ 1l\n        var count = 0l\n        while (count < n) {\n            k = i +\
    \ j\n            if (isPrime(k)) {\n                count += 1\n            }\n\
    \            i = j\n            j = k\n        }\n        return k", "       \
    \ var f1 : Long = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n\
    \        var c : Long = 3l\n        while (c < n) {\n            f1 = f2\n   \
    \         f2 = f3\n            f3 = f1 + f2\n            if (f3.isPrime) {\n \
    \               c += 1\n            }\n        }\n        return f3", "      \
    \  var fib = new Fibonacci()\n        var i = 1l\n        var result = 0l\n  \
    \      while (i <= n) {\n            result = fib.next\n            if (result.isPrime)\
    \ i += 1\n        }\n        return result", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i <= n) {\n            var fib = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n \
    \           if (isPrime(fib)) {\n                fibs += fib;\n              \
    \  i += 1l;\n            }\n        }\n        return fibs(n.toInt - 1);", " \
    \       var i = 1l\n        var fib = 1l\n        var fib1 = 1l\n        var fib2\
    \ = 1l\n        while (i < n) {\n            fib = fib1 + fib2\n            fib2\
    \ = fib1\n            fib1 = fib\n            if (fib.isPrime) i += 1\n      \
    \  }\n        return fib", "        val primes = new PrimeSet(1000000)\n     \
    \   var fib = new Fibonacci()\n        var i = 0l\n        var result = 0l\n \
    \       while (i < n) {\n            result = fib.next\n            if (primes.contains(result))\
    \ i += 1\n        }\n        return result", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            val fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        def primeFib(n : Long,\
    \ fib : Long, fib_1 : Long, fib_2 : Long, count : Long) : Long = {\n         \
    \   if (count == n) fib\n            else {\n                val fib_next = fib_1\
    \ + fib_2\n                if (isPrime(fib_next)) primeFib(n, fib_next, fib, fib_1,\
    \ count + 1)\n                else primeFib(n, fib, fib_1, fib_next, count)\n\
    \            }\n        }\n        primeFib(n, 2, 3, 1, 1)", "        var i =\
    \ 1l\n        var j = 1l\n        var k = 1l\n        var count = 0l\n       \
    \ while (count < n) {\n            k = i + j\n            if (k.isPrime) {\n \
    \               count += 1\n            }\n            i = j\n            j =\
    \ k\n        }\n        return k", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 0l\n        var j = 1l\n        var k = 0l\n        var count\
    \ = 0l\n        while (count < n) {\n            k = i + j\n            i = j\n\
    \            j = k\n            if (primes.isPrime(k)) count += 1\n        }\n\
    \        return k", "        var i = 1l\n        var j = 1l\n        var k = 1l\n\
    \        var count = 1l\n        while (count < n) {\n            k = i + j\n\
    \            if (BigInt(k).isProbablePrime(10)) {\n                count += 1\n\
    \            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var\
    \ count = 0l\n        while (count < n) {\n            k = i + j\n           \
    \ if (isPrime(k)) {\n                count += 1\n            }\n            i\
    \ = j\n            j = k\n        }\n        return k", "        var a = 2l;\n\
    \        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while\
    \ (i < n) {\n            a = b;\n            b = c;\n            c = a + b;\n\
    \            i = i + 1;\n        }\n        return c;", "        var i = 1l\n\
    \        var j = 1l\n        var k = 1l\n        var count = 1l\n        while\
    \ (count < n) {\n            k = i + j\n            if (BigInt(k).isProbablePrime(100))\
    \ count += 1\n            i = j\n            j = k\n        }\n        return\
    \ k", "        def primeFib(n : Long, a : Long, b : Long, count : Long) : Long\
    \ = {\n            if (count == n) b\n            else {\n                val\
    \ c = a + b\n                if (isPrime(c)) primeFib(n, b, c, count + 1)\n  \
    \              else primeFib(n, b, c, count)\n            }\n        }\n     \
    \   primeFib(n, 0, 1, 1)", "        var fibs = new ArrayBuffer[Long]();\n    \
    \    fibs += 1;\n        fibs += 2;\n        var i = 2;\n        while(i < n)\
    \ {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n   \
    \     }\n        return fibs(n.toInt - 1);", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i < n) {\n            fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n    \
    \        i += 1l;\n        }\n        return fibs(n.toInt - 1);", "        var\
    \ i = 1l\n        var j = 1l\n        var k = 1l\n        var c = 0l\n       \
    \ while (c < n) {\n            k = i + j\n            if (isPrime(k)) c += 1\n\
    \            i = j\n            j = k\n        }\n        return k", "       \
    \ val primes = new PrimeSet(1000000)\n        var a = 2l\n        var b = 3l\n\
    \        var c = 5l\n        var i = 5l\n        while (i < n) {\n           \
    \ a = b\n            b = c\n            c = a + b\n            i += 1\n      \
    \  }\n        return c", "        var i = 1l\n        var j = 2l\n        var\
    \ k = 3l\n        var count = 2l\n        while (count < n) {\n            i =\
    \ j\n            j = k\n            k = i + j\n            if (isPrime(k)) {\n\
    \                count += 1\n            }\n        }\n        return k", "  \
    \      val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j =\
    \ 2l\n        var k = 3l\n        var count = 1l\n        while (count < n) {\n\
    \            i = j\n            j = k\n            k = i + j\n            if (primes.contains(k))\
    \ count += 1\n        }\n        k", "        var a = 2l;\n        var b = 3l;\n\
    \        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n         \
    \   a = b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n\
    \        }\n        return c;", "        def primeFib(n : Long, a : Long, b :\
    \ Long, i : Long) : Long = {\n            if (i == n) b\n            else {\n\
    \                val c = a + b\n                if (isPrime(c)) primeFib(n, b,\
    \ c, i + 1)\n                else primeFib(n, b, c, i)\n            }\n      \
    \  }\n        primeFib(n, 1, 2, 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 1l\n        var p = 0l\n \
    \       while (i <= n) {\n            p = fib.next\n            if (primes.contains(p))\
    \ i += 1\n        }\n        return p", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n \
    \       while (i < n) {\n            p = fib.next\n            if (primes.contains(p))\
    \ i += 1\n        }\n        return p", "        var i = 1l\n        var j = 1l\n\
    \        var k = 1l\n        var count = 1l\n        while (count < n) {\n   \
    \         k = i + j\n            if (isPrime(k)) {\n                count += 1\n\
    \            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var primes = new ArrayBuffer[Long]();\n        primes += 2l;\n\
    \        primes += 3l;\n        var fib = new ArrayBuffer[Long]();\n        fib\
    \ += 2l;\n        fib += 3l;\n        var i = 2l;\n        while (fib.length <\
    \ n) {\n            var j = 0;\n            while (primes(j) * primes(j) <= i)\
    \ {\n                if (i % primes(j) == 0) {\n                    i += 1;\n\
    \                    j = 0;\n                } else {\n                    j +=\
    \ 1;\n                }\n            }\n            primes += i;\n           \
    \ fib += fib(fib.length - 1) + fib(fib.length - 2);\n        }\n        return\
    \ fib(fib.length - 1);", "        var fib = new Fibonacci()\n        var i = 0l\n\
    \        while (i < n) {\n            val f = fib.next()\n            if (isPrime(f))\
    \ i += 1\n            if (i == n) return f\n        }\n        return -1", " \
    \       def primeFib(n : Long, a : Long, b : Long, i : Long) : Long = {\n    \
    \        if (i == n) b\n            else {\n                val c = a + b\n  \
    \              if (Library.isPrime(c)) primeFib(n, b, c, i + 1)\n            \
    \    else primeFib(n, b, c, i)\n            }\n        }\n        primeFib(n,\
    \ 1, 2, 1)", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n\
    \        fibs += 3;\n        var i = 2;\n        while(i <= n) {\n           \
    \ var next = fibs(i - 1) + fibs(i - 2);\n            if(isPrime(next)) {\n   \
    \             fibs += next;\n                i += 1;\n            }\n        }\n\
    \        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 0l\n        var result = 0l\n\
    \        while (i < n) {\n            result = fib.next\n            if (primes.contains(result))\
    \ i += 1\n        }\n        return result", "        var a = 2l;\n        var\
    \ b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n\
    \            a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        while (k\
    \ < n) {\n            val t = i + j\n            if (primes.isPrime(t)) k += 1\n\
    \            i = j\n            j = t\n        }\n        j", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     fib(2) = 2\n        var i = 3\n        while (i <= n) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        var result\
    \ = fib(n.toInt)\n        while (!isPrime(result)) {\n            result = fib(n.toInt\
    \ - 1) + fib(n.toInt - 2)\n            n -= 1\n        }\n        return result",
  "        var i = 1l\n        var j = 2l\n        var k = 3l\n        var count =\
    \ 2l\n        while (count < n) {\n            i = j\n            j = k\n    \
    \        k = i + j\n            if (k.isPrime) count += 1\n        }\n       \
    \ k", "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n       \
    \ var i = 3l;\n        while (i <= n) {\n            a = b;\n            b = c;\n\
    \            c = a + b;\n            if (isPrime(c)) {\n                i += 1;\n\
    \            }\n        }\n        return c;", "        def primeFib(n : Long,\
    \ a : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n      \
    \      else {\n                val c = a + b\n                if (isPrime(c))\
    \ primeFib(n, b, c, i + 1)\n                else primeFib(n, b, c, i)\n      \
    \      }\n        }\n        primeFib(n, 1, 2, 1)", "        def primeFib(n :\
    \ Long, a : Long, b : Long, c : Long) : Long = {\n            if (n == 1) {\n\
    \                a\n            } else if (n == 2) {\n                b\n    \
    \        } else {\n                val d = a + b\n                if (isPrime(d))\
    \ {\n                    primeFib(n - 1, b, d, c + 1)\n                } else\
    \ {\n                    primeFib(n, b, d, c)\n                }\n           \
    \ }\n        }\n        primeFib(n, 2, 3, 2)", "        var a = 2l;\n        var\
    \ b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n\
    \            a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        var fib = new Fibonacci()\n\
    \        var i = 0l\n        var f = 0l\n        while (i < n) {\n           \
    \ f = fib.next\n            if (isPrime(f)) i += 1\n        }\n        return\
    \ f", "        val primes = new PrimeSet(1000000)\n        val fibs = new FibonacciSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        while (i <= n) {\n          \
    \  if (primes.contains(fibs(j))) i += 1\n            j += 1\n        }\n     \
    \   fibs(j - 1)", "        def primeFib(n : Long, a : Long, b : Long, count :\
    \ Long) : Long = {\n            if (count == n) b\n            else {\n      \
    \          val c = a + b\n                if (isPrime(c)) primeFib(n, b, c, count\
    \ + 1)\n                else primeFib(n, b, c, count)\n            }\n       \
    \ }\n        primeFib(n, 1, 2, 1)", "        var i = 1l\n        var j = 1l\n\
    \        var k = 1l\n        var count = 1l\n        while (count < n) {\n   \
    \         k = i + j\n            if (k.isPrime) count += 1\n            i = j\n\
    \            j = k\n        }\n        k", "        if (n == 1) return 2\n   \
    \     if (n == 2) return 3\n        var f1 = 2\n        var f2 = 3\n        var\
    \ count = 2\n        while (count < n) {\n            val f3 = f1 + f2\n     \
    \       if (isPrime(f3)) {\n                count += 1\n                if (count\
    \ == n) return f3\n            }\n            f1 = f2\n            f2 = f3\n \
    \       }\n        return -1", "        var fib = new Fibonacci()\n        var\
    \ i = 0l\n        var p = fib.next()\n        while (i < n) {\n            p =\
    \ fib.next()\n            if (p.isPrime) {\n                i += 1\n         \
    \   }\n        }\n        return p", "        val fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        return fibs(n.toInt - 1);", "        def primeFib0(n : Long,\
    \ a : Long, b : Long, c : Long) : Long = {\n            if (n == 0) c\n      \
    \      else if (isPrime(b)) primeFib0(n - 1, b, a + b, b)\n            else primeFib0(n,\
    \ b, a + b, c)\n        }\n        primeFib0(n, 0, 1, 0)", "        val primes\
    \ = new PrimeSet(1000000)\n        var i = 1l\n        var j = 1l\n        var\
    \ k = 2l\n        var count = 0l\n        while (count < n) {\n            if\
    \ (primes.contains(k)) {\n                count += 1\n            }\n        \
    \    val t = k\n            k = i + j\n            i = j\n            j = t\n\
    \        }\n        k", "        var i = 0l\n        var j = 1l\n        var k\
    \ = 0l\n        var count = 0l\n        while (count < n) {\n            k = i\
    \ + j\n            if (k.isPrime) {\n                count += 1\n            }\n\
    \            i = j\n            j = k\n        }\n        return k", "       \
    \ var i = 1l\n        var j = 2l\n        var k = 3l\n        var count = 2l\n\
    \        while (count < n) {\n            i = j\n            j = k\n         \
    \   k = i + j\n            if (k.isPrime) {\n                count += 1\n    \
    \        }\n        }\n        return k", "        var primes = new ArrayBuffer[Long]();\n\
    \        primes += 2l;\n        primes += 3l;\n        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (primes.length < n) {\n            i += 1l;\n            if (i % 2l == 0l) {\n\
    \                continue;\n            }\n            var isPrime = true;\n \
    \           for (prime <- primes) {\n                if (prime * prime > i) {\n\
    \                    break;\n                }\n                if (i % prime\
    \ == 0l) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            if (isPrime) {\n              \
    \  primes += i;\n                var fib = fibs(fibs.length - 1l) + fibs(fibs.length\
    \ - 2l);\n                if (fib == i) {\n                    fibs += i;\n  \
    \              }\n            }\n        }\n        return fibs(fibs.length -\
    \ 1l);", "        val fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n \
    \       fibs += 3l;\n        var i = 2l;\n        while (i <= n) {\n         \
    \   val fib = fibs(i.toInt - 2) + fibs(i.toInt - 1);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1l;\n            }\n \
    \       }\n        fibs(n.toInt - 1)", "        var fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 2\n        fib(1) = 3\n        var i = 2\n        while (i <\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            if (fib(i) %\
    \ 2 == 0) {\n                i -= 1\n            }\n            i += 1\n     \
    \   }\n        return fib(n.toInt - 1)", "        var i = 1l\n        var j =\
    \ 1l\n        var k = 2l\n        var count = 1l\n        while (count < n) {\n\
    \            k = i + j\n            if (isPrime(k)) {\n                count +=\
    \ 1\n            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        def primeFib(n : Long, a : Long, b : Long, count : Long) : Long\
    \ = {\n            if (count == n) b\n            else if (isPrime(b)) primeFib(n,\
    \ b, a + b, count + 1)\n            else primeFib(n, b, a + b, count)\n      \
    \  }\n        primeFib(n, 1, 2, 1)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            val fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        def primeFib(n : Long,\
    \ a : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n      \
    \      else if (isPrime(b)) primeFib(n, b, a + b, i + 1)\n            else primeFib(n,\
    \ b, a + b, i)\n        }\n        primeFib(n, 2, 3, 1)", "        var f1 : Long\
    \ = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n        var i\
    \ : Long = 3l\n        while(i < n) {\n            f1 = f2\n            f2 = f3\n\
    \            f3 = f1 + f2\n            while(!isPrime(f3)) {\n               \
    \ f1 = f2\n                f2 = f3\n                f3 = f1 + f2\n           \
    \ }\n            i = i + 1\n        }\n        return f3", "        val primes\
    \ = new PrimeSet(10000)\n        var i = 1l\n        var j = 1l\n        var k\
    \ = 1l\n        var count = 0l\n        while (count < n) {\n            val t\
    \ = i + j\n            if (primes.isPrime(t)) {\n                k = t\n     \
    \           count += 1\n            }\n            i = j\n            j = t\n\
    \        }\n        k", "        var i = 1l\n        var j = 1l\n        var k\
    \ = 1l\n        var count = 0l\n        while (count < n) {\n            k = i\
    \ + j\n            if (isPrime(k)) {\n                count += 1\n           \
    \ }\n            i = j\n            j = k\n        }\n        return k", "   \
    \     val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j =\
    \ 1l\n        var k = 1l\n        var count = 0l\n        while (count < n) {\n\
    \            k = i + j\n            if (primes.contains(k)) count += 1\n     \
    \       i = j\n            j = k\n        }\n        k", "        var f1 : Long\
    \ = 2\n        var f2 : Long = 3\n        var f3 : Long = 5\n        var i : Long\
    \ = 3\n        while (i < n) {\n            f1 = f2\n            f2 = f3\n   \
    \         f3 = f1 + f2\n            if (f3.isPrime) {\n                i += 1\n\
    \            }\n        }\n        return f3", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        var j\
    \ = 3l;\n        while (i < n) {\n            var k = j + fibs(fibs.length - 2);\n\
    \            if (k.isPrime) {\n                fibs += k;\n                i +=\
    \ 1;\n            }\n            j += 2;\n        }\n        return fibs(fibs.length\
    \ - 1);", "        def primeFib(n : Long, a : Long, b : Long, c : Long) : Long\
    \ = {\n            if (n == 1) a\n            else if (n == 2) b\n           \
    \ else if (n == 3) c\n            else {\n                val d = a + b + c\n\
    \                if (isPrime(d)) primeFib(n - 1, b, c, d)\n                else\
    \ primeFib(n, b, c, d)\n            }\n        }\n        primeFib(n, 2, 3, 5)",
  "        def primeFibHelper(n : Long, a : Long, b : Long, count : Long) : Long =\
    \ {\n            if (count == n) b\n            else if (isPrime(b)) primeFibHelper(n,\
    \ b, a + b, count + 1)\n            else primeFibHelper(n, b, a + b, count)\n\
    \        }\n        primeFibHelper(n, 0, 1, 1)", "        var i = 1l\n       \
    \ var j = 1l\n        var k = 0l\n        var count = 0l\n        while (count\
    \ < n) {\n            k = i + j\n            i = j\n            j = k\n      \
    \      if (BigInt(k).isProbablePrime(10)) count += 1\n        }\n        k", " \
    \       var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i =\
    \ 3l;\n        while (i < n) {\n            a = b;\n            b = c;\n     \
    \       c = a + b;\n            i = i + 1;\n        }\n        return c;", " \
    \       val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j\
    \ = 1l\n        var k = 2l\n        var count = 0l\n        while (count < n)\
    \ {\n            if (primes.contains(k)) count += 1\n            i = j\n     \
    \       j = k\n            k = i + j\n        }\n        k", "        var fibs\
    \ = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs += 3;\n       \
    \ var i = 2;\n        while (i <= n) {\n            var fib = fibs(i - 1) + fibs(i\
    \ - 2);\n            if (isPrime(fib)) {\n                fibs += fib;\n     \
    \           i += 1;\n            }\n        }\n        return fibs(n.toInt - 1);",
  "        var i = 0l\n        var j = 1l\n        var k = 0l\n        var count =\
    \ 0l\n        while (count < n) {\n            k = i + j\n            if (k.isPrime)\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var fib = new Fibonacci()\n \
    \       var i = 0l\n        var result = 0l\n        while (i < n) {\n       \
    \     result = fib.next\n            if (isPrime(result)) i += 1\n        }\n\
    \        return result", "        var a = 2l;\n        var b = 3l;\n        var\
    \ c = 5l;\n        var i = 3l;\n        while (i < n) {\n            a = b;\n\
    \            b = c;\n            c = a + b;\n            i = i + 1;\n        }\n\
    \        return c;", "        var fibs = new ArrayBuffer[Long]();\n        fibs\
    \ += 2;\n        fibs += 3;\n        var i = 2;\n        while (i < n) {\n   \
    \         fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n        }\n\
    \        var j = fibs.length - 1;\n        while (j >= 0) {\n            if (isPrime(fibs(j)))\
    \ return fibs(j);\n            j -= 1;\n        }\n        return 0;", "     \
    \   var fib = new Fibonacci()\n        var i = 0l\n        var f = 0l\n      \
    \  while (i < n) {\n            f = fib.next()\n            if (f.isPrime) i +=\
    \ 1\n        }\n        return f", "        var i = 1l\n        var j = 2l\n \
    \       var k = 3l\n        var c = 0l\n        while (c < n) {\n            if\
    \ (isPrime(k)) {\n                c += 1\n            }\n            val t = k\n\
    \            k = i + j\n            i = j\n            j = t\n        }\n    \
    \    return k", "        def fib(n : Long) : Long = {\n            if (n == 1)\
    \ return 2\n            if (n == 2) return 3\n            var a = 2l\n       \
    \     var b = 3l\n            var i = 3l\n            while (i <= n) {\n     \
    \           val c = a + b\n                a = b\n                b = c\n    \
    \            i += 1\n            }\n            return b\n        }\n        def\
    \ isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n    \
    \        if (n == 2) return true\n            if (n % 2 == 0) return false\n \
    \           val sqrtN = sqrt(n).toLong\n            var i = 3l\n            while\
    \ (i <= sqrtN) {\n                if (n % i == 0) return false\n             \
    \   i += 2\n            }\n            return true\n        }\n        var i =\
    \ 1l\n        var j = 1l\n        while (i <= n) {\n            j += 1\n     \
    \       if (isPrime(fib(j))) i += 1\n        }\n        return fib(j)", "    \
    \    def primeFib(n : Long, a : Long, b : Long, c : Long) : Long = {\n       \
    \     if (n == 1) {\n                a\n            } else if (n == 2) {\n   \
    \             b\n            } else {\n                val d = a + b + c\n   \
    \             if (isPrime(d)) {\n                    primeFib(n - 1, b, c, d)\n\
    \                } else {\n                    primeFib(n, b, c, d)\n        \
    \        }\n            }\n        }\n        primeFib(n, 2, 3, 5)", "       \
    \ var a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n\
    \        while (i < n) {\n            a = b;\n            b = c;\n           \
    \ c = a + b;\n            i = i + 1;\n        }\n        return c;", "       \
    \ var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs += 3l;\n\
    \        var i = 2l;\n        while (i <= n) {\n            var fib = fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            if (isPrime(fib)) {\n               \
    \ fibs += fib;\n                i += 1l;\n            }\n        }\n        return\
    \ fibs(n.toInt - 1);", "        var a = 2l;\n        var b = 3l;\n        var\
    \ c = 5l;\n        var i = 4l;\n        while (i <= n) {\n            a = b;\n\
    \            b = c;\n            c = a + b;\n            while (!isPrime(c)) {\n\
    \                a = b;\n                b = c;\n                c = a + b;\n\
    \            }\n            i += 1;\n        }\n        return c;", "        var\
    \ i = 1l\n        var j = 1l\n        var k = 1l\n        var count = 1l\n   \
    \     while (count < n) {\n            k = i + j\n            if (k.isPrime) {\n\
    \                count += 1\n            }\n            i = j\n            j =\
    \ k\n        }\n        return k", "        var i = 1l\n        var j = 2l\n \
    \       var k = 3l\n        var count = 1l\n        while (count < n) {\n    \
    \        if (isPrime(k)) {\n                count += 1\n            }\n      \
    \      i = j\n            j = k\n            k = i + j\n        }\n        return\
    \ k", "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n       \
    \ var i = 3l;\n        while (i < n) {\n            a = b;\n            b = c;\n\
    \            c = a + b;\n            i = i + 1;\n        }\n        return c;",
  "        var i = 1l\n        var j = 2l\n        var k = 3l\n        var count =\
    \ 1l\n        while (count < n) {\n            if (isPrime(k)) {\n           \
    \     count += 1\n            }\n            i = j\n            j = k\n      \
    \      k = i + j\n        }\n        return k", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1;\n        fibs += 2;\n        var i = 2;\n        while (i\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        var fib = fibs(i - 1);\n        while (!isPrime(fib)) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2);\n            fib = fibs(i);\n\
    \            i += 1;\n        }\n        return fib;", "        val primes = new\
    \ PrimeSet(1000000)\n        var fib = 1l\n        var fib_prev = 1l\n       \
    \ var i = 1l\n        while (i < n) {\n            val temp = fib\n          \
    \  fib += fib_prev\n            fib_prev = temp\n            if (primes.contains(fib))\
    \ i += 1\n        }\n        fib", "        var a = 2l;\n        var b = 3l;\n\
    \        var c = 5l;\n        var i = 5l;\n        while (i < n) {\n         \
    \   a = b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n\
    \        }\n        return c;", "        var i = 1l\n        var a = 2l\n    \
    \    var b = 3l\n        var c = 5l\n        while (i < n) {\n            val\
    \ d = a + b + c\n            a = b\n            b = c\n            c = d\n   \
    \         if (isPrime(c)) i += 1\n        }\n        return c", "        val primes\
    \ = new Primes(1000000)\n        var a = 1l\n        var b = 1l\n        var c\
    \ = 2l\n        var i = 1l\n        while (i < n) {\n            a = b\n     \
    \       b = c\n            c = a + b\n            if (primes.isPrime(c)) i +=\
    \ 1\n        }\n        return c", "        var fib : Long = 1\n        var fib_prev\
    \ : Long = 1\n        var count : Long = 0\n        while (count < n) {\n    \
    \        val fib_next = fib + fib_prev\n            fib_prev = fib\n         \
    \   fib = fib_next\n            if (isPrime(fib)) count += 1\n        }\n    \
    \    return fib", "        var i = 0l\n        var j = 1l\n        var k = 0l\n\
    \        var count = 0l\n        while (count < n) {\n            k = i + j\n\
    \            if (k.isPrime) {\n                count += 1\n            }\n   \
    \         i = j\n            j = k\n        }\n        return k", "        var\
    \ i = 1l\n        var j = 1l\n        var k = 1l\n        var count = 1l\n   \
    \     while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        def primeFib(n : Long, a : Long,\
    \ b : Long, i : Long) : Long = {\n            if (i == n) b\n            else\
    \ if (isPrime(b)) primeFib(n, b, a + b, i + 1)\n            else primeFib(n, b,\
    \ a + b, i)\n        }\n        primeFib(n, 1, 2, 1)", "        var fib = new\
    \ Fibonacci()\n        var i = 0l\n        var f = 0l\n        while (i < n) {\n\
    \            f = fib.next()\n            if (f.isPrime()) i += 1\n        }\n\
    \        return f", "        def primeFib(n : Long, a : Long, b : Long, count\
    \ : Long) : Long = {\n            if (count == n) b\n            else if (isPrime(b))\
    \ primeFib(n, b, a + b, count + 1)\n            else primeFib(n, b, a + b, count)\n\
    \        }\n        primeFib(n, 1, 2, 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 2l\n        var k = 3l\n        var count\
    \ = 0l\n        while (count < n) {\n            if (primes.contains(k)) {\n \
    \               count += 1\n            }\n            val t = k\n           \
    \ k = i + j\n            i = j\n            j = t\n        }\n        k", "  \
    \      var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs +=\
    \ 3;\n        var i = 2;\n        while (i <= n) {\n            var fib = fibs(i\
    \ - 1) + fibs(i - 2);\n            if (isPrime(fib)) {\n                fibs +=\
    \ fib;\n                i += 1;\n            }\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var i = 1l\n        var j = 1l\n        var k = 2l\n      \
    \  var count = 2l\n        while (count < n) {\n            if (isPrime(k)) {\n\
    \                count += 1\n            }\n            val temp = k\n       \
    \     k = i + j\n            i = j\n            j = temp\n        }\n        k",
  "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count =\
    \ 0l\n        while (count < n) {\n            k = i + j\n            if (k.isPrime)\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        def primeFib(n : Long, a : Long,\
    \ b : Long, count : Long) : Long = {\n            if (count == n) b\n        \
    \    else {\n                val c = a + b\n                if (isPrime(c)) primeFib(n,\
    \ b, c, count + 1)\n                else primeFib(n, b, c, count)\n          \
    \  }\n        }\n        primeFib(n, 1, 2, 1)", "        var a : Long = 2l;\n\
    \        var b : Long = 3l;\n        var c : Long = 5l;\n        var i : Long\
    \ = 3l;\n        while (i < n) {\n            a = b;\n            b = c;\n   \
    \         c = a + b;\n            i = i + 1l;\n        }\n        return c;",
  "        val primes = new PrimeSet(1000000)\n        val fib = new Fibonacci()\n\
    \        var i = 0l\n        var p = 0l\n        while (i < n) {\n           \
    \ p = fib.next\n            if (primes.contains(p)) i += 1\n        }\n      \
    \  p", "        def primeFib(n : Long, a : Long, b : Long, i : Long) : Long =\
    \ {\n            if (i == n) b\n            else if (isPrime(b)) primeFib(n, b,\
    \ a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n        }\n      \
    \  primeFib(n, 2, 3, 1)", "        var fib = new Array[Long](n.toInt)\n      \
    \  fib(0) = 2\n        fib(1) = 3\n        var i = 2\n        var j = 0\n    \
    \    while (i < n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n         \
    \   if (isPrime(fib(i))) {\n                i += 1\n            }\n        }\n\
    \        return fib(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            var fib = fibs(i - 1) + fibs(i - 2);\n            if (fib.isPrime)\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        var fibs = ListBuffer[Long](2l,\
    \ 3l)\n        var i = 2l\n        while (fibs.length < n) {\n            val\
    \ fib = fibs(i.toInt - 1) + fibs(i.toInt - 2)\n            if (fib.isPrime) fibs\
    \ += fib\n            i += 1\n        }\n        fibs(n.toInt - 1)", "       \
    \ var fib = new Fibonacci()\n        var i = 1l\n        var p = fib.next\n  \
    \      while (i < n) {\n            p = fib.next\n            if (p.isPrime) i\
    \ += 1\n        }\n        return p", "        var i = 1l\n        var j = 1l\n\
    \        var k = 0l\n        var count = 1l\n        while (count < n) {\n   \
    \         k = i + j\n            i = j\n            j = k\n            if (isPrime(k))\
    \ count += 1\n        }\n        return k", "        def primeFib(n : Long, a\
    \ : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n        \
    \    else {\n                val c = a + b\n                if (c.isPrime) primeFib(n,\
    \ b, c, i + 1)\n                else primeFib(n, b, c, i)\n            }\n   \
    \     }\n        primeFib(n, 0, 1, 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var f1 = 2l\n        var f2 = 3l\n        var f3 = 5l\n        var i\
    \ = 2l\n        while (i < n) {\n            f1 = f2\n            f2 = f3\n  \
    \          f3 = f1 + f2\n            i += 1\n        }\n        return f3", " \
    \       var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        var i = 2\n        while (i <= n) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n            i += 1\n        }\n        var prime = new Array[Boolean](fib(n.toInt)\
    \ + 1)\n        i = 2\n        while (i <= fib(n.toInt)) {\n            prime(i)\
    \ = true\n            i += 1\n        }\n        i = 2\n        while (i <= fib(n.toInt))\
    \ {\n            if (prime(i)) {\n                var j = i * 2\n            \
    \    while (j <= fib(n.toInt)) {\n                    prime(j) = false\n     \
    \               j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = 0\n        while (i <= n) {\n            if (prime(fib(i.toInt)))\
    \ {\n                return fib(i.toInt)\n            }\n            i += 1\n\
    \        }\n        return 0", "        var i = 1l\n        var j = 2l\n     \
    \   var k = 3l\n        var count = 1l\n        while (count < n) {\n        \
    \    if (isPrime(k)) {\n                count += 1\n            }\n          \
    \  i = j\n            j = k\n            k = i + j\n        }\n        return\
    \ k", "        val primes = new PrimeSet(1000000)\n        var a = 2l\n      \
    \  var b = 3l\n        var c = 5l\n        var i = 5l\n        while (i < n) {\n\
    \            a = b\n            b = c\n            c = a + b\n            i +=\
    \ 1\n        }\n        return c", "        var i = 1l\n        var j = 2l\n \
    \       var k = 3l\n        var count = 2l\n        while (count < n) {\n    \
    \        i = j\n            j = k\n            k = i + j\n            if (isPrime(k))\
    \ count += 1\n        }\n        return k", "        var a = 2l;\n        var\
    \ b = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n\
    \            a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        var a = 2l;\n        var b\
    \ = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n \
    \           a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 1l\n        var result = 0l\n\
    \        while (i <= n) {\n            val f = fib.next\n            if (primes.contains(f))\
    \ {\n                result = f\n                i += 1\n            }\n     \
    \   }\n        result", "        var fib = new Fibonacci()\n        var i = 0l\n\
    \        var f = 0l\n        while (i < n) {\n            f = fib.next\n     \
    \       if (f.isPrime) i += 1\n        }\n        return f", "        var fib\
    \ = new Fibonacci()\n        var i = 0l\n        var p = 0l\n        while (i\
    \ < n) {\n            p = fib.next\n            if (p.isPrime) i += 1\n      \
    \  }\n        return p", "        val primes = new PrimeSet(1000000)\n       \
    \ var fib = new Fibonacci()\n        var i = 1l\n        while (i < n) {\n   \
    \         fib.next\n            while (!primes.contains(fib.current)) fib.next\n\
    \            i += 1\n        }\n        fib.current", "        def primeFib(n\
    \ : Long, a : Long, b : Long, i : Long) : Long = {\n            if (i == n) b\n\
    \            else {\n                val c = a + b\n                if (c.isPrime)\
    \ primeFib(n, b, c, i + 1)\n                else primeFib(n, b, c, i)\n      \
    \      }\n        }\n        primeFib(n, 1, 2, 1)", "        def primeFibRec(n\
    \ : Long, a : Long, b : Long, count : Long) : Long = {\n            if (count\
    \ == n) b\n            else if (isPrime(b)) primeFibRec(n, b, a + b, count + 1)\n\
    \            else primeFibRec(n, b, a + b, count)\n        }\n        primeFibRec(n,\
    \ 1, 2, 1)", "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n\
    \        var i = 3l;\n        while (i < n) {\n            a = b;\n          \
    \  b = c;\n            c = a + b;\n            i = i + 1;\n        }\n       \
    \ return c;", "        var fib = new Fibonacci()\n        var i = 1l\n       \
    \ var p = fib.next\n        while (i < n) {\n            p = fib.next\n      \
    \      if (p.isPrime) i += 1\n        }\n        return p", "        var a = 2l;\n\
    \        var b = 3l;\n        var c = 5l;\n        var count = 3l;\n        while\
    \ (count < n) {\n            a = b;\n            b = c;\n            c = a + b;\n\
    \            if (c.isPrime) {\n                count += 1;\n            }\n  \
    \      }\n        return c;", "        var fibs = new ArrayBuffer[Long]();\n \
    \       fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i <\
    \ n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        return fibs(n.toInt - 1);", "        val primes = new PrimeSet(1000000)\n\
    \        var a = 2l\n        var b = 3l\n        var c = 5l\n        var i = 2l\n\
    \        while (i < n) {\n            a = b\n            b = c\n            c\
    \ = a + b\n            i += 1\n        }\n        return c", "        def primeFib(n\
    \ : Long, a : Long, b : Long, count : Long) : Long = {\n            if (count\
    \ == n) b\n            else {\n                val c = a + b\n               \
    \ if (Library.isPrime(c)) primeFib(n, b, c, count + 1)\n                else primeFib(n,\
    \ b, c, count)\n            }\n        }\n        primeFib(n, 1, 2, 1)", "   \
    \     def primeFib(n : Long, a : Long, b : Long, i : Long) : Long = {\n      \
    \      if (i == n) b\n            else if (isPrime(b)) primeFib(n, b, a + b, i\
    \ + 1)\n            else primeFib(n, b, a + b, i)\n        }\n        primeFib(n,\
    \ 1, 2, 1)", "        var i = 1l\n        var j = 1l\n        var k = 0l\n   \
    \     var count = 0l\n        while (count < n) {\n            k = i + j\n   \
    \         i = j\n            j = k\n            if (isPrime(k)) count += 1\n \
    \       }\n        return k", "        val primes = new PrimeSet(1000000)\n  \
    \      var i = 0l\n        var f = 1l\n        var f1 = 1l\n        var f2 = 1l\n\
    \        while (i < n) {\n            f = f1 + f2\n            if (primes.isPrime(f))\
    \ i += 1\n            f2 = f1\n            f1 = f\n        }\n        return f",
  "        var i = 1l\n        var j = 1l\n        var k = 0l\n        var c = 0l\n\
    \        while (c < n) {\n            k = i + j\n            if (k.isPrime) {\n\
    \                c += 1\n            }\n            i = j\n            j = k\n\
    \        }\n        return k", "        def primeFib(n : Long, a : Long, b : Long,\
    \ c : Long) : Long = {\n            if (n == 1) b\n            else if (n == 2)\
    \ c\n            else {\n                val d = a + b + c\n                if\
    \ (isPrime(d)) primeFib(n - 1, b, c, d)\n                else primeFib(n, b, c,\
    \ d)\n            }\n        }\n        primeFib(n, 2, 3, 5)", "        var a\
    \ = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 3l;\n     \
    \   while (i < n) {\n            a = b;\n            b = c;\n            c = a\
    \ + b;\n            i = i + 1;\n        }\n        return c;", "        val primes\
    \ = new PrimeSet(1000000)\n        var fib = new Fibonacci(1000000)\n        var\
    \ i = 0l\n        var result = 0l\n        while (i < n) {\n            result\
    \ = fib.next\n            if (primes.contains(result)) i += 1\n        }\n   \
    \     return result", "        var fibs = new ListBuffer[Long]();\n        fibs\
    \ += 1l;\n        fibs += 2l;\n        var i = 2l;\n        while (i < n) {\n\
    \            fibs += fibs(i.toInt - 1) + fibs(i.toInt - 2);\n            i +=\
    \ 1l;\n        }\n        var j = n - 1l;\n        while (j >= 0l) {\n       \
    \     if (isPrime(fibs(j.toInt))) return fibs(j.toInt);\n            j -= 1l;\n\
    \        }\n        return 0l;", "        val primes = new PrimeSet(1000000)\n\
    \        val fibs = new FibonacciSet(1000000)\n        var i = 1l\n        var\
    \ j = 1l\n        var k = 0l\n        while (k < n) {\n            if (primes.contains(fibs(i)))\
    \ {\n                k += 1\n                j = fibs(i)\n            }\n    \
    \        i += 1\n        }\n        j", "        var f = new Array[Long](n.toInt\
    \ + 1)\n        f(0) = 0\n        f(1) = 1\n        f(2) = 2\n        var i =\
    \ 3\n        while (i <= n) {\n            f(i) = f(i - 1) + f(i - 2)\n      \
    \      i += 1\n        }\n        return f(n.toInt)", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        return fib(n.toInt)", "        val primes = new PrimeSet(1000000)\n\
    \        var fib = new Fibonacci()\n        var i = 0l\n        var p = 0l\n \
    \       while (i < n) {\n            p = fib.next\n            if (primes.contains(p))\
    \ i += 1\n        }\n        return p", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i <= n) {\n            val fib = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n \
    \           if (isPrime(fib)) {\n                fibs += fib;\n              \
    \  i += 1l;\n            }\n        }\n        return fibs(n.toInt - 1);", " \
    \       val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j\
    \ = 1l\n        var k = 2l\n        var count = 1l\n        while (count < n)\
    \ {\n            i = j\n            j = k\n            k = i + j\n           \
    \ if (primes.contains(k)) count += 1\n        }\n        k", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        var j = n.toInt\n        while\
    \ (j >= 0) {\n            if (isPrime(fib(j))) return fib(j)\n            j -=\
    \ 1\n        }\n        return 0", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        var prime = new Array[Boolean](fib(n.toInt) + 1)\n       \
    \ i = 2\n        while (i <= fib(n.toInt)) {\n            prime(i) = true\n  \
    \          i += 1\n        }\n        i = 2\n        while (i <= fib(n.toInt))\
    \ {\n            if (prime(i)) {\n                var j = i * 2\n            \
    \    while (j <= fib(n.toInt)) {\n                    prime(j) = false\n     \
    \               j += i\n                }\n            }\n            i += 1\n\
    \        }\n        i = 0\n        while (i <= n) {\n            if (prime(fib(i).toInt))\
    \ {\n                return fib(i)\n            }\n            i += 1\n      \
    \  }\n        return 0", "        val primes = new PrimeSet(1000000)\n       \
    \ var fib = new Fibonacci(1000000)\n        var count = 0l\n        var result\
    \ = 0l\n        while (count < n) {\n            result = fib.next\n         \
    \   if (primes.contains(result)) count += 1\n        }\n        result", "   \
    \     var fib = new Fibonacci()\n        var i = 0l\n        var result = 0l\n\
    \        while (i < n) {\n            result = fib.next\n            if (isPrime(result))\
    \ i += 1\n        }\n        return result", "        def primeFib(n : Long, a\
    \ : Long, b : Long, count : Long) : Long = {\n            if (count == n) b\n\
    \            else {\n                val c = a + b\n                if (isPrime(c))\
    \ primeFib(n, b, c, count + 1)\n                else primeFib(n, b, c, count)\n\
    \            }\n        }\n        primeFib(n, 1, 2, 1)", "        var i = 0l\n\
    \        var j = 1l\n        var k = 1l\n        var l = 0l\n        while (l\
    \ < n) {\n            if (isPrime(k)) {\n                l += 1\n            }\n\
    \            val m = i + j\n            i = j\n            j = k\n           \
    \ k = m\n        }\n        k", "        var a = 2l;\n        var b = 3l;\n  \
    \      var c = 5l;\n        var i = 3l;\n        while (i < n) {\n           \
    \ a = b;\n            b = c;\n            c = a + b;\n            i = i + 1;\n\
    \        }\n        return c;", "        var count = 0l\n        var i = 1l\n\
    \        while (count < n) {\n            if (isPrime(fib(i))) count += 1\n  \
    \          i += 1\n        }\n        fib(i - 1)", "        var i = 1l\n     \
    \   var j = 1l\n        var k = 2l\n        var count = 0l\n        while (count\
    \ < n) {\n            if (isPrime(k)) {\n                count += 1\n        \
    \        if (count == n) return k\n            }\n            i = j\n        \
    \    j = k\n            k = i + j\n        }\n        return 0", "        val\
    \ primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n        var\
    \ i = 0l\n        var result = 0l\n        while (i < n) {\n            val x\
    \ = fib.next\n            if (primes.contains(x)) {\n                i += 1\n\
    \                result = x\n            }\n        }\n        return result",
  "        def primeFib0(n : Long, a : Long, b : Long, i : Long) : Long = {\n    \
    \        if (i == n) b\n            else {\n                val c = a + b\n  \
    \              if (isPrime(c)) primeFib0(n, b, c, i + 1)\n                else\
    \ primeFib0(n, b, c, i)\n            }\n        }\n        primeFib0(n, 0, 1,\
    \ 1)", "        def primeFib(n : Long, a : Long, b : Long, c : Long) : Long =\
    \ {\n            if (n == 1) {\n                a\n            } else if (n ==\
    \ 2) {\n                b\n            } else {\n                val d = a + b\n\
    \                if (d.isPrime) {\n                    primeFib(n - 1, b, c, d)\n\
    \                } else {\n                    primeFib(n, b, c, d)\n        \
    \        }\n            }\n        }\n        primeFib(n, 2, 3, 5)", "       \
    \ val primes = new PrimeSet(1000000)\n        var i = 1l\n        var j = 1l\n\
    \        var k = 2l\n        var count = 0l\n        while (count < n) {\n   \
    \         if (primes.contains(k)) count += 1\n            val t = i + j\n    \
    \        i = j\n            j = k\n            k = t\n        }\n        k", " \
    \       var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs\
    \ += 3;\n        var i = 2;\n        while (i <= n) {\n            var fib = fibs(i\
    \ - 1) + fibs(i - 2);\n            if (fib.isPrime) {\n                fibs +=\
    \ fib;\n                i += 1;\n            }\n        }\n        return fibs(n.toInt\
    \ - 1);", "        def primeFib(n : Long, a : Long, b : Long, i : Long) : Long\
    \ = {\n            if (i == n) b\n            else if (isPrime(b)) primeFib(n,\
    \ b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n        }\n   \
    \     primeFib(n, 2, 3, 1)", "        def primeFib(n : Long, a : Long, b : Long,\
    \ i : Long) : Long = {\n            if (i == n) b\n            else if (isPrime(b))\
    \ primeFib(n, b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n  \
    \      }\n        primeFib(n, 1, 2, 1)", "        var i = 1l\n        var j =\
    \ 1l\n        var k = 1l\n        var count = 0l\n        while (count < n) {\n\
    \            k = i + j\n            if (isPrime(k)) {\n                count +=\
    \ 1\n            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var a = 2l;\n        var b = 3l;\n        var c = 5l;\n       \
    \ var i = 3l;\n        while (i < n) {\n            a = b;\n            b = c;\n\
    \            c = a + b;\n            i = i + 1;\n        }\n        return c;",
  "        def primeFib(n : Long, a : Long, b : Long, count : Long) : Long = {\n \
    \           if (count == n) b\n            else if (isPrime(b)) primeFib(n, b,\
    \ a + b, count + 1)\n            else primeFib(n, b, a + b, count)\n        }\n\
    \        primeFib(n, 2, 3, 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 1l\n        var c = 0l\n\
    \        while (c < n) {\n            val t = i + j\n            if (primes.isPrime(t))\
    \ {\n                k = t\n                c += 1\n            }\n          \
    \  i = j\n            j = t\n        }\n        k", "        var i = 1l\n    \
    \    var j = 1l\n        var k = 1l\n        var count = 0l\n        while (count\
    \ < n) {\n            k = i + j\n            if (isPrime(k)) count += 1\n    \
    \        i = j\n            j = k\n        }\n        return k", "        var\
    \ a = 2l;\n        var b = 3l;\n        var c = 5l;\n        var i = 2l;\n   \
    \     while (i < n) {\n            a = b;\n            b = c;\n            c =\
    \ a + b;\n            i = i + 1;\n        }\n        return c;", "        val\
    \ fibs = new ArrayBuffer[Long]();\n        fibs += 1l;\n        fibs += 2l;\n\
    \        var i = 2l;\n        while (i < n) {\n            fibs += fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            i += 1l;\n        }\n        var j =\
    \ n - 1l;\n        while (j >= 0l) {\n            if (isPrime(fibs(j.toInt)))\
    \ {\n                return fibs(j.toInt);\n            }\n            j -= 1l;\n\
    \        }\n        return -1l;", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 1l\n        var j = 1l\n        var k = 2l\n        var count\
    \ = 0l\n        while (count < n) {\n            if (primes.contains(k)) {\n \
    \               count += 1\n            }\n            val t = k\n           \
    \ k = i + j\n            i = j\n            j = t\n        }\n        k", "  \
    \      var fibs = new ArrayBuffer[Long]();\n        fibs += 2l;\n        fibs\
    \ += 3l;\n        var i = 2l;\n        while (i < n) {\n            fibs += fibs(i.toInt\
    \ - 1) + fibs(i.toInt - 2);\n            i += 1l;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        def primeFib(n : Long, a : Long, b : Long, i : Long) : Long\
    \ = {\n            if (i == n) b\n            else {\n                val c =\
    \ a + b\n                if (isPrime(c)) primeFib(n, b, c, i + 1)\n          \
    \      else primeFib(n, b, c, i)\n            }\n        }\n        primeFib(n,\
    \ 0, 1, 1)", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n\
    \        fibs += 3;\n        var i = 2;\n        var p = 5;\n        while(i <=\
    \ n) {\n            if(isPrime(p)) {\n                fibs += p;\n           \
    \     i += 1;\n            }\n            p += 2;\n        }\n        fibs(n.toInt\
    \ - 1);", "        var fib = new Array[Long](n.toInt)\n        fib(0) = 2\n  \
    \      fib(1) = 3\n        var i = 2\n        while (i < n) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt\
    \ - 1)", "        def primeFib0(n : Long, a : Long, b : Long, i : Long) : Long\
    \ = {\n            if (i == n) b\n            else if (isPrime(b)) primeFib0(n,\
    \ b, a + b, i + 1)\n            else primeFib0(n, b, a + b, i)\n        }\n  \
    \      primeFib0(n, 2, 3, 1)", "        def primeFib(n : Long, a : Long, b : Long,\
    \ c : Long) : Long = {\n            if (n == 1) {\n                b\n       \
    \     } else {\n                if (isPrime(c)) {\n                    primeFib(n\
    \ - 1, b, c, a + b)\n                } else {\n                    primeFib(n,\
    \ b, c, a + b)\n                }\n            }\n        }\n        primeFib(n,\
    \ 0, 2, 3)", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 2;\n\
    \        fibs += 3;\n        var i = 2;\n        while (i <= n) {\n          \
    \  val f = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(f)) {\n       \
    \         fibs += f;\n                i += 1;\n            }\n        }\n    \
    \    return fibs(n.toInt - 1);", "        def primeFib(n : Long, a : Long, b :\
    \ Long, i : Long) : Long = {\n            if (i == n) b\n            else if (isPrime(b))\
    \ primeFib(n, b, a + b, i + 1)\n            else primeFib(n, b, a + b, i)\n  \
    \      }\n        primeFib(n, 1, 2, 1)", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 1\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        var p = new Array[Boolean](fib(n.toInt) + 1)\n        i =\
    \ 2\n        while (i < p.length) {\n            p(i) = true\n            i +=\
    \ 1\n        }\n        i = 2\n        while (i < p.length) {\n            if\
    \ (p(i)) {\n                var j = i + i\n                while (j < p.length)\
    \ {\n                    p(j) = false\n                    j += i\n          \
    \      }\n            }\n            i += 1\n        }\n        i = 0\n      \
    \  while (i <= n) {\n            if (p(fib(i).toInt)) {\n                return\
    \ fib(i)\n            }\n            i += 1\n        }\n        return 0", " \
    \       var count = 0l\n        var i = 1l\n        var fib = 0l\n        while\
    \ (count < n) {\n            fib = fibonacci(i)\n            if (isPrime(fib))\
    \ count += 1\n            i += 1\n        }\n        return fib", "        var\
    \ fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n\
    \        fib(2) = 2\n        var i = 3\n        while (i <= n) {\n           \
    \ fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        var\
    \ result = fib(n.toInt)\n        while (!isPrime(result)) {\n            n +=\
    \ 1\n            result = fib(n.toInt)\n        }\n        return result", " \
    \       val primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n\
    \        var i = 0l\n        var p = 0l\n        while (i < n) {\n           \
    \ p = fib.next\n            if (primes.contains(p)) i += 1\n        }\n      \
    \  return p", "        var i = 1l\n        var j = 2l\n        var k = 3l\n  \
    \      var c = 0l\n        while (c < n) {\n            if (isPrime(k)) {\n  \
    \              c += 1\n            }\n            val t = k\n            k = i\
    \ + j\n            i = j\n            j = t\n        }\n        return k", " \
    \       var i = 1l\n        var j = 1l\n        var k = 1l\n        var c = 1l\n\
    \        while (c < n) {\n            k = i + j\n            if (BigInt(k).isProbablePrime(10))\
    \ c += 1\n            i = j\n            j = k\n        }\n        return k",
  "        var i = 1l\n        var j = 1l\n        var k = 0l\n        var count =\
    \ 0l\n        while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var fib = new Fibonacci()\n \
    \       var i = 0l\n        var p = 0l\n        while (i < n) {\n            p\
    \ = fib.next\n            if (p.isPrime) i += 1\n        }\n        return p",
  "        var i = 1l\n        var j = 1l\n        var k = 1l\n        var count =\
    \ 1l\n        while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var i = 1l\n        var j = 1l\n\
    \        var k = 1l\n        var count = 0l\n        while (count < n) {\n   \
    \         k = i + j\n            if (isPrime(k)) {\n                count += 1\n\
    \            }\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var f1 : Long = 2\n        var f2 : Long = 3\n        var i : Long\
    \ = 2\n        while (i < n) {\n            val f3 : Long = f1 + f2\n        \
    \    f1 = f2\n            f2 = f3\n            if (f1.isPrime) {\n           \
    \     i += 1\n            }\n        }\n        return f1", "        var fib =\
    \ new Fibonacci()\n        var i = 0l\n        var result = 0l\n        while\
    \ (i < n) {\n            result = fib.next\n            if (isPrime(result)) i\
    \ += 1\n        }\n        return result", "        var a = 2l;\n        var b\
    \ = 3l;\n        var c = 5l;\n        var i = 3l;\n        while (i < n) {\n \
    \           a = b;\n            b = c;\n            c = a + b;\n            i\
    \ = i + 1;\n        }\n        return c;", "        var i = 1l\n        var j\
    \ = 1l\n        var k = 1l\n        var count = 0l\n        while (count < n)\
    \ {\n            k = i + j\n            if (isPrime(k)) {\n                count\
    \ += 1\n            }\n            i = j\n            j = k\n        }\n     \
    \   return k"]
stop_tokens:
- "\n    }\n"
