name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        def primeFibRec(n : Long, a : Long, b : Long, i : Long) : Long\
    \ = {\n            if (i == n) b\n            else {\n                val c =\
    \ a + b\n                if (isPrime(c)) primeFibRec(n, b, c, i + 1)\n       \
    \         else primeFibRec(n, b, c, i)\n            }\n        }\n        primeFibRec(n,\
    \ 1, 2, 1)", "        var i = 0l\n        var j = 1l\n        var k = 0l\n   \
    \     var count = 0l\n        while (count < n) {\n            k = i + j\n   \
    \         if (isPrime(k)) {\n                count += 1\n            }\n     \
    \       i = j\n            j = k\n        }\n        return k", "        var i\
    \ = 1l\n        var j = 1l\n        var k = 1l\n        var count = 1l\n     \
    \   while (count < n) {\n            k = i + j\n            if (isPrime(k)) count\
    \ += 1\n            i = j\n            j = k\n        }\n        k", "       \
    \ def primeFib(n : Long, a : Long, b : Long, c : Long) : Long = {\n          \
    \  if (n == 1) a\n            else if (n == 2) b\n            else if (n == 3)\
    \ c\n            else if (isPrime(c)) primeFib(n - 1, b, c, a + b + c)\n     \
    \       else primeFib(n, a, b, c + a + b)\n        }\n        primeFib(n, 2, 3,\
    \ 5)", "        var i = 1l\n        var j = 1l\n        var k = 2l\n        var\
    \ count = 0l\n        while (count < n) {\n            if (isPrime(k)) count +=\
    \ 1\n            val t = i + j\n            i = j\n            j = k\n       \
    \     k = t\n        }\n        return k", "        var i = 0l\n        var j\
    \ = 1l\n        var k = 0l\n        var count = 0l\n        while (count < n)\
    \ {\n            k = i + j\n            i = j\n            j = k\n           \
    \ if (k.isPrime) count += 1\n        }\n        return k", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 2;\n        fibs += 3;\n        var\
    \ i = 2;\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2);\n            i += 1;\n        }\n        return fibs(n.toInt - 1);", " \
    \       val primes = new PrimeSet(1000000)\n        var fib = new Fibonacci()\n\
    \        var i = 0l\n        var p = 0l\n        while (i < n) {\n           \
    \ p = fib.next\n            if (primes.contains(p)) i += 1\n        }\n      \
    \  return p", "        val primes = new PrimeSet(1000000)\n        var i = 1l\n\
    \        var j = 1l\n        var k = 1l\n        var count = 0l\n        while\
    \ (count < n) {\n            k = i + j\n            if (primes.isPrime(k)) count\
    \ += 1\n            i = j\n            j = k\n        }\n        k", "       \
    \ var i = 1l\n        var f = 1l\n        var f1 = 1l\n        var f2 = 2l\n \
    \       var p = 2l\n        while (i < n) {\n            f = f1 + f2\n       \
    \     f1 = f2\n            f2 = f\n            if (f.isPrime) {\n            \
    \    p = f\n                i += 1\n            }\n        }\n        return p",
  "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        fib(2) = 2\n        var i = 3\n        while (i <= n) {\n     \
    \       fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n    \
    \    var p = 2\n        var j = 1\n        while (j < n) {\n            p += 1\n\
    \            while (!isPrime(p)) {\n                p += 1\n            }\n  \
    \          if (fib.contains(p)) {\n                j += 1\n            }\n   \
    \     }\n        p", "        var i = 1l\n        var j = 1l\n        var k =\
    \ 1l\n        var count = 0l\n        while (count < n) {\n            k = i +\
    \ j\n            if (isPrime(k)) {\n                count += 1\n            }\n\
    \            i = j\n            j = k\n        }\n        return k", "       \
    \ var f1 : Long = 2l\n        var f2 : Long = 3l\n        var f3 : Long = 5l\n\
    \        var c : Long = 3l\n        while (c < n) {\n            f1 = f2\n   \
    \         f2 = f3\n            f3 = f1 + f2\n            if (f3.isPrime) {\n \
    \               c += 1\n            }\n        }\n        return f3", "      \
    \  var fib = new Fibonacci()\n        var i = 1l\n        var result = 0l\n  \
    \      while (i <= n) {\n            result = fib.next\n            if (result.isPrime)\
    \ i += 1\n        }\n        return result", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2l;\n        fibs += 3l;\n        var i = 2l;\n        while\
    \ (i <= n) {\n            var fib = fibs(i.toInt - 1) + fibs(i.toInt - 2);\n \
    \           if (isPrime(fib)) {\n                fibs += fib;\n              \
    \  i += 1l;\n            }\n        }\n        return fibs(n.toInt - 1);", " \
    \       var i = 1l\n        var fib = 1l\n        var fib1 = 1l\n        var fib2\
    \ = 1l\n        while (i < n) {\n            fib = fib1 + fib2\n            fib2\
    \ = fib1\n            fib1 = fib\n            if (fib.isPrime) i += 1\n      \
    \  }\n        return fib", "        val primes = new PrimeSet(1000000)\n     \
    \   var fib = new Fibonacci()\n        var i = 0l\n        var result = 0l\n \
    \       while (i < n) {\n            result = fib.next\n            if (primes.contains(result))\
    \ i += 1\n        }\n        return result", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 2;\n        fibs += 3;\n        var i = 2;\n        while (i\
    \ <= n) {\n            val fib = fibs(i - 1) + fibs(i - 2);\n            if (isPrime(fib))\
    \ {\n                fibs += fib;\n                i += 1;\n            }\n  \
    \      }\n        return fibs(n.toInt - 1);", "        def primeFib(n : Long,\
    \ fib : Long, fib_1 : Long, fib_2 : Long, count : Long) : Long = {\n         \
    \   if (count == n) fib\n            else {\n                val fib_next = fib_1\
    \ + fib_2\n                if (isPrime(fib_next)) primeFib(n, fib_next, fib, fib_1,\
    \ count + 1)\n                else primeFib(n, fib, fib_1, fib_next, count)\n\
    \            }\n        }\n        primeFib(n, 2, 3, 1, 1)", "        var i =\
    \ 1l\n        var j = 1l\n        var k = 1l\n        var count = 0l\n       \
    \ while (count < n) {\n            k = i + j\n            if (k.isPrime) {\n \
    \               count += 1\n            }\n            i = j\n            j =\
    \ k\n        }\n        return k"]
stop_tokens:
- "\n    }\n"
