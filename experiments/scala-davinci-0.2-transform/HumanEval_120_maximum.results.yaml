language: scala
name: HumanEval_120_maximum
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x < y)\n        for (i <- 0 until k.toInt) heap.insert(arr(i))\n\
    \        for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.peek)\
    \ {\n                heap.remove()\n                heap.insert(arr(i))\n    \
    \        }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpufl3b6y3.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.remove()\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bdz6clc.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ in arr.\n        // As we iterate through arr, we will add elements to the heap.\n\
    \        // If the heap size is greater than k, we will remove the smallest element.\n\
    \        // This will ensure that the heap always contains the k largest elements.\n\
    \        // At the end, we will return the heap as a sorted list.\n        //\
    \ Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n        val\
    \ heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n       \
    \     heap.enqueue(x)\n            if (heap.size > k) heap.dequeue\n        }\n\
    \        heap.toList.sorted\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdfyr4mdk.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        return\
    \ arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxhr9ud7_.scala:24)\n\tat Problem.main(tmpxhr9ud7_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We will use a heap to store\
    \ the maximum k numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm7grik6g.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We will use a heap to store the maximum k numbers.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// We will use a min-heap to store the negative numbers, and a\
    \ max-heap to store the positive numbers.\e[0m\n\e[31m23 |\e[0m        \e[34m//\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\e[0m\n\e[31m24 |\e[0m        \e[34m// We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We will use a min-heap to store the negative numbers, and a\
    \ max-heap to store the positive numbers.\e[0m\n\e[31m27 |\e[0m        \e[34m//\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\e[0m\n\e[31m28 |\e[0m        \e[34m// We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// We will use a min-heap to store the negative numbers, and a\
    \ max-heap to store the positive numbers.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\e[0"
  stdout: ''
  timestamp: 1659793573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // Sort the array in descending order\n        // Return the first k\
    \ elements\n        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8a8jwdg2.scala:26)\n\tat Problem.main(tmp8a8jwdg2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The heap will have size k.\n        // We will\
    \ iterate through the array, and add each element to the heap.\n        // If\
    \ the heap is full, we will remove the largest element from the heap.\n      \
    \  // After iterating through the array, we will have the k largest elements.\n\
    \        // We will then return the heap in reverse order.\n        // Time complexity:\
    \ O(n log k)\n        // Space complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (element <- arr) {\n            if (heap.size < k) {\n          \
    \      heap.enqueue(element)\n            } else {\n                if (element\
    \ > heap.head) {\n                    heap.dequeue\n                    heap.enqueue(element)\n\
    \                }\n            }\n        }\n        heap.toList.reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx9iplrwl.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x < y)\n        for (i <- arr) {\n            heap.push(i)\n\
    \            if (heap.size > k) heap.pop\n        }\n        heap.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe5b_cewt.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will contain the largest k elements\
    \ in the array.\n        // We will iterate through the array and add each element\
    \ to the max heap.\n        // If the max heap is larger than k, we will remove\
    \ the largest element from the max heap.\n        // Once we have iterated through\
    \ the entire array, we will return the max heap.\n        // The max heap will\
    \ be sorted in descending order.\n        // Time Complexity: O(n log k)\n   \
    \     // Space Complexity: O(k)\n        val maxHeap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            maxHeap.enqueue(x)\n            if (maxHeap.size\
    \ > k) {\n                maxHeap.dequeue()\n            }\n        }\n      \
    \  maxHeap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt7uvx5iw.scala:41)\n\tat Problem.main(tmpt7uvx5iw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            temp = arr(i) :: temp\n\
    \            temp = temp.sorted\n            if (temp.length > k) {\n        \
    \        temp = temp.dropRight(1)\n            }\n        }\n        result =\
    \ temp.sorted\n        result = result.reverse\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqm9q1i5h.scala:35)\n\tat Problem.main(tmpqm9q1i5h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        return\
    \ List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk169t_rv.scala:24)\n\tat Problem.main(tmpk169t_rv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // The idea is to use a min\
    \ heap to store the k largest elements.\n        // The heap is initialized with\
    \ the first k elements of the array.\n        // Then we iterate through the remaining\
    \ elements of the array.\n        // If the current element is greater than the\
    \ minimum element in the heap,\n        // we remove the minimum element from\
    \ the heap and add the current element to the heap.\n        // In the end, the\
    \ heap will contain the k largest elements.\n        // The time complexity is\
    \ O(nlogk) where n is the length of the array.\n        // The space complexity\
    \ is O(k).\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n  \
    \      for (i <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzd6cnckn.scala:42)\n\tat Problem.main(tmpzd6cnckn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will contain the k largest elements in the\
    \ array.\n        // We will iterate through the array and add each element to\
    \ the heap.\n        // If the heap is full, we will remove the smallest element\
    \ from the heap.\n        // If the heap is not full, we will add the element\
    \ to the heap.\n        // After we have iterated through the array, the heap\
    \ will contain the k largest elements.\n        // We will then sort the heap\
    \ and return it.\n        // Time complexity: O(n log k)\n        // Space complexity:\
    \ O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n        for (x <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(x)\n            else if\
    \ (x > heap.head) {\n                heap.dequeue\n                heap.enqueue(x)\n\
    \            }\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_5858zbk.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the k largest elements.\n    \
    \    // If the heap has less than k elements, we add the current element to the\
    \ heap.\n        // If the heap has k elements, we compare the current element\
    \ with the minimum element in the heap.\n        // If the current element is\
    \ greater than the minimum element in the heap, we remove the minimum element\
    \ from the heap and add the current element to the heap.\n        // If the current\
    \ element is less than the minimum element in the heap, we do nothing.\n     \
    \   // After we have processed all the elements in the array, we return the elements\
    \ in the heap.\n        // The time complexity of this algorithm is O(n log k).\n\
    \        // The space complexity of this algorithm is O(k).\n        val heap\
    \ = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- arr) {\n\
    \            if (heap.size < k) heap.enqueue(i)\n            else if (i > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(i)\n         \
    \   }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ewqbzrx.scala:43)\n\tat Problem.main(tmp4ewqbzrx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // The priority queue will contain the k largest\
    \ elements.\n        // We can then sort the priority queue and return the result.\n\
    \        // The time complexity of this algorithm is O(n log k) and the space\
    \ complexity is O(k).\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            pq.enqueue(x)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min-heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements.\n\
    \        // If we encounter an element that is larger than the minimum element\
    \ in the heap,\n        // we remove the minimum element and add the new element.\n\
    \        // This will ensure that the heap contains the k largest elements.\n\
    \        // The time complexity is O(n log k) and the space complexity is O(k).\n\
    \        val heap = new scala.collection.mutable.PriorityQueue[Long]()\n     \
    \   for (x <- arr) {\n            if (heap.size < k) heap.enqueue(x)\n       \
    \     else if (x > heap.head) {\n                heap.dequeue\n              \
    \  heap.enqueue(x)\n            }\n        }\n        heap.toList.sorted\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzkgwn6lp.scala:38)\n\tat Problem.main(tmpzkgwn6lp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a min-heap.\n        // The heap\
    \ will contain the k largest elements.\n        // We will iterate through the\
    \ array and add each element to the heap.\n        // If the heap is full, we\
    \ will remove the smallest element in the heap.\n        // After we have iterated\
    \ through the array, we will return the heap.\n        // The heap will be sorted\
    \ in ascending order.\n        // We will reverse the heap to get the descending\
    \ order.\n        // We will return the heap.\n        // Time Complexity: O(n\
    \ log k)\n        // Space Complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpup92yngr.scala:31:23 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var result = List[Long]()\n        var max = -1001l\n        var maxIndex\
    \ = -1\n        for (i <- 0 until k.toInt) {\n            for (j <- 0 until arr.length)\
    \ {\n                if (arr(j) > max) {\n                    max = arr(j)\n \
    \                   maxIndex = j\n                }\n            }\n         \
    \   result = result :+ max\n            arr = arr.patch(maxIndex, Nil, 1)\n  \
    \          max = -1001l\n            maxIndex = -1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwz4m1nxd.scala:37:16 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            arr = arr.patch(maxIndex, Nil, \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793575
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min-heap to\
    \ solve this problem.\n        // The idea is to keep the heap size at k, and\
    \ if the next element is greater than the minimum\n        // element in the heap,\
    \ we remove the minimum element and add the next element to the heap.\n      \
    \  // This way, we will always have the k largest elements in the heap.\n    \
    \    // We can use a min-heap to solve this problem.\n        // The idea is to\
    \ keep the heap size at k, and if the next element is greater than the minimum\n\
    \        // element in the heap, we remove the minimum element and add the next\
    \ element to the heap.\n        // This way, we will always have the k largest\
    \ elements in the heap.\n        val heap = new PriorityQueue[Long]()(Ordering.by((_\
    \ : Long) * -1))\n        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n\
    \            else if (i > heap.head) {\n                heap.dequeue\n       \
    \         heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: queue is empty\n\tat scala.collection.mutable.PriorityQueue.head(PriorityQueue.scala:254)\n\
    \tat Problem$.maximum$$anonfun$1(tmpbw4aoavg.scala:31)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.maximum(tmpbw4aoavg.scala:35)\n\
    \tat Problem$.main(tmpbw4aoavg.scala:49)\n\tat Problem.main(tmpbw4aoavg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be of size k.\n        // We will add\
    \ the first k elements to the heap.\n        // For each element after the first\
    \ k elements, we will compare it to the minimum element in the heap.\n       \
    \ // If the element is greater than the minimum element, we will remove the minimum\
    \ element and add the new element.\n        // We will continue this process until\
    \ we have processed all elements.\n        // Then we will return the heap.\n\
    \        // The time complexity is O(n log k) and the space complexity is O(k).\n\
    \        val heap = new mutable.PriorityQueue[Long]()\n        for (i <- 0 until\
    \ k.toInt) {\n            heap.enqueue(arr(i))\n        }\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList.sorted\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4c7icx2z.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var maxIndex : Int = 0\n \
    \       for (i <- 0 to k.toInt - 1) {\n            max = arr(0)\n            maxIndex\
    \ = 0\n            for (j <- 0 to arr.length - 1) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr = arr.take(maxIndex) ++ arr.drop(maxIndex + 1)\n        }\n       \
    \ return result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmppjx7l_jh.scala:33:16 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            arr = arr.take(maxIndex) ++ arr.drop(maxIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var result\
    \ : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var index : Long = 0l\n        var max : Long = 0l\n        var maxIndex\
    \ : Long = 0l\n        for (i <- 0l until k) {\n            max = arr(i.toInt)\n\
    \            maxIndex = i\n            for (j <- i + 1l until arr.length) {\n\
    \                if (arr(j.toInt) > max) {\n                    max = arr(j.toInt)\n\
    \                    maxIndex = j\n                }\n            }\n        \
    \    temp = arr.updated(maxIndex.toInt, arr(i.toInt))\n            temp = temp.updated(i.toInt,\
    \ max)\n            arr = temp\n            result = result :+ max\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpbg1z15k1.scala:38:16 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            arr = temp\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the largest k elements in the\
    \ array.\n        // If the heap is full and the next element is larger than the\
    \ smallest element in the heap,\n        // then we remove the smallest element\
    \ and add the new element.\n        // The heap will be sorted in descending order.\n\
    \        // The heap will have a maximum size of k.\n        // We will use a\
    \ min-heap to store the elements.\n        // The heap will be sorted in ascending\
    \ order.\n        // The heap will have a maximum size of k.\n        // We will\
    \ use a max-heap to store the elements.\n        // The heap will be sorted in\
    \ descending order.\n        // The heap will have a maximum size of k.\n    \
    \    // We will use a min-heap to store the elements.\n        // The heap will\
    \ be sorted in ascending order.\n        // The heap will have a maximum size\
    \ of k.\n        // We will use a max-heap to store the elements.\n        //\
    \ The heap will be sorted in descending order.\n        // The heap will have\
    \ a maximum size of k.\n        // We will use a min-heap to store the elements.\n\
    \        // The heap will be sorted in ascending order.\n        // The heap will\
    \ have a maximum size of k.\n        // We will use a max-heap to store the elements.\n\
    \        // The heap will be sorted in descending order.\n        // The heap\
    \ will have a maximum size of k.\n        // We will use a min-heap to store the\
    \ elements.\n        // The heap will be sorted in ascending order.\n        //\
    \ The heap will have a maximum size of k.\n        // We will use a max-heap to\
    \ store the elements.\n        // The heap will be sorted in descending order.\n\
    \        // The heap will have a maximum size of k.\n        // We will use a\
    \ min-heap to store the elements.\n        // The heap will be sorted in ascending\
    \ order.\n        // The heap will have a maximum size of k.\n        // We will\
    \ use a max-heap to store the elements.\n        // The heap will be sorted in\
    \ descending order.\n        // The heap will have a maximum size of k.\n    \
    \    // We will use a min-heap to\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb7_nlsgj.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// The heap will store the largest k elements in the\
    \ array.\e[0m\n\e[31m22 |\e[0m        \e[34m// If the heap is full and the next\
    \ element is larger than the smallest element in the heap,\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// then we remove the smallest element and add the new element.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// The heap will be sorted in descending order.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// The heap will have a maximum size of k.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We will use a min-heap to store the elements.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// The heap will be sorted in ascending order.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// The heap will have a maximum size of k.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// We will use a max-heap to store the elements.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// The heap will be sorted in descending order.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// The heap will have a maximum size of k.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// We will use a min-heap to store the elements.\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// The heap will be sorted in ascending order.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// The heap will have a maximum size of k.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// We will use a max-heap to store the elements.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// The heap will be sorted in descending order.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// The heap will have a maximum size of k.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We will use a min-heap to store the elements.\e\
    [0m\n\e[31m39 |\e[0m   "
  stdout: ''
  timestamp: 1659793577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var temp2 : List[Long] = List[Long]()\n        var temp3 : List[Long]\
    \ = List[Long]()\n        var temp4 : List[Long] = List[Long]()\n        var temp5\
    \ : List[Long] = List[Long]()\n        var temp6 : List[Long] = List[Long]()\n\
    \        var temp7 : List[Long] = List[Long]()\n        var temp8 : List[Long]\
    \ = List[Long]()\n        var temp9 : List[Long] = List[Long]()\n        var temp10\
    \ : List[Long] = List[Long]()\n        var temp11 : List[Long] = List[Long]()\n\
    \        var temp12 : List[Long] = List[Long]()\n        var temp13 : List[Long]\
    \ = List[Long]()\n        var temp14 : List[Long] = List[Long]()\n        var\
    \ temp15 : List[Long] = List[Long]()\n        var temp16 : List[Long] = List[Long]()\n\
    \        var temp17 : List[Long] = List[Long]()\n        var temp18 : List[Long]\
    \ = List[Long]()\n        var temp19 : List[Long] = List[Long]()\n        var\
    \ temp20 : List[Long] = List[Long]()\n        var temp21 : List[Long] = List[Long]()\n\
    \        var temp22 : List[Long] = List[Long]()\n        var temp23 : List[Long]\
    \ = List[Long]()\n        var temp24 : List[Long] = List[Long]()\n        var\
    \ temp25 : List[Long] = List[Long]()\n        var temp26 : List[Long] = List[Long]()\n\
    \        var temp27 : List[Long] = List[Long]()\n        var temp28 : List[Long]\
    \ = List[Long]()\n        var temp29 : List[Long] = List[Long]()\n        var\
    \ temp30 : List[Long] = List[Long]()\n        var temp31 : List[Long] =\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvycalzlg.scala:52:33 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mvar\e[0m \e[36mtemp31\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] =\n\e[31m\e[31m   |\e[0m                                \
    \ ^\e[0m\n\e[31m   |\e[0m                                 expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvycalzlg.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can solve this problem\
    \ using a max heap.\n        // The max heap will contain the k largest elements.\n\
    \        // We can then iterate over the array and add each element to the heap.\n\
    \        // If the heap is full, we can compare the current element to the top\
    \ of the heap.\n        // If the current element is larger than the top of the\
    \ heap, we can remove the top of the heap\n        // and add the current element\
    \ to the heap.\n        // After iterating over the array, we can return the heap\
    \ as a sorted list.\n        // This algorithm runs in O(n log k) time and O(k)\
    \ space.\n        val heap = new mutable.PriorityQueue[Long]()\n        for (i\
    \ <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n            else\
    \ if (i > heap.head) {\n                heap.dequeue\n                heap.enqueue(i)\n\
    \            }\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt_ymzhg6.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        for (i <- arr) {\n            heap.enqueue(i)\n        \
    \    if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((a\
    \ : Long, b : Long) => a > b)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.remove()\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyxcqi91r.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36ma\e[0m : \e[35mLong\e[0m, \e[36mb\e\
    [0m : \e[35mLong\e[0m) => a > b)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val pq = new PriorityQueue[Long]()(Ordering.by(x\
    \ => -x))\n        for (i <- arr) {\n            pq.enqueue(i)\n            if\
    \ (pq.size > k) pq.dequeue\n        }\n        pq.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy2i5vag9.scala:31)\n\tat Problem.main(tmpy2i5vag9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given an array arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // Example 1:\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // Example 2:\n        // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n\
    \        // Example 3:\n        // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
    \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n        //\
    \ (List[Long](2l.toLong))\n        // Note:\n        // 1. The length of the array\
    \ will be in the range of [1, 1000].\n        // 2. The elements in the array\
    \ will be in the range of [-1000, 1000].\n        // 3. 0 <= k <= len(arr)\n \
    \       def maximum(arr : List[Long], k : Long) : List[Long] = {\n           \
    \ // Given an array arr of integers and a positive integer k, return a sorted\
    \ list \n            // of length k with the maximum k numbers in arr.\n     \
    \       // Example 1:\n            // >>> maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l))\n            // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n\
    \            // Example 2:\n            // >>> maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l))\n            // (List[Long](4l.toLong, 4l.toLong))\n\
    \            // Example 3:\n            // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong,\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqhlg72qr.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqhlg72qr.scala:35:63\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                   Found:    Unit\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m36 |\e[0m            \e[34m// Given an array arr of integers and a positive\
    \ integer k, return a sorted list \e[0m\n\e[31m37 |\e[0m            \e[34m// of\
    \ length k with the maximum k numbers in arr.\e[0m\n\e[31m38 |\e[0m          \
    \  \e[34m// Example 1:\e[0m\n\e[31m39 |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\e[0m\n\e[31m40 |\e[0m            \e[34m// (List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))\e[0m\n\e[31m41 |\e[0m            \e[34m// Example 2:\e\
    [0m\n\e[31m42 |\e[0m            \e[34m// >>> maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l))\e[0m\n\e[31m43 |\e[0m            \e[34m// (List[Long](4l.toLong,\
    \ 4l.toLong))\e[0m\n\e[31m44 |\e[0m            \e[34m// Example 3:\e[0m\n\e[31m45\
    \ |\e[0m            \e[34m// >>> maximum((List[Long](-3l.toLong, 2l.toLong,\e\
    [0m\n\e[31m46 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqhlg72qr.scala:61:1 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpqhlg72qr.scala:47:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m47 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e"
  stdout: ''
  timestamp: 1659793579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long](arr,\
    \ (a : Long, b : Long) => a > b)\n        val result = new ListBuffer[Long]\n\
    \        for (i <- 0l until k) {\n            result += heap.pop\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx3bu4_7p.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m](arr, (\e[36ma\e[0m : \e[35mLong\e[0m, \e\
    [36mb\e[0m : \e[35mLong\e[0m) => a > b)\n\e[31m\e[31m   |\e[0m               \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        for (i <- 0 until k.toInt)\
    \ {\n            max = arr.max\n            result = result :+ max\n         \
    \   arr = arr.filter(x => x != max)\n        }\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmprc6hpiok.scala:25:16 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            arr = arr.filter(\e[36mx\e[0m => x != max)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.dequeueAll.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a max heap to store the k largest elements.\n\
    \        // The heap will be sorted in descending order.\n        // We can then\
    \ return the heap as a list.\n        // The time complexity is O(n * log(k))\
    \ and the space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else {\n                if (i > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(i)\n                }\n            }\n     \
    \   }\n        heap.toList.sorted.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9qr0bxb6.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // You can add another function as well, if required\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var max : Long = 0\n       \
    \ var maxIndex : Int = 0\n        var i : Int = 0\n        while (i < k) {\n \
    \           max = -1000\n            maxIndex = 0\n            for (j <- 0 to\
    \ arr.length - 1) {\n                if (arr(j) > max) {\n                   \
    \ max = arr(j)\n                    maxIndex = j\n                }\n        \
    \    }\n            result = result :+ max\n            arr = arr.updated(maxIndex,\
    \ -1001)\n            i += 1\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkwh9l9o4.scala:35:16 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            arr = arr.updated(maxIndex, -\e[31m1001\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store the minimum k\
    \ numbers.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy0j0tk58.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbers.\e[0m\n\e[31m26 |\e[0m       \
    \ \e[34m// We can use a max-heap to store the minimum k numbers.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbers.\e[0m\n\e[31m32 |\e[0m       \
    \ \e[34m// We can use a max-heap to store the minimum k numbers.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// We can use a min-heap to store the maximum k numbers.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max-heap to store the minimum\
    \ k numbers.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the maximum k numbers.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the minimum k numbers.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the maximum k numbe"
  stdout: ''
  timestamp: 1659793579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the k largest elements in the\
    \ array.\n        // If the heap has k elements and the next element in the array\
    \ is larger than the smallest element in the heap,\n        // then we remove\
    \ the smallest element from the heap and add the new element.\n        // Otherwise,\
    \ we do nothing.\n        // At the end, we return the elements in the heap in\
    \ sorted order.\n        // The heap will be implemented as a min-heap.\n    \
    \    // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6dgxb2h9.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// The heap will store the k largest elements in the\
    \ array.\e[0m\n\e[31m22 |\e[0m        \e[34m// If the heap has k elements and\
    \ the next element in the array is larger than the smallest element in the heap,\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// then we remove the smallest element from\
    \ the heap and add the new element.\e[0m\n\e[31m24 |\e[0m        \e[34m// Otherwise,\
    \ we do nothing.\e[0m\n\e[31m25 |\e[0m        \e[34m// At the end, we return the\
    \ elements in the heap in sorted order.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ The heap will be implemented as a min-heap.\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// The heap will be implemented as a min-heap.\e[0m\n\e[31m28 |\e[0m     \
    \   \e[34m// The heap will be implemented as a min-heap.\e[0m\n\e[31m29 |\e[0m\
    \        \e[34m// The heap will be implemented as a min-heap.\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// The heap will be implemented as a min-heap.\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e[0m\n\e\
    [31m32 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// The heap will be implemented as a min-heap.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// The heap will be impl"
  stdout: ''
  timestamp: 1659793579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have a size of k.\n      \
    \  // We will iterate through the array and add each element to the heap.\n  \
    \      // If the heap is full, we will remove the largest element from the heap.\n\
    \        // After iterating through the array, we will have the k largest elements\
    \ in the heap.\n        // We will then return the heap as a sorted list.\n  \
    \      val heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n     \
    \       if (heap.size < k) {\n                heap.add(i)\n            } else\
    \ {\n                if (i > heap.peek) {\n                    heap.remove()\n\
    \                    heap.add(i)\n                }\n            }\n        }\n\
    \        heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1xf7drd_.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the k largest elements.\n    \
    \    // If the heap size is less than k, then we add the element to the heap.\n\
    \        // If the heap size is equal to k, then we check if the element is greater\
    \ than the minimum element in the heap.\n        // If it is, then we remove the\
    \ minimum element and add the new element.\n        // If it is not, then we do\
    \ nothing.\n        // After we have iterated through the entire array, we return\
    \ the heap.\n        // The heap will be sorted in ascending order, so we reverse\
    \ it.\n        // Time Complexity: O(n * log(k))\n        // Space Complexity:\
    \ O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n        for (element\
    \ <- arr) {\n            if (heap.size < k) heap.enqueue(element)\n          \
    \  else if (element > heap.head) {\n                heap.dequeue\n           \
    \     heap.enqueue(element)\n            }\n        }\n        heap.toList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphjpxbkya.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.extract()\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphtv302rf.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        arr.sortWith(_ > _).take(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpclvy4gbv.scala:23)\n\tat Problem.main(tmpclvy4gbv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // We can use a min heap to store the first\
    \ k elements.\n        // Then, for each element after the first k, we can compare\
    \ it to the top of the heap.\n        // If it is greater than the top of the\
    \ heap, we can remove the top of the heap and add the new element.\n        //\
    \ This will ensure that the heap always contains the k largest elements.\n   \
    \     // Then, we can simply return the heap as a sorted list.\n        // This\
    \ will take O(n log k) time and O(k) space.\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n    \
    \    }\n        for (i <- k.toInt until arr.length) {\n            if (arr(i)\
    \ > heap.head) {\n                heap.dequeue\n                heap.enqueue(arr(i))\n\
    \            }\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmmoucvnk.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The time complexity is O(n log k).\n       \
    \ // The space complexity is O(k).\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpukft815x.scala:29)\n\tat Problem.main(tmpukft815x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // You have to return a list of Long\n        // Do not change the function\
    \ signature\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // A heap is a data structure that allows us to efficiently\
    \ find the maximum element.\n        // We can use a min-heap to find the maximum\
    \ k elements in the array.\n        // We can use the heap to keep track of the\
    \ k largest elements we've seen so far.\n        // As we iterate through each\
    \ element of the array, we will offer it to the heap.\n        // If the heap\
    \ has fewer than k elements, we can offer the element to the heap.\n        //\
    \ If the heap has k elements, we can peek at the minimum element.\n        //\
    \ If the current element is greater than the minimum element, we can poll the\
    \ minimum element and offer the current element.\n        // This will maintain\
    \ the heap property.\n        // After we are done iterating through the array,\
    \ we can poll all the elements from the heap.\n        // This will give us the\
    \ maximum k elements in the array.\n        // Time Complexity: O(n log k)\n \
    \       // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (x <- arr) {\n            if (heap.size < k) heap.offer(x)\n    \
    \        else if (x > heap.peek) {\n                heap.poll\n              \
    \  heap.offer(x)\n            }\n        }\n        val result = new ListBuffer[Long]()\n\
    \        while (!heap.isEmpty) result += heap.poll\n        result.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshr6clqr.scala:35:36 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (heap.size < k) heap.offer(x)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue offer is not a member of scala.collection.mutable.PriorityQueue[Long]\
    \ - did you mean heap.toBuffer?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshr6clqr.scala:36:30\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m (x > heap.peek) {\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.PriorityQueue[Long]\
    \ - did you mean heap.head?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshr6clqr.scala:37:21\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                heap.poll\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue poll\
    \ is not a member of scala.collection.mutable.PriorityQueue[Long] - did you mean\
    \ heap.coll?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshr6clqr.scala:38:21\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                heap.offer(x)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue offer\
    \ is not a member of scala.collection.mutable.PriorityQueue[Long] - did you mean\
    \ heap.toBuffer?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpshr6clqr.scala:42:45\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mwhile\e[0m\
    \ (!heap.isEmpty) result += heap.poll\n\e[31m\e[31m   |\e[0m                 \
    \                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue poll is not a member\
    \ of scala.collection.mutable.PriorityQueue[Long] - did you mean heap.coll?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659793584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = -1001l\n        var maxIndex : Int =\
    \ -1\n        for (i <- 0 until k.toInt) {\n            for (j <- 0 until arr.length)\
    \ {\n                if (arr(j) > max) {\n                    max = arr(j)\n \
    \                   maxIndex = j\n                }\n            }\n         \
    \   result = result :+ max\n            arr(maxIndex) = -1001l\n            max\
    \ = -1001l\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpooiqwom3.scala:31:12 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            arr(maxIndex) = -\e[31m1001l\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1659793582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((a\
    \ : Long, b : Long) => a > b)\n        for (i <- 0 until arr.length) {\n     \
    \       if (heap.size < k) heap.insert(arr(i))\n            else if (arr(i) >\
    \ heap.peek) {\n                heap.pop\n                heap.insert(arr(i))\n\
    \            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8z_utodq.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36ma\e[0m : \e[35mLong\e[0m, \e[36mb\e\
    [0m : \e[35mLong\e[0m) => a > b)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(x\
    \ => -x))\n        for (i <- arr) {\n            heap.enqueue(i)\n           \
    \ if (heap.size > k) heap.dequeue\n        }\n        heap.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07ze4h4d.scala:31)\n\tat Problem.main(tmp07ze4h4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ in the array.\n        // We will iterate through the array, and if the element\
    \ is larger than the smallest element in the heap,\n        // we will remove\
    \ the smallest element and add the new element to the heap.\n        // At the\
    \ end, we will have the k largest elements in the heap.\n        // We can then\
    \ sort the heap and return it.\n        // Time Complexity: O(n log k)\n     \
    \   // Space Complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppefc7uwn.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new MinHeap[Long](k.toInt)\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.insert(i)\n   \
    \         else if (i > heap.peek) {\n                heap.remove\n           \
    \     heap.insert(i)\n            }\n        }\n        heap.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi42o1_zi.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMinHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MinHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min-heap to\
    \ solve this problem.\n        // The heap will contain the maximum k numbers\
    \ in arr.\n        // We will iterate through arr and add each element to the\
    \ heap.\n        // If the heap contains more than k elements, we will remove\
    \ the minimum element.\n        // After iterating through arr, we will return\
    \ the sorted heap.\n        val heap = new mutable.PriorityQueue[Long]()\n   \
    \     for (x <- arr) {\n            heap.enqueue(x)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0fr_9l14.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var max : Long = 0\n       \
    \ var maxIndex : Int = 0\n        for (i <- 0 to arr.length - 1) {\n         \
    \   if (arr(i) > max) {\n                max = arr(i)\n                maxIndex\
    \ = i\n            }\n        }\n        result = result :+ max\n        arr.remove(maxIndex)\n\
    \        for (i <- 0 to k - 2) {\n            max = 0\n            maxIndex =\
    \ 0\n            for (j <- 0 to arr.length - 1) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr.remove(maxIndex)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi98z79na.scala:31:12 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        arr.remove(maxIndex)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value remove is not a member of List[Long]\
    \ - did you mean arr.reduce?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi98z79na.scala:32:23\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m to k - \e[31m2\e[0m) {\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m\
    \   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpi98z79na.scala:42:16 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            arr.remove(maxIndex)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member of\
    \ List[Long], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((a\
    \ : Long, b : Long) => a > b)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.remove\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplybs5pj5.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36ma\e[0m : \e[35mLong\e[0m, \e[36mb\e\
    [0m : \e[35mLong\e[0m) => a > b)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a max-heap, and it will contain the\
    \ k largest elements.\n        // We will iterate through the array, and if the\
    \ current element is larger than the smallest element in the heap,\n        //\
    \ we will replace the smallest element in the heap with the current element.\n\
    \        // At the end, we will return the heap.\n        // The heap will be\
    \ implemented using a priority queue.\n        // The priority queue will be a\
    \ max-heap.\n        // The priority queue will be implemented using a binary\
    \ heap.\n        // The binary heap will be implemented using an array.\n    \
    \    // The binary heap will be a max-heap.\n        // The binary heap will be\
    \ implemented using the following functions:\n        // 1. get_left_child_index(index)\n\
    \        // 2. get_right_child_index(index)\n        // 3. get_parent_index(index)\n\
    \        // 4. swap(index1, index2)\n        // 5. heapify_up(index)\n       \
    \ // 6. heapify_down(index)\n        // 7. insert(value)\n        // 8. extract_max()\n\
    \        // 9. get_max()\n        // 10. get_size()\n        // 11. is_empty()\n\
    \        // 12. heap_sort(array)\n        // 13. print_heap()\n        // 14.\
    \ print_array(array)\n        // The heap will be implemented using the following\
    \ functions:\n        // 1. get_left_child_index(index)\n        // 2. get_right_child_index(index)\n\
    \        // 3. get_parent_index(index)\n        // 4. swap(index1, index2)\n \
    \       // 5. heapify_up(index)\n        // 6. heapify_down(index)\n        //\
    \ 7. insert(value)\n        // 8. extract_max()\n        // 9. get_max()\n   \
    \     // 10. get_size()\n        // 11. is_empty()\n        // 12. heap_sort(array)\n\
    \        // 13. print_heap()\n        // 14. print_array(array)\n        // The\
    \ heap will be implemented using the following functions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1g4mng_f.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// The heap will be a max-heap, and it will contain\
    \ the k largest elements.\e[0m\n\e[31m22 |\e[0m        \e[34m// We will iterate\
    \ through the array, and if the current element is larger than the smallest element\
    \ in the heap,\e[0m\n\e[31m23 |\e[0m        \e[34m// we will replace the smallest\
    \ element in the heap with the current element.\e[0m\n\e[31m24 |\e[0m        \e\
    [34m// At the end, we will return the heap.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ The heap will be implemented using a priority queue.\e[0m\n\e[31m26 |\e[0m \
    \       \e[34m// The priority queue will be a max-heap.\e[0m\n\e[31m27 |\e[0m\
    \        \e[34m// The priority queue will be implemented using a binary heap.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// The binary heap will be implemented using\
    \ an array.\e[0m\n\e[31m29 |\e[0m        \e[34m// The binary heap will be a max-heap.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// The binary heap will be implemented using\
    \ the following functions:\e[0m\n\e[31m31 |\e[0m        \e[34m// 1. get_left_child_index(index)\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// 2. get_right_child_index(index)\e[0m\n\e\
    [31m33 |\e[0m        \e[34m// 3. get_parent_index(index)\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// 4. swap(index1, index2)\e[0m\n\e[31m35 |\e[0m        \e[34m//\
    \ 5. heapify_up(index)\e[0m\n\e[31m36 |\e[0m        \e[34m// 6. heapify_down(index)\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// 7. insert(value)\e[0m\n\e[31m38 |\e[0m  \
    \      \e[34m// 8. extract_max()\e[0m\n\e[31m39 |\e[0m        \e[34m// 9. get_max()\e\
    [0m\n\e[31m40 |\e[0m        \e[34m// 10. get"
  stdout: ''
  timestamp: 1659793584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a recursive function\
    \ to solve this problem\n        def maximumHelper(arr : List[Long], k : Long,\
    \ result : List[Long]) : List[Long] = {\n            if (k == 0) result\n    \
    \        else {\n                val max = arr.max\n                val index\
    \ = arr.indexOf(max)\n                val newArr = arr.take(index) ++ arr.drop(index\
    \ + 1)\n                maximumHelper(newArr, k - 1, result :+ max)\n        \
    \    }\n        }\n        // Return the result\n        maximumHelper(arr, k,\
    \ List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3y5cd6sm.scala:34)\n\tat Problem.main(tmp3y5cd6sm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793585
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        return\
    \ List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk169t_rv.scala:24)\n\tat Problem.main(tmpk169t_rv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min heap to keep track of the largest\
    \ k elements.\n        // We can then sort the heap and return the result.\n \
    \       // This will take O(n log k) time and O(k) space.\n        val heap =\
    \ new Heap[Long]((x : Long, y : Long) => x < y)\n        for (x <- arr) {\n  \
    \          if (heap.size < k) heap.push(x)\n            else {\n             \
    \   if (x > heap.peek) {\n                    heap.pop\n                    heap.push(x)\n\
    \                }\n            }\n        }\n        heap.sort\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoailedgt.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ val sorted = arr.sorted\n        val length = sorted.length\n        val result\
    \ = sorted.slice(length - k.toInt, length)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ val sorted = arr.sorted\n        val result = new ListBuffer[Long]\n       \
    \ for (i <- 0 until k.toInt) {\n            result += sorted(sorted.length - 1\
    \ - i)\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7txgqh9e.scala:29)\n\tat Problem.main(tmp7txgqh9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a recursive function\
    \ to solve this problem\n        def maximumHelper(arr : List[Long], k : Long,\
    \ acc : List[Long]) : List[Long] = {\n            // Base case\n            if\
    \ (k == 0) acc\n            // Recursive case\n            else {\n          \
    \      val max = arr.max\n                maximumHelper(arr.filter(x => x != max),\
    \ k - 1, acc :+ max)\n            }\n        }\n        // Call the helper function\n\
    \        maximumHelper(arr, k, List[Long]())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiu8y0hv_.scala:34)\n\tat Problem.main(tmpiu8y0hv_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var maxIndex : Int = 0\n \
    \       for (i <- 0 to arr.length - 1) {\n            if (arr(i) > max) {\n  \
    \              max = arr(i)\n                maxIndex = i\n            }\n   \
    \     }\n        result = result :+ max\n        var arr2 : List[Long] = arr.slice(0,\
    \ maxIndex) ++ arr.slice(maxIndex + 1, arr.length)\n        for (i <- 0 to k -\
    \ 2) {\n            max = 0\n            maxIndex = 0\n            for (j <- 0\
    \ to arr2.length - 1) {\n                if (arr2(j) > max) {\n              \
    \      max = arr2(j)\n                    maxIndex = j\n                }\n  \
    \          }\n            result = result :+ max\n            arr2 = arr2.slice(0,\
    \ maxIndex) ++ arr2.slice(maxIndex + 1, arr2.length)\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpylskht6r.scala:31:23\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m to k - \e[31m2\e[0m) {\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m\
    \   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793585
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List()\n        var arr_copy : List[Long] = arr\n        for (i <- 0l.toLong\
    \ to k - 1l.toLong) {\n            val max_value : Long = arr_copy.max\n     \
    \       result = result :+ max_value\n            arr_copy = arr_copy.filter(x\
    \ => x != max_value)\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7x2909ks.scala:30)\n\tat Problem.main(tmp7x2909ks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- (sorted.length -\
    \ k).toInt to sorted.length - 1) {\n            result += sorted(i)\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (x <- arr) {\n            heap.push(x)\n\
    \            if (heap.size > k) heap.pop\n        }\n        heap.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00i5yoc8.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793585
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        for (i <- arr) {\n            heap.enqueue(i)\n        \
    \    if (heap.size > k) heap.dequeue\n        }\n        heap.dequeueAll.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ val arr_sorted = arr.sorted\n        val arr_sorted_rev = arr_sorted.reverse\n\
    \        val arr_sorted_rev_k = arr_sorted_rev.take(k.toInt)\n        arr_sorted_rev_k\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp89cns7ug.scala:27)\n\tat Problem.main(tmp89cns7ug.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            pq.enqueue(i)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ arr.sortWith(_ > _).take(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv3fa39fz.scala:24)\n\tat Problem.main(tmpv3fa39fz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a max heap to store the k largest elements.\n\
    \        // We can use a min heap to store the k smallest elements.\n        //\
    \ We can use a max heap to store the k largest elements.\n        // We can use\
    \ a min heap to store the k smallest elements.\n        // We can use a max heap\
    \ to store the k largest elements.\n        // We can use a min heap to store\
    \ the k smallest elements.\n        // We can use a max heap to store the k largest\
    \ elements.\n        // We can use a min heap to store the k smallest elements.\n\
    \        // We can use a max heap to store the k largest elements.\n        //\
    \ We can use a min heap to store the k smallest elements.\n        // We can use\
    \ a max heap to store the k largest elements.\n        // We can use a min heap\
    \ to store the k smallest elements.\n        // We can use a max heap to store\
    \ the k largest elements.\n        // We can use a min heap to store the k smallest\
    \ elements.\n        // We can use a max heap to store the k largest elements.\n\
    \        // We can use a min heap to store the k smallest elements.\n        //\
    \ We can use a max heap to store the k largest elements.\n        // We can use\
    \ a min heap to store the k smallest elements.\n        // We can use a max heap\
    \ to store the k largest elements.\n        // We can use a min heap to store\
    \ the k smallest elements.\n        // We can use a max heap to store the k largest\
    \ elements.\n        // We can use a min heap to store the k smallest elements.\n\
    \        // We can use a max heap to store the k largest elements.\n        //\
    \ We can use a min heap to store the k smallest elements.\n        // We can use\
    \ a max heap to store the k largest elements.\n        // We can use a min heap\
    \ to store the k smallest elements.\n        // We can use a max heap to store\
    \ the k largest elements.\n        // We can use a min heap to store the k smallest\
    \ elements.\n        // We can use a max heap to store the k largest elements.\n\
    \        // We can use a min heap to store the k smallest elements.\n        //\
    \ We can use a max heap to store the k largest elements.\n        //\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa0t_k23f.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a max heap to store the k largest elements.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a max heap to store\
    \ the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a min\
    \ heap to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ We can use a max heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We can use a min heap to store the k smallest elements.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// We can use a max heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a max heap to store\
    \ the k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a min\
    \ heap to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ We can use a max heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m\
    \        \e[34m// We can use a min heap to store the k smallest elements.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// We can use a max heap to store the k largest elements.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a max heap to store\
    \ the k largest elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a min\
    \ heap to store the k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m//\
    \ We can use a max heap to s"
  stdout: ''
  timestamp: 1659793587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var maxIndex : Int = 0\n \
    \       for (i <- 0 to arr.length - 1) {\n            if (arr(i) > max) {\n  \
    \              max = arr(i)\n                maxIndex = i\n            }\n   \
    \     }\n        result = result :+ max\n        for (i <- 0 to k - 2) {\n   \
    \         max = 0\n            for (j <- 0 to arr.length - 1) {\n            \
    \    if (arr(j) > max && j != maxIndex) {\n                    max = arr(j)\n\
    \                    maxIndex = j\n                }\n            }\n        \
    \    result = result :+ max\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjcowjl5d.scala:30:23\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m to k - \e[31m2\e[0m) {\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m\
    \   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // return List[Long]()\n        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will store the k largest elements.\n\
    \        // For each element in the array, we will add it to the heap.\n     \
    \   // If the heap size is greater than k, we will remove the largest element.\n\
    \        val heap = new MaxHeap[Long]()\n        for (x <- arr) {\n          \
    \  heap.add(x)\n            if (heap.size > k) heap.remove()\n        }\n    \
    \    heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplxdjav_p.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type\
    \ MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var max = new ListBuffer[Long]()\n\
    \        for (i <- 0l.toLong to k - 1l.toLong) {\n            var max_index =\
    \ 0l.toLong\n            for (j <- i.toLong to arr.length - 1l.toLong) {\n   \
    \             if (arr(j.toInt) > arr(max_index.toInt)) {\n                   \
    \ max_index = j\n                }\n            }\n            max += arr(max_index.toInt)\n\
    \            var temp = arr(i.toInt)\n            arr(i.toInt) = arr(max_index.toInt)\n\
    \            arr(max_index.toInt) = temp\n        }\n        return max.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdefnaha9.scala:30:12 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            arr(i.toInt) = arr(max_index.toInt)\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdefnaha9.scala:31:12 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            arr(max_index.toInt) = temp\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - 1 - i)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7piifrl7.scala:28)\n\tat Problem.main(tmp7piifrl7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0l\n        var maxIndex : Int = 0\n\
    \        var i : Int = 0\n        while (i < k) {\n            max = arr(0)\n\
    \            maxIndex = 0\n            for (j <- 0 until arr.length) {\n     \
    \           if (arr(j) > max) {\n                    max = arr(j)\n          \
    \          maxIndex = j\n                }\n            }\n            result\
    \ = result :+ max\n            arr = arr.patch(maxIndex, Nil, 1)\n           \
    \ i += 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqaxnib7n.scala:34:16 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr = arr.patch(maxIndex, Nil, \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            temp = arr(i) :: temp\n\
    \            temp = temp.sorted\n            if (temp.length > k) {\n        \
    \        temp = temp.dropRight(1)\n            }\n        }\n        result =\
    \ temp.sorted\n        result = result.reverse\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqm9q1i5h.scala:35)\n\tat Problem.main(tmpqm9q1i5h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min-heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements.\n\
    \        // We will iterate through the array, and if the element is larger than\
    \ the \n        // smallest element in the heap, we will remove the smallest element\
    \ and add \n        // the new element.\n        // The heap will always contain\
    \ the k largest elements.\n        // When we are done iterating, we will return\
    \ the heap.\n        // The heap will be in ascending order, so we will reverse\
    \ it.\n        val heap = new mutable.PriorityQueue[Long]()\n        for (i <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(i)\n            else if\
    \ (i > heap.head) {\n                heap.dequeue\n                heap.enqueue(i)\n\
    \            }\n        }\n        heap.toList.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplf9t7o70.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - 1 - i)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7piifrl7.scala:28)\n\tat Problem.main(tmp7piifrl7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var index : Long = 0\n   \
    \     var count : Long = 0\n        while (count < k) {\n            max = 0\n\
    \            index = 0\n            for (i <- 0 to arr.length - 1) {\n       \
    \         if (arr(i) > max) {\n                    max = arr(i)\n            \
    \        index = i\n                }\n            }\n            result = result\
    \ :+ max\n            arr(index) = -1001\n            count += 1\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5z9x9c33.scala:34:12 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr(index) = -\e[31m1001\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1659793589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // The heap will be of size k.\n        // If the heap is full and the\
    \ next element is greater than the root,\n        // then we can remove the root\
    \ and insert the next element.\n        // If the heap is not full, then we can\
    \ insert the next element.\n        // Once we have gone through the entire array,\
    \ we can return the heap.\n        // Since the heap is a min-heap, we can reverse\
    \ the heap to get the k largest elements.\n        // Time Complexity: O(n * log(k))\n\
    \        // Space Complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (x <- arr) {\n            if (heap.size < k) heap.enqueue(x)\n  \
    \          else if (x > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(x)\n            }\n        }\n        heap.toList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9vvxcoun.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We will use a heap to store\
    \ the k largest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf7ubpq4x.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We will use a heap to store the k largest elements.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We will use a max heap to store the k largest\
    \ elements.\e[0m\n\e[31m22 |\e[0m        \e[34m// We will use a min heap to store\
    \ the k smallest elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We will use a\
    \ max heap to store the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ We will use a min heap to store the k smallest elements.\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// We will use a max heap to store the k largest elements.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We will use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will use a max heap to store\
    \ the k largest elements.\e[0m\n\e[31m28 |\e[0m        \e[34m// We will use a\
    \ min heap to store the k smallest elements.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ We will use a max heap to store the k largest elements.\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// We will use a min heap to store the k smallest elements.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// We will use a max heap to store the k largest\
    \ elements.\e[0m\n\e[31m32 |\e[0m        \e[34m// We will use a min heap to store\
    \ the k smallest elements.\e[0m\n\e[31m33 |\e[0m        \e[34m// We will use a\
    \ max heap to store the k largest elements.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ We will use a min heap to store the k smallest elements.\e[0m\n\e[31m35 |\e\
    [0m        \e[34m// We will use a max heap to store the k largest elements.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// We will use a min heap to store the k smallest\
    \ elements.\e[0m\n\e[31m37 |\e[0m        \e[34m//"
  stdout: ''
  timestamp: 1659793590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var arr_sorted : List[Long]\
    \ = arr.sorted\n        for (i <- 0 until k.toInt) {\n            result = result\
    \ :+ arr_sorted(arr_sorted.length - 1 - i)\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1nxn5la.scala:29)\n\tat Problem.main(tmpc1nxn5la.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // A heap is a data structure that allows us to efficiently\
    \ find the minimum or maximum element.\n        // We can use a min heap to find\
    \ the maximum k elements.\n        // The min heap will contain the k largest\
    \ elements.\n        // We can iterate through the array and add each element\
    \ to the heap.\n        // If the heap contains more than k elements, we remove\
    \ the minimum element.\n        // This will ensure that the heap contains the\
    \ k largest elements.\n        // After iterating through the array, we can return\
    \ the elements in the heap.\n        // Time Complexity: O(n log k)\n        //\
    \ Space Complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (x <- arr) {\n            heap.enqueue(x)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6dz8xcnp.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have a size of k.\n      \
    \  // We will iterate through the array and add each element to the heap.\n  \
    \      // If the heap size is greater than k, we will remove the max element.\n\
    \        // After iterating through the array, we will return the heap.\n    \
    \    val heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n       \
    \     heap.add(i)\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5854msj3.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.push(i)\n\
    \            if (heap.size > k) heap.pop\n        }\n        heap.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl9ts2tdl.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result = List[Long]()\n        var max = arr.max\n        for (i <- 0 until\
    \ k.toInt) {\n            result = result :+ max\n            arr.remove(arr.indexOf(max))\n\
    \            max = arr.max\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdei31fn2.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            arr.remove(arr.indexOf(max))\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value remove is not a\
    \ member of List[Long] - did you mean arr.reduce?\n1 error found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // The priority queue will be sorted by the\
    \ absolute value of the elements in the array.\n        // The first k elements\
    \ in the priority queue will be the answer.\n        // Time complexity: O(n *\
    \ log(k))\n        // Space complexity: O(k)\n        val pq = new PriorityQueue[Long]()(Ordering.by(x\
    \ => abs(x)))\n        for (x <- arr) {\n            pq.enqueue(x)\n         \
    \   if (pq.size > k) pq.dequeue\n        }\n        pq.toList.sorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfxn7j584.scala:34)\n\tat Problem.main(tmpfxn7j584.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The heap will have a maximum size of k.\n  \
    \      // If the heap is full, we will only add an element if it is greater than\
    \ the root of the heap.\n        // If the heap is not full, we will add the element.\n\
    \        // The heap will be sorted from greatest to least.\n        // The heap\
    \ will be sorted from greatest to least.\n        // We will return the heap as\
    \ a list.\n        // Time Complexity: O(nlogk)\n        // Space Complexity:\
    \ O(k)\n        val heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr)\
    \ {\n            if (heap.size < k) heap.add(i)\n            else if (i > heap.peek)\
    \ {\n                heap.poll\n                heap.add(i)\n            }\n \
    \       }\n        heap.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp91cs_y_9.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result = List[Long]()\n        var max = 0l\n        var maxIndex = 0\n\
    \        for (i <- 0 until k.toInt) {\n            max = arr(0)\n            maxIndex\
    \ = 0\n            for (j <- 0 until arr.length) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr = arr.patch(maxIndex, Nil, 1)\n        }\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmga0736l.scala:34:16 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr = arr.patch(maxIndex, Nil, \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val maxHeap = new MaxHeap[Long](k.toInt)\n\
    \        for (i <- arr) {\n            maxHeap.insert(i)\n        }\n        maxHeap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6hxg1nu7.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxHeap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.extract\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_p53vb9.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        arr.sortWith(_\
    \ > _).take(k.toInt)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf_gexdku.scala:24)\n\tat Problem.main(tmpf_gexdku.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have size k.\n        // We\
    \ will iterate through the array and add each element to the heap.\n        //\
    \ If the heap is full, we will remove the maximum element from the heap.\n   \
    \     // After we iterate through the array, we will return the heap.\n      \
    \  val heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n         \
    \   if (heap.size < k) {\n                heap.add(i)\n            } else {\n\
    \                if (i > heap.peek) {\n                    heap.poll\n       \
    \             heap.add(i)\n                }\n            }\n        }\n     \
    \   heap.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgcltrnvh.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        var result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ k.toInt) {\n            var max = arr.max\n            result += max\n     \
    \       arr = arr.filter(_ != max)\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmptgkpuzec.scala:28:16 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            arr = arr.filter(_ != max)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will be of size k.\n        //\
    \ We will iterate through the array and add each element to the heap.\n      \
    \  // If the heap is full, we will remove the maximum element from the heap and\
    \ add the current element.\n        // We will then return the heap as a sorted\
    \ list.\n        // This algorithm will run in O(n log k) time and O(k) space.\n\
    \        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n     \
    \   for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n       \
    \     else {\n                if (i > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(i)\n                }\n            }\n     \
    \   }\n        heap.toList.sorted\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9nviln0j.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp9nviln0j.scala:26:65 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m   |\e[0m                     \
    \                                            ^^\e[0m\n\e[31m   |\e[0mvalue unary_-\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp9nviln0j.scala:26:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimal\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[S] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mby\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        var result : List[Long] =\
    \ List[Long]()\n        var max : Long = 0\n        var maxIndex : Int = 0\n \
    \       var i : Int = 0\n        while (i < k) {\n            max = arr(0)\n \
    \           maxIndex = 0\n            for (j <- 0 until arr.length) {\n      \
    \          if (arr(j) > max) {\n                    max = arr(j)\n           \
    \         maxIndex = j\n                }\n            }\n            result =\
    \ result :+ max\n            arr = arr.take(maxIndex) ++ arr.drop(maxIndex + 1)\n\
    \            i += 1\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmprxsrdfj6.scala:34:16 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr = arr.take(maxIndex) ++ arr.drop(maxIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Given an array arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \        // (List[Long](2l.toLong))\n        // Note:\n        // 1. The length\
    \ of the array will be in the range of [1, 1000].\n        // 2. The elements\
    \ in the array will be in the range of [-1000, 1000].\n        // 3. 0 <= k <=\
    \ len(arr)\n        def loop(arr : List[Long], k : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (k == 0l) acc\n            else {\n                val max\
    \ = arr.max\n                loop(arr.filterNot(_ == max), k - 1l, acc :+ max)\n\
    \            }\n        }\n        loop(arr, k, List[Long]())\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong,\
    \ 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjabzs0wy.scala:42)\n\tat Problem.main(tmpjabzs0wy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define the maximum function\
    \ as a recursive function\n        def maximum(arr : List[Long], k : Long, acc\
    \ : List[Long]) : List[Long] = {\n            // If the size of the accumulator\
    \ is equal to k, return the accumulator\n            if (acc.size == k) acc\n\
    \            // Otherwise, if the size of the accumulator is less than k,\n  \
    \          // find the maximum element in the list and add it to the accumulator\n\
    \            else {\n                // Find the maximum element in the list\n\
    \                val max = arr.max\n                // Add the maximum element\
    \ to the accumulator\n                val newAcc = acc :+ max\n              \
    \  // Remove the maximum element from the list\n                val newArr = arr.filter(x\
    \ => x != max)\n                // Recursively call the maximum function\n   \
    \             maximum(newArr, k, newAcc)\n            }\n        }\n        //\
    \ Call the maximum function\n        maximum(arr, k, List[Long]())\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5_8bbjc2.scala:41)\n\tat Problem.main(tmp5_8bbjc2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap(arr)\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += heap.pop\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk2bb3pjb.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m(arr)\n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: type Heap\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        return\
    \ List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk169t_rv.scala:24)\n\tat Problem.main(tmpk169t_rv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a min-heap.\n        // We will add\
    \ the first k elements to the heap.\n        // Then we will iterate through the\
    \ rest of the elements.\n        // If the current element is greater than the\
    \ minimum element in the heap,\n        // we will remove the minimum element\
    \ and add the current element.\n        // Finally, we will return the heap as\
    \ a sorted list.\n        val heap = new Heap[Long]((x : Long, y : Long) => x\
    \ < y)\n        for (i <- 0l until k) {\n            heap.add(arr(i.toInt))\n\
    \        }\n        for (i <- k until arr.length) {\n            if (arr(i.toInt)\
    \ > heap.peek) {\n                heap.remove()\n                heap.add(arr(i.toInt))\n\
    \            }\n        }\n        heap.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphypvb3kc.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        val n =\
    \ arr.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until\
    \ n) {\n            if (result.length < k) {\n                result += arr(i)\n\
    \            } else {\n                val min = result.min\n                if\
    \ (arr(i) > min) {\n                    result -= min\n                    result\
    \ += arr(i)\n                }\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7kya9x3s.scala:38)\n\tat Problem.main(tmp7kya9x3s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((a\
    \ : Long, b : Long) => a > b)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.remove\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplybs5pj5.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36ma\e[0m : \e[35mLong\e[0m, \e[36mb\e\
    [0m : \e[35mLong\e[0m) => a > b)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 to k.toInt - 1)\
    \ {\n            result += sorted(sorted.length - 1 - i)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk1d5k0tb.scala:28)\n\tat Problem.main(tmpk1d5k0tb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // You can add another function as well, if required\n        val arr2\
    \ = arr.sorted\n        val arr3 = arr2.reverse\n        val arr4 = arr3.take(k.toInt)\n\
    \        arr4\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw58kdl6r.scala:28)\n\tat Problem.main(tmpw58kdl6r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will store the k largest elements in the\
    \ array.\n        // We will iterate through the array and add elements to the\
    \ heap.\n        // If the heap is full, we will remove the smallest element from\
    \ the heap.\n        // If the heap is not full, we will add the element to the\
    \ heap.\n        // After iterating through the array, we will return the heap.\n\
    \        // The heap will be sorted in ascending order.\n        // We will reverse\
    \ the heap to get the result.\n        // Time Complexity: O(n log k)\n      \
    \  // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()\n \
    \       for (element <- arr) {\n            if (heap.size < k) {\n           \
    \     heap.enqueue(element)\n            } else {\n                if (element\
    \ > heap.head) {\n                    heap.dequeue\n                    heap.enqueue(element)\n\
    \                }\n            }\n        }\n        heap.toList.reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxbx6k8hf.scala:44)\n\tat Problem.main(tmpxbx6k8hf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Define a recursive function\
    \ to solve this problem\n        def maximumHelper(arr : List[Long], k : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (k == 0) acc\n          \
    \  else {\n                val max = arr.max\n                val newArr = arr.filter(x\
    \ => x != max)\n                maximumHelper(newArr, k - 1, acc :+ max)\n   \
    \         }\n        }\n        maximumHelper(arr, k, List[Long]())\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp40rjbhmw.scala:32)\n\tat Problem.main(tmp40rjbhmw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is the number of maximum\
    \ numbers to be returned\n        // Return a list of maximum numbers of length\
    \ 'k'\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // The max heap will have a size of k.\n      \
    \  // We will iterate through the array and add the elements to the heap.\n  \
    \      // If the heap is full, we will remove the largest element from the heap\
    \ and add the new element.\n        // If the heap is not full, we will just add\
    \ the new element.\n        // After we iterate through the array, we will return\
    \ the heap.\n        val heap = new MaxHeap[Long](k.toInt)\n        for (i <-\
    \ arr) {\n            if (heap.size == k) {\n                heap.remove()\n \
    \           }\n            heap.add(i)\n        }\n        heap.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvvp4j2im.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // Return a sorted list of length `k` with the maximum `k` numbers in\
    \ `arr`\n        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        //\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggdti8xy.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ We can use a min heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We can use a max heap to store the k smallest elements.\e[0m\n\
    \e[31m27 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ We can use a min heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m\
    \        \e[34m// We can use a max heap to store the k smallest elements.\e[0m\n\
    \e[31m33 |\e[0m        \e[34m// We can use a min heap to store the k largest elements.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max heap to store the k smallest\
    \ elements.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min heap to store\
    \ the k largest elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max\
    \ heap to store the k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m//\
    \ We can use a min heap to s"
  stdout: ''
  timestamp: 1659793596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.remove\n        }\n        heap.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55mp1fod.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxkvdthdo.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m33 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m35 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m36\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m37 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We can also use a max heap "
  stdout: ''
  timestamp: 1659793597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We will use a heap to store\
    \ the maximum k numbers.\n        // The heap will be a min-heap, so that the\
    \ minimum number is always at the top.\n        // We will use a heap of size\
    \ k, and we will insert the first k numbers into the heap.\n        // For each\
    \ subsequent number, we will compare it to the minimum number in the heap.\n \
    \       // If the number is greater than the minimum number, we will remove the\
    \ minimum number from the heap and insert the new number.\n        // After we\
    \ have processed all numbers, we will return the heap.\n        // The heap is\
    \ a min-heap, so we will reverse the heap to get the maximum k numbers.\n    \
    \    // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n     \
    \   val heap = new Heap(k)\n        for (i <- 0 until arr.length) {\n        \
    \    if (i < k) heap.insert(arr(i))\n            else {\n                if (arr(i)\
    \ > heap.minimum()) {\n                    heap.removeMinimum()\n            \
    \        heap.insert(arr(i))\n                }\n            }\n        }\n  \
    \      heap.heap.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpltcmi9lo.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m(k)\n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: type Heap\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var i : Long = 0l\n        while (i < k) {\n            var max : Long\
    \ = -1001l\n            var index : Long = 0l\n            var j : Long = 0l\n\
    \            while (j < arr.length) {\n                if (!temp.contains(j) &&\
    \ arr(j.toInt) > max) {\n                    max = arr(j.toInt)\n            \
    \        index = j\n                }\n                j += 1\n            }\n\
    \            result = result :+ max\n            temp = temp :+ index\n      \
    \      i += 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsdcp_2fa.scala:42)\n\tat Problem.main(tmpsdcp_2fa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr)\
    \ {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- arr) {\n            pq.enqueue(i)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8wl6eygx.scala:31)\n\tat Problem.main(tmp8wl6eygx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val maxHeap = new MaxHeap[Long](k.toInt)\n\
    \        for (x <- arr) {\n            maxHeap.insert(x)\n        }\n        maxHeap.getSortedList()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp147zt_n7.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxHeap\e[0m = \e[33mnew\e\
    [0m \e[35mMaxHeap\e[0m[\e[35mLong\e[0m](k.toInt)\n\e[31m\e[31m   |\e[0m      \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: type MaxHeap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv91pc9un.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a heap to solve this problem.\e[0m\n\e\
    [31m21 |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the k largest elements.\e[0m\n\e[31m26 |\e[0m      \
    \  \e[34m// We can use a max-heap to store the k smallest elements.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can\
    \ use a min-heap to store the k largest elements.\e[0m\n\e[31m32 |\e[0m      \
    \  \e[34m// We can use a max-heap to store the k smallest elements.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// We can use a min-heap to store the k largest elements.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max-heap to store the k smallest\
    \ elements.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can use a min-heap to store\
    \ the k largest elements.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can use a max-heap\
    \ to store the k smallest elements.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can\
    \ use a min-heap to s"
  stdout: ''
  timestamp: 1659793598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((x\
    \ : Long) => -x))\n        for (x <- arr) {\n            heap.enqueue(x)\n   \
    \         if (heap.size > k) heap.dequeue\n        }\n        heap.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_273swnb.scala:31)\n\tat Problem.main(tmp_273swnb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793599
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val arr2 = arr.sortWith(_\
    \ > _)\n        arr2.take(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_5uo6gm.scala:24)\n\tat Problem.main(tmpj_5uo6gm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793600
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ val sorted = arr.sorted\n        val result = sorted.takeRight(k.toInt)\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap(arr)\n\
    \        var result = List[Long]()\n        for (i <- 0l until k) {\n        \
    \    result = heap.pop() :: result\n        }\n        result.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd2vf1e8a.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m(arr)\n\e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: type Heap\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result : List[Long] = List[Long]()\n        var max : Long = 0\n       \
    \ var maxIndex : Int = 0\n        var count : Long = 0\n        while (count <\
    \ k) {\n            max = arr(0)\n            maxIndex = 0\n            for (i\
    \ <- 0 until arr.length) {\n                if (arr(i) > max) {\n            \
    \        max = arr(i)\n                    maxIndex = i\n                }\n \
    \           }\n            result = result :+ max\n            arr = arr.patch(maxIndex,\
    \ Nil, 1)\n            count += 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2dfchsq0.scala:35:16 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            arr = arr.patch(maxIndex, Nil, \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val arr\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793599
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - i - 1)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4zo7ib6h.scala:28)\n\tat Problem.main(tmp4zo7ib6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793600
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this function body\n\
    \        // You can add another function as well, if required\n        var result\
    \ = List[Long]()\n        var temp = List[Long]()\n        for (i <- 0 until arr.length)\
    \ {\n            if (temp.length < k) {\n                temp = temp :+ arr(i)\n\
    \            } else {\n                var min = temp(0)\n                var\
    \ index = 0\n                for (j <- 0 until temp.length) {\n              \
    \      if (temp(j) < min) {\n                        min = temp(j)\n         \
    \               index = j\n                    }\n                }\n        \
    \        if (arr(i) > min) {\n                    temp = temp.updated(index, arr(i))\n\
    \                }\n            }\n        }\n        temp = temp.sorted\n   \
    \     for (i <- 0 until temp.length) {\n            result = result :+ temp(temp.length\
    \ - 1 - i)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprtiynfs1.scala:48)\n\tat Problem.main(tmprtiynfs1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(x\
    \ => -x))\n        for (i <- arr) {\n            heap.enqueue(i)\n           \
    \ if (heap.size > k) heap.dequeue\n        }\n        heap.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07ze4h4d.scala:31)\n\tat Problem.main(tmp07ze4h4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - 1 - i)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7piifrl7.scala:28)\n\tat Problem.main(tmp7piifrl7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n     \
    \   val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until\
    \ n) {\n            pq.enqueue(arr(i))\n            if (pq.length > k) pq.dequeue\n\
    \        }\n        pq.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1hxfamm9.scala:32)\n\tat Problem.main(tmp1hxfamm9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.add(i)\n\
    \            if (heap.size > k) heap.poll\n        }\n        heap.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi4g324oq.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m \e[35mHeap\e[0m[\e[35mLong\e[0m]((\e[36mx\e[0m : \e[35mLong\e[0m, \e[36my\e\
    [0m : \e[35mLong\e[0m) => x > y)\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                       Not found: type Heap\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793599
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a priority queue\
    \ to solve this problem.\n        // We can also use a heap to solve this problem.\n\
    \        // We can also use a binary search tree to solve this problem.\n    \
    \    // We can also use a hash table to solve this problem.\n        // We can\
    \ also use a binary search to solve this problem.\n        // We can also use\
    \ a merge sort to solve this problem.\n        // We can also use a quick sort\
    \ to solve this problem.\n        // We can also use a selection sort to solve\
    \ this problem.\n        // We can also use a bubble sort to solve this problem.\n\
    \        // We can also use a insertion sort to solve this problem.\n        //\
    \ We can also use a shell sort to solve this problem.\n        // We can also\
    \ use a counting sort to solve this problem.\n        // We can also use a radix\
    \ sort to solve this problem.\n        // We can also use a bucket sort to solve\
    \ this problem.\n        // We can also use a heap sort to solve this problem.\n\
    \        // We can also use a tree sort to solve this problem.\n        // We\
    \ can also use a merge sort to solve this problem.\n        // We can also use\
    \ a quick sort to solve this problem.\n        // We can also use a selection\
    \ sort to solve this problem.\n        // We can also use a bubble sort to solve\
    \ this problem.\n        // We can also use a insertion sort to solve this problem.\n\
    \        // We can also use a shell sort to solve this problem.\n        // We\
    \ can also use a counting sort to solve this problem.\n        // We can also\
    \ use a radix sort to solve this problem.\n        // We can also use a bucket\
    \ sort to solve this problem.\n        // We can also use a heap sort to solve\
    \ this problem.\n        // We can also use a tree sort to solve this problem.\n\
    \        // We can also use a merge sort to solve this problem.\n        // We\
    \ can also use a quick sort to solve this problem.\n        // We can also use\
    \ a selection sort to solve this problem.\n        // We can also use a bubble\
    \ sort to solve this problem.\n        // We can also use a insertion sort to\
    \ solve this problem.\n        // We can also use a shell sort to solve this problem.\n\
    \        // We can also use a counting sort to solve this problem.\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp02f8opzz.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a priority queue to solve this problem.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// We can also use a heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can also use a binary search tree to solve\
    \ this problem.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can also use a hash table\
    \ to solve this problem.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can also use\
    \ a binary search to solve this problem.\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ We can also use a merge sort to solve this problem.\e[0m\n\e[31m26 |\e[0m  \
    \      \e[34m// We can also use a quick sort to solve this problem.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can also use a selection sort to solve this problem.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can also use a bubble sort to solve this\
    \ problem.\e[0m\n\e[31m29 |\e[0m        \e[34m// We can also use a insertion sort\
    \ to solve this problem.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can also use\
    \ a shell sort to solve this problem.\e[0m\n\e[31m31 |\e[0m        \e[34m// We\
    \ can also use a counting sort to solve this problem.\e[0m\n\e[31m32 |\e[0m  \
    \      \e[34m// We can also use a radix sort to solve this problem.\e[0m\n\e[31m33\
    \ |\e[0m        \e[34m// We can also use a bucket sort to solve this problem.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can also use a heap sort to solve this\
    \ problem.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can also use a tree sort to\
    \ solve this problem.\e[0m\n\e[31m36 |\e[0m        \e[34m// We can also use a\
    \ merge sort to solve this problem.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can\
    \ also use a quick sort to solve this problem.\e[0m\n"
  stdout: ''
  timestamp: 1659793600
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can do this in O(n)\
    \ time and O(k) space.\n        // First, we create a list of the first k elements.\n\
    \        // Then, we iterate through the rest of the elements.\n        // If\
    \ the element is greater than the minimum element in the list,\n        // we\
    \ remove the minimum element and add the new element.\n        // Finally, we\
    \ return the list.\n        val list = new ListBuffer[Long]()\n        for (i\
    \ <- 0 until k.toInt) {\n            list += arr(i)\n        }\n        for (i\
    \ <- k.toInt until arr.length) {\n            if (arr(i) > list.min) {\n     \
    \           list -= list.min\n                list += arr(i)\n            }\n\
    \        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmtqggucu.scala:39)\n\tat Problem.main(tmpmtqggucu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a min heap.\n        // The heap\
    \ will contain the k largest elements.\n        // We will iterate through the\
    \ array.\n        // If the heap is not full, add the element to the heap.\n \
    \       // If the heap is full, check if the element is larger than the minimum\
    \ element in the heap.\n        // If it is, remove the minimum element and add\
    \ the new element.\n        // If it is not, do nothing.\n        // Once we have\
    \ iterated through the array, we will have the k largest elements in the heap.\n\
    \        // We will then sort the heap and return it.\n        // Time Complexity:\
    \ O(n log k)\n        // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: queue is empty\n\tat scala.collection.mutable.PriorityQueue.head(PriorityQueue.scala:254)\n\
    \tat Problem$.maximum$$anonfun$1(tmp7phdxj3_.scala:35)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.maximum(tmp7phdxj3_.scala:39)\n\
    \tat Problem$.main(tmp7phdxj3_.scala:53)\n\tat Problem.main(tmp7phdxj3_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is the number of elements\
    \ to return\n        // return a list of integers\n        arr.sorted.takeRight(k.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        //\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxkvdthdo.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m23 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m24 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m27 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can also use a max heap to solve this\
    \ problem.\e[0m\n\e[31m31 |\e[0m        \e[34m// We can also use a min heap to\
    \ solve this problem.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can also use a\
    \ max heap to solve this problem.\e[0m\n\e[31m33 |\e[0m        \e[34m// We can\
    \ also use a min heap to solve this problem.\e[0m\n\e[31m34 |\e[0m        \e[34m//\
    \ We can also use a max heap to solve this problem.\e[0m\n\e[31m35 |\e[0m    \
    \    \e[34m// We can also use a min heap to solve this problem.\e[0m\n\e[31m36\
    \ |\e[0m        \e[34m// We can also use a max heap to solve this problem.\e[0m\n\
    \e[31m37 |\e[0m        \e[34m// We can also use a min heap to solve this problem.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We can also use a max heap "
  stdout: ''
  timestamp: 1659793597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a max heap to\
    \ solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpak0tyoqk.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mmaximum\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mk\e[0m : \e[35mLong\e\
    [0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m           \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    Unit\n\e[31m   |\e[0m\
    \                                                    Required: List[Long]\n\e\
    [31m20 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e[0m\n\
    \e[31m21 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m33 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m35 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m36 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m37 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// We can use a max heap to solve this problem.\e\
    [0m\n\e[31m39 |\e[0m        \e[34m// We can use a max heap to solve thi"
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result = List[Long]()\n        var max = -1001l\n        var maxIndex =\
    \ -1\n        for (i <- 0 until k.toInt) {\n            max = -1001l\n       \
    \     maxIndex = -1\n            for (j <- i until arr.length) {\n           \
    \     if (arr(j) > max) {\n                    max = arr(j)\n                \
    \    maxIndex = j\n                }\n            }\n            result = result\
    \ :+ max\n            arr(maxIndex) = -1001l\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu9lal30j.scala:34:12 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr(maxIndex) = -\e[31m1001l\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min-heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements.\n\
    \        // We will iterate through the array, and if the current element is larger\
    \ than the\n        // smallest element in the heap, we will remove the smallest\
    \ element and add the current\n        // element.\n        // After iterating\
    \ through the array, we will return the heap.\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8bghpu5.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpd8bghpu5.scala:26:65 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m   |\e[0m                     \
    \                                            ^^\e[0m\n\e[31m   |\e[0mvalue unary_-\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpd8bghpu5.scala:26:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mheap\e[0m = \e[33mnew\e\
    [0m mutable.PriorityQueue[\e[35mLong\e[0m]()(Ordering.by(-_))\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[S] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mby\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum k numbers in 'arr'\n\
    \        arr.sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill this in.\n       \
    \ var result = List[Long]()\n        var arr2 = arr.sorted\n        for (i <-\
    \ 0 until k.toInt) {\n            result = result :+ arr2(arr2.length - 1 - i)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzihcwnrg.scala:29)\n\tat Problem.main(tmpzihcwnrg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is the number of maximum\
    \ elements to return\n        // You can use the 'scala.math.Ordering' object\n\
    \        // For example, 'Ordering.Long' compares two Longs\n        // You can\
    \ use the 'sorted' method of a list\n        // For example, 'List(1, 2, 3).sorted'\
    \ returns a sorted list\n        // You can use the 'take' method of a list\n\
    \        // For example, 'List(1, 2, 3).take(2)' returns a list with the first\
    \ two elements\n        arr.sorted.take(k.toInt).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
    \ -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n\
    \    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong,\
    \ -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong,\
    \ 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong,\
    \ 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong,\
    \ 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp19wvsyv7.scala:32)\n\tat Problem.main(tmp19wvsyv7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        // We can use a min heap to\
    \ keep track of the k largest elements.\n        // The heap will be initialized\
    \ with the first k elements of the array.\n        // Then, we iterate through\
    \ the array, and if the current element is larger\n        // than the minimum\
    \ element in the heap, we remove the minimum element and\n        // insert the\
    \ current element.\n        // The heap will always contain the k largest elements.\n\
    \        // The time complexity is O(n log k) and the space complexity is O(k).\n\
    \        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i\
    \ <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt until arr.length)\
    \ {\n            if (arr(i) > heap.head) {\n                heap.dequeue\n   \
    \             heap.enqueue(arr(i))\n            }\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: queue is empty\n\tat scala.collection.mutable.PriorityQueue.head(PriorityQueue.scala:254)\n\
    \tat Problem$.maximum$$anonfun$2(tmp210xjuco.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.maximum(tmp210xjuco.scala:34)\n\
    \tat Problem$.main(tmp210xjuco.scala:48)\n\tat Problem.main(tmp210xjuco.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong,\
    \ -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong,\
    \ 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
    \ Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)),\
    \ (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example\
    \ 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the array\
    \ will be in the range of [1, 1000].\n    // 2. The elements in the array will\
    \ be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr\
    \ : List[Long], k : Long) : List[Long] = {\n        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
    \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
    \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
    \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
    \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
    \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
    \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n  \
    \  assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong,\
    \ -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
    \ 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n\
    \    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong,\
    \ 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong,\
    \ 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793574
