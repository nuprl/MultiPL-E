name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns True if the object q will fly, and False otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n\
  \    // (false)\n    // # 1+2 is less than the maximum possible weight, but it's\
  \ unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (9l))\n    // (true)\n    // # 3+2+3 is less than the maximum possible weight,\
  \ and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)), (5l))\n    //\
  \ (true)\n    // # 3 is less than the maximum possible weight, and it's balanced.\n\
  \    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        if (q.length == 0) return true\n        if (q.length == 1)\
    \ return true\n        if (q.length == 2) return q(0) == q(1)\n        if (q.length\
    \ == 3) return q(0) == q(2)\n        if (q.length % 2 == 0) return false\n   \
    \     if (q.sum > w) return false\n        for (i <- 0 until q.length / 2) {\n\
    \            if (q(i) != q(q.length - 1 - i)) return false\n        }\n      \
    \  return true", "        val sum = q.sum\n        val palindrome = q.reverse\
    \ == q\n        sum <= w && palindrome", "        var sum = 0l\n        for (i\
    \ <- q) {\n            sum += i\n        }\n        if (sum > w) return false\n\
    \        val q2 = q.reverse\n        for (i <- 0 until q.length) {\n         \
    \   if (q(i) != q2(i)) return false\n        }\n        return true", "      \
    \  val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum <=\
    \ w && isPalindrome", "        val qSum = q.sum\n        val qReverse = q.reverse\n\
    \        val qIsPalindrome = q == qReverse\n        val qWillFly = qSum <= w\n\
    \        qIsPalindrome && qWillFly", "        def isBalanced(q : List[Long]) :\
    \ Boolean = {\n            if (q.length == 0) return true\n            if (q.length\
    \ == 1) return true\n            if (q.head == q.last) return isBalanced(q.tail.init)\n\
    \            return false\n        }\n        if (isBalanced(q) && q.sum <= w)\
    \ return true\n        return false", "        val sum = q.sum\n        val isBalanced\
    \ = q.reverse == q\n        sum <= w && isBalanced", "        def isBalanced(q\
    \ : List[Long]) : Boolean = {\n            if (q.length == 0) return true\n  \
    \          if (q.length == 1) return true\n            if (q.head == q.last) return\
    \ isBalanced(q.tail.init)\n            return false\n        }\n        if (isBalanced(q)\
    \ && q.sum <= w) return true\n        return false", "        def isBalanced(q\
    \ : List[Long]) : Boolean = {\n            if (q.length == 0) return true\n  \
    \          if (q.length == 1) return true\n            if (q.head == q.last) return\
    \ isBalanced(q.tail.init)\n            return false\n        }\n        def sum(q\
    \ : List[Long]) : Long = {\n            if (q.length == 0) return 0\n        \
    \    return q.head + sum(q.tail)\n        }\n        if (isBalanced(q) && sum(q)\
    \ <= w) return true\n        return false", "        val sum = q.sum\n       \
    \ val palindrome = q.reverse == q\n        sum <= w && palindrome", "        val\
    \ sum = q.sum\n        val palindrome = q.reverse == q\n        sum <= w && palindrome",
  "        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum > w) return\
    \ false\n        if (rightSum > w) return false\n        if (leftSum != rightSum)\
    \ return false\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ right(half - 1 - i)) return false\n        }\n        return true", "      \
    \  val sum = q.sum\n        if (sum > w) return false\n        val qq = q.map(_.toString).mkString\n\
    \        val qqq = qq.reverse\n        return qq == qqq", "        // Write your\
    \ code here\n        true", "        if (q.length == 0) return true\n        if\
    \ (q.length == 1) return q(0) <= w\n        if (q.length == 2) return q(0) + q(1)\
    \ <= w\n        if (q.length % 2 == 0) return false\n        var sum = 0l\n  \
    \      for (i <- 0 until q.length) {\n            sum += q(i)\n            if\
    \ (sum > w) return false\n        }\n        var i = 0\n        var j = q.length\
    \ - 1\n        while (i < j) {\n            if (q(i) != q(j)) return false\n \
    \           i += 1\n            j -= 1\n        }\n        true", "        val\
    \ sum = q.sum\n        val isBalanced = q.reverse == q\n        sum <= w && isBalanced",
  "        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.foldLeft(0l)((a, b) => a + b)\n        val rightSum = right.foldLeft(0l)((a,\
    \ b) => a + b)\n        if (leftSum != rightSum) return false\n        val leftReverse\
    \ = left.reverse\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ leftReverse(i)) return false\n        }\n        if (leftSum > w) return false\n\
    \        return true", "        // Write your code here\n        if (q.length\
    \ == 0) return true\n        if (q.length == 1) return true\n        if (q.length\
    \ == 2) return q(0) == q(1)\n        if (q.length % 2 == 0) return false\n   \
    \     val mid = q.length / 2\n        val left = q.slice(0, mid)\n        val\
    \ right = q.slice(mid + 1, q.length)\n        val sum = q.sum\n        if (sum\
    \ > w) return false\n        if (left.sum != right.sum) return false\n       \
    \ return true", "        val sum = q.sum\n        val palindrome = q.reverse ==\
    \ q\n        palindrome && sum <= w", "        def isPalindrome(q : List[Long])\
    \ : Boolean = {\n            if (q.length == 1) return true\n            if (q.length\
    \ == 2) return q(0) == q(1)\n            if (q(0) == q(q.length - 1)) return isPalindrome(q.slice(1,\
    \ q.length - 1))\n            return false\n        }\n        if (isPalindrome(q))\
    \ {\n            var sum = 0l\n            for (x <- q) sum += x\n           \
    \ return sum <= w\n        }\n        return false"]
stop_tokens:
- "\n    }\n"
