language: scala
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- x) {\n     \
    \           if (c == '(') {\n                    current_nesting += 1\n      \
    \              max_nesting = max(max_nesting, current_nesting)\n             \
    \   } else if (c == ')') {\n                    current_nesting -= 1\n       \
    \         }\n            }\n            max_nesting\n        }).toList.map(x =>\
    \ x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var nesting_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  nesting_level += 1\n                    if (nesting_level > max_nesting_level)\
    \ {\n                        max_nesting_level = nesting_level\n             \
    \       }\n                } else if (paren == ')') {\n                    nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val max_nesting =\
    \ parens.map(x => {\n            var max_level = 0\n            var level = 0\n\
    \            for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        max_nesting.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxg0_jgyz.scala:24:20\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    depth += 1\n       \
    \             max_depth = max(max_depth, depth)\n                } else if (c\
    \ == ')') {\n                    depth -= 1\n                }\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (ch <-\
    \ group) {\n                if (ch == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (ch == ')') {\n                    current_level -= 1\n \
    \               }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l.toLong, 0l.toLong)((acc, c) =>\
    \ {\n            if (c == '(') (acc._1 + 1, max(acc._1 + 1, acc._2))\n       \
    \     else if (c == ')') (acc._1 - 1, acc._2)\n            else (acc._1, acc._2)\n\
    \        })._2)\n        paren_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result = result :+ max_depth\n        }\n        return result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var paren_levels\
    \ = List[Long]()\n        for (i <- 0 until paren_groups.length) {\n         \
    \   var paren_level = 0l\n            var max_paren_level = 0l\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    paren_level += 1\n                    if (paren_level\
    \ > max_paren_level) max_paren_level = paren_level\n                }\n      \
    \          else if (paren_groups(i)(j) == ')') {\n                    paren_level\
    \ -= 1\n                }\n            }\n            paren_levels = paren_levels\
    \ :+ max_paren_level\n        }\n        return paren_levels\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(s => {\n            var max_depth =\
    \ 0\n            var cur_depth = 0\n            for (c <- s) {\n             \
    \   if (c == '(') {\n                    cur_depth += 1\n                    max_depth\
    \ = max(max_depth, cur_depth)\n                } else if (c == ')') {\n      \
    \              cur_depth -= 1\n                }\n            }\n            max_depth\n\
    \        }).toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList, 0, 0)).toList\n  \
    \      paren_levels\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0wyx3ud.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList, \e[31m0\e[0m, \e[31m0\e[0m)).toList\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: parseNestedParensHelper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpo0wyx3ud.scala:11:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList, \e[31m0\e[0m, \e[31m0\e[0m)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                      No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m                                          where:    B is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (char <- group)\
    \ {\n                if (char == '(') {\n                    level += 1\n    \
    \                if (level > max_level) max_level = level\n                }\n\
    \                else if (char == ')') {\n                    level -= 1\n   \
    \             }\n            }\n            paren_levels += max_level\n      \
    \  }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        val max_nesting_list\
    \ = paren_list.map(x => {\n            var max_nesting = 0\n            var nesting\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') nesting += 1\n                else if (x(i) == ')') nesting -= 1\n    \
    \            if (nesting > max_nesting) max_nesting = nesting\n            }\n\
    \            max_nesting\n        })\n        max_nesting_list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6fftnlow.scala:21:8\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m        max_nesting_list\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (max_nesting_list : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       max_nesting_levels.map(x => if (x < 0) 0 else x).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb9skd4pb.scala:12:57\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        max_nesting_levels.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x < \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m x).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var max_nesting = 0\n        var\
    \ current_nesting = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_nesting += 1\n                max_nesting =\
    \ max(max_nesting, current_nesting)\n            } else if (c == ')') {\n    \
    \            current_nesting -= 1\n            } else if (c == ' ') {\n      \
    \          result = result :+ max_nesting\n                max_nesting = 0\n \
    \               current_nesting = 0\n            }\n        }\n        result\
    \ = result :+ max_nesting\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l)((acc, x) => if (x == '(') acc\
    \ + 1 else acc - 1)).toList\n        val paren_max_levels = paren_levels.map(x\
    \ => x.abs)\n        paren_max_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucrjs4ij.scala:16)\n\tat Problem.main(tmpucrjs4ij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(List[Long](0l.toLong))((acc, c) =>\
    \ {\n            if (c == '(') {\n                acc.head + 1l.toLong :: acc\n\
    \            } else {\n                acc.head - 1l.toLong :: acc\n         \
    \   }\n        }).reverse.tail)\n        paren_levels.map(x => x.max).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren <- parens) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0l\n            var max_level = 0l\n            for (c <- group) {\n\
    \                if (c == '(') {\n                    level += 1\n           \
    \         if (level > max_level) max_level = level\n                }\n      \
    \          else if (c == ')') {\n                    level -= 1\n            \
    \    }\n            }\n            paren_levels += max_level\n        }\n    \
    \    paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var current_level = 0\n            var max_level = 0\n \
    \           for (paren <- paren_group) {\n                if (paren == '(') current_level\
    \ += 1\n                else if (paren == ')') current_level -= 1\n          \
    \      if (current_level > max_level) max_level = current_level\n            }\n\
    \            result = result :+ max_level\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (i <- 0 until\
    \ group.length) {\n                if (group(i) == '(') {\n                  \
    \  depth += 1\n                    max_depth = max(max_depth, depth)\n       \
    \         } else if (group(i) == ')') {\n                    depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l)((acc, x) => if (x == '(') acc\
    \ + 1 else acc - 1)).toList\n        val max_levels = paren_levels.map(x => if\
    \ (x < 0) 0 else x)\n        max_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4zda6don.scala:16)\n\tat Problem.main(tmp4zda6don.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_nesting_level = 0\n            var current_nesting_level = 0\n\
    \            for (paren <- paren_group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           current_nesting_level -= 1\n                }\n            }\n   \
    \         max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            max_levels += max_level\n        }\n  \
    \      max_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_list\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_nesting\
    \ += 1\n                    if (current_nesting > max_nesting) max_nesting = current_nesting\n\
    \                }\n                else if (paren == ')') {\n               \
    \     current_nesting -= 1\n                }\n            }\n            max_nesting_list\
    \ += max_nesting\n        }\n        max_nesting_list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(paren_group => {\n            var max_level = 0\n       \
    \     var level = 0\n            for (i <- 0 until paren_group.length) {\n   \
    \             if (paren_group(i) == '(') {\n                    level += 1\n \
    \                   max_level = max(max_level, level)\n                } else\
    \ if (paren_group(i) == ')') {\n                    level -= 1\n             \
    \   }\n            }\n            max_level\n        }).toList\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm39bvde3.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_level\n        })\n        max_nesting_levels.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6i9_nb2j.scala:24:27\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            val paren_group = paren_groups(i)\n            var max_nesting =\
    \ 0\n            var current_nesting = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group(j) == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                } else if (paren_group(j) == ')') {\n                    current_nesting\
    \ -= 1\n                }\n            }\n            result += max_nesting\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_level = paren_levels.max\n        val max_level_index = paren_levels.indexOf(max_level)\n\
    \        val max_level_paren_group = paren_groups(max_level_index)\n        val\
    \ max_level_paren_group_levels = max_level_paren_group.map(x => if (x == '(')\
    \ 1 else -1).scanLeft(0)(_ + _).toList\n        val max_level_paren_group_max_level\
    \ = max_level_paren_group_levels.max\n        val max_level_paren_group_max_level_index\
    \ = max_level_paren_group_levels.indexOf(max_level_paren_group_max_level)\n  \
    \      val max_level_paren_group_max_level_paren_group = max_level_paren_group.substring(0,\
    \ max_level_paren_group_max_level_index + 1)\n        val max_level_paren_group_max_level_paren_group_levels\
    \ = max_level_paren_group_max_level_paren_group.map(x => if (x == '(') 1 else\
    \ -1).scanLeft(0)(_ + _).toList\n        val max_level_paren_group_max_level_paren_group_max_level\
    \ = max_level_paren_group_max_level_paren_group_levels.max\n        val max_level_paren_group_max_level_paren_group_max_level_index\
    \ = max_level_paren_group_max_level_paren_group_levels.indexOf(max_level_paren_group_max_level_paren_group_max_level)\n\
    \        val max_level_paren_group_max_level_paren_group_max_level_paren_group\
    \ = max_level_paren_group_max_level_paren_group.substring(0, max_level_paren_group_max_level_paren_group\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzmao6crt.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpzmao6crt.scala:22:137 -------------------\e[0m\e[0m\n\e[31m22 |\e[0m\
    \        \e[33mval\e[0m \e[36mmax_level_paren_group_max_level_paren_group_max_level_paren_group\e\
    [0m = max_level_paren_group_max_level_paren_group.substring(\e[31m0\e[0m, max_level_paren_group_max_level_paren_group\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    (max_level_paren_group_max_level_paren_group : String)\n\e[31m  \
    \ |\e[0m        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzmao6crt.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798031
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        val paren_groups = paren_string.split(\"\
    \ \")\n        for (group <- paren_groups) {\n            var max_level = 0\n\
    \            var current_level = 0\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    current_level += 1\n            \
    \        max_level = max(max_level, current_level)\n                } else if\
    \ (c == ')') {\n                    current_level -= 1\n                }\n  \
    \          }\n            result = result :+ max_level\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.foldLeft(0l)((acc, c) => if (c == '(') acc + 1 else\
    \ acc - 1))\n        val max_levels = paren_levels.map(x => abs(x))\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp81ggo1av.scala:16)\n\tat Problem.main(tmp81ggo1av.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups\n        val groups = paren_string.split(\"\
    \ \")\n        // For each group, find the maximum level of nesting\n        val\
    \ max_nesting = groups.map(group => {\n            var max_nesting = 0\n     \
    \       var current_nesting = 0\n            for (i <- 0 until group.length) {\n\
    \                if (group(i) == '(') {\n                    current_nesting +=\
    \ 1\n                    max_nesting = max(max_nesting, current_nesting)\n   \
    \             } else if (group(i) == ')') {\n                    current_nesting\
    \ -= 1\n                }\n            }\n            max_nesting\n        })\n\
    \        // Return the maximum level of nesting for each group\n        max_nesting.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb_rgyicl.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        max_nesting.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798031
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0l)((acc, c) => if (c == '(') acc\
    \ + 1 else if (c == ')') acc - 1 else acc)).toList\n        paren_levels\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpav2bvjfw.scala:15)\n\tat Problem.main(tmpav2bvjfw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (char <- group) {\n        \
    \        if (char == '(') {\n                    level += 1\n                \
    \    if (level > max_level) max_level = level\n                }\n           \
    \     else if (char == ')') {\n                    level -= 1\n              \
    \  }\n            }\n            result = result :+ max_level\n        }\n   \
    \     return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (ch <- group)\
    \ {\n                if (ch == '(') depth += 1\n                else if (ch ==\
    \ ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.foldLeft(0, 0)((acc, y) => {\n            if\
    \ (y == '(') (acc._1 + 1, max(acc._1 + 1, acc._2))\n            else if (y ==\
    \ ')') (acc._1 - 1, acc._2)\n            else acc\n        })._2)\n        paren_levels.map(x\
    \ => x.toLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_level = 0l\n            var level = 0l\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ level += 1\n                    if (level > max_level) max_level = level\n \
    \               }\n                else if (paren == ')') {\n                \
    \    level -= 1\n                }\n            }\n            paren_levels +=\
    \ max_level\n        }\n        paren_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var max_level = 0\n            var level = 0\n            for (c <- paren_group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        var level = 0\n            var max_level = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ level += 1\n                    if (level > max_level) max_level = level\n \
    \               }\n                else if (paren == ')') {\n                \
    \    level -= 1\n                }\n            }\n            paren_levels +=\
    \ max_level\n        }\n        paren_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result = result :+ max_depth\n        }\n        return result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var cur_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    cur_level += 1\n   \
    \                 max_level = max(max_level, cur_level)\n                } else\
    \ if (c == ')') {\n                    cur_level -= 1\n                }\n   \
    \         }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list = paren_string.split(\" \").toList\n        var result\
    \ = List[Long]()\n        for (paren <- paren_list) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (i <- 0 until paren.length)\
    \ {\n                if (paren(i) == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result = result :+ max_depth\n        }\n        return result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups of parentheses separated by spaces.\n\
    \        val paren_groups = paren_string.split(\" \")\n        // For each group,\
    \ find the maximum depth of nesting of parentheses.\n        paren_groups.map(group\
    \ => {\n            // Keep track of the maximum depth of nesting of parentheses.\n\
    \            var max_depth = 0\n            // Keep track of the current depth\
    \ of nesting of parentheses.\n            var current_depth = 0\n            //\
    \ Iterate through each character in the group.\n            for (c <- group) {\n\
    \                // If the character is an opening parenthesis, increment the\
    \ current depth of nesting.\n                if (c == '(') {\n               \
    \     current_depth += 1\n                    // Update the maximum depth of nesting\
    \ if the current depth is greater.\n                    if (current_depth > max_depth)\
    \ max_depth = current_depth\n                }\n                // If the character\
    \ is a closing parenthesis, decrement the current depth of nesting.\n        \
    \        else if (c == ')') current_depth -= 1\n            }\n            //\
    \ Return the maximum depth of nesting.\n            max_depth\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphvaf_6m4.scala:31:11\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_groups.map(\e[36mgroup\e\
    [0m => {\n\e[31m14 |\e[0m            \e[34m// Keep track of the maximum depth\
    \ of nesting of parentheses.\e[0m\n\e[31m15 |\e[0m            \e[33mvar\e[0m \e\
    [36mmax_depth\e[0m = \e[31m0\e[0m\n\e[31m16 |\e[0m            \e[34m// Keep track\
    \ of the current depth of nesting of parentheses.\e[0m\n\e[31m17 |\e[0m      \
    \      \e[33mvar\e[0m \e[36mcurrent_depth\e[0m = \e[31m0\e[0m\n\e[31m18 |\e[0m\
    \            \e[34m// Iterate through each character in the group.\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mfor\e[0m (c <- group) {\n\e[31m20 |\e[0m           \
    \     \e[34m// If the character is an opening parenthesis, increment the current\
    \ depth of nesting.\e[0m\n\e[31m21 |\e[0m                \e[33mif\e[0m (c == \e\
    [31m'('\e[0m) {\n\e[31m22 |\e[0m                    current_depth += \e[31m1\e\
    [0m\n\e[31m23 |\e[0m                    \e[34m// Update the maximum depth of nesting\
    \ if the current depth is greater.\e[0m\n\e[31m24 |\e[0m                    \e\
    [33mif\e[0m (current_depth > max_depth) max_depth = current_depth\n\e[31m25 |\e\
    [0m                }\n\e[31m26 |\e[0m                \e[34m// If the character\
    \ is a closing parenthesis, decrement the current depth of nesting.\e[0m\n\e[31m27\
    \ |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m')'\e[0m) current_depth\
    \ -= \e[31m1\e[0m\n\e[31m28 |\e[0m            }\n\e[31m29 |\e[0m            \e\
    [34m// Return the maximum depth of nesting.\e[0m\n\e[31m30 |\e[0m            max_depth\n\
    \e[31m31 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_depth = 0\n        var cur_depth = 0\n        var result\
    \ = List[Long]()\n        for (c <- paren_string) {\n            if (c == '(')\
    \ {\n                cur_depth += 1\n                max_depth = max(max_depth,\
    \ cur_depth)\n            } else if (c == ')') {\n                cur_depth -=\
    \ 1\n            } else if (c == ' ') {\n                result = result :+ max_depth\n\
    \                max_depth = 0\n                cur_depth = 0\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmposwkvdlq.scala:28)\n\tat Problem.main(tmposwkvdlq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_groups.length) {\n         \
    \   var max_depth = 0\n            var depth = 0\n            for (j <- 0 until\
    \ paren_groups(i).length) {\n                if (paren_groups(i)(j) == '(') depth\
    \ += 1\n                else if (paren_groups(i)(j) == ')') depth -= 1\n     \
    \           if (depth > max_depth) max_depth = depth\n            }\n        \
    \    result = result :+ max_depth\n        }\n        return result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_nesting = paren_groups.map(x => x.count(y => y == '(') + x.count(y\
    \ => y == ')'))\n        val paren_max_nesting = paren_nesting.map(x => x / 2)\n\
    \        val paren_levels_max_nesting = paren_levels.zip(paren_max_nesting).map(x\
    \ => x._1 + x._2)\n        paren_levels_max_nesting.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpevc2sa07.scala:15:33\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        paren_levels_max_nesting.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var max_depth\
    \ = 0\n        var depth = 0\n        var result = List[Long]()\n        for (group\
    \ <- paren_groups) {\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    depth += 1\n                    max_depth = max(max_depth,\
    \ depth)\n                } else if (c == ')') {\n                    depth -=\
    \ 1\n                }\n            }\n            result = result :+ max_depth.toLong\n\
    \            max_depth = 0\n            depth = 0\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var max_depth = 0\n            var depth = 0\n         \
    \   for (c <- paren_group) {\n                if (c == '(') depth += 1\n     \
    \           else if (c == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren <- parens) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_with_index = paren_levels.zipWithIndex\n        val paren_levels_with_index_filtered\
    \ = paren_levels_with_index.filter(x => x._1 >= 0)\n        val paren_levels_with_index_filtered_sorted\
    \ = paren_levels_with_index_filtered.sortBy(x => x._1)\n        val paren_levels_with_index_filtered_sorted_grouped\
    \ = paren_levels_with_index_filtered_sorted.groupBy(x => x._1)\n        val paren_levels_with_index_filtered_sorted_grouped_map\
    \ = paren_levels_with_index_filtered_sorted_grouped.map(x => x._2.map(y => y._2))\n\
    \        val paren_levels_with_index_filtered_sorted_grouped_map_sorted = paren_levels_with_index_filtered_sorted_grouped_map.toList.sortBy(x\
    \ => x.head)\n        val paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened\
    \ = paren_levels_with_index_filtered_sorted_grouped_map_sorted.flatten\n     \
    \   val paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map\
    \ = paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened.map(x\
    \ => paren_levels(x))\n        paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3tor1ab4.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mFound:    (paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map\
    \ : \n\e[31m   |\e[0m  List[Int]\n\e[31m   |\e[0m)\n\e[31m   |\e[0mRequired: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798041
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(x\
    \ => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_level += 1\n      \
    \              max_level = max(max_level, current_level)\n                } else\
    \ if (c == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            result = result :+ max_level\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (i <-\
    \ 0 until group.length) {\n                if (group(i) == '(') {\n          \
    \          current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (group(i) == ')') {\n            \
    \        current_depth -= 1\n                }\n            }\n            result\
    \ += max_depth\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var current_level = 0\n            var max_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else if (paren == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into multiple groups.\n        val groups = paren_string.split(\"\
    \ \")\n        // For each group, find the maximum depth of nesting.\n       \
    \ groups.map(group => {\n            // Keep track of the maximum depth of nesting.\n\
    \            var max_depth = 0\n            // Keep track of the current depth\
    \ of nesting.\n            var current_depth = 0\n            // For each character\
    \ in the group, update the current depth of nesting.\n            group.foreach(c\
    \ => {\n                c match {\n                    case '(' => current_depth\
    \ += 1\n                    case ')' => current_depth -= 1\n                }\n\
    \                // Update the maximum depth of nesting if the current depth is\
    \ greater.\n                if (current_depth > max_depth) max_depth = current_depth\n\
    \            })\n            // Return the maximum depth of nesting.\n       \
    \     max_depth\n        }).map(x => x.toLong).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    current_level += 1\n\
    \                    max_level = max(max_level, current_level)\n             \
    \   } else if (c == ')') {\n                    current_level -= 1\n         \
    \       }\n            }\n            result += max_level\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_stack = new Stack[Char]\n        val paren_max_levels = paren_groups.map(x\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (paren <- x) {\n                if (paren == '(') {\n          \
    \          paren_stack.push(paren)\n                    current_level += 1\n \
    \                   if (current_level > max_level) max_level = current_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     paren_stack.pop\n                    current_level -= 1\n              \
    \  }\n            }\n            max_level\n        })\n        paren_max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yc97apk.scala:29:25\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        paren_max_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798042
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_list = paren_string.split(\" \").toList\n        var result\
    \ = List[Long]()\n        for (paren <- paren_list) {\n            var stack =\
    \ Stack[Char]()\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') {\n     \
    \               stack.push(c)\n                    current_depth += 1\n      \
    \              if (current_depth > max_depth) max_depth = current_depth\n    \
    \            }\n                else if (c == ')') {\n                    if (stack.isEmpty)\
    \ throw new Exception(\"Invalid input\")\n                    stack.pop\n    \
    \                current_depth -= 1\n                }\n            }\n      \
    \      if (!stack.isEmpty) throw new Exception(\"Invalid input\")\n          \
    \  result = result :+ max_depth\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_level\n        })\n        paren_levels.toList.map(level => level.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result = max_depth :: result\n        }\n        return result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (paren <- group) {\n                if (paren ==\
    \ '(') depth += 1\n                else if (paren == ')') depth -= 1\n       \
    \         max_depth = max(max_depth, depth)\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (paren <-\
    \ group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            var paren_level = 0l\n            var max_paren_level = 0l\n    \
    \        for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') paren_level += 1\n                else if (paren_groups(i)(j) == ')')\
    \ paren_level -= 1\n                if (paren_level > max_paren_level) max_paren_level\
    \ = paren_level\n            }\n            paren_levels += max_paren_level\n\
    \        }\n        paren_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var stack\
    \ = Stack[Char]()\n            var max_depth = 0\n            var depth = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         stack.push(c)\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          stack.pop\n                    depth -= 1\n                }\n    \
    \        }\n            result = result :+ max_depth\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797850
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) max_level = current_level\n\
    \                }\n                else if (c == ')') {\n                   \
    \ current_level -= 1\n                }\n            }\n            max_nesting_levels\
    \ += max_level\n        }\n        max_nesting_levels.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the input string into groups of parentheses.\n        val\
    \ paren_groups = paren_string.split(\" \")\n        // For each group, find the\
    \ maximum nesting level.\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            // Keep track of the current nesting level.\n            var\
    \ current_nesting_level = 0\n            // Keep track of the maximum nesting\
    \ level.\n            var max_nesting_level = 0\n            // Iterate through\
    \ each character in the group.\n            for (i <- 0 until group.length) {\n\
    \                // If the character is an opening parenthesis, increase the current\
    \ nesting level.\n                if (group(i) == '(') {\n                   \
    \ current_nesting_level += 1\n                    // Update the maximum nesting\
    \ level if necessary.\n                    if (current_nesting_level > max_nesting_level)\
    \ max_nesting_level = current_nesting_level\n                }\n             \
    \   // If the character is a closing parenthesis, decrease the current nesting\
    \ level.\n                else if (group(i) == ')') current_nesting_level -= 1\n\
    \            }\n            // Return the maximum nesting level.\n           \
    \ max_nesting_level\n        })\n        // Return the maximum nesting levels.\n\
    \        max_nesting_levels.toList.map(level => level.toLong)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (c == ')') {\n  \
    \                  current_level -= 1\n                }\n            }\n    \
    \        max_level\n        })\n        max_nesting_levels.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8pk70ucy.scala:24:27\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val depths\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var depth = 0\n            var max_depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            depths += max_depth\n        }\n        depths.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_depth = 0\n            var depth = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') depth += 1\n                else if (paren_group(j) == ')') depth -=\
    \ 1\n                if (depth > max_depth) max_depth = depth\n            }\n\
    \            result = result :+ max_depth\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_counts = paren_groups.map(x => x.count(y => y == '('))\n   \
    \     val paren_levels_max = paren_levels.max\n        val paren_levels_min =\
    \ paren_levels.min\n        val paren_counts_max = paren_counts.max\n        val\
    \ paren_counts_min = paren_counts.min\n        val paren_levels_max_count = paren_levels.count(x\
    \ => x == paren_levels_max)\n        val paren_levels_min_count = paren_levels.count(x\
    \ => x == paren_levels_min)\n        val paren_counts_max_count = paren_counts.count(x\
    \ => x == paren_counts_max)\n        val paren_counts_min_count = paren_counts.count(x\
    \ => x == paren_counts_min)\n        val paren_levels_max_count_max = List(paren_levels_max_count,\
    \ paren_levels_min_count).max\n        val paren_counts_max_count_max = List(paren_counts_max_count,\
    \ paren_counts_min_count).max\n        val paren_levels_max_count_min = List(paren_levels_max_count,\
    \ paren_levels_min_count).min\n        val paren_counts_max_count_min = List(paren_counts_max_count,\
    \ paren_counts_min_count).min\n        List(paren_levels_max_count_max, paren_counts_max_count_max,\
    \ paren_levels_max_count_min, paren_counts_max_count_min).map(x => x.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9yo_w5jb.scala:28)\n\tat Problem.main(tmp9yo_w5jb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n        \
    \    var max_level = 0\n            var current_level = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (paren == ')') {\n                    current_level\
    \ -= 1\n                }\n            }\n            result += max_level\n  \
    \      }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ = result :+ max_depth\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    if (current_level > max_level) {\n               \
    \         max_level = current_level\n                    }\n                }\
    \ else if (c == ')') {\n                    current_level -= 1\n             \
    \   }\n            }\n            paren_levels += max_level\n        }\n     \
    \   paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798052
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         var level = 0\n            var max_level = 0\n            for (j <-\
    \ 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j) ==\
    \ '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren_groups(i)(j)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (ch <- group) {\n                if (ch == '(') {\n             \
    \       current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (ch == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wkm5grd.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp8wkm5grd.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        if (level > max_level) max_level = level\n                }\n       \
    \         else if (c == ')') {\n                    level -= 1\n             \
    \   }\n            }\n            paren_levels += max_level\n        }\n     \
    \   paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depth -= 1\n            } else if\
    \ (c == ' ') {\n                result = result :+ max_depth\n               \
    \ max_depth = 0\n                depth = 0\n            }\n        }\n       \
    \ result = result :+ max_depth\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_nesting_level = 0\n     \
    \       var current_nesting_level = 0\n            for (paren <- group) {\n  \
    \              if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList.map(level\
    \ => level.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_groups.length) {\n         \
    \   var max_nesting = 0\n            var current_nesting = 0\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') current_nesting += 1\n                else if (paren_groups(i)(j) ==\
    \ ')') current_nesting -= 1\n                if (current_nesting > max_nesting)\
    \ max_nesting = current_nesting\n            }\n            result = result :+\
    \ max_nesting\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var max_levels\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var current_level\
    \ = 0\n            var max_level = 0\n            for (paren <- group) {\n   \
    \             if (paren == '(') {\n                    current_level += 1\n  \
    \                  if (current_level > max_level) max_level = current_level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     current_level -= 1\n                }\n            }\n            max_levels\
    \ = max_levels :+ max_level\n        }\n        return max_levels\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                if (depth > max_depth) max_depth = depth\n     \
    \       }\n            result += max_depth\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var depth = 0\n            var max_depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    depth += 1\n       \
    \             max_depth = max(max_depth, depth)\n                } else if (c\
    \ == ')') {\n                    depth -= 1\n                }\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(x => {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (x(i) == ')') {\n\
    \                    current_depth -= 1\n                }\n            }\n  \
    \          max_depth\n        }).toList\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdt739y8e.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798053
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var current_level = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_level += 1\n      \
    \              max_level = max(max_level, current_level)\n                } else\
    \ if (c == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            result = result :+ max_level\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depth -= 1\n            } else if\
    \ (c == ' ') {\n                result = result :+ max_depth\n               \
    \ max_depth = 0\n                depth = 0\n            }\n        }\n       \
    \ result = result :+ max_depth\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result = result :+ max_depth\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') current_depth += 1\n               \
    \ else if (c == ')') current_depth -= 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var current_level = 0\n      \
    \  var max_level = 0\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                current_level += 1\n                max_level = max(max_level,\
    \ current_level)\n            } else if (c == ')') {\n                current_level\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_level\n                max_level = 0\n                current_level = 0\n\
    \            }\n        }\n        result = result :+ max_level\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren <- parens) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_depth\
    \ += 1\n                    max_depth = max(max_depth, current_depth)\n      \
    \          } else if (c == ')') {\n                    current_depth -= 1\n  \
    \              }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    current_nesting += 1\n  \
    \                  max_nesting = max(max_nesting, current_nesting)\n         \
    \       } else if (c == ')') {\n                    current_nesting -= 1\n   \
    \             }\n            }\n            result = result :+ max_nesting\n \
    \       }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            var max_depth =\
    \ 0\n            var current_depth = 0\n            for (c <- x) {\n         \
    \       if (c == '(') {\n                    current_depth += 1\n            \
    \        max_depth = max(max_depth, current_depth)\n                } else if\
    \ (c == ')') {\n                    current_depth -= 1\n                }\n  \
    \          }\n            max_depth\n        }).toList.map(x => x.toLong)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                if (depth > max_depth) max_depth = depth\n           \
    \ }\n            result += max_depth\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => parseNestedParensHelper(x)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5t7pdw10.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        paren_groups.map(\e[36mx\e[0m => parseNestedParensHelper(x)).toList\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: parseNestedParensHelper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp5t7pdw10.scala:11:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        paren_groups.map(\e[36mx\e[0m => parseNestedParensHelper(x)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') {\n                    level += 1\n              \
    \      max_level = max(max_level, level)\n                } else if (paren ==\
    \ ')') {\n                    level -= 1\n                }\n            }\n \
    \           result = result :+ max_level\n        }\n        return result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var max_depth = 0\n        var\
    \ depth = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n\
    \                depth += 1\n                max_depth = max(max_depth, depth)\n\
    \            } else if (c == ')') {\n                depth -= 1\n            }\
    \ else if (c == ' ') {\n                result = result :+ max_depth\n       \
    \         max_depth = 0\n                depth = 0\n            }\n        }\n\
    \        result = result :+ max_depth\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result =\
    \ result :+ max_depth\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(group\
    \ => {\n            var max_nesting = 0\n            var current_nesting = 0\n\
    \            for (c <- group) {\n                if (c == '(') current_nesting\
    \ += 1\n                else if (c == ')') current_nesting -= 1\n            \
    \    max_nesting = max(max_nesting, current_nesting)\n            }\n        \
    \    max_nesting\n        }).toList.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result = result :+ max_depth\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') {\n\
    \                    depth += 1\n                    max_depth = max(max_depth,\
    \ depth)\n                } else if (c == ')') {\n                    depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string by spaces.\n        val paren_groups = paren_string.split(\"\
    \ \")\n        // For each group, find the maximum nesting level.\n        val\
    \ max_nesting_levels = paren_groups.map(group => {\n            // Keep track\
    \ of the current nesting level.\n            var current_nesting_level = 0\n \
    \           // Keep track of the maximum nesting level.\n            var max_nesting_level\
    \ = 0\n            // Iterate over the characters in the group.\n            for\
    \ (character <- group) {\n                // If the character is a left parenthesis,\
    \ increment the current nesting level.\n                if (character == '(')\
    \ {\n                    current_nesting_level += 1\n                }\n     \
    \           // If the character is a right parenthesis, decrement the current\
    \ nesting level.\n                else if (character == ')') {\n             \
    \       current_nesting_level -= 1\n                }\n                // If the\
    \ current nesting level is greater than the maximum nesting level, update the\
    \ maximum nesting level.\n                if (current_nesting_level > max_nesting_level)\
    \ {\n                    max_nesting_level = current_nesting_level\n         \
    \       }\n            }\n            // Return the maximum nesting level.\n \
    \           max_nesting_level\n        })\n        // Return the list of maximum\
    \ nesting levels.\n        max_nesting_levels.toList.map(level => level.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        return paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7q2v18iz.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: parseNestedParensHelper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp7q2v18iz.scala:11:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x))\n\e[31m\e[31m   |\e[0m             \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659798054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n  \
    \      paren_max_levels.toList.map(x => x.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqyvxgu8l.scala:16)\n\tat Problem.main(tmpqyvxgu8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798056
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                max_level = max(max_level, level)\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n        \
    \    var max_depth = 0\n            var current_depth = 0\n            for (paren\
    \ <- paren_group) {\n                if (paren == '(') {\n                   \
    \ current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (paren == ')') {\n                    current_depth\
    \ -= 1\n                }\n            }\n            result += max_depth\n  \
    \      }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList, 0, 0))\n        paren_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp081p18rx.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList, \e[31m0\e[0m, \e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: parseNestedParensHelper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp081p18rx.scala:11:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_levels\e[0m = paren_groups.map(\e\
    [36mx\e[0m => parseNestedParensHelper(x.toList, \e[31m0\e[0m, \e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                      No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m                                          where:    B is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n   \
    \         var max_depth = 0\n            var current_depth = 0\n            for\
    \ (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                }\n                else if\
    \ (paren_groups(i)(j) == ')') {\n                    current_depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => {\n            var max_nesting_level = 0\n         \
    \   var current_nesting_level = 0\n            for (i <- 0 until x.length) {\n\
    \                if (x(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (x(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    }).toList\n        max_nesting_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuc73q6si.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        max_nesting_levels\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (max_nesting_levels : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (paren <- parens) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- paren) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result = result :+\
    \ max_depth\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798055
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val depths = new\
    \ ListBuffer[Long]()\n        for (group <- groups) {\n            var depth =\
    \ 0\n            var max_depth = 0\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            depths +=\
    \ max_depth\n        }\n        depths.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_max = paren_levels.map(x => if (x < 0) 0 else x)\n  \
    \      paren_levels_max.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ro8lqxj.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        paren_levels_max.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_level = 0\n            var level = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren_group(j)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result = result :+ max_level\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798058
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(s => {\n            var max_depth =\
    \ 0\n            var depth = 0\n            for (c <- s) {\n                if\
    \ (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n     \
    \           max_depth = max(max_depth, depth)\n            }\n            max_depth\n\
    \        }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwh8faztc.scala:19:11\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36ms\e[0m => {\n\e[31m11 |\e[0m            \e[33mvar\e\
    [0m \e[36mmax_depth\e[0m = \e[31m0\e[0m\n\e[31m12 |\e[0m            \e[33mvar\e\
    [0m \e[36mdepth\e[0m = \e[31m0\e[0m\n\e[31m13 |\e[0m            \e[33mfor\e[0m\
    \ (c <- s) {\n\e[31m14 |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e[0m)\
    \ depth += \e[31m1\e[0m\n\e[31m15 |\e[0m                \e[33melse\e[0m \e[33mif\e\
    [0m (c == \e[31m')'\e[0m) depth -= \e[31m1\e[0m\n\e[31m16 |\e[0m             \
    \   max_depth = max(max_depth, depth)\n\e[31m17 |\e[0m            }\n\e[31m18\
    \ |\e[0m            max_depth\n\e[31m19 |\e[0m        }).toList\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e\
    [0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798058
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var current_level = 0\n            for (c <-\
    \ group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            result += max_level\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') depth += 1\n                else if (c == ')')\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Write your code here\n        var result = List[Long]()\n    \
    \    var stack = Stack[Char]()\n        for (c <- paren_string) {\n          \
    \  if (c == '(') {\n                stack.push(c)\n            } else if (c ==\
    \ ')') {\n                stack.pop()\n            } else if (c == ' ') {\n  \
    \              result = result :+ stack.size\n            }\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7v81qdv5.scala:25)\n\tat Problem.main(tmp7v81qdv5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdrqp7mmz.scala:13:19\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        max_levels.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_depth = 0\n            var depth = 0\n            for (c <- group) {\n \
    \               if (c == '(') depth += 1\n                else if (c == ')') depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n\
    \                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (x(i) == ')') {\n                \
    \    current_level -= 1\n                }\n            }\n            max_level\n\
    \        }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzhxlyurx.scala:23:11\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_groups.map(\e[36mx\e\
    [0m => {\n\e[31m12 |\e[0m            \e[33mvar\e[0m \e[36mmax_level\e[0m = \e\
    [31m0\e[0m\n\e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mcurrent_level\e[0m\
    \ = \e[31m0\e[0m\n\e[31m14 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m\
    \ until x.length) {\n\e[31m15 |\e[0m                \e[33mif\e[0m (x(i) == \e\
    [31m'('\e[0m) {\n\e[31m16 |\e[0m                    current_level += \e[31m1\e\
    [0m\n\e[31m17 |\e[0m                    max_level = max(max_level, current_level)\n\
    \e[31m18 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (x(i) == \e[31m')'\e\
    [0m) {\n\e[31m19 |\e[0m                    current_level -= \e[31m1\e[0m\n\e[31m20\
    \ |\e[0m                }\n\e[31m21 |\e[0m            }\n\e[31m22 |\e[0m     \
    \       max_level\n\e[31m23 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m   \
    \     ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m\
    \   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798058
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')')).map(x\
    \ => abs(x)).toList\n        return max_nesting_levels\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0hc66beb.scala:12:15\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m max_nesting_levels\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \              Found:    (max_nesting_levels : List[Int])\n\e[31m   |\e[0m   \
    \            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798058
