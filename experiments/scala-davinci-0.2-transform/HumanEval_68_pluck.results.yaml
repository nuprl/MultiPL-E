language: scala
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var min = Long.MaxValue\n        var minIndex = Long.MaxValue\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \       }\n        }\n        if (min == Long.MaxValue) return List[Long]()\n\
    \        return List[Long](min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List[Long]()\n        else List[Long](min.toLong, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n    \
    \    else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n\
    \        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                index = i\n            }\n      \
    \  }\n        if (index != -1) {\n            result = List(min, index.toLong)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.length == 0) return List[Long]()\n       \
    \ val min = evens.min\n        val index = arr.indexOf(min)\n        List[Long](min,\
    \ index.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min : Long = Long.MaxValue\n\
    \        var minIndex : Long = -1\n        for (i <- 0 until arr.length) {\n \
    \           if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n\
    \                minIndex = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You have to return a list of Long\n        // You can add helper\
    \ functions as needed\n        var minEven = Long.MaxValue\n        var minEvenIndex\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0 && arr(i) < minEven) {\n                minEven = arr(i)\n               \
    \ minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1)\
    \ return List()\n        return List(minEven, minEvenIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        var min = Long.MaxValue\n        var minIndex = -1\n       \
    \ for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) <\
    \ min) {\n                min = arr(i)\n                minIndex = i\n       \
    \     }\n        }\n        if (min == Long.MaxValue) return List()\n        return\
    \ List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n\
    \        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n    \
    \        if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven =\
    \ arr(i)\n                minEvenIndex = i\n            }\n        }\n       \
    \ if (minEvenIndex == -1) return List[Long]()\n        return List[Long](minEven,\
    \ minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        List(min, index.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n\
    \        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n    \
    \        if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven =\
    \ arr(i)\n                minEvenIndex = i\n            }\n        }\n       \
    \ if (minEven == Long.MaxValue) return List()\n        return List(minEven, minEvenIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0)\
    \ {\n            return List[Long]()\n        }\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) {\n            return List[Long]()\n        }\n        return List[Long](min,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        var min = Long.MaxValue\n        var minIndex = -1\n       \
    \ for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) <\
    \ min) {\n                min = arr(i)\n                minIndex = i\n       \
    \     }\n        }\n        if (minIndex == -1) return List()\n        return\
    \ List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var minEven = Long.MaxValue\n        var minEvenIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < minEven)\
    \ {\n                minEven = arr(i)\n                minEvenIndex = i\n    \
    \        }\n        }\n        if (minEvenIndex == -1) return List()\n       \
    \ return List(minEven, minEvenIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var minIndex = 10001\n        var flag = false\n  \
    \      for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i).toInt\n                minIndex = i\n\
    \                flag = true\n            }\n        }\n        if (flag) {\n\
    \            List(min, minIndex)\n        } else {\n            List()\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0)\
    \ return List()\n        var min = Long.MaxValue\n        var minIndex = -1\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \       }\n        }\n        if (minIndex == -1) return List()\n        return\
    \ List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // 'arr' is an array of non-negative integers\n        // 'arr'\
    \ is a tree branch\n        // Return a list of two elements, the first element\
    \ is the smallest even value,\n        // the second element is the index of the\
    \ smallest even value\n        // If there are no even values or the given array\
    \ is empty, return [].\n        // If multiple nodes with the same smallest even\
    \ value are found return the node that has smallest index.\n        var evens\
    \ = List[Long]()\n        var index = 0\n        for (i <- arr) {\n          \
    \  if (i % 2 == 0) {\n                evens = evens :+ i\n            }\n    \
    \        index += 1\n        }\n        if (evens.isEmpty) {\n            return\
    \ List[Long]()\n        }\n        var min = evens.min\n        var minIndex =\
    \ arr.indexOf(min)\n        return List[Long](min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    val value = arr(i)\n            if (value % 2 == 0 && value < min) {\n  \
    \              min = value\n                minIndex = i\n            }\n    \
    \    }\n        if (minIndex == -1) List() else List(min, minIndex)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n        \
    \    val min = evens.min\n            val index = arr.indexOf(min)\n         \
    \   List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List()\n        else List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) return List[Long]()\n        return List[Long](min, minIndex.toLong)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0)\
    \ return List[Long]()\n        val evens = arr.filter(_ % 2 == 0)\n        if\
    \ (evens.length == 0) return List[Long]()\n        val min = evens.min\n     \
    \   val index = arr.indexOf(min)\n        List[Long](min, index.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // 'pluck' has one parameter:\n        // arr: List[Long]\n  \
    \      // 'pluck' must return a List[Long]\n        var result : List[Long] =\
    \ List()\n        var min : Long = Long.MaxValue\n        var index : Long = -1\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                index = i\n        \
    \    }\n        }\n        if (index != -1) {\n            result = List(min,\
    \ index)\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var min = Long.MaxValue\n        var minIndex = -1\n \
    \       for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \       }\n        }\n        if (minIndex == -1) return List[Long]()\n      \
    \  return List[Long](min, minIndex.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List[Long]()\n        else List[Long](min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n    \
    \    else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    val x = arr(i)\n            if (x % 2 == 0 && x < min) {\n              \
    \  min = x\n                minIndex = i\n            }\n        }\n        if\
    \ (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List[Long]()\n        else List[Long](min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) {\n            List()\n        } else\
    \ {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List[Long]()\n        else List[Long](min.toLong, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinsnga4z.scala:34)\n\tat Problem.main(tmpinsnga4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) List()\n    \
    \    else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        var min = Long.MaxValue\n        var minIndex = -1\n       \
    \ for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) <\
    \ min) {\n                min = arr(i)\n                minIndex = i\n       \
    \     }\n        }\n        if (minIndex == -1) return List()\n        return\
    \ List(min, minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List[Long]()\n        else List[Long](min, index.toLong)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ if (arr.isEmpty) return List[Long]()\n        var min = Long.MaxValue\n    \
    \    var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if\
    \ (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n        \
    \        minIndex = i\n            }\n        }\n        if (minIndex == -1) return\
    \ List[Long]()\n        return List[Long](min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List[Long]()\n        else List[Long](min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List()\n        else List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min =\
    \ evens.min\n        val index = arr.indexOf(min)\n        return List(min, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List[Long]()\n        else List[Long](min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ return List[Long]()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        return List[Long](min, index.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ if (arr.isEmpty) return List[Long]()\n        val evens = arr.filter(x => x\
    \ % 2 == 0)\n        if (evens.isEmpty) return List[Long]()\n        val min =\
    \ evens.min\n        val index = arr.indexOf(min)\n        List[Long](min, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = 0\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (min == Long.MaxValue) List()\n        else List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n\
    \        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n    \
    \        if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven =\
    \ arr(i)\n                minEvenIndex = i\n            }\n        }\n       \
    \ if (minEvenIndex == -1) List()\n        else List(minEven, minEvenIndex)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List()\n        else List(min, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.length == 0) return List[Long]()\n       \
    \ val min = evens.min\n        val index = arr.indexOf(min)\n        List[Long](min,\
    \ index.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List[Long]()\n        else {\n  \
    \          val min = evens.min\n            val index = arr.indexOf(min)\n   \
    \         List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var evens = ListBuffer[Long]()\n        var evensIndex = ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                evens += arr(i)\n                evensIndex += i\n          \
    \  }\n        }\n        if (evens.length == 0) {\n            return List[Long]()\n\
    \        }\n        var min = evens(0)\n        var minIndex = evensIndex(0)\n\
    \        for (i <- 1 until evens.length) {\n            if (evens(i) < min) {\n\
    \                min = evens(i)\n                minIndex = evensIndex(i)\n  \
    \          }\n        }\n        return List[Long](min, minIndex)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty)\
    \ return List[Long]()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        return List(min, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001l\n        var min_index = 10001\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                min_index = i\n            }\n        }\n        if\
    \ (min == 10001) {\n            List[Long]()\n        } else {\n            List[Long](min,\
    \ min_index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty)\
    \ return List[Long]()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        List[Long](min, index.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var min = Long.MaxValue\n        var minIndex = -1\n \
    \       for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \       }\n        }\n        if (minIndex == -1) return List[Long]()\n      \
    \  return List[Long](min, minIndex.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min =\
    \ evens.min\n        val index = arr.indexOf(min)\n        List(min, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var min = Long.MaxValue\n        var minIndex = -1\n \
    \       for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \       }\n        }\n        if (minIndex == -1) return List[Long]()\n      \
    \  return List[Long](min, minIndex.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var result = List[Long]()\n        var min = Long.MaxValue\n        var index\
    \ = 0\n        var i = 0\n        for (i <- 0 until arr.length) {\n          \
    \  if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n    \
    \            index = i\n            }\n        }\n        if (min != Long.MaxValue)\
    \ {\n            result = List(min, index)\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ if (arr.isEmpty) return List[Long]()\n        val evens = arr.filter(_ % 2 ==\
    \ 0)\n        if (evens.isEmpty) return List[Long]()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List[Long](min, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = 10001l.toLong\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\n\
    \        else List(min, index.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // `0` is the place holder for the smallest even value\n     \
    \   // `1` is the place holder for the index of the smallest even value\n    \
    \    List[Long](0l.toLong, 1l.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qhyvytz.scala:36)\n\tat Problem.main(tmp0qhyvytz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List[Long]()\n        else List[Long](min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        var min = Long.MaxValue\n        var index = -1\n        for (i\
    \ <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                index = i\n            }\n    \
    \    }\n        if (index == -1) List()\n        else List(min, index)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var min : Long = Long.MaxValue\n        var minIndex :\
    \ Long = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) %\
    \ 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                minIndex\
    \ = i\n            }\n        }\n        if (min == Long.MaxValue) return List[Long]()\n\
    \        return List[Long](min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List[Long]()\n        var minEven = Long.MaxValue\n        var minEvenIndex\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0 && arr(i) < minEven) {\n                minEven = arr(i)\n               \
    \ minEvenIndex = i\n            }\n        }\n        if (minEvenIndex == -1)\
    \ return List[Long]()\n        return List[Long](minEven, minEvenIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // 'pluck' has one parameter:\n        // arr: List[Long]\n  \
    \      // 'pluck' must return a List[Long]\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\n\
    \        else List(min, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var minEven = -1\n        var minEvenIndex = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0) {\n                if (minEven == -1 ||\
    \ arr(i) < minEven) {\n                    minEven = arr(i).toInt\n          \
    \          minEvenIndex = i\n                }\n            }\n        }\n   \
    \     if (minEven == -1) List()\n        else List(minEven, minEvenIndex)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ arr.zipWithIndex.filter(x => x._1 % 2 == 0).sortBy(x => (x._1, x._2)).headOption.map(x\
    \ => List(x._1, x._2)).getOrElse(List())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuypihwjv.scala:32:125\
    \ -------------------\e[0m\e[0m\n\e[31m32 |\e[0m        arr.zipWithIndex.filter(\e\
    [36mx\e[0m => x._1 % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(\e[36mx\e[0m => (x._1,\
    \ x._2)).headOption.map(\e[36mx\e[0m => List(x._1, x._2)).getOrElse(List())\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // `0` is the place holder for the smallest even value\n     \
    \   // `1` is the place holder for the index of the smallest even value\n    \
    \    var result = List[Long](0l.toLong, 1l.toLong)\n        var smallestEvenValue\
    \ = Long.MaxValue\n        var smallestEvenValueIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < smallestEvenValue)\
    \ {\n                smallestEvenValue = arr(i)\n                smallestEvenValueIndex\
    \ = i\n            }\n        }\n        if (smallestEvenValueIndex != -1) {\n\
    \            result = List[Long](smallestEvenValue, smallestEvenValueIndex.toLong)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphtv2asv3.scala:50)\n\tat Problem.main(tmphtv2asv3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 1000000000000l\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val idx = arr.indexOf(min)\n            List(min,\
    \ idx)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinsnga4z.scala:34)\n\tat Problem.main(tmpinsnga4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val idx = arr.indexOf(min)\n            List(min,\
    \ idx)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) return List()\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    val x = arr(i)\n            if (x % 2 == 0 && x < min) {\n              \
    \  min = x\n                minIndex = i\n            }\n        }\n        if\
    \ (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        var min = Long.MaxValue\n        var index = -1\n        for (i\
    \ <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                index = i\n            }\n    \
    \    }\n        if (index == -1) return List()\n        return List(min, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List[Long]()\n        else List[Long](min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List[Long]()\n        else {\n       \
    \     val min = evens.min\n            val index = arr.indexOf(min)\n        \
    \    List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(_\
    \ % 2 == 0)\n        if (even.isEmpty) List()\n        else {\n            val\
    \ min = even.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min =\
    \ evens.min\n        val index = arr.indexOf(min)\n        return List(min, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) return List()\n        val min = evens.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) return\
    \ List()\n        else return List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinsnga4z.scala:34)\n\tat Problem.main(tmpinsnga4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You have to return a list of Long\n        // The first element\
    \ should be the smallest even value\n        // The second element should be the\
    \ index of the smallest even value\n        // If there are no even values or\
    \ the given array is empty, return List[Long]()\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List[Long]()\n\
    \        else List[Long](min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0)\
    \ return List[Long]()\n        var min = Long.MaxValue\n        var index = -1\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                index = i\n        \
    \    }\n        }\n        if (index == -1) return List[Long]()\n        List[Long](min,\
    \ index.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = -1l\n   \
    \     var minIndex = -1\n        var index = 0\n        for (i <- arr) {\n   \
    \         if (i % 2 == 0) {\n                if (min == -1 || i < min) {\n   \
    \                 min = i\n                    minIndex = index\n            \
    \    }\n            }\n            index += 1\n        }\n        if (min == -1)\
    \ List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // 'pluck' has one parameter:\n        // arr: List[Long]\n  \
    \      // 'pluck' must return a List[Long]\n        if (arr.isEmpty) {\n     \
    \       return List[Long]()\n        }\n        var min = Long.MaxValue\n    \
    \    var minIndex = -1\n        for (i <- 0 until arr.length) {\n            if\
    \ (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n        \
    \        minIndex = i\n            }\n        }\n        if (minIndex == -1) {\n\
    \            return List[Long]()\n        }\n        return List[Long](min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ return List[Long]()\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvinqq3we.scala:35)\n\tat Problem.main(tmpvinqq3we.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n            val\
    \ min = evens.min\n            val index = arr.indexOf(min)\n            List(min,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty) {\n    \
    \        List[Long]()\n        } else {\n            val min = evens.min\n   \
    \         val index = arr.indexOf(min)\n            List[Long](min, index.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinsnga4z.scala:34)\n\tat Problem.main(tmpinsnga4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n\
    \        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n    \
    \        if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven =\
    \ arr(i)\n                minEvenIndex = i\n            }\n        }\n       \
    \ if (minEvenIndex == -1) return List()\n        return List(minEven, minEvenIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEven = Long.MaxValue\n\
    \        var minEvenIndex = -1\n        for (i <- 0 until arr.length) {\n    \
    \        if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven =\
    \ arr(i)\n                minEvenIndex = i\n            }\n        }\n       \
    \ if (minEvenIndex == -1) List()\n        else List(minEven, minEvenIndex)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty)\
    \ return List()\n        val min = evens.min\n        val index = arr.indexOf(min)\n\
    \        List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var result = List[Long]()\n        var min = Long.MaxValue\n        var index\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0 && arr(i) < min) {\n                min = arr(i)\n                index =\
    \ i\n            }\n        }\n        if (index != -1) {\n            result\
    \ = List(min, index)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        return List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpinsnga4z.scala:34)\n\tat Problem.main(tmpinsnga4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = arr.filter(x => x % 2 == 0).min\n        if (min == Long.MaxValue)\
    \ return List()\n        var idx = arr.indexOf(min)\n        List(min, idx)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpv5_gfle3.scala:32)\n\tat Problem$.main(tmpv5_gfle3.scala:40)\n\
    \tat Problem.main(tmpv5_gfle3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var result : List[Long]\
    \ = List()\n        var minEven : Long = Long.MaxValue\n        var minEvenIndex\
    \ : Long = Long.MaxValue\n        for (i <- 0 until arr.length) {\n          \
    \  if (arr(i) % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n\
    \                minEvenIndex = i\n            }\n        }\n        if (minEven\
    \ != Long.MaxValue) {\n            result = List(minEven, minEvenIndex)\n    \
    \    }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = 10001\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i).toInt\n                index = i\n            }\n        }\n        if\
    \ (index == -1) List[Long]()\n        else List[Long](min.toLong, index.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List[Long]()\n        else {\n  \
    \          val min = evens.min\n            val index = arr.indexOf(min)\n   \
    \         List(min, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) return List[Long]()\n        return List[Long](min, minIndex)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var result = List[Long]()\n        var min = 10001\n        var index = -1\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i).toInt\n                index = i\n  \
    \          }\n        }\n        if (index != -1) {\n            result = List(min,\
    \ index)\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    val v = arr(i)\n            if (v % 2 == 0 && v < min) {\n              \
    \  min = v\n                minIndex = i\n            }\n        }\n        if\
    \ (minIndex == -1) List() else List(min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List()\n        else List(min, minIndex.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ if (arr.isEmpty) {\n            return List()\n        }\n        var min =\
    \ Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                minIndex = i\n            }\n        }\n        if (minIndex\
    \ == -1) {\n            return List()\n        }\n        return List(min, minIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n        \
    \    val min = evens.min\n            val index = arr.indexOf(min)\n         \
    \   List(min, index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) {\n            List[Long]()\n   \
    \     } else {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            List[Long](min, index.toLong)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var evens = List[Long]()\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0) {\n                evens = evens :+ arr(i)\n       \
    \     }\n        }\n        if (evens.length == 0) {\n            return List[Long]()\n\
    \        }\n        var min = evens(0)\n        var minIndex = 0\n        for\
    \ (i <- 0 until evens.length) {\n            if (evens(i) < min) {\n         \
    \       min = evens(i)\n                minIndex = i\n            }\n        }\n\
    \        return List[Long](min, minIndex.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpka6l1avu.scala:53)\n\tat Problem.main(tmpka6l1avu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List[Long]()\n        else List[Long](min, index.toLong)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var result = List[Long]()\n        var min = Long.MaxValue\n        var index\
    \ = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0 && arr(i) < min) {\n                min = arr(i)\n                index =\
    \ i\n            }\n        }\n        if (index != -1) {\n            result\
    \ = List(min, index.toLong)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\
    \ else List(min, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) return List()\n        return List(min, minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n        \
    \        min = arr(i)\n                minIndex = i\n            }\n        }\n\
    \        if (minIndex == -1) List()\n        else List(min, minIndex)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) {\n\
    \            return List[Long]()\n        }\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) {\n            return List[Long]()\n        }\n        return List[Long](min,\
    \ minIndex.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = 10001l.toLong\n\
    \        var index = -1\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n     \
    \           index = i\n            }\n        }\n        if (index == -1) List()\n\
    \        else List(min, index.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) List() else List(min, minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var min = Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) List()\n        else List(min, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798619
