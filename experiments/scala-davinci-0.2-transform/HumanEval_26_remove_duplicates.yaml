name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val map = new HashMap[Long, Int]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n    \
    \    for (number <- numbers) {\n            if (map(number) == 1) result += number\n\
    \        }\n        result.toList", "        val set = new HashSet[Long]\n   \
    \     val result = new ListBuffer[Long]\n        for (number <- numbers) {\n \
    \           if (!set.contains(number)) {\n                set += number\n    \
    \            result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", '        numbers.distinct', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) {\n                map(number) += 1\n  \
    \          } else {\n                map(number) = 1\n            }\n        }\n\
    \        numbers.filter(number => map(number) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var map = Map[Long, Int]()\n        for (number <- numbers) {\n      \
    \      if (map.contains(number)) {\n                map(number) += 1\n       \
    \     } else {\n                map(number) = 1\n            }\n        }\n  \
    \      for (number <- numbers) {\n            if (map(number) == 1) {\n      \
    \          result = result :+ number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                result = result :+ number\n  \
    \              set = set + number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                result = result :+ number\n  \
    \              set += number\n            }\n        }\n        result", "   \
    \     var result : List[Long] = List()\n        var set : Set[Long] = Set()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        return result", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (n\
    \ <- numbers) {\n            if (!set.contains(n)) {\n                result =\
    \ result :+ n\n                set = set + n\n            }\n        }\n     \
    \   result", "        var result : List[Long] = List()\n        var set : Set[Long]\
    \ = Set()\n        for (i <- numbers) {\n            if (!set.contains(i)) {\n\
    \                result = result :+ i\n                set = set + i\n       \
    \     }\n        }\n        return result", '        numbers.distinct', "    \
    \    val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n   \
    \         if (map.contains(number)) {\n                map(number) += 1\n    \
    \        } else {\n                map(number) = 1\n            }\n        }\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (map(number) == 1) {\n                result += number\n     \
    \       }\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (n <- numbers) {\n   \
    \         if (!set.contains(n)) {\n                set += n\n                result\
    \ += n\n            }\n        }\n        result.toList", "        val map = new\
    \ HashMap[Long, Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        val map\
    \ = new HashMap[Long, Int]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) {\n                map(number) += 1\n            } else\
    \ {\n                map(number) = 1\n            }\n        }\n        var result\
    \ = List[Long]()\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) {\n                result = number :: result\n            }\n        }\n\
    \        result.reverse", "        var result = List[Long]()\n        var set\
    \ = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var map = Map[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (i <-\
    \ numbers) {\n            if (!set.contains(i)) {\n                set += i\n\
    \                result += i\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]()\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set += number\n            }\n        }\n\
    \        result", "        // TODO: Implement this method\n        return List[Long]()",
  "        val map = new HashMap[Long, Int]()\n        for (n <- numbers) {\n    \
    \        map.put(n, map.getOrElse(n, 0) + 1)\n        }\n        numbers.filter(n\
    \ => map(n) == 1)", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        numbers.filter(number => map(number)\
    \ == 1)", "        val map = new HashMap[Long, Int]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n    \
    \    for (number <- numbers) {\n            if (map(number) == 1) result += number\n\
    \        }\n        result.toList", "        numbers.foldLeft(Map[Long, Int]())((m,\
    \ n) => {\n            m + (n -> (m.getOrElse(n, 0) + 1))\n        }).filter(p\
    \ => p._2 == 1).map(p => p._1).toList", "        val map = new HashMap[Long, Int]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", "        var map\
    \ = Map[Long, Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        var result\
    \ = List[Long]()\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result = number :: result\n        }\n        result.reverse", "     \
    \   var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (n <- numbers) {\n            if (map.contains(n)) map(n)\
    \ += 1\n            else map(n) = 1\n        }\n        numbers.filter(n => map(n)\
    \ == 1)", "        val map = new HashMap[Long, Int]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        numbers.filter(number => map(number) ==\
    \ 1)", '        numbers.distinct', "        var map = Map[Long, Int]()\n     \
    \   for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", '        numbers.distinct',
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Int]()\n       \
    \ for (n <- numbers) {\n            if (map.contains(n)) map(n) += 1\n       \
    \     else map(n) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (n <- numbers) {\n            if (map(n) == 1) result += n\n    \
    \    }\n        result.toList", "        val set = new HashSet[Long]\n       \
    \ val result = new ListBuffer[Long]\n        for (number <- numbers) {\n     \
    \       if (!set.contains(number)) {\n                set += number\n        \
    \        result += number\n            }\n        }\n        result.toList", " \
    \       var result = List[Long]()\n        var set = Set[Long]()\n        for\
    \ (number <- numbers) {\n            if (!set.contains(number)) {\n          \
    \      result = result :+ number\n                set += number\n            }\n\
    \        }\n        result", "        val numbersSet = numbers.toSet\n       \
    \ numbersSet.toList", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (n <- numbers) {\n            if (!set.contains(n))\
    \ {\n                set += n\n                result += n\n            }\n  \
    \      }\n        result.toList", "        val map = new HashMap[Long, Int]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.distinct', " \
    \       val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", '        numbers.distinct', "        var\
    \ result = List[Long]()\n        var map = Map[Long, Boolean]()\n        for (number\
    \ <- numbers) {\n            if (!map.contains(number)) {\n                result\
    \ = result :+ number\n                map += (number -> true)\n            }\n\
    \        }\n        result", '        numbers.distinct', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.distinct', " \
    \       val map = new HashMap[Long, Int]()\n        for (n <- numbers) {\n   \
    \         if (map.contains(n)) map(n) += 1\n            else map(n) = 1\n    \
    \    }\n        var result = List[Long]()\n        for (n <- numbers) {\n    \
    \        if (map(n) == 1) result = n :: result\n        }\n        result.reverse",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = new HashMap[Long, Int]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) {\n\
    \                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        val result = new ListBuffer[Long]\n \
    \       for (number <- numbers) {\n            if (map(number) == 1) {\n     \
    \           result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        numbers.foreach(n => {\n    \
    \        if (map.contains(n)) map(n) += 1\n            else map(n) = 1\n     \
    \   })\n        numbers.filter(n => map(n) == 1)", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        val map = new HashMap[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", '        numbers.toSet.toList', " \
    \       var result = List[Long]()\n        for (number <- numbers) {\n       \
    \     if (!result.contains(number)) {\n                result = result :+ number\n\
    \            }\n        }\n        result", "        val map = new HashMap[Long,\
    \ Boolean]()\n        numbers.foreach(x => map.put(x, true))\n        map.keys.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", '        numbers.distinct', '        numbers.distinct',
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", '        numbers.foldLeft(List[Long]())((acc, x) => if
    (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (n <- numbers) {\n   \
    \         if (!set.contains(n)) {\n                set += n\n                result\
    \ += n\n            }\n        }\n        result.toList", "        val set = new\
    \ HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        var result = new ListBuffer[Long]()\n        var\
    \ set = new HashSet[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                result += number\n              \
    \  set += number\n            }\n        }\n        result.toList", "        val\
    \ map = new HashMap[Long, Int]\n        for (number <- numbers) {\n          \
    \  if (map.contains(number)) map(number) += 1\n            else map(number) =\
    \ 1\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", '        numbers.distinct', "    \
    \    val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var map = new HashMap[Long, Boolean]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) {\n\
    \                map.put(number, false)\n            } else {\n              \
    \  map.put(number, true)\n            }\n        }\n        var result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map.get(number).get) {\n \
    \               result += number\n            }\n        }\n        return result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        var result = List[Long]()\n        var map =\
    \ Map[Long, Int]()\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        for (number <- numbers) {\n         \
    \   if (map(number) == 1) {\n                result = result :+ number\n     \
    \       }\n        }\n        result", "        var result = List[Long]()\n  \
    \      var set = Set[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                result = result :+ number\n     \
    \           set = set + number\n            }\n        }\n        result", " \
    \       var result = List[Long]()\n        var set = Set[Long]()\n        for\
    \ (number <- numbers) {\n            if (!set.contains(number)) {\n          \
    \      result = result :+ number\n                set = set + number\n       \
    \     }\n        }\n        result", "        var result = List[Long]()\n    \
    \    var set = Set[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                result = result :+ number\n     \
    \           set += number\n            }\n        }\n        result", "      \
    \  var map = Map[Long, Int]()\n        for (number <- numbers) {\n           \
    \ if (map.contains(number)) {\n                map(number) += 1\n            }\
    \ else {\n                map(number) = 1\n            }\n        }\n        var\
    \ result = List[Long]()\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) {\n                result = number :: result\n            }\n        }\n\
    \        result.reverse", "        val map = new HashMap[Long, Int]\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) map(number) +=\
    \ 1\n            else map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  '        numbers.distinct', "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (n <- numbers) {\n            if (map.contains(n)) map(n)\
    \ += 1\n            else map(n) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (n <- numbers) {\n            if (map(n) == 1) result += n\n    \
    \    }\n        result.toList", "        var result = List[Long]()\n        var\
    \ set = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var map = HashMap[Long, Int]()\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) {\n                map(number) += 1\n  \
    \          } else {\n                map(number) = 1\n            }\n        }\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) {\n    \
    \            result = result :+ number\n            }\n        }\n        result",
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        val map = new HashMap[Long, Int]()\n        for (number <-\
    \ numbers) {\n            if (map.contains(number)) map(number) += 1\n       \
    \     else map(number) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x)) acc else
    acc :+ x)', "        val map = new HashMap[Long, Long]\n        for (number <-\
    \ numbers) {\n            if (map.contains(number)) map(number) += 1\n       \
    \     else map(number) = 1\n        }\n        var result = List[Long]()\n   \
    \     for (number <- numbers) {\n            if (map(number) == 1) result = number\
    \ :: result\n        }\n        result.reverse", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        var set = new HashSet[Long]()\n\
    \        var list = new ListBuffer[Long]()\n        for (n <- numbers) {\n   \
    \         if (!set.contains(n)) {\n                set += n\n                list\
    \ += n\n            }\n        }\n        list.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) result += number\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.toSet.toList',
  '        numbers.distinct', "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", '        numbers.distinct', "        var\
    \ result = List[Long]()\n        var set = Set[Long]()\n        for (number <-\
    \ numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val map = new HashMap[Long, Long]\n        for\
    \ (n <- numbers) {\n            if (map.contains(n)) {\n                map(n)\
    \ += 1\n            } else {\n                map(n) = 1\n            }\n    \
    \    }\n        numbers.filter(n => map(n) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.distinct', "        val map = new HashMap[Long, Int]()\n      \
    \  for (n <- numbers) {\n            if (map.contains(n)) map(n) += 1\n      \
    \      else map(n) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (n <- numbers) {\n            if (map(n) == 1) result += n\n    \
    \    }\n        result.toList", "        // Fill in the code here\n        return\
    \ null", "        var map = new HashMap[Long, Int]()\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        var result = new ListBuffer[Long]()\n  \
    \      for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        numbers.filter(number => map(number) == 1)", "     \
    \   var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set += number\n            }\n        }\n\
    \        result", "        // TODO: Implement this method\n        return List[Long]()",
  "        var set = Set[Long]()\n        var result = List[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result = number :: result\n            }\n      \
    \  }\n        result.reverse", "        var result = List[Long]()\n        var\
    \ set = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        val map = new HashMap[Long,\
    \ Int]()\n        for (i <- numbers) {\n            if (map.contains(i)) map(i)\
    \ += 1\n            else map(i) = 1\n        }\n        numbers.filter(i => map(i)\
    \ == 1)", '        numbers.foldLeft(List[Long]())((acc, x) => if (acc.contains(x))
    acc else acc :+ x)', "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.foldLeft(List[Long]())((list, number) => if (list.contains(number))
    list else list :+ number)', "        var map = Map[Long, Int]()\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", '        numbers.distinct',
  '        numbers.distinct', "        var uniqueNumbers = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (!uniqueNumbers.contains(number))\
    \ {\n                uniqueNumbers += number\n            }\n        }\n     \
    \   uniqueNumbers.toList", '        numbers.foldLeft(List[Long]())((acc, x) =>
    if (acc.contains(x)) acc else acc :+ x)', "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ map(number) += 1\n            else map(number) = 1\n        }\n        numbers.filter(number\
    \ => map(number) == 1)", "        var result = List[Long]()\n        var set =\
    \ Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        var hash = HashMap[Long, Int]()\n        for (number <- numbers) {\n\
    \            if (hash.contains(number)) {\n                hash(number) += 1\n\
    \            } else {\n                hash(number) = 1\n            }\n     \
    \   }\n        for (number <- numbers) {\n            if (hash(number) == 1) {\n\
    \                result = result :+ number\n            }\n        }\n       \
    \ result", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var map = Map[Long, Long]()\n\
    \        for (i <- numbers) {\n            if (map.contains(i)) map(i) += 1\n\
    \            else map(i) = 1\n        }\n        var result = List[Long]()\n \
    \       for (i <- numbers) {\n            if (map(i) == 1) result = i :: result\n\
    \        }\n        result.reverse", "        val map = new HashMap[Long, Boolean]\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) {\n\
    \                map += (number -> false)\n            } else {\n            \
    \    map += (number -> true)\n            }\n        }\n        val result = new\
    \ ListBuffer[Long]\n        for (number <- numbers) {\n            if (map(number))\
    \ {\n                result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (i\
    \ <- numbers) {\n            if (!set.contains(i)) {\n                result =\
    \ result :+ i\n                set = set + i\n            }\n        }\n     \
    \   result", "        var result : List[Long] = List()\n        var seen : Set[Long]\
    \ = Set()\n        for (number <- numbers) {\n            if (!seen.contains(number))\
    \ {\n                result = result :+ number\n                seen = seen +\
    \ number\n            }\n        }\n        return result", "        val set =\
    \ new HashSet[Long]\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                set\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", "        val map = new HashMap[Long, Int]\n        for (number\
    \ <- numbers) {\n            if (map.contains(number)) map(number) += 1\n    \
    \        else map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result +=\
    \ number\n        }\n        result.toList", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set += number\n            }\n        }\n\
    \        result", "        var result = List[Long]()\n        var set = Set[Long]()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set += number\n  \
    \          }\n        }\n        result", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  '        numbers.distinct', "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (n <- numbers) {\n            if (!set.contains(n))\
    \ {\n                set += n\n                result += n\n            }\n  \
    \      }\n        result.toList", "        var result = List[Long]()\n       \
    \ var set = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set += number\n\
    \            }\n        }\n        result", "        var map = Map[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (map.contains(number)) map(number)\
    \ += 1\n            else map(number) = 1\n        }\n        var result = List[Long]()\n\
    \        for (number <- numbers) {\n            if (map(number) == 1) result =\
    \ number :: result\n        }\n        result.reverse", "        val map = new\
    \ HashMap[Long, Int]\n        for (i <- numbers) {\n            if (map.contains(i))\
    \ {\n                map(i) += 1\n            } else {\n                map(i)\
    \ = 1\n            }\n        }\n        val list = new ListBuffer[Long]\n   \
    \     for (i <- numbers) {\n            if (map(i) == 1) {\n                list\
    \ += i\n            }\n        }\n        list.toList", "        val map = new\
    \ HashMap[Long, Int]()\n        for (n <- numbers) {\n            if (map.contains(n))\
    \ map(n) += 1\n            else map(n) = 1\n        }\n        val result = new\
    \ ListBuffer[Long]()\n        for (n <- numbers) {\n            if (map(n) ==\
    \ 1) result += n\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (n\
    \ <- numbers) {\n            if (!set.contains(n)) {\n                result =\
    \ result :+ n\n                set = set + n\n            }\n        }\n     \
    \   result", "        val map = HashMap[Long, Int]()\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) {\n                map(number) += 1\n\
    \            } else {\n                map(number) = 1\n            }\n      \
    \  }\n        val result = ListBuffer[Long]()\n        for (number <- numbers)\
    \ {\n            if (map(number) == 1) {\n                result += number\n \
    \           }\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (n <- numbers) {\n            if (!set.contains(n))\
    \ {\n                result = result :+ n\n                set = set + n\n   \
    \         }\n        }\n        result", "        val unique = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!unique.contains(number)) {\n                unique += number\n\
    \                result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var seen = Set[Long]()\n        for\
    \ (number <- numbers) {\n            if (!seen.contains(number)) {\n         \
    \       result = result :+ number\n                seen = seen + number\n    \
    \        }\n        }\n        result", "        val set = new HashSet[Long]()\n\
    \        val result = new ListBuffer[Long]()\n        for (n <- numbers) {\n \
    \           if (!set.contains(n)) {\n                set += n\n              \
    \  result += n\n            }\n        }\n        result.toList", "        val\
    \ map = new HashMap[Long, Int]\n        for (number <- numbers) {\n          \
    \  if (map.contains(number)) {\n                map(number) += 1\n           \
    \ } else {\n                map(number) = 1\n            }\n        }\n      \
    \  val result = new ListBuffer[Long]\n        for (number <- numbers) {\n    \
    \        if (map(number) == 1) {\n                result += number\n         \
    \   }\n        }\n        result.toList", "        val map = new HashMap[Long,\
    \ Int]\n        for (number <- numbers) {\n            if (map.contains(number))\
    \ {\n                map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        numbers.filter(number => map(number)\
    \ == 1)", "        var result = List[Long]()\n        var hash = HashMap[Long,\
    \ Int]()\n        for (i <- numbers) {\n            if (hash.contains(i)) {\n\
    \                hash(i) += 1\n            } else {\n                hash += (i\
    \ -> 1)\n            }\n        }\n        for (i <- numbers) {\n            if\
    \ (hash(i) == 1) {\n                result = result :+ i\n            }\n    \
    \    }\n        result", "        val set = new HashSet[Long]()\n        val result\
    \ = new ListBuffer[Long]()\n        for (number <- numbers) {\n            if\
    \ (!set.contains(number)) {\n                set += number\n                result\
    \ += number\n            }\n        }\n        result.toList", "        var map\
    \ = Map[Long, Long]()\n        for (n <- numbers) {\n            if (map.contains(n))\
    \ {\n                map(n) += 1\n            } else {\n                map(n)\
    \ = 1\n            }\n        }\n        var result = List[Long]()\n        for\
    \ (n <- numbers) {\n            if (map(n) == 1) {\n                result = n\
    \ :: result\n            }\n        }\n        result.reverse", "        val set\
    \ = new HashSet[Long]\n        val result = new ListBuffer[Long]\n        for\
    \ (number <- numbers) {\n            if (!set.contains(number)) {\n          \
    \      set += number\n                result += number\n            }\n      \
    \  }\n        result.toList", '        numbers.distinct', '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)', "        var map = Map[Long, Int]()\n\
    \        for (n <- numbers) {\n            if (map.contains(n)) map(n) += 1\n\
    \            else map(n) = 1\n        }\n        var result = List[Long]()\n \
    \       for (n <- numbers) {\n            if (map(n) == 1) result = n :: result\n\
    \        }\n        result.reverse", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- numbers) {\n            if (map.contains(i)) map(i) += 1\n\
    \            else map(i) = 1\n        }\n        val result = new ListBuffer[Long]()\n\
    \        for (i <- numbers) {\n            if (map(i) == 1) result += i\n    \
    \    }\n        result.toList", "        var result = List[Long]()\n        var\
    \ set = Set[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        result", "        var result : List[Long] =\
    \ List[Long]()\n        var map : Map[Long, Int] = Map[Long, Int]()\n        for\
    \ (number <- numbers) {\n            if (map.contains(number)) {\n           \
    \     map(number) += 1\n            } else {\n                map(number) = 1\n\
    \            }\n        }\n        for (number <- numbers) {\n            if (map(number)\
    \ == 1) {\n                result = result :+ number\n            }\n        }\n\
    \        return result", "        val set = new HashSet[Long]\n        val result\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        val numbersSet = numbers.toSet\n\
    \        val numbersMap = numbers.groupBy(identity).mapValues(_.size)\n      \
    \  val numbersList = numbersSet.toList\n        val numbersListFiltered = numbersList.filter(numbersMap(_)\
    \ == 1)\n        numbersListFiltered", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (number\
    \ <- numbers) {\n            if (!set.contains(number)) {\n                result\
    \ = result :+ number\n                set = set + number\n            }\n    \
    \    }\n        result", "        val hash = HashMap[Long, Int]()\n        for\
    \ (n <- numbers) {\n            if (hash.contains(n)) hash(n) += 1\n         \
    \   else hash(n) = 1\n        }\n        numbers.filter(n => hash(n) == 1)", " \
    \       val map = new HashMap[Long, Int]\n        for (n <- numbers) {\n     \
    \       if (map.contains(n)) map(n) += 1\n            else map += (n -> 1)\n \
    \       }\n        numbers.filter(n => map(n) == 1)", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set += number\n            }\n        }\n        result", "  \
    \      var result = List[Long]()\n        var map = Map[Long, Int]()\n       \
    \ for (number <- numbers) {\n            if (map.contains(number)) {\n       \
    \         map(number) += 1\n            } else {\n                map(number)\
    \ = 1\n            }\n        }\n        for (number <- numbers) {\n         \
    \   if (map(number) == 1) {\n                result = result :+ number\n     \
    \       }\n        }\n        result", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        var m = Map[Long, Int]()\n        for (n <- numbers) {\n            if\
    \ (m.contains(n)) m(n) += 1\n            else m(n) = 1\n        }\n        var\
    \ result = List[Long]()\n        for (n <- numbers) {\n            if (m(n) ==\
    \ 1) result = n :: result\n        }\n        result.reverse", "        val map\
    \ = new HashMap[Long, Int]\n        for (number <- numbers) {\n            if\
    \ (map.contains(number)) map(number) += 1\n            else map(number) = 1\n\
    \        }\n        numbers.filter(map(_) == 1)", '        numbers.distinct',
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", "        val numbersSet = new HashSet[Long]\n       \
    \ val result = new ListBuffer[Long]\n        for (number <- numbers) {\n     \
    \       if (!numbersSet.contains(number)) {\n                numbersSet += number\n\
    \                result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (n <- numbers) {\n      \
    \      if (map.contains(n)) map(n) += 1\n            else map(n) = 1\n       \
    \ }\n        numbers.filter(n => map(n) == 1)"]
stop_tokens:
- "\n    }\n"
