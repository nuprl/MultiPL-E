name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val map = new HashMap[Long, Int]\n        for (number <- numbers)\
    \ {\n            if (map.contains(number)) map(number) += 1\n            else\
    \ map(number) = 1\n        }\n        val result = new ListBuffer[Long]\n    \
    \    for (number <- numbers) {\n            if (map(number) == 1) result += number\n\
    \        }\n        result.toList", "        val set = new HashSet[Long]\n   \
    \     val result = new ListBuffer[Long]\n        for (number <- numbers) {\n \
    \           if (!set.contains(number)) {\n                set += number\n    \
    \            result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) map(number) += 1\n            else map(number)\
    \ = 1\n        }\n        val result = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            if (map(number) == 1) result += number\n        }\n\
    \        result.toList", '        numbers.distinct', "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n \
    \           if (map.contains(number)) {\n                map(number) += 1\n  \
    \          } else {\n                map(number) = 1\n            }\n        }\n\
    \        numbers.filter(number => map(number) == 1)", "        val set = new HashSet[Long]\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (!set.contains(number)) {\n                set += number\n   \
    \             result += number\n            }\n        }\n        result.toList",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var map = Map[Long, Int]()\n        for (number <- numbers) {\n      \
    \      if (map.contains(number)) {\n                map(number) += 1\n       \
    \     } else {\n                map(number) = 1\n            }\n        }\n  \
    \      for (number <- numbers) {\n            if (map(number) == 1) {\n      \
    \          result = result :+ number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                result = result :+ number\n  \
    \              set = set + number\n            }\n        }\n        result",
  "        val set = new HashSet[Long]\n        val result = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                result += number\n           \
    \ }\n        }\n        result.toList", "        var result = List[Long]()\n \
    \       var set = Set[Long]()\n        for (number <- numbers) {\n           \
    \ if (!set.contains(number)) {\n                result = result :+ number\n  \
    \              set += number\n            }\n        }\n        result", "   \
    \     var result : List[Long] = List()\n        var set : Set[Long] = Set()\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                result = result :+ number\n                set = set + number\n\
    \            }\n        }\n        return result", "        var result = List[Long]()\n\
    \        var set = Set[Long]()\n        for (number <- numbers) {\n          \
    \  if (!set.contains(number)) {\n                result = result :+ number\n \
    \               set = set + number\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var set = Set[Long]()\n        for (n\
    \ <- numbers) {\n            if (!set.contains(n)) {\n                result =\
    \ result :+ n\n                set = set + n\n            }\n        }\n     \
    \   result", "        var result : List[Long] = List()\n        var set : Set[Long]\
    \ = Set()\n        for (i <- numbers) {\n            if (!set.contains(i)) {\n\
    \                result = result :+ i\n                set = set + i\n       \
    \     }\n        }\n        return result", '        numbers.distinct', "    \
    \    val map = new HashMap[Long, Int]\n        for (number <- numbers) {\n   \
    \         if (map.contains(number)) {\n                map(number) += 1\n    \
    \        } else {\n                map(number) = 1\n            }\n        }\n\
    \        val result = new ListBuffer[Long]\n        for (number <- numbers) {\n\
    \            if (map(number) == 1) {\n                result += number\n     \
    \       }\n        }\n        result.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (acc.contains(x)) acc else acc :+ x)']
stop_tokens:
- "\n    }\n"
