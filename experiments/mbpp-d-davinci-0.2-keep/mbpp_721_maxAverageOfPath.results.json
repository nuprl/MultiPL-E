{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp60b1h8l6.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp60b1h8l6.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp60b1h8l6.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp60b1h8l6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmptn2fbtl7.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmptn2fbtl7.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmptn2fbtl7.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptn2fbtl7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tlong[][] dp = new long[cost.length][cost[0].length];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < cost.length; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < cost[0].length; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < cost.length; i++)\n\t\tfor (int j = 1; j < cost[0].length; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn (float)dp[cost.length - 1][cost[0].length - 1] / (cost.length + cost[0].length - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp8_6okzf_.d(18): Error: C style cast illegal, use `cast(float)dp[cost.length - 1][cost[0].length - 1]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8_6okzf_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmperfhj8mo.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmperfhj8mo.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmperfhj8mo.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperfhj8mo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmphhq8lm41.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmphhq8lm41.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmphhq8lm41.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphhq8lm41.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++) \n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++) \n\t\tfor (int j = 1; j < n; j++) \n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp7572tn7w.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7572tn7w.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7572tn7w.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7572tn7w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpiwa4q440.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpiwa4q440.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpiwa4q440.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwa4q440.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp18nkh78f.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp18nkh78f.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp18nkh78f.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18nkh78f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n-1][n-1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmplykq32x0.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmplykq32x0.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmplykq32x0.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplykq32x0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpscuva_k1.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpscuva_k1.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpscuva_k1.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscuva_k1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpn008kzch.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpn008kzch.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpn008kzch.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn008kzch.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tdp[i][j] = cost[i][j] + max(dp[i-1][j], dp[i][j-1]);\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpg6tdhqag.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpg6tdhqag.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpg6tdhqag.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg6tdhqag.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpvrlrsxq3.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpvrlrsxq3.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpvrlrsxq3.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvrlrsxq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp73wcr5vy.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp73wcr5vy.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp73wcr5vy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73wcr5vy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\t\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpj5ysvxvd.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpj5ysvxvd.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpj5ysvxvd.d(23): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj5ysvxvd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7s03hulu.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7s03hulu.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7s03hulu.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s03hulu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    int n = cost.length;\n    float[][] dp = new float[n][n];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < n; i++) \n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < n; i++) \n    {\n        for (int j = 1; j < n; j++) \n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpux3e_euk.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpux3e_euk.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpux3e_euk.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpux3e_euk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\t// Write your code here\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 3);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpclmrp6r0.d(10): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpclmrp6r0.d(11): Error: variable `n` cannot be read at compile time\n/tmp/tmpclmrp6r0.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpclmrp6r0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpykthn5_3.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpykthn5_3.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpykthn5_3.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykthn5_3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tlong[][] dp = new long[cost.length][cost.length];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < cost.length; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < cost.length; i++)\n\t{\n\t\tfor (int j = 1; j < cost.length; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn (float)dp[cost.length - 1][cost.length - 1] / (2 * cost.length - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpwy7m18ov.d(23): Error: C style cast illegal, use `cast(float)dp[cost.length - 1][cost.length - 1]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwy7m18ov.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmptn2fbtl7.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmptn2fbtl7.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmptn2fbtl7.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptn2fbtl7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpo24eu5ws.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpo24eu5ws.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpo24eu5ws.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo24eu5ws.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    int n = cost.length;\n    float[][] dp = new float[n][n];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < n; i++) \n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < n; i++) \n    {\n        for (int j = 1; j < n; j++) \n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpux3e_euk.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpux3e_euk.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpux3e_euk.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpux3e_euk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpscuva_k1.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpscuva_k1.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpscuva_k1.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscuva_k1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp73wcr5vy.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp73wcr5vy.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp73wcr5vy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73wcr5vy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmperfhj8mo.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmperfhj8mo.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmperfhj8mo.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperfhj8mo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpscuva_k1.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpscuva_k1.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpscuva_k1.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscuva_k1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tlong[][] dp = new long[cost.length][cost.length];\n\tdp[0][0] = cost[0][0];\n\t\n\tfor(int i = 1; i < cost.length; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < cost.length; i++)\n\t{\n\t\tfor(int j = 1; j < cost.length; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn (float)dp[cost.length - 1][cost.length - 1] / (2 * cost.length - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp12ervzvh.d(26): Error: C style cast illegal, use `cast(float)dp[cost.length - 1][cost.length - 1]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp12ervzvh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    int n = cost.length;\n    float[][] dp = new float[n][n];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < n; i++) \n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < n; i++) \n    {\n        for (int j = 1; j < n; j++) \n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpux3e_euk.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpux3e_euk.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpux3e_euk.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpux3e_euk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp1advv1_4.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp1advv1_4.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp1advv1_4.d(23): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1advv1_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7s03hulu.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7s03hulu.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7s03hulu.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s03hulu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    long[][] dp = new long[cost.length][cost.length];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < cost.length; i++) \n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < cost.length; i++) \n    {\n        for (int j = 1; j < cost.length; j++) \n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length - 1][cost.length - 1] / (2.0 * cost.length - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmptn2lux4f.d(9): Error: variable `cost` cannot be read at compile time\n/tmp/tmptn2lux4f.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptn2lux4f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpulv52f81.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpulv52f81.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpulv52f81.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpulv52f81.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpscuva_k1.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpscuva_k1.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpscuva_k1.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscuva_k1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; ++i) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; ++i) \n\t{\n\t\tfor (int j = 1; j < n; ++j) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpqs1z_a70.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpqs1z_a70.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpqs1z_a70.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqs1z_a70.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp73wcr5vy.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp73wcr5vy.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp73wcr5vy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73wcr5vy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++) \n\t{\n\t\tfor(int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpuoy2xpyr.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpuoy2xpyr.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpuoy2xpyr.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuoy2xpyr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmptn2fbtl7.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmptn2fbtl7.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmptn2fbtl7.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptn2fbtl7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp73wcr5vy.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp73wcr5vy.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp73wcr5vy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73wcr5vy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpscuva_k1.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpscuva_k1.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpscuva_k1.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpscuva_k1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7j_gapx9.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7j_gapx9.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7j_gapx9.d(19): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7j_gapx9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7s03hulu.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7s03hulu.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7s03hulu.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s03hulu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\tfor(int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpo24eu5ws.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpo24eu5ws.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpo24eu5ws.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo24eu5ws.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp57li3okl.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp57li3okl.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp57li3okl.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57li3okl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tint m = cost[0].length;\n\tfloat[][] dp = new float[n][m];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int j = 1; j < m; j++) \n\t{\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < m; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][m - 1] / (n + m - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpqgfn54tf.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpqgfn54tf.d(10): Error: cannot implicitly convert expression `cost[0].length` of type `ulong` to `int`\n/tmp/tmpqgfn54tf.d(11): Error: variable `n` cannot be read at compile time\n/tmp/tmpqgfn54tf.d(25): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgfn54tf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\tfor (int i = 1; i < n; i++)\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp73wcr5vy.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp73wcr5vy.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp73wcr5vy.d(18): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73wcr5vy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tlong[][] dp = new long[cost.length][cost.length];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < cost.length; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < cost.length; i++) \n\t{\n\t\tfor (int j = 1; j < cost.length; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[cost.length - 1][cost.length - 1] / (cost.length * cost.length);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp5w21wod2.d(9): Error: variable `cost` cannot be read at compile time\n/tmp/tmp5w21wod2.d(20): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5w21wod2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpzm05g_2g.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpzm05g_2g.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpzm05g_2g.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzm05g_2g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpn008kzch.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpn008kzch.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpn008kzch.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn008kzch.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tlong[][] dp = new long[cost.length][cost[0].length];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < cost.length; i++)\n\t{\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < cost[0].length; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t}\n\tfor(int i = 1; i < cost.length; i++)\n\t{\n\t\tfor(int j = 1; j < cost[0].length; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn (float)dp[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpe9ul192i.d(26): Error: C style cast illegal, use `cast(float)dp[cost.length - 1][cost[0].length - 1]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9ul192i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\t\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\t\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpqp6y_8kk.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpqp6y_8kk.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpqp6y_8kk.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqp6y_8kk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7s03hulu.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7s03hulu.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7s03hulu.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s03hulu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\t// Write your code here\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp1da51xj8.d(10): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp1da51xj8.d(11): Error: variable `n` cannot be read at compile time\n/tmp/tmp1da51xj8.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1da51xj8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpw2zmph_5.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpw2zmph_5.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpw2zmph_5.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw2zmph_5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\t\n\tdp[0][0] = cost[0][0];\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\t\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\t\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmp60b1h8l6.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp60b1h8l6.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp60b1h8l6.d(24): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp60b1h8l6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmptn2fbtl7.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmptn2fbtl7.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmptn2fbtl7.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptn2fbtl7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 1; j < n; j++)\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmp7j_gapx9.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmp7j_gapx9.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmp7j_gapx9.d(19): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7j_gapx9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = cost[i][j] + max(dp[i - 1][j], dp[i][j - 1]);\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmptxatn0er.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmptxatn0er.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmptxatn0er.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptxatn0er.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    int n = cost.length;\n    float[][] dp = new float[n][n];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < n; i++) \n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < n; i++) \n    {\n        for (int j = 1; j < n; j++) \n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpux3e_euk.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpux3e_euk.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpux3e_euk.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpux3e_euk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n    int n = cost.length;\n    float[][] dp = new float[n][n];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i < n; i++)\n    {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (int i = 1; i < n; i++)\n    {\n        for (int j = 1; j < n; j++)\n        {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpik6bphw0.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpik6bphw0.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpik6bphw0.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpik6bphw0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\t// Write your code here\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1]/(2*n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1666124036,
      "stdout": "",
      "stderr": "/tmp/tmpoha5x0ax.d(10): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpoha5x0ax.d(11): Error: variable `n` cannot be read at compile time\n/tmp/tmpoha5x0ax.d(22): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoha5x0ax.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tdp[0][i] = dp[0][i - 1] + cost[0][i];\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0];\n\t}\n\tfor (int i = 1; i < n; i++) \n\t{\n\t\tfor (int j = 1; j < n; j++) \n\t\t{\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n - 1][n - 1] / (2 * n - 1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmpt9nv7i7j.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmpt9nv7i7j.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmpt9nv7i7j.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt9nv7i7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\n/*\n\n\tGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\t\n*/\nfloat maxAverageOfPath(long[][] cost) \n{\n\tint n = cost.length;\n\tfloat[][] dp = new float[n][n];\n\tdp[0][0] = cost[0][0];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tfor(int j = 1; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1] / (2*n-1);\n}\nunittest\n{\n    alias candidate = maxAverageOfPath;\n\n    assert(candidate([[1L, 2L, 3L], [6L, 5L, 4L], [7L, 3L, 9L]]) == 5.2);\n    assert(candidate([[2L, 3L, 4L], [7L, 6L, 5L], [8L, 4L, 10L]]) == 6.2);\n    assert(candidate([[3L, 4L, 5L], [8L, 7L, 6L], [9L, 5L, 11L]]) == 7.2);\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]) == 5.8);\n}\nvoid main(){}",
      "timestamp": 1665517225,
      "stdout": "",
      "stderr": "/tmp/tmperfhj8mo.d(9): Error: cannot implicitly convert expression `cost.length` of type `ulong` to `int`\n/tmp/tmperfhj8mo.d(10): Error: variable `n` cannot be read at compile time\n/tmp/tmperfhj8mo.d(21): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperfhj8mo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}