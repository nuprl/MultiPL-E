{
  "name": "mbpp_4_heap_queue_largest",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\n\t\n*/\nlong[] heap_queue_largest(long[] nums, long n) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = heap_queue_largest;\n\n    assert(candidate([25L, 35L, 22L, 85L, 14L, 65L, 75L, 22L, 58L], 3L) == [85L, 75L, 65L]);\n    assert(candidate([25L, 35L, 22L, 85L, 14L, 65L, 75L, 22L, 58L], 2L) == [85L, 75L]);\n    assert(candidate([25L, 35L, 22L, 85L, 14L, 65L, 75L, 22L, 58L], 5L) == [85L, 75L, 65L, 58L, 35L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[nums.length];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_sift_down(heap, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theapify_up(heap, heap_size - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theapify_down(heap, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach_reverse(i; 0..n)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theapify_down(heap, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\theap[i] = nums[i];\n\t}\n\t\n\tfor (long i = n / 2 - 1; i >= 0; i--)\n\t{\n\t\theapify(heap, n, i);\n\t}\n\t\n\tfor (long i = n; i < nums.length; i++)\n\t{\n\t\tif (nums[i] > heap[0])\n\t\t{\n\t\t\theap[0] = nums[i];\n\t\t\theapify(heap, n, 0);\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. heap_size)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_sift_down(heap, 0, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[nums.length];\n\tlong heap_size = 0;\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach_reverse(i; 0 .. heap_size)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_sift_down(heap, 0, heap_size - 1);\n\t\theap_size--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] heap;\n\tlong i;\n\tlong j;\n\tlong temp;\n\t\n\tif (n == 0)\n\t{\n\t\treturn [];\n\t}\n\t\n\theap = nums[0..n];\n\t\n\tfor (i = n / 2; i >= 0; i--)\n\t{\n\t\tj = i;\n\t\twhile (j < n)\n\t\t{\n\t\t\tif (2 * j + 1 < n && heap[2 * j + 1] > heap[j])\n\t\t\t{\n\t\t\t\ttemp = heap[j];\n\t\t\t\theap[j] = heap[2 * j + 1];\n\t\t\t\theap[2 * j + 1] = temp;\n\t\t\t\tj = 2 * j + 1;\n\t\t\t}\n\t\t\telse if (2 * j + 2 < n && heap[2 * j + 2] > heap[j])\n\t\t\t{\n\t\t\t\ttemp = heap[j];\n\t\t\t\theap[j] = heap[2 * j + 2];\n\t\t\t\theap[2 * j + 2] = temp;\n\t\t\t\tj = 2 * j + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = n; i < nums.length; i++)\n\t{\n\t\tif (nums[i] > heap[0])\n\t\t{\n\t\t\theap[0] = nums[i];\n\t\t\tj = 0;\n\t\t\twhile (j < n)\n\t\t\t{\n\t\t\t\tif (2 * j + 1 < n && heap[2 * j + 1] > heap[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = heap[j];\n\t\t\t\t\theap[j] = heap[2 * j + 1];\n\t\t\t\t\theap[2 * j + 1] = temp;\n\t\t\t\t\tj = 2 * j + 1;\n\t\t\t\t",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. heap_size)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_sift_down(heap, 0, heap_size);\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_insert(heap, heap_size);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_insert(heap, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_insert(heap, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\t\n\t\t\tif(heap_size == n)\n\t\t\t{\n\t\t\t\theap_build(heap);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach_reverse(i; 0 .. heap_size)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap_swap(heap, 0, heap_size - 1);\n\t\theap_size--;\n\t\theap_sift_down(heap, 0, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\t\n\t// create a heap queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// add all the numbers to the queue\n\tforeach(num; nums)\n\t{\n\t\tpq.put(num);\n\t}\n\t\n\t// get the n largest numbers\n\tforeach(i; 0 .. n)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (n <= 0)\n\t\treturn new long[0];\n\t\n\tlong[] result = new long[n];\n\t\n\tforeach (num; nums)\n\t{\n\t\tif (num > result[0])\n\t\t{\n\t\t\tresult[0] = num;\n\t\t\t\n\t\t\tlong i = 0;\n\t\t\twhile (i < n)\n\t\t\t{\n\t\t\t\tlong left = 2 * i + 1;\n\t\t\t\tlong right = 2 * i + 2;\n\t\t\t\t\n\t\t\t\tif (left < n && result[left] > result[i])\n\t\t\t\t{\n\t\t\t\t\tlong temp = result[i];\n\t\t\t\t\tresult[i] = result[left];\n\t\t\t\t\tresult[left] = temp;\n\t\t\t\t\ti = left;\n\t\t\t\t}\n\t\t\t\telse if (right < n && result[right] > result[i])\n\t\t\t\t{\n\t\t\t\t\tlong temp = result[i];\n\t\t\t\t\tresult[i] = result[right];\n\t\t\t\t\tresult[right] = temp;\n\t\t\t\t\ti = right;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tif (n > nums.length)\n\t\treturn result;\n\t\n\tlong[] heap = new long[n];\n\t\n\tforeach (long num; nums)\n\t{\n\t\tif (num > heap[0])\n\t\t{\n\t\t\theap[0] = num;\n\t\t\theap_sift_down(heap, 0, n);\n\t\t}\n\t}\n\t\n\tforeach (long i; 0 .. n)\n\t\tresult[i] = heap[i];\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size - 1);\n\t\t}\n\t\telse if(num > heap[0])\n\t\t{\n\t\t\theap[0] = num;\n\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. heap_size)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_sift_down(heap, 0, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\t\n\tif (nums.length == 0)\n\t\treturn result;\n\t\n\tif (nums.length < n)\n\t\tn = nums.length;\n\t\n\tlong[] heap = new long[n];\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\theap[i] = nums[i];\n\t}\n\t\n\tfor (long i = n / 2; i >= 0; i--)\n\t{\n\t\theapify(heap, i, n);\n\t}\n\t\n\tfor (long i = n; i < nums.length; i++)\n\t{\n\t\tif (nums[i] > heap[0])\n\t\t{\n\t\t\theap[0] = nums[i];\n\t\t\theapify(heap, 0, n);\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[n - i - 1];\n\t\theapify(heap, 0, n - i - 1);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size-1);\n\t\t}\n\t\telse if(num > heap[0])\n\t\t{\n\t\t\theap[0] = num;\n\t\t\theap_sift_down(heap, 0, heap_size);\n\t\t}\n\t}\n\tforeach(i; 0..n)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size-1];\n\t\theap_size--;\n\t\theap_sift_down(heap, 0, heap_size);\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[nums.length];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theapify_up(heap, heap_size);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theapify_down(heap, heap_size);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(long i = n - 1; i >= 0; i--)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theapify_down(heap, heap_size);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_size = heap_size;\n\t\t\t}\n\t\t}\n\t}\n\t\n\theap_size = heap_size;\n\t\n\twhile(heap_size > 0)\n\t{\n\t\tresult[heap_size - 1] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\t\n\t\tlong i = 0;\n\t\twhile(i < heap_size)\n\t\t{\n\t\t\tlong left = 2 * i + 1;\n\t\t\tlong right = 2 * i + 2;\n\t\t\tlong largest = i;\n\t\t\t\n\t\t\tif(left < heap_size && heap[left] > heap[largest])\n\t\t\t{\n\t\t\t\tlargest = left;\n\t\t\t}\n\t\t\t\n\t\t\tif(right < heap_size && heap[right] > heap[largest])\n\t\t\t{\n\t\t\t\tlargest = right;\n\t\t\t}\n\t\t\t\n\t\t\tif(largest != i)\n\t\t\t{\n\t\t\t\tlong temp = heap[i];\n\t\t\t\theap[i] = heap[largest];\n\t\t\t\theap[largest] = temp;\n\t\t\t\ti = largest;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap.length < n)\n\t\t{\n\t\t\theap ~= num;\n\t\t\theap_push(heap);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(heap[0] < num)\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_push(heap);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[$-1];\n\t\theap.length--;\n\t\theap_pop(heap);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[n];\n\tlong[] heap = new long[n];\n\tlong heap_size = 0;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(heap_size < n)\n\t\t{\n\t\t\theap[heap_size] = num;\n\t\t\theap_size++;\n\t\t\theap_sift_up(heap, heap_size-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num > heap[0])\n\t\t\t{\n\t\t\t\theap[0] = num;\n\t\t\t\theap_sift_down(heap, heap_size-1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap_size-1];\n\t\theap_size--;\n\t\theap_sift_down(heap, heap_size-1);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] heap;\n\tlong i, j, k, temp;\n\t\n\tif (n > nums.length)\n\t\tn = nums.length;\n\t\n\tresult = new long[n];\n\theap = new long[n];\n\t\n\tfor (i = 0; i < n; i++)\n\t\theap[i] = nums[i];\n\t\n\tfor (i = n / 2; i >= 0; i--)\n\t{\n\t\tj = i;\n\t\twhile (j < n)\n\t\t{\n\t\t\tk = j * 2 + 1;\n\t\t\tif (k + 1 < n && heap[k] < heap[k + 1])\n\t\t\t\tk++;\n\t\t\tif (k < n && heap[j] < heap[k])\n\t\t\t{\n\t\t\t\ttemp = heap[j];\n\t\t\t\theap[j] = heap[k];\n\t\t\t\theap[k] = temp;\n\t\t\t\tj = k;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor (i = n; i < nums.length; i++)\n\t{\n\t\tif (nums[i] > heap[0])\n\t\t{\n\t\t\theap[0] = nums[i];\n\t\t\tj = 0;\n\t\t\twhile (j < n)\n\t\t\t{\n\t\t\t\tk = j * 2 + 1;\n\t\t\t\tif (k + 1 < n && heap[k] < heap[k + 1])\n\t\t\t\t\tk++;\n\t\t\t\tif (k < n && heap[j] < heap[k])\n\t\t\t\t{\n\t\t\t\t\ttemp = heap[j];\n\t\t\t\t\theap[j] = heap[k];\n\t\t\t\t\theap[k] = temp;\n\t\t\t\t\tj = k;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t"
  ]
}