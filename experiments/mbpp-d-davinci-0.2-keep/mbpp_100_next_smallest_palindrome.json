{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\t\n*/\nlong next_smallest_palindrome(long num) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = next_smallest_palindrome;\n\n    assert(candidate(99L) == 101L);\n    assert(candidate(1221L) == 1331L);\n    assert(candidate(120L) == 121L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong n = num;\n\tlong digits = 0;\n\tlong temp = 0;\n\tlong num_digits = 0;\n\tlong left_half = 0;\n\tlong right_half = 0;\n\tlong left_half_digits = 0;\n\tlong right_half_digits = 0;\n\tlong left_half_copy = 0;\n\tlong right_half_copy = 0;\n\tlong left_half_copy_digits = 0;\n\tlong right_half_copy_digits = 0;\n\tlong left_half_copy_reversed = 0;\n\tlong right_half_copy_reversed = 0;\n\tlong left_half_copy_reversed_digits = 0;\n\tlong right_half_copy_reversed_digits = 0;\n\tlong left_half_copy_reversed_temp = 0;\n\tlong right_half_copy_reversed_temp = 0;\n\tlong left_half_copy_reversed_temp_digits = 0;\n\tlong right_half_copy_reversed_temp_digits = 0;\n\tlong left_half_copy_reversed_temp_digits_copy = 0;\n\tlong right_half_copy_reversed_temp_digits_copy = 0;\n\tlong left_half_copy_reversed_temp_digits_copy_reversed = 0;\n\tlong right_half_copy_reversed_temp_digits_copy_reversed = 0;\n\tlong left_half_copy_reversed_temp_digits_copy_reversed_digits = 0;\n\tlong right_half_copy_reversed_temp_digits_copy_reversed_digits = 0;\n\tlong left_half_copy_reversed_temp_digits_copy_reversed_digits_copy = 0;\n\tlong right_half_copy_reversed_temp_digits_copy_reversed_digits_copy =",
    "{\n\tlong n = num;\n\tlong rev = 0;\n\tlong d;\n\t\n\twhile (n > 0) \n\t{\n\t\td = n % 10;\n\t\trev = rev * 10 + d;\n\t\tn /= 10;\n\t}\n\t\n\tif (num == rev)\n\t\treturn num;\n\t\n\tif (num > rev)\n\t\treturn rev;\n\t\n\tlong inc = 1;\n\twhile (true) \n\t{\n\t\trev = num + inc;\n\t\tn = rev;\n\t\tlong rev2 = 0;\n\t\twhile (n > 0) \n\t\t{\n\t\t\td = n % 10;\n\t\t\trev2 = rev2 * 10 + d;\n\t\t\tn /= 10;\n\t\t}\n\t\tif (rev == rev2)\n\t\t\treturn rev;\n\t\tinc++;\n\t}\n}",
    "{\n\tlong num_digits = log10(num) + 1;\n\tlong num_digits_half = num_digits / 2;\n\tlong num_digits_half_ceil = ceil(num_digits / 2);\n\tlong num_digits_half_floor = floor(num_digits / 2);\n\t\n\tlong num_digits_half_ceil_pow = pow(10, num_digits_half_ceil);\n\tlong num_digits_half_floor_pow = pow(10, num_digits_half_floor);\n\t\n\tlong num_digits_half_ceil_pow_minus_one = num_digits_half_ceil_pow - 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow = num_digits_half_ceil_pow_minus_one - num_digits_half_floor_pow;\n\t\n\tlong num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow_div_two = num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow / 2;\n\t\n\tlong num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow_div_two_plus_num_digits_half_floor_pow = num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow_div_two + num_digits_half_floor_pow;\n\t\n\tlong num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow_div_two_plus_num_digits_half_floor_pow_plus_num_digits_half_ceil_pow_minus_one_minus_num_digits_half_floor_pow_div_two = num_digits_half",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tlong num_digits = log10(num) + 1;\n\tlong half_digits = num_digits / 2;\n\t\n\tlong left_half = num / pow(10, half_digits);\n\tlong right_half = num % (long)pow(10, half_digits);\n\t\n\tif (left_half == right_half)\n\t\treturn num;\n\t\n\tif (left_half > right_half)\n\t\treturn num - right_half + left_half;\n\t\n\tlong new_num = num + (long)pow(10, half_digits);\n\t\n\treturn next_smallest_palindrome(new_num);\n}",
    "{\n\tlong num_copy = num;\n\tlong num_digits = 0;\n\tlong num_digits_half = 0;\n\tlong num_digits_half_floor = 0;\n\tlong num_digits_half_ceil = 0;\n\tlong num_digits_half_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_ceil_ceil = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_ceil_ceil_floor = 0;\n\tlong num_digits_half_ceil_ceil_ceil_ceil_ceil_ceil_ceil_ceil_ceil = 0;\n\t",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = (long)log10(num) + 1;\n\t\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\tlong num_digits_half = num_digits / 2;\n\t\n\tlong num_left = num / (long)pow(10, num_digits_half);\n\tlong num_right = num % (long)pow(10, num_digits_half);\n\t\n\tlong num_left_rev = 0;\n\t\n\tif (num_digits % 2 == 0)\n\t{\n\t\tnum_left_rev = num_right;\n\t}\n\telse\n\t{\n\t\tnum_left_rev = num_right / 10;\n\t}\n\t\n\tif (num_left == num_left_rev)\n\t{\n\t\tif (num_digits % 2 == 0)\n\t\t{\n\t\t\treturn num + (long)pow(10, num_digits_half);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn num + (long)pow(10, num_digits_half) * 10;\n\t\t}\n\t}\n\telse if (num_left < num_left_rev)\n\t{\n\t\tif (num_digits % 2 == 0)\n\t\t{\n\t\t\treturn num + (long)pow(10, num_digits_half) * 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn num + (long)pow(10, num_digits_half) * 11;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlong num_left_new = num_left + 1;\n\t\tlong num_left_new_rev = 0;\n\t\t\n\t\tif (num_digits % 2 == 0)\n\t\t{\n\t\t\tnum_left_new_rev = num_left_new;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\t\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\tlong left_half = num / pow(10, num_digits / 2);\n\tlong right_half = num % (long)pow(10, num_digits / 2);\n\t\n\tlong next_palindrome = left_half * (long)pow(10, num_digits / 2) + right_half;\n\t\n\tif (next_palindrome > num)\n\t\treturn next_palindrome;\n\t\n\tif (left_half % 10 == 9)\n\t{\n\t\tleft_half++;\n\t\tleft_half /= 10;\n\t}\n\telse\n\t\tleft_half++;\n\t\n\treturn left_half * (long)pow(10, num_digits / 2) + left_half % (long)pow(10, num_digits / 2);\n}",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\t// get the number of digits\n\tint digits = (int)log10(num) + 1;\n\t\n\t// if the number is a palindrome, add 1 to the middle digit\n\tif (is_palindrome(num))\n\t{\n\t\tint middle = digits / 2;\n\t\t\n\t\t// get the middle digit\n\t\tint middle_digit = (int)(num / pow(10, middle)) % 10;\n\t\t\n\t\t// add 1 to the middle digit\n\t\tmiddle_digit++;\n\t\t\n\t\t// if the middle digit is 10, we need to carry the 1 to the next digit\n\t\tif (middle_digit == 10)\n\t\t{\n\t\t\t// get the next digit\n\t\t\tint next_digit = (int)(num / pow(10, middle + 1)) % 10;\n\t\t\t\n\t\t\t// add 1 to the next digit\n\t\t\tnext_digit++;\n\t\t\t\n\t\t\t// if the next digit is 10, we need to carry the 1 to the next digit\n\t\t\tif (next_digit == 10)\n\t\t\t{\n\t\t\t\t// get the next digit\n\t\t\t\tint next_next_digit = (int)(num / pow(10, middle + 2)) % 10;\n\t\t\t\t\n\t\t\t\t// add 1 to the next digit\n\t\t\t\tnext_next_digit++;\n\t\t\t\t\n\t\t\t\t// if the next digit is 10, we need to carry the 1 to the next digit\n\t\t\t\tif (next_next_digit == 10)\n\t\t\t\t{\n\t\t\t\t\t// get the next digit\n\t\t\t\t\tint next_next_next_digit = (int)(num / pow(10, middle + 3)) % 10;\n\t\t\t\t\t\n\t\t\t\t\t// add 1 to the next digit\n\t\t\t\t\tnext_next_next_digit++;\n\t\t\t\t\t\n\t\t\t\t\t// if the next digit is 10, we need to carry the 1",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num);\n\tlong num_digits_half = num_digits / 2;\n\t\n\tlong left_half = num / pow(10, num_digits_half);\n\tlong right_half = num % (long)pow(10, num_digits_half);\n\t\n\tlong left_half_rev = reverse(left_half);\n\t\n\tif (left_half_rev < right_half)\n\t{\n\t\tleft_half++;\n\t\tleft_half_rev = reverse(left_half);\n\t}\n\t\n\tlong result = left_half * pow(10, num_digits_half) + left_half_rev;\n\t\n\treturn result;\n}",
    "{\n\tif(num < 0)\n\t\treturn -1;\n\t\n\tif(num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\tlong num_half_digits = num_digits / 2;\n\tlong num_half_digits_ceil = ceil(num_half_digits);\n\tlong num_half_digits_floor = floor(num_half_digits);\n\t\n\tlong num_left_half = num / pow(10, num_half_digits_ceil);\n\tlong num_right_half = num % (long)pow(10, num_half_digits_floor);\n\t\n\tlong num_left_half_reversed = reverse(num_left_half);\n\t\n\tif(num_left_half_reversed > num_right_half)\n\t\treturn num_left_half * pow(10, num_half_digits_ceil) + num_left_half_reversed;\n\t\n\tif(num_left_half_reversed == num_right_half)\n\t{\n\t\tif(num_digits % 2 == 0)\n\t\t\treturn num_left_half * pow(10, num_half_digits_ceil) + num_left_half_reversed;\n\t\telse\n\t\t\treturn (num_left_half + 1) * pow(10, num_half_digits_ceil) + reverse(num_left_half + 1);\n\t}\n\t\n\tif(num_left_half_reversed < num_right_half)\n\t{\n\t\tif(num_digits % 2 == 0)\n\t\t\treturn (num_left_half + 1) * pow(10, num_half_digits_ceil) + reverse(num_left_half + 1);\n\t\telse\n\t\t\treturn (num_left_half + 1) * pow(10, num_half_digits_ceil) + reverse(num_left_half + 1);\n\t}\n\t\n\treturn -1;\n}",
    "{\n\t// if the number is a palindrome, return it\n\tif (is_palindrome(num))\n\t\treturn num;\n\t\n\t// if the number is a single digit, return the next palindrome\n\tif (num < 10)\n\t\treturn num + 1;\n\t\n\t// if the number is a double digit, return the next palindrome\n\tif (num < 100)\n\t\treturn num + 11;\n\t\n\t// if the number is a triple digit, return the next palindrome\n\tif (num < 1000)\n\t\treturn num + 101;\n\t\n\t// if the number is a quadruple digit, return the next palindrome\n\tif (num < 10000)\n\t\treturn num + 1001;\n\t\n\t// if the number is a quintuple digit, return the next palindrome\n\tif (num < 100000)\n\t\treturn num + 10001;\n\t\n\t// if the number is a sextuple digit, return the next palindrome\n\tif (num < 1000000)\n\t\treturn num + 100001;\n\t\n\t// if the number is a septuple digit, return the next palindrome\n\tif (num < 10000000)\n\t\treturn num + 1000001;\n\t\n\t// if the number is an octuple digit, return the next palindrome\n\tif (num < 100000000)\n\t\treturn num + 10000001;\n\t\n\t// if the number is a nonuple digit, return the next palindrome\n\tif (num < 1000000000)\n\t\treturn num + 100000001;\n\t\n\t// if the number is a decuple digit, return the next palindrome\n\tif (num < 10000000000)\n\t\treturn num + 1000000001;\n\t\n\t// if the number is an undecuple digit, return the next palindrome\n\tif (num < 100000000000)\n\t\treturn num + 10000000001;\n\t\n\t// if the number is a duodecuple digit, return the next palindrome\n\tif (num < 1000000000000)\n\t\treturn num + 100000000001;\n\t\n\t// if the number is a tredecuple digit, return the next pal",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\t\n\tif (num_digits == 1)\n\t\treturn num;\n\t\n\tlong half_digits = num_digits / 2;\n\t\n\tlong left_half = num / pow(10, half_digits);\n\tlong right_half = num % (long)pow(10, half_digits);\n\t\n\tlong left_half_rev = 0;\n\tlong right_half_rev = 0;\n\t\n\tif (num_digits % 2 == 0)\n\t{\n\t\tleft_half_rev = reverse(left_half);\n\t\tright_half_rev = reverse(right_half);\n\t}\n\telse\n\t{\n\t\tleft_half_rev = reverse(left_half / 10);\n\t\tright_half_rev = reverse(right_half);\n\t}\n\t\n\tif (left_half_rev > right_half_rev)\n\t{\n\t\treturn left_half * pow(10, half_digits) + left_half_rev;\n\t}\n\telse\n\t{\n\t\tlong new_left_half = left_half + 1;\n\t\tlong new_left_half_rev = reverse(new_left_half);\n\t\t\n\t\treturn new_left_half * pow(10, half_digits) + new_left_half_rev;\n\t}\n}",
    "{\n\tif (num < 0) return -1;\n\tif (num < 10) return num;\n\t\n\tauto digits = to!string(num);\n\t\n\tif (digits.length % 2 == 0)\n\t{\n\t\tauto left = digits[0 .. $/2];\n\t\tauto right = digits[$/2 .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\treturn to!long(left ~ left[$-1 .. 0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto new_left = to!string(to!long(left) + 1);\n\t\t\treturn to!long(new_left ~ new_left[$-1 .. 0]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto left = digits[0 .. $/2];\n\t\tauto middle = digits[$/2 .. $/2+1];\n\t\tauto right = digits[$/2+1 .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\treturn to!long(left ~ middle ~ left[$-1 .. 0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto new_left = to!string(to!long(left) + 1);\n\t\t\treturn to!long(new_left ~ middle ~ new_left[$-1 .. 0]);\n\t\t}\n\t}\n}",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tlong num_digits = log10(num) + 1;\n\tlong num_digits_half = num_digits / 2;\n\tlong num_digits_half_ceil = num_digits_half + (num_digits % 2);\n\t\n\tlong num_half = num / pow(10, num_digits_half_ceil);\n\tlong num_half_rev = num_half;\n\t\n\tif (num_digits % 2 == 1)\n\t\tnum_half_rev /= 10;\n\t\n\tnum_half_rev = reverse(num_half_rev);\n\t\n\tlong num_half_rev_pow = pow(10, num_digits_half);\n\t\n\tif (num_half_rev < num_half)\n\t\tnum_half_rev += num_half_rev_pow;\n\t\n\tlong num_half_rev_pow_ceil = pow(10, num_digits_half_ceil);\n\t\n\treturn num_half_rev * num_half_rev_pow_ceil + num_half_rev / num_half_rev_pow;\n}",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tauto digits = to!string(num);\n\tauto len = digits.length;\n\t\n\tif (len % 2 == 0)\n\t{\n\t\tauto half = len / 2;\n\t\tauto left = digits[0 .. half];\n\t\tauto right = digits[half .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\tauto new_right = left.dup;\n\t\t\treverse(new_right);\n\t\t\treturn to!long(left ~ new_right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto new_left = to!string(to!long(left) + 1);\n\t\t\tauto new_right = new_left.dup;\n\t\t\treverse(new_right);\n\t\t\treturn to!long(new_left ~ new_right);\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto half = len / 2;\n\t\tauto left = digits[0 .. half];\n\t\tauto right = digits[half + 1 .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\tauto new_right = left.dup;\n\t\t\treverse(new_right);\n\t\t\treturn to!long(left ~ digits[half] ~ new_right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto new_left = to!string(to!long(left) + 1);\n\t\t\tauto new_right = new_left.dup;\n\t\t\treverse(new_right);\n\t\t\treturn to!long(new_left ~ digits[half] ~ new_right);\n\t\t}\n\t}\n}",
    "{\n\t// if the number is negative, return the next smallest positive palindrome\n\tif (num < 0)\n\t\treturn next_smallest_palindrome(-num);\n\t\n\t// if the number is a single digit, return the next smallest palindrome\n\tif (num < 10)\n\t\treturn num + 1;\n\t\n\t// if the number is a palindrome, return the next smallest palindrome\n\tif (is_palindrome(num))\n\t\treturn num + 2;\n\t\n\t// if the number is a power of 10, return the next smallest palindrome\n\tif (is_power_of_10(num))\n\t\treturn num + 2;\n\t\n\t// if the number is a power of 10 minus 1, return the next smallest palindrome\n\tif (is_power_of_10(num + 1))\n\t\treturn num + 3;\n\t\n\t// if the number is a power of 10 plus 1, return the next smallest palindrome\n\tif (is_power_of_10(num - 1))\n\t\treturn num + 1;\n\t\n\t// if the number is a palindrome with a single digit changed, return the next smallest palindrome\n\tif (is_palindrome_with_single_digit_changed(num))\n\t\treturn num + 2;\n\t\n\t// if the number is a palindrome with a single digit changed, return the next smallest palindrome\n\tif (is_palindrome_with_single_digit_changed(num + 1))\n\t\treturn num + 3;\n\t\n\t// if the number is a palindrome with a single digit changed, return the next smallest palindrome\n\tif (is_palindrome_with_single_digit_changed(num - 1))\n\t\treturn num + 1;\n\t\n\t// if the number is a palindrome with a single digit changed, return the next smallest palindrome\n\tif (is_palindrome_with_single_digit_changed(num + 2))\n\t\treturn num + 4;\n\t\n\t// if the number is a palindrome with a single digit changed, return the next smallest palindrome\n\tif (is_palind",
    "{\n\tlong num_digits = log10(num) + 1;\n\tlong num_digits_half = num_digits / 2;\n\tlong num_digits_half_ceil = ceil(num_digits / 2.0);\n\t\n\tlong num_digits_half_ceil_pow = pow(10, num_digits_half_ceil);\n\tlong num_digits_half_pow = pow(10, num_digits_half);\n\t\n\tlong num_digits_half_ceil_pow_minus_1 = num_digits_half_ceil_pow - 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow = num_digits_half_ceil_pow_minus_1 - num_digits_half_pow;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus_1 = num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow + 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus_1_minus_num_digits_half_pow = num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus_1 - num_digits_half_pow;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus_1_minus_num_digits_half_pow_plus_1 = num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus_1_minus_num_digits_half_pow + 1;\n\t\n\tlong num_digits_half_ceil_pow_minus_1_minus_num_digits_half_pow_plus",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tauto digits = to!string(num);\n\tauto len = digits.length;\n\t\n\tif (len % 2 == 0)\n\t{\n\t\tauto mid = len / 2;\n\t\tauto left = digits[0..mid];\n\t\tauto right = digits[mid..$];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\tauto left_int = to!long(left);\n\t\t\treturn left_int * pow(10, mid) + left_int;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto left_int = to!long(left);\n\t\t\treturn (left_int + 1) * pow(10, mid) + (left_int + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto mid = len / 2;\n\t\tauto left = digits[0..mid];\n\t\tauto right = digits[mid+1..$];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\tauto left_int = to!long(left);\n\t\t\treturn left_int * pow(10, mid+1) + left_int;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto left_int = to!long(left);\n\t\t\treturn (left_int + 1) * pow(10, mid+1) + (left_int + 1);\n\t\t}\n\t}\n}",
    "{\n\tif (num < 0)\n\t\treturn -1;\n\t\n\tif (num < 10)\n\t\treturn num;\n\t\n\tauto digits = to!string(num);\n\t\n\tif (digits.length % 2 == 0)\n\t{\n\t\tauto left = digits[0 .. digits.length / 2];\n\t\tauto right = digits[digits.length / 2 .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\treturn to!long(left ~ left[$ .. 0]);\n\t\t}\n\t\telse if (left == right)\n\t\t{\n\t\t\tauto next_left = to!string(to!long(left) + 1);\n\t\t\treturn to!long(next_left ~ next_left[$ .. 0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn to!long(left ~ left[$ .. 0]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tauto left = digits[0 .. digits.length / 2];\n\t\tauto right = digits[digits.length / 2 + 1 .. $];\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\treturn to!long(left ~ digits[digits.length / 2] ~ left[$ .. 0]);\n\t\t}\n\t\telse if (left == right)\n\t\t{\n\t\t\tauto next_left = to!string(to!long(left) + 1);\n\t\t\treturn to!long(next_left ~ next_left[$ .. 0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn to!long(left ~ digits[digits.length / 2] ~ left[$ .. 0]);\n\t\t}\n\t}\n}",
    "{\n\tlong num_digits = log10(num) + 1;\n\tlong num_digits_half = num_digits / 2;\n\t\n\tlong num_left = num / pow(10, num_digits_half);\n\tlong num_right = num % (long)pow(10, num_digits_half);\n\t\n\tlong num_left_rev = reverse(num_left);\n\t\n\tif (num_left_rev < num_right) \n\t{\n\t\tnum_left += 1;\n\t\tnum_left_rev = reverse(num_left);\n\t}\n\t\n\tlong num_new = num_left * pow(10, num_digits_half) + num_left_rev;\n\t\n\treturn num_new;\n}"
  ]
}