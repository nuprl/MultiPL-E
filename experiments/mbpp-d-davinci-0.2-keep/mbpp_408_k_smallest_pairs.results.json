{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto res = new long[][](len, 2);\n\t\n\tfor (auto i = 0; i < len; ++i)\n\t{\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpb4jlphb8.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb4jlphb8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpo3lznec1.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3lznec1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\t\n\tfor (size_t i = 0; i < n1; ++i)\n\t{\n\t\tfor (size_t j = 0; j < n2; ++j)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\treturn pairs[0 .. min(k, n1 * n2)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp8ug_1zfc.d(22): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmp8ug_1zfc.d(24): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ug_1zfc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\theap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif(t[2] == m - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmp438bmaeh.d(12): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp438bmaeh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpbhhljodt.d(16): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpbhhljodt.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbhhljodt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long))(k, (a, b) => a[0] > b[0]);\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmpraf3sows.d(17): Error: template instance `PriorityQueue!(Tuple!(long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpraf3sows.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpairs[count] = [num1, num2];\n\t\t\tindices[count] = [i, j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i, pair; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tres[i] = pair;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmph8sxmhb7.d(24): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph8sxmhb7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpbrcbu34w.d(22): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbrcbu34w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(tuple!(long, long, long));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] + nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tauto ret = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tret[i] = [t[1], t[2]];\n\t}\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpkwq7kqp6.d(10): Error: template instance `PriorityQueue!(tuple!(long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwq7kqp6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(nums1.length, k))\n\t\tpq.put(new long[] { nums1[i], nums2[0], 0 });\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tbreak;\n\t\t\n\t\tres[i] = new long[] { cur[0], cur[1] };\n\t\tpq.put(new long[] { cur[0], nums2[cur[2] + 1], cur[2] + 1 });\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp4lqy3b58.d(16): Error: found `{` when expecting `,`\n/tmp/tmp4lqy3b58.d(16): Error: found `}` when expecting `,`\n/tmp/tmp4lqy3b58.d(27): Error: found `{` when expecting `;` following statement\n/tmp/tmp4lqy3b58.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmp4lqy3b58.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp4lqy3b58.d(28): Error: found `{` when expecting `,`\n/tmp/tmp4lqy3b58.d(28): Error: found `}` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4lqy3b58.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(Tuple!(long, long, long))(Tuple!(long, long, long)(0, 0, nums1[0] + nums2[0]), std.less);\n\tauto visited = new bool[nums1.length][nums2.length];\n\tvisited[0][0] = true;\n\t\n\tlong[][] result;\n\twhile (k-- > 0) \n\t{\n\t\tauto t = pq.popFront();\n\t\tresult ~= [nums1[t[0]], nums2[t[1]]];\n\t\tif (t[0] + 1 < nums1.length && !visited[t[0] + 1][t[1]]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]]));\n\t\t\tvisited[t[0] + 1][t[1]] = true;\n\t\t}\n\t\tif (t[1] + 1 < nums2.length && !visited[t[0]][t[1] + 1]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t\t\tvisited[t[0]][t[1] + 1] = true;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmp54d83m0w.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long))` template `PriorityQueue` is not defined\n/tmp/tmp54d83m0w.d(11): Error: variable `nums1` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54d83m0w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long))(Tuple!(long, long, long, long)(0, 0, nums1[0] + nums2[0], 0));\n\tauto result = new long[][](0);\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult ~= [t[2], t[3]];\n\t\t\n\t\tif (t[0] < n - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]], nums2[t[1]]));\n\t\t\n\t\tif (t[0] == 0 && t[1] < m - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(0, t[1] + 1, nums1[0] + nums2[t[1] + 1], nums2[t[1] + 1]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmput6dlbt3.d(12): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmput6dlbt3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = new MinHeap!(long[2])();\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tforeach (i; 0 .. n)\n\t{\n\t\tminHeap.push([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto [num1, num2, idx] = minHeap.pop();\n\t\tresult[i] = [num1, num2];\n\t\tif (idx == m - 1)\n\t\t\tcontinue;\n\t\tminHeap.push([num1, nums2[idx + 1], idx + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp6l3kgfo0.d(26): Error: basic type expected, not `[`\n/tmp/tmp6l3kgfo0.d(26): Error: found `,` when expecting `]`\n/tmp/tmp6l3kgfo0.d(26): Error: semicolon expected, not `]`\n/tmp/tmp6l3kgfo0.d(26): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6l3kgfo0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpbu3zrzai.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbu3zrzai.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif(len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. min(k, len1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\t\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto top = minHeap.pop;\n\t\tresult[count] = [top[0], top[1]];\n\t\tcount++;\n\t\t\n\t\tif(top[3] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[3] + 1], top[2], top[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp02mgfn1m.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\n/tmp/tmp02mgfn1m.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02mgfn1m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto res = new long[][](n);\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpfecsgop4.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfecsgop4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2, n;\n\tlong[] tmp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1 * n2, k);\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](n);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpur1dp1jy.d(17): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpur1dp1jy.d(29): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpur1dp1jy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto ret = new long[][](min(k, nums1.length * nums2.length));\n\t\n\tforeach(i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tauto t = pq.get;\n\t\tret[i] = new long[](2);\n\t\tret[i][0] = t[0];\n\t\tret[i][1] = t[1];\n\t\tif(t[3] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmp9dntoas6.d(11): Error: new can only create structs, dynamic arrays or class objects, not `long[][]`'s\n/tmp/tmp9dntoas6.d(13): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp9dntoas6.d(15): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp9dntoas6.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp9dntoas6.d(20): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9dntoas6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong sum;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\tpairs = new long[][](n);\n\t\n\ti = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\tpairs[i] = [num1, num2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tm = min(k, n);\n\tresult = new long[][](m);\n\t\n\ti = 0;\n\twhile(i < m)\n\t{\n\t\tresult[i] = pairs[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517371,
      "stdout": "",
      "stderr": "/tmp/tmp_dse80zc.d(35): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmp_dse80zc.d(37): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_dse80zc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums1.length - 1)\n\t\t{\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmp6pe4h3a8.d(14): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pe4h3a8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif (pq.length > k) \n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.pop();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpiangx6lj.d(16): Error: variable `tmpiangx6lj.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] - (b[0] + b[1])`, and variables cannot be of type `void`\n/tmp/tmpiangx6lj.d(16): Error: template lambda has no value\n/tmp/tmpiangx6lj.d(17): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiangx6lj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp0psf3lnz.d(17): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0psf3lnz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n    long[][] result = new long[][](k);\n    if (nums1.length == 0 || nums2.length == 0 || k == 0)\n        return result;\n    auto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n    foreach (i; 0 .. nums1.length)\n        foreach (j; 0 .. nums2.length)\n            pq.put(tuple(nums1[i], nums2[j]));\n    foreach (i; 0 .. k)\n        result[i] = pq.get;\n    return result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpmt0vfey0.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmt0vfey0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\t\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][] temp50;\n\tlong[][] temp51;\n\tlong[][] temp52;\n\tlong[][] temp53;\n\tlong[][] temp54;\n\tlong[][] temp55;\n\tlong[][]\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpeu3bd9cf.d(68): Error: no identifier for declarator `long[][]`\n/tmp/tmpeu3bd9cf.d(68): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeu3bd9cf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\twhile(k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tk--;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpeoahj3uz.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeoahj3uz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpjyhorlna.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[], Tuple!(long, long)[])` template `PriorityQueue` is not defined\n/tmp/tmpjyhorlna.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjyhorlna.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[count] = [nums1[i], nums2[j]];\n\t\t\tindices[count] = [i, j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tstd.algorithm.sort(pairs, comp);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tres[i] = pairs[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpx9egzp8d.d(24): Error: variable `tmpx9egzp8d.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] > b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmpx9egzp8d.d(24): Error: template lambda has no value\n/tmp/tmpx9egzp8d.d(26): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx9egzp8d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] heap;\n\tlong i, j, n;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\theap = new long[][](nums1.length * nums2.length, 2);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\theap[i * nums2.length + j][0] = nums1[i];\n\t\t\theap[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\theap_sort(heap);\n\t\n\tn = min(k, heap.length);\n\tresult = new long[][](n, 2);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i][0] = heap[i][0];\n\t\tresult[i][1] = heap[i][1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpic618ktr.d(28): Error: undefined identifier `heap_sort`\n/tmp/tmpic618ktr.d(30): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpic618ktr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong p;\n\tlong q;\n\tlong r;\n\tlong s;\n\tlong t;\n\tlong u;\n\tlong v;\n\tlong w;\n\tlong x;\n\tlong y;\n\tlong z;\n\tlong aa;\n\tlong bb;\n\tlong cc;\n\tlong dd;\n\tlong ee;\n\tlong ff;\n\tlong gg;\n\tlong hh;\n\tlong ii;\n\tlong jj;\n\tlong kk;\n\tlong ll;\n\tlong mm;\n\tlong nn;\n\tlong oo;\n\tlong pp;\n\tlong qq;\n\tlong rr;\n\tlong ss;\n\tlong tt;\n\tlong uu;\n\tlong vv;\n\tlong ww;\n\tlong xx;\n\tlong yy;\n\tlong zz;\n\tlong aaa;\n\tlong bbb;\n\tlong ccc;\n\tlong ddd;\n\tlong eee;\n\tlong fff;\n\tlong ggg;\n\tlong hhh;\n\tlong iii;\n\tlong jjj;\n\tlong kkk;\n\tlong lll;\n\tlong mmm;\n\tlong nnn;\n\tlong ooo;\n\tlong ppp;\n\tlong qqq;\n\tlong rrr;\n\tlong sss;\n\tlong ttt;\n\tlong uuu;\n\tlong vvv;\n\tlong www;\n\tlong xxx;\n\tlong yyy;\n\tlong zzz;\n\tlong aaaa;\n\tlong bbbb;\n\tlong cccc;\n\tlong dddd;\n\tlong eeee;\n\tlong ffff;\n\tlong gggg;\n\tlong hhhh;\n\tlong iiii;\n\tlong jjjj;\n\tlong kkkk;\n\tlong llll;\n\tlong mmmm;\n\tlong nnnn;\n\tlong\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpuhvclxo4.d(97): Error: no identifier for declarator `long`\n/tmp/tmpuhvclxo4.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuhvclxo4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[k][];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (long i = 0; i < nums1.length && i < k; i++)\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++) \n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = new long[]{cur[0], cur[1]};\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp8uwqiqw5.d(17): Error: found `{` when expecting `,`\n/tmp/tmp8uwqiqw5.d(17): Error: found `}` when expecting `,`\n/tmp/tmp8uwqiqw5.d(22): Error: found `{` when expecting `;` following statement\n/tmp/tmp8uwqiqw5.d(22): Error: found `}` when expecting `;` following statement\n/tmp/tmp8uwqiqw5.d(22): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp8uwqiqw5.d(25): Error: found `{` when expecting `,`\n/tmp/tmp8uwqiqw5.d(25): Error: found `}` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8uwqiqw5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto max_heap = new MinHeap!(tuple!(long, long, long));\n\tmax_heap.insert(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\twhile (count < k && !max_heap.empty)\n\t{\n\t\tauto t = max_heap.pop;\n\t\tresult[count] = [t[0], t[1], t[2]];\n\t\tcount++;\n\t\tif (t[1] + 1 < n1)\n\t\t\tmax_heap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\tif (t[1] == 0 && t[2] + 1 < n2)\n\t\t\tmax_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpuxszk1im.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuxszk1im.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp8qvodf8_.d(10): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8qvodf8_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn res;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto cur = pq.get();\n\t\tif (cur is null) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tres[i] = [cur[0], cur[1]];\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp3154uiyy.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp3154uiyy.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3154uiyy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmponolo2lt.d(22): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmponolo2lt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], \"a > b\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp331qbasi.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], \"a > b\")` template `PriorityQueue` is not defined\n/tmp/tmp331qbasi.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp331qbasi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, l, m;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[l][0] = nums1[i];\n\t\t\tpairs[l][1] = nums2[j];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(m; 0 .. k)\n\t{\n\t\tresult[m][0] = pairs[m][0];\n\t\tresult[m][1] = pairs[m][1];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpomr7uktq.d(16): Error: variable `i` is shadowing variable `tmpomr7uktq.k_smallest_pairs.i`\n/tmp/tmpomr7uktq.d(18): Error: variable `j` is shadowing variable `tmpomr7uktq.k_smallest_pairs.j`\n/tmp/tmpomr7uktq.d(26): Error: no property `sort` for type `long[][]`\n/tmp/tmpomr7uktq.d(30): Error: variable `m` is shadowing variable `tmpomr7uktq.k_smallest_pairs.m`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpomr7uktq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif(n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)(0, 0));\n\t\n\tforeach(i; 0 .. min(n1, k))\n\t{\n\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(Tuple!(long, long)(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp71jjlj3f.d(16): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)(0, 0))` template `PriorityQueue` is not defined\n/tmp/tmp71jjlj3f.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp71jjlj3f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tlong[][] pairs = new long[nums1.length * nums2.length][2];\n\tlong idx = 0;\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpairs[idx++] = [nums1[i], nums2[j]];\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pairs[i];\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpmvmst2bl.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmpmvmst2bl.d(13): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpmvmst2bl.d(19): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmvmst2bl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto comp = (a, b) => nums1[a[0]] + nums1[a[1]] > nums1[b[0]] + nums1[b[1]];\n\tauto pq = new PriorityQueue!(comp)();\n\tpq.put(tuple(0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i) \n\t{\n\t\tauto idx = pq.get();\n\t\tres[i][0] = nums1[idx[0]];\n\t\tres[i][1] = nums2[idx[1]];\n\t\t\n\t\tif (idx[0] + 1 < nums1.length) pq.put(tuple(idx[0] + 1, idx[1]));\n\t\tif (idx[0] == 0 && idx[1] + 1 < nums2.length) pq.put(tuple(idx[0], idx[1] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp774q7blo.d(10): Error: variable `k` cannot be read at compile time\n/tmp/tmp774q7blo.d(13): Error: variable `tmp774q7blo.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => nums1[a[0]] + nums1[a[1]] > nums1[b[0]] + nums1[b[1]]`, and variables cannot be of type `void`\n/tmp/tmp774q7blo.d(13): Error: template lambda has no value\n/tmp/tmp774q7blo.d(14): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp774q7blo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\");\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tlong[][] result;\n\twhile(k-- > 0)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.popFront;\n\t\tresult ~= [t[0], t[1]];\n\t\t\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\n\t\tif(t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp5tb1pz4d.d(16): Error: template instance `Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\")` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5tb1pz4d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp02jrl2_o.d(16): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmp02jrl2_o.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02jrl2_o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] heap = new long[][](k);\n\tlong heapSize = 0;\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(heapSize < k)\n\t\t\t{\n\t\t\t\theap[heapSize] = [nums1[i], nums2[j]];\n\t\t\t\theapSize++;\n\t\t\t\tif(heapSize == k)\n\t\t\t\t{\n\t\t\t\t\theap.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap[0][0] + heap[0][1])\n\t\t\t\t{\n\t\t\t\t\theap[0] = [nums1[i], nums2[j]];\n\t\t\t\t\theap.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpf63p4ibt.d(24): Error: no property `sort` for type `long[][]`\n/tmp/tmpf63p4ibt.d(32): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf63p4ibt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[count] = [t[0], t[1]];\n\t\tcount++;\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpx7p7brox.d(12): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\n/tmp/tmpx7p7brox.d(14): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7p7brox.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, n1, n2, n;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tresult[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tresult.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tif (k < n)\n\t{\n\t\ttemp = new long[][](k);\n\t\tfor (i = 0; i < k; i++)\n\t\t{\n\t\t\ttemp[i] = result[i];\n\t\t}\n\t\tresult = temp;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpov1iuoxz.d(31): Error: no property `sort` for type `long[][]`\n/tmp/tmpov1iuoxz.d(35): Error: cannot implicitly convert expression `new long[][](cast(ulong)k)` of type `long[][]` to `long[]`\n/tmp/tmpov1iuoxz.d(38): Error: cannot implicitly convert expression `result[cast(ulong)i]` of type `long[]` to `long`\n/tmp/tmpov1iuoxz.d(40): Error: cannot implicitly convert expression `temp` of type `long[]` to `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov1iuoxz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long));\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto t = pq.get;\n\t\t\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpjgksiaa8.d(13): Error: found `,` when expecting `.` following long\n/tmp/tmpjgksiaa8.d(13): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpjgksiaa8.d(13): Error: found `)` when expecting `.` following long\n/tmp/tmpjgksiaa8.d(13): Error: found `)` when expecting identifier following `long`.\n/tmp/tmpjgksiaa8.d(13): Error: found `;` when expecting `,`\n/tmp/tmpjgksiaa8.d(15): Error: expression expected, not `foreach`\n/tmp/tmpjgksiaa8.d(15): Error: found `;` when expecting `,`\n/tmp/tmpjgksiaa8.d(15): Error: found `..` when expecting `,`\n/tmp/tmpjgksiaa8.d(16): Error: found `{` when expecting `,`\n/tmp/tmpjgksiaa8.d(17): Error: found `;` when expecting `,`\n/tmp/tmpjgksiaa8.d(18): Error: expression expected, not `}`\n/tmp/tmpjgksiaa8.d(20): Error: found `auto` when expecting `,`\n/tmp/tmpjgksiaa8.d(20): Error: found `;` when expecting `,`\n/tmp/tmpjgksiaa8.d(22): Error: expression expected, not `foreach`\n/tmp/tmpjgksiaa8.d(22): Error: found `;` when expecting `,`\n/tmp/tmpjgksiaa8.d(22): E",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tpq.put(tuple(0, 0, nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i][0] = t[2];\n\t\tresult[i][1] = t[3];\n\t\tif (t[0] == nums1.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp5jva2x41.d(14): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5jva2x41.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i, n; nums1)\n\t{\n\t\tminHeap.push(tuple(n, nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpb0uy8h4g.d(15): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb0uy8h4g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\tif (k == 0) return [];\n\t\n\tauto heap = new MinHeap!(Tuple!(long, long, long, long))();\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto visited = new bool[n1][n2];\n\tvisited[0][0] = true;\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[1], t[2]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[2] + 1 < n2 && !visited[t[1]][t[2] + 1])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t\t\tvisited[t[1]][t[2] + 1] = true;\n\t\t\t}\n\t\t\tif (t[1] + 1 < n1 && !visited[t[1] + 1][t[2]])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 0));\n\t\t\t\tvisited[t[1] + 1][t[2]] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[1] + 1 < n1 && !visited[t[1] + 1][t[2]])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp8fqluz97.d(46): Error: expression expected, not `unittest`\n/tmp/tmp8fqluz97.d(47): Error: found `{` when expecting `,`\n/tmp/tmp8fqluz97.d(48): Error: expression expected, not `alias`\n/tmp/tmp8fqluz97.d(48): Error: found `candidate` when expecting `,`\n/tmp/tmp8fqluz97.d(48): Error: expression expected, not `=`\n/tmp/tmp8fqluz97.d(48): Error: found `k_smallest_pairs` when expecting `,`\n/tmp/tmp8fqluz97.d(48): Error: expression expected, not `;`\n/tmp/tmp8fqluz97.d(50): Error: found `assert` when expecting `,`\n/tmp/tmp8fqluz97.d(50): Error: found `;` when expecting `,`\n/tmp/tmp8fqluz97.d(51): Error: found `;` when expecting `,`\n/tmp/tmp8fqluz97.d(52): Error: found `;` when expecting `,`\n/tmp/tmp8fqluz97.d(53): Error: expression expected, not `}`\n/tmp/tmp8fqluz97.d(54): Error: found `void` when expecting `,`\n/tmp/tmp8fqluz97.d(54): Error: found `{` when expecting `,`\n/tmp/tmp8fqluz97.d(54): Error: expression expected, not `}`\n/tmp/tmp8fqluz97.d(54): Error: found `End of File` when expecting `,`\n/tmp/tmp8fql",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, num; nums1) \n\t{\n\t\tmin_heap.push(tuple(num, nums2[0], i, 0));\n\t}\n\t\n\twhile (k-- > 0 && !min_heap.empty) \n\t{\n\t\tauto t = min_heap.pop;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[3] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmin_heap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp3l_1v9gg.d(17): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3l_1v9gg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\");\n\tforeach (i, n1; nums1)\n\t\tforeach (j, n2; nums2)\n\t\t\tpq.put(tuple(n1 + n2, i, j, 0));\n\t\n\tlong[][] res;\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tif (t[3] == 1)\n\t\t\tcontinue;\n\t\tres ~= [t[1], t[2]];\n\t\tt[3] = 1;\n\t\tpq.put(t);\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpybx_ghmw.d(10): Error: template instance `PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpybx_ghmw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif(len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(tuple!(long, long, long, long))(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\tauto result = new long[][](k);\n\tauto count = 0;\n\t\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[count] = [nums1[pair[1]], nums2[pair[2]]];\n\t\tcount++;\n\t\t\n\t\tif(pair[3] == 1 && pair[1] + 1 < len1)\n\t\t\tminHeap.push(tuple(nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2], 1));\n\t\t\n\t\tif(pair[3] == 2 && pair[2] + 1 < len2)\n\t\t\tminHeap.push(tuple(nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpa7is0a20.d(16): Error: template instance `MinHeap!(tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa7is0a20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto result = new long[][](k);\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long))();\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(minHeap.top[0] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = minHeap.top[1];\n\t\tresult[i][1] = minHeap.top[2];\n\t\tminHeap.pop();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpg3_ay1sx.d(11): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg3_ay1sx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto res = new long[][](n);\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1665517372,
      "stdout": "",
      "stderr": "/tmp/tmpfecsgop4.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfecsgop4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l, m;\n\tlong min;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\ttemp = new long[nums1.length][nums2.length];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tmin = temp[i][j];\n\t\t\tfor (l = i; l < nums1.length; l++)\n\t\t\t{\n\t\t\t\tfor (m = j; m < nums2.length; m++)\n\t\t\t\t{\n\t\t\t\t\tif (temp[l][m] < min)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin = temp[l][m];\n\t\t\t\t\t\ttemp[l][m] = temp[i][j];\n\t\t\t\t\t\ttemp[i][j] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = temp[i / nums2.length][i % nums2.length] - nums2[i % nums2.length];\n\t\tresult[i][1] = nums2[i % nums2.length];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpklqowc9t.d(18): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpklqowc9t.d(48): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpklqowc9t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto cur = pq.get();\n\t\tresult[i] = new long[](cur[0], cur[1]);\n\t\t\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp31e7jfk1.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp31e7jfk1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[i] = [pair[0], pair[1]];\n\t\t\n\t\tif (pair[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpuw5sl_fm.d(16): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmpuw5sl_fm.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpuw5sl_fm.d(23): Error: function expected before `()`, not `new long[][](2LU)` of type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuw5sl_fm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1) continue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp6h8hxlvo.d(15): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp6h8hxlvo.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6h8hxlvo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tmin_heap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tlong[][] result;\n\t\n\twhile (k-- > 0 && min_heap.length > 0)\n\t{\n\t\tauto t = min_heap.pop();\n\t\t\n\t\tresult ~= [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\tmin_heap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpwjdta8bw.d(12): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwjdta8bw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp5qdlmksj.d(27): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5qdlmksj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(n1, n2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length, 2);\n\tforeach(i, t; pq)\n\t{\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpc8g_y_so.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc8g_y_so.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[] tmp;\n\tlong i, j, n;\n\t\n\tn = nums1.length;\n\tif (n == 0)\n\t\treturn res;\n\t\n\tres = new long[][](k);\n\t\n\ttmp = new long[n];\n\tfor (i = 0; i < n; i++)\n\t\ttmp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tj = minIndex(tmp);\n\t\tres[i] = [nums1[j], nums2[0]];\n\t\tif (nums2.length == 1)\n\t\t\tbreak;\n\t\ttmp[j] = nums1[j] + nums2[1];\n\t\tnums2 = nums2[1..$];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpb2ksqe2n.d(26): Error: undefined identifier `minIndex`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb2ksqe2n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] heap;\n\tlong i, j, n, m, h, t;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\theap = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\theap[i] = pairs[i];\n\t}\n\t\n\tfor (i = k / 2 - 1; i >= 0; i--)\n\t{\n\t\theapify(heap, i, k);\n\t}\n\t\n\tfor (i = k; i < n * m; i++)\n\t{\n\t\tif (pairs[i][0] + pairs[i][1] < heap[0][0] + heap[0][1])\n\t\t{\n\t\t\theap[0] = pairs[i];\n\t\t\theapify(heap, 0, k);\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpn3j4jfrn.d(42): Error: undefined identifier `heapify`\n/tmp/tmpn3j4jfrn.d(50): Error: undefined identifier `heapify`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn3j4jfrn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long));\n\t\n\t// insert the first element\n\tpq.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\t// create a set to store the visited elements\n\tauto visited = new HashSet!(tuple(long, long));\n\t\n\t// create a result array\n\tauto result = new long[][](k);\n\t\n\t// while the queue is not empty\n\twhile (!pq.empty)\n\t{\n\t\t// get the top element\n\t\tauto top = pq.top;\n\t\t\n\t\t// pop the top element\n\t\tpq.pop;\n\t\t\n\t\t// if the element is already visited, continue\n\t\tif (visited.contains(top[1 .. $])) continue;\n\t\t\n\t\t// add the element to the result array\n\t\tresult[top[3]] = [top[1], top[2]];\n\t\t\n\t\t// add the element to the visited set\n\t\tvisited.insert(top[1 .. $]);\n\t\t\n\t\t// if the result array is full, break\n\t\tif (top[3] == k - 1) break;\n\t\t\n\t\t// if the first element is not the last element\n\t\tif (top[1] + 1 < n1)\n\t\t{\n\t\t\t// insert the next element\n\t\t\tpq.insert(tuple(nums1[top[1] + 1] + nums2[top[2]], top[1] + 1, top[2], top[3] + 1));\n\t\t}\n\t\t\n\t\t// if the second element is not the last element\n\t\tif (top[2] + 1 < n2)\n\t\t{\n\t\t\t// insert the next element\n\t\t\tpq.insert(tuple(nums1[\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmppe_7aiw3.d(16): Error: found `,` when expecting `.` following long\n/tmp/tmppe_7aiw3.d(16): Error: found `long` when expecting identifier following `long`.\n/tmp/tmppe_7aiw3.d(16): Error: found `,` when expecting `.` following long\n/tmp/tmppe_7aiw3.d(16): Error: found `long` when expecting identifier following `long`.\n/tmp/tmppe_7aiw3.d(22): Error: found `,` when expecting `.` following long\n/tmp/tmppe_7aiw3.d(22): Error: found `long` when expecting identifier following `long`.\n/tmp/tmppe_7aiw3.d(60): Error: expression expected, not `unittest`\n/tmp/tmppe_7aiw3.d(61): Error: found `{` when expecting `,`\n/tmp/tmppe_7aiw3.d(62): Error: expression expected, not `alias`\n/tmp/tmppe_7aiw3.d(62): Error: found `candidate` when expecting `,`\n/tmp/tmppe_7aiw3.d(62): Error: expression expected, not `=`\n/tmp/tmppe_7aiw3.d(62): Error: found `k_smallest_pairs` when expecting `,`\n/tmp/tmppe_7aiw3.d(62): Error: expression expected, not `;`\n/tmp/tmppe_7aiw3.d(64): Error: found `assert` when expecting `,`\n/tmp/tmppe_7aiw3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) return new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] < b[2]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(i, 0, nums1[i] + nums2[0]));\n\t}\n\t\n\tlong[][] res = new long[][](k);\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = new long[] {nums1[t[0]], nums2[t[1]]};\n\t\tif (t[1] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpr8z_5q5w.d(12): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpr8z_5q5w.d(16): Error: declaration expected, not `foreach`\n/tmp/tmpr8z_5q5w.d(16): Error: declaration expected, not `0`\n/tmp/tmpr8z_5q5w.d(19): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr8z_5q5w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\tresult = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpv6t0ur7q.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv6t0ur7q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\t\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpyk3l8ar_.d(23): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyk3l8ar_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpkkyymeoi.d(13): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkkyymeoi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tminHeap.insert(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = minHeap.pop;\n\t\tresult[i] = [nums1[pair[1]], nums2[pair[2]]];\n\t\t\n\t\tif (pair[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert(tuple(nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpq8lsyh9p.d(15): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpq8lsyh9p.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq8lsyh9p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, n; nums1)\n\t{\n\t\tminHeap.push(tuple(n, nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmphsdmmux5.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphsdmmux5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i, num1; nums1) \n\t{\n\t\tpq.put(tuple(num1, nums2[0], i, 0));\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpwx_b3d7p.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwx_b3d7p.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1) continue;\n\t\t\n\t\tminHeap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpzjvcx98w.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzjvcx98w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long))(Tuple!(long, long, long)(0, 0, nums1[0] + nums2[0]), Tuple!(long, long, long)(n1 - 1, n2 - 1, nums1[n1 - 1] + nums2[n2 - 1]));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = pq.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[0] == 0 && t[1] + 1 < n2)\n\t\t\tpq.insert(Tuple!(long, long, long)(0, t[1] + 1, nums1[0] + nums2[t[1] + 1]));\n\t\t\n\t\tif (t[0] + 1 < n1 && t[1] == 0)\n\t\t\tpq.insert(Tuple!(long, long, long)(t[0] + 1, 0, nums1[t[0] + 1] + nums2[0]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpujm5l3bh.d(12): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpujm5l3bh.d(19): Error: template instance `PriorityQueue!(Tuple!(long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpujm5l3bh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp862oc591.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp862oc591.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, index;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tindex = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpfxyq7dv7.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpfxyq7dv7.d(16): Error: variable `i` is shadowing variable `tmpfxyq7dv7.k_smallest_pairs.i`\n/tmp/tmpfxyq7dv7.d(18): Error: variable `j` is shadowing variable `tmpfxyq7dv7.k_smallest_pairs.j`\n/tmp/tmpfxyq7dv7.d(25): Error: no property `sort` for type `long[][]`\n/tmp/tmpfxyq7dv7.d(27): Error: variable `k` cannot be read at compile time\n/tmp/tmpfxyq7dv7.d(28): Error: variable `i` is shadowing variable `tmpfxyq7dv7.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfxyq7dv7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, l;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[l] = pair;\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpognjce1k.d(17): Error: variable `i` is shadowing variable `tmpognjce1k.k_smallest_pairs.i`\n/tmp/tmpognjce1k.d(19): Error: variable `j` is shadowing variable `tmpognjce1k.k_smallest_pairs.j`\n/tmp/tmpognjce1k.d(29): Error: no property `sort` for type `long[][]`\n/tmp/tmpognjce1k.d(32): Error: variable `i` is shadowing variable `tmpognjce1k.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpognjce1k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp5qdlmksj.d(27): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5qdlmksj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index][0] = nums1[i];\n\t\t\tpairs[index][1] = nums2[j];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp67qf2g8i.d(23): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67qf2g8i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto arr = new long[][](n1 * n2);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tfor (size_t j = 0; j < n2; j++)\n\t\t{\n\t\t\tarr[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(arr, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\treturn arr[0 .. min(k, n1 * n2)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmptt_3inai.d(24): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmptt_3inai.d(26): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptt_3inai.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\n\tauto ret = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tret[i] = [t[0], t[1]];\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpaa7usw5c.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaa7usw5c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = MinHeap!(Tuple!(long, long, long, long))();\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\tminHeap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.extractMin();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[t[1]];\n\t\tresult[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\tminHeap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\tminHeap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpdpg7sket.d(12): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdpg7sket.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < n1; i++)\n\t\tmin_heap.insert(tuple(nums1[i] + nums2[0], i, 0, nums2[0]));\n\t\n\tfor (long i = 0; i < k && !min_heap.empty; i++)\n\t{\n\t\tauto t = min_heap.extractMin;\n\t\tresult[i] = [t[0], t[3]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums2[t[2] + 1]));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpl73a42_6.d(12): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl73a42_6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t{\n\t\t\tif (t[3] < n2 - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[3] < n2 - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpq_4psiql.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_4psiql.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach(j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif(nums1[i] + nums2[j] < top[0] + top[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres = new long[][](pq.length);\n\t\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tres[i] = pq.get;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp38grgt9_.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\n/tmp/tmp38grgt9_.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp38grgt9_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\ti = 0;\n\twhile(i < k && i < pairs.length)\n\t{\n\t\tresult[i] = pairs[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpk7xrqjp8.d(14): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpk7xrqjp8.d(25): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7xrqjp8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tlong[][] res = new long[][](min(k, nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length)) \n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t\tif (t[3] == nums2.length - 1) \n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmprnfz98zn.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmprnfz98zn.d(15): Error: declaration expected, not `foreach`\n/tmp/tmprnfz98zn.d(15): Error: declaration expected, not `0`\n/tmp/tmprnfz98zn.d(20): Error: declaration expected, not `foreach`\n/tmp/tmprnfz98zn.d(20): Error: declaration expected, not `0`\n/tmp/tmprnfz98zn.d(23): Error: no identifier for declarator `res[i]`\n/tmp/tmprnfz98zn.d(23): Error: declaration expected, not `=`\n/tmp/tmprnfz98zn.d(24): Error: no identifier for declarator `res[i][0]`\n/tmp/tmprnfz98zn.d(24): Error: declaration expected, not `=`\n/tmp/tmprnfz98zn.d(25): Error: no identifier for declarator `res[i][1]`\n/tmp/tmprnfz98zn.d(25): Error: declaration expected, not `=`\n/tmp/tmprnfz98zn.d(26): Error: declaration expected, not `if`\n/tmp/tmprnfz98zn.d(28): Error: unexpected `(` in declarator\n/tmp/tmprnfz98zn.d(28): Error: unexpected `(` in declarator\n/tmp/tmprnfz98zn.d(28): Error: found `+` when expecting `)`\n/tmp/tmprnfz98zn.d(28): Error: found `1` ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\ti = 0;\n\tforeach(elem1; nums1)\n\t{\n\t\tforeach(elem2; nums2)\n\t\t{\n\t\t\tpairs[i] = [elem1, elem2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp = new long[][](n);\n\t\n\tauto cmp = (long[] a, long[] b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t};\n\t\n\tstd.algorithm.sort(pairs, cmp);\n\t\n\tif (k > n)\n\t\tk = n;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpu_cam47x.d(36): Error: undefined identifier `algorithm` in package `std`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_cam47x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, l, m;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[0];\n\t\tresult[i][1] = nums2[0];\n\t}\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tif (nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1])\n\t\t\t{\n\t\t\t\tresult[k - 1][0] = nums1[i];\n\t\t\t\tresult[k - 1][1] = nums2[j];\n\t\t\t\t\n\t\t\t\tfor (l = k - 1; l > 0; l--)\n\t\t\t\t{\n\t\t\t\t\tif (result[l][0] + result[l][1] < result[l - 1][0] + result[l - 1][1])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp = result[l];\n\t\t\t\t\t\tresult[l] = result[l - 1];\n\t\t\t\t\t\tresult[l - 1] = temp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcb4mhvit.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429921]\n??:? void tmpcb4mhvit.__unittest_L52_C1() [0x428651]\n??:? void tmpcb4mhvit.__modtest() [0x428b10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e4d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x4295fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b179]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b208]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b105]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x4295d5]\n??:? runModuleUnitTests [0x42e2a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429de4]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto res = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")();\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tres ~= [t[0], t[1]];\n\t\tif (t[2] == nums1.length - 1)\n\t\t{\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse if (t[3] == nums2.length - 1)\n\t\t{\n\t\t\tif (t[2] < nums1.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpymf_ea75.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymf_ea75.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [t[0], t[1], t[2]];\n\t\t\n\t\tif (t[1] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t\n\t\tif (t[1] == 0 && t[2] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmphzjjt63v.d(16): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphzjjt63v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new BinaryHeap!(Pair!(long, long))(Pair!(long, long)(0, 0), (a, b) => a.first + a.second < b.first + b.second);\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(heap.length < k)\n\t\t\t{\n\t\t\t\theap.insert(Pair!(long, long)(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap.top.first + heap.top.second)\n\t\t\t\t{\n\t\t\t\t\theap.pop;\n\t\t\t\t\theap.insert(Pair!(long, long)(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](heap.length);\n\t\n\tforeach(i; 0 .. heap.length)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[heap.top.first];\n\t\tresult[i][1] = nums2[heap.top.second];\n\t\theap.pop;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpr0bkveow.d(13): Error: template instance `BinaryHeap!(Pair!(long, long))` template `BinaryHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr0bkveow.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong i, j, n1, n2, n, m, cnt;\n\tlong[] tmp;\n\tlong[][] heap;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1, n2);\n\tm = max(n1, n2);\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn res;\n\t\n\theap = new long[n][2];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\theap[i][0] = nums1[i];\n\t\theap[i][1] = nums2[i];\n\t}\n\t\n\tif (n1 > n2)\n\t{\n\t\ttmp = nums1;\n\t\tnums1 = nums2;\n\t\tnums2 = tmp;\n\t}\n\t\n\tmake_heap(heap);\n\t\n\tres = new long[k][2];\n\tcnt = 0;\n\t\n\twhile (cnt < k)\n\t{\n\t\tres[cnt][0] = heap[0][0];\n\t\tres[cnt][1] = heap[0][1];\n\t\tcnt++;\n\t\t\n\t\tif (cnt == k)\n\t\t\tbreak;\n\t\t\n\t\tif (heap[0][1] == nums2[n2 - 1])\n\t\t{\n\t\t\tpop_heap(heap);\n\t\t\theap[n - 1][0] = nums1[n - 1];\n\t\t\theap[n - 1][1] = nums2[0];\n\t\t\tpush_heap(heap);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpop_heap(heap);\n\t\t\theap[n - 1][0] = heap[n - 1][0];\n\t\t\theap[n - 1][1] = nums2[heap[n - 1][1] + 1];\n\t\t\tpush\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpg4_p9gve.d(65): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpg4_p9gve.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpg4_p9gve.d(73): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpg4_p9gve.d(73): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg4_p9gve.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] < b[2]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(i, 0, nums1[i] + nums2[0]));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[t[0]];\n\t\tresult[i][1] = nums2[t[1]];\n\t\t\n\t\tif (t[1] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmpc27_nzi7.d(11): Error: new can only create structs, dynamic arrays or class objects, not `long[][]`'s\n/tmp/tmpc27_nzi7.d(13): Error: template instance `PriorityQueue!(Tuple!(long, long, long), \"a[2] < b[2]\")` template `PriorityQueue` is not defined\n/tmp/tmpc27_nzi7.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc27_nzi7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i, t; temp)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tres[i] = t;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmplaeuwgek.d(22): Error: no property `sort` for type `long[][]`\n/tmp/tmplaeuwgek.d(24): Error: variable `i` is shadowing variable `tmplaeuwgek.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplaeuwgek.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong i, j, n1, n2;\n\tlong[] temp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\t\n\ttemp = new long[n1];\n\t\n\tfor (i = 0; i < n1; i++)\n\t\ttemp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tlong min = temp[0];\n\t\tlong min_index = 0;\n\t\t\n\t\tfor (j = 1; j < n1; j++)\n\t\t{\n\t\t\tif (temp[j] < min)\n\t\t\t{\n\t\t\t\tmin = temp[j];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[0];\n\t\t\n\t\ttemp[min_index] = long.max;\n\t\t\n\t\tif (i < k - 1)\n\t\t{\n\t\t\tif (min_index == n1 - 1)\n\t\t\t\ttemp[min_index] = long.max;\n\t\t\telse\n\t\t\t\ttemp[min_index] = nums1[min_index] + nums2[1];\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_g0s3g1l.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x4297b9]\n??:? void tmp_g0s3g1l.__unittest_L58_C1() [0x4284e9]\n??:? void tmp_g0s3g1l.__modtest() [0x4289a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e36b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b011]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b0a0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42af9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42946d]\n??:? runModuleUnitTests [0x42e141]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429c7c]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmphohgj7y0.d(22): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphohgj7y0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmptipoyc3w.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmptipoyc3w.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptipoyc3w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long));\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\tif (t[2] == 0 && t[1] + 1 < nums1.length)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\tif (t[2] + 1 < nums2.length)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "/tmp/tmp9i_im75o.d(14): Error: found `,` when expecting `.` following long\n/tmp/tmp9i_im75o.d(14): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp9i_im75o.d(14): Error: found `,` when expecting `.` following long\n/tmp/tmp9i_im75o.d(14): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9i_im75o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmppykcokez.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppykcokez.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto res = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn res;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = heap.popFront();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = nums1[t[1]];\n\t\tres[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpy68r6q01.d(12): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy68r6q01.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpovrd6xko.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpovrd6xko.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i, e1; nums1) \n\t{\n\t\tminHeap.push(tuple(e1, nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (minHeap.empty) \n\t\t\tbreak;\n\t\t\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1) \n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpa6m1s70x.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa6m1s70x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n - 1)\n\t\t{\n\t\t\tif (t[3] < m - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse if (t[3] == m - 1)\n\t\t{\n\t\t\tif (t[2] < n - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmplcfyarxk.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplcfyarxk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\tlong[] temp;\n\tlong[] temp_pair;\n\tlong temp_sum;\n\tlong min_sum;\n\tlong min_index;\n\tlong count;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp_pair = new long[2];\n\t\t\ttemp_pair[0] = nums1[i];\n\t\t\ttemp_pair[1] = nums2[j];\n\t\t\tpairs[i * nums2.length + j] = temp_pair;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\tmin_sum = pairs[i][0] + pairs[i][1];\n\t\tmin_index = i;\n\t\tfor (j = i + 1; j < pairs.length; j++)\n\t\t{\n\t\t\ttemp_sum = pairs[j][0] + pairs[j][1];\n\t\t\tif (temp_sum < min_sum)\n\t\t\t{\n\t\t\t\tmin_sum = temp_sum;\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\ttemp = pairs[i];\n\t\tpairs[i] = pairs[min_index];\n\t\tpairs[min_index] = temp;\n\t}\n\t\n\tcount = 0;\n\tresult = new long[k][];\n\tfor (i = 0; i < pairs.length && count < k; i++)\n\t{\n\t\tresult[count] = pairs[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpalj3ks_t.d(23): Error: variable `nums1` cannot be read at compile time\n/tmp/tmpalj3ks_t.d(55): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpalj3ks_t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp33nqtug6.d(30): Error: no property `sort` for type `long[][]`\n/tmp/tmp33nqtug6.d(32): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp33nqtug6.d(34): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33nqtug6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(len1, k))\n\t{\n\t\tforeach (j; 0 .. min(len2, k))\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = minHeap.top;\n\t\t\t\tif (nums1[i] + nums2[j] < top[0] + top[1])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn minHeap.data;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp3g1798qf.d(15): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmp3g1798qf.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3g1798qf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = t[];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpzgn6d0xv.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgn6d0xv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\theap.insert(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] < n2 - 1)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp4yf1r8hw.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4yf1r8hw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpcqksa5bn.d(16): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcqksa5bn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto nums1_size = nums1.length;\n\tauto nums2_size = nums2.length;\n\tauto result = new long[][](k);\n\tauto result_size = 0;\n\tauto nums1_index = new long[nums1_size];\n\tauto nums2_index = new long[nums2_size];\n\t\n\tfor (auto i = 0; i < nums1_size; i++)\n\t{\n\t\tnums1_index[i] = 0;\n\t}\n\t\n\tfor (auto i = 0; i < nums2_size; i++)\n\t{\n\t\tnums2_index[i] = 0;\n\t}\n\t\n\twhile (result_size < k)\n\t{\n\t\tauto min_value = long.max;\n\t\tauto min_index = -1;\n\t\t\n\t\tfor (auto i = 0; i < nums1_size; i++)\n\t\t{\n\t\t\tif (nums1_index[i] < nums2_size)\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[nums1_index[i]] < min_value)\n\t\t\t\t{\n\t\t\t\t\tmin_value = nums1[i] + nums2[nums1_index[i]];\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto i = 0; i < nums2_size; i++)\n\t\t{\n\t\t\tif (nums2_index[i] < nums1_size)\n\t\t\t{\n\t\t\t\tif (nums2[i] + nums1[nums2_index[i]] < min_value)\n\t\t\t\t{\n\t\t\t\t\tmin_value = nums2[i] + nums1[nums2_index[i]];\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (min\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpoxhxztbc.d(57): Error: found `unittest` when expecting `)`\n/tmp/tmpoxhxztbc.d(65): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpoxhxztbc.d(65): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoxhxztbc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\tindices[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpwhq_tcld.d(24): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\n/tmp/tmpwhq_tcld.d(26): Error: variable `i` is shadowing variable `tmpwhq_tcld.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwhq_tcld.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] tmp;\n\tlong i, j;\n\tlong n1, n2;\n\tlong min;\n\tlong min_i, min_j;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\ttmp = new long[][](n1);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\ttmp[i] = new long[n2];\n\t\tfor (j = 0; j < n2; j++)\n\t\t\ttmp[i][j] = nums1[i] + nums2[j];\n\t}\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = tmp[0][0];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\tfor (j = 0; j < n1; j++)\n\t\t{\n\t\t\tfor (long l = 0; l < n2; l++)\n\t\t\t{\n\t\t\t\tif (tmp[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = tmp[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_i];\n\t\tresult[i][1] = nums2[min_j];\n\t\ttmp[min_i][min_j] = long.max;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tforeach (j; 0 .. n2)\n\t\t{\n\t\t\tif (min_heap.length < k)\n\t\t\t\tmin_heap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < min_heap.top[0])\n\t\t\t\t{\n\t\t\t\t\tmin_heap.pop;\n\t\t\t\t\tmin_heap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpuwj5q8dz.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuwj5q8dz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(int, int, int), \"a[2] < b[2]\");\n\tpq.put(tuple(0, 0, nums1[0] + nums2[0]));\n\t\n\tauto seen = new bool[][](n1, n2);\n\tseen[0][0] = true;\n\t\n\tauto res = new long[][](k);\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto [x, y, _] = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = nums1[x];\n\t\tres[i][1] = nums2[y];\n\t\tif (x + 1 < n1 && !seen[x + 1][y])\n\t\t{\n\t\t\tpq.put(tuple(x + 1, y, nums1[x + 1] + nums2[y]));\n\t\t\tseen[x + 1][y] = true;\n\t\t}\n\t\tif (y + 1 < n2 && !seen[x][y + 1])\n\t\t{\n\t\t\tpq.put(tuple(x, y + 1, nums1[x] + nums2[y + 1]));\n\t\t\tseen[x][y + 1] = true;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpr7pnzgrs.d(24): Error: basic type expected, not `[`\n/tmp/tmpr7pnzgrs.d(24): Error: found `,` when expecting `]`\n/tmp/tmpr7pnzgrs.d(24): Error: semicolon expected, not `]`\n/tmp/tmpr7pnzgrs.d(24): Error: found `]` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr7pnzgrs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tfor (long i = 0; i < k; ++i)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmppnr3gfz9.d(12): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnr3gfz9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto res = new long[][](len, 2);\n\t\n\tif (len1 == 0 || len2 == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. len)\n\t\tpq.put([nums1[i], nums2[i]]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = cur;\n\t\tif (cur[1] < nums2[len2 - 1])\n\t\t\tpq.put([cur[0], cur[1] + 1]);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpwgdovmsm.d(12): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpwgdovmsm.d(18): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwgdovmsm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong[long] idx;\n\tlong[long] idx_pairs;\n\tlong[long] idx_res;\n\tlong[long] idx_pairs_res;\n\tlong[long] idx_pairs_res_tmp;\n\tlong[long] idx_pairs_res_tmp2;\n\tlong[long] idx_pairs_res_tmp3;\n\tlong[long] idx_pairs_res_tmp4;\n\tlong[long] idx_pairs_res_tmp5;\n\tlong[long] idx_pairs_res_tmp6;\n\tlong[long] idx_pairs_res_tmp7;\n\tlong[long] idx_pairs_res_tmp8;\n\tlong[long] idx_pairs_res_tmp9;\n\tlong[long] idx_pairs_res_tmp10;\n\tlong[long] idx_pairs_res_tmp11;\n\tlong[long] idx_pairs_res_tmp12;\n\tlong[long] idx_pairs_res_tmp13;\n\tlong[long] idx_pairs_res_tmp14;\n\tlong[long] idx_pairs_res_tmp15;\n\tlong[long] idx_pairs_res_tmp16;\n\tlong[long] idx_pairs_res_tmp17;\n\tlong[long] idx_pairs_res_tmp18;\n\tlong[long] idx_pairs_res_tmp19;\n\tlong[long] idx_pairs_res_tmp20;\n\tlong[long] idx_pairs_res_tmp21;\n\tlong[long] idx_pairs_res_tmp22;\n\tlong[long] idx_pairs_res_tmp23;\n\tlong[long] idx_pairs_res_tmp24;\n\tlong[long] idx_pairs_res_tmp25;\n\t\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpg27w6byc.d(46): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg27w6byc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)))();\n\t\n\tforeach (i, n1; nums1)\n\t{\n\t\tforeach (j, n2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert(tuple(n1 + n2, i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (n1 + n2 < minHeap.top.tupleof[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.insert(tuple(n1 + n2, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto res = new long[][](minHeap.length);\n\tforeach (i, t; minHeap)\n\t{\n\t\tres[i] = [nums1[t.tupleof[1]], nums2[t.tupleof[2]]];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpeazvjrdr.d(15): Error: template instance `MinHeap!(typeof(Tuple!(long, long, long)))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeazvjrdr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tlong[][] result = new long[][](k);\n\tif(n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto cmp = (long[] a, long[] b) => a[0] + a[1] < b[0] + b[1];\n\tauto pq = new PriorityQueue!(cmp)();\n\t\n\tforeach(i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put(new long[](nums1[i / n2], nums2[i % n2]));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpj5fzacbv.d(10): Error: cannot implicitly convert expression `nums1.length` of type `ulong` to `int`\n/tmp/tmpj5fzacbv.d(11): Error: cannot implicitly convert expression `nums2.length` of type `ulong` to `int`\n/tmp/tmpj5fzacbv.d(17): Error: template instance `PriorityQueue!cmp` template `PriorityQueue` is not defined\n/tmp/tmpj5fzacbv.d(19): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj5fzacbv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek[0] + pq.peek[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpumc60qq3.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpumc60qq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tminHeap.push(tuple(nums1[i / n2], nums2[i % n2], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0)\n\t\t{\n\t\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpa75cviqs.d(16): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpa75cviqs.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa75cviqs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tlong[][] result;\n\t\n\twhile (k > 0 && !heap.empty)\n\t{\n\t\tauto t = heap.popFront();\n\t\t\n\t\tresult ~= [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[2] < n2 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 0));\n\t\t\t\n\t\t\tif (t[1] < n1 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[1] < n1 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t}\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpqlj9e296.d(16): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqlj9e296.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](min(k, len1 * len2));\n\tauto index = 0;\n\twhile (index < k && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[index] = [t[0], t[1]];\n\t\tif (t[2] == len2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpvaar0mcw.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpvaar0mcw.d(17): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpvaar0mcw.d(20): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvaar0mcw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto res = new long[][](k);\n\tauto i = 0;\n\twhile (i < k && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i++] = t[0 .. 2];\n\t\tif (t[2] == n2 - 1) continue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\treturn res[0 .. i];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpb01e0dtj.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpb01e0dtj.d(16): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb01e0dtj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tminHeap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.extractMin;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < n2)\n\t\t\tminHeap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, 0));\n\t\t\n\t\tif (t[3] == 0 && t[2] + 1 < n1)\n\t\t\tminHeap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpx4emttm4.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx4emttm4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = cur[0 .. 2];\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpnyem5prf.d(15): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpnyem5prf.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnyem5prf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\t\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tauto heap = new PriorityQueue!(comp)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (heap.length < k)\n\t\t\t{\n\t\t\t\theap.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < heap.peek[0] + heap.peek[1])\n\t\t\t\t{\n\t\t\t\t\theap.get();\n\t\t\t\t\theap.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpmtdp4jax.d(18): Error: variable `tmpmtdp4jax.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] > b[0] + b[1]`, and variables cannot be of type `void`\n/tmp/tmpmtdp4jax.d(18): Error: template lambda has no value\n/tmp/tmpmtdp4jax.d(20): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtdp4jax.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = n1;\n\t\t\tpair[1] = n2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmppo9m_cjh.d(30): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo9m_cjh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres = new long[][](pq.length);\n\tforeach (i; 0 .. pq.length) \n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpnkdqwjwh.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnkdqwjwh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile(k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp65tx5qe9.d(15): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmp65tx5qe9.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp65tx5qe9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i, e1; nums1)\n\t{\n\t\tforeach (j, e2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(tuple(e1 + e2, i, j));\n\t\t\telse if (e1 + e2 < minHeap.top[0])\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push(tuple(e1 + e2, i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i, e; minHeap)\n\t{\n\t\tresult[i] = [nums1[e[1]], nums2[e[2]]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp4x85xhhq.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4x85xhhq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]));\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tauto t = pq.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[1] + 1 < nums2.length)\n\t\t\tpq.put(Tuple!(long, long)(t[0], t[1] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp8ihuj8ka.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]))` template `PriorityQueue` is not defined\n/tmp/tmp8ihuj8ka.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ihuj8ka.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[count] = [nums1[i], nums2[j]];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tres[i] = temp[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpe_m3po9d.d(22): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_m3po9d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto min_heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tmin_heap.insert(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop();\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif (t[2] == n2 - 1) continue;\n\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpdplm2mke.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmpdplm2mke.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdplm2mke.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong min;\n\tlong min_index;\n\tlong min_index_2;\n\tlong min_index_3;\n\tlong min_index_4;\n\tlong min_index_5;\n\tlong min_index_6;\n\tlong min_index_7;\n\tlong min_index_8;\n\tlong min_index_9;\n\tlong min_index_10;\n\tlong min_index_11;\n\tlong min_index_12;\n\tlong min_index_13;\n\tlong min_index_14;\n\tlong min_index_15;\n\tlong min_index_16;\n\tlong min_index_17;\n\tlong min_index_18;\n\tlong min_index_19;\n\tlong min_index_20;\n\tlong min_index_21;\n\tlong min_index_22;\n\tlong min_index_23;\n\tlong min_index_24;\n\tlong min_index_25;\n\tlong min_index_26;\n\tlong min_index_27;\n\tlong min_index_28;\n\tlong min_index_29;\n\tlong min_index_30;\n\tlong min_index_31;\n\tlong min_index_32;\n\tlong min_index_33;\n\tlong min_index_34;\n\tlong min_index_35;\n\tlong min_index_36;\n\tlong min_index_37;\n\tlong min_index_38;\n\tlong min_index_39;\n\tlong min_index_40;\n\tlong min_index_41;\n\tlong min_index_42;\n\tlong min_index_43;\n\tlong min_index_44;\n\tlong min_index_45;\n\tlong min_index_46;\n\tlong min_index_47;\n\tlong min_index_48;\n\tlong min_index_49;\n\tlong min_index_50;\n\tlong min_index_51;\n\tlong min_index_52;\n\tlong min_index_53;\n\tlong min\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpc4vh1822.d(69): Error: semicolon expected, not `unittest`\n/tmp/tmpc4vh1822.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc4vh1822.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result[0 .. i];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpe4ebjq3w.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpe4ebjq3w.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpe4ebjq3w.d(37): Error: undefined identifier `i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe4ebjq3w.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = [cur[0], cur[1]];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp6v8qhjzt.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1])` template `PriorityQueue` is not defined\n/tmp/tmp6v8qhjzt.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6v8qhjzt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto top = minHeap.pop();\n\t\tresult[i] = [top[0], top[1]];\n\t\t\n\t\tif (top[3] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[3] + 1], top[2], top[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp5u11e90l.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\n/tmp/tmp5u11e90l.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5u11e90l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long))(Tuple!(long, long, long, long)(0, 0, 0, 0), Tuple!(long, long, long, long)(n, m, n, m));\n\tauto result = new long[][](0);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\theap.insert(Tuple!(long, long, long, long)(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && heap.length > 0)\n\t{\n\t\tauto t = heap.popFront();\n\t\t\n\t\tif (t[1] < t[2])\n\t\t{\n\t\t\tresult ~= [nums1[t[1]], nums2[t[3]]];\n\t\t\theap.insert(Tuple!(long, long, long, long)(nums1[t[1] + 1] + nums2[t[3]], t[1] + 1, t[2], t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= [nums1[t[1]], nums2[t[3]]];\n\t\t\theap.insert(Tuple!(long, long, long, long)(nums1[t[1]] + nums2[t[3] + 1], t[1], t[2], t[3] + 1));\n\t\t}\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpbam4no2x.d(12): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbam4no2x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmphr756nvj.d(14): Error: variable `tmphr756nvj.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] - (b[0] + b[1])`, and variables cannot be of type `void`\n/tmp/tmphr756nvj.d(14): Error: template lambda has no value\n/tmp/tmphr756nvj.d(16): Error: template instance `PriorityQueue!(typeof(comp))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphr756nvj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j;\n\tlong size1 = nums1.length;\n\tlong size2 = nums2.length;\n\t\n\tif (size1 == 0 || size2 == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tif (k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tif (k > size1 * size2)\n\t{\n\t\tk = size1 * size2;\n\t}\n\t\n\ttemp = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t}\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i][0] = nums1[0];\n\t\ttemp[i][1] = nums2[i];\n\t}\n\t\n\tfor (i = 1; i < size1; i++)\n\t{\n\t\tfor (j = 0; j < size2; j++)\n\t\t{\n\t\t\tif (nums1[i] + nums2[j] < temp[k - 1][0] + temp[k - 1][1])\n\t\t\t{\n\t\t\t\ttemp[k - 1][0] = nums1[i];\n\t\t\t\ttemp[k - 1][1] = nums2[j];\n\t\t\t\t\n\t\t\t\tfor (long m = k - 1; m > 0; m--)\n\t\t\t\t{\n\t\t\t\t\tif (temp[m][0] + temp[m][1] < temp[m - 1][0] + temp[m - 1][1])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong[] t = temp[m];\n\t\t\t\t\t\ttemp[m] = temp[m - 1];\n\t\t\t\t\t\ttemp[m - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult =\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpfhtv0drj.d(67): Error: expression expected, not `unittest`\n/tmp/tmpfhtv0drj.d(68): Error: found `{` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhtv0drj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek[0] + pq.peek[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp7jegqmvl.d(14): Error: variable `tmp7jegqmvl.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b)\n{\nreturn a[0] + a[1] < b[0] + b[1];\n}\n`, and variables cannot be of type `void`\n/tmp/tmp7jegqmvl.d(14): Error: template lambda has no value\n/tmp/tmp7jegqmvl.d(15): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7jegqmvl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto comp = (Tuple!(long, long, long) a, Tuple!(long, long, long) b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t};\n\t\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tlong[][] res;\n\twhile (k-- > 0 && !pq.empty())\n\t{\n\t\tauto t = pq.get();\n\t\tres ~= [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpu2x6380g.d(19): Error: template instance `PriorityQueue!comp` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2x6380g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpbdvm4jkl.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbdvm4jkl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tforeach (j; 0 .. min(k, nums2.length)) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto pair = pq.get();\n\t\t\t\tif (pair[0] + pair[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp917fegey.d(14): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\n/tmp/tmp917fegey.d(15): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp917fegey.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, m, n;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\ttemp = new long[][](m, n);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = temp.sort();\n\t\n\tresult = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpg5fdubc9.d(30): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg5fdubc9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn [];\n\t\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long))(tuple!(long, long, long, long)(0, 0, nums1[0], nums2[0]), std.less!(tuple!(long, long, long, long)));\n\t\n\tlong[][] result;\n\t\n\twhile(k-- > 0)\n\t{\n\t\tauto t = pq.front;\n\t\tpq.popFront();\n\t\tresult ~= [t[2], t[3]];\n\t\t\n\t\tif(t[0] == nums1.length - 1)\n\t\t{\n\t\t\tif(t[1] < nums2.length - 1)\n\t\t\t\tpq.push(tuple!(long, long, long, long)(t[0], t[1] + 1, t[2], nums2[t[1] + 1]));\n\t\t}\n\t\telse if(t[1] == nums2.length - 1)\n\t\t{\n\t\t\tif(t[0] < nums1.length - 1)\n\t\t\t\tpq.push(tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.push(tuple!(long, long, long, long)(t[0], t[1] + 1, t[2], nums2[t[1] + 1]));\n\t\t\tpq.push(tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp3r84e81r.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3r84e81r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get().array;\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmptl_hm7au.d(11): Error: new can only create structs, dynamic arrays or class objects, not `long[][]`'s\n/tmp/tmptl_hm7au.d(13): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptl_hm7au.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpqiud7jnn.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqiud7jnn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmppyx76lgv.d(15): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmppyx76lgv.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppyx76lgv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp8ja8sgd2.d(15): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ja8sgd2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[][] visited = new long[][](nums1.length, nums2.length);\n\tvisited[0][0] = 1;\n\t\n\tlong count = 0;\n\twhile (count < k && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult[count] = cur;\n\t\tcount++;\n\t\t\n\t\tif (cur[0] + 1 < nums1.length && visited[cur[0] + 1][cur[1]] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0] + 1, cur[1]));\n\t\t\tvisited[cur[0] + 1][cur[1]] = 1;\n\t\t}\n\t\t\n\t\tif (cur[1] + 1 < nums2.length && visited[cur[0]][cur[1] + 1] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0], cur[1] + 1));\n\t\t\tvisited[cur[0]][cur[1] + 1] = 1;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp7ftric6d.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ftric6d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t}\n\t}\n\t\n\tlong[][] result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tif(t[3] == 0)\n\t\t{\n\t\t\tresult[i] = new long[](2);\n\t\t\tresult[i][0] = nums1[t[1]];\n\t\t\tresult[i][1] = nums2[t[2]];\n\t\t\tpq.put(tuple(t[0], t[1], t[2], 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp02abwcmr.d(10): Error: template instance `PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp02abwcmr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\theap.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmprd84qtyt.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprd84qtyt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v, nums2[0], i, 0));\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t\t\n\t\tif (t[3] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpary4bc33.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpary4bc33.d(15): Error: declaration expected, not `foreach`\n/tmp/tmpary4bc33.d(15): Error: no identifier for declarator `nums1`\n/tmp/tmpary4bc33.d(15): Error: declaration expected, not `)`\n/tmp/tmpary4bc33.d(20): Error: declaration expected, not `foreach`\n/tmp/tmpary4bc33.d(20): Error: declaration expected, not `0`\n/tmp/tmpary4bc33.d(23): Error: no identifier for declarator `res[i]`\n/tmp/tmpary4bc33.d(23): Error: declaration expected, not `=`\n/tmp/tmpary4bc33.d(24): Error: no identifier for declarator `res[i][0]`\n/tmp/tmpary4bc33.d(24): Error: declaration expected, not `=`\n/tmp/tmpary4bc33.d(25): Error: no identifier for declarator `res[i][1]`\n/tmp/tmpary4bc33.d(25): Error: declaration expected, not `=`\n/tmp/tmpary4bc33.d(27): Error: declaration expected, not `if`\n/tmp/tmpary4bc33.d(30): Error: unexpected `(` in declarator\n/tmp/tmpary4bc33.d(30): Error: unexpected `(` in declarator\n/tmp/tmpary4bc33.d(30): Error: fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpairs[index++] = [nums1[i], nums2[j]];\n\tpairs = pairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach(i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpl_5u6et_.d(16): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl_5u6et_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpbqnjmcqh.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpbqnjmcqh.d(16): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbqnjmcqh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpor52d7kj.d(14): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpor52d7kj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long))();\n\t\n\tif(n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tfor(long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1], t[2]];\n\t\tif(t[1] == 0 && t[2] + 1 < m)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\tif(t[1] + 1 < n)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpb5toda34.d(13): Error: template instance `PriorityQueue!(tuple!(long, long, long))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb5toda34.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == 0 && t[3] + 1 < n2)\n\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif (t[2] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmppcnqnfqe.d(15): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppcnqnfqe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](n1 * n2);\n\tauto cnt = 0;\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tres[cnt][0] = nums1[i];\n\t\t\tres[cnt][1] = nums2[j];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tstd.algorithm.sort(res[0 .. cnt], comp);\n\treturn res[0 .. min(k, cnt)];\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp7mhlmx0y.d(24): Error: variable `tmp7mhlmx0y.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b)\n{\nreturn a[0] + a[1] < b[0] + b[1];\n}\n`, and variables cannot be of type `void`\n/tmp/tmp7mhlmx0y.d(24): Error: template lambda has no value\n/tmp/tmp7mhlmx0y.d(25): Error: undefined identifier `algorithm` in package `std`\n/tmp/tmp7mhlmx0y.d(26): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mhlmx0y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpdmdvymv3.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdmdvymv3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto nums1_size = nums1.length;\n\tauto nums2_size = nums2.length;\n\t\n\tif (nums1_size == 0 || nums2_size == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(long[2]);\n\t\n\tforeach (i; 0 .. min(k, nums1_size))\n\t{\n\t\tmin_heap.insert([nums1[i], nums2[0]]);\n\t}\n\t\n\tauto result = new long[][2](min_heap.size);\n\t\n\tforeach (i; 0 .. min(k, nums1_size * nums2_size))\n\t{\n\t\tauto pair = min_heap.pop();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[nums2_size - 1])\n\t\t{\n\t\t\tauto next_pair = [pair[0], pair[1] + 1];\n\t\t\tmin_heap.insert(next_pair);\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmprxi82vro.d(16): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmprxi82vro.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmprxi82vro.d(25): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprxi82vro.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.extractMin();\n\t\tresult[i] = pair[0 .. 2];\n\t\t\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpd508dd10.d(16): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\n/tmp/tmpd508dd10.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpd508dd10.d(23): Error: function expected before `()`, not `new long[][](2LU)` of type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd508dd10.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)))();\n\t\n\tforeach (i, num1; nums1)\n\t{\n\t\tminHeap.push(tuple(num1, nums2[0], 0));\n\t}\n\t\n\tlong[][] result;\n\twhile (k-- > 0 && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpg6um75so.d(15): Error: template instance `MinHeap!(typeof(Tuple!(long, long, long)))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg6um75so.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, v; nums1)\n\t\tforeach(j, w; nums2)\n\t\t\tpq.put(tuple(v, w, i, j));\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpgria5sho.d(10): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgria5sho.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || a[2] == b[2] && a[3] < b[3]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](min(k, n1 * n2));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpn2uekojq.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || a[2] == b[2] && a[3] < b[3]\")` template `PriorityQueue` is not defined\n/tmp/tmpn2uekojq.d(18): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpn2uekojq.d(21): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpn2uekojq.d(23): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn2uekojq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long))();\n\t\n\t// add first row\n\tforeach (i, num; nums2)\n\t\tminHeap.add(tuple(nums1[0] + num, 0, i, num));\n\t\n\tlong[][] result;\n\t\n\twhile (k-- > 0 && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult ~= [t[1], t[3]];\n\t\t\n\t\tif (t[0] < n1 - 1)\n\t\t\tminHeap.add(tuple(nums1[t[0] + 1] + nums2[t[2]], t[0] + 1, t[2], nums2[t[2]]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp2wov2uag.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2wov2uag.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp294m7hi7.d(19): Error: variable `i` is shadowing variable `tmp294m7hi7.k_smallest_pairs.i`\n/tmp/tmp294m7hi7.d(20): Error: variable `j` is shadowing variable `tmp294m7hi7.k_smallest_pairs.j`\n/tmp/tmp294m7hi7.d(23): Error: no property `sort` for type `long[][]`\n/tmp/tmp294m7hi7.d(27): Error: variable `i` is shadowing variable `tmp294m7hi7.k_smallest_pairs.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp294m7hi7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length == k)\n\t\t\t{\n\t\t\t\tif(pq.front[0] + pq.front[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.popFront();\n\t\t\t\t\tpq.pushBack([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.pushBack([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t}\n\t}\n\tresult = pq.data;\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp93krlymx.d(11): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93krlymx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(nums1[0] + nums2[0]));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tforeach (j; 0 .. n2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(nums1[i] + nums2[j]);\n\t\t\telse if (nums1[i] + nums2[j] < minHeap.top)\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push(nums1[i] + nums2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn minHeap.data;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmps_dho4mc.d(16): Error: template instance `MinHeap!(typeof(nums1[0] + nums2[0]))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps_dho4mc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong[] pair_;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong l;\n\tlong r;\n\tlong mid;\n\tlong count;\n\tlong count_;\n\tlong index;\n\tlong index_;\n\tlong min;\n\tlong min_;\n\tlong max;\n\tlong max_;\n\tlong min_index;\n\tlong min_index_;\n\tlong max_index;\n\tlong max_index_;\n\tlong min_count;\n\tlong min_count_;\n\tlong max_count;\n\tlong max_count_;\n\tlong min_index_count;\n\tlong min_index_count_;\n\tlong max_index_count;\n\tlong max_index_count_;\n\tlong min_index_count_index;\n\tlong min_index_count_index_;\n\tlong max_index_count_index;\n\tlong max_index_count_index_;\n\tlong min_index_count_index_count;\n\tlong min_index_count_index_count_;\n\tlong max_index_count_index_count;\n\tlong max_index_count_index_count_;\n\tlong min_index_count_index_count_index;\n\tlong min_index_count_index_count_index_;\n\tlong max_index_count_index_count_index;\n\tlong max_index_count_index_count_index_;\n\tlong min_index_count_index_count_index_count;\n\tlong min_index_count_index_count_index_count_;\n\tlong max_index_count_index_count_index_count;\n\tlong max_index_count_index_count_index_count_;\n\tlong min_index_count_index_count_index_count_index;\n\tlong min_index_count_index_count_index_count_index_;\n\tlong max_index_count_index_count_index_count_index;\n\tlong max_index_count_index_count_index\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp1e5g1yop.d(61): Error: semicolon expected, not `unittest`\n/tmp/tmp1e5g1yop.d(61): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1e5g1yop.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] heap = new long[][](nums1.length * nums2.length);\n\tlong heapSize = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap[heapSize] = [nums1[i] + nums2[j], i, j];\n\t\t\theapSize++;\n\t\t}\n\t}\n\t\n\theap = heap[0 .. heapSize];\n\t\n\theap = heap.sort!((a, b) => a[0] < b[0]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = [heap[i][1], heap[i][2]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpwqcmp3p5.d(24): Error: no property `sort` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwqcmp3p5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] > b[0]\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v + nums2[0], i, 0, v));\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[] {t[3], nums2[t[2]]};\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums1[t[1]]));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpm_8x1834.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpm_8x1834.d(13): Error: found `,` when expecting `.` following long\n/tmp/tmpm_8x1834.d(13): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpm_8x1834.d(13): Error: found `,` when expecting `.` following long\n/tmp/tmpm_8x1834.d(13): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpm_8x1834.d(15): Error: declaration expected, not `foreach`\n/tmp/tmpm_8x1834.d(15): Error: no identifier for declarator `nums1`\n/tmp/tmpm_8x1834.d(15): Error: declaration expected, not `)`\n/tmp/tmpm_8x1834.d(20): Error: declaration expected, not `foreach`\n/tmp/tmpm_8x1834.d(20): Error: declaration expected, not `0`\n/tmp/tmpm_8x1834.d(23): Error: no identifier for declarator `res[i]`\n/tmp/tmpm_8x1834.d(23): Error: declaration expected, not `=`\n/tmp/tmpm_8x1834.d(24): Error: declaration expected, not `if`\n/tmp/tmpm_8x1834.d(26): Error: unexpected `(` in declarator\n/tmp/tmpm_8x1834.d(26): Error: un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](0);\n\tif(n1 == 0 || n2 == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\twhile(k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get();\n\t\tresult ~= [t[0], t[1]];\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif(t[2] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpxdmz2mm6.d(15): Error: template instance `PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdmz2mm6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto p = minHeap.pop;\n\t\tresult[i] = [nums1[p[1]], nums2[p[2]]];\n\t\t\n\t\tif (p[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(nums1[p[1]] + nums2[p[2] + 1], p[1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp11bnv34v.d(16): Error: template instance `MinHeap!(typeof(Tuple!(long, long, long)))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp11bnv34v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[i * n2 + j] = pair;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpcska8kth.d(31): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcska8kth.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpugfssbjj.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\n/tmp/tmpugfssbjj.d(18): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpugfssbjj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tlong[][] heap = new long[][](k);\n\tlong heap_size = 0;\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(heap_size < k)\n\t\t\t{\n\t\t\t\theap[heap_size] = [nums1[i], nums2[j]];\n\t\t\t\theap_size++;\n\t\t\t\tif(heap_size == k)\n\t\t\t\t{\n\t\t\t\t\theap_size = build_heap(heap, heap_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap[0][0] + heap[0][1])\n\t\t\t\t{\n\t\t\t\t\theap[0] = [nums1[i], nums2[j]];\n\t\t\t\t\theap_size = heapify(heap, heap_size, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tres[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_size = heapify(heap, heap_size, 0);\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpbce68c69.d(24): Error: undefined identifier `build_heap`\n/tmp/tmpbce68c69.d(32): Error: undefined identifier `heapify`\n/tmp/tmpbce68c69.d(43): Error: undefined identifier `heapify`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbce68c69.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, m, n, l, r, mid;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\tif (k > m * n)\n\t\tk = m * n;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[0];\n\t\tresult[i][1] = nums2[0];\n\t}\n\t\n\tfor (i = 1; i < m; i++)\n\t{\n\t\tfor (j = 1; j < n; j++)\n\t\t{\n\t\t\ttemp = new long[2];\n\t\t\ttemp[0] = nums1[i];\n\t\t\ttemp[1] = nums2[j];\n\t\t\t\n\t\t\tl = 0;\n\t\t\tr = k - 1;\n\t\t\t\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tmid = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tif (temp[0] + temp[1] < result[mid][0] + result[mid][1])\n\t\t\t\t\tr = mid - 1;\n\t\t\t\telse\n\t\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t\t\n\t\t\tfor (l = k - 1; l > r; l--)\n\t\t\t\tresult[l] = result[l - 1];\n\t\t\t\n\t\t\tresult[r + 1] = temp;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmptsv8vxu1.d(56): Range violation\n----------------\n??:? _d_arrayboundsp [0x429922]\n??:? long[][] tmptsv8vxu1.k_smallest_pairs(long[], long[], long) [0x428404]\n??:? void tmptsv8vxu1.__unittest_L62_C1() [0x4284ed]\n??:? void tmptsv8vxu1.__modtest() [0x428a60]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e423]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42954e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b0c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b158]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b055]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429525]\n??:? runModuleUnitTests [0x42e1f9]\n??:? void rt.dmain2._d_run_main(int, char**, ext",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(long[2])();\n\t\n\tauto result = new long[][](k);\n\t\n\tauto i = 0;\n\twhile (i < k && i < n1 * n2)\n\t{\n\t\tauto pair = [nums1[i / n2], nums2[i % n2]];\n\t\tmin_heap.insert(pair);\n\t\t++i;\n\t}\n\t\n\ti = 0;\n\twhile (i < k && !min_heap.empty)\n\t{\n\t\tresult[i] = min_heap.pop;\n\t\t++i;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpidahqou4.d(16): Error: template instance `MinHeap!(long[2])` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpidahqou4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmphytfwgvn.d(14): Error: variable `tmphytfwgvn.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b)\n{\nreturn a[0] + a[1] < b[0] + b[1];\n}\n`, and variables cannot be of type `void`\n/tmp/tmphytfwgvn.d(14): Error: template lambda has no value\n/tmp/tmphytfwgvn.d(15): Error: template instance `PriorityQueue!(typeof(comp))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphytfwgvn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto minHeap = MinHeap!(tuple!(long, long, long))();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto p = minHeap.pop();\n\t\tresult[i] = [p[0], p[1]];\n\t\t\n\t\tif (p[2] == n2 - 1) continue;\n\t\t\n\t\tminHeap.insert(tuple(p[0], nums2[p[2] + 1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmph4_na6xq.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\n/tmp/tmph4_na6xq.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph4_na6xq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto nums1_index = new long[nums1.length];\n\tauto nums2_index = new long[nums2.length];\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tlong min = long.max;\n\t\tlong min_index = -1;\n\t\t\n\t\tfor (long j = 0; j < nums1.length; j++) \n\t\t{\n\t\t\tif (nums1_index[j] >= nums2.length)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (nums1[j] + nums2[nums1_index[j]] < min) \n\t\t\t{\n\t\t\t\tmin = nums1[j] + nums2[nums1_index[j]];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[nums1_index[min_index]];\n\t\t\n\t\tnums1_index[min_index]++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpx1ttk40u.d(11): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpx1ttk40u.d(18): Error: declaration expected, not `for`\n/tmp/tmpx1ttk40u.d(18): Error: no identifier for declarator `i`\n/tmp/tmpx1ttk40u.d(18): Error: declaration expected, not `<`\n/tmp/tmpx1ttk40u.d(18): Error: no identifier for declarator `i`\n/tmp/tmpx1ttk40u.d(18): Error: declaration expected, not `++`\n/tmp/tmpx1ttk40u.d(23): Error: declaration expected, not `for`\n/tmp/tmpx1ttk40u.d(23): Error: no identifier for declarator `j`\n/tmp/tmpx1ttk40u.d(23): Error: declaration expected, not `<`\n/tmp/tmpx1ttk40u.d(23): Error: no identifier for declarator `j`\n/tmp/tmpx1ttk40u.d(23): Error: declaration expected, not `++`\n/tmp/tmpx1ttk40u.d(28): Error: declaration expected, not `if`\n/tmp/tmpx1ttk40u.d(31): Error: no identifier for declarator `min_index`\n/tmp/tmpx1ttk40u.d(31): Error: declaration expected, not `=`\n/tmp/tmpx1ttk40u.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx1ttk",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpexvazixx.d(15): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpexvazixx.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpexvazixx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpactrd1x1.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\n/tmp/tmpactrd1x1.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpactrd1x1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v, nums2[0], i, 0));\n\t\n\tlong[][] result;\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp2regikr6.d(16): Error: template instance `PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2regikr6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[3] + 1));\n\t\t\n\t\tif (t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpwkqv0arz.d(16): Error: template instance `Heap!(Tuple!(long, long, long, long))` template `Heap` is not defined, did you mean wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwkqv0arz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\t\t\tpq.get();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp0qsuwoou.d(16): Error: variable `tmp0qsuwoou.k_smallest_pairs.comp` type `void` is inferred from initializer `(a, b) => a[0] + a[1] - (b[0] + b[1])`, and variables cannot be of type `void`\n/tmp/tmp0qsuwoou.d(16): Error: template lambda has no value\n/tmp/tmp0qsuwoou.d(18): Error: template instance `PriorityQueue!(typeof(comp))` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qsuwoou.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\tif (pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpsv8d2he6.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1])` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsv8d2he6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1) continue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpbv_po4li.d(13): Error: found `,` when expecting `.` following long\n/tmp/tmpbv_po4li.d(13): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpbv_po4li.d(13): Error: found `,` when expecting `.` following long\n/tmp/tmpbv_po4li.d(13): Error: found `long` when expecting identifier following `long`.\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbv_po4li.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] res;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tres = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpkupbd0qf.d(15): Error: template instance `PriorityQueue!((a) => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])` template `PriorityQueue` is not defined\n/tmp/tmpkupbd0qf.d(17): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkupbd0qf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp_arr;\n\tlong i, j, m, n, l, r;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\ttemp = new long[m][n];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\ttemp_arr = new long[m * n];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp_arr[i * n + j] = temp[i][j];\n\t\t}\n\t}\n\t\n\ttemp_arr = temp_arr.sort();\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t{\n\t\t\t\tif (temp[j][l] == temp_arr[i])\n\t\t\t\t{\n\t\t\t\t\tresult[i][0] = nums1[j];\n\t\t\t\t\tresult[i][1] = nums2[l];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpxjulf6sd.d(21): Error: variable `m` cannot be read at compile time\n/tmp/tmpxjulf6sd.d(41): Error: no property `sort` for type `long[]`\n/tmp/tmpxjulf6sd.d(43): Error: variable `k` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxjulf6sd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < minHeap.top.tupleof[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[minHeap.top.tupleof[1]];\n\t\tresult[i][1] = nums2[minHeap.top.tupleof[2]];\n\t\tminHeap.pop;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmpl2eia47t.d(13): Error: template instance `MinHeap!(Tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl2eia47t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tmin_heap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] < n2 - 1)\n\t\t{\n\t\t\tmin_heap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpy0i3a2jn.d(16): Error: template instance `MinHeap!(Tuple!(long, long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy0i3a2jn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n    auto len1 = nums1.length;\n    auto len2 = nums2.length;\n    auto len = min(len1, len2);\n    auto res = new long[][](len);\n    auto i = 0;\n    auto j = 0;\n    auto count = 0;\n    while(i < len1 && j < len2 && count < k)\n    {\n        res[count][0] = nums1[i];\n        res[count][1] = nums2[j];\n        count++;\n        if(i == len1 - 1)\n            j++;\n        else if(j == len2 - 1)\n            i++;\n        else\n        {\n            if(nums1[i+1] < nums2[j+1])\n                i++;\n            else\n                j++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpn_mj7yt0.d(12): Error: undefined identifier `min`, did you mean function `main`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_mj7yt0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\tforeach (i, n; nums1)\n\t\tminHeap.push(tuple(n, nums2[0], 0));\n\t\n\tauto res = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tres[i] = [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpmwl6_7q_.d(15): Error: template instance `MinHeap!(tuple!(long, long, long))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmwl6_7q_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpknfotfjg.d(22): Error: template instance `sort!((a, b) => a[0] + a[1] < b[0] + b[1])` template `sort` is not defined, did you mean sqrt?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknfotfjg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\tif (k == 0) return [];\n\t\n\t// min heap\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\t// add first row\n\tforeach (i, e; nums2)\n\t{\n\t\tpq.put([nums1[0], e]);\n\t}\n\t\n\t// add other rows\n\tforeach (i, e; nums1[1 .. $])\n\t{\n\t\tforeach (j, f; nums2)\n\t\t{\n\t\t\tauto pair = [e, f];\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put(pair);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pq.peek[0] + pq.peek[1] > pair[0] + pair[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmpl0ewrvgq.d(16): Error: template instance `PriorityQueue!(long[], \"a[0] + a[1]\")` template `PriorityQueue` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl0ewrvgq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto heap = new MinHeap!(typeof(tuple!(long, long, long)));\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\theap.insert(tuple(n1 + n2, i, j));\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[1], t[2]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122951,
      "stdout": "",
      "stderr": "/tmp/tmphej7x5s0.d(10): Error: template instance `MinHeap!(typeof(tuple!(long, long, long)))` template `MinHeap` is not defined\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphej7x5s0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n{\n\tauto minHeap = new MinHeap!(typeof(tuple(long, long, long)));\n\tauto result = new long[][](k);\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push(tuple(num1, num2, i + j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(minHeap.top[2] > i + j)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(tuple(num1, num2, i + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, pair; minHeap)\n\t{\n\t\tresult[i] = [pair[0], pair[1]];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "/tmp/tmp1m8to_l_.d(10): Error: found `,` when expecting `.` following long\n/tmp/tmp1m8to_l_.d(10): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp1m8to_l_.d(10): Error: found `)` when expecting `.` following long\n/tmp/tmp1m8to_l_.d(10): Error: found `)` when expecting identifier following `long`.\n/tmp/tmp1m8to_l_.d(10): Error: found `;` when expecting `)`\n/tmp/tmp1m8to_l_.d(11): Error: found `auto` when expecting `)` following template argument list\n/tmp/tmp1m8to_l_.d(11): Error: semicolon expected following auto declaration, not `result`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1m8to_l_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}