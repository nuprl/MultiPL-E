{
  "name": "mbpp_239_get_total_number_of_sequences",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\t\n*/\nlong get_total_number_of_sequences(long m, long n) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = get_total_number_of_sequences;\n\n    assert(candidate(10L, 4L) == 4L);\n    assert(candidate(5L, 2L) == 6L);\n    assert(candidate(16L, 3L) == 84L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong result = 0;\n\tlong[long] dp = new long[long[](n + 1)];\n\tdp[0] = 1;\n\tfor (long i = 1; i <= n; i++) \n\t{\n\t\tfor (long j = 2 * i; j <= m; j++) \n\t\t{\n\t\t\tdp[i] += dp[i - 1];\n\t\t}\n\t}\n\treturn dp[n];\n}",
    "{\n\tlong result = 0;\n\tlong[long] cache = new long[long][];\n\tfor (long i = 0; i <= m; i++)\n\t{\n\t\tcache[i] = new long[n+1];\n\t\tfor (long j = 0; j <= n; j++)\n\t\t{\n\t\t\tcache[i][j] = -1;\n\t\t}\n\t}\n\t\n\tresult = get_total_number_of_sequences_helper(m, n, cache);\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tif (n == 1)\n\t\tresult = m;\n\telse\n\t{\n\t\tfor (long i = 2; i <= m; i++)\n\t\t{\n\t\t\tresult += get_total_number_of_sequences(i, n - 1);\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong m1 = 0;\n\tlong n1 = 0;\n\tlong o = 0;\n\tlong p = 0;\n\tlong q = 0;\n\tlong r = 0;\n\tlong s = 0;\n\tlong t = 0;\n\tlong u = 0;\n\tlong v = 0;\n\tlong w = 0;\n\tlong x = 0;\n\tlong y = 0;\n\tlong z = 0;\n\tlong aa = 0;\n\tlong ab = 0;\n\tlong ac = 0;\n\tlong ad = 0;\n\tlong ae = 0;\n\tlong af = 0;\n\tlong ag = 0;\n\tlong ah = 0;\n\tlong ai = 0;\n\tlong aj = 0;\n\tlong ak = 0;\n\tlong al = 0;\n\tlong am = 0;\n\tlong an = 0;\n\tlong ao = 0;\n\tlong ap = 0;\n\tlong aq = 0;\n\tlong ar = 0;\n\tlong as = 0;\n\tlong at = 0;\n\tlong au = 0;\n\tlong av = 0;\n\tlong aw = 0;\n\tlong ax = 0;\n\tlong ay = 0;\n\tlong az = 0;\n\tlong ba = 0;\n\tlong bb = 0;\n\tlong bc = 0;\n\tlong bd = 0;\n\tlong be = 0;\n\tlong bf = 0;\n\tlong bg = 0;\n\tlong bh = 0;\n\tlong bi = 0;\n\tlong bj = 0;\n\tlong bk = 0;\n\tlong bl = 0;\n\tlong bm = 0;\n\tlong bn = 0;\n\tlong bo = 0;\n\tlong bp = 0;\n\tlong bq = 0;\n\tlong br = 0;\n\tlong bs = 0;\n\tlong bt = 0;\n\tlong bu = 0;\n\tlong bv = 0;\n\tlong bw = 0;\n\tlong bx = 0;\n\tlong",
    "{\n\tlong result = 0;\n\tlong start = 0;\n\tlong end = m;\n\tlong mid = (start + end) / 2;\n\tlong prev = 0;\n\tlong count = 0;\n\twhile (start <= end)\n\t{\n\t\tmid = (start + end) / 2;\n\t\tif (mid >= 2 * prev)\n\t\t{\n\t\t\tprev = mid;\n\t\t\tcount++;\n\t\t\tif (count == n)\n\t\t\t{\n\t\t\t\tresult++;\n\t\t\t\tcount--;\n\t\t\t\tprev = prev / 2;\n\t\t\t}\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tend = mid - 1;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tif (n == 0)\n\t{\n\t\tresult = 1;\n\t}\n\telse\n\t{\n\t\tfor (long i = 2; i <= m; i++)\n\t\t{\n\t\t\tresult += get_total_number_of_sequences(i, n - 1);\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\tlong[][] arr = new long[n][m];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tarr[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tarr[i][j] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (k = 0; k < m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (k >= 2 * j)\n\t\t\t\t\t{\n\t\t\t\t\t\tarr[i][j] += arr[i - 1][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tresult += arr[n - 1][i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[long] dp = new long[m + 1];\n\tdp[0] = 1;\n\tforeach(i; 1 .. m + 1)\n\t{\n\t\tdp[i] = 0;\n\t\tforeach(j; 2 * i .. i + 1)\n\t\t{\n\t\t\tdp[i] += dp[j - i];\n\t\t}\n\t}\n\treturn dp[n];\n}",
    "{\n\tlong[long] dp = new long[m + 1];\n\tdp[0] = 1;\n\t\n\tforeach(i; 1 .. n)\n\t{\n\t\tforeach(j; 2 .. m + 1)\n\t\t{\n\t\t\tdp[j] += dp[j - 2];\n\t\t}\n\t}\n\t\n\treturn dp[m];\n}",
    "{\n\tlong result = 0;\n\tlong[long] dp = new long[long[](n + 1)];\n\t\n\tfor (long i = 0; i <= n; i++) \n\t{\n\t\tdp[i] = 0;\n\t}\n\t\n\tdp[0] = 1;\n\t\n\tfor (long i = 1; i <= n; i++) \n\t{\n\t\tfor (long j = 2 * i; j <= m; j++) \n\t\t{\n\t\t\tdp[i] += dp[i - 1];\n\t\t}\n\t}\n\t\n\tresult = dp[n];\n\t\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tif (n == 0)\n\t\treturn 1;\n\telse if (n == 1)\n\t\treturn m;\n\telse\n\t{\n\t\tforeach (i; 0 .. m)\n\t\t{\n\t\t\tresult += get_total_number_of_sequences(i * 2, n - 1);\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tif (n == 0)\n\t\treturn 1;\n\tif (m == 0)\n\t\treturn 0;\n\tfor (long i = 2 * m; i <= m; i++)\n\t\tresult += get_total_number_of_sequences(i, n - 1);\n\treturn result;\n}",
    "{\n\tlong[long] dp = new long[m + 1];\n\tdp[0] = 1;\n\tfor (long i = 1; i <= m; i++) \n\t{\n\t\tfor (long j = i * 2; j <= m; j++) \n\t\t{\n\t\t\tdp[j] += dp[j - i];\n\t\t}\n\t}\n\treturn dp[m];\n}",
    "{\n\tlong result = 0;\n\tlong[long] cache;\n\t\n\tauto get_total_number_of_sequences_helper = (long m, long n) =>\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\t\n\t\tif (n == 1)\n\t\t\treturn m;\n\t\t\n\t\tif (cache.count(n))\n\t\t\treturn cache[n];\n\t\t\n\t\tfor (long i = 2 * n; i <= m; ++i)\n\t\t\tresult += get_total_number_of_sequences_helper(i, n - 1);\n\t\t\n\t\tcache[n] = result;\n\t\treturn result;\n\t};\n\t\n\treturn get_total_number_of_sequences_helper(m, n);\n}",
    "{\n\tlong[long] dp = new long[m + 1];\n\tdp[0] = 1;\n\tfor (long i = 1; i <= m; i++)\n\t{\n\t\tfor (long j = i * 2; j <= m; j++)\n\t\t{\n\t\t\tdp[j] += dp[j - i];\n\t\t}\n\t}\n\treturn dp[m];\n}",
    "{\n\tlong result = 0;\n\tlong[long] cache;\n\t\n\tforeach(i; 0 .. n + 1)\n\t\tcache[i] = 0;\n\t\n\tcache[0] = 1;\n\t\n\tforeach(i; 1 .. n + 1)\n\t{\n\t\tforeach(j; 2 .. m + 1)\n\t\t{\n\t\t\tif(j >= 2 * i)\n\t\t\t\tcache[i] += cache[i - 1];\n\t\t}\n\t}\n\t\n\treturn cache[n];\n}",
    "{\n\tlong[long] dp = new long[m + 1];\n\t\n\tdp[0] = 1;\n\t\n\tforeach(i; 1 .. m + 1)\n\t{\n\t\tforeach(j; 2 * i .. i + 1)\n\t\t{\n\t\t\tdp[i] += dp[j - i];\n\t\t}\n\t}\n\t\n\treturn dp[n];\n}",
    "{\n\tlong result = 0;\n\tif (n == 0)\n\t\treturn 1;\n\tfor (long i = 2; i <= m; i++)\n\t{\n\t\tresult += get_total_number_of_sequences(m, n - 1);\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tif (n == 0)\n\t{\n\t\tresult = 1;\n\t}\n\telse\n\t{\n\t\tfor (long i = 2; i <= m; i++)\n\t\t{\n\t\t\tresult += get_total_number_of_sequences(i, n - 1);\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong result = 0;\n\tlong max_possible_value = 2 * m;\n\tlong[long] dp = new long[max_possible_value + 1];\n\t\n\tdp[0] = 1;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 2 .. m + 1)\n\t\t{\n\t\t\tif(j <= max_possible_value)\n\t\t\t{\n\t\t\t\tdp[j] += dp[j - 2];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = dp[m];\n\t\n\treturn result;\n}"
  ]
}