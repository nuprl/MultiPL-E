{
  "name": "mbpp_238_number_of_substrings",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\n*/\nlong number_of_substrings(string str) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = number_of_substrings;\n\n    assert(candidate(\"abc\") == 6L);\n    assert(candidate(\"abcd\") == 10L);\n    assert(candidate(\"abcde\") == 15L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tlong count = 0; \n\tfor (long i = 0; i < str.length(); i++) \n\t\tfor (long j = i + 1; j <= str.length(); j++) \n\t\t\tif (str.substr(i, j).length() > 0) \n\t\t\t\tcount++; \n\treturn count; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif(str.substr(i, j - i) != \"\")\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n  \n        // Pick ending points for substrings \n        // starting with str[i] \n        for (long j = i + 1; j <= n; j++) { \n  \n            // If current substring has unique \n            // character till now, then \n            // increment count \n            if (uniqueSubstr(str, i, j)) \n                cnt[j - i]++; \n        } \n    } \n  \n    // Summation of all possible lengths \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += cnt[i] * i; \n  \n    return sum; \n} \n  \n// This function returns true if the \n// characters between str[start] to \n// str[end] have all unique characters. ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tint n = str.length(); \n\treturn (n * (n + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    long count = 0; \n    for (long i = 0; i < n; i++) \n        for (long len = 1; len <= n - i; len++) \n            count += 1; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); ++i) \n\t{\n\t\tfor (long j = i + 1; j <= str.length(); ++j) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t\tforeach(j; i .. str.length)\n\t\t\tcount++;\n\treturn count;\n}",
    "{\n    long count = 0;\n    for (long i = 0; i < str.length(); i++) {\n        for (long j = i + 1; j <= str.length(); j++) {\n            if (str.substr(i, j - i) != \"\") {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    long cnt = 0; // Initialize result \n    for (long i = 0; i < n; i++)  \n        for (long len = 1; len <= n - i; len++) \n            cnt += 1; \n  \n    return cnt; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  ]
}