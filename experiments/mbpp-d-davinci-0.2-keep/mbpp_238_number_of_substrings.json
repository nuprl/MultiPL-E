{
  "name": "mbpp_238_number_of_substrings",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a python function to count the number of non-empty substrings of a given string.\n\t\n*/\nlong number_of_substrings(string str) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = number_of_substrings;\n\n    assert(candidate(\"abc\") == 6L);\n    assert(candidate(\"abcd\") == 10L);\n    assert(candidate(\"abcde\") == 15L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tlong count = 0; \n\tfor (long i = 0; i < str.length(); i++) \n\t\tfor (long j = i + 1; j <= str.length(); j++) \n\t\t\tif (str.substr(i, j).length() > 0) \n\t\t\t\tcount++; \n\treturn count; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif(str.substr(i, j - i) != \"\")\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n  \n        // Pick ending points for substrings \n        // starting with str[i] \n        for (long j = i + 1; j <= n; j++) { \n  \n            // If current substring has unique \n            // character till now, then \n            // increment count \n            if (uniqueSubstr(str, i, j)) \n                cnt[j - i]++; \n        } \n    } \n  \n    // Summation of all possible lengths \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += cnt[i] * i; \n  \n    return sum; \n} \n  \n// This function returns true if the \n// characters between str[start] to \n// str[end] have all unique characters. ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tint n = str.length(); \n\treturn (n * (n + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    long count = 0; \n    for (long i = 0; i < n; i++) \n        for (long len = 1; len <= n - i; len++) \n            count += 1; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); ++i) \n\t{\n\t\tfor (long j = i + 1; j <= str.length(); ++j) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t\tforeach(j; i .. str.length)\n\t\t\tcount++;\n\treturn count;\n}",
    "{\n    long count = 0;\n    for (long i = 0; i < str.length(); i++) {\n        for (long j = i + 1; j <= str.length(); j++) {\n            if (str.substr(i, j - i) != \"\") {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    long cnt = 0; // Initialize result \n    for (long i = 0; i < n; i++)  \n        for (long len = 1; len <= n - i; len++) \n            cnt += 1; \n  \n    return cnt; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n        // Number of unique characters in current \n        // substring. \n        long sub_cnt = 0; \n  \n        // Pick ending points for substrings \n        // starting with i \n        for (long j = i; j < n; j++) { \n            // If current character is not \n            // present, increment sub_cnt \n            // unique character count \n            if (str[j] == '1') \n                sub_cnt++; \n  \n            // Add current substring (of length \n            // j-i+1) in count of different \n            // substrings of length j-i+1 \n            cnt[sub_cnt]++; \n        } \n    } \n  \n    // Summation of all counts \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += i * cnt[i]; \n  \n    return sum; \n} ",
    "{ \n    long result = 0; \n    for (int i = 0; i < str.length(); i++) \n        for (int j = i + 1; j <= str.length(); j++) \n            if (str.substr(i, j - i) != \"\") \n                result++; \n    return result; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    int n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++) \n\t\t{\n\t\t\tif (str[i..j].length > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t\tcount++;\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{ \n\tlong count = 0; \n\tfor (long i = 0; i < str.length(); i++) \n\t\tfor (long j = i + 1; j <= str.length(); j++) \n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t\tcount++; \n\treturn count; \n} ",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong len = str.length;\n\treturn len * (len + 1) / 2;\n}",
    "{ \n    int n = str.length(); \n  \n    // substring length \n    int len = 0; \n  \n    // result \n    long res = 0; \n  \n    // iterate over all lengths \n    // from 1 to n \n    for (len = 1; len <= n; len++) { \n  \n        // iterate over all possible \n        // starting indices \n        for (int i = 0; i <= n - len; i++) { \n  \n            // generate substring of length \n            // 'len' and calculate its \n            // hash value \n            string sub_str = str.substr(i, len); \n            res++; \n        } \n    } \n    return res; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong n = str.length;\n\treturn n * (n + 1) / 2;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong length = str.length;\n\treturn (length * (length + 1)) / 2;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = 1; j <= str.length - i; j++) \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    int n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length; i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str[i..j].length() > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong n = str.length;\n\treturn n * (n + 1) / 2;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // Pick a starting point \n    long count = 0; \n    for (long i = 0; i < n; i++) \n        for (long j = i+1; j <= n; j++) \n            if (str[i..j].length > 0) \n                count++; \n  \n    return count; \n} ",
    "{\n    long result = 0;\n    for (int i = 0; i < str.length(); i++)\n    {\n        for (int j = 1; j <= str.length() - i; j++)\n        {\n            result++;\n        }\n    }\n    return result;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    int n = str.length(); \n  \n    // substring length \n    int len = 1; \n  \n    // result \n    int count = 0; \n  \n    // run till len becomes n \n    while (len <= n) { \n  \n        // run for every possible starting index \n        for (int i = 0; i <= n - len; i++) { \n  \n            // check if current substring is non-empty \n            if (str[i..i + len - 1] != \"\") \n                count++; \n        } \n  \n        // increment substring length \n        len++; \n    } \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str[i..j].length() > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++) \n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    long cnt = 0; // Initialize result \n    for (long i = 0; i < n; i++) \n        for (long len = 1; len <= n - i; len++) \n            cnt += 1; \n  \n    return cnt; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++) \n\t\t{\n\t\t\tif (str[i..j].length > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = 1; j <= str.length() - i; j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++) \n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong len = str.length;\n\treturn len * (len + 1) / 2;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n+1]; \n  \n    // Pick starting point \n    for (long i = 1; i <= n; i++) \n    { \n        // Pick ending point \n        for (long j = i; j <= n; j++) \n        { \n            // If current substring has unique \n            // character till now, increment \n            // count and set ending point \n            if (isUnique(str, i, j)) \n                cnt[j - i + 1]++; \n        } \n    } \n  \n    // Return total count of substrings \n    long ans = 0; \n    for (long i = 1; i <= n; i++) \n        ans += cnt[i]; \n    return ans; \n} \n  \n// This function returns true if all \n// characters in str[low..high] are \n// distinct, else returns false ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong len = str.length;\n\treturn (len * (len + 1)) / 2;\n}",
    "{ \n    long n = str.length(); \n  \n    // substring length \n    long len = 1; \n    long count = 0; \n  \n    // run loop from i=0 to n-1 \n    while (len <= n) { \n  \n        // run loop from i=0 to n-len \n        for (long i = 0; i <= n - len; i++) { \n            long j = i + len - 1; \n  \n            // check if substring str[i..j] is palindrome \n            bool isPalindrome = true; \n            for (long k = 0; k < len / 2; k++) { \n                if (str[i + k] != str[j - k]) { \n                    isPalindrome = false; \n                    break; \n                } \n            } \n  \n            // if substring str[i..j] is palindrome, then \n            // increase count \n            if (isPalindrome) \n                count++; \n        } \n  \n        // increase substring length \n        len++; \n    } \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n    long count = 0;\n    long n = str.length;\n    for (long i = 0; i < n; i++)\n        for (long j = i + 1; j <= n; j++)\n            if (str[i..j].length > 0)\n                count++;\n    return count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str[i..j].length() > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    int n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length; i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; \n    for (long i = 0; i < str.length(); i++) \n        for (long j = i + 1; j <= str.length(); j++) \n            if (str.substr(i, j - i) != \"\") \n                count++; \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++) \n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\") \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tint n = str.length(); \n\treturn (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = 1; j <= str.length - i; j++) \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    return (str.length() * (str.length() + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (size_t i = 0; i < str.length(); i++) \n\t{\n\t\tfor (size_t j = i + 1; j <= str.length(); j++) \n\t\t{\n\t\t\tif (str.substr(i, j - i).length() > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i+1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j] != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length) {\n\t\tforeach(j; i .. str.length) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (size_t i = 0; i < str.length(); i++)\n\t{\n\t\tfor (size_t j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++)\n\t{\n\t\tfor (long j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++) {\n\t\tfor (long j = i + 1; j <= str.length(); j++) {\n\t\t\tif (str.substr(i, j - i) != \"\") {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    return (str.length() * (str.length() + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    return (str.length() * (str.length() + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n        // Number of unique characters in current \n        // substring. \n        long sub_cnt = 0; \n  \n        // Pick ending points for substrings \n        // starting with i \n        for (long j = i; j < n; j++) { \n            if (str[j] == '1') \n                sub_cnt++; \n  \n            // Increase count of substrings with \n            // sub_cnt unique characters \n            cnt[sub_cnt]++; \n        } \n    } \n  \n    // Initialize result \n    long res = 0; \n  \n    // Traverse up \n    for (long i = n; i > 0; i--) \n  \n        // If number of substrings with i unique \n        // characters is more than 1, then \n        // update result \n        if (cnt[i] > 1) \n            res += (i * (i - 1) / 2) * cnt[i]; \n        else\n            res += (i * (i + 1) / 2) * cnt[i]; \n  \n    return res; \n} ",
    "{\n\tlong n = str.length;\n\treturn n * (n + 1) / 2;\n}",
    "{ \n    int n = str.length(); \n  \n    // substring length \n    int len = 0; \n  \n    // result \n    int result = 0; \n  \n    // iterate over all lengths \n    for (int i = 0; i < n; i++) { \n  \n        // iterate over all substrings of length len \n        for (int j = 0; j <= n - i; j++) { \n  \n            // check if the substring is non-empty \n            if (j > 0) \n                result++; \n        } \n    } \n  \n    return result; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // substring are of length 1 \n    long result = n; \n  \n    // check for all lengths from 2 to n \n    for (long i = 2; i <= n; i++) \n    { \n        for (long j = 0; j < n - i + 1; j++) \n        { \n            long k = i + j - 1; \n            if (str[j] == str[k]) \n                result++; \n        } \n    } \n  \n    return result; \n} ",
    "{\n\tlong count = 0;\n\tfor (long i = 0; i < str.length(); i++) {\n\t\tfor (long j = i + 1; j <= str.length(); j++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong len = str.length;\n\treturn (len * (len + 1)) / 2;\n}",
    "{\n\tlong count = 0;\n\tint n = str.length();\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t\tcount++;\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i; j < str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n+1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n        // To store count of substrings starting \n        // with str[i] \n        long[] curr_cnt = new long[n+1]; \n  \n        // Pick ending points for substrings \n        // starting with str[i] \n        for (long j = i; j < n; j++) { \n            // Pick starting point of substring, \n            // initialize count of distinct \n            // characters \n            long curr_end = j; \n            long curr_len = curr_end - i + 1; \n            long curr_distinct_char = 0; \n  \n            // To store presence/absence of 26 \n            // characters using a single integer \n            long mask = 0; \n  \n            // This operation is O(1) \n            while (curr_end >= i) { \n                // Check if character str[curr_end] \n                // is already present in current \n                // substring or not \n                if ((mask & (1 << (str[curr_end] - 'a'))) == 0) { \n                    curr_distinct_char++; \n  \n                    // Mark presence of current character \n                    mask = mask | (1 << (str[curr_end] - 'a')); \n                } \n                curr_end--; \n            } \n  \n            // If current substring has all unique \n            // characters \n            if (curr_distinct_char == curr_len) { \n                // Increase count of all substrings \n                // with same number of distinct \n                // characters. \n                cnt[curr_distinct_char]++; \n  \n                // Increase count of current substring \n                curr_c",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++) \n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++) \n\t\t{\n\t\t\tif (str[i..j].length > 0) \n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (size_t i = 0; i < str.length(); i++)\n\t{\n\t\tfor (size_t j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j).length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n    long count = 0;\n    for (long i = 0; i < str.length(); i++)\n        for (long j = i + 1; j <= str.length(); j++)\n            if (str.substr(i, j - i).length() > 0)\n                count++;\n    return count;\n}",
    "{ \n    long n = str.length(); \n  \n    // substring are of form \"i-j\" where i \n    // varies from 0 to n-1 & j varies from i+1 to n. \n    // So there are n*(n+1)/2 substrings in total \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n    long n = str.length();\n    return n * (n + 1) / 2;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\t\tfor(int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str.substr(i, j - i) != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long count = 0; \n    for (long i = 0; i < str.length(); i++) \n        for (long j = i + 1; j <= str.length(); j++) \n            if (str.substr(i, j - i) != \"\") \n                count++; \n  \n    return count; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length) \n\t{\n\t\tforeach(j; i .. str.length) \n\t\t{\n\t\t\tif(str[i .. j].length > 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n\tlong n = str.length(); \n\treturn n * (n + 1) / 2; \n} ",
    "{\n\tlong n = str.length;\n\treturn n * (n + 1) / 2;\n}",
    "{ \n    int n = str.length(); \n  \n    // substring length \n    int len = 1; \n    int cnt = 0; // Initialize result \n  \n    // Starting point of substring \n    int i = 0; \n  \n    // One by one move ending point to right \n    // and count different substrings \n    // starting from i \n    while (i < n) { \n        // Starting point of substring \n        int j = i; \n  \n        // Ending point of substring \n        int k = j + len - 1; \n  \n        // Count different substrings \n        // starting from i \n        while (k < n) { \n            // Increment count \n            cnt++; \n  \n            // Move ending point \n            j++; \n            k = j + len - 1; \n        } \n  \n        // Move starting point \n        i++; \n    } \n  \n    return cnt; \n} ",
    "{ \n\tint n = str.length(); \n\treturn (n * (n + 1)) / 2; \n} ",
    "{\n\tlong len = str.length;\n\tlong result = 0;\n\tfor (long i = 0; i < len; i++) \n\t{\n\t\tfor (long j = i + 1; j <= len; j++) \n\t\t{\n\t\t\tif (str[i..j].length > 0) \n\t\t\t{\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point \n    for (long i = 1; i <= n; i++) { \n  \n        // Pick ending point \n        for (long j = i; j <= n; j++) { \n  \n            // If current substring has exactly \n            // i unique characters, then increment \n            // count of substrings with i unique \n            // characters \n            if (unique(str, i, j)) \n                cnt[i]++; \n        } \n    } \n  \n    // Return total count of substrings with \n    // exactly k unique characters \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += cnt[i]; \n    return sum; \n} \n  \n// This function returns true if str[start..end] \n// has exactly k unique characters, else false ",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length; i++)\n\t{\n\t\tfor (int j = i + 1; j <= str.length; j++)\n\t\t{\n\t\t\tif (str[i..j] != \"\")\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length) \n\t{\n\t\tforeach(j; i .. str.length) \n\t\t{\n\t\t\tif(str[i .. j].length != 0) \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n    long count = 0;\n    for (int i = 0; i < str.length(); i++)\n    {\n        for (int j = i + 1; j <= str.length(); j++)\n        {\n            count++;\n        }\n    }\n    return count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t{\n\t\tforeach(j; i .. str.length)\n\t\t{\n\t\t\tif(str[i .. j].length > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{\n\tlong count = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tfor (int j = i+1; j <= str.length(); j++)\n\t\t{\n\t\t\tif (str[i..j].length() > 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n        // Number of unique characters in current \n        // substring. \n        long no_of_chars = 0; \n  \n        // Pick ending point for current substring. \n        for (long j = i; j < n; j++) { \n            // If this is a new character for this \n            // substring, increment no_of_chars. \n            if (str[j] == '0') \n                no_of_chars++; \n  \n            // Add current substring to result \n            cnt[no_of_chars]++; \n        } \n    } \n  \n    // Initialize result \n    long result = 0; \n  \n    // Traverse through the array and add \n    // all those substrings to result which \n    // have exactly k unique characters \n    for (long i = 1; i <= n; i++) \n        result += (cnt[i] * (cnt[i] + 1) / 2); \n  \n    return result; \n} ",
    "{ \n\treturn (str.length() * (str.length() + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n+1]; \n  \n    // Pick starting point \n    for (long i = 1; i <= n; i++) \n    { \n        // Pick ending point \n        for (long j = i; j <= n; j++) \n        { \n            // If current string is not \n            // already processed \n            if (uniqueSubstring(str, i, j)) \n                cnt[uniqueChar(str, i, j)]++; \n        } \n    } \n  \n    // Return total count of substrings \n    long sum = 0; \n    for (long i = 1; i <= n; i++) \n        sum += cnt[i]; \n  \n    return sum; \n} \n  \n// This function returns true if str[start..end] \n// contains one and only one distinct character ",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return (n * (n + 1)) / 2; \n} ",
    "{\n\tlong count = 0;\n\tforeach(i; 0 .. str.length)\n\t\tforeach(j; i .. str.length)\n\t\t\tcount++;\n\treturn count;\n}",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n    return n * (n + 1) / 2; \n} ",
    "{ \n    long n = str.length(); \n  \n    // To store count of substrings with \n    // exactly i unique characters \n    long[] cnt = new long[n + 1]; \n  \n    // Pick starting point in outer loop \n    // and lengths of different strings for \n    // a given starting point \n    for (long i = 0; i < n; i++) { \n        // Number of unique characters in current \n        // substring. \n        long no_of_unique_char = 0; \n  \n        // Last index of all characters of current \n        // substring. Initialize as -1. \n        long[] last_index = new long[256]; \n        for (long j = 0; j < 256; j++) \n            last_index[j] = -1; \n  \n        // i'th character is part of current \n        // substring \n        last_index[str[i]] = i; \n        no_of_unique_char++; \n  \n        // Iterate through all remaining characters \n        // and update last_index[] and no_of_unique_char \n        // as described in algorithm \n        for (long j = i + 1; j < n; j++) { \n            // If this is not first appearance of j'th \n            // character, \n            if (last_index[str[j]] != -1) { \n                // This is different character than \n                // previous one \n                if (last_index[str[j]] < i) { \n                    no_of_unique_char++; \n                } \n  \n                // Update last appearance of \n                // current character \n                last_index[str[j]] = j; \n            } \n  \n            // Add current substring (of length j-i+1) \n            // in count array \n            cnt[no_of_unique_char]++; \n        } \n    } \n  \n    // Substrings with all unique characters \n    long ans = cnt[1]; \n  \n    // Add all those substrings which have same \n    // number of unique characters and different",
    "{ \n    long n = str.length(); \n  \n    // Pick a starting point \n    for (long i = 0; i < n; i++) \n    { \n        // Pick ending point \n        for (long j = i; j < n; j++) \n        { \n            //  Print characters from current \n            // starting point to current ending \n            // point.   \n            for (long k = i; k <= j; k++) \n                cout << str[k]; \n  \n            cout << endl; \n        } \n    } \n    return 0; \n} "
  ]
}