{
  "name": "mbpp_92_is_undulating",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to check whether the given number is undulating or not.\n\t\n*/\nbool is_undulating(long n) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = is_undulating;\n\n    assert(candidate(1212121L) == true);\n    assert(candidate(1991L) == false);\n    assert(candidate(121L) == true);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tauto digits = to!(string)(n);\n\t\n\tif (digits.length < 3)\n\t\treturn false;\n\t\n\tauto last = digits[0];\n\tauto second_last = digits[1];\n\t\n\tbool is_increasing = last < second_last;\n\t\n\tfor (size_t i = 2; i < digits.length; i++)\n\t{\n\t\tauto current = digits[i];\n\t\t\n\t\tif (is_increasing)\n\t\t{\n\t\t\tif (current > second_last)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (current < second_last)\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tlast = second_last;\n\t\tsecond_last = current;\n\t\tis_increasing = !is_increasing;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tint[] digits = to!(int[])(n.toString()).map!(a => a.to!int()).array();\n\t\n\tif (digits.length < 3)\n\t\treturn false;\n\t\n\tint i = 0;\n\twhile (i < digits.length - 2)\n\t{\n\t\tif (digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2])\n\t\t\treturn false;\n\t\t\n\t\tif (digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2])\n\t\t\ti += 2;\n\t\telse if (digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2])\n\t\t\ti += 2;\n\t\telse\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tauto is_even = true;\n\t\n\tforeach(i, d; digits)\n\t{\n\t\tif(is_even)\n\t\t{\n\t\t\tif(d < digits[i + 1])\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(d > digits[i + 1])\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tis_even = !is_even;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\t\n\tforeach(i; 0 .. digits.length - 2)\n\t{\n\t\tif(digits[i] == digits[i + 1])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tbool is_undulating = true;\n\tfor(int i = 0; i < digits.length - 2; i++)\n\t{\n\t\tif(digits[i] != digits[i + 2])\n\t\t{\n\t\t\tis_undulating = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn is_undulating;\n}",
    "{\n\tauto digits = n.to!string.split(\"\").map!(a => a.to!long).array;\n\t\n\tforeach(i, ref digit; digits)\n\t{\n\t\tif(i == 0)\n\t\t\tcontinue;\n\t\t\n\t\tif(i % 2 == 0)\n\t\t{\n\t\t\tif(digits[i] >= digits[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(digits[i] <= digits[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = n.to!string.map!(a => a.to!int).array;\n\t\n\tforeach(i; 0..digits.length - 2)\n\t{\n\t\tif(digits[i] == digits[i + 1])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto odd = true;\n\tfor (size_t i = 0; i < digits.length - 1; i++) \n\t{\n\t\tif (odd) \n\t\t{\n\t\t\tif (digits[i] >= digits[i + 1])\n\t\t\t\treturn false;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tif (digits[i] <= digits[i + 1])\n\t\t\t\treturn false;\n\t\t}\n\t\todd = !odd;\n\t}\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tif(digits.length < 3)\n\t\treturn false;\n\t\n\tfor(size_t i = 0; i < digits.length - 2; i++)\n\t{\n\t\tif(digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] || digits[i] == digits[i + 2])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tint[] digits = n.to!string.split(\"\").map!(a => a.to!int).array;\n\tint[] diffs = new int[digits.length - 1];\n\tforeach(i, d; digits)\n\t{\n\t\tif(i > 0)\n\t\t\tdiffs[i - 1] = d - digits[i - 1];\n\t}\n\t\n\tforeach(i, d; diffs)\n\t{\n\t\tif(i > 0)\n\t\t{\n\t\t\tif(d == 0 || d == diffs[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tauto even = true;\n\tauto prev = digits[0];\n\tforeach(i, digit; digits[1 .. $])\n\t{\n\t\tif(even)\n\t\t{\n\t\t\tif(digit >= prev)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(digit <= prev)\n\t\t\t\treturn false;\n\t\t}\n\t\tprev = digit;\n\t\teven = !even;\n\t}\n\treturn true;\n}",
    "{\n\tif (n < 100) \n\t\treturn false;\n\t\n\tauto digits = to!(string)(n);\n\t\n\tfor (size_t i = 0; i < digits.length - 2; i++) \n\t{\n\t\tif (digits[i] == digits[i + 2]) \n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}",
    "{\n\tbool is_undulating = false;\n\t\n\t// Get the digits of the number\n\tauto digits = to!(string)(n).map!(a => a.to!int).array;\n\t\n\t// Check if the digits are undulating\n\tfor (int i = 0; i < digits.length - 2; i++) \n\t{\n\t\tif (digits[i] % 2 == 0 && digits[i + 1] % 2 == 1 && digits[i + 2] % 2 == 0) \n\t\t{\n\t\t\tis_undulating = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn is_undulating;\n}",
    "{\n\tauto digits = to!string(n);\n\t\n\tif(digits.length < 3)\n\t\treturn false;\n\t\n\tfor(size_t i = 1; i < digits.length - 1; i++)\n\t{\n\t\tif(digits[i] == digits[i - 1] || digits[i] == digits[i + 1])\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "{\n\tauto digits = to!(string)(n);\n\t\n\tfor(int i = 0; i < digits.length - 1; i++)\n\t{\n\t\tif(digits[i] == digits[i + 1])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}",
    "{\n\tbool result = false;\n\t\n\tif (n < 100) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 100) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 101) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 102) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 103) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 104) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 105) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 106) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 107) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 108) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 109) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 110) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 111) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 112) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 113) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 114) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 115) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 116) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 117) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 118) \n\t{\n\t\treturn true;\n\t}\n\t\n\tif (n == 119) \n\t{\n\t\treturn false;\n\t}\n\t\n\tif (n == 120) \n\t{\n\t\treturn true;",
    "{\n\tint last_digit = n % 10;\n\tint next_digit = 0;\n\tint prev_digit = 0;\n\tbool is_undulating = true;\n\t\n\twhile(n != 0)\n\t{\n\t\tprev_digit = next_digit;\n\t\tnext_digit = n % 10;\n\t\t\n\t\tif(prev_digit == next_digit)\n\t\t{\n\t\t\tis_undulating = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tn /= 10;\n\t}\n\t\n\treturn is_undulating;\n}",
    "{\n\tauto digits = to!string(n);\n\tauto len = digits.length;\n\t\n\tif (len < 3)\n\t\treturn false;\n\t\n\tfor (size_t i = 0; i < len - 2; i++) \n\t{\n\t\tif (digits[i] == digits[i + 2])\n\t\t\treturn true;\n\t}\n\t\n\treturn false;\n}",
    "{\n\tauto digits = to!(string)(n);\n\tauto even = true;\n\tfor (size_t i = 1; i < digits.length; i++) {\n\t\tif (even && digits[i] > digits[i - 1])\n\t\t\treturn false;\n\t\tif (!even && digits[i] < digits[i - 1])\n\t\t\treturn false;\n\t\teven = !even;\n\t}\n\treturn true;\n}",
    "{\n\tauto digits = to!string(n);\n\tforeach(i, digit; digits)\n\t{\n\t\tif(i % 2 == 0)\n\t\t{\n\t\t\tif(digits[i] != digits[i + 1])\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(digits[i] == digits[i + 1])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  ]
}