{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto res = new long[][](len, 2);\n\t\n\tfor (auto i = 0; i < len; ++i)\n\t{\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\t\n\tfor (size_t i = 0; i < n1; ++i)\n\t{\n\t\tfor (size_t j = 0; j < n2; ++j)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\treturn pairs[0 .. min(k, n1 * n2)];\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\theap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif(t[2] == m - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long))(k, (a, b) => a[0] > b[0]);\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpairs[count] = [num1, num2];\n\t\t\tindices[count] = [i, j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i, pair; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tres[i] = pair;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(tuple!(long, long, long));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] + nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tauto ret = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tret[i] = [t[1], t[2]];\n\t}\n\t\n\treturn ret;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(nums1.length, k))\n\t\tpq.put(new long[] { nums1[i], nums2[0], 0 });\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tbreak;\n\t\t\n\t\tres[i] = new long[] { cur[0], cur[1] };\n\t\tpq.put(new long[] { cur[0], nums2[cur[2] + 1], cur[2] + 1 });\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto pq = PriorityQueue!(Tuple!(long, long, long))(Tuple!(long, long, long)(0, 0, nums1[0] + nums2[0]), std.less);\n\tauto visited = new bool[nums1.length][nums2.length];\n\tvisited[0][0] = true;\n\t\n\tlong[][] result;\n\twhile (k-- > 0) \n\t{\n\t\tauto t = pq.popFront();\n\t\tresult ~= [nums1[t[0]], nums2[t[1]]];\n\t\tif (t[0] + 1 < nums1.length && !visited[t[0] + 1][t[1]]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]]));\n\t\t\tvisited[t[0] + 1][t[1]] = true;\n\t\t}\n\t\tif (t[1] + 1 < nums2.length && !visited[t[0]][t[1] + 1]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t\t\tvisited[t[0]][t[1] + 1] = true;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long))(Tuple!(long, long, long, long)(0, 0, nums1[0] + nums2[0], 0));\n\tauto result = new long[][](0);\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult ~= [t[2], t[3]];\n\t\t\n\t\tif (t[0] < n - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]], nums2[t[1]]));\n\t\t\n\t\tif (t[0] == 0 && t[1] < m - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(0, t[1] + 1, nums1[0] + nums2[t[1] + 1], nums2[t[1] + 1]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = new MinHeap!(long[2])();\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tforeach (i; 0 .. n)\n\t{\n\t\tminHeap.push([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto [num1, num2, idx] = minHeap.pop();\n\t\tresult[i] = [num1, num2];\n\t\tif (idx == m - 1)\n\t\t\tcontinue;\n\t\tminHeap.push([num1, nums2[idx + 1], idx + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif(len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. min(k, len1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\t\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto top = minHeap.pop;\n\t\tresult[count] = [top[0], top[1]];\n\t\tcount++;\n\t\t\n\t\tif(top[3] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[3] + 1], top[2], top[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto res = new long[][](n);\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2, n;\n\tlong[] tmp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1 * n2, k);\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](n);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto ret = new long[][](min(k, nums1.length * nums2.length));\n\t\n\tforeach(i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tauto t = pq.get;\n\t\tret[i] = new long[](2);\n\t\tret[i][0] = t[0];\n\t\tret[i][1] = t[1];\n\t\tif(t[3] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn ret;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong sum;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\tpairs = new long[][](n);\n\t\n\ti = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\tpairs[i] = [num1, num2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tm = min(k, n);\n\tresult = new long[][](m);\n\t\n\ti = 0;\n\twhile(i < m)\n\t{\n\t\tresult[i] = pairs[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums1.length - 1)\n\t\t{\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\treturn result;\n}"
  ]
}