{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\n*/\nlong[][] k_smallest_pairs(long[] nums1, long[] nums2, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = k_smallest_pairs;\n\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 2L) == [[1L, 2L], [1L, 4L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 1L) == [[1L, 2L]]);\n    assert(candidate([1L, 3L, 7L], [2L, 4L, 6L], 7L) == [[1L, 2L], [1L, 4L], [3L, 2L], [1L, 6L], [3L, 4L], [3L, 6L], [7L, 2L]]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto res = new long[][](len, 2);\n\t\n\tfor (auto i = 0; i < len; ++i)\n\t{\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto pairs = new long[][](n1 * n2);\n\t\n\tfor (size_t i = 0; i < n1; ++i)\n\t{\n\t\tfor (size_t j = 0; j < n2; ++j)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\treturn pairs[0 .. min(k, n1 * n2)];\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\theap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif(t[2] == m - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long))(k, (a, b) => a[0] > b[0]);\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpairs[count] = [num1, num2];\n\t\t\tindices[count] = [i, j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i, pair; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tres[i] = pair;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(tuple!(long, long, long));\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] + nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tauto ret = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tret[i] = [t[1], t[2]];\n\t}\n\t\n\treturn ret;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(nums1.length, k))\n\t\tpq.put(new long[] { nums1[i], nums2[0], 0 });\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tbreak;\n\t\t\n\t\tres[i] = new long[] { cur[0], cur[1] };\n\t\tpq.put(new long[] { cur[0], nums2[cur[2] + 1], cur[2] + 1 });\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto pq = PriorityQueue!(Tuple!(long, long, long))(Tuple!(long, long, long)(0, 0, nums1[0] + nums2[0]), std.less);\n\tauto visited = new bool[nums1.length][nums2.length];\n\tvisited[0][0] = true;\n\t\n\tlong[][] result;\n\twhile (k-- > 0) \n\t{\n\t\tauto t = pq.popFront();\n\t\tresult ~= [nums1[t[0]], nums2[t[1]]];\n\t\tif (t[0] + 1 < nums1.length && !visited[t[0] + 1][t[1]]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]]));\n\t\t\tvisited[t[0] + 1][t[1]] = true;\n\t\t}\n\t\tif (t[1] + 1 < nums2.length && !visited[t[0]][t[1] + 1]) \n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t\t\tvisited[t[0]][t[1] + 1] = true;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long))(Tuple!(long, long, long, long)(0, 0, nums1[0] + nums2[0], 0));\n\tauto result = new long[][](0);\n\t\n\twhile (k-- > 0)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult ~= [t[2], t[3]];\n\t\t\n\t\tif (t[0] < n - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1] + nums2[t[1]], nums2[t[1]]));\n\t\t\n\t\tif (t[0] == 0 && t[1] < m - 1)\n\t\t\theap.push(Tuple!(long, long, long, long)(0, t[1] + 1, nums1[0] + nums2[t[1] + 1], nums2[t[1] + 1]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = new MinHeap!(long[2])();\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tforeach (i; 0 .. n)\n\t{\n\t\tminHeap.push([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto [num1, num2, idx] = minHeap.pop();\n\t\tresult[i] = [num1, num2];\n\t\tif (idx == m - 1)\n\t\t\tcontinue;\n\t\tminHeap.push([num1, nums2[idx + 1], idx + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif(len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. min(k, len1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\t\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto top = minHeap.pop;\n\t\tresult[count] = [top[0], top[1]];\n\t\tcount++;\n\t\t\n\t\tif(top[3] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[3] + 1], top[2], top[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto res = new long[][](n);\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2, n;\n\tlong[] tmp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1 * n2, k);\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](n);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto ret = new long[][](min(k, nums1.length * nums2.length));\n\t\n\tforeach(i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tauto t = pq.get;\n\t\tret[i] = new long[](2);\n\t\tret[i][0] = t[0];\n\t\tret[i][1] = t[1];\n\t\tif(t[3] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn ret;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong n;\n\tlong m;\n\tlong sum;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\tpairs = new long[][](n);\n\t\n\ti = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\tpairs[i] = [num1, num2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(pairs, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tm = min(k, n);\n\tresult = new long[][](m);\n\t\n\ti = 0;\n\twhile(i < m)\n\t{\n\t\tresult[i] = pairs[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums1.length - 1)\n\t\t{\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\tif (pq.length > k) \n\t\t\t{\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[][](pq.length);\n\t\n\tforeach (i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n    long[][] result = new long[][](k);\n    if (nums1.length == 0 || nums2.length == 0 || k == 0)\n        return result;\n    auto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n    foreach (i; 0 .. nums1.length)\n        foreach (j; 0 .. nums2.length)\n            pq.put(tuple(nums1[i], nums2[j]));\n    foreach (i; 0 .. k)\n        result[i] = pq.get;\n    return result;\n}",
    "{\n\t\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[][] temp3;\n\tlong[][] temp4;\n\tlong[][] temp5;\n\tlong[][] temp6;\n\tlong[][] temp7;\n\tlong[][] temp8;\n\tlong[][] temp9;\n\tlong[][] temp10;\n\tlong[][] temp11;\n\tlong[][] temp12;\n\tlong[][] temp13;\n\tlong[][] temp14;\n\tlong[][] temp15;\n\tlong[][] temp16;\n\tlong[][] temp17;\n\tlong[][] temp18;\n\tlong[][] temp19;\n\tlong[][] temp20;\n\tlong[][] temp21;\n\tlong[][] temp22;\n\tlong[][] temp23;\n\tlong[][] temp24;\n\tlong[][] temp25;\n\tlong[][] temp26;\n\tlong[][] temp27;\n\tlong[][] temp28;\n\tlong[][] temp29;\n\tlong[][] temp30;\n\tlong[][] temp31;\n\tlong[][] temp32;\n\tlong[][] temp33;\n\tlong[][] temp34;\n\tlong[][] temp35;\n\tlong[][] temp36;\n\tlong[][] temp37;\n\tlong[][] temp38;\n\tlong[][] temp39;\n\tlong[][] temp40;\n\tlong[][] temp41;\n\tlong[][] temp42;\n\tlong[][] temp43;\n\tlong[][] temp44;\n\tlong[][] temp45;\n\tlong[][] temp46;\n\tlong[][] temp47;\n\tlong[][] temp48;\n\tlong[][] temp49;\n\tlong[][] temp50;\n\tlong[][] temp51;\n\tlong[][] temp52;\n\tlong[][] temp53;\n\tlong[][] temp54;\n\tlong[][] temp55;\n\tlong[][]",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tlong[][] result;\n\twhile(k > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tk--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[count] = [nums1[i], nums2[j]];\n\t\t\tindices[count] = [i, j];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tstd.algorithm.sort(pairs, comp);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tres[i] = pairs[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] heap;\n\tlong i, j, n;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\theap = new long[][](nums1.length * nums2.length, 2);\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\theap[i * nums2.length + j][0] = nums1[i];\n\t\t\theap[i * nums2.length + j][1] = nums2[j];\n\t\t}\n\t}\n\t\n\theap_sort(heap);\n\t\n\tn = min(k, heap.length);\n\tresult = new long[][](n, 2);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tresult[i][0] = heap[i][0];\n\t\tresult[i][1] = heap[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[][] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong i;\n\tlong j;\n\tlong m;\n\tlong n;\n\tlong p;\n\tlong q;\n\tlong r;\n\tlong s;\n\tlong t;\n\tlong u;\n\tlong v;\n\tlong w;\n\tlong x;\n\tlong y;\n\tlong z;\n\tlong aa;\n\tlong bb;\n\tlong cc;\n\tlong dd;\n\tlong ee;\n\tlong ff;\n\tlong gg;\n\tlong hh;\n\tlong ii;\n\tlong jj;\n\tlong kk;\n\tlong ll;\n\tlong mm;\n\tlong nn;\n\tlong oo;\n\tlong pp;\n\tlong qq;\n\tlong rr;\n\tlong ss;\n\tlong tt;\n\tlong uu;\n\tlong vv;\n\tlong ww;\n\tlong xx;\n\tlong yy;\n\tlong zz;\n\tlong aaa;\n\tlong bbb;\n\tlong ccc;\n\tlong ddd;\n\tlong eee;\n\tlong fff;\n\tlong ggg;\n\tlong hhh;\n\tlong iii;\n\tlong jjj;\n\tlong kkk;\n\tlong lll;\n\tlong mmm;\n\tlong nnn;\n\tlong ooo;\n\tlong ppp;\n\tlong qqq;\n\tlong rrr;\n\tlong sss;\n\tlong ttt;\n\tlong uuu;\n\tlong vvv;\n\tlong www;\n\tlong xxx;\n\tlong yyy;\n\tlong zzz;\n\tlong aaaa;\n\tlong bbbb;\n\tlong cccc;\n\tlong dddd;\n\tlong eeee;\n\tlong ffff;\n\tlong gggg;\n\tlong hhhh;\n\tlong iiii;\n\tlong jjjj;\n\tlong kkkk;\n\tlong llll;\n\tlong mmmm;\n\tlong nnnn;\n\tlong",
    "{\n\tlong[][] res = new long[k][];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tfor (long i = 0; i < nums1.length && i < k; i++)\n\t\tpq.put(new long[]{nums1[i], nums2[0], 0});\n\t\n\tfor (long i = 0; i < k && !pq.empty(); i++) \n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = new long[]{cur[0], cur[1]};\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n\t}\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto max_heap = new MinHeap!(tuple!(long, long, long));\n\tmax_heap.insert(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\twhile (count < k && !max_heap.empty)\n\t{\n\t\tauto t = max_heap.pop;\n\t\tresult[count] = [t[0], t[1], t[2]];\n\t\tcount++;\n\t\tif (t[1] + 1 < n1)\n\t\t\tmax_heap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\tif (t[1] == 0 && t[2] + 1 < n2)\n\t\t\tmax_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif(top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](pq.length);\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn res;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto cur = pq.get();\n\t\tif (cur is null) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tres[i] = [cur[0], cur[1]];\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], \"a > b\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, l, m;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[l][0] = nums1[i];\n\t\t\tpairs[l][1] = nums2[j];\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(m; 0 .. k)\n\t{\n\t\tresult[m][0] = pairs[m][0];\n\t\tresult[m][1] = pairs[m][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif(n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)(0, 0));\n\t\n\tforeach(i; 0 .. min(n1, k))\n\t{\n\t\tpq.put(Tuple!(long, long)(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(Tuple!(long, long)(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tlong[][] pairs = new long[nums1.length * nums2.length][2];\n\tlong idx = 0;\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpairs[idx++] = [nums1[i], nums2[j]];\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pairs[i];\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res = new long[k][2];\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto comp = (a, b) => nums1[a[0]] + nums1[a[1]] > nums1[b[0]] + nums1[b[1]];\n\tauto pq = new PriorityQueue!(comp)();\n\tpq.put(tuple(0, 0));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i) \n\t{\n\t\tauto idx = pq.get();\n\t\tres[i][0] = nums1[idx[0]];\n\t\tres[i][1] = nums2[idx[1]];\n\t\t\n\t\tif (idx[0] + 1 < nums1.length) pq.put(tuple(idx[0] + 1, idx[1]));\n\t\tif (idx[0] == 0 && idx[1] + 1 < nums2.length) pq.put(tuple(idx[0], idx[1] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[0] + a[1]\");\n\theap.insert(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tlong[][] result;\n\twhile(k-- > 0)\n\t{\n\t\tif(heap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = heap.popFront;\n\t\tresult ~= [t[0], t[1]];\n\t\t\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\n\t\tif(t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] heap = new long[][](k);\n\tlong heapSize = 0;\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(heapSize < k)\n\t\t\t{\n\t\t\t\theap[heapSize] = [nums1[i], nums2[j]];\n\t\t\t\theapSize++;\n\t\t\t\tif(heapSize == k)\n\t\t\t\t{\n\t\t\t\t\theap.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap[0][0] + heap[0][1])\n\t\t\t\t{\n\t\t\t\t\theap[0] = [nums1[i], nums2[j]];\n\t\t\t\t\theap.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\tauto count = 0;\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[count] = [t[0], t[1]];\n\t\tcount++;\n\t\tif(t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, n1, n2, n;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = n1 * n2;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tresult[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tresult.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tif (k < n)\n\t{\n\t\ttemp = new long[][](k);\n\t\tfor (i = 0; i < k; i++)\n\t\t{\n\t\t\ttemp[i] = result[i];\n\t\t}\n\t\tresult = temp;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long));\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto t = pq.get;\n\t\t\n\t\tres[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tpq.put(tuple(0, 0, nums1[0], nums2[0]));\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i][0] = t[2];\n\t\tresult[i][1] = t[3];\n\t\tif (t[0] == nums1.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i, n; nums1)\n\t{\n\t\tminHeap.push(tuple(n, nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\tif (k == 0) return [];\n\t\n\tauto heap = new MinHeap!(Tuple!(long, long, long, long))();\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto visited = new bool[n1][n2];\n\tvisited[0][0] = true;\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[1], t[2]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[2] + 1 < n2 && !visited[t[1]][t[2] + 1])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 1));\n\t\t\t\tvisited[t[1]][t[2] + 1] = true;\n\t\t\t}\n\t\t\tif (t[1] + 1 < n1 && !visited[t[1] + 1][t[2]])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 0));\n\t\t\t\tvisited[t[1] + 1][t[2]] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[1] + 1 < n1 && !visited[t[1] + 1][t[2]])\n\t\t\t{\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, num; nums1) \n\t{\n\t\tmin_heap.push(tuple(num, nums2[0], i, 0));\n\t}\n\t\n\twhile (k-- > 0 && !min_heap.empty) \n\t{\n\t\tauto t = min_heap.pop;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[3] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tmin_heap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\");\n\tforeach (i, n1; nums1)\n\t\tforeach (j, n2; nums2)\n\t\t\tpq.put(tuple(n1 + n2, i, j, 0));\n\t\n\tlong[][] res;\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tif (t[3] == 1)\n\t\t\tcontinue;\n\t\tres ~= [t[1], t[2]];\n\t\tt[3] = 1;\n\t\tpq.put(t);\n\t}\n\treturn res;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif(len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(tuple!(long, long, long, long))(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\tauto result = new long[][](k);\n\tauto count = 0;\n\t\n\twhile(count < k && !minHeap.empty)\n\t{\n\t\tauto pair = minHeap.pop;\n\t\tresult[count] = [nums1[pair[1]], nums2[pair[2]]];\n\t\tcount++;\n\t\t\n\t\tif(pair[3] == 1 && pair[1] + 1 < len1)\n\t\t\tminHeap.push(tuple(nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2], 1));\n\t\t\n\t\tif(pair[3] == 2 && pair[2] + 1 < len2)\n\t\t\tminHeap.push(tuple(nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[][](k);\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long))();\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(minHeap.top[0] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = minHeap.top[1];\n\t\tresult[i][1] = minHeap.top[2];\n\t\tminHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\tauto res = new long[][](n);\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tres[i] = new long[2];\n\t\tres[i][0] = nums1[i];\n\t\tres[i][1] = nums2[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, l, m;\n\tlong min;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\ttemp = new long[nums1.length][nums2.length];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tmin = temp[i][j];\n\t\t\tfor (l = i; l < nums1.length; l++)\n\t\t\t{\n\t\t\t\tfor (m = j; m < nums2.length; m++)\n\t\t\t\t{\n\t\t\t\t\tif (temp[l][m] < min)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin = temp[l][m];\n\t\t\t\t\t\ttemp[l][m] = temp[i][j];\n\t\t\t\t\t\ttemp[i][j] = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = temp[i / nums2.length][i % nums2.length] - nums2[i % nums2.length];\n\t\tresult[i][1] = nums2[i % nums2.length];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tauto cur = pq.get();\n\t\tresult[i] = new long[](cur[0], cur[1]);\n\t\t\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.pop();\n\t\tresult[i] = [pair[0], pair[1]];\n\t\t\n\t\tif (pair[2] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1) continue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tmin_heap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tlong[][] result;\n\t\n\twhile (k-- > 0 && min_heap.length > 0)\n\t{\n\t\tauto t = min_heap.pop();\n\t\t\n\t\tresult ~= [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\tmin_heap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(n1, n2, i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](pq.length, 2);\n\tforeach(i, t; pq)\n\t{\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res;\n\tlong[] tmp;\n\tlong i, j, n;\n\t\n\tn = nums1.length;\n\tif (n == 0)\n\t\treturn res;\n\t\n\tres = new long[][](k);\n\t\n\ttmp = new long[n];\n\tfor (i = 0; i < n; i++)\n\t\ttmp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tj = minIndex(tmp);\n\t\tres[i] = [nums1[j], nums2[0]];\n\t\tif (nums2.length == 1)\n\t\t\tbreak;\n\t\ttmp[j] = nums1[j] + nums2[1];\n\t\tnums2 = nums2[1..$];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] heap;\n\tlong i, j, n, m, h, t;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\theap = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\theap[i] = pairs[i];\n\t}\n\t\n\tfor (i = k / 2 - 1; i >= 0; i--)\n\t{\n\t\theapify(heap, i, k);\n\t}\n\t\n\tfor (i = k; i < n * m; i++)\n\t{\n\t\tif (pairs[i][0] + pairs[i][1] < heap[0][0] + heap[0][1])\n\t\t{\n\t\t\theap[0] = pairs[i];\n\t\t\theapify(heap, 0, k);\n\t\t}\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = heap[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long));\n\t\n\t// insert the first element\n\tpq.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\t// create a set to store the visited elements\n\tauto visited = new HashSet!(tuple(long, long));\n\t\n\t// create a result array\n\tauto result = new long[][](k);\n\t\n\t// while the queue is not empty\n\twhile (!pq.empty)\n\t{\n\t\t// get the top element\n\t\tauto top = pq.top;\n\t\t\n\t\t// pop the top element\n\t\tpq.pop;\n\t\t\n\t\t// if the element is already visited, continue\n\t\tif (visited.contains(top[1 .. $])) continue;\n\t\t\n\t\t// add the element to the result array\n\t\tresult[top[3]] = [top[1], top[2]];\n\t\t\n\t\t// add the element to the visited set\n\t\tvisited.insert(top[1 .. $]);\n\t\t\n\t\t// if the result array is full, break\n\t\tif (top[3] == k - 1) break;\n\t\t\n\t\t// if the first element is not the last element\n\t\tif (top[1] + 1 < n1)\n\t\t{\n\t\t\t// insert the next element\n\t\t\tpq.insert(tuple(nums1[top[1] + 1] + nums2[top[2]], top[1] + 1, top[2], top[3] + 1));\n\t\t}\n\t\t\n\t\t// if the second element is not the last element\n\t\tif (top[2] + 1 < n2)\n\t\t{\n\t\t\t// insert the next element\n\t\t\tpq.insert(tuple(nums1[",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) return new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] < b[2]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(i, 0, nums1[i] + nums2[0]));\n\t}\n\t\n\tlong[][] res = new long[][](k);\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = new long[] {nums1[t[0]], nums2[t[1]]};\n\t\tif (t[1] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\tresult = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = t[0];\n\t\tresult[i][1] = t[1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\t\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tminHeap.insert(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto pair = minHeap.pop;\n\t\tresult[i] = [nums1[pair[1]], nums2[pair[2]]];\n\t\t\n\t\tif (pair[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert(tuple(nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i, n; nums1)\n\t{\n\t\tminHeap.push(tuple(n, nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i, num1; nums1) \n\t{\n\t\tpq.put(tuple(num1, nums2[0], i, 0));\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[2] == n2 - 1) continue;\n\t\t\n\t\tminHeap.push(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto n = min(n1, n2);\n\t\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long))(Tuple!(long, long, long)(0, 0, nums1[0] + nums2[0]), Tuple!(long, long, long)(n1 - 1, n2 - 1, nums1[n1 - 1] + nums2[n2 - 1]));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = pq.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[0] == 0 && t[1] + 1 < n2)\n\t\t\tpq.insert(Tuple!(long, long, long)(0, t[1] + 1, nums1[0] + nums2[t[1] + 1]));\n\t\t\n\t\tif (t[0] + 1 < n1 && t[1] == 0)\n\t\t\tpq.insert(Tuple!(long, long, long)(t[0] + 1, 0, nums1[t[0] + 1] + nums2[0]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, index;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\tindex = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[k][];\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j, l;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\tl = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[l] = pair;\n\t\t\tl++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index][0] = nums1[i];\n\t\t\tpairs[index][1] = nums2[j];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto arr = new long[][](n1 * n2);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tfor (size_t j = 0; j < n2; j++)\n\t\t{\n\t\t\tarr[i * n2 + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(arr, (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\treturn arr[0 .. min(k, n1 * n2)];\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\n\tauto ret = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tret[i] = [t[0], t[1]];\n\t}\n\treturn ret;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto minHeap = MinHeap!(Tuple!(long, long, long, long))();\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\tminHeap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.extractMin();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[t[1]];\n\t\tresult[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\tminHeap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\tminHeap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tfor (long i = 0; i < n1; i++)\n\t\tmin_heap.insert(tuple(nums1[i] + nums2[0], i, 0, nums2[0]));\n\t\n\tfor (long i = 0; i < k && !min_heap.empty; i++)\n\t{\n\t\tauto t = min_heap.extractMin;\n\t\tresult[i] = [t[0], t[3]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums2[t[2] + 1]));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t{\n\t\t\tif (t[3] < n2 - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[3] < n2 - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tforeach(j; 0 .. min(k, nums2.length))\n\t\t{\n\t\t\tif(pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.peek;\n\t\t\t\tif(nums1[i] + nums2[j] < top[0] + top[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres = new long[][](pq.length);\n\t\n\tforeach(i; 0 .. pq.length)\n\t{\n\t\tres[i] = pq.get;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\ti = 0;\n\twhile(i < k && i < pairs.length)\n\t{\n\t\tresult[i] = pairs[i];\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tlong[][] res = new long[][](min(k, nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length)) \n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t\tif (t[3] == nums2.length - 1) \n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[][] temp;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\ti = 0;\n\tforeach(elem1; nums1)\n\t{\n\t\tforeach(elem2; nums2)\n\t\t{\n\t\t\tpairs[i] = [elem1, elem2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp = new long[][](n);\n\t\n\tauto cmp = (long[] a, long[] b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t};\n\t\n\tstd.algorithm.sort(pairs, cmp);\n\t\n\tif (k > n)\n\t\tk = n;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, l, m;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[0];\n\t\tresult[i][1] = nums2[0];\n\t}\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tif (nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1])\n\t\t\t{\n\t\t\t\tresult[k - 1][0] = nums1[i];\n\t\t\t\tresult[k - 1][1] = nums2[j];\n\t\t\t\t\n\t\t\t\tfor (l = k - 1; l > 0; l--)\n\t\t\t\t{\n\t\t\t\t\tif (result[l][0] + result[l][1] < result[l - 1][0] + result[l - 1][1])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp = result[l];\n\t\t\t\t\t\tresult[l] = result[l - 1];\n\t\t\t\t\t\tresult[l - 1] = temp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto res = new long[][](0);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\")();\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tres ~= [t[0], t[1]];\n\t\tif (t[2] == nums1.length - 1)\n\t\t{\n\t\t\tif (t[3] < nums2.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse if (t[3] == nums2.length - 1)\n\t\t{\n\t\t\tif (t[2] < nums1.length - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(tuple!(long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [t[0], t[1], t[2]];\n\t\t\n\t\tif (t[1] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t\t\n\t\tif (t[1] == 0 && t[2] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tauto heap = new BinaryHeap!(Pair!(long, long))(Pair!(long, long)(0, 0), (a, b) => a.first + a.second < b.first + b.second);\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tforeach(j; 0 .. m)\n\t\t{\n\t\t\tif(heap.length < k)\n\t\t\t{\n\t\t\t\theap.insert(Pair!(long, long)(i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap.top.first + heap.top.second)\n\t\t\t\t{\n\t\t\t\t\theap.pop;\n\t\t\t\t\theap.insert(Pair!(long, long)(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](heap.length);\n\t\n\tforeach(i; 0 .. heap.length)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[heap.top.first];\n\t\tresult[i][1] = nums2[heap.top.second];\n\t\theap.pop;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\tlong i, j, n1, n2, n, m, cnt;\n\tlong[] tmp;\n\tlong[][] heap;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\tn = min(n1, n2);\n\tm = max(n1, n2);\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn res;\n\t\n\theap = new long[n][2];\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\theap[i][0] = nums1[i];\n\t\theap[i][1] = nums2[i];\n\t}\n\t\n\tif (n1 > n2)\n\t{\n\t\ttmp = nums1;\n\t\tnums1 = nums2;\n\t\tnums2 = tmp;\n\t}\n\t\n\tmake_heap(heap);\n\t\n\tres = new long[k][2];\n\tcnt = 0;\n\t\n\twhile (cnt < k)\n\t{\n\t\tres[cnt][0] = heap[0][0];\n\t\tres[cnt][1] = heap[0][1];\n\t\tcnt++;\n\t\t\n\t\tif (cnt == k)\n\t\t\tbreak;\n\t\t\n\t\tif (heap[0][1] == nums2[n2 - 1])\n\t\t{\n\t\t\tpop_heap(heap);\n\t\t\theap[n - 1][0] = nums1[n - 1];\n\t\t\theap[n - 1][1] = nums2[0];\n\t\t\tpush_heap(heap);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpop_heap(heap);\n\t\t\theap[n - 1][0] = heap[n - 1][0];\n\t\t\theap[n - 1][1] = nums2[heap[n - 1][1] + 1];\n\t\t\tpush",
    "{\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] < b[2]\");\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put(tuple(i, 0, nums1[i] + nums2[0]));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[t[0]];\n\t\tresult[i][1] = nums2[t[1]];\n\t\t\n\t\tif (t[1] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], t[1] + 1, nums1[t[0]] + nums2[t[1] + 1]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i, t; temp)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tres[i] = t;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong i, j, n1, n2;\n\tlong[] temp;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\t\n\ttemp = new long[n1];\n\t\n\tfor (i = 0; i < n1; i++)\n\t\ttemp[i] = nums1[i] + nums2[0];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tlong min = temp[0];\n\t\tlong min_index = 0;\n\t\t\n\t\tfor (j = 1; j < n1; j++)\n\t\t{\n\t\t\tif (temp[j] < min)\n\t\t\t{\n\t\t\t\tmin = temp[j];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[0];\n\t\t\n\t\ttemp[min_index] = long.max;\n\t\t\n\t\tif (i < k - 1)\n\t\t{\n\t\t\tif (min_index == n1 - 1)\n\t\t\t\ttemp[min_index] = long.max;\n\t\t\telse\n\t\t\t\ttemp[min_index] = nums1[min_index] + nums2[1];\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (pq.empty) \n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t\tcontinue;\n\t\t\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long));\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[t[3]] = [nums1[t[1]], nums2[t[2]]];\n\t\tif (t[2] == 0 && t[1] + 1 < nums1.length)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], t[3] + 1));\n\t\tif (t[2] + 1 < nums2.length)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto res = new long[][](k);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn res;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tauto t = heap.popFront();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = nums1[t[1]];\n\t\tres[i][1] = nums2[t[2]];\n\t\t\n\t\tif (t[3] == 1 && t[1] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t\n\t\tif (t[3] == 2 && t[2] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 2));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0) \n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i, e1; nums1) \n\t{\n\t\tminHeap.push(tuple(e1, nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tif (minHeap.empty) \n\t\t\tbreak;\n\t\t\n\t\tauto t = minHeap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n2 - 1) \n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n - 1)\n\t\t{\n\t\t\tif (t[3] < m - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t\telse if (t[3] == m - 1)\n\t\t{\n\t\t\tif (t[2] < n - 1)\n\t\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[2] + 1], nums2[t[3]], t[2] + 1, t[3]));\n\t\t\tpq.put(tuple(nums1[t[2]], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j;\n\tlong[] temp;\n\tlong[] temp_pair;\n\tlong temp_sum;\n\tlong min_sum;\n\tlong min_index;\n\tlong count;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tpairs = new long[nums1.length * nums2.length][];\n\t\n\tfor (i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp_pair = new long[2];\n\t\t\ttemp_pair[0] = nums1[i];\n\t\t\ttemp_pair[1] = nums2[j];\n\t\t\tpairs[i * nums2.length + j] = temp_pair;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < pairs.length; i++)\n\t{\n\t\tmin_sum = pairs[i][0] + pairs[i][1];\n\t\tmin_index = i;\n\t\tfor (j = i + 1; j < pairs.length; j++)\n\t\t{\n\t\t\ttemp_sum = pairs[j][0] + pairs[j][1];\n\t\t\tif (temp_sum < min_sum)\n\t\t\t{\n\t\t\t\tmin_sum = temp_sum;\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\ttemp = pairs[i];\n\t\tpairs[i] = pairs[min_index];\n\t\tpairs[min_index] = temp;\n\t}\n\t\n\tcount = 0;\n\tresult = new long[k][];\n\tfor (i = 0; i < pairs.length && count < k; i++)\n\t{\n\t\tresult[count] = pairs[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n, m;\n\t\n\tn = nums1.length;\n\tm = nums2.length;\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpairs = new long[][](n * m);\n\t\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tpairs[i * m + j] = [nums1[i], nums2[j]];\n\t\t}\n\t}\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](min(k, n * m));\n\t\n\tfor (i = 0; i < min(k, n * m); i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(len1, k))\n\t{\n\t\tforeach (j; 0 .. min(len2, k))\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto top = minHeap.top;\n\t\t\t\tif (nums1[i] + nums2[j] < top[0] + top[1])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn minHeap.data;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tforeach (j; 0 .. nums2.length)\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto t = pq.get;\n\t\tresult[i] = t[];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\theap.insert(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] < n2 - 1)\n\t\t{\n\t\t\theap.insert(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_size = nums1.length;\n\tauto nums2_size = nums2.length;\n\tauto result = new long[][](k);\n\tauto result_size = 0;\n\tauto nums1_index = new long[nums1_size];\n\tauto nums2_index = new long[nums2_size];\n\t\n\tfor (auto i = 0; i < nums1_size; i++)\n\t{\n\t\tnums1_index[i] = 0;\n\t}\n\t\n\tfor (auto i = 0; i < nums2_size; i++)\n\t{\n\t\tnums2_index[i] = 0;\n\t}\n\t\n\twhile (result_size < k)\n\t{\n\t\tauto min_value = long.max;\n\t\tauto min_index = -1;\n\t\t\n\t\tfor (auto i = 0; i < nums1_size; i++)\n\t\t{\n\t\t\tif (nums1_index[i] < nums2_size)\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[nums1_index[i]] < min_value)\n\t\t\t\t{\n\t\t\t\t\tmin_value = nums1[i] + nums2[nums1_index[i]];\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto i = 0; i < nums2_size; i++)\n\t\t{\n\t\t\tif (nums2_index[i] < nums1_size)\n\t\t\t{\n\t\t\t\tif (nums2[i] + nums1[nums2_index[i]] < min_value)\n\t\t\t\t{\n\t\t\t\t\tmin_value = nums2[i] + nums1[nums2_index[i]];\n\t\t\t\t\tmin_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (min",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong[][] indices = new long[][](nums1.length * nums2.length);\n\tlong i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpairs[i] = [n1, n2];\n\t\t\tindices[i] = [n1, n2];\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] tmp;\n\tlong i, j;\n\tlong n1, n2;\n\tlong min;\n\tlong min_i, min_j;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tresult = new long[][](k);\n\ttmp = new long[][](n1);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\ttmp[i] = new long[n2];\n\t\tfor (j = 0; j < n2; j++)\n\t\t\ttmp[i][j] = nums1[i] + nums2[j];\n\t}\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tmin = tmp[0][0];\n\t\tmin_i = 0;\n\t\tmin_j = 0;\n\t\tfor (j = 0; j < n1; j++)\n\t\t{\n\t\t\tfor (long l = 0; l < n2; l++)\n\t\t\t{\n\t\t\t\tif (tmp[j][l] < min)\n\t\t\t\t{\n\t\t\t\t\tmin = tmp[j][l];\n\t\t\t\t\tmin_i = j;\n\t\t\t\t\tmin_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_i];\n\t\tresult[i][1] = nums2[min_j];\n\t\ttmp[min_i][min_j] = long.max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tforeach (j; 0 .. n2)\n\t\t{\n\t\t\tif (min_heap.length < k)\n\t\t\t\tmin_heap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < min_heap.top[0])\n\t\t\t\t{\n\t\t\t\t\tmin_heap.pop;\n\t\t\t\t\tmin_heap.push(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop;\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(Tuple!(int, int, int), \"a[2] < b[2]\");\n\tpq.put(tuple(0, 0, nums1[0] + nums2[0]));\n\t\n\tauto seen = new bool[][](n1, n2);\n\tseen[0][0] = true;\n\t\n\tauto res = new long[][](k);\n\tfor (int i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto [x, y, _] = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = nums1[x];\n\t\tres[i][1] = nums2[y];\n\t\tif (x + 1 < n1 && !seen[x + 1][y])\n\t\t{\n\t\t\tpq.put(tuple(x + 1, y, nums1[x + 1] + nums2[y]));\n\t\t\tseen[x + 1][y] = true;\n\t\t}\n\t\tif (y + 1 < n2 && !seen[x][y + 1])\n\t\t{\n\t\t\tpq.put(tuple(x, y + 1, nums1[x] + nums2[y + 1]));\n\t\t\tseen[x][y + 1] = true;\n\t\t}\n\t}\n\treturn res;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\tauto result = new long[][](k);\n\t\n\tif (n == 0 || m == 0 || k == 0)\n\t\treturn result;\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tfor (long i = 0; i < k; ++i)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < m)\n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t\t\n\t\tif (t[2] + 1 < n)\n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto res = new long[][](len, 2);\n\t\n\tif (len1 == 0 || len2 == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. len)\n\t\tpq.put([nums1[i], nums2[i]]);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = cur;\n\t\tif (cur[1] < nums2[len2 - 1])\n\t\t\tpq.put([cur[0], cur[1] + 1]);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] res;\n\tlong[][] pairs;\n\tlong i;\n\tlong j;\n\tlong n1;\n\tlong n2;\n\tlong[long] idx;\n\tlong[long] idx_pairs;\n\tlong[long] idx_res;\n\tlong[long] idx_pairs_res;\n\tlong[long] idx_pairs_res_tmp;\n\tlong[long] idx_pairs_res_tmp2;\n\tlong[long] idx_pairs_res_tmp3;\n\tlong[long] idx_pairs_res_tmp4;\n\tlong[long] idx_pairs_res_tmp5;\n\tlong[long] idx_pairs_res_tmp6;\n\tlong[long] idx_pairs_res_tmp7;\n\tlong[long] idx_pairs_res_tmp8;\n\tlong[long] idx_pairs_res_tmp9;\n\tlong[long] idx_pairs_res_tmp10;\n\tlong[long] idx_pairs_res_tmp11;\n\tlong[long] idx_pairs_res_tmp12;\n\tlong[long] idx_pairs_res_tmp13;\n\tlong[long] idx_pairs_res_tmp14;\n\tlong[long] idx_pairs_res_tmp15;\n\tlong[long] idx_pairs_res_tmp16;\n\tlong[long] idx_pairs_res_tmp17;\n\tlong[long] idx_pairs_res_tmp18;\n\tlong[long] idx_pairs_res_tmp19;\n\tlong[long] idx_pairs_res_tmp20;\n\tlong[long] idx_pairs_res_tmp21;\n\tlong[long] idx_pairs_res_tmp22;\n\tlong[long] idx_pairs_res_tmp23;\n\tlong[long] idx_pairs_res_tmp24;\n\tlong[long] idx_pairs_res_tmp25;\n\t",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)))();\n\t\n\tforeach (i, n1; nums1)\n\t{\n\t\tforeach (j, n2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert(tuple(n1 + n2, i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (n1 + n2 < minHeap.top.tupleof[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.insert(tuple(n1 + n2, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto res = new long[][](minHeap.length);\n\tforeach (i, t; minHeap)\n\t{\n\t\tres[i] = [nums1[t.tupleof[1]], nums2[t.tupleof[2]]];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\tlong[][] result = new long[][](k);\n\tif(n1 == 0 || n2 == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto cmp = (long[] a, long[] b) => a[0] + a[1] < b[0] + b[1];\n\tauto pq = new PriorityQueue!(cmp)();\n\t\n\tforeach(i; 0 .. min(k, n1 * n2))\n\t{\n\t\tpq.put(new long[](nums1[i / n2], nums2[i % n2]));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1]);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek[0] + pq.peek[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get;\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tresult[i] = pq.get;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tminHeap.push(tuple(nums1[i / n2], nums2[i % n2], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0)\n\t\t{\n\t\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\t\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tlong[][] result;\n\t\n\twhile (k > 0 && !heap.empty)\n\t{\n\t\tauto t = heap.popFront();\n\t\t\n\t\tresult ~= [nums1[t[1]], nums2[t[2]]];\n\t\t\n\t\tif (t[3] == 0)\n\t\t{\n\t\t\tif (t[2] < n2 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, 0));\n\t\t\t\n\t\t\tif (t[1] < n1 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (t[1] < n1 - 1)\n\t\t\t\theap.insert(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2], 1));\n\t\t}\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], 0));\n\t\n\tauto result = new long[][](min(k, len1 * len2));\n\tauto index = 0;\n\twhile (index < k && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult[index] = [t[0], t[1]];\n\t\tif (t[2] == len2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t\tindex++;\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\", \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto res = new long[][](k);\n\tauto i = 0;\n\twhile (i < k && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i++] = t[0 .. 2];\n\t\tif (t[2] == n2 - 1) continue;\n\t\tpq.put([t[0], nums2[t[2] + 1], t[2] + 1]);\n\t}\n\treturn res[0 .. i];\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tminHeap.insert(tuple(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !minHeap.empty; ++i)\n\t{\n\t\tauto t = minHeap.extractMin;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == 0 && t[3] + 1 < n2)\n\t\t\tminHeap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, 0));\n\t\t\n\t\tif (t[3] == 0 && t[2] + 1 < n1)\n\t\t\tminHeap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tres[i] = cur[0 .. 2];\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\t\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => a[0] + a[1] > b[0] + b[1];\n\t\n\tauto heap = new PriorityQueue!(comp)();\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (heap.length < k)\n\t\t\t{\n\t\t\t\theap.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < heap.peek[0] + heap.peek[1])\n\t\t\t\t{\n\t\t\t\t\theap.get();\n\t\t\t\t\theap.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = heap.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\t\n\tpairs = new long[][](nums1.length * nums2.length);\n\t\n\ti = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = n1;\n\t\t\tpair[1] = n2;\n\t\t\tpairs[i] = pair;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\ti = 0;\n\tforeach(p; pairs)\n\t{\n\t\tif(i == k)\n\t\t\tbreak;\n\t\tresult[i] = p;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\tif (nums1.length == 0 || nums2.length == 0) \n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tres = new long[][](pq.length);\n\tforeach (i; 0 .. pq.length) \n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\twhile(k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach (i, e1; nums1)\n\t{\n\t\tforeach (j, e2; nums2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(tuple(e1 + e2, i, j));\n\t\t\telse if (e1 + e2 < minHeap.top[0])\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push(tuple(e1 + e2, i, j));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i, e; minHeap)\n\t{\n\t\tresult[i] = [nums1[e[1]], nums2[e[2]]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[](), Tuple!(long, long)(nums1[0], nums2[0]));\n\t\n\tforeach (i; 0 .. min(k, nums1.length * nums2.length))\n\t{\n\t\tauto t = pq.popFront();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[1] + 1 < nums2.length)\n\t\t\tpq.put(Tuple!(long, long)(t[0], t[1] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] temp = new long[][](nums1.length * nums2.length);\n\tlong count = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\ttemp[count] = [nums1[i], nums2[j]];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\ttemp.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tres[i] = temp[i];\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0) return [];\n\t\n\tauto min_heap = new MinHeap!(tuple!(long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tmin_heap.insert(tuple(nums1[i] + nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop();\n\t\tresult[i] = [nums1[t[1]], nums2[t[2]]];\n\t\tif (t[2] == n2 - 1) continue;\n\t\tmin_heap.insert(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i;\n\tlong j;\n\tlong min;\n\tlong min_index;\n\tlong min_index_2;\n\tlong min_index_3;\n\tlong min_index_4;\n\tlong min_index_5;\n\tlong min_index_6;\n\tlong min_index_7;\n\tlong min_index_8;\n\tlong min_index_9;\n\tlong min_index_10;\n\tlong min_index_11;\n\tlong min_index_12;\n\tlong min_index_13;\n\tlong min_index_14;\n\tlong min_index_15;\n\tlong min_index_16;\n\tlong min_index_17;\n\tlong min_index_18;\n\tlong min_index_19;\n\tlong min_index_20;\n\tlong min_index_21;\n\tlong min_index_22;\n\tlong min_index_23;\n\tlong min_index_24;\n\tlong min_index_25;\n\tlong min_index_26;\n\tlong min_index_27;\n\tlong min_index_28;\n\tlong min_index_29;\n\tlong min_index_30;\n\tlong min_index_31;\n\tlong min_index_32;\n\tlong min_index_33;\n\tlong min_index_34;\n\tlong min_index_35;\n\tlong min_index_36;\n\tlong min_index_37;\n\tlong min_index_38;\n\tlong min_index_39;\n\tlong min_index_40;\n\tlong min_index_41;\n\tlong min_index_42;\n\tlong min_index_43;\n\tlong min_index_44;\n\tlong min_index_45;\n\tlong min_index_46;\n\tlong min_index_47;\n\tlong min_index_48;\n\tlong min_index_49;\n\tlong min_index_50;\n\tlong min_index_51;\n\tlong min_index_52;\n\tlong min_index_53;\n\tlong min",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result[0 .. i];\n}",
    "{\n\tlong[][] result;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], (a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tresult = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto cur = pq.get();\n\t\tresult[i] = [cur[0], cur[1]];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\t\n\tif (len1 == 0 || len2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. min(k, len1))\n\t{\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto top = minHeap.pop();\n\t\tresult[i] = [top[0], top[1]];\n\t\t\n\t\tif (top[3] == len2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(top[0], nums2[top[3] + 1], top[2], top[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto heap = new Heap!(Tuple!(long, long, long, long))(Tuple!(long, long, long, long)(0, 0, 0, 0), Tuple!(long, long, long, long)(n, m, n, m));\n\tauto result = new long[][](0);\n\t\n\tif (n == 0 || m == 0)\n\t\treturn result;\n\t\n\theap.insert(Tuple!(long, long, long, long)(nums1[0] + nums2[0], 0, 0, 0));\n\t\n\twhile (k > 0 && heap.length > 0)\n\t{\n\t\tauto t = heap.popFront();\n\t\t\n\t\tif (t[1] < t[2])\n\t\t{\n\t\t\tresult ~= [nums1[t[1]], nums2[t[3]]];\n\t\t\theap.insert(Tuple!(long, long, long, long)(nums1[t[1] + 1] + nums2[t[3]], t[1] + 1, t[2], t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult ~= [nums1[t[1]], nums2[t[3]]];\n\t\t\theap.insert(Tuple!(long, long, long, long)(nums1[t[1]] + nums2[t[3] + 1], t[1], t[2], t[3] + 1));\n\t\t}\n\t\t\n\t\tk--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j;\n\tlong size1 = nums1.length;\n\tlong size2 = nums2.length;\n\t\n\tif (size1 == 0 || size2 == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tif (k == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tif (k > size1 * size2)\n\t{\n\t\tk = size1 * size2;\n\t}\n\t\n\ttemp = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i] = new long[2];\n\t}\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\ttemp[i][0] = nums1[0];\n\t\ttemp[i][1] = nums2[i];\n\t}\n\t\n\tfor (i = 1; i < size1; i++)\n\t{\n\t\tfor (j = 0; j < size2; j++)\n\t\t{\n\t\t\tif (nums1[i] + nums2[j] < temp[k - 1][0] + temp[k - 1][1])\n\t\t\t{\n\t\t\t\ttemp[k - 1][0] = nums1[i];\n\t\t\t\ttemp[k - 1][1] = nums2[j];\n\t\t\t\t\n\t\t\t\tfor (long m = k - 1; m > 0; m--)\n\t\t\t\t{\n\t\t\t\t\tif (temp[m][0] + temp[m][1] < temp[m - 1][0] + temp[m - 1][1])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong[] t = temp[m];\n\t\t\t\t\t\ttemp[m] = temp[m - 1];\n\t\t\t\t\t\ttemp[m - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tresult =",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek[0] + pq.peek[1]) \n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto comp = (Tuple!(long, long, long) a, Tuple!(long, long, long) b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t};\n\t\n\tauto pq = new PriorityQueue!(comp)();\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tlong[][] res;\n\twhile (k-- > 0 && !pq.empty())\n\t{\n\t\tauto t = pq.get();\n\t\tres ~= [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get;\n\t\t\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tforeach (j; 0 .. min(k, nums2.length)) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto pair = pq.get();\n\t\t\t\tif (pair[0] + pair[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong i, j, m, n;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\ttemp = new long[][](m, n);\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\ttemp = temp.sort();\n\t\n\tresult = new long[][](k, 2);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn [];\n\t\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long))(tuple!(long, long, long, long)(0, 0, nums1[0], nums2[0]), std.less!(tuple!(long, long, long, long)));\n\t\n\tlong[][] result;\n\t\n\twhile(k-- > 0)\n\t{\n\t\tauto t = pq.front;\n\t\tpq.popFront();\n\t\tresult ~= [t[2], t[3]];\n\t\t\n\t\tif(t[0] == nums1.length - 1)\n\t\t{\n\t\t\tif(t[1] < nums2.length - 1)\n\t\t\t\tpq.push(tuple!(long, long, long, long)(t[0], t[1] + 1, t[2], nums2[t[1] + 1]));\n\t\t}\n\t\telse if(t[1] == nums2.length - 1)\n\t\t{\n\t\t\tif(t[0] < nums1.length - 1)\n\t\t\t\tpq.push(tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpq.push(tuple!(long, long, long, long)(t[0], t[1] + 1, t[2], nums2[t[1] + 1]));\n\t\t\tpq.push(tuple!(long, long, long, long)(t[0] + 1, t[1], nums1[t[0] + 1], t[3]));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][]();\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[](nums1.length * nums2.length));\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tres[i] = pq.get().array;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto len1 = nums1.length;\n\tauto len2 = nums2.length;\n\tauto len = min(len1, len2);\n\tauto result = new long[][](len);\n\t\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[i];\n\t\tresult[i][1] = nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. min(k, nums1.length))\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\t\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\tpq.put(new long[](nums1[0], nums2[0]));\n\t\n\tlong[][] visited = new long[][](nums1.length, nums2.length);\n\tvisited[0][0] = 1;\n\t\n\tlong count = 0;\n\twhile (count < k && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult[count] = cur;\n\t\tcount++;\n\t\t\n\t\tif (cur[0] + 1 < nums1.length && visited[cur[0] + 1][cur[1]] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0] + 1, cur[1]));\n\t\t\tvisited[cur[0] + 1][cur[1]] = 1;\n\t\t}\n\t\t\n\t\tif (cur[1] + 1 < nums2.length && visited[cur[0]][cur[1] + 1] == 0) \n\t\t{\n\t\t\tpq.put(new long[](cur[0], cur[1] + 1));\n\t\t\tvisited[cur[0]][cur[1] + 1] = 1;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(tuple!(long, long, long, long)[], \"a[0] < b[0]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] + nums2[j], i, j, 0));\n\t\t}\n\t}\n\t\n\tlong[][] result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tif(t[3] == 0)\n\t\t{\n\t\t\tresult[i] = new long[](2);\n\t\t\tresult[i][0] = nums1[t[1]];\n\t\t\tresult[i][1] = nums2[t[2]];\n\t\t\tpq.put(tuple(t[0], t[1], t[2], 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\")();\n\theap.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto res = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] == n1 - 1)\n\t\t\tcontinue;\n\t\t\n\t\theap.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v, nums2[0], i, 0));\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[](2);\n\t\tres[i][0] = t[0];\n\t\tres[i][1] = t[1];\n\t\t\n\t\tif (t[3] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpairs[index++] = [nums1[i], nums2[j]];\n\tpairs = pairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\tforeach(i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tif(pq.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto cur = pq.get;\n\t\tresult[i] = cur[0 .. 2];\n\t\t\n\t\tif(cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\")();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t\tpq.put([nums1[i], nums2[0], 0]);\n\t\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto cur = pq.get;\n\t\tresult ~= cur[0 .. 2];\n\t\tif (cur[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put([cur[0], nums2[cur[2] + 1], cur[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n = nums1.length;\n\tauto m = nums2.length;\n\tauto result = new long[][](k);\n\tauto pq = new PriorityQueue!(tuple!(long, long, long))();\n\t\n\tif(n == 0 || m == 0)\n\t\treturn result;\n\t\n\tpq.put(tuple(nums1[0] + nums2[0], 0, 0));\n\t\n\tfor(long i = 0; i < k && !pq.empty; i++)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1], t[2]];\n\t\tif(t[1] == 0 && t[2] + 1 < m)\n\t\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1));\n\t\tif(t[1] + 1 < n)\n\t\t\tpq.put(tuple(nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\tauto result = new long[][](k);\n\tfor (long i = 0; i < k && !pq.empty; ++i)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[2] == 0 && t[3] + 1 < n2)\n\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif (t[2] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto res = new long[][](n1 * n2);\n\tauto cnt = 0;\n\tfor (auto i = 0; i < n1; i++)\n\t{\n\t\tfor (auto j = 0; j < n2; j++)\n\t\t{\n\t\t\tres[cnt][0] = nums1[i];\n\t\t\tres[cnt][1] = nums2[j];\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tstd.algorithm.sort(res[0 .. cnt], comp);\n\treturn res[0 .. min(k, cnt)];\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j], i, j));\n\t\t\tif(pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tauto res = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tres[i] = [t[0], t[1]];\n\t}\n\treturn res;\n}",
    "{\n\tauto nums1_size = nums1.length;\n\tauto nums2_size = nums2.length;\n\t\n\tif (nums1_size == 0 || nums2_size == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(long[2]);\n\t\n\tforeach (i; 0 .. min(k, nums1_size))\n\t{\n\t\tmin_heap.insert([nums1[i], nums2[0]]);\n\t}\n\t\n\tauto result = new long[][2](min_heap.size);\n\t\n\tforeach (i; 0 .. min(k, nums1_size * nums2_size))\n\t{\n\t\tauto pair = min_heap.pop();\n\t\tresult[i] = pair;\n\t\t\n\t\tif (pair[1] < nums2[nums2_size - 1])\n\t\t{\n\t\t\tauto next_pair = [pair[0], pair[1] + 1];\n\t\t\tmin_heap.insert(next_pair);\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = MinHeap!(long[2])();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert([nums1[i], nums2[0], 0]);\n\t}\n\t\n\tauto result = new long[][2](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto pair = minHeap.extractMin();\n\t\tresult[i] = pair[0 .. 2];\n\t\t\n\t\tif (pair[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.insert([pair[0], nums2[pair[2] + 1], pair[2] + 1]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)))();\n\t\n\tforeach (i, num1; nums1)\n\t{\n\t\tminHeap.push(tuple(num1, nums2[0], 0));\n\t}\n\t\n\tlong[][] result;\n\twhile (k-- > 0 && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] > b[0] + b[1]\");\n\tforeach(i, v; nums1)\n\t\tforeach(j, w; nums2)\n\t\t\tpq.put(tuple(v, w, i, j));\n\t\n\tlong[][] result;\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || a[2] == b[2] && a[3] < b[3]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](min(k, n1 * n2));\n\t\n\tforeach (i; 0 .. min(k, n1 * n2))\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long))();\n\t\n\t// add first row\n\tforeach (i, num; nums2)\n\t\tminHeap.add(tuple(nums1[0] + num, 0, i, num));\n\t\n\tlong[][] result;\n\t\n\twhile (k-- > 0 && !minHeap.empty)\n\t{\n\t\tauto t = minHeap.pop;\n\t\tresult ~= [t[1], t[3]];\n\t\t\n\t\tif (t[0] < n1 - 1)\n\t\t\tminHeap.add(tuple(nums1[t[0] + 1] + nums2[t[2]], t[0] + 1, t[2], nums2[t[2]]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong i, j, n1, n2;\n\t\n\tn1 = nums1.length;\n\tn2 = nums2.length;\n\t\n\tpairs = new long[][](n1 * n2);\n\t\n\tforeach (i; 0 .. n1)\n\t\tforeach (j; 0 .. n2)\n\t\t\tpairs[i * n2 + j] = [nums1[i], nums2[j]];\n\t\n\tpairs.sort!((a, b) => a[0] + a[1] < b[0] + b[1]);\n\t\n\tresult = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t\tresult[i] = pairs[i];\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.length == k)\n\t\t\t{\n\t\t\t\tif(pq.front[0] + pq.front[1] > nums1[i] + nums2[j])\n\t\t\t\t{\n\t\t\t\t\tpq.popFront();\n\t\t\t\t\tpq.pushBack([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.pushBack([nums1[i], nums2[j]]);\n\t\t\t}\n\t\t}\n\t}\n\tresult = pq.data;\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(nums1[0] + nums2[0]));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tforeach (j; 0 .. n2)\n\t\t{\n\t\t\tif (minHeap.length < k)\n\t\t\t\tminHeap.push(nums1[i] + nums2[j]);\n\t\t\telse if (nums1[i] + nums2[j] < minHeap.top)\n\t\t\t{\n\t\t\t\tminHeap.pop;\n\t\t\t\tminHeap.push(nums1[i] + nums2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn minHeap.data;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong[] pair_;\n\tlong i;\n\tlong j;\n\tlong n;\n\tlong m;\n\tlong l;\n\tlong r;\n\tlong mid;\n\tlong count;\n\tlong count_;\n\tlong index;\n\tlong index_;\n\tlong min;\n\tlong min_;\n\tlong max;\n\tlong max_;\n\tlong min_index;\n\tlong min_index_;\n\tlong max_index;\n\tlong max_index_;\n\tlong min_count;\n\tlong min_count_;\n\tlong max_count;\n\tlong max_count_;\n\tlong min_index_count;\n\tlong min_index_count_;\n\tlong max_index_count;\n\tlong max_index_count_;\n\tlong min_index_count_index;\n\tlong min_index_count_index_;\n\tlong max_index_count_index;\n\tlong max_index_count_index_;\n\tlong min_index_count_index_count;\n\tlong min_index_count_index_count_;\n\tlong max_index_count_index_count;\n\tlong max_index_count_index_count_;\n\tlong min_index_count_index_count_index;\n\tlong min_index_count_index_count_index_;\n\tlong max_index_count_index_count_index;\n\tlong max_index_count_index_count_index_;\n\tlong min_index_count_index_count_index_count;\n\tlong min_index_count_index_count_index_count_;\n\tlong max_index_count_index_count_index_count;\n\tlong max_index_count_index_count_index_count_;\n\tlong min_index_count_index_count_index_count_index;\n\tlong min_index_count_index_count_index_count_index_;\n\tlong max_index_count_index_count_index_count_index;\n\tlong max_index_count_index_count_index",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] heap = new long[][](nums1.length * nums2.length);\n\tlong heapSize = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\theap[heapSize] = [nums1[i] + nums2[j], i, j];\n\t\t\theapSize++;\n\t\t}\n\t}\n\t\n\theap = heap[0 .. heapSize];\n\t\n\theap = heap.sort!((a, b) => a[0] < b[0]);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = [heap[i][1], heap[i][2]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] > b[0]\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v + nums2[0], i, 0, v));\n\t\n\tlong[][] res = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = new long[] {t[3], nums2[t[2]]};\n\t\tif (t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(nums1[t[1]] + nums2[t[2] + 1], t[1], t[2] + 1, nums1[t[1]]));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tauto result = new long[][](0);\n\tif(n1 == 0 || n2 == 0 || k == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\tpq.put(tuple(nums1[0], nums2[0], 0, 0));\n\t\n\twhile(k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get();\n\t\tresult ~= [t[0], t[1]];\n\t\tif(t[2] == 0 && t[3] + 1 < n2)\n\t\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\tif(t[2] + 1 < n1)\n\t\t\tpq.put(tuple(nums1[t[2] + 1], t[1], t[2] + 1, t[3]));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(typeof(Tuple!(long, long, long)));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tminHeap.push(tuple(nums1[i] + nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tif (minHeap.empty)\n\t\t\tbreak;\n\t\t\n\t\tauto p = minHeap.pop;\n\t\tresult[i] = [nums1[p[1]], nums2[p[2]]];\n\t\t\n\t\tif (p[2] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(nums1[p[1]] + nums2[p[2] + 1], p[1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tlong[][] pairs;\n\tlong[] pair;\n\tlong i, j;\n\tlong n1 = nums1.length;\n\tlong n2 = nums2.length;\n\tlong n = n1 * n2;\n\t\n\tpairs = new long[][](n);\n\t\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tpair = new long[](2);\n\t\t\tpair[0] = nums1[i];\n\t\t\tpair[1] = nums2[j];\n\t\t\tpairs[i * n2 + j] = pair;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tminHeap.push(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\t\n\t\tminHeap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tlong[][] heap = new long[][](k);\n\tlong heap_size = 0;\n\t\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tif(heap_size < k)\n\t\t\t{\n\t\t\t\theap[heap_size] = [nums1[i], nums2[j]];\n\t\t\t\theap_size++;\n\t\t\t\tif(heap_size == k)\n\t\t\t\t{\n\t\t\t\t\theap_size = build_heap(heap, heap_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < heap[0][0] + heap[0][1])\n\t\t\t\t{\n\t\t\t\t\theap[0] = [nums1[i], nums2[j]];\n\t\t\t\t\theap_size = heapify(heap, heap_size, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0..k)\n\t{\n\t\tres[i] = heap[0];\n\t\theap[0] = heap[heap_size - 1];\n\t\theap_size--;\n\t\theap_size = heapify(heap, heap_size, 0);\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[] temp;\n\tlong i, j, m, n, l, r, mid;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\tif (k > m * n)\n\t\tk = m * n;\n\t\n\tresult = new long[][](k);\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[0];\n\t\tresult[i][1] = nums2[0];\n\t}\n\t\n\tfor (i = 1; i < m; i++)\n\t{\n\t\tfor (j = 1; j < n; j++)\n\t\t{\n\t\t\ttemp = new long[2];\n\t\t\ttemp[0] = nums1[i];\n\t\t\ttemp[1] = nums2[j];\n\t\t\t\n\t\t\tl = 0;\n\t\t\tr = k - 1;\n\t\t\t\n\t\t\twhile (l <= r)\n\t\t\t{\n\t\t\t\tmid = (l + r) / 2;\n\t\t\t\t\n\t\t\t\tif (temp[0] + temp[1] < result[mid][0] + result[mid][1])\n\t\t\t\t\tr = mid - 1;\n\t\t\t\telse\n\t\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t\t\n\t\t\tfor (l = k - 1; l > r; l--)\n\t\t\t\tresult[l] = result[l - 1];\n\t\t\t\n\t\t\tresult[r + 1] = temp;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(long[2])();\n\t\n\tauto result = new long[][](k);\n\t\n\tauto i = 0;\n\twhile (i < k && i < n1 * n2)\n\t{\n\t\tauto pair = [nums1[i / n2], nums2[i % n2]];\n\t\tmin_heap.insert(pair);\n\t\t++i;\n\t}\n\t\n\ti = 0;\n\twhile (i < k && !min_heap.empty)\n\t{\n\t\tresult[i] = min_heap.pop;\n\t\t++i;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn res;\n\t\n\tauto comp = (a, b) { return a[0] + a[1] < b[0] + b[1]; };\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tif (pq.length < k)\n\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (nums1[i] + nums2[j] < pq.peek()[0] + pq.peek()[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put([nums1[i], nums2[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t\tres[i] = pq.get();\n\t\n\treturn res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto minHeap = MinHeap!(tuple!(long, long, long))();\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t{\n\t\tminHeap.insert(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto p = minHeap.pop();\n\t\tresult[i] = [p[0], p[1]];\n\t\t\n\t\tif (p[2] == n2 - 1) continue;\n\t\t\n\t\tminHeap.insert(tuple(p[0], nums2[p[2] + 1], p[2] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[][] {};\n\t\n\tauto nums1_index = new long[nums1.length];\n\tauto nums2_index = new long[nums2.length];\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tlong min = long.max;\n\t\tlong min_index = -1;\n\t\t\n\t\tfor (long j = 0; j < nums1.length; j++) \n\t\t{\n\t\t\tif (nums1_index[j] >= nums2.length)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (nums1[j] + nums2[nums1_index[j]] < min) \n\t\t\t{\n\t\t\t\tmin = nums1[j] + nums2[nums1_index[j]];\n\t\t\t\tmin_index = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = new long[2];\n\t\tresult[i][0] = nums1[min_index];\n\t\tresult[i][1] = nums2[nums1_index[min_index]];\n\t\t\n\t\tnums1_index[min_index]++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0) return [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach (i; 0 .. min(k, n1))\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\tif (t[3] == n2 - 1) continue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result;\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\tforeach (i; 0 .. min(k, nums1.length)) \n\t{\n\t\tpq.put(new long[](nums1[i], nums2[0], 0));\n\t}\n\t\n\twhile (k-- > 0 && !pq.empty) \n\t{\n\t\tauto cur = pq.get();\n\t\tresult ~= new long[](cur[0], cur[1]);\n\t\tif (cur[2] == nums2.length - 1) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpq.put(new long[](cur[0], nums2[cur[2] + 1], cur[2] + 1));\n\t}\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long, long), \"a[0] + a[1]\", \"a[2] < b[2] || (a[2] == b[2] && a[3] < b[3])\");\n\t\n\tforeach (i, v; nums1)\n\t\tpq.put(tuple(v, nums2[0], i, 0));\n\t\n\tlong[][] result;\n\twhile (k-- > 0 && !pq.empty)\n\t{\n\t\tauto t = pq.get;\n\t\tresult ~= [t[0], t[1]];\n\t\tif (t[3] == n2 - 1)\n\t\t\tcontinue;\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto heap = new Heap!(Tuple!(long, long, long, long));\n\theap.insert(tuple(nums1[0] + nums2[0], 0, 0, 1));\n\t\n\tauto result = new long[][](k);\n\t\n\tfor (long i = 0; i < k && !heap.empty; ++i)\n\t{\n\t\tauto t = heap.pop;\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[2] + 1 < n1)\n\t\t\theap.insert(tuple(nums1[t[2] + 1] + nums2[t[3]], t[2] + 1, t[3], t[3] + 1));\n\t\t\n\t\tif (t[3] + 1 < n2)\n\t\t\theap.insert(tuple(nums1[t[2]] + nums2[t[3] + 1], t[2], t[3] + 1, t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0) \n\t{\n\t\treturn result;\n\t}\n\t\n\tauto comp = (a, b) => (a[0] + a[1]) - (b[0] + b[1]);\n\t\n\tauto pq = new PriorityQueue!(typeof(comp))(comp);\n\t\n\tforeach (i; 0 .. nums1.length) \n\t{\n\t\tforeach (j; 0 .. nums2.length) \n\t\t{\n\t\t\tif (pq.length < k) \n\t\t\t{\n\t\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tauto top = pq.get();\n\t\t\t\tif (top[0] + top[1] > nums1[i] + nums2[j]) \n\t\t\t\t{\n\t\t\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\t\t\tpq.get();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k) \n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\t\n\tif (nums1.length == 0 || nums2.length == 0 || k == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1])();\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i], nums2[j]));\n\t\t\tif (pq.length > k)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = [t[0], t[1]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto pq = new PriorityQueue!(tuple(long, long, long, long), \"a[0] + a[1] < b[0] + b[1]\");\n\t\n\tforeach(i; 0 .. min(k, n1))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[3] == n2 - 1) continue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[][] res;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn res;\n\t\n\tauto pq = new PriorityQueue!(a => a[0] + a[1], Tuple!(long, long)[], Tuple!(long, long)[])();\n\t\n\tforeach(i; 0 .. min(k, nums1.length))\n\t{\n\t\tpq.put(tuple(nums1[i], nums2[0], 0));\n\t}\n\t\n\tres = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = pq.get();\n\t\tres[i] = [t[0], t[1]];\n\t\t\n\t\tif(t[2] == nums2.length - 1)\n\t\t\tcontinue;\n\t\t\n\t\tpq.put(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result;\n\tlong[][] temp;\n\tlong[] temp_arr;\n\tlong i, j, m, n, l, r;\n\t\n\tm = nums1.length;\n\tn = nums2.length;\n\t\n\tif (m == 0 || n == 0)\n\t\treturn result;\n\t\n\ttemp = new long[m][n];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp[i][j] = nums1[i] + nums2[j];\n\t\t}\n\t}\n\t\n\ttemp_arr = new long[m * n];\n\t\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\ttemp_arr[i * n + j] = temp[i][j];\n\t\t}\n\t}\n\t\n\ttemp_arr = temp_arr.sort();\n\t\n\tresult = new long[k][2];\n\t\n\tfor (i = 0; i < k; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t{\n\t\t\t\tif (temp[j][l] == temp_arr[i])\n\t\t\t\t{\n\t\t\t\t\tresult[i][0] = nums1[j];\n\t\t\t\t\tresult[i][1] = nums2[l];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tauto minHeap = new MinHeap!(Tuple!(long, long, long));\n\t\n\tforeach(i; 0 .. n1)\n\t{\n\t\tforeach(j; 0 .. n2)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.insert(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] + nums2[j] < minHeap.top.tupleof[0])\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop;\n\t\t\t\t\tminHeap.insert(tuple(nums1[i] + nums2[j], i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = new long[](2);\n\t\tresult[i][0] = nums1[minHeap.top.tupleof[1]];\n\t\tresult[i][1] = nums2[minHeap.top.tupleof[2]];\n\t\tminHeap.pop;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\tif (n1 == 0 || n2 == 0)\n\t\treturn [];\n\t\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long, long));\n\t\n\tforeach (i; 0 .. n1)\n\t{\n\t\tmin_heap.push(tuple(nums1[i], nums2[0], i, 0));\n\t}\n\t\n\tauto result = new long[][](k);\n\t\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = min_heap.pop();\n\t\tresult[i] = [t[0], t[1]];\n\t\t\n\t\tif (t[3] < n2 - 1)\n\t\t{\n\t\t\tmin_heap.push(tuple(t[0], nums2[t[3] + 1], t[2], t[3] + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n    auto len1 = nums1.length;\n    auto len2 = nums2.length;\n    auto len = min(len1, len2);\n    auto res = new long[][](len);\n    auto i = 0;\n    auto j = 0;\n    auto count = 0;\n    while(i < len1 && j < len2 && count < k)\n    {\n        res[count][0] = nums1[i];\n        res[count][1] = nums2[j];\n        count++;\n        if(i == len1 - 1)\n            j++;\n        else if(j == len2 - 1)\n            i++;\n        else\n        {\n            if(nums1[i+1] < nums2[j+1])\n                i++;\n            else\n                j++;\n        }\n    }\n    return res;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0 || k == 0)\n\t\treturn [];\n\t\n\tauto minHeap = new MinHeap!(tuple!(long, long, long));\n\tforeach (i, n; nums1)\n\t\tminHeap.push(tuple(n, nums2[0], 0));\n\t\n\tauto res = new long[][](k);\n\tforeach (i; 0 .. k)\n\t{\n\t\tauto t = minHeap.pop();\n\t\tres[i] = [t[0], t[1]];\n\t\tif (t[2] == n2 - 1)\n\t\t\tcontinue;\n\t\tminHeap.push(tuple(t[0], nums2[t[2] + 1], t[2] + 1));\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[][] result = new long[][](k);\n\tlong[][] pairs = new long[][](nums1.length * nums2.length);\n\tlong index = 0;\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpairs[index] = [nums1[i], nums2[j]];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tsort!((a, b) => a[0] + a[1] < b[0] + b[1])(pairs);\n\t\n\tforeach(i; 0 .. k)\n\t{\n\t\tresult[i] = pairs[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\tif (n1 == 0 || n2 == 0) return [];\n\tif (k == 0) return [];\n\t\n\t// min heap\n\tauto pq = new PriorityQueue!(long[], \"a[0] + a[1]\");\n\t\n\t// add first row\n\tforeach (i, e; nums2)\n\t{\n\t\tpq.put([nums1[0], e]);\n\t}\n\t\n\t// add other rows\n\tforeach (i, e; nums1[1 .. $])\n\t{\n\t\tforeach (j, f; nums2)\n\t\t{\n\t\t\tauto pair = [e, f];\n\t\t\tif (pq.length < k)\n\t\t\t{\n\t\t\t\tpq.put(pair);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pq.peek[0] + pq.peek[1] > pair[0] + pair[1])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn pq.toArray;\n}",
    "{\n\tauto heap = new MinHeap!(typeof(tuple!(long, long, long)));\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\theap.insert(tuple(n1 + n2, i, j));\n\t\t}\n\t}\n\t\n\tauto result = new long[][](k);\n\tforeach(i; 0 .. k)\n\t{\n\t\tauto t = heap.pop();\n\t\tresult[i] = [t[1], t[2]];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto minHeap = new MinHeap!(typeof(tuple(long, long, long)));\n\tauto result = new long[][](k);\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(minHeap.length < k)\n\t\t\t{\n\t\t\t\tminHeap.push(tuple(num1, num2, i + j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(minHeap.top[2] > i + j)\n\t\t\t\t{\n\t\t\t\t\tminHeap.pop();\n\t\t\t\t\tminHeap.push(tuple(num1, num2, i + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, pair; minHeap)\n\t{\n\t\tresult[i] = [pair[0], pair[1]];\n\t}\n\t\n\treturn result;\n}"
  ]
}