{
  "name": "mbpp_308_large_product",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\n*/\nlong[] large_product(long[] nums1, long[] nums2, long N) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = large_product;\n\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 3L) == [60L, 54L, 50L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 4L) == [60L, 54L, 50L, 48L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 5L) == [60L, 54L, 50L, 48L, 45L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a > b\", \"a[2] > b[2]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t}\n\t}\n\t\n\tlong[] ret = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tret[i] = t[0] * t[1];\n\t}\n\treturn ret;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto cmp = (a, b) => a > b;\n\t\n\tnums1.sort!cmp;\n\tnums2.sort!cmp;\n\t\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile (k < N)\n\t{\n\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\n\t\tif (i == nums1.length - 1)\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse if (j == nums2.length - 1)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse if (nums1[i + 1] * nums2[j] > nums1[i] * nums2[j + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple array\n\tTuple!(long, long)[] tuples = new Tuple!(long, long)[nums1.length * nums2.length];\n\t\n\t// populate the tuple array\n\tint i = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\ttuples[i] = tuple(num1, num2);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t// sort the tuple array\n\ttuples.sort!((a, b) => a[0] * a[1] > b[0] * b[1]);\n\t\n\t// populate the result array\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = tuples[i][0] * tuples[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tlong product = nums1[i] * nums2[j];\n\t\t\t\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(product);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(product > pq.peek)\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(product);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$ - 1 - i] * nums2_sorted[$ - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile(N--)\n\t{\n\t\tlong max = 0;\n\t\tlong max_i = 0;\n\t\tlong max_j = 0;\n\t\t\n\t\tforeach(i, num1; nums1_sorted)\n\t\t{\n\t\t\tforeach(j, num2; nums2_sorted)\n\t\t\t{\n\t\t\t\tif(num1 * num2 > max)\n\t\t\t\t{\n\t\t\t\t\tmax = num1 * num2;\n\t\t\t\t\tmax_i = i;\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult ~= max;\n\t\tnums1_sorted[max_i] = 0;\n\t\tnums2_sorted[max_j] = 0;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] res = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tforeach(i, e; nums1)\n\t{\n\t\tif(e > max1[0])\n\t\t{\n\t\t\tmax1[0] = e;\n\t\t\tmax1.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, e; nums2)\n\t{\n\t\tif(e > max2[0])\n\t\t{\n\t\t\tmax2[0] = e;\n\t\t\tmax2.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, e; max1)\n\t{\n\t\tforeach(j, f; max2)\n\t\t{\n\t\t\tif(e * f > res[0])\n\t\t\t{\n\t\t\t\tres[0] = e * f;\n\t\t\t\tres.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple = nums1_sorted_rev.map!(a => tuple(a, nums1_sorted.indexOf(a)));\n\tauto nums2_sorted_rev_tuple = nums2_sorted_rev.map!(a => tuple(a, nums2_sorted.indexOf(a)));\n\t\n\tauto nums1_sorted_rev_tuple_sorted = nums1_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\tauto nums2_sorted_rev_tuple_sorted = nums2_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev = nums1_sorted_rev_tuple_sorted.dup.reverse;\n\tauto nums2_sorted_rev_tuple_sorted_rev = nums2_sorted_rev_tuple_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple = nums1_sorted_rev_tuple_sorted_rev.map!(a => tuple(a[0], a[1], nums2_sorted_rev_tuple_sorted_rev.map!(b => tuple(b[0], b[1])).filter!(b => b[1] != a[1]).map!(b => b[0]).sum));\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple_sorted = nums1_sorted_",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.remove(nums1_sorted.length-1);\n\t\tnums2_sorted.remove(nums2_sorted.length-1);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = max2[i] = long.min;\n\t}\n\t\n\tforeach (n1; nums1)\n\t{\n\t\tforeach (n2; nums2)\n\t\t{\n\t\t\tlong product = n1 * n2;\n\t\t\t\n\t\t\tif (product > max1[0])\n\t\t\t{\n\t\t\t\tmax1[0] = product;\n\t\t\t\tmax1.sort();\n\t\t\t}\n\t\t\t\n\t\t\tif (product > max2[0])\n\t\t\t{\n\t\t\t\tmax2[0] = product;\n\t\t\t\tmax2.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (n1; max1)\n\t{\n\t\tforeach (n2; max2)\n\t\t{\n\t\t\tlong product = n1 * n2;\n\t\t\t\n\t\t\tif (product > result[0])\n\t\t\t{\n\t\t\t\tresult[0] = product;\n\t\t\t\tresult.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$ - i] * nums2_sorted[$ - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\t\n\t\tif(nums1_sorted[$-1] > nums2_sorted[$-1])\n\t\t{\n\t\t\tnums1_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\n\tsort(products);\n\treturn products[$ - N .. $];\n}"
  ]
}