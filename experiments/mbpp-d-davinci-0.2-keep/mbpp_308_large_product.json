{
  "name": "mbpp_308_large_product",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\n*/\nlong[] large_product(long[] nums1, long[] nums2, long N) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = large_product;\n\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 3L) == [60L, 54L, 50L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 4L) == [60L, 54L, 50L, 48L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L], [3L, 6L, 8L, 9L, 10L, 6L], 5L) == [60L, 54L, 50L, 48L, 45L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a > b\", \"a[2] > b[2]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t}\n\t}\n\t\n\tlong[] ret = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tret[i] = t[0] * t[1];\n\t}\n\treturn ret;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto cmp = (a, b) => a > b;\n\t\n\tnums1.sort!cmp;\n\tnums2.sort!cmp;\n\t\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\t\n\twhile (k < N)\n\t{\n\t\tresult[k] = nums1[i] * nums2[j];\n\t\t\n\t\tif (i == nums1.length - 1)\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse if (j == nums2.length - 1)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse if (nums1[i + 1] * nums2[j] > nums1[i] * nums2[j + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple array\n\tTuple!(long, long)[] tuples = new Tuple!(long, long)[nums1.length * nums2.length];\n\t\n\t// populate the tuple array\n\tint i = 0;\n\tforeach(num1; nums1)\n\t{\n\t\tforeach(num2; nums2)\n\t\t{\n\t\t\ttuples[i] = tuple(num1, num2);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t// sort the tuple array\n\ttuples.sort!((a, b) => a[0] * a[1] > b[0] * b[1]);\n\t\n\t// populate the result array\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = tuples[i][0] * tuples[i][1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tlong product = nums1[i] * nums2[j];\n\t\t\t\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(product);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(product > pq.peek)\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(product);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$ - 1 - i] * nums2_sorted[$ - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile(N--)\n\t{\n\t\tlong max = 0;\n\t\tlong max_i = 0;\n\t\tlong max_j = 0;\n\t\t\n\t\tforeach(i, num1; nums1_sorted)\n\t\t{\n\t\t\tforeach(j, num2; nums2_sorted)\n\t\t\t{\n\t\t\t\tif(num1 * num2 > max)\n\t\t\t\t{\n\t\t\t\t\tmax = num1 * num2;\n\t\t\t\t\tmax_i = i;\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult ~= max;\n\t\tnums1_sorted[max_i] = 0;\n\t\tnums2_sorted[max_j] = 0;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] res = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tforeach(i, e; nums1)\n\t{\n\t\tif(e > max1[0])\n\t\t{\n\t\t\tmax1[0] = e;\n\t\t\tmax1.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, e; nums2)\n\t{\n\t\tif(e > max2[0])\n\t\t{\n\t\t\tmax2[0] = e;\n\t\t\tmax2.sort();\n\t\t}\n\t}\n\t\n\tforeach(i, e; max1)\n\t{\n\t\tforeach(j, f; max2)\n\t\t{\n\t\t\tif(e * f > res[0])\n\t\t\t{\n\t\t\t\tres[0] = e * f;\n\t\t\t\tres.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple = nums1_sorted_rev.map!(a => tuple(a, nums1_sorted.indexOf(a)));\n\tauto nums2_sorted_rev_tuple = nums2_sorted_rev.map!(a => tuple(a, nums2_sorted.indexOf(a)));\n\t\n\tauto nums1_sorted_rev_tuple_sorted = nums1_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\tauto nums2_sorted_rev_tuple_sorted = nums2_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev = nums1_sorted_rev_tuple_sorted.dup.reverse;\n\tauto nums2_sorted_rev_tuple_sorted_rev = nums2_sorted_rev_tuple_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple = nums1_sorted_rev_tuple_sorted_rev.map!(a => tuple(a[0], a[1], nums2_sorted_rev_tuple_sorted_rev.map!(b => tuple(b[0], b[1])).filter!(b => b[1] != a[1]).map!(b => b[0]).sum));\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple_sorted = nums1_sorted_",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.remove(nums1_sorted.length-1);\n\t\tnums2_sorted.remove(nums2_sorted.length-1);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = max2[i] = long.min;\n\t}\n\t\n\tforeach (n1; nums1)\n\t{\n\t\tforeach (n2; nums2)\n\t\t{\n\t\t\tlong product = n1 * n2;\n\t\t\t\n\t\t\tif (product > max1[0])\n\t\t\t{\n\t\t\t\tmax1[0] = product;\n\t\t\t\tmax1.sort();\n\t\t\t}\n\t\t\t\n\t\t\tif (product > max2[0])\n\t\t\t{\n\t\t\t\tmax2[0] = product;\n\t\t\t\tmax2.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach (n1; max1)\n\t{\n\t\tforeach (n2; max2)\n\t\t{\n\t\t\tlong product = n1 * n2;\n\t\t\t\n\t\t\tif (product > result[0])\n\t\t\t{\n\t\t\t\tresult[0] = product;\n\t\t\t\tresult.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$ - i] * nums2_sorted[$ - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\t\n\t\tif(nums1_sorted[$-1] > nums2_sorted[$-1])\n\t\t{\n\t\t\tnums1_sorted.popBack;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums2_sorted.popBack;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\n\tsort(products);\n\treturn products[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] sorted1 = nums1.dup.sort;\n\tlong[] sorted2 = nums2.dup.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = sorted1[sorted1.length - i - 1] * sorted2[sorted2.length - i - 1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple = tuple(nums1_sorted_rev);\n\tauto nums2_sorted_rev_tuple = tuple(nums2_sorted_rev);\n\t\n\tauto nums1_sorted_rev_tuple_indexed = nums1_sorted_rev_tuple.indexed;\n\tauto nums2_sorted_rev_tuple_indexed = nums2_sorted_rev_tuple.indexed;\n\t\n\tauto nums1_sorted_rev_tuple_indexed_sorted = nums1_sorted_rev_tuple_indexed.sort;\n\tauto nums2_sorted_rev_tuple_indexed_sorted = nums2_sorted_rev_tuple_indexed.sort;\n\t\n\tauto nums1_sorted_rev_tuple_indexed_sorted_rev = nums1_sorted_rev_tuple_indexed_sorted.dup.reverse;\n\tauto nums2_sorted_rev_tuple_indexed_sorted_rev = nums2_sorted_rev_tuple_indexed_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple_indexed_sorted_rev_tuple = tuple(nums1_sorted_rev_tuple_indexed_sorted_rev);\n\tauto nums2_sorted_rev_tuple_indexed_sorted_rev_tuple = tuple(nums2_sorted_rev_tuple_indexed_sorted_rev);\n\t\n\tauto nums1_sorted_rev_tuple_indexed_sorted_rev_tuple_indexed",
    "{\n\tlong[] result = new long[N];\n\t\n\tint i = 0;\n\tint j = 0;\n\t\n\twhile(i < N)\n\t{\n\t\tlong max = 0;\n\t\tint max_i = 0;\n\t\tint max_j = 0;\n\t\t\n\t\tfor(int k = 0; k < nums1.length; k++)\n\t\t{\n\t\t\tfor(int l = 0; l < nums2.length; l++)\n\t\t\t{\n\t\t\t\tif(nums1[k] * nums2[l] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[k] * nums2[l];\n\t\t\t\t\tmax_i = k;\n\t\t\t\t\tmax_j = l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[i] = max;\n\t\tnums1[max_i] = 0;\n\t\tnums2[max_j] = 0;\n\t\ti++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\t\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => b - a);\n\tnums2.sort!((a, b) => b - a);\n\t\n\t// create a priority queue for storing the products\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), (a, b) => a[0] < b[0]);\n\t\n\t// add the products of the first elements of nums1 and nums2\n\tfor (int i = 0; i < n1; i++)\n\t{\n\t\tfor (int j = 0; j < n2; j++)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] * nums2[j], i, j));\n\t\t}\n\t}\n\t\n\t// pop the top N products from the priority queue\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = t[0];\n\t\t\n\t\t// add the product of the next element in nums1 and nums2\n\t\tint next_i = t[1];\n\t\tint next_j = t[2];\n\t\t\n\t\tif (next_i + 1 < n1 && next_j + 1 < n2)\n\t\t{\n\t\t\tpq.put(tuple(nums1[next_i + 1] * nums2[next_j + 1], next_i + 1, next_j + 1));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tlong max_index = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t\tmax_index = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tnums1[max_index] = 0;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tlong product = num1 * num2;\n\t\t\tif(product > result[N-1])\n\t\t\t{\n\t\t\t\tresult[N-1] = product;\n\t\t\t\tresult.sort();\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n    long[] result = new long[N];\n    long[] nums1_sorted = nums1.dup.sort;\n    long[] nums2_sorted = nums2.dup.sort;\n    long[] nums1_sorted_rev = nums1_sorted.dup.reverse;\n    long[] nums2_sorted_rev = nums2_sorted.dup.reverse;\n    long[] nums1_sorted_rev_trunc = nums1_sorted_rev[0..$-1];\n    long[] nums2_sorted_rev_trunc = nums2_sorted_rev[0..$-1];\n    long[] nums1_sorted_trunc = nums1_sorted[0..$-1];\n    long[] nums2_sorted_trunc = nums2_sorted[0..$-1];\n    long[] nums1_sorted_rev_trunc_rev = nums1_sorted_rev_trunc.dup.reverse;\n    long[] nums2_sorted_rev_trunc_rev = nums2_sorted_rev_trunc.dup.reverse;\n    long[] nums1_sorted_rev_trunc_rev_trunc = nums1_sorted_rev_trunc_rev[0..$-1];\n    long[] nums2_sorted_rev_trunc_rev_trunc = nums2_sorted_rev_trunc_rev[0..$-1];\n    long[] nums1_sorted_rev_trunc_rev_trunc_rev = nums1_sorted_rev_trunc_rev_trunc.dup.reverse;\n    long[] nums2_sorted_rev_trunc_rev_trunc_rev = nums2_sorted_rev_trunc_rev_trunc.dup.reverse;\n    long[] nums1_sorted_rev_trunc_rev_trunc_rev_trunc = nums1_sorted_rev_trunc_rev_trunc_rev[0..$-1];",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(a; nums1)\n\t\t{\n\t\t\tforeach(b; nums2)\n\t\t\t{\n\t\t\t\tif(a * b > max)\n\t\t\t\t{\n\t\t\t\t\tmax = a * b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(a; nums1)\n\t\t{\n\t\t\tforeach(b; nums2)\n\t\t\t{\n\t\t\t\tif(a * b == max)\n\t\t\t\t{\n\t\t\t\t\ta = 0;\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.sort(std.numeric.comparison);\n\tlong[] nums2_sorted = nums2.sort(std.numeric.comparison);\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tresult ~= n1 * n2;\n\t\t}\n\t}\n\t\n\treturn result.sort()[$-N..$];\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(long);\n\t\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tmaxHeap.add(n1 * n2);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = maxHeap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tint i = 0;\n\tforeach(n1; nums1)\n\t\tforeach(n2; nums2)\n\t\t\tproducts[i++] = n1 * n2;\n\t\n\tsort(products);\n\treturn products[$ - N .. $];\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tnums1_sorted.sort;\n\tauto nums2_sorted = nums2.dup;\n\tnums2_sorted.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tauto num1 = nums1_sorted[$-1-i];\n\t\tauto num2 = nums2_sorted[$-1-i];\n\t\t\n\t\tresult ~= num1 * num2;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto maxHeap = new MaxHeap!(tuple!(long, long, long));\n\t\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tif(maxHeap.length < N)\n\t\t\t{\n\t\t\t\tmaxHeap.insert(tuple(n1, n2, n1 * n2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(n1 * n2 > maxHeap.peek().product)\n\t\t\t\t{\n\t\t\t\t\tmaxHeap.pop();\n\t\t\t\t\tmaxHeap.insert(tuple(n1, n2, n1 * n2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, t; maxHeap)\n\t{\n\t\tresult[i] = t.product;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile(N > 0)\n\t{\n\t\tresult ~= nums1_sorted.back * nums2_sorted.back;\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tif(nums1.length == 1 && nums2.length == 1)\n\t{\n\t\tresult[0] = nums1[0] * nums2[0];\n\t\treturn result;\n\t}\n\t\n\tlong[] max_nums1 = new long[N];\n\tlong[] max_nums2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax_nums1[i] = nums1[0];\n\t\tmax_nums2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max_nums1[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax_nums1[k] = max_nums1[k - 1];\n\t\t\t\t}\n\t\t\t\tmax_nums1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max_nums2[j])\n\t\t\t{\n\t\t\t\tfor(int k = N - 1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax_nums2[k] = max_nums2[k - 1];\n\t\t\t\t}\n\t\t\t\tmax_nums2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$ - 1] * nums2_sorted[$ - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpq.put(n1 * n2);\n\t\t}\n\t}\n\t\n\tforeach(n; 0 .. N)\n\t{\n\t\tresult ~= pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] > b[2]\");\n\t\n\t// add the first element of nums1 and nums2 to the priority queue\n\tpq.put(tuple(0, 0, nums1[0] * nums2[0]));\n\t\n\t// create a set to store the visited indices\n\tauto visited = new Set!(Tuple!(long, long));\n\t\n\t// add the first element to the visited set\n\tvisited.insert(tuple(0, 0));\n\t\n\t// loop N times\n\tforeach (i; 0 .. N)\n\t{\n\t\t// get the top element from the priority queue\n\t\tauto top = pq.get();\n\t\t\n\t\t// add the product to the result\n\t\tresult[i] = top[2];\n\t\t\n\t\t// get the indices of the top element\n\t\tlong i1 = top[0];\n\t\tlong i2 = top[1];\n\t\t\n\t\t// if the next element of nums1 is not visited\n\t\tif (i1 + 1 < nums1.length && !visited.contains(tuple(i1 + 1, i2)))\n\t\t{\n\t\t\t// add the next element of nums1 to the priority queue\n\t\t\tpq.put(tuple(i1 + 1, i2, nums1[i1 + 1] * nums2[i2]));\n\t\t\t\n\t\t\t// add the next element of nums1 to the visited set\n\t\t\tvisited.insert(tuple(i1 + 1, i2));\n\t\t}\n\t\t\n\t\t// if the next element of nums2 is not visited\n\t\tif (i2 + 1 < nums2.length && !visited.",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tint n1 = nums1.length;\n\tint n2 = nums2.length;\n\t\n\tif(n1 == 0 || n2 == 0)\n\t\treturn result;\n\t\n\tif(N == 0)\n\t\treturn result;\n\t\n\tif(N > n1 * n2)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] > b[2]\");\n\t\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tfor(int j = 0; j < n2; j++)\n\t\t{\n\t\t\tpq.put(tuple(i, j, nums1[i] * nums2[j]));\n\t\t}\n\t}\n\t\n\tint k = 0;\n\twhile(k < N)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[k] = t[2];\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn new long[0];\n\t\n\tauto products = new long[nums1.length * nums2.length];\n\t\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tproducts[i++] = n1 * n2;\n\t\t}\n\t}\n\t\n\tstd.algorithm.sort(products);\n\t\n\treturn products[$-N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 in descending order\n\tnums1.sort!((a, b) => b - a);\n\t\n\t// sort nums2 in descending order\n\tnums2.sort!((a, b) => b - a);\n\t\n\t// create a min heap\n\tauto min_heap = new MinHeap!(Tuple!(long, long, long));\n\t\n\t// insert the first element of each array into the min heap\n\tmin_heap.insert(tuple(nums1[0] * nums2[0], 0, 0));\n\t\n\t// while the size of the min heap is less than N\n\twhile (min_heap.size < N)\n\t{\n\t\t// pop the top element from the min heap\n\t\tauto top = min_heap.pop;\n\t\t\n\t\t// push the next element from the array that the top element came from\n\t\t// if the next element is from nums1, then push the next element from nums2\n\t\tif (top[1] == 0)\n\t\t\tmin_heap.insert(tuple(nums1[top[1] + 1] * nums2[top[2]], top[1] + 1, top[2]));\n\t\telse\n\t\t\tmin_heap.insert(tuple(nums1[top[1]] * nums2[top[2] + 1], top[1], top[2] + 1));\n\t}\n\t\n\t// while the min heap is not empty\n\twhile (!min_heap.empty)\n\t{\n\t\t// pop the top element from the min heap\n\t\tauto top = min_heap.pop;\n\t\t\n\t\t// push the top element into the result array\n\t\tresult ~= top[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a tuple of the two arrays\n\tTuple!(long[], long[]) tuple = tuple(nums1, nums2);\n\t\n\t// create a",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the index and the value\n\tTuple!(long, long)[] nums1T = new Tuple!(long, long)[nums1.length];\n\tTuple!(long, long)[] nums2T = new Tuple!(long, long)[nums2.length];\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tnums1T[i] = tuple(i, nums1[i]);\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tnums2T[i] = tuple(i, nums2[i]);\n\t}\n\t\n\t// sort the tuples\n\tnums1T.sort!((a, b) => a[1] > b[1]);\n\tnums2T.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple of the index and the value\n\tTuple!(long, long)[] nums1T2 = new Tuple!(long, long)[nums1.length];\n\tTuple!(long, long)[] nums2T2 = new Tuple!(long, long)[nums2.length];\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tnums1T2[i] = tuple(i, nums1[i]);\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tnums2T2[i] = tuple(i, nums2[i]);\n\t}\n\t\n\t// sort the tuples\n\tnums1T2.sort!((a, b) => a[1] < b[1]);\n\tnums2T2.sort!((a, b) => a[1] < b[1]);\n\t\n\t// create a tuple of the index",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tlong[] result;\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\twhile(N > 0)\n\t{\n\t\tresult ~= nums1_sorted.back * nums2_sorted.back;\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort both arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// push the first element from each array into the queue\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// iterate through the arrays\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\t// if the product is greater than the smallest element in the queue\n\t\t\tif(num1 * num2 > pq.peek())\n\t\t\t{\n\t\t\t\t// pop the smallest element\n\t\t\t\tpq.get();\n\t\t\t\t\n\t\t\t\t// push the new element\n\t\t\t\tpq.put(num1 * num2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// pop the elements from the queue into the result array\n\tforeach(i, n; result)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp[k++] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\tsort(temp);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(a => a[0], Tuple!(long, long, long)[](), Tuple!(long, long, long)(0, 0, 0));\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(Tuple!(long, long, long)(nums1[i] * nums2[j], i, j));\n\t\t\tif(pq.size > N)\n\t\t\t\tpq.get;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get;\n\t\tresult[i] = t[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tint i = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tproducts[i++] = n1 * n2;\n\t\t}\n\t}\n\t\n\tsort(products);\n\treturn products[$-N..$];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\t\n\tint k = 0;\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp[k++] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tsort(temp);\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto s1 = nums1.sort();\n\tauto s2 = nums2.sort();\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = s1[i] * s2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_len = nums1_sorted.length;\n\tauto nums2_len = nums2_sorted.length;\n\t\n\tauto nums1_index = nums1_len - 1;\n\tauto nums2_index = nums2_len - 1;\n\t\n\tauto result = new long[];\n\t\n\twhile (N > 0)\n\t{\n\t\tauto nums1_val = nums1_sorted[nums1_index];\n\t\tauto nums2_val = nums2_sorted[nums2_index];\n\t\t\n\t\tif (nums1_val * nums2_val > nums1_sorted[nums1_index - 1] * nums2_sorted[nums2_index - 1])\n\t\t{\n\t\t\tresult ~= nums1_val * nums2_val;\n\t\t\tnums1_index--;\n\t\t\tnums2_index--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (nums1_val > nums2_val)\n\t\t\t{\n\t\t\t\tresult ~= nums1_val * nums2_sorted[nums2_index - 1];\n\t\t\t\tnums1_index--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult ~= nums1_sorted[nums1_index - 1] * nums2_val;\n\t\t\t\tnums2_index--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tN--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tproducts.sort();\n\t\n\treturn products[$ - N .. $];\n}",
    "{\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] > b[2]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto t = pq.get();\n\t\t\t\tif(t[2] < n1 * n2)\n\t\t\t\t{\n\t\t\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] result = new long[N];\n\tforeach(i, t; pq)\n\t{\n\t\tresult[i] = t[2];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1[0] * nums2[0];\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tif(n1 * n2 > result[i])\n\t\t\t\t{\n\t\t\t\t\tresult[i] = n1 * n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] * nums2[0] == result[i])\n\t\t\t{\n\t\t\t\tnums1[j] = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums1[0] * nums2[j] == result[i])\n\t\t\t{\n\t\t\t\tnums2[j] = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tint i = nums1_sorted.length - 1;\n\tint j = nums2_sorted.length - 1;\n\t\n\tfor(int k = 0; k < N; k++)\n\t{\n\t\tif(nums1_sorted[i] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j-1])\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j-1];\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(num1; nums1_sorted)\n\t{\n\t\tforeach(num2; nums2_sorted)\n\t\t{\n\t\t\tresult ~= num1 * num2;\n\t\t}\n\t}\n\t\n\tresult.sort;\n\t\n\treturn result[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.sort(std.numeric.ordering.gt);\n\tlong[] nums2_sorted = nums2.sort(std.numeric.ordering.gt);\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[i] * nums2_sorted[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tauto nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tint i = 0;\n\tforeach(n1; nums1)\n\t\tforeach(n2; nums2)\n\t\t\tproducts[i++] = n1 * n2;\n\t\n\tsort(products);\n\t\n\treturn products[$ - N .. $];\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t{\n\t\treturn result;\n\t}\n\t\n\tif (nums1.length == 1)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tresult[i] = nums1[0] * nums2[i];\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tif (nums2.length == 1)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tresult[i] = nums1[i] * nums2[0];\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tlong[][] products = new long[nums1.length][nums2.length];\n\t\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tproducts[i][j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong max = products[0][0];\n\t\tint max_i = 0;\n\t\tint max_j = 0;\n\t\tfor (int j = 0; j < nums1.length; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < nums2.length; k++)\n\t\t\t{\n\t\t\t\tif (products[j][k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = products[j][k];\n\t\t\t\t\tmax_i = j;\n\t\t\t\t\tmax_j = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tproducts[max_i][max_j] = -1;\n\t}\n\t\n\treturn result;\n}\n",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\t//std.algorithm.sort(nums1_sorted);\n\t//std.algorithm.sort(nums2_sorted);\n\t\n\tlong[] nums1_sorted_reversed = nums1_sorted.dup;\n\tlong[] nums2_sorted_reversed = nums2_sorted.dup;\n\tnums1_sorted_reversed.reverse;\n\tnums2_sorted_reversed.reverse;\n\t\n\t//std.algorithm.reverse(nums1_sorted_reversed);\n\t//std.algorithm.reverse(nums2_sorted_reversed);\n\t\n\tlong[] nums1_sorted_reversed_indexed = nums1_sorted_reversed.dup;\n\tlong[] nums2_sorted_reversed_indexed = nums2_sorted_reversed.dup;\n\t\n\t//std.algorithm.iota(nums1_sorted_reversed_indexed);\n\t//std.algorithm.iota(nums2_sorted_reversed_indexed);\n\t\n\tfor(long i = 0; i < nums1_sorted_reversed_indexed.length; i++)\n\t{\n\t\tnums1_sorted_reversed_indexed[i] = i;\n\t}\n\t\n\tfor(long i = 0; i < nums2_sorted_reversed_indexed.length; i++)\n\t{\n\t\tnums2_sorted_reversed_indexed[i] = i;\n\t}\n\t\n\t//std.algorithm.sort(nums1_sorted_reversed_indexed, (a, b) => nums1_sorted_reversed[",
    "{\n\tlong[][] products = new long[nums1.length][nums2.length];\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tproducts[i][j] = num1 * num2;\n\t\t}\n\t}\n\t\n\tlong[] result = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = products[0][0];\n\t\tlong[] max_index = [0, 0];\n\t\tforeach(j, k; products)\n\t\t{\n\t\t\tif(products[j][k] > max)\n\t\t\t{\n\t\t\t\tmax = products[j][k];\n\t\t\t\tmax_index = [j, k];\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tproducts[max_index[0]][max_index[1]] = 0;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tint i = nums1_sorted.length - 1;\n\tint j = nums2_sorted.length - 1;\n\t\n\tint k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\n\t\tif(i > 0 && j > 0)\n\t\t{\n\t\t\tif(nums1_sorted[i - 1] * nums2_sorted[j] > nums1_sorted[i] * nums2_sorted[j - 1])\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\telse if(i > 0)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\t\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tlong max_index = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t\tmax_index = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tnums1[max_index] = 0;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong[] temp2;\n\tlong[] temp3;\n\tlong[] temp4;\n\tlong[] temp5;\n\tlong[] temp6;\n\tlong[] temp7;\n\tlong[] temp8;\n\tlong[] temp9;\n\tlong[] temp10;\n\tlong[] temp11;\n\tlong[] temp12;\n\tlong[] temp13;\n\tlong[] temp14;\n\tlong[] temp15;\n\tlong[] temp16;\n\tlong[] temp17;\n\tlong[] temp18;\n\tlong[] temp19;\n\tlong[] temp20;\n\tlong[] temp21;\n\tlong[] temp22;\n\tlong[] temp23;\n\tlong[] temp24;\n\tlong[] temp25;\n\tlong[] temp26;\n\tlong[] temp27;\n\tlong[] temp28;\n\tlong[] temp29;\n\tlong[] temp30;\n\tlong[] temp31;\n\tlong[] temp32;\n\tlong[] temp33;\n\tlong[] temp34;\n\tlong[] temp35;\n\tlong[] temp36;\n\tlong[] temp37;\n\tlong[] temp38;\n\tlong[] temp39;\n\tlong[] temp40;\n\tlong[] temp41;\n\tlong[] temp42;\n\tlong[] temp43;\n\tlong[] temp44;\n\tlong[] temp45;\n\tlong[] temp46;\n\tlong[] temp47;\n\tlong[] temp48;\n\tlong[] temp49;\n\tlong[] temp50;\n\tlong[] temp51;\n\tlong[] temp52;\n\tlong[] temp53;\n\tlong[] temp54;\n\tlong[] temp55;\n\tlong[] temp56;\n\tlong[] temp57;\n\tlong[] temp58;\n\tlong[] temp59;\n\tlong[] temp60;\n\tlong[] temp61;\n\tlong[] temp62;\n\tlong[] temp63;\n\tlong[] temp64;\n\tlong[] temp65;\n\tlong[] temp66;\n\tlong[] temp67;\n\tlong[] temp68;\n\tlong[] temp69;\n\tlong[] temp70;\n\tlong[] temp71;\n\tlong[] temp72;\n",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] max_nums1 = nums1_sorted[nums1_sorted.length - N .. $];\n\tlong[] max_nums2 = nums2_sorted[nums2_sorted.length - N .. $];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max_nums1[i] * max_nums2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// create a set of tuples\n\tauto set = new Set!(Tuple!(long, long));\n\t\n\t// loop through the arrays\n\tforeach(i, nums1)\n\t{\n\t\tforeach(j, nums2)\n\t\t{\n\t\t\t// create a tuple\n\t\t\tauto t = tuple(nums1[i], nums2[j]);\n\t\t\t\n\t\t\t// if the tuple is not in the set\n\t\t\tif(!set.contains(t))\n\t\t\t{\n\t\t\t\t// add the tuple to the set\n\t\t\t\tset.insert(t);\n\t\t\t\t\n\t\t\t\t// add the product to the priority queue\n\t\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// loop through the priority queue\n\tforeach(i, pq)\n\t{\n\t\t// add the product to the result\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a new array to hold the products\n\tlong[] products = new long[nums1.length * nums2.length];\n\t\n\t// calculate the products\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\t// sort the products\n\tproducts.sort();\n\t\n\t// return the last N products\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = products[products.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tauto pq = new PriorityQueue!(long, \"a > b\")();\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tpq.put(num1 * num2);\n\t\t\tif(pq.length > N)\n\t\t\t\tpq.pop();\n\t\t}\n\t}\n\t\n\tforeach(i, e; pq)\n\t\tresult[i] = e;\n\t\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tlong prod = num1 * num2;\n\t\t\t\n\t\t\tif(prod > result[$-1])\n\t\t\t{\n\t\t\t\tresult[$-1] = prod;\n\t\t\t\tresult.sort!((a, b) => a > b);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(N == 0)\n\t\t\t\treturn result;\n\t\t\t\n\t\t\tif(num1 * num2 > result[$-1])\n\t\t\t{\n\t\t\t\tresult[$-1] = num1 * num2;\n\t\t\t\tresult.sort;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\n\tforeach(i; 0 .. N)\n\t\tresult[i] = pq.get();\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tif(nums1.length == 1 && nums2.length == 1)\n\t{\n\t\tresult[0] = nums1[0] * nums2[0];\n\t\treturn result;\n\t}\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tint i = nums1_sorted.length - 1;\n\tint j = nums2_sorted.length - 1;\n\t\n\tint k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tresult[k] = nums1_sorted[i] * nums2_sorted[j];\n\t\t\n\t\tif(i == 0)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\telse if(j == 0)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\telse if(nums1_sorted[i] > nums2_sorted[j])\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\t\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(N == 0)\n\t\treturn result;\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tif(N > nums1.length * nums2.length)\n\t\treturn result;\n\t\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_index = nums1.length - 1;\n\tauto nums2_index = nums2.length - 1;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_index] * nums2_sorted[nums2_index];\n\t\t\n\t\tif(nums1_index == 0)\n\t\t\tnums2_index--;\n\t\telse if(nums2_index == 0)\n\t\t\tnums1_index--;\n\t\telse if(nums1_sorted[nums1_index - 1] * nums2_sorted[nums2_index] > nums1_sorted[nums1_index] * nums2_sorted[nums2_index - 1])\n\t\t\tnums1_index--;\n\t\telse\n\t\t\tnums2_index--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort both lists\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// Store the products in the priority queue\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\t// Pop the top N products from the priority queue\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_max = nums1_sorted[$-1];\n\tauto nums2_max = nums2_sorted[$-1];\n\t\n\tauto max_product = nums1_max * nums2_max;\n\t\n\tauto nums1_min = nums1_sorted[0];\n\tauto nums2_min = nums2_sorted[0];\n\t\n\tauto min_product = nums1_min * nums2_min;\n\t\n\tauto products = new long[N];\n\t\n\tauto nums1_index = 0;\n\tauto nums2_index = 0;\n\t\n\tfor(auto i = 0; i < N; i++)\n\t{\n\t\tif(nums1_sorted[nums1_index] * nums2_sorted[nums2_index] < nums1_sorted[nums1_index] * nums2_sorted[nums2_index + 1])\n\t\t{\n\t\t\tproducts[i] = nums1_sorted[nums1_index] * nums2_sorted[nums2_index + 1];\n\t\t\tnums2_index++;\n\t\t}\n\t\telse if(nums1_sorted[nums1_index] * nums2_sorted[nums2_index] < nums1_sorted[nums1_index + 1] * nums2_sorted[nums2_index])\n\t\t{\n\t\t\tproducts[i] = nums1_sorted[nums1_index + 1] * nums2_sorted[nums2_index];\n\t\t\tnums1_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducts[i] = nums1_sorted[nums1_index] * nums2_sorted[nums2_index];\n\t\t\tnums1_index++;\n\t\t",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort!((a, b) => a > b);\n\tnums2.sort!((a, b) => a > b);\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long, (a, b) => a < b);\n\t\n\t// push the first element into the queue\n\tpq.push(nums1[0] * nums2[0]);\n\t\n\t// create a set to store the visited elements\n\tauto visited = new Set!(Tuple!(long, long));\n\t\n\t// mark the first element as visited\n\tvisited.insert(tuple(0, 0));\n\t\n\t// create a tuple to store the current position\n\tauto cur = tuple(0, 0);\n\t\n\t// loop N times\n\tforeach (i; 0 .. N)\n\t{\n\t\t// pop the top element from the queue\n\t\tresult[i] = pq.pop();\n\t\t\n\t\t// get the current position\n\t\tcur = tuple(cur[0], cur[1]);\n\t\t\n\t\t// if the current position is not the last element of nums1\n\t\tif (cur[0] != nums1.length - 1)\n\t\t{\n\t\t\t// if the next element of nums1 is not visited\n\t\t\tif (!visited.contains(tuple(cur[0] + 1, cur[1])))\n\t\t\t{\n\t\t\t\t// push the next element of nums1 into the queue\n\t\t\t\tpq.push(nums1[cur[0] + 1] * nums2[cur[1]]);\n\t\t\t\t\n\t\t\t\t// mark the next element of nums1 as visited\n\t\t\t\tvisited.insert(tuple(cur[0] + 1, cur[1]));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// if the current position is not the last element of nums2\n\t\tif (cur[1] != nums2.length - 1)\n\t\t{",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple = nums1_sorted_rev.map!(a => tuple(a, nums1.indexOf(a)));\n\tauto nums2_sorted_rev_tuple = nums2_sorted_rev.map!(a => tuple(a, nums2.indexOf(a)));\n\t\n\tauto nums1_sorted_rev_tuple_sorted = nums1_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\tauto nums2_sorted_rev_tuple_sorted = nums2_sorted_rev_tuple.sort!((a, b) => a[0] < b[0]);\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev = nums1_sorted_rev_tuple_sorted.dup.reverse;\n\tauto nums2_sorted_rev_tuple_sorted_rev = nums2_sorted_rev_tuple_sorted.dup.reverse;\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple = nums1_sorted_rev_tuple_sorted_rev.map!(a => tuple(a[0] * a[1], a[0], a[1]));\n\tauto nums2_sorted_rev_tuple_sorted_rev_tuple = nums2_sorted_rev_tuple_sorted_rev.map!(a => tuple(a[0] * a[1], a[0], a[1]));\n\t\n\tauto nums1_sorted_rev_tuple_sorted_rev_tuple",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto maxHeap = new MaxHeap!(tuple!(long, long));\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(maxHeap.length < N)\n\t\t\t{\n\t\t\t\tmaxHeap.insert(tuple(num1 * num2, num1, num2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauto max = maxHeap.peek();\n\t\t\t\tif(num1 * num2 > max[0])\n\t\t\t\t{\n\t\t\t\t\tmaxHeap.pop();\n\t\t\t\t\tmaxHeap.insert(tuple(num1 * num2, num1, num2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, max; maxHeap)\n\t{\n\t\tresult[i] = max[0];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] sorted1 = nums1.dup.sort;\n\tlong[] sorted2 = nums2.dup.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = sorted1[$-1] * sorted2[$-1];\n\t\tsorted1.popBack;\n\t\tsorted2.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a tuple of the index and the value\n\tauto nums1_tuple = zip(iota(nums1.length), nums1);\n\tauto nums2_tuple = zip(iota(nums2.length), nums2);\n\t\n\t// sort the tuples by the value\n\tnums1_tuple.sort!((a, b) => a[1] > b[1]);\n\tnums2_tuple.sort!((a, b) => a[1] > b[1]);\n\t\n\t// create a tuple of the index and the value\n\tauto nums1_tuple_sorted = zip(iota(nums1.length), nums1_tuple);\n\tauto nums2_tuple_sorted = zip(iota(nums2.length), nums2_tuple);\n\t\n\t// sort the tuples by the value\n\tnums1_tuple_sorted.sort!((a, b) => a[1][1] > b[1][1]);\n\tnums2_tuple_sorted.sort!((a, b) => a[1][1] > b[1][1]);\n\t\n\t// create a tuple of the index and the value\n\tauto nums1_tuple_sorted_sorted = zip(iota(nums1.length), nums1_tuple_sorted);\n\tauto nums2_tuple_sorted_sorted = zip(iota(nums2.length), nums2_tuple_sorted);\n\t\n\t// sort the tuples by the value\n\tnums1_tuple_sorted_sorted.sort!((a, b) => a[1][1][1] > b[1][1][1]);\n\tnums2_tuple_sorted_sorted.sort!((a, b) => a[1][1][1] > b[1][1][1]);\n\t\n\t// create a tuple",
    "{\n\tauto nums1_sorted = nums1.sort();\n\tauto nums2_sorted = nums2.sort();\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$ - 1 - i] * nums2_sorted[$ - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\tauto result = new long[N];\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n    long[] result = new long[N];\n    for (long i = 0; i < N; i++)\n    {\n        long max = long.min;\n        long max1 = 0;\n        long max2 = 0;\n        for (long j = 0; j < nums1.length; j++)\n        {\n            for (long k = 0; k < nums2.length; k++)\n            {\n                if (nums1[j] * nums2[k] > max)\n                {\n                    max = nums1[j] * nums2[k];\n                    max1 = nums1[j];\n                    max2 = nums2[k];\n                }\n            }\n        }\n        result[i] = max;\n        nums1 = nums1.filter!(a => a != max1);\n        nums2 = nums2.filter!(a => a != max2);\n    }\n    return result;\n}",
    "{\n\tauto t = tuple(nums1, nums2);\n\tauto products = t[0].map!(a => t[1].map!(b => a * b));\n\tauto flat = products.flatten;\n\tauto sorted = flat.sort!((a, b) => a > b);\n\treturn sorted.take(N);\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max1 = new long[N];\n\tlong[] max2 = new long[N];\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tmax1[i] = nums1[0];\n\t\tmax2[i] = nums2[0];\n\t}\n\t\n\tfor(int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums1[i] > max1[j])\n\t\t\t{\n\t\t\t\tfor(int k = N-1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax1[k] = max1[k-1];\n\t\t\t\t}\n\t\t\t\tmax1[j] = nums1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < nums2.length; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif(nums2[i] > max2[j])\n\t\t\t{\n\t\t\t\tfor(int k = N-1; k > j; k--)\n\t\t\t\t{\n\t\t\t\t\tmax2[k] = max2[k-1];\n\t\t\t\t}\n\t\t\t\tmax2[j] = nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max1[i] * max2[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[k++] = n1 * n2;\n\t\t}\n\t}\n\ttemp.sort;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup;\n\tauto nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tlong product = num1 * num2;\n\t\t\t\n\t\t\tif(product > result[N-1])\n\t\t\t{\n\t\t\t\tresult[N-1] = product;\n\t\t\t\tresult.sort;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tif(n1 * n2 > max)\n\t\t\t\t{\n\t\t\t\t\tmax = n1 * n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] == max)\n\t\t\t{\n\t\t\t\tnums1[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums2[j] == max)\n\t\t\t{\n\t\t\t\tnums2[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](N);\n\tauto maxHeap = new MaxHeap!(long)();\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(maxHeap.size < N)\n\t\t\t\tmaxHeap.push(num1 * num2);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(num1 * num2 > maxHeap.top)\n\t\t\t\t{\n\t\t\t\t\tmaxHeap.pop();\n\t\t\t\t\tmaxHeap.push(num1 * num2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, product; products)\n\t{\n\t\tproducts[i] = maxHeap.pop;\n\t}\n\t\n\treturn products;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto p = new long[][](nums1.length, nums2.length);\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tp[i][j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tauto p_sorted = p.sort!((a, b) => a > b);\n\t\n\treturn p_sorted[0..N];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1[0] * nums2[0];\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tif(n1 * n2 > result[i])\n\t\t\t\t{\n\t\t\t\t\tresult[i] = n1 * n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tif(n1 * nums2[0] == result[i])\n\t\t\t{\n\t\t\t\tnums1 = nums1[1 .. $];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tif(nums1[0] * n2 == result[i])\n\t\t\t{\n\t\t\t\tnums2 = nums2[1 .. $];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tlong product = n1 * n2;\n\t\t\t\tif(product > max)\n\t\t\t\t{\n\t\t\t\t\tmax = product;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] == max)\n\t\t\t{\n\t\t\t\tnums1[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums2[j] == max)\n\t\t\t{\n\t\t\t\tnums2[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted = nums1_sorted[0..$-1];\n\t\tnums2_sorted = nums2_sorted[0..$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto l1 = nums1.length;\n\tauto l2 = nums2.length;\n\t\n\tauto max = new long[][](l1, l2);\n\t\n\tforeach(i; 0 .. l1)\n\t{\n\t\tforeach(j; 0 .. l2)\n\t\t{\n\t\t\tmax[i][j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tauto res = new long[](N);\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto max_val = max[0][0];\n\t\tauto max_i = 0;\n\t\tauto max_j = 0;\n\t\t\n\t\tforeach(i; 0 .. l1)\n\t\t{\n\t\t\tforeach(j; 0 .. l2)\n\t\t\t{\n\t\t\t\tif(max[i][j] > max_val)\n\t\t\t\t{\n\t\t\t\t\tmax_val = max[i][j];\n\t\t\t\t\tmax_i = i;\n\t\t\t\t\tmax_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tres[i] = max_val;\n\t\tmax[max_i][max_j] = -1;\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tif(n1 * n2 > max)\n\t\t\t\t{\n\t\t\t\t\tmax = n1 * n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] == max)\n\t\t\t{\n\t\t\t\tnums1[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums2[j] == max)\n\t\t\t{\n\t\t\t\tnums2[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto nums1_sorted_rev = nums1_sorted.dup.reverse;\n\tauto nums2_sorted_rev = nums2_sorted.dup.reverse;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev = nums1_sorted.dup;\n\tlong[] nums2_sorted_rev = nums2_sorted.dup;\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tlong[] nums1_sorted_rev_index = new long[nums1_sorted_rev.length];\n\tlong[] nums2_sorted_rev_index = new long[nums2_sorted_rev.length];\n\t\n\tfor(long i = 0; i < nums1_sorted_rev.length; i++)\n\t{\n\t\tnums1_sorted_rev_index[i] = nums1_sorted.indexOf(nums1_sorted_rev[i]);\n\t}\n\t\n\tfor(long i = 0; i < nums2_sorted_rev.length; i++)\n\t{\n\t\tnums2_sorted_rev_index[i] = nums2_sorted.indexOf(nums2_sorted_rev[i]);\n\t}\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(Tuple!(long, long, long), \"a[2] > b[2]\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(i, j, nums1[i] * nums2[j]));\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = t[2];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] products = new long[nums1.length * nums2.length];\n\t\n\tint index = 0;\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\tproducts[index++] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tsort(products);\n\t\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = products[products.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tproducts.sort!((a, b) => a > b);\n\t\n\treturn products[0 .. N];\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1 - i] * nums2_sorted[nums2_sorted.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] sorted1 = nums1.dup.sort;\n\tlong[] sorted2 = nums2.dup.sort;\n\t\n\tlong[] max1 = sorted1[sorted1.length - 1 .. $];\n\tlong[] max2 = sorted2[sorted2.length - 1 .. $];\n\t\n\tlong[] min1 = sorted1[0 .. sorted1.length - 1];\n\tlong[] min2 = sorted2[0 .. sorted2.length - 1];\n\t\n\tlong[] max_products = new long[N];\n\tlong[] min_products = new long[N];\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tmax_products[i] = max1[i] * max2[i];\n\t\tmin_products[i] = min1[i] * min2[i];\n\t}\n\t\n\tmax_products.sort;\n\tmin_products.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = max_products[i] > min_products[i] ? max_products[i] : min_products[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint index = 0;\n\tfor (int i = 0; i < nums1.length; i++)\n\t{\n\t\tfor (int j = 0; j < nums2.length; j++)\n\t\t{\n\t\t\ttemp[index++] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\tsort(temp);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(n1; nums1)\n\t\t{\n\t\t\tforeach(n2; nums2)\n\t\t\t{\n\t\t\t\tif(n1 * n2 > max)\n\t\t\t\t{\n\t\t\t\t\tmax = n1 * n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tif(nums1[j] == max / nums2[0])\n\t\t\t{\n\t\t\t\tnums1[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(nums2[j] == max / nums1[0])\n\t\t\t{\n\t\t\t\tnums2[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto result = new long[N];\n\tauto n1 = nums1.length;\n\tauto n2 = nums2.length;\n\t\n\t// sort nums1 and nums2\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a min-heap\n\tauto heap = new MinHeap!(long)(N);\n\t\n\t// add the first element to the heap\n\theap.add(nums1[n1-1] * nums2[n2-1]);\n\t\n\t// start from the second last element of nums1\n\t// and the last element of nums2\n\tauto i = n1 - 2;\n\tauto j = n2 - 1;\n\t\n\t// loop until we have N elements in the heap\n\twhile (heap.size < N)\n\t{\n\t\t// add the product of the current elements to the heap\n\t\theap.add(nums1[i] * nums2[j]);\n\t\t\n\t\t// if we have reached the end of nums1,\n\t\t// we need to move to the next element of nums2\n\t\tif (i == 0)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\t// otherwise, we need to move to the next element of nums1\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\t// copy the elements from the heap to the result array\n\tforeach (i, ref e; result)\n\t{\n\t\te = heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// create a priority queue\n\tauto pq = new PriorityQueue!(long)();\n\t\n\t// add the first N elements to the queue\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tpq.put(nums1[i] * nums2[i]);\n\t}\n\t\n\t// iterate through the rest of the elements\n\tfor (int i = N; i < nums1.length; i++)\n\t{\n\t\tfor (int j = N; j < nums2.length; j++)\n\t\t{\n\t\t\t// if the product is greater than the smallest product in the queue, replace it\n\t\t\tif (nums1[i] * nums2[j] > pq.peek())\n\t\t\t{\n\t\t\t\tpq.take();\n\t\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// put the results in the array\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = pq.take();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] res = new long[N];\n\t\n\tauto pq = new PriorityQueue!(long)();\n\t\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\tpq.put(n1*n2);\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tres[i] = pq.get();\n\t}\n\t\n\treturn res;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto sorted1 = nums1.sort();\n\tauto sorted2 = nums2.sort();\n\t\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\t\n\twhile(k < N)\n\t{\n\t\tif(sorted1[i] * sorted2[j] > sorted1[i] * sorted2[j + 1])\n\t\t{\n\t\t\tresult[k] = sorted1[i] * sorted2[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[k] = sorted1[i] * sorted2[j + 1];\n\t\t\ti++;\n\t\t}\n\t\tk++;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i,n; nums1)\n\t{\n\t\tforeach(j,m; nums2)\n\t\t{\n\t\t\tresult ~= n*m;\n\t\t}\n\t}\n\t\n\tresult.sort;\n\tresult.reverse;\n\t\n\treturn result[0..N];\n}",
    "{\n\tauto s1 = nums1.sort(std.functional.reverse);\n\tauto s2 = nums2.sort(std.functional.reverse);\n\t\n\tlong[] result;\n\t\n\tforeach(i, num1; s1)\n\t{\n\t\tforeach(j, num2; s2)\n\t\t{\n\t\t\tresult ~= num1 * num2;\n\t\t}\n\t}\n\t\n\treturn result.sort(std.functional.reverse).take(N);\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = PriorityQueue!(tuple!(long, long, long), \"a > b\", \"a[2] > b[2]\");\n\tforeach(i, n1; nums1)\n\t{\n\t\tforeach(j, n2; nums2)\n\t\t{\n\t\t\tif(pq.length < N)\n\t\t\t{\n\t\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(n1 * n2 > pq.peek[2])\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(tuple(i, j, n1 * n2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] result = new long[N];\n\tforeach(i, t; pq)\n\t{\n\t\tresult[i] = t[2];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result;\n\tlong[] temp;\n\tlong temp_num;\n\tlong temp_num2;\n\tlong temp_num3;\n\tlong temp_num4;\n\tlong temp_num5;\n\tlong temp_num6;\n\tlong temp_num7;\n\tlong temp_num8;\n\tlong temp_num9;\n\tlong temp_num10;\n\tlong temp_num11;\n\tlong temp_num12;\n\tlong temp_num13;\n\tlong temp_num14;\n\tlong temp_num15;\n\tlong temp_num16;\n\tlong temp_num17;\n\tlong temp_num18;\n\tlong temp_num19;\n\tlong temp_num20;\n\tlong temp_num21;\n\tlong temp_num22;\n\tlong temp_num23;\n\tlong temp_num24;\n\tlong temp_num25;\n\tlong temp_num26;\n\tlong temp_num27;\n\tlong temp_num28;\n\tlong temp_num29;\n\tlong temp_num30;\n\tlong temp_num31;\n\tlong temp_num32;\n\tlong temp_num33;\n\tlong temp_num34;\n\tlong temp_num35;\n\tlong temp_num36;\n\tlong temp_num37;\n\tlong temp_num38;\n\tlong temp_num39;\n\tlong temp_num40;\n\tlong temp_num41;\n\tlong temp_num42;\n\tlong temp_num43;\n\tlong temp_num44;\n\tlong temp_num45;\n\tlong temp_num46;\n\tlong temp_num47;\n\tlong temp_num48;\n\tlong temp_num49;\n\tlong temp_num50;\n\tlong temp_num51;\n\tlong temp_num52;\n\tlong temp_num53;\n\tlong temp_num54;\n\tlong temp_num55;\n\tlong temp_num56;\n\tlong temp_num57;\n\tlong temp_num58;\n\tlong temp_num59;\n\tlong temp_num60;\n\tlong temp_num61;\n\tlong temp_num62;\n\tlong",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort(std.numeric.comparison);\n\tauto nums2_sorted = nums2.sort(std.numeric.comparison);\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted = nums1_sorted[0..$-1];\n\t\tnums2_sorted = nums2_sorted[0..$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif (nums1.length == 0 || nums2.length == 0)\n\t\treturn result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\", \"a\");\n\t\n\tforeach (i; 0 .. nums1.length)\n\t{\n\t\tforeach (j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tforeach (i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tlong[] nums1_sorted_rev = nums1_sorted.dup;\n\tlong[] nums2_sorted_rev = nums2_sorted.dup;\n\t\n\tnums1_sorted_rev.reverse;\n\tnums2_sorted_rev.reverse;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted_rev[i] * nums2_sorted_rev[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup;\n\tnums1_sorted.sort;\n\tauto nums2_sorted = nums2.dup;\n\tnums2_sorted.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto products = new long[](nums1.length * nums2.length);\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tproducts[i * nums2.length + j] = nums1[i] * nums2[j];\n\t\t}\n\t}\n\t\n\tproducts.sort!((a, b) => a > b);\n\t\n\treturn products[0 .. N];\n}",
    "{\n    long[] result = new long[N];\n    long[] nums1_sorted = nums1.dup;\n    long[] nums2_sorted = nums2.dup;\n    nums1_sorted.sort;\n    nums2_sorted.sort;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    while(k < N)\n    {\n        result[k] = nums1_sorted[i] * nums2_sorted[j];\n        if(i == nums1_sorted.length - 1)\n        {\n            j++;\n        }\n        else if(j == nums2_sorted.length - 1)\n        {\n            i++;\n        }\n        else if(nums1_sorted[i] * nums2_sorted[j + 1] > nums1_sorted[i + 1] * nums2_sorted[j])\n        {\n            j++;\n        }\n        else\n        {\n            i++;\n        }\n        k++;\n    }\n    return result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tlong[] result;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult ~= nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted = nums1_sorted[0..$-1];\n\t\tnums2_sorted = nums2_sorted[0..$-1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\t\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.sort();\n\tauto nums2_sorted = nums2.sort();\n\tauto result = new long[N];\n\t\n\tfor(long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1_sorted.length - 1] * nums2_sorted[nums2_sorted.length - 1];\n\t\tnums1_sorted.popBack();\n\t\tnums2_sorted.popBack();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto maxHeap = new MaxHeap!(tuple!(long, long, long));\n\t\n\tforeach(i, num1; nums1)\n\t{\n\t\tforeach(j, num2; nums2)\n\t\t{\n\t\t\tif(maxHeap.length < N)\n\t\t\t{\n\t\t\t\tmaxHeap.insert(tuple(num1 * num2, i, j));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(num1 * num2 > maxHeap.peek().front)\n\t\t\t\t{\n\t\t\t\t\tmaxHeap.pop();\n\t\t\t\t\tmaxHeap.insert(tuple(num1 * num2, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, t; maxHeap)\n\t{\n\t\tresult[i] = t.front;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// Sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t// Create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t// Add the first element to the queue\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// Add the rest of the elements\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tif(pq.size() < N)\n\t\t\t{\n\t\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(nums1[i] * nums2[j] > pq.peek())\n\t\t\t\t{\n\t\t\t\t\tpq.get();\n\t\t\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Copy the elements to the result array\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint k = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[k++] = n1 * n2;\n\t\t}\n\t}\n\tsort(temp);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - 1 - i];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t// sort nums1 and nums2 in descending order\n\tnums1.sort!((a, b) => b - a);\n\tnums2.sort!((a, b) => b - a);\n\t\n\t// create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, (a, b) => a > b);\n\t\n\t// insert the first product into the priority queue\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t// create a set to store the products that have been inserted into the priority queue\n\tauto set = new Set!(long);\n\tset.insert(nums1[0] * nums2[0]);\n\t\n\t// create a 2D array to store the indices of the factors of the products in the priority queue\n\tlong[][] indices = new long[][](N, 2);\n\tindices[0][0] = 0;\n\tindices[0][1] = 0;\n\t\n\t// create a 2D array to store the factors of the products in the priority queue\n\tlong[][] factors = new long[][](N, 2);\n\tfactors[0][0] = nums1[0];\n\tfactors[0][1] = nums2[0];\n\t\n\t// create a 2D array to store the next factors of the products in the priority queue\n\tlong[][] next_factors = new long[][](N, 2);\n\tnext_factors[0][0] = nums1[1];\n\tnext_factors[0][1] = nums2[0];\n\t\n\t// create a 2D array to store the next indices of the factors of the products in the priority queue\n\tlong[][] next_indices = new long[][](N, 2);\n\tnext_indices[0][0] = 1;\n\tnext_indices[0][1] = 0;\n\t\n\t// create a 2D array to store the previous factors of the products in the priority queue\n\tlong[][] prev_factors = new long[][](N, 2);",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0 .. nums1.length)\n\t\t{\n\t\t\tforeach(k; 0 .. nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\tnums1 = nums1.filter!(x => x != max / nums1[0]);\n\t\tnums2 = nums2.filter!(x => x != max / nums2[0]);\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tlong max = 0;\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = nums1[j] * nums2[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i] = max;\n\t\t\n\t\tforeach(j; 0..nums1.length)\n\t\t{\n\t\t\tforeach(k; 0..nums2.length)\n\t\t\t{\n\t\t\t\tif(nums1[j] * nums2[k] == max)\n\t\t\t\t{\n\t\t\t\t\tnums1[j] = 0;\n\t\t\t\t\tnums2[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto pq = new PriorityQueue!(long[])();\n\tforeach(i; 0..nums1.length)\n\t{\n\t\tforeach(j; 0..nums2.length)\n\t\t{\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t}\n\t}\n\t\n\tlong[] result = new long[N];\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = pq.get();\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] temp = new long[nums1.length * nums2.length];\n\tint index = 0;\n\tforeach(n1; nums1)\n\t{\n\t\tforeach(n2; nums2)\n\t\t{\n\t\t\ttemp[index++] = n1 * n2;\n\t\t}\n\t}\n\ttemp.sort;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tresult[i] = temp[temp.length - i - 1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup.sort;\n\tlong[] nums2_sorted = nums2.dup.sort;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] max_nums1 = new long[N];\n\tlong[] max_nums2 = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tmax_nums1[i] = max(nums1);\n\t\tmax_nums2[i] = max(nums2);\n\t\tresult[i] = max_nums1[i] * max_nums2[i];\n\t\tnums1.remove(max_nums1[i]);\n\t\tnums2.remove(max_nums2[i]);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tnums1.sort();\n\tnums2.sort();\n\t\n\tlong[] nums1_reverse = nums1.dup.reverse;\n\tlong[] nums2_reverse = nums2.dup.reverse;\n\t\n\tforeach(i; 0..N)\n\t{\n\t\tresult[i] = nums1_reverse[i] * nums2_reverse[i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tauto nums1_sorted = nums1.dup.sort;\n\tauto nums2_sorted = nums2.dup.sort;\n\t\n\tauto result = new long[N];\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tresult[i] = nums1_sorted[$ - 1] * nums2_sorted[$ - 1];\n\t\tnums1_sorted = nums1_sorted[0 .. $ - 1];\n\t\tnums2_sorted = nums2_sorted[0 .. $ - 1];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t//sort the arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t//create a priority queue\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t//add the first element of each array to the queue\n\tpq.put(nums1[0] * nums2[0]);\n\t\n\t//create a tuple of the indices of the elements in the queue\n\tauto indices = tuple(0, 0);\n\t\n\t//create a set to keep track of the indices that have been used\n\tauto used = new Set!(tuple(long, long));\n\t\n\t//add the first tuple to the set\n\tused.insert(indices);\n\t\n\t//loop through the number of elements we want to find\n\tforeach(i; 0 .. N)\n\t{\n\t\t//get the largest element from the queue\n\t\tresult[i] = pq.get();\n\t\t\n\t\t//get the indices of the largest element\n\t\tindices = used.popFront();\n\t\t\n\t\t//if the first index is less than the length of the first array\n\t\tif(indices[0] < nums1.length - 1)\n\t\t{\n\t\t\t//add the next element in the first array to the queue\n\t\t\tpq.put(nums1[indices[0] + 1] * nums2[indices[1]]);\n\t\t\t\n\t\t\t//add the new tuple to the set\n\t\t\tused.insert(tuple(indices[0] + 1, indices[1]));\n\t\t}\n\t\t\n\t\t//if the second index is less than the length of the second array\n\t\tif(indices[1] < nums2.length - 1)\n\t\t{\n\t\t\t//add the next element in the second array to the queue\n\t\t\tpq.put(nums1[indices[0]] * nums2[indices[1] + 1]);\n\t\t\t\n\t\t\t//add the new tuple to the set\n\t\t\tused.insert(tuple(",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.dup;\n\tlong[] nums2_sorted = nums2.dup;\n\tnums1_sorted.sort;\n\tnums2_sorted.sort;\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[$-1] * nums2_sorted[$-1];\n\t\tnums1_sorted.popBack;\n\t\tnums2_sorted.popBack;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tif(nums1.length == 0 || nums2.length == 0) return result;\n\t\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\tforeach(i; 0 .. nums1.length)\n\t\tforeach(j; 0 .. nums2.length)\n\t\t\tpq.put(nums1[i] * nums2[j]);\n\t\t\t\n\tforeach(i; 0 .. N)\n\t\tresult[i] = pq.get();\n\t\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\tlong[] nums1_sorted = nums1.sort(std.numeric.comparison);\n\tlong[] nums2_sorted = nums2.sort(std.numeric.comparison);\n\t\n\tfor (long i = 0; i < N; i++)\n\t{\n\t\tresult[i] = nums1_sorted[nums1.length - 1 - i] * nums2_sorted[nums2.length - 1 - i];\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\tauto pq = new PriorityQueue!(a => a[0], Tuple!(long, long, long)[], Tuple!(long, long, long)[](nums1.length * nums2.length));\n\t\n\tforeach(i; 0 .. nums1.length)\n\t{\n\t\tforeach(j; 0 .. nums2.length)\n\t\t{\n\t\t\tpq.put(tuple(nums1[i] * nums2[j], i, j));\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. N)\n\t{\n\t\tauto t = pq.get();\n\t\tresult[i] = t[0];\n\t\t\n\t\tif(t[1] < nums1.length - 1)\n\t\t{\n\t\t\tpq.put(tuple(nums1[t[1] + 1] * nums2[t[2]], t[1] + 1, t[2]));\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[N];\n\t\n\t//sort the two arrays\n\tnums1.sort();\n\tnums2.sort();\n\t\n\t//create a tuple of the two arrays\n\tauto tuple = tuple(nums1, nums2);\n\t\n\t//create a priority queue to store the products\n\tauto pq = new PriorityQueue!(long, \"a > b\");\n\t\n\t//create a set to store the products\n\tauto set = new Set!(long);\n\t\n\t//iterate through the tuple\n\tforeach(i, num1; tuple[0])\n\t{\n\t\tforeach(j, num2; tuple[1])\n\t\t{\n\t\t\t//calculate the product\n\t\t\tlong product = num1 * num2;\n\t\t\t\n\t\t\t//check if the product is in the set\n\t\t\tif(!set.contains(product))\n\t\t\t{\n\t\t\t\t//add the product to the set\n\t\t\t\tset.insert(product);\n\t\t\t\t\n\t\t\t\t//add the product to the priority queue\n\t\t\t\tpq.put(product);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//iterate through the priority queue\n\tforeach(i, product; pq)\n\t{\n\t\t//add the product to the result array\n\t\tresult[i] = product;\n\t}\n\t\n\treturn result;\n}"
  ]
}