{
  "name": "mbpp_468_max_product",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\t\n*/\nlong max_product(long[] arr) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = max_product;\n\n    assert(candidate([3L, 100L, 4L, 5L, 150L, 6L]) == 3000L);\n    assert(candidate([4L, 42L, 55L, 68L, 80L]) == 50265600L);\n    assert(candidate([10L, 22L, 9L, 33L, 21L, 50L, 41L, 60L]) == 2460L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong max_product = 1;\n\tlong curr_product = 1;\n\tlong max_num = 0;\n\tforeach(num; arr)\n\t{\n\t\tif(num > max_num)\n\t\t{\n\t\t\tmax_num = num;\n\t\t\tcurr_product *= num;\n\t\t\tmax_product = max(max_product, curr_product);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr_product = 1;\n\t\t}\n\t}\n\treturn max_product;\n}",
    "{\n\tlong max_product = 1;\n\tlong[] max_products = new long[arr.length];\n\tfor (int i = 0; i < arr.length; i++) \n\t{\n\t\tmax_products[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[j] < arr[i]) \n\t\t\t{\n\t\t\t\tmax_products[i] = max(max_products[i], max_products[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, max_products[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong[] max_product = new long[arr.length];\n\tlong[] max_product_index = new long[arr.length];\n\tlong[] max_product_index_reverse = new long[arr.length];\n\tlong[] max_product_reverse = new long[arr.length];\n\t\n\tmax_product[0] = arr[0];\n\tmax_product_index[0] = 0;\n\tmax_product_index_reverse[arr.length-1] = arr.length-1;\n\tmax_product_reverse[arr.length-1] = arr[arr.length-1];\n\t\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tmax_product[i] = arr[i];\n\t\tmax_product_index[i] = i;\n\t\t\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[j] < arr[i]) \n\t\t\t{\n\t\t\t\tif (max_product[i] < max_product[j] * arr[i]) \n\t\t\t\t{\n\t\t\t\t\tmax_product[i] = max_product[j] * arr[i];\n\t\t\t\t\tmax_product_index[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = arr.length-2; i >= 0; i--) \n\t{\n\t\tmax_product_reverse[i] = arr[i];\n\t\tmax_product_index_reverse[i] = i;\n\t\t\n\t\tfor (int j = arr.length-1; j > i; j--) \n\t\t{\n\t\t\tif (arr[j] < arr[i]) \n\t\t\t{\n\t\t\t\tif (max_product_reverse[i] < max_product_reverse[j] * arr[i]) \n\t\t\t\t{\n\t\t\t\t\tmax_product_reverse[i] = max_product_reverse[j] * arr[i];\n\t\t\t\t\tmax_product",
    "{\n\tlong[] max_product = new long[arr.length];\n\tmax_product[0] = arr[0];\n\tlong max = max_product[0];\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tmax_product[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[j] < arr[i]) \n\t\t\t{\n\t\t\t\tmax_product[i] = max(max_product[i], max_product[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax = max(max, max_product[i]);\n\t}\n\treturn max;\n}",
    "{\n\tlong max = 0;\n\tlong product = 1;\n\tforeach(i; arr)\n\t{\n\t\tproduct *= i;\n\t\tif(product > max)\n\t\t\tmax = product;\n\t}\n\treturn max;\n}",
    "{\n\tlong max_product = 1;\n\tlong[] max_products = new long[arr.length];\n\t\n\tfor (int i = 0; i < arr.length; i++)\n\t{\n\t\tmax_products[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (arr[i] > arr[j])\n\t\t\t{\n\t\t\t\tmax_products[i] = max(max_products[i], max_products[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, max_products[i]);\n\t}\n\t\n\treturn max_product;\n}",
    "{\n\tlong[] max_product = new long[arr.length];\n\tmax_product[0] = arr[0];\n\tlong max = max_product[0];\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tmax_product[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[i] > arr[j]) \n\t\t\t{\n\t\t\t\tmax_product[i] = max(max_product[i], max_product[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax = max(max, max_product[i]);\n\t}\n\treturn max;\n}",
    "{\n\tlong max_product = 1;\n\tlong current_product = 1;\n\tlong current_max = arr[0];\n\tlong current_min = arr[0];\n\t\n\tfor(int i = 1; i < arr.length; i++)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tcurrent_max = max(current_max * arr[i], arr[i]);\n\t\t\tcurrent_min = min(current_min * arr[i], arr[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong temp = current_max;\n\t\t\tcurrent_max = max(current_min * arr[i], arr[i]);\n\t\t\tcurrent_min = min(temp * arr[i], arr[i]);\n\t\t}\n\t\t\n\t\tmax_product = max(max_product, current_max);\n\t}\n\t\n\treturn max_product;\n}",
    "{\n\tlong max_product = 1;\n\tlong[] max_product_arr = new long[arr.length];\n\tfor (int i = 0; i < arr.length; i++)\n\t{\n\t\tmax_product_arr[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (arr[j] < arr[i])\n\t\t\t{\n\t\t\t\tmax_product_arr[i] = max(max_product_arr[i], max_product_arr[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, max_product_arr[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong[] max_prod = new long[arr.length];\n\tlong[] min_prod = new long[arr.length];\n\t\n\tmax_prod[0] = arr[0];\n\tmin_prod[0] = arr[0];\n\t\n\tlong max_product = arr[0];\n\t\n\tfor (int i = 1; i < arr.length; i++)\n\t{\n\t\tmax_prod[i] = max(arr[i], max(arr[i] * max_prod[i - 1], arr[i] * min_prod[i - 1]));\n\t\tmin_prod[i] = min(arr[i], min(arr[i] * max_prod[i - 1], arr[i] * min_prod[i - 1]));\n\t\t\n\t\tmax_product = max(max_product, max_prod[i]);\n\t}\n\t\n\treturn max_product;\n}",
    "{\n\tlong[] max = new long[arr.length];\n\tlong[] min = new long[arr.length];\n\tlong[] res = new long[arr.length];\n\tmax[0] = arr[0];\n\tmin[0] = arr[0];\n\tres[0] = arr[0];\n\tfor(int i = 1; i < arr.length; i++)\n\t{\n\t\tmax[i] = max(arr[i], max(arr[i] * max[i-1], arr[i] * min[i-1]));\n\t\tmin[i] = min(arr[i], min(arr[i] * max[i-1], arr[i] * min[i-1]));\n\t\tres[i] = max(res[i-1], max[i]);\n\t}\n\treturn res[arr.length-1];\n}",
    "{\n\tlong[] max_product = new long[arr.length];\n\tlong[] max_product_index = new long[arr.length];\n\tlong[] max_product_prev_index = new long[arr.length];\n\t\n\tmax_product[0] = arr[0];\n\tmax_product_index[0] = 0;\n\tmax_product_prev_index[0] = -1;\n\t\n\tfor (int i = 1; i < arr.length; i++)\n\t{\n\t\tmax_product[i] = arr[i];\n\t\tmax_product_index[i] = i;\n\t\tmax_product_prev_index[i] = -1;\n\t\t\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (arr[i] > arr[j] && max_product[i] < max_product[j] * arr[i])\n\t\t\t{\n\t\t\t\tmax_product[i] = max_product[j] * arr[i];\n\t\t\t\tmax_product_index[i] = i;\n\t\t\t\tmax_product_prev_index[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong max = max_product[0];\n\tlong max_index = 0;\n\tfor (int i = 1; i < arr.length; i++)\n\t{\n\t\tif (max < max_product[i])\n\t\t{\n\t\t\tmax = max_product[i];\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\t\n\treturn max;\n}",
    "{\n\tlong max_product = 0;\n\tlong[] products = new long[arr.length];\n\tproducts[0] = arr[0];\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tlong max_product_so_far = 0;\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[i] > arr[j]) \n\t\t\t{\n\t\t\t\tmax_product_so_far = max(max_product_so_far, products[j]);\n\t\t\t}\n\t\t}\n\t\tproducts[i] = max_product_so_far * arr[i];\n\t\tmax_product = max(max_product, products[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong max_product = 1;\n\tlong[] dp = new long[arr.length];\n\tdp[0] = arr[0];\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tdp[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[i] > arr[j]) \n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i], dp[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, dp[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong max = 0;\n\tlong[] dp = new long[arr.length];\n\tdp[0] = arr[0];\n\tfor (int i = 1; i < arr.length; i++)\n\t{\n\t\tdp[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (arr[i] > arr[j])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i], dp[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax = max(max, dp[i]);\n\t}\n\treturn max;\n}",
    "{\n\tlong max_product = 0;\n\tlong[] max_product_arr = new long[arr.length];\n\tmax_product_arr[0] = arr[0];\n\tfor(int i = 1; i < arr.length; i++)\n\t{\n\t\tmax_product_arr[i] = arr[i];\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(arr[i] > arr[j])\n\t\t\t{\n\t\t\t\tmax_product_arr[i] = max(max_product_arr[i], max_product_arr[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, max_product_arr[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong max_product = 0;\n\tlong max_so_far = 0;\n\tlong min_so_far = 0;\n\tlong max_ending_here = 0;\n\tlong min_ending_here = 0;\n\t\n\tforeach(i; arr)\n\t{\n\t\tmax_ending_here = max(i, max(i * max_so_far, i * min_so_far));\n\t\tmin_ending_here = min(i, min(i * max_so_far, i * min_so_far));\n\t\t\n\t\tmax_so_far = max_ending_here;\n\t\tmin_so_far = min_ending_here;\n\t\t\n\t\tmax_product = max(max_product, max_so_far);\n\t}\n\t\n\treturn max_product;\n}",
    "{\n\tlong max_product = 1;\n\tlong[] products = new long[arr.length];\n\t\n\tfor(int i = 0; i < arr.length; i++)\n\t{\n\t\tproducts[i] = arr[i];\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(arr[j] < arr[i])\n\t\t\t{\n\t\t\t\tproducts[i] = max(products[i], products[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax_product = max(max_product, products[i]);\n\t}\n\treturn max_product;\n}",
    "{\n\tlong max = 0;\n\tlong[] dp = new long[arr.length];\n\tfor (int i = 0; i < arr.length; i++) \n\t{\n\t\tdp[i] = arr[i];\n\t\tfor (int j = 0; j < i; j++) \n\t\t{\n\t\t\tif (arr[i] > arr[j]) \n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i], dp[j] * arr[i]);\n\t\t\t}\n\t\t}\n\t\tmax = max(max, dp[i]);\n\t}\n\treturn max;\n}",
    "{\n\tlong max_product = 1;\n\tlong max_product_so_far = 1;\n\tforeach(i; arr)\n\t{\n\t\tmax_product_so_far = max(max_product_so_far * i, i);\n\t\tmax_product = max(max_product, max_product_so_far);\n\t}\n\treturn max_product;\n}"
  ]
}