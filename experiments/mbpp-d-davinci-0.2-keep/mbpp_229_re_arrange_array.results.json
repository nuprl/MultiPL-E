{
  "name": "mbpp_229_re_arrange_array",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; negative_count .. n)\n\t{\n\t\tresult[i] = positive[i - negative_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd4jz67tc.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpd4jz67tc.__unittest_L42_C1() [0x4281e8]\n??:? void tmpd4jz67tc.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] result2 = new long[n];\n\tlong[] result3 = new long[n];\n\tlong[] result4 = new long[n];\n\tlong[] result5 = new long[n];\n\tlong[] result6 = new long[n];\n\tlong[] result7 = new long[n];\n\tlong[] result8 = new long[n];\n\tlong[] result9 = new long[n];\n\tlong[] result10 = new long[n];\n\tlong[] result11 = new long[n];\n\tlong[] result12 = new long[n];\n\tlong[] result13 = new long[n];\n\tlong[] result14 = new long[n];\n\tlong[] result15 = new long[n];\n\tlong[] result16 = new long[n];\n\tlong[] result17 = new long[n];\n\tlong[] result18 = new long[n];\n\tlong[] result19 = new long[n];\n\tlong[] result20 = new long[n];\n\tlong[] result21 = new long[n];\n\tlong[] result22 = new long[n];\n\tlong[] result23 = new long[n];\n\tlong[] result24 = new long[n];\n\tlong[] result25 = new long[n];\n\tlong[] result26 = new long[n];\n\tlong[] result27 = new long[n];\n\tlong[] result28 = new long[n];\n\tlong[] result29 = new long[n];\n\tlong[] result30 = new long[n];\n\tlong[] result31 = new long[n];\n\tlong[] result32 = new long[n];\n\tlong[] result33 = new long[n];\n\tlong[] result34 = new long[n];\n\tlong[] result35 = new long[n];\n\tlong[] result36 = new long[n];\n\tlong[] result37 = new long[n];\n\tlong[] result38 = new long[n];\n\tlong[] result39 = new long[n];\n\tlong[] result40 = new long[n];\n\tlong[] result41 = new long[n];\n\tlong[] result42 = new long[n];\n\tlong[] result43 =\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmpnwnvjncm.d(53): Error: expression expected, not `unittest`\n/tmp/tmpnwnvjncm.d(54): Error: semicolon expected, not `{`\n/tmp/tmpnwnvjncm.d(61): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnwnvjncm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] temp = new long[n];\n\tlong[] result = new long[n];\n\tlong[] result2 = new long[n];\n\tlong[] result3 = new long[n];\n\tlong[] result4 = new long[n];\n\tlong[] result5 = new long[n];\n\tlong[] result6 = new long[n];\n\tlong[] result7 = new long[n];\n\tlong[] result8 = new long[n];\n\tlong[] result9 = new long[n];\n\tlong[] result10 = new long[n];\n\tlong[] result11 = new long[n];\n\tlong[] result12 = new long[n];\n\tlong[] result13 = new long[n];\n\tlong[] result14 = new long[n];\n\tlong[] result15 = new long[n];\n\tlong[] result16 = new long[n];\n\tlong[] result17 = new long[n];\n\tlong[] result18 = new long[n];\n\tlong[] result19 = new long[n];\n\tlong[] result20 = new long[n];\n\tlong[] result21 = new long[n];\n\tlong[] result22 = new long[n];\n\tlong[] result23 = new long[n];\n\tlong[] result24 = new long[n];\n\tlong[] result25 = new long[n];\n\tlong[] result26 = new long[n];\n\tlong[] result27 = new long[n];\n\tlong[] result28 = new long[n];\n\tlong[] result29 = new long[n];\n\tlong[] result30 = new long[n];\n\tlong[] result31 = new long[n];\n\tlong[] result32 = new long[n];\n\tlong[] result33 = new long[n];\n\tlong[] result34 = new long[n];\n\tlong[] result35 = new long[n];\n\tlong[] result36 = new long[n];\n\tlong[] result37 = new long[n];\n\tlong[] result38 = new long[n];\n\tlong[] result39 = new long[n];\n\tlong[] result40 = new long[n];\n\tlong[] result41 = new long[n];\n\tlong[] result42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp8sf6hu8h.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp8sf6hu8h.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp8sf6hu8h.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8sf6hu8h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count+i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5wnli1nk.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp5wnli1nk.__unittest_L38_C1() [0x4281ec]\n??:? void tmp5wnli1nk.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt4vcllgw.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpt4vcllgw.__unittest_L42_C1() [0x4281ec]\n??:? void tmpt4vcllgw.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{ \n    long[] temp = new long[n]; \n    long j = 0; \n  \n    // Traverse the array and store positive elements in temp \n    for (long i = 0; i < n; i++) { \n        if (arr[i] < 0) { \n            temp[j] = arr[i]; \n            j++; \n        } \n    } \n  \n    // Traverse the array and store negative elements in temp \n    for (long i = 0; i < n; i++) { \n        if (arr[i] >= 0) { \n            temp[j] = arr[i]; \n            j++; \n        } \n    } \n  \n    // Copy contents of temp[] to arr[] \n    for (long i = 0; i < n; i++) \n        arr[i] = temp[i]; \n  \n    return arr; \n} \nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp44h83ftx.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4285dd]\n??:? void tmp44h83ftx.__unittest_L35_C1() [0x428104]\n??:? void tmp44h83ftx.__modtest() [0x428360]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c697]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b52a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430741]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b501]\n??:? runModuleUnitTests [0x42c46d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428aa0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6ep1e9ex.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp6ep1e9ex.__unittest_L41_C1() [0x4281ec]\n??:? void tmp6ep1e9ex.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < k; i++)\n\t{\n\t\tresult[j] = temp[i];\n\t\tj++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpokavveln.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4285b5]\n??:? void tmpokavveln.__unittest_L37_C1() [0x4280d8]\n??:? void tmpokavveln.__modtest() [0x428334]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c66f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b502]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]\n??:? runModuleUnitTests [0x42c445]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[i + neg_index] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7t6lz7rr.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp7t6lz7rr.__unittest_L38_C1() [0x428168]\n??:? void tmp7t6lz7rr.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxdvhn_bi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxdvhn_bi.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxdvhn_bi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_count = 0;\n\tlong positive_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpalqrqfzy.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpalqrqfzy.__unittest_L42_C1() [0x4281ec]\n??:? void tmpalqrqfzy.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkppqj__q.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpkppqj__q.__unittest_L41_C1() [0x4281ec]\n??:? void tmpkppqj__q.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6uby_b3w.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp6uby_b3w.__unittest_L38_C1() [0x4281ec]\n??:? void tmp6uby_b3w.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(long i; 0 .. neg_index)\n\t{\n\t\tres[index] = neg[i];\n\t\tindex++;\n\t}\n\tforeach(long i; 0 .. pos_index)\n\t{\n\t\tres[index] = pos[i];\n\t\tindex++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppwb9awas.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmppwb9awas.__unittest_L41_C1() [0x4281f4]\n??:? void tmppwb9awas.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; negative_index..n)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfm1h9zxo.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpfm1h9zxo.__unittest_L42_C1() [0x4281e8]\n??:? void tmpfm1h9zxo.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] res = new long[n];\n    long[] neg = new long[n];\n    long[] pos = new long[n];\n    long neg_count = 0;\n    long pos_count = 0;\n    foreach(i; 0..n)\n    {\n        if(arr[i] < 0)\n        {\n            neg[neg_count] = arr[i];\n            neg_count++;\n        }\n        else\n        {\n            pos[pos_count] = arr[i];\n            pos_count++;\n        }\n    }\n    foreach(i; 0..neg_count)\n    {\n        res[i] = neg[i];\n    }\n    foreach(i; 0..pos_count)\n    {\n        res[neg_count + i] = pos[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1fzw_3pj.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp1fzw_3pj.__unittest_L38_C1() [0x4281ec]\n??:? void tmp1fzw_3pj.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzgnqhm2q.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpzgnqhm2q.__unittest_L42_C1() [0x4281f4]\n??:? void tmpzgnqhm2q.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(long i = 0; i < k; i++)\n\t{\n\t\tresult[j] = temp[i];\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxar9fnzi.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285b5]\n??:? void tmpxar9fnzi.__unittest_L34_C1() [0x4280d8]\n??:? void tmpxar9fnzi.__modtest() [0x428334]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c66f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b502]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]\n??:? runModuleUnitTests [0x42c445]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu979agzp.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpu979agzp.__unittest_L41_C1() [0x4281ec]\n??:? void tmpu979agzp.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptpq_gf3n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptpq_gf3n.__unittest_L38_C1() [0x4281ec]\n??:? void tmptpq_gf3n.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp06afe7qu.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp06afe7qu.__unittest_L42_C1() [0x428168]\n??:? void tmp06afe7qu.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzgnqhm2q.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpzgnqhm2q.__unittest_L42_C1() [0x4281f4]\n??:? void tmpzgnqhm2q.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_0qoq5lw.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp_0qoq5lw.__unittest_L41_C1() [0x4281f4]\n??:? void tmp_0qoq5lw.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmposo74204.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmposo74204.__unittest_L41_C1() [0x4281f4]\n??:? void tmposo74204.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptpq_gf3n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptpq_gf3n.__unittest_L38_C1() [0x4281ec]\n??:? void tmptpq_gf3n.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\ttemp[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tresult[j] = temp[i];\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpagsu2hpa.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285b5]\n??:? void tmpagsu2hpa.__unittest_L34_C1() [0x4280d8]\n??:? void tmpagsu2hpa.__modtest() [0x428334]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c66f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b502]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]\n??:? runModuleUnitTests [0x42c445]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp06afe7qu.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp06afe7qu.__unittest_L42_C1() [0x428168]\n??:? void tmp06afe7qu.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5h65_w36.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp5h65_w36.__unittest_L42_C1() [0x4281ec]\n??:? void tmp5h65_w36.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\ttemp2[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (long i = 0; i < j; i++) \n\t{\n\t\tresult[i] = temp[i];\n\t}\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tresult[j + i] = temp2[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxv7dgiiw.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpxv7dgiiw.__unittest_L38_C1() [0x428168]\n??:? void tmpxv7dgiiw.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong[] neg_pos = neg ~ pos;\n\tforeach(long i; 0..n)\n\t{\n\t\tres[i] = neg_pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdtorv65t.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42865d]\n??:? void tmpdtorv65t.__unittest_L35_C1() [0x428184]\n??:? void tmpdtorv65t.__modtest() [0x4283e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c85f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430835]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6c9]\n??:? runModuleUnitTests [0x42c635]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jon6yav.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8jon6yav.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8jon6yav.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] result = new long[n];\n    long[] positive = new long[n];\n    long[] negative = new long[n];\n    long positive_index = 0;\n    long negative_index = 0;\n    foreach(elem; arr)\n    {\n        if(elem < 0)\n        {\n            negative[negative_index] = elem;\n            negative_index++;\n        }\n        else\n        {\n            positive[positive_index] = elem;\n            positive_index++;\n        }\n    }\n    long index = 0;\n    foreach(elem; negative)\n    {\n        result[index] = elem;\n        index++;\n    }\n    foreach(elem; positive)\n    {\n        result[index] = elem;\n        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpoyxw_1lm.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42870e]\n??:? long[] tmpoyxw_1lm.re_arrange_array(long[], long) [0x428034]\n??:? void tmpoyxw_1lm.__unittest_L41_C1() [0x4280ef]\n??:? void tmpoyxw_1lm.__modtest() [0x4283e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c717]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430835]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b581]\n??:? runModuleUnitTests [0x42c4ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) in",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong i = 0, j = n - 1;\n\tforeach(x; arr)\n\t{\n\t\tif(x < 0)\n\t\t{\n\t\t\tresult[i] = x;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[j] = x;\n\t\t\tj--;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt0ws5kns.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x4284f5]\n??:? void tmpt0ws5kns.__unittest_L27_C1() [0x428018]\n??:? void tmpt0ws5kns.__modtest() [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b442]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430659]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]\n??:? runModuleUnitTests [0x42c385]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[count] = neg[i];\n\t\tcount++;\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[count] = pos[i];\n\t\tcount++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcvz1ev75.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpcvz1ev75.__unittest_L41_C1() [0x4281f4]\n??:? void tmpcvz1ev75.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxdvhn_bi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxdvhn_bi.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxdvhn_bi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = neg_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - neg_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmoheq40g.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpmoheq40g.__unittest_L42_C1() [0x428168]\n??:? void tmpmoheq40g.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptpq_gf3n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptpq_gf3n.__unittest_L38_C1() [0x4281ec]\n??:? void tmptpq_gf3n.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[i + neg_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp46suqgu1.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp46suqgu1.__unittest_L42_C1() [0x4281f4]\n??:? void tmp46suqgu1.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5a3hrxr1.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp5a3hrxr1.__unittest_L38_C1() [0x4281ec]\n??:? void tmp5a3hrxr1.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; negative_index..n)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfm1h9zxo.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpfm1h9zxo.__unittest_L42_C1() [0x4281e8]\n??:? void tmpfm1h9zxo.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = neg_count; i < neg_count + pos_count; i++)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6umaml1x.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp6umaml1x.__unittest_L38_C1() [0x42816c]\n??:? void tmp6umaml1x.__modtest() [0x4283c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong zero_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..zero_index)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmnc8jnw8.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpmnc8jnw8.__unittest_L53_C1() [0x42836c]\n??:? void tmpmnc8jnw8.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfo5vm0ev.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpfo5vm0ev.__unittest_L41_C1() [0x428168]\n??:? void tmpfo5vm0ev.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_cnt = 0;\n\tlong neg_cnt = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_cnt] = arr[i];\n\t\t\tneg_cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_cnt] = arr[i];\n\t\t\tpos_cnt++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_cnt)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_cnt)\n\t{\n\t\tres[neg_cnt + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjng4ml46.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpjng4ml46.__unittest_L42_C1() [0x4281ec]\n??:? void tmpjng4ml46.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] negative = new long[arr.length];\n\tlong[] positive = new long[arr.length];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8loeroes.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8loeroes.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8loeroes.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "/tmp/tmpdszf18hv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmpdszf18hv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmpdszf18hv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdszf18hv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] positive = new long[arr.length];\n\tlong[] negative = new long[arr.length];\n\tlong[] zero = new long[arr.length];\n\tlong[] temp = new long[arr.length];\n\tlong[] temp2 = new long[arr.length];\n\tlong[] temp3 = new long[arr.length];\n\tlong[] temp4 = new long[arr.length];\n\tlong[] temp5 = new long[arr.length];\n\tlong[] temp6 = new long[arr.length];\n\tlong[] temp7 = new long[arr.length];\n\tlong[] temp8 = new long[arr.length];\n\tlong[] temp9 = new long[arr.length];\n\tlong[] temp10 = new long[arr.length];\n\tlong[] temp11 = new long[arr.length];\n\tlong[] temp12 = new long[arr.length];\n\tlong[] temp13 = new long[arr.length];\n\tlong[] temp14 = new long[arr.length];\n\tlong[] temp15 = new long[arr.length];\n\tlong[] temp16 = new long[arr.length];\n\tlong[] temp17 = new long[arr.length];\n\tlong[] temp18 = new long[arr.length];\n\tlong[] temp19 = new long[arr.length];\n\tlong[] temp20 = new long[arr.length];\n\tlong[] temp21 = new long[arr.length];\n\tlong[] temp22 = new long[arr.length];\n\tlong[] temp23 = new long[arr.length];\n\tlong[] temp24 = new long[arr.length];\n\tlong[] temp25 = new long[arr.length];\n\tlong[] temp26 = new long[arr.length];\n\tlong[] temp27 = new long[arr.length];\n\tlong[] temp28 = new long[arr.length];\n\tlong[] temp29 = new long[arr.length];\n\tlong[] temp30 = new long[arr.length];\n\tlong[] temp31 = new long[arr.length];\n\tlong[] temp32 = new long[arr.length];\n\tlong[] temp33 = new long[arr\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "/tmp/tmptsiz8p0x.d(47): Error: found `unittest` when expecting `]`\n/tmp/tmptsiz8p0x.d(48): Error: semicolon expected, not `{`\n/tmp/tmptsiz8p0x.d(55): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptsiz8p0x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_count = 0;\n\tlong positive_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = 0; i < positive_count; i++) \n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp09qa9of5.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp09qa9of5.__unittest_L38_C1() [0x428168]\n??:? void tmp09qa9of5.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[i+neg_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpucmowi0q.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpucmowi0q.__unittest_L42_C1() [0x4281f4]\n??:? void tmpucmowi0q.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[i+neg_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmhn6ffo2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpmhn6ffo2.__unittest_L42_C1() [0x4281f4]\n??:? void tmpmhn6ffo2.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0s8pramj.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp0s8pramj.__unittest_L41_C1() [0x428168]\n??:? void tmp0s8pramj.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tauto result = arr[0 .. n];\n\tlong i = 0;\n\tlong j = n - 1;\n\twhile (i < j)\n\t{\n\t\twhile (i < j && result[i] < 0)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\twhile (i < j && result[j] >= 0)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j)\n\t\t{\n\t\t\tauto temp = result[i];\n\t\t\tresult[i] = result[j];\n\t\t\tresult[j] = temp;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuw5mg_kc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42857d]\n??:? void tmpuw5mg_kc.__unittest_L32_C1() [0x4280a0]\n??:? void tmpuw5mg_kc.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b46e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430601]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ab0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43058d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b445]\n??:? runModuleUnitTests [0x42c3b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[count] = neg[i];\n\t\tcount++;\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[count] = pos[i];\n\t\tcount++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk93tq20d.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpk93tq20d.__unittest_L41_C1() [0x4281f4]\n??:? void tmpk93tq20d.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_count; i++) \n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_count; i++) \n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzir66uvh.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpzir66uvh.__unittest_L38_C1() [0x428168]\n??:? void tmpzir66uvh.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] res = new long[arr.length];\n    long[] neg = new long[arr.length];\n    long[] pos = new long[arr.length];\n    long neg_count = 0;\n    long pos_count = 0;\n    foreach(long i; 0..n)\n    {\n        if(arr[i] < 0)\n        {\n            neg[neg_count] = arr[i];\n            neg_count++;\n        }\n        else\n        {\n            pos[pos_count] = arr[i];\n            pos_count++;\n        }\n    }\n    foreach(long i; 0..neg_count)\n    {\n        res[i] = neg[i];\n    }\n    foreach(long i; 0..pos_count)\n    {\n        res[neg_count+i] = pos[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz0pkiv9m.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpz0pkiv9m.__unittest_L38_C1() [0x4281ec]\n??:? void tmpz0pkiv9m.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tlong zero_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] > 0) \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t} \n\t\telse if (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < zero_index; i++) \n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk9rhzeoa.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmpk9rhzeoa.__unittest_L53_C1() [0x4282b8]\n??:? void tmpk9rhzeoa.__modtest() [0x428514]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c84f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43096d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c625]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu1vua4xf.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpu1vua4xf.__unittest_L42_C1() [0x4281ec]\n??:? void tmpu1vua4xf.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(long i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbd6xckgh.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpbd6xckgh.__unittest_L38_C1() [0x4281ec]\n??:? void tmpbd6xckgh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(long i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_k0ubo_9.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp_k0ubo_9.__unittest_L42_C1() [0x4281ec]\n??:? void tmp_k0ubo_9.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeq126ujc.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpeq126ujc.__unittest_L42_C1() [0x428168]\n??:? void tmpeq126ujc.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; neg_count..n)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpis90_ko2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpis90_ko2.__unittest_L42_C1() [0x4281e8]\n??:? void tmpis90_ko2.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxdvhn_bi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxdvhn_bi.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxdvhn_bi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong zero_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_count] = arr[i];\n\t\t\tzero_count++;\n\t\t}\n\t}\n\t\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[count] = negative[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..zero_count)\n\t{\n\t\tresult[count] = zero[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[count] = positive[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0tiu5hb.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpi0tiu5hb.__unittest_L58_C1() [0x42836c]\n??:? void tmpi0tiu5hb.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor(long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpietfyld5.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpietfyld5.__unittest_L38_C1() [0x428168]\n??:? void tmpietfyld5.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong j = 0;\n\tlong k = n - 1;\n\tforeach (i; 0 .. n)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tres[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres[k] = arr[i];\n\t\t\tk--;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeqmz_3nd.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428545]\n??:? void tmpeqmz_3nd.__unittest_L28_C1() [0x42806c]\n??:? void tmpeqmz_3nd.__modtest() [0x4282c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b492]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43071d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bcc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b469]\n??:? runModuleUnitTests [0x42c3d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; negative_index .. positive_index + negative_index)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\tforeach(i; positive_index + negative_index .. positive_index + negative_index + zero_index)\n\t{\n\t\tresult[i] = zero[i - positive_index - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6c5itxr9.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42885d]\n??:? void tmp6c5itxr9.__unittest_L54_C1() [0x428384]\n??:? void tmp6c5itxr9.__modtest() [0x4285e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c917]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ee4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b781]\n??:? runModuleUnitTests [0x42c6ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdc8w2isi.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpdc8w2isi.__unittest_L41_C1() [0x4281f4]\n??:? void tmpdc8w2isi.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptb07tjzg.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptb07tjzg.__unittest_L38_C1() [0x4281ec]\n??:? void tmptb07tjzg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\t\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\tlong l = 0;\n\t\n\tforeach(long x; arr)\n\t{\n\t\tif(x < 0)\n\t\t{\n\t\t\ttemp[i] = x;\n\t\t\ti++;\n\t\t}\n\t\telse if(x == 0)\n\t\t{\n\t\t\ttemp2[j] = x;\n\t\t\tj++;\n\t\t}\n\t\telse if(x > 0)\n\t\t{\n\t\t\ttemp3[k] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tforeach(long x; temp)\n\t{\n\t\tresult[l] = x;\n\t\tl++;\n\t}\n\t\n\tforeach(long x; temp2)\n\t{\n\t\tresult[l] = x;\n\t\tl++;\n\t}\n\t\n\tforeach(long x; temp3)\n\t{\n\t\tresult[l] = x;\n\t\tl++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_lwzuz82.d(48): Range violation\n----------------\n??:? _d_arrayboundsp [0x42883e]\n??:? long[] tmp_lwzuz82.re_arrange_array(long[], long) [0x4280e3]\n??:? void tmp_lwzuz82.__unittest_L60_C1() [0x42821b]\n??:? void tmp_lwzuz82.__modtest() [0x42850c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c847]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430965]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b1]\n??:? runModuleUnitTests [0x42c61d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) in",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jon6yav.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8jon6yav.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8jon6yav.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplhgm72dx.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmplhgm72dx.__unittest_L42_C1() [0x428168]\n??:? void tmplhgm72dx.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9sl2sry2.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp9sl2sry2.__unittest_L41_C1() [0x4281f4]\n??:? void tmp9sl2sry2.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9ve6eva_.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp9ve6eva_.__unittest_L41_C1() [0x4281f4]\n??:? void tmp9ve6eva_.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] neg_arr = new long[n];\n\tlong[] pos_arr = new long[n];\n\tlong[] result = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg_arr[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos_arr[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = neg_arr[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = pos_arr[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7zlwieom.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp7zlwieom.__unittest_L42_C1() [0x4281ec]\n??:? void tmp7zlwieom.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] result_pos = new long[n];\n\tlong[] result_neg = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tresult_neg[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult_pos[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tj = 0;\n\tk = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(j < k)\n\t\t{\n\t\t\tresult[i] = result_neg[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = result_pos[k];\n\t\t\tk++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpitnxvi.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x42867d]\n??:? void tmpqpitnxvi.__unittest_L45_C1() [0x4281a4]\n??:? void tmpqpitnxvi.__modtest() [0x428400]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c737]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430855]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a1]\n??:? runModuleUnitTests [0x42c50d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4xm1gtai.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4xm1gtai.__unittest_L42_C1() [0x4281ec]\n??:? void tmp4xm1gtai.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jon6yav.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8jon6yav.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8jon6yav.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong zero_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_count] = arr[i];\n\t\t\tzero_count++;\n\t\t}\n\t}\n\t\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[count] = negative[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..zero_count)\n\t{\n\t\tresult[count] = zero[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[count] = positive[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0tiu5hb.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpi0tiu5hb.__unittest_L58_C1() [0x42836c]\n??:? void tmpi0tiu5hb.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tfor(long i = 0; i < zero_index; i++)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tfor(long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpksy9ee0b.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428795]\n??:? void tmpksy9ee0b.__unittest_L58_C1() [0x4282b8]\n??:? void tmpksy9ee0b.__modtest() [0x428514]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c84f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43096d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4308f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c625]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_idx = 0;\n\tlong pos_idx = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_idx; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_idx; i++)\n\t{\n\t\tres[neg_idx + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp681ktl_x.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp681ktl_x.__unittest_L38_C1() [0x428168]\n??:? void tmp681ktl_x.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = negative_index; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplhgm72dx.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmplhgm72dx.__unittest_L42_C1() [0x428168]\n??:? void tmplhgm72dx.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwhmwws22.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpwhmwws22.__unittest_L42_C1() [0x4281f4]\n??:? void tmpwhmwws22.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppdugz33q.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmppdugz33q.__unittest_L38_C1() [0x4281ec]\n??:? void tmppdugz33q.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptpq_gf3n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptpq_gf3n.__unittest_L38_C1() [0x4281ec]\n??:? void tmptpq_gf3n.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp06afe7qu.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp06afe7qu.__unittest_L42_C1() [0x428168]\n??:? void tmp06afe7qu.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tforeach(long i; 0..neg_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tforeach(long i; 0..pos_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4611rp7h.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp4611rp7h.__unittest_L41_C1() [0x4281f4]\n??:? void tmp4611rp7h.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tlong zero_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_count] = arr[i];\n\t\t\tzero_count++;\n\t\t}\n\t}\n\t\n\tlong count = 0;\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[count] = negative[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..zero_count)\n\t{\n\t\tresult[count] = zero[i];\n\t\tcount++;\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[count] = positive[i];\n\t\tcount++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi0tiu5hb.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpi0tiu5hb.__unittest_L58_C1() [0x42836c]\n??:? void tmpi0tiu5hb.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_idx = 0;\n\tlong neg_idx = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_idx] = arr[i];\n\t\t\tneg_idx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_idx] = arr[i];\n\t\t\tpos_idx++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_idx)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_idx)\n\t{\n\t\tresult[neg_idx + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr441d7_2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpr441d7_2.__unittest_L42_C1() [0x4281ec]\n??:? void tmpr441d7_2.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0 .. n) \n\t{\n\t\tif(arr[i] < 0) \n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tlong i = 0;\n\tforeach(j; 0 .. neg_count) \n\t{\n\t\tres[i] = neg[j];\n\t\ti++;\n\t}\n\tforeach(j; 0 .. pos_count) \n\t{\n\t\tres[i] = pos[j];\n\t\ti++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoipj2fdy.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpoipj2fdy.__unittest_L41_C1() [0x4281f4]\n??:? void tmpoipj2fdy.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] result = new long[n];\n    long[] positive = new long[n];\n    long[] negative = new long[n];\n    long positive_index = 0;\n    long negative_index = 0;\n    foreach(i; 0..n)\n    {\n        if(arr[i] < 0)\n        {\n            negative[negative_index] = arr[i];\n            negative_index++;\n        }\n        else\n        {\n            positive[positive_index] = arr[i];\n            positive_index++;\n        }\n    }\n    foreach(i; 0..negative_index)\n    {\n        result[i] = negative[i];\n    }\n    foreach(i; 0..positive_index)\n    {\n        result[negative_index + i] = positive[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpp242uwcb.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpp242uwcb.__unittest_L38_C1() [0x4281ec]\n??:? void tmpp242uwcb.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tres[i + neg_count] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp43c28lq8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp43c28lq8.__unittest_L42_C1() [0x4281f4]\n??:? void tmp43c28lq8.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\tfor (long i = 0; i < n; i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} else {\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) {\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < positive_index; i++) {\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwmfo01h2.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpwmfo01h2.__unittest_L35_C1() [0x428168]\n??:? void tmpwmfo01h2.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] temp = new long[n];\n\tlong[] result = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] result2 = new long[n];\n\tlong[] result3 = new long[n];\n\tlong[] result4 = new long[n];\n\tlong[] result5 = new long[n];\n\tlong[] result6 = new long[n];\n\tlong[] result7 = new long[n];\n\tlong[] result8 = new long[n];\n\tlong[] result9 = new long[n];\n\tlong[] result10 = new long[n];\n\tlong[] result11 = new long[n];\n\tlong[] result12 = new long[n];\n\tlong[] result13 = new long[n];\n\tlong[] result14 = new long[n];\n\tlong[] result15 = new long[n];\n\tlong[] result16 = new long[n];\n\tlong[] result17 = new long[n];\n\tlong[] result18 = new long[n];\n\tlong[] result19 = new long[n];\n\tlong[] result20 = new long[n];\n\tlong[] result21 = new long[n];\n\tlong[] result22 = new long[n];\n\tlong[] result23 = new long[n];\n\tlong[] result24 = new long[n];\n\tlong[] result25 = new long[n];\n\tlong[] result26 = new long[n];\n\tlong[] result27 = new long[n];\n\tlong[] result28 = new long[n];\n\tlong[] result29 = new long[n];\n\tlong[] result30 = new long[n];\n\tlong[] result31 = new long[n];\n\tlong[] result32 = new long[n];\n\tlong[] result33 = new long[n];\n\tlong[] result34 = new long[n];\n\tlong[] result35 = new long[n];\n\tlong[] result36 = new long[n];\n\tlong[] result37 = new long[n];\n\tlong[] result38 = new long[n];\n\tlong[] result39 = new long[n];\n\tlong[] result40 = new long[n];\n\tlong[] result41 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "/tmp/tmp9xk_lihz.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp9xk_lihz.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp9xk_lihz.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9xk_lihz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jon6yav.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8jon6yav.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8jon6yav.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxdvhn_bi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxdvhn_bi.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxdvhn_bi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_i = 0;\n\tlong neg_i = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tneg[neg_i] = arr[i];\n\t\t\tneg_i++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpos[pos_i] = arr[i];\n\t\t\tpos_i++;\n\t\t}\n\t}\n\tlong i = 0;\n\twhile (neg_i > 0) \n\t{\n\t\tres[i] = neg[neg_i - 1];\n\t\tneg_i--;\n\t\ti++;\n\t}\n\twhile (pos_i > 0) \n\t{\n\t\tres[i] = pos[pos_i - 1];\n\t\tpos_i--;\n\t\ti++;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl7hjnxa6.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmpl7hjnxa6.__unittest_L43_C1() [0x428158]\n??:? void tmpl7hjnxa6.__modtest() [0x4283b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9wnck_4x.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp9wnck_4x.__unittest_L42_C1() [0x428168]\n??:? void tmp9wnck_4x.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(index, value; arr)\n\t{\n\t\tif(value < 0)\n\t\t{\n\t\t\tnegative[neg_index] = value;\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = value;\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tneg_index = 0;\n\tpos_index = 0;\n\tforeach(index, value; result)\n\t{\n\t\tif(neg_index < negative.length)\n\t\t{\n\t\t\tresult[index] = negative[neg_index];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[index] = positive[pos_index];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptaxmil24.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x42865d]\n??:? void tmptaxmil24.__unittest_L46_C1() [0x428184]\n??:? void tmptaxmil24.__modtest() [0x4283e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c717]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b5aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430835]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ce4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b581]\n??:? runModuleUnitTests [0x42c4ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] ret = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tret[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tret[neg_index + i] = pos[i];\n\t}\n\t\n\treturn ret;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps_d29cy_.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmps_d29cy_.__unittest_L42_C1() [0x4281ec]\n??:? void tmps_d29cy_.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i;0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tforeach(i;0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i;0..pos_index)\n\t{\n\t\tresult[neg_index+i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe2_ercl3.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpe2_ercl3.__unittest_L38_C1() [0x4281ec]\n??:? void tmpe2_ercl3.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative_array = new long[n];\n\tlong[] positive_array = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative_array[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive_array[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative_array[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive_array[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7uzjg9iq.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp7uzjg9iq.__unittest_L42_C1() [0x4281ec]\n??:? void tmp7uzjg9iq.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_i = 0;\n\tlong neg_i = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_i] = arr[i];\n\t\t\tneg_i++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_i] = arr[i];\n\t\t\tpos_i++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_i)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_i)\n\t{\n\t\tres[neg_i + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpngmy7org.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpngmy7org.__unittest_L42_C1() [0x4281ec]\n??:? void tmpngmy7org.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; neg_count..n)\n\t{\n\t\tresult[i] = positive[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpis90_ko2.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpis90_ko2.__unittest_L42_C1() [0x4281e8]\n??:? void tmpis90_ko2.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_i = 0;\n\tlong neg_i = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_i] = arr[i];\n\t\t\tneg_i++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_i] = arr[i];\n\t\t\tpos_i++;\n\t\t}\n\t}\n\tfor (long i = 0; i < neg_i; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tfor (long i = 0; i < pos_i; i++)\n\t{\n\t\tres[neg_i + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122891,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2rhs95b5.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp2rhs95b5.__unittest_L38_C1() [0x428168]\n??:? void tmp2rhs95b5.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjyw17eiq.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpjyw17eiq.__unittest_L45_C1() [0x428168]\n??:? void tmpjyw17eiq.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++) \n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx9r64f8t.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpx9r64f8t.__unittest_L42_C1() [0x428168]\n??:? void tmpx9r64f8t.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[i+neg_count] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi9i1cge5.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpi9i1cge5.__unittest_L38_C1() [0x4281f4]\n??:? void tmpi9i1cge5.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = negative_count; i < n; i++) \n\t{\n\t\tresult[i] = positive[i - negative_count];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp77dnhn4r.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp77dnhn4r.__unittest_L38_C1() [0x428168]\n??:? void tmp77dnhn4r.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9j9jllb4.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp9j9jllb4.__unittest_L38_C1() [0x4281ec]\n??:? void tmp9j9jllb4.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo6qf60vm.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpo6qf60vm.__unittest_L42_C1() [0x428168]\n??:? void tmpo6qf60vm.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfo5vm0ev.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpfo5vm0ev.__unittest_L41_C1() [0x428168]\n??:? void tmpfo5vm0ev.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t}\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\tforeach(i; neg_count .. n)\n\t{\n\t\tres[i] = pos[i - neg_count];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsf8d367v.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpsf8d367v.__unittest_L38_C1() [0x4281e8]\n??:? void tmpsf8d367v.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor(long i = 0; i < n; i++)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t}\n\t\n\tfor(long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor(long i = negative_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqvtdgwj8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpqvtdgwj8.__unittest_L42_C1() [0x428168]\n??:? void tmpqvtdgwj8.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe0ed6ppb.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpe0ed6ppb.__unittest_L42_C1() [0x4281f4]\n??:? void tmpe0ed6ppb.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index+i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbx0z_171.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpbx0z_171.__unittest_L42_C1() [0x4281ec]\n??:? void tmpbx0z_171.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_index; i++) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = negative_index; i < n; i++) \n\t{\n\t\tresult[i] = positive[i - negative_index];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgodi0l3n.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpgodi0l3n.__unittest_L38_C1() [0x428168]\n??:? void tmpgodi0l3n.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpow3z1tfa.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpow3z1tfa.__unittest_L42_C1() [0x4281ec]\n??:? void tmpow3z1tfa.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] result = new long[n];\n    long[] positive = new long[n];\n    long[] negative = new long[n];\n    long pos_index = 0;\n    long neg_index = 0;\n    foreach(i; 0..n)\n    {\n        if(arr[i] < 0)\n        {\n            negative[neg_index] = arr[i];\n            neg_index++;\n        }\n        else\n        {\n            positive[pos_index] = arr[i];\n            pos_index++;\n        }\n    }\n    long index = 0;\n    foreach(i; 0..neg_index)\n    {\n        result[index] = negative[i];\n        index++;\n    }\n    foreach(i; 0..pos_index)\n    {\n        result[index] = positive[i];\n        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_kdsr7yb.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmp_kdsr7yb.__unittest_L41_C1() [0x4281f4]\n??:? void tmp_kdsr7yb.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr4z_hf1a.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpr4z_hf1a.__unittest_L42_C1() [0x4281ec]\n??:? void tmpr4z_hf1a.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(long i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(long i; 0 .. neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(long i; 0 .. pos_count)\n\t{\n\t\tres[neg_count + i] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprb52slu3.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmprb52slu3.__unittest_L42_C1() [0x4281ec]\n??:? void tmprb52slu3.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tforeach(i; 0..n) \n\t{\n\t\tif(arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index) \n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index) \n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4igkh8aj.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4igkh8aj.__unittest_L41_C1() [0x4281ec]\n??:? void tmp4igkh8aj.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(long i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tforeach(long i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx8thh15.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpwx8thh15.__unittest_L38_C1() [0x4281ec]\n??:? void tmpwx8thh15.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_count)\n\t{\n\t\tresult[negative_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxdvhn_bi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpxdvhn_bi.__unittest_L42_C1() [0x4281ec]\n??:? void tmpxdvhn_bi.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxhkzfxa7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpxhkzfxa7.__unittest_L42_C1() [0x428168]\n??:? void tmpxhkzfxa7.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tfor (long i = 0; i < negative_count; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\tfor (long i = negative_count; i < n; i++)\n\t{\n\t\tresult[i] = positive[i - negative_count];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf3_tv16p.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpf3_tv16p.__unittest_L38_C1() [0x428168]\n??:? void tmpf3_tv16p.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi2nlmzaf.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpi2nlmzaf.__unittest_L42_C1() [0x4281ec]\n??:? void tmpi2nlmzaf.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n    long[] res = new long[n];\n    long i = 0;\n    long j = n - 1;\n    foreach (e; arr[0 .. n]) \n    {\n        if (e < 0) \n        {\n            res[i] = e;\n            i++;\n        } \n        else \n        {\n            res[j] = e;\n            j--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfjillpt2.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42850d]\n??:? void tmpfjillpt2.__unittest_L28_C1() [0x428034]\n??:? void tmpfjillpt2.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b45a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306e5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430671]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b431]\n??:? runModuleUnitTests [0x42c39d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289d0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\tlong index = 0;\n\tfor (long i = 0; i < neg_index; i++) \n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\tfor (long i = 0; i < pos_index; i++) \n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyi_uw2nt.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpyi_uw2nt.__unittest_L41_C1() [0x428168]\n??:? void tmpyi_uw2nt.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4vxt2hzi.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp4vxt2hzi.__unittest_L42_C1() [0x428168]\n??:? void tmp4vxt2hzi.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tfor (long i = neg_count; i < neg_count + pos_count; i++)\n\t{\n\t\tres[i] = pos[i - neg_count];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfi5s3e3b.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpfi5s3e3b.__unittest_L42_C1() [0x42816c]\n??:? void tmpfi5s3e3b.__modtest() [0x4283c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq05b9fbq.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpq05b9fbq.__unittest_L42_C1() [0x4281ec]\n??:? void tmpq05b9fbq.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\tlong[] temp = negative[0..negative_index] ~ positive[0..positive_index];\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tresult[i] = temp[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0_ybhmbh.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42864d]\n??:? void tmp0_ybhmbh.__unittest_L35_C1() [0x428174]\n??:? void tmp0_ybhmbh.__modtest() [0x4283d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c84f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b6e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430825]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b6b9]\n??:? runModuleUnitTests [0x42c625]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < neg_count; i++)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tfor (long i = neg_count; i < n; i++)\n\t{\n\t\tres[i] = pos[i - neg_count];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptj7do68h.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmptj7do68h.__unittest_L42_C1() [0x428168]\n??:? void tmptj7do68h.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive_arr = new long[n];\n\tlong[] negative_arr = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative_arr[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive_arr[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative_arr[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive_arr[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe__76kkh.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpe__76kkh.__unittest_L42_C1() [0x4281ec]\n??:? void tmpe__76kkh.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] neg = new long[n];\n\tlong[] pos = new long[n];\n\tlong neg_count = 0;\n\tlong pos_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpchronymm.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpchronymm.__unittest_L38_C1() [0x4281ec]\n??:? void tmpchronymm.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tfor (long i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_index; i++)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_index; i++)\n\t{\n\t\tresult[i + negative_index] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp06afe7qu.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmp06afe7qu.__unittest_L42_C1() [0x428168]\n??:? void tmp06afe7qu.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx5iggrqg.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpx5iggrqg.__unittest_L42_C1() [0x4281ec]\n??:? void tmpx5iggrqg.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong j = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] >= 0) \n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp5uy4qp2b.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42856d]\n??:? void tmp5uy4qp2b.__unittest_L30_C1() [0x428094]\n??:? void tmp5uy4qp2b.__modtest() [0x4282f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c627]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430745]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bf4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b491]\n??:? runModuleUnitTests [0x42c3fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp19u415n7.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp19u415n7.__unittest_L42_C1() [0x4281ec]\n??:? void tmp19u415n7.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos_arr = new long[n];\n\tlong[] neg_arr = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg_arr[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos_arr[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg_arr[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = pos_arr[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwoz58ebo.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpwoz58ebo.__unittest_L41_C1() [0x4281ec]\n??:? void tmpwoz58ebo.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[arr.length];\n\tlong[] temp = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tresult[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (long i = 0; i < j; i++) \n\t{\n\t\tresult[k] = temp[i];\n\t\tk++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa7bprtpm.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285ad]\n??:? void tmpa7bprtpm.__unittest_L34_C1() [0x4280d4]\n??:? void tmpa7bprtpm.__modtest() [0x428330]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c667]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d1]\n??:? runModuleUnitTests [0x42c43d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] result_pos = new long[n];\n\tlong[] result_neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tresult_neg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult_pos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = result_neg[i];\n\t}\n\t\n\tforeach(i; 0..pos_count)\n\t{\n\t\tresult[neg_count + i] = result_pos[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgwj5d71f.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpgwj5d71f.__unittest_L42_C1() [0x4281ec]\n??:? void tmpgwj5d71f.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong j = 0;\n\tlong k = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\tif (arr[i] < 0) \n\t\t{\n\t\t\tresult[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ttemp[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (long i = 0; i < k; i++) \n\t{\n\t\tresult[j] = temp[i];\n\t\tj++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu9cqxccz.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4285b5]\n??:? void tmpu9cqxccz.__unittest_L34_C1() [0x4280d8]\n??:? void tmpu9cqxccz.__modtest() [0x428334]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c66f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b502]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]\n??:? runModuleUnitTests [0x42c445]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\t\n\tfor (long i = 0; i < n; i++) {\n\t\tif (arr[i] < 0) {\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t} else {\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\t\n\tfor (long i = 0; i < negative_count; i++) {\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tfor (long i = 0; i < positive_count; i++) {\n\t\tresult[i + negative_count] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwc3kzzdo.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428645]\n??:? void tmpwc3kzzdo.__unittest_L36_C1() [0x428168]\n??:? void tmpwc3kzzdo.__modtest() [0x4283c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b592]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43081d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ccc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]\n??:? runModuleUnitTests [0x42c4d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tres[i + neg_count] = pos[i];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppm0h_zad.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmppm0h_zad.__unittest_L42_C1() [0x4281f4]\n??:? void tmppm0h_zad.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong neg_index = 0;\n\tlong pos_index = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfo_9w0ed.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpfo_9w0ed.__unittest_L42_C1() [0x4281ec]\n??:? void tmpfo_9w0ed.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] res = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_counter = 0;\n\tlong neg_counter = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tneg[neg_counter] = arr[i];\n\t\t\tneg_counter++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos[pos_counter] = arr[i];\n\t\t\tpos_counter++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_counter)\n\t{\n\t\tres[i] = neg[i];\n\t}\n\t\n\tforeach(i; neg_counter..n)\n\t{\n\t\tres[i] = pos[i - neg_counter];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptlcim3ph.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmptlcim3ph.__unittest_L42_C1() [0x4281e8]\n??:? void tmptlcim3ph.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong positive_count = 0;\n\tlong negative_count = 0;\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_count] = arr[i];\n\t\t\tnegative_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_count] = arr[i];\n\t\t\tpositive_count++;\n\t\t}\n\t}\n\tlong i = 0;\n\tforeach(j; 0..negative_count)\n\t{\n\t\tresult[i] = negative[j];\n\t\ti++;\n\t}\n\tforeach(j; 0..positive_count)\n\t{\n\t\tresult[i] = positive[j];\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjvxtr89l.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4286cd]\n??:? void tmpjvxtr89l.__unittest_L41_C1() [0x4281f4]\n??:? void tmpjvxtr89l.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] positive = new long[n];\n\tlong negative_index = 0;\n\tlong positive_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..negative_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..positive_index)\n\t{\n\t\tresult[negative_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0zq3fqc4.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp0zq3fqc4.__unittest_L42_C1() [0x4281ec]\n??:? void tmp0zq3fqc4.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong[] zero = new long[n];\n\tlong positive_index = 0;\n\tlong negative_index = 0;\n\tlong zero_index = 0;\n\t\n\tforeach(long i; 0..n)\n\t{\n\t\tif(arr[i] > 0)\n\t\t{\n\t\t\tpositive[positive_index] = arr[i];\n\t\t\tpositive_index++;\n\t\t}\n\t\telse if(arr[i] < 0)\n\t\t{\n\t\t\tnegative[negative_index] = arr[i];\n\t\t\tnegative_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzero[zero_index] = arr[i];\n\t\t\tzero_index++;\n\t\t}\n\t}\n\t\n\tlong index = 0;\n\tforeach(long i; 0..negative_index)\n\t{\n\t\tresult[index] = negative[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(long i; 0..zero_index)\n\t{\n\t\tresult[index] = zero[i];\n\t\tindex++;\n\t}\n\t\n\tforeach(long i; 0..positive_index)\n\t{\n\t\tresult[index] = positive[i];\n\t\tindex++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpp3x_9ux5.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428845]\n??:? void tmpp3x_9ux5.__unittest_L58_C1() [0x42836c]\n??:? void tmpp3x_9ux5.__modtest() [0x4285c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b792]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a1d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ecc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b769]\n??:? runModuleUnitTests [0x42c6d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0 .. n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0 .. neg_count)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0 .. pos_count)\n\t{\n\t\tresult[neg_count + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpue3d3qm8.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmpue3d3qm8.__unittest_L42_C1() [0x4281ec]\n??:? void tmpue3d3qm8.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong pos_index = 0;\n\tlong neg_index = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[neg_index] = arr[i];\n\t\t\tneg_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[pos_index] = arr[i];\n\t\t\tpos_index++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_index)\n\t{\n\t\tresult[i] = negative[i];\n\t}\n\t\n\tforeach(i; 0..pos_index)\n\t{\n\t\tresult[neg_index + i] = positive[i];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122890,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jon6yav.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp8jon6yav.__unittest_L42_C1() [0x4281ec]\n??:? void tmp8jon6yav.__modtest() [0x428448]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] pos = new long[n];\n\tlong[] neg = new long[n];\n\tlong pos_count = 0;\n\tlong neg_count = 0;\n\t\n\tforeach(i; 0..n)\n\t{\n\t\tif(arr[i] >= 0)\n\t\t{\n\t\t\tpos[pos_count] = arr[i];\n\t\t\tpos_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tneg[neg_count] = arr[i];\n\t\t\tneg_count++;\n\t\t}\n\t}\n\t\n\tforeach(i; 0..neg_count)\n\t{\n\t\tresult[i] = neg[i];\n\t}\n\t\n\tforeach(i; neg_count..n)\n\t{\n\t\tresult[i] = pos[i - neg_count];\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4b4mkz3c.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4286c5]\n??:? void tmp4b4mkz3c.__unittest_L42_C1() [0x4281e8]\n??:? void tmp4b4mkz3c.__modtest() [0x428444]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c77f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b612]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43089d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430d4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430829]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5e9]\n??:? runModuleUnitTests [0x42c555]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428b88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] positive = new long[n];\n\tlong[] negative = new long[n];\n\tlong i = 0;\n\tlong j = 0;\n\tlong k = 0;\n\twhile(i < n)\n\t{\n\t\tif(arr[i] < 0)\n\t\t{\n\t\t\tnegative[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositive[k] = arr[i];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\tj = 0;\n\twhile(i < n)\n\t{\n\t\tif(j < k)\n\t\t{\n\t\t\tresult[i] = negative[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[i] = positive[k];\n\t\t\tk++;\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1666122892,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3tc1nujf.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428635]\n??:? void tmp3tc1nujf.__unittest_L48_C1() [0x42815c]\n??:? void tmp3tc1nujf.__modtest() [0x4283b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b582]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43080d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430799]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b559]\n??:? runModuleUnitTests [0x42c4c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428af8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\t\n*/\nlong[] re_arrange_array(long[] arr, long n) \n{\n\tlong[] result = new long[n];\n\tlong[] temp = new long[n];\n\tlong[] temp2 = new long[n];\n\tlong[] temp3 = new long[n];\n\tlong[] temp4 = new long[n];\n\tlong[] temp5 = new long[n];\n\tlong[] temp6 = new long[n];\n\tlong[] temp7 = new long[n];\n\tlong[] temp8 = new long[n];\n\tlong[] temp9 = new long[n];\n\tlong[] temp10 = new long[n];\n\tlong[] temp11 = new long[n];\n\tlong[] temp12 = new long[n];\n\tlong[] temp13 = new long[n];\n\tlong[] temp14 = new long[n];\n\tlong[] temp15 = new long[n];\n\tlong[] temp16 = new long[n];\n\tlong[] temp17 = new long[n];\n\tlong[] temp18 = new long[n];\n\tlong[] temp19 = new long[n];\n\tlong[] temp20 = new long[n];\n\tlong[] temp21 = new long[n];\n\tlong[] temp22 = new long[n];\n\tlong[] temp23 = new long[n];\n\tlong[] temp24 = new long[n];\n\tlong[] temp25 = new long[n];\n\tlong[] temp26 = new long[n];\n\tlong[] temp27 = new long[n];\n\tlong[] temp28 = new long[n];\n\tlong[] temp29 = new long[n];\n\tlong[] temp30 = new long[n];\n\tlong[] temp31 = new long[n];\n\tlong[] temp32 = new long[n];\n\tlong[] temp33 = new long[n];\n\tlong[] temp34 = new long[n];\n\tlong[] temp35 = new long[n];\n\tlong[] temp36 = new long[n];\n\tlong[] temp37 = new long[n];\n\tlong[] temp38 = new long[n];\n\tlong[] temp39 = new long[n];\n\tlong[] temp40 = new long[n];\n\tlong[] temp41 = new long[n];\n\tlong[] temp42 = new\nunittest\n{\n    alias candidate = re_arrange_array;\n\n    assert(candidate([-1L, 2L, -3L, 4L, 5L, 6L, -7L, 8L, 9L], 9L) == [-1L, -3L, -7L, 4L, 5L, 6L, 2L, 8L, 9L]);\n    assert(candidate([12L, -14L, -26L, 13L, 15L], 5L) == [-14L, -26L, 12L, 13L, 15L]);\n    assert(candidate([10L, 24L, 36L, -42L, -39L, -78L, 85L], 7L) == [-42L, -39L, -78L, 10L, 24L, 36L, 85L]);\n}\nvoid main(){}",
      "timestamp": 1665517266,
      "stdout": "",
      "stderr": "/tmp/tmp2bhjsvmv.d(53): Error: basic type expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp2bhjsvmv.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2bhjsvmv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}