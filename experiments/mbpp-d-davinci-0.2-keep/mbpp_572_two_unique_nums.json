{
  "name": "mbpp_572_two_unique_nums",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a python function to remove duplicate numbers from a given number of lists.\n\t\n*/\nlong[] two_unique_nums(long[] nums) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = two_unique_nums;\n\n    assert(candidate([1L, 2L, 3L, 2L, 3L, 4L, 5L]) == [1L, 4L, 5L]);\n    assert(candidate([1L, 2L, 3L, 2L, 4L, 5L]) == [1L, 3L, 4L, 5L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 2L, 3L, 4L, 5L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\t\n\tlong mask = xor & -xor;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & mask) == 0)\n\t\t\tresult[0] ^= num;\n\t\telse\n\t\t\tresult[1] ^= num;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) == 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(unique_nums[0] == 0)\n\t\t{\n\t\t\tunique_nums[0] = num;\n\t\t}\n\t\telse if(unique_nums[0] == num)\n\t\t{\n\t\t\tunique_nums[0] = 0;\n\t\t}\n\t\telse if(unique_nums[1] == 0)\n\t\t{\n\t\t\tunique_nums[1] = num;\n\t\t}\n\t\telse if(unique_nums[1] == num)\n\t\t{\n\t\t\tunique_nums[1] = 0;\n\t\t}\n\t}\n\t\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\tlong right_most_bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & right_most_bit) != 0)\n\t\t\tresult[0] ^= num;\n\t\telse\n\t\t\tresult[1] ^= num;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\t\n\tforeach(num; nums)\n\t{\n\t\tif(unique_nums[0] == 0)\n\t\t{\n\t\t\tunique_nums[0] = num;\n\t\t}\n\t\telse if(unique_nums[0] == num)\n\t\t{\n\t\t\tunique_nums[0] = 0;\n\t\t}\n\t\telse if(unique_nums[1] == 0)\n\t\t{\n\t\t\tunique_nums[1] = num;\n\t\t}\n\t\telse if(unique_nums[1] == num)\n\t\t{\n\t\t\tunique_nums[1] = 0;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tfor (long num : nums) \n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong bit = xor & ~(xor - 1);\n\tfor (long num : nums) \n\t{\n\t\tif ((num & bit) != 0) \n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tfor (int i = 0; i < nums.length; i++)\n\t{\n\t\txor ^= nums[i];\n\t}\n\t\n\tint right_most_set_bit = xor & ~(xor - 1);\n\t\n\tfor (int i = 0; i < nums.length; i++)\n\t{\n\t\tif ((nums[i] & right_most_set_bit) != 0)\n\t\t{\n\t\t\tunique_nums[0] ^= nums[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= nums[i];\n\t\t}\n\t}\n\t\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\tunique_nums[0] = xor;\n\tunique_nums[1] = xor;\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\t// find the rightmost set bit\n\tlong right_set_bit = xor & ~(xor - 1);\n\t\n\t// divide the numbers into two groups\n\tforeach(num; nums)\n\t{\n\t\tif((num & right_set_bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\t// Find the rightmost set bit\n\tlong rightmost_set_bit = xor & ~(xor - 1);\n\t\n\t// Divide the numbers into two groups\n\tforeach(num; nums)\n\t{\n\t\tif((num & rightmost_set_bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\t\n\tlong right_most_bit = xor & ~(xor - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & right_most_bit) != 0)\n\t\t\tresult[0] ^= num;\n\t\telse\n\t\t\tresult[1] ^= num;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] ret = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\tlong bit = xor & ~(xor - 1);\n\tforeach(num; nums)\n\t{\n\t\tif((num & bit) != 0)\n\t\t{\n\t\t\tret[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret[1] ^= num;\n\t\t}\n\t}\n\treturn ret;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t\txor ^= num;\n\t\n\t// Get the rightmost set bit in xor\n\tlong set_bit_no = (xor & ~(xor - 1));\n\t\n\t// Now divide elements in two sets by comparing rightmost set\n\t// bit of xor with bit at same position in each element.\n\tforeach(num; nums)\n\t{\n\t\tif((num & set_bit_no) != 0)\n\t\t\tresult[0] ^= num;\n\t\telse\n\t\t\tresult[1] ^= num;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong xor_num = 0;\n\tforeach(num; nums)\n\t{\n\t\txor_num ^= num;\n\t}\n\t\n\tlong last_bit = xor_num & ~(xor_num - 1);\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & last_bit) != 0)\n\t\t{\n\t\t\tunique_nums[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums[1] ^= num;\n\t\t}\n\t}\n\treturn unique_nums;\n}",
    "{\n\tlong[] result = new long[2];\n\tlong xor = 0;\n\tforeach(num; nums)\n\t{\n\t\txor ^= num;\n\t}\n\t\n\tlong mask = xor & -xor;\n\t\n\tforeach(num; nums)\n\t{\n\t\tif((num & mask) == 0)\n\t\t{\n\t\t\tresult[0] ^= num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[1] ^= num;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong[] unique_nums_index = new long[2];\n\tlong[] unique_nums_count = new long[2];\n\t\n\tunique_nums[0] = nums[0];\n\tunique_nums[1] = nums[1];\n\tunique_nums_index[0] = 0;\n\tunique_nums_index[1] = 1;\n\tunique_nums_count[0] = 1;\n\tunique_nums_count[1] = 1;\n\t\n\tforeach(i, num; nums)\n\t{\n\t\tif(num == unique_nums[0])\n\t\t{\n\t\t\tunique_nums_count[0]++;\n\t\t}\n\t\telse if(num == unique_nums[1])\n\t\t{\n\t\t\tunique_nums_count[1]++;\n\t\t}\n\t\telse if(unique_nums_count[0] == 0)\n\t\t{\n\t\t\tunique_nums[0] = num;\n\t\t\tunique_nums_index[0] = i;\n\t\t\tunique_nums_count[0] = 1;\n\t\t}\n\t\telse if(unique_nums_count[1] == 0)\n\t\t{\n\t\t\tunique_nums[1] = num;\n\t\t\tunique_nums_index[1] = i;\n\t\t\tunique_nums_count[1] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunique_nums_count[0]--;\n\t\t\tunique_nums_count[1]--;\n\t\t}\n\t}\n\t\n\treturn unique_nums;\n}",
    "{\n\tlong[] unique_nums = new long[2];\n\tlong[] nums_copy = nums.dup;\n\tnums_copy.sort;\n\t\n\tif (nums_copy[0] != nums_copy[1])\n\t{\n\t\tunique_nums[0] = nums_copy[0];\n\t\tunique_nums[1] = nums_copy[1];\n\t}\n\telse\n\t{\n\t\tunique_nums[0] = nums_copy[2];\n\t\tunique_nums[1] = nums_copy[3];\n\t}\n\t\n\treturn unique_nums;\n}"
  ]
}