{
  "name": "mbpp_747_lcs_of_three",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\t\n*/\nlong lcs_of_three(string X, string Y, string Z) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = lcs_of_three;\n\n    assert(candidate(\"AGGT12\", \"12TXAYB\", \"12XBA\") == 2L);\n    assert(candidate(\"Reels\", \"Reelsfor\", \"ReelsforReels\") == 5L);\n    assert(candidate(\"abcd1e2\", \"bc12ea\", \"bd1ea\") == 3L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) \n    { \n        for (int j = 0; j <= n; j++) \n        { \n            for (int k = 0; k <= o; k++) \n            { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                        L[i][j - 1][k]), \n                                    L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length(); \n    int n = Y.length(); \n    int o = Z.length(); \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    /* Following steps build L[m+1][n+1][o+1] in bottom up fashion. Note \n       that L[i][j][k] contains length of LCS of X[0..i-1] and Y[0..j-1] \n       and Z[0..k-1] */\n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], L[i][j - 1][k]), L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    /* L[m][n][o] contains length of LCS for X[0..n-1] and Y[0..m-1] and Z[0..o-1]*/\n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length(); \n    int n = Y.length(); \n    int o = Z.length(); \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                         L[i][j - 1][k]), \n                                     L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n    int[][][] L = new int[m + 1][n + 1][o + 1]; \n  \n    /* Following steps build L[m+1][n+1][o+1] in bottom up fashion. Note  \n         that L[i][j][k] contains length of LCS of X[0..i-1] and Y[0..j-1] \n         and Z[0..k-1] */\n    for (int i = 0; i <= m; i++) \n    { \n        for (int j = 0; j <= n; j++) \n        { \n            for (int k = 0; k <= o; k++) \n            { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(L[i - 1][j][k], L[i][j - 1][k], L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    /* L[m][n][o] contains length of LCS for X[0..n-1] and  \n        Y[0..m-1] and Z[0..o-1]*/\n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length(); \n    int n = Y.length(); \n    int o = Z.length(); \n  \n    // declaring 2D array \n    int L[m + 1][n + 1][o + 1]; \n  \n    // looping through the string \n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                         L[i][j - 1][k]), \n                                     L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\t\n\tint L[m+1][n+1][o+1]; \n\t\n\tfor (int i=0; i<=m; i++) \n\t{ \n\t\tfor (int j=0; j<=n; j++) \n\t\t{ \n\t\t\tfor (int k=0; k<=o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i-1] == Y[j-1] && X[i-1]==Z[k-1]) \n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], L[i][j-1][k]),L[i][j][k-1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n    int[][][] L = new int[m + 1][n + 1][o + 1]; \n  \n    /* Following steps build L[m+1][n+1][o+1] in bottom up fashion. Note  \n       that L[i][j][k] contains length of LCS of X[0..i-1] and Y[0..j-1] \n       and Z[0..k-1] */\n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(L[i - 1][j][k], L[i][j - 1][k], L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    /* L[m][n][o] contains length of LCS for X[0..n-1] and Y[0..m-1] and Z[0..o-1]*/\n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n  \n    int[][][] L = new int[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                        L[i][j - 1][k]), \n                                    L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\tint L[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(max(L[i - 1][j][k], \n\t\t\t\t\t\t\t\t\t\tL[i][j - 1][k]), \n\t\t\t\t\t\t\t\t\tL[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\t\n\tint[][][] L = new int[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0 || k == 0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(L[i - 1][j][k], L[i][j - 1][k], L[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\t\n\treturn L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\tint L[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(max(L[i - 1][j][k], \n\t\t\t\t\t\t\t\t\tL[i][j - 1][k]), \n\t\t\t\t\t\t\t\t\tL[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) \n    { \n        for (int j = 0; j <= n; j++) \n        { \n            for (int k = 0; k <= o; k++) \n            { \n                if (i == 0 || j == 0||k==0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k-1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                         L[i][j - 1][k]), \n                                     L[i][j][k-1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n    int m = X.length(); \n    int n = Y.length(); \n    int o = Z.length(); \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                         L[i][j - 1][k]), \n                                     L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} \n  \n// Driver code ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n    int[][][] L = new int[m + 1][n + 1][o + 1]; \n  \n    /* Following steps build L[m+1][n+1][o+1] in bottom up fashion. Note \n       that L[i][j][k] contains length of LCS of X[0..i-1] and Y[0..j-1] \n       and Z[0..k-1]*/\n    for (int i = 0; i <= m; i++) \n    { \n        for (int j = 0; j <= n; j++) \n        { \n            for (int k = 0; k <= o; k++) \n            { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(L[i - 1][j][k], \n                                     L[i][j - 1][k], \n                                     L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    /* L[m][n][o] contains length of LCS for X[0..n-1] and \n      Y[0..m-1] and Z[0..o-1]*/\n    return L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\t\n\tint[][][] L = new int[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(L[i - 1][j][k], \n\t\t\t\t\t\t\t\t\tL[i][j - 1][k], \n\t\t\t\t\t\t\t\t\tL[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\tint[][][] L = new int[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0 || k == 0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(L[i - 1][j][k], L[i][j - 1][k], L[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\t\n\tint[][][] L = new int[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0 || k == 0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(L[i - 1][j][k], L[i][j - 1][k], L[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\t\n\treturn L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\tint L[m + 1][n + 1][o + 1]; \n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(max(L[i - 1][j][k], \n\t\t\t\t\t\t\t\t\t\tL[i][j - 1][k]), \n\t\t\t\t\t\t\t\t\tL[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} ",
    "{ \n    int m = X.length; \n    int n = Y.length; \n    int o = Z.length; \n  \n    int L[m + 1][n + 1][o + 1]; \n  \n    for (int i = 0; i <= m; i++) { \n        for (int j = 0; j <= n; j++) { \n            for (int k = 0; k <= o; k++) { \n                if (i == 0 || j == 0 || k == 0) \n                    L[i][j][k] = 0; \n  \n                else if (X[i - 1] == Y[j - 1] && \n                         X[i - 1] == Z[k - 1]) \n                    L[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n  \n                else\n                    L[i][j][k] = max(max(L[i - 1][j][k], \n                                         L[i][j - 1][k]), \n                                     L[i][j][k - 1]); \n            } \n        } \n    } \n  \n    return L[m][n][o]; \n} ",
    "{ \n\tint m = X.length; \n\tint n = Y.length; \n\tint o = Z.length; \n\t\n\tint L[m + 1][n + 1][o + 1]; \n\t\n\tfor (int i = 0; i <= m; i++) \n\t{ \n\t\tfor (int j = 0; j <= n; j++) \n\t\t{ \n\t\t\tfor (int k = 0; k <= o; k++) \n\t\t\t{ \n\t\t\t\tif (i == 0 || j == 0||k==0) \n\t\t\t\t\tL[i][j][k] = 0; \n\t\t\t\telse if (X[i - 1] == Y[j - 1] && X[i - 1]==Z[k - 1]) \n\t\t\t\t\tL[i][j][k] = L[i - 1][j - 1][k - 1] + 1; \n\t\t\t\telse\n\t\t\t\t\tL[i][j][k] = max(max(L[i - 1][j][k], \n\t\t\t\t\t\t\t\t\t\tL[i][j - 1][k]), \n\t\t\t\t\t\t\t\t\tL[i][j][k - 1]); \n\t\t\t} \n\t\t} \n\t} \n\treturn L[m][n][o]; \n} "
  ]
}