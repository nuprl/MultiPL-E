{
  "name": "mbpp_291_count_no_of_ways",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\n*/\nlong count_no_of_ways(long n, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = count_no_of_ways;\n\n    assert(candidate(2L, 4L) == 16L);\n    assert(candidate(3L, 2L) == 6L);\n    assert(candidate(4L, 4L) == 228L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count * (k - 1);\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); \n\t\n\t// There are k ways to paint 0 posts \n\tdp[0] = 0; \n\t\n\t// There are k ways to paint 1 posts with k colors \n\tdp[1] = k; \n\t\n\t// There are 0 ways for 1 post to paint with 1 color \n\tdp[2] = k + k * (k - 1); \n\t\n\t// Fill for 2 posts onwards \n\tfor (long i = 3; i <= n; i++) \n\t\tdp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n\t\n\treturn dp[n]; \n} ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\t\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simpilicity \n\t// (Number of columns is equal to number of colors \n\t// of the fence plus 1) \n\tlong dp[n + 1][k + 1]; \n\t\n\t// Initialize first column of all rows as same color \n\t// (one way to paint the fence) \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row, except dp[0][0], as 0. The \n\t// dp[0][0] is initialized as 0 and not 1 because \n\t// the zero post has one color (itself), we can't \n\t// paint the zero post with any other color. \n\tfor (long j = 1; j <= k; j++) \n\t\tdp[0][j] = 0; \n\t\n\t// Fill rest of the entries in dp[][] \n\tfor (long i = 1; i <= n; i++) \n\t\tfor (long j = 2; j <= k; j++) \n\t\t\tdp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]); \n\t\n\treturn dp[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems.  k+2 is used \n    // so that we can use modular arithmetic. i.e., we assume that the \n    // count is for i-2 and i-1 \n    long dp[][] = new long[n+1][k+2]; \n  \n    // There are k ways to color first post \n    for (long j = 1; j <= k; j++) \n        dp[1][j] = 1; \n  \n    // There is only one way to color the first two posts in \n    // the same color \n    for (long i = 2; i <= n; i++) \n        dp[i][2] = k; \n  \n    // Fill rest of the entries in table using recursive relation \n    // explained above. \n    for (long i = 3; i <= n; i++) \n        for (long j = 1; j <= k; j++) \n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % 1000000007; \n  \n    // sum of all the entries of last row is our answer \n    long ans = 0; \n    for (long j = 1; j <= k; j++) \n        ans = (ans + dp[n][j]) % 1000000007; \n  \n    return ans; \n} ",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simpilicity  \n\t// (Number of posts is directly used as row index and  \n\t// number of colors is directly used as column index).  \n\t// The entries in 0th row and 0th column are never used.  \n\tlong[][] dp = new long[n + 1][k + 1]; \n\t\n\t// Base cases  \n\t// If number of posts is 0 then there are 0 ways  \n\t// If number of posts is 1 then there are k ways  \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// Fill rest of the entries in table using recursive  \n\t// formula  \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\t// Ways when the last post has color c \n\t\t\tlong diffColorCount = (dp[i - 1][c] * (k - 1)); \n\t\t\t\n\t\t\t// Ways when the last two posts have same color c \n\t\t\tlong sameColorCount = dp[i - 1][c - 1]; \n\t\t\t\n\t\t\t// Total ways till i posts and last post has color c \n\t\t\tdp[i][c] = diffColorCount + sameColorCount; \n\t\t} \n\t} \n\t\n\t// Return total ways for n posts and k colors \n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color = k * (k - 1);\n\tlong same_color = k;\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff_color;\n\t\tdiff_color = (diff_color + same_color) * (k - 1);\n\t\tsame_color = temp;\n\t}\n\t\n\treturn diff_color + same_color;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = total_counts * (k - 1);\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of columns is equal to number of colors \n\t// of posts and number of rows is equal to number \n\t// of posts) \n\tlong[][] dp = new long[n][k]; ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n+1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0th post \n    dp[0] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count) property \n    dp[1] = k; \n  \n    // There are 0 ways for two posts to \n    // violate (same color_count) property \n    dp[2] = k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; ++i)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; ++i) {\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn diff_color_count + same_color_count;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    long same = 0, diff = k; \n  \n    for (long i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // One extra row and column are used for simplicity \n    // (Number of posts is directly used as row index and \n    // number of colors is directly used as column index). \n    // The entries in 0th row and 0th column are never used. \n    long[][] dp = new long[n + 1][k + 1]; \n  \n    // Initialize first column as 0. There will always be \n    // 0 ways to paint if number of colors is 0. \n    for (long i = 0; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Initialize first row as 0. There will always be 0 \n    // ways to paint if number of posts is 0. \n    for (long j = 0; j <= k; j++) \n        dp[0][j] = 0; \n  \n    // Initialize first row and first column as 0. \n    dp[1][1] = k; \n    for (long j = 2; j <= k; j++) \n        dp[1][j] = dp[1][j - 1] * (k - 1); \n  \n    // Fill entries in other rows. \n    for (long i = 2; i <= n; i++) \n    { \n        // Fill entries in jth column using previous \n        // column values. \n        for (long j = 1; j <= k; j++) \n        { \n            // If first post is painted with jth color, \n            // number of ways to paint remaining posts \n            // is same as number of ways to paint \n            // n-1 posts with (k-1) colors. \n            dp[i][j] = dp[i - 1][j - 1] * (k - 1); \n  \n            // If first post is painted with some other \n            // color, number of ways to paint remaining \n            // posts is same as number of ways to paint \n            // n-1 posts with k colors. \n            dp[i][j] += dp[i - 1][",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\tlong total_count = diff_color_count + same_color_count;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = total_count * (k - 1);\n\t\ttotal_count = diff_color_count + same_color_count;\n\t}\n\treturn total_count;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    long same = 0, diff = k; \n  \n    for (long i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\treturn (diff_color_count + same_color_count);\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\treturn k * k * count_no_of_ways(n - 2, k);\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways to paint 1 post with k colors \n    dp[1] = k; \n  \n    // There are k ways to paint 2 posts with k colors \n    dp[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tlong same = 0;\n\tlong diff = k;\n\tlong total = k;\n\tfor (long i = 2; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count - diff_color_counts;\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint the first post (there is only one post) \n    dp[1] = k; \n  \n    // There are 0 ways for single post to paint the same color twice \n    dp[2] = k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tlong total = same + diff;\n\tfor (long i = 3; i <= n; i++) {\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\tlong same = 0, diff = k; \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k-1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n    // Create a table to store results of subproblems.  \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to color first post \n    dp[1] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count) condition \n    long same = 0, diff = k; \n  \n    // Fill for 2 posts onwards \n    for (long i = 2; i <= n; i++) { \n        // Current same is same as previous diff \n        same = diff; \n  \n        // We always have k-1 choices for next post \n        diff = dp[i - 1] * (k - 1); \n  \n        // Total choices till i. \n        dp[i] = (same + diff); \n    } \n  \n    return dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{ \n    // Create a table to store results of subproblems.  k+2 is used \n    // so that we can use modular arithmetic. i.e., we assume that \n    // the count can be very large \n    long dp[][] = new long[n+1][k+2]; \n  \n    // There are k ways to paint the first post (there is only \n    // one post) \n    for (long i = 1; i <= k; i++) \n        dp[1][i] = i; \n  \n    // There are 0 ways for any other post to paint 0th color \n    for (long i = 0; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // There is only one way to paint the 0th post i.e with 0th \n    // color \n    for (long j = 0; j <= k; j++) \n        dp[0][j] = 0; \n  \n    // Fill rest of the entries in table using recursive relation \n    // i is the current post and j is the current color \n    for (long i = 2; i <= n; i++) \n    { \n        for (long j = 1; j <= k; j++) \n        { \n            // If current color j is used, number of ways is same \n            // as number of ways to paint previous post with color \n            // j = dp[i-1][j] \n            // If current color j is not used, number of ways is \n            // (j-1)*dp[i-1][j-1] \n            dp[i][j] = (dp[i-1][j] + (j-1)*dp[i-1][j-1]) % 1000000007; \n        } \n    } \n  \n    // Return the number of ways for n posts with k colors \n    return dp[n][k]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of posts is directly used as row index and k as column index). \n\tlong dp[n + 1][k + 1]; \n\t\n\t// Initialize first column of dp table \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row of dp table \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[1][j] = j; \n\t\n\t// Fill entries in dp table using recursive relation \n\t// dp[i][j] = dp[i][j-1] + dp[i-1][k-1] + dp[i-1][k-2] + ... + dp[i-1][0] \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long j = 2; j <= k; j++) \n\t\t{ \n\t\t\tdp[i][j] = 0; \n\t\t\tfor (long x = 0; x < j; x++) \n\t\t\t\tdp[i][j] += dp[i - 1][x]; \n\t\t} \n\t} \n\t\n\t// Required number of ways \n\treturn dp[n][k]; \n} ",
    "{\n\tif(n == 0 || k == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor(long i = 2; i < n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i][j] will store count of ways to paint i posts \n\t// using j colors \n\tlong dp[n + 1][k + 1]; \n\t\n\t// There are k ways to paint 0th post \n\tfor (long i = 0; i <= k; i++) \n\t\tdp[0][i] = 0; \n\t\n\t// There is only one way to paint 0 posts \n\t// i.e. do not paint \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][0] = 0; \n\t\n\t// There is only one way to paint 1 post and that \n\t// is to use a color \n\tfor (long i = 1; i <= k; i++) \n\t\tdp[1][i] = i; \n\t\n\t// Fill rest of the entries in table using recursive \n\t// formula \n\tfor (long i = 2; i <= n; i++) \n\t\tfor (long j = 1; j <= k; j++) \n\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 1000000007; \n\t\n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of solutions for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simpliciy \n\t// (Number of columns is equal to number of colors \n\t// of posts and number of rows is one more than \n\t// number of posts) \n\tlong dp[][] = new long[n+1][k+1]; \n\t\n\t// Initialize first column of dp table \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row of dp table \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[1][j] = j; \n\t\n\t// Fill entries in dp table using recursive relation \n\t// dp[i][j] = dp[i-1][j-1] + dp[i-1][j]*(j-1); \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long j = 2; j <= k; j++) \n\t\t{ \n\t\t\tdp[i][j] = (dp[i-1][j-1] + (dp[i-1][j] * (j-1))) % 1000000007; \n\t\t} \n\t} \n\t\n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\telse if (n == 2) \n\t\treturn k * k;\n\telse \n\t{\n\t\tlong same = k;\n\t\tlong diff = k * (k - 1);\n\t\tfor (long i = 3; i <= n; i++) \n\t\t{\n\t\t\tlong temp = diff;\n\t\t\tdiff = (same + diff) * (k - 1);\n\t\t\tsame = temp;\n\t\t}\n\t\treturn same + diff;\n\t}\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of columns is equal to number of colors \n\t// of posts and number of rows is equal to number \n\t// of posts). The value of table[i][j] will be the \n\t// number of ways to paint the fence with i posts \n\t// and j colors \n\tlong[][] table = new long[n+1][k+1]; \n\t\n\t// There are k ways to paint the fence with 0 posts \n\tfor (long j = 0; j <= k; j++) \n\t\ttable[0][j] = 0; \n\t\n\t// There is only one way to paint 0 posts with 0 colors \n\tfor (long i = 0; i <= n; i++) \n\t\ttable[i][0] = 0; \n\t\n\t// There is only one way to paint 0 posts with 1 color \n\tfor (long i = 0; i <= n; i++) \n\t\ttable[i][1] = 1; \n\t\n\t// Fill rest of the entries in table using recursive \n\t// formula \n\tfor (long i = 1; i <= n; i++) \n\t\tfor (long j = 2; j <= k; j++) \n\t\t\ttable[i][j] = (j * table[i - 1][j] + \n\t\t\t\t\t\t\ttable[i - 1][j - 1]); \n\t\n\treturn table[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // b[i] will store count of solutions for i posts and k colors \n    long[] b = new long[n + 1]; \n  \n    // There is one way to paint 0 posts \n    b[0] = 0; \n  \n    // There is k ways to paint 1 post \n    b[1] = k; \n  \n    // There is k * k ways to paint 2 posts \n    // We always have two consecutive posts to be painted \n    // with same color \n    b[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n    { \n        // Calculate number of ways excluding i-th post \n        // with i-1 th post painted with same color \n        long diffColorCount = (k - 1) * (b[i - 1] + b[i - 2]); \n  \n        // Calculate number of ways including i-th post \n        // with i-1 th post painted with same color \n        long sameColorCount = (k - 1) * b[i - 2]; \n  \n        // Total number of ways is sum of ways excluding \n        // and including i-th post \n        b[i] = diffColorCount + sameColorCount; \n    } \n  \n    return b[n]; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n  \n    // There are k ways to paint the first post (first row of the table) \n    for (long i = 0; i <= k; i++) \n        dp[i] = i; \n  \n    // There is only one way to paint 0'th post (most left in the table) \n    // as there is nothing to the left of it, so 0 ways \n    dp[0] = 0; \n  \n    // Fill rest of the entries in table using recursive relation \n    // dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1) \n    for (long i = 3; i <= n; i++) \n        dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i][j] will store count of ways for i posts and j colors \n\tlong dp[n+1][k+1]; \n\t\n\t// There are k ways to paint 0 posts \n\tfor (long i = 0; i <= k; i++) \n\t\tdp[0][i] = 0; \n\t\n\t// There is only one way to paint 1 post with same color \n\tfor (long i = 0; i <= k; i++) \n\t\tdp[1][i] = i; \n\t\n\t// There are no ways for 0 posts and 1 color \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Fill rest of the entries in table using recursive relation \n\t// i: number of posts, j: number of colors \n\tfor (long i = 2; i <= n; i++) \n\t\tfor (long j = 2; j <= k; j++) \n\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]) % 1000000007; \n\t\n\treturn dp[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways to paint 1 post with k colors \n    dp[1] = k; \n  \n    // There are k ways to paint 2 posts with k colors \n    dp[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // One extra row and column are used for simplicity \n    // (Number of columns is equal to number of colors \n    // of posts and number of rows is equal to number \n    // of posts) \n    long dp[][] = new long[n][k]; \n  \n    // Initialize first column of dp table \n    for (int i = 0; i < n; i++) \n        dp[i][0] = 0; \n  \n    // Initialize first row of dp table \n    for (int j = 0; j < k; j++) \n        dp[0][j] = j; \n  \n    // Fill entries in dp table using recursive relation \n    // dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]*(k-1)) \n    for (int i = 1; i < n; i++) { \n        for (int j = 1; j < k; j++) { \n            dp[i][j] = (dp[i - 1][j - 1] + \n                        (dp[i - 1][j] * (k - 1)) % 1000000007) % 1000000007; \n        } \n    } \n  \n    // Required number of ways \n    return dp[n - 1][k - 1]; \n} ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // b[i] will store count of solutions for i posts and k colors \n    long b[n + 1]; \n    b[0] = 0; \n    b[1] = k; \n    b[2] = k + k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        b[i] = (k - 1) * (b[i - 1] + b[i - 2]); \n  \n    return b[n]; \n} ",
    "{ \n\tif (n == 1) \n\t\treturn k; \n\tif (n == 2) \n\t\treturn k + k * (k - 1); \n\tlong same = k; \n\tlong diff = k * (k - 1); \n\tfor (long i = 3; i <= n; i++) \n\t{ \n\t\tlong temp = diff; \n\t\tdiff = (same + diff) * (k - 1); \n\t\tsame = temp; \n\t} \n\treturn same + diff; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of posts is directly used as row index and \n\t// number of colors is directly used as column index). \n\t// The entries in 0th row and 0th column are never used. \n\tlong[][] dp = new long[n+1][k+1]; ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i][j] will store count of ways for i posts \n\t// and k colors \n\tlong[][] dp = new long[n + 1][k + 1]; ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn (diff_color_count + same_color_count);\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0th post \n    dp[0] = k; \n  \n    // There are 0 ways for single post to paint \n    // same color as previous one \n    dp[1] = k; \n  \n    // There are k * k ways for 2 posts to paint \n    // different colors \n    dp[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{ \n    long same = 0, diff = k; \n  \n    for (long i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // b[i] will store count of solutions for i posts and k colors \n    long b[n+1]; \n    b[0] = 0; \n    b[1] = k; \n    b[2] = k + (k * (k - 1)); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        b[i] = (k - 1) * (b[i - 1] + b[i - 2]); \n  \n    return b[n]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 2; i < n; ++i) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\tlong same = k;\n\tlong diff = k*(k-1);\n\tlong total = same + diff;\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tsame = diff;\n\t\tdiff = total*(k-1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 1) return k;\n\tif(n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(int i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (int i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count - diff_color_counts;\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simplicity  \n\t// (Number of columns is equal to number of colors  \n\t// of posts and number of rows is one more than  \n\t// number of posts)  \n\tlong dp[n + 1][k + 1]; \n\t\n\t// Initialize first column of dp table  \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row of dp table  \n\tfor (long j = 0; j <= k; j++) \n\t\tdp[1][j] = j; \n\t\n\t// Fill entries in dp table using recursive relation  \n\t// dp[i][j] = dp[i][j-1] + dp[i-1][k-j];  \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long j = 2; j <= k; j++) \n\t\t{ \n\t\t\tdp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % 1000000007; \n\t\t} \n\t} \n\t\n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = total_counts * (k - 1);\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// b[i] will store count of solutions for i posts and k colors \n\tlong[] b = new long[n + 1]; ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of columns is equal to number of colors \n\t// of posts and number of rows is equal to number \n\t// of posts) \n\tlong[][] dp = new long[n + 1][k + 1]; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // b[i] will store count of solutions for i posts and k colors \n    long b[n+1]; \n    b[0] = 0; \n    b[1] = k; \n    b[2] = k + (k * (k - 1)); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        b[i] = (k - 1) * (b[i - 1] + b[i - 2]); \n  \n    return b[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same = 0, diff = k; ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to color first post \n    dp[1] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count and adjacent) \n    // condition \n    long same = 0, diff = k; \n  \n    // Fill for 2 posts onwards \n    for (long i = 2; i <= n; i++) { \n        // Current same is same as previous diff \n        same = diff; \n  \n        // We always have k-1 choices for next post \n        diff = dp[i - 1] * (k - 1); \n  \n        // Total choices till i. \n        dp[i] = (same + diff); \n    } \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n    // Create a table to store results of subproblems.  k+2 is used \n    // so that we can use modular arithmetic. i.e., we assume that the \n    // count can be very large \n    long dp[][] = new long[n + 1][k + 2]; \n  \n    // There are k ways to paint the first post (there is only one post) \n    for (long j = 1; j <= k; j++) \n        dp[1][j] = 1; \n  \n    // There is only one way to paint zero posts (there are no posts) \n    for (long i = 0; i <= n; i++) \n        dp[i][1] = 1; \n  \n    // Fill rest of the entries in table using recursive relation \n    // i: number of posts \n    // j: number of colors \n    for (long i = 2; i <= n; i++) \n        for (long j = 2; j <= k; j++) \n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 1000000007; \n  \n    // Return the ways when there are n posts and k colors \n    return dp[n][k]; \n} ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems.  k+2 rows are needed \n    // as the calculation is to be done on basis of k and k-1 \n    long dp[][] = new long[k+2][n+1]; \n  \n    // Initialize first column of all rows as same \n    for (int i = 0; i<=k+1; i++) \n        dp[i][1] = i; \n  \n    // Fill entries in other columns \n    for (int j=2; j<=n; j++) \n        for (int i=1; i<=k; i++) \n            dp[i][j] = (dp[i-1][j-1] + dp[i][j-1])%1000000007; \n  \n    // There will be k ways for coloring first post, k-1 ways for second \n    // post... 1 way for k'th post.  Total ways will be k*k-1*...*1 \n    long total = 1; \n    for (int i = 1; i<=k; i++) \n        total = (total*i)%1000000007; \n  \n    // Initialize result \n    long res = total; \n  \n    // Calculate value of (total - (k-1)*(k-1)...*1) and \n    // (total - (k-2)*(k-2)...*1) and so on. Add the values calculated \n    // in above steps \n    for (int j=2; j<=n; j++) \n    { \n        res = (res + (total - dp[k][j])%1000000007)%1000000007; \n        total = (total*k)%1000000007; \n    } \n  \n    return res; \n} ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn (diff_color_count + same_color_count);\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\t// same[i] means the ith post has the same color with the (i-1)th post.\n\tlong same = k;\n\t// diff[i] means the ith post has a different color with the (i-1)th post.\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\t// For the ith post, the number of ways of painting ith post\n\t\t// with the same color with the (i-1)th post is same[i-1].\n\t\t//\n\t\t// The number of ways of painting ith post with a different color\n\t\t// with the (i-1)th post is diff[i-1].\n\t\t//\n\t\t// So total ways of painting ith post, diff[i] = (same[i-1] + diff[i-1]) * (k-1)\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems.  \n    // One extra row and column are used for simplicity  \n    // (Number of posts is directly used as row index and  \n    // number of colors as column index). The entries in  \n    // 0th row and 0th column are never used.  \n    long[][] dp = new long[n + 1][k + 1]; \n  \n    // Fill entries in first column  \n    for (long i = 0; i <= n; i++) \n        dp[i][1] = 1; \n  \n    // Fill entries in first row  \n    for (long j = 0; j <= k; j++) \n        dp[1][j] = j; \n  \n    // Fill rest of the entries in dp[][]  \n    for (long i = 2; i <= n; i++) \n        for (long j = 2; j <= k; j++) \n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j] -  \n                        dp[i - 1][j - 1]) % 1000000007; \n  \n    return dp[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems.  k+2 rows are needed \n    // as n can be maximum k and need to store results for n = 0 and n = 1 \n    long[][] dp = new long[k+2][n+1]; \n  \n    // Initialize first column of all rows as same as with one post and k colors \n    for (long i = 0; i <= k; i++) \n        dp[i][1] = i; \n  \n    // Fill entries in other columns. \n    for (long i = 2; i <= n; i++) \n    { \n        for (long j = 0; j <= k; j++) \n        { \n            // If first color (j = 0) then only one way to paint as all posts \n            // have same color. \n            if (j == 0) \n                dp[j][i] = dp[j+1][i-1]; \n  \n            // If second color (j = 1) then two ways to paint as adjacent \n            // posts can have diff color. \n            else if (j == 1) \n                dp[j][i] = (dp[j-1][i-1] + dp[j+1][i-1]); \n  \n            // If third color (j = 2) then three ways to paint as adjacent \n            // posts can have diff color. \n            else if (j == 2) \n                dp[j][i] = (dp[j-1][i-1] + dp[j+1][i-1] + dp[j][i-1]); \n  \n            // If fourth color (j = 3) then four ways to paint as adjacent \n            // posts can have diff color. \n            else if (j == 3) \n                dp[j][i] = (dp[j-1][i-1] + dp[j+1][i-1] + dp[j][i-1] + dp[j-2][i-1]); \n  \n            // If fifth color (j = 4) then five ways to paint as adjacent \n           ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of posts is directly used as row index and \n\t// number of colors is directly used as column index). \n\t// The entries in 0th row and 0th column are never used. \n\tlong[][] dp = new long[n + 1][k + 1]; ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems.  k+2 is used \n    // so that we can use modular arithmetic. i.e., we assume that \n    // the count can be very large \n    long dp[][] = new long[n + 1][k + 2]; \n  \n    // There are k ways to color first post \n    for (long j = 1; j <= k; j++) \n        dp[1][j] = 1; \n  \n    // There are 0 ways for any other post to violate \n    // the no-adjacent-same-color rule \n    for (long i = 2; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Fill for rest of the posts \n    for (long i = 2; i <= n; i++) \n    { \n        // There are two cases for coloring the ith post \n        // a) Violating the rule by same color as (i-1)th post \n        // b) Not violating the rule \n        for (long j = 1; j <= k; j++) \n        { \n            // Case a) \n            long x = dp[i - 1][j] * (k - 1); \n  \n            // Case b) \n            long y = dp[i - 1][j - 1] * (k - 1); \n  \n            // Total count is sum of a) and b) \n            // taking modulo \n            dp[i][j] = (x + y) % 1000000007; \n        } \n    } \n  \n    // Required \n    long ans = 0; \n    for (long j = 1; j <= k; j++) \n        ans = (ans + dp[n][j]) % 1000000007; \n    return ans; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways to paint 1 post with k colors \n    dp[1] = k; \n  \n    // There are k ways to paint 2 posts with k colors \n    dp[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tlong total = same + diff;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t\ttotal = same + diff;\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // b[i] will store count of solutions for i posts and k colors \n    long[] b = new long[n + 1]; \n  \n    // There is one way to paint 0 posts \n    b[0] = 0; \n  \n    // There is k ways to paint 1 post \n    b[1] = k; \n  \n    // There is k * k ways to paint 2 posts \n    // We always have two consecutive posts to be painted \n    // with same color \n    b[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) { \n        // Calculate number of ways excluding i-th post \n        // with i-1 th post painted with same color \n        long diffColorCount = (k - 1) * (b[i - 1] + b[i - 2]); \n  \n        // Calculate number of ways including i-th post \n        // with i-1 th post painted with same color \n        long sameColorCount = (k - 1) * b[i - 2]; \n  \n        // Total number of ways is sum of ways excluding \n        // and including i-th post \n        b[i] = diffColorCount + sameColorCount; \n    } \n  \n    return b[n]; \n} ",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n  \n    // There are k ways to paint the first post (first row of the table) \n    for (long i = 0; i <= k; i++) \n        dp[i] = i; \n  \n    // There is only one way to paint 0'th post (most left post in the table) \n    // with any of the k colors \n    for (long i = k + 1; i <= n; i++) \n        dp[i] = 0; \n  \n    // Fill rest of the entries in table using recursive relation \n    // dp[i] = (dp[i - 1] + dp[i - k]) % 1000000007 \n    for (long i = k + 2; i <= n; i++) \n        dp[i] = (dp[i - 1] + dp[i - k]) % 1000000007; \n  \n    // Return the result for n posts and k colors \n    return dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of solutions for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0th post \n    dp[0] = k; \n  \n    // There are 0 ways for single post to \n    // violate (same color_count) property \n    dp[1] = k; \n  \n    // There are 0 ways for two posts to \n    // violate (same color_count) property \n    dp[2] = k * (k - 1); \n  \n    // Fill for 3 to n posts \n    for (int i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n  \n    // There are k ways to paint the first post (first row of the table) \n    for (long i = 0; i <= k; i++) \n        dp[i] = i; \n  \n    // There is only one way to paint 0 posts (second row of the table) \n    dp[0] = 1; \n  \n    // Fill rest of the entries in table using recursive relation \n    // i is the number of posts and j is the number of colors \n    for (long i = 2; i <= n; i++) \n        for (long j = 1; j <= k; j++) \n            dp[i] = (dp[i] + dp[i - 1] * (k - 1)) % 1000000007; \n  \n    // There are dp[n] ways for n posts and k colors \n    return dp[n]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways to paint 1 post with k colors \n    dp[1] = k; \n  \n    // There are k ways to paint 2 posts with k colors \n    dp[2] = k * k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// b[i] will store count of solutions for i posts and k colors \n\tlong b[n + 1]; \n\tb[0] = b[1] = k; \n\tb[2] = k + (k * (k - 1)); ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n    long same = 0, diff = k; \n  \n    for (long i = 2; i <= n; i++) \n    { \n        long temp = diff; \n        diff = (same + diff) * (k-1); \n        same = temp; \n    } \n  \n    return same + diff; \n} ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 2; i < n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn (diff_color_count + same_color_count);\n}",
    "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_count = k * (k - 1);\n\tlong same_color_count = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_count;\n\t\tdiff_color_count = (diff_color_count + same_color_count) * (k - 1);\n\t\tsame_color_count = temp;\n\t}\n\t\n\treturn (diff_color_count + same_color_count);\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simplicity \n\t// (Number of posts is directly used as row index and k as column index). \n\tlong dp[n + 1][k + 1]; ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n+1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint 0 posts \n    dp[0] = k; \n  \n    // There are 0 ways to paint 1 post with k colors \n    dp[1] = k; \n  \n    // There are k*k ways to paint 2 posts with k colors \n    dp[2] = k*k; \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i-1] + dp[i-2]); \n  \n    return dp[n]; \n} ",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn diff + same;\n}",
    "{\n\tif(n == 1) return k;\n\tif(n == 2) return k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k-1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems.  \n    // One extra row and column are used for simplicity  \n    // (Number of posts is directly used as row index and  \n    // number of colors is directly used as column index).  \n    // The entries in 0th row and 0th column are never used.  \n    long[][] dp = new long[n + 1][k + 1]; \n  \n    // Initialize first column with all 0s. The 0th  \n    // entry of first column doesn't matter as numbers  \n    // in 0th row are all 0.  \n    for (long i = 0; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Initialize first row with all 1s. The 0th  \n    // entry of first row doesn't matter as numbers  \n    // in 0th column are all 0.  \n    for (long j = 0; j <= k; j++) \n        dp[0][j] = 0; \n  \n    // Fill entries in bottom up manner  \n    for (long i = 1; i <= n; i++) { \n        for (long j = 1; j <= k; j++) { \n            // There are two cases,  \n            // a) Last two posts have same color.  \n            // b) Last two posts have different colors.  \n  \n            // Case a) Last two have same color.  \n            long same = dp[i - 1][j - 1]; \n  \n            // Case b) Last two have different colors.  \n            long diff = (dp[i - 1][j] * (j - 1)); \n  \n            // total count  \n            dp[i][j] = same + diff; \n        } \n    } \n  \n    return dp[n][k]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simpilicity \n\t// (Number of columns is equal to number of colors \n\t// of the fence plus 1) \n\tlong[][] dp = new long[n+1][k+1]; \n\t\n\t// There are k ways to color first post \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// There is only one way to color 0th post with \n\t// any of the k colors \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Fill rest of the entries in table using recursive \n\t// formula \n\tfor (long i = 2; i <= n; i++) \n\t\tfor (long c = 2; c <= k; c++) \n\t\t\tdp[i][c] = (dp[i-1][c] + dp[i-1][c-1]) % 1000000007; \n\t\n\t// There are n*k ways to color n posts \n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\tlong total = 0;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\ttotal = diff + same;\n\t\tsame = diff;\n\t\tdiff = total * (k - 1);\n\t}\n\treturn total;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n  \n    // There are k ways to color first post (first row of dp table) \n    for (long i = 0; i <= k; i++) \n        dp[i] = i; \n  \n    // There are 0 ways for 0 posts and k > 0. \n    for (long i = 0; i <= n; i++) \n        dp[i][0] = 0; \n  \n    // Fill rest of the entries in table using recursive relation \n    // dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])*(k-1) \n    for (long i = 3; i <= n; i++) \n        for (long j = 1; j <= k; j++) \n            dp[i][j] = (dp[i - 1][j - 1] +  \n                        dp[i - 1][j]) * (k - 1); \n  \n    // Total ways are sum of all values in last row. \n    return dp[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems. \n    // dp[i] will store count of ways for i posts and k colors \n    long dp[n + 1]; \n    memset(dp, 0, sizeof(dp)); \n  \n    // There are k ways to paint the first post (there is only one post) \n    dp[1] = k; \n  \n    // There are 0 ways for single post to paint the same color \n    // as previous post \n    dp[2] = k + (k * (k - 1)); \n  \n    // Fill for 3 to n posts \n    for (long i = 3; i <= n; i++) \n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n  \n    return dp[n]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// dp[i] will store count of solutions for i posts and k colors \n\tlong dp[n+1]; \n\tmemset(dp, 0, sizeof(dp)); ",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0) \n\t\treturn 0;\n\tif (n == 1) \n\t\treturn k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn (same + diff);\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tauto temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; ++i)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) return k;\n\tif (n == 2) return k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t{\n\t\treturn k;\n\t}\n\tif (n == 2) \n\t{\n\t\treturn k * k;\n\t}\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// k+1 is used instead of k since the values \n\t// starting from 0 are used and there are k+1 \n\t// different colors. \n\tlong dp[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simplicity (Number of posts is directly used as row index and k as column index). The entries in 0th row and 0th column are never used. \n\tlong[][] dp = new long[n + 1][k + 1]; \n\t\n\t// Fill entries in first column as 1. There is only one way to paint 0 posts with any color. \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][0] = 0; \n\t\n\t// Fill entries in first row as 1. There is only one way to paint 0 posts with any color. \n\tfor (long i = 0; i <= k; i++) \n\t\tdp[0][i] = 0; \n\t\n\t// Fill rest of the entries in table using recursive relation \n\t// i: number of posts, j: number of colors \n\tfor (long i = 1; i <= n; i++) \n\t{ \n\t\tfor (long j = 1; j <= k; j++) \n\t\t{ \n\t\t\t// When the last two posts have different colors \n\t\t\tlong diff_color_count = dp[i - 1][j - 1] * (j - 1); \n\t\t\t\n\t\t\t// When the last two posts have same color \n\t\t\tlong same_color_count = dp[i - 1][j] * (j - 1); \n\t\t\t\n\t\t\t// total count is sum of ways, painting such that last two have different colors and ways, painting such that last two have same colors \n\t\t\tdp[i][j] = diff_color_count + same_color_count; \n\t\t} \n\t} \n\t\n\treturn dp[n][k]; \n} ",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simpilicity \n\t// (Number of columns is equal to number of colors \n\t// of the fence plus 1 and same for rows). The value of \n\t// dp[i][j] will be the number of ways if the fence has \n\t// i posts and j colors \n\tlong[][] dp = new long[n + 1][k + 1]; ",
    "{\n\tif (n == 0) return 0;\n\tif (n == 1) return k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k*k;\n\t\n\tlong same = k;\n\tlong diff = k*(k-1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff)*(k-1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}"
  ]
}