{
  "name": "mbpp_291_count_no_of_ways",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\t\n*/\nlong count_no_of_ways(long n, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = count_no_of_ways;\n\n    assert(candidate(2L, 4L) == 16L);\n    assert(candidate(3L, 2L) == 6L);\n    assert(candidate(4L, 4L) == 228L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_count = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = diff_color_counts * (k - 1);\n\t\tsame_color_counts = total_count * (k - 1);\n\t\ttotal_count = diff_color_counts + same_color_counts;\n\t}\n\treturn total_count;\n}",
    "{\n\tif(n == 1)\n\t\treturn k;\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong diff = k * (k - 1);\n\tlong same = k;\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tauto temp = diff;\n\t\tdiff = (diff + same) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn diff + same;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; ++i) \n\t{\n\t\tauto temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\t\n\treturn (diff_color_counts + same_color_counts);\n}",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// dp[i] will store count of ways for i posts and k colors \n\tlong dp[n + 1]; \n\tmemset(dp, 0, sizeof(dp)); \n\t\n\t// There are k ways to paint 0 posts \n\tdp[0] = 0; \n\t\n\t// There are k ways to paint 1 posts with k colors \n\tdp[1] = k; \n\t\n\t// There are 0 ways for 1 post to paint with 1 color \n\tdp[2] = k + k * (k - 1); \n\t\n\t// Fill for 2 posts onwards \n\tfor (long i = 3; i <= n; i++) \n\t\tdp[i] = (k - 1) * (dp[i - 1] + dp[i - 2]); \n\t\n\treturn dp[n]; \n} ",
    "{\n\tif(n == 1)\n\t\treturn k;\n\t\n\tif(n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor(long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\t// One extra row and column are used for simpilicity \n\t// (Number of columns is equal to number of colors \n\t// of the fence plus 1) \n\tlong dp[n + 1][k + 1]; \n\t\n\t// Initialize first column of all rows as same color \n\t// (one way to paint the fence) \n\tfor (long i = 0; i <= n; i++) \n\t\tdp[i][1] = 1; \n\t\n\t// Initialize first row, except dp[0][0], as 0. The \n\t// dp[0][0] is initialized as 0 and not 1 because \n\t// the zero post has one color (itself), we can't \n\t// paint the zero post with any other color. \n\tfor (long j = 1; j <= k; j++) \n\t\tdp[0][j] = 0; \n\t\n\t// Fill rest of the entries in dp[][] \n\tfor (long i = 1; i <= n; i++) \n\t\tfor (long j = 2; j <= k; j++) \n\t\t\tdp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]); \n\t\n\treturn dp[n][k]; \n} ",
    "{ \n    // Create a table to store results of subproblems.  k+2 is used \n    // so that we can use modular arithmetic. i.e., we assume that the \n    // count is for i-2 and i-1 \n    long dp[][] = new long[n+1][k+2]; \n  \n    // There are k ways to color first post \n    for (long j = 1; j <= k; j++) \n        dp[1][j] = 1; \n  \n    // There is only one way to color the first two posts in \n    // the same color \n    for (long i = 2; i <= n; i++) \n        dp[i][2] = k; \n  \n    // Fill rest of the entries in table using recursive relation \n    // explained above. \n    for (long i = 3; i <= n; i++) \n        for (long j = 1; j <= k; j++) \n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % 1000000007; \n  \n    // sum of all the entries of last row is our answer \n    long ans = 0; \n    for (long j = 1; j <= k; j++) \n        ans = (ans + dp[n][j]) % 1000000007; \n  \n    return ans; \n} ",
    "{ \n\t// Create a table to store results of subproblems.  \n\t// One extra row and column are used for simpilicity  \n\t// (Number of posts is directly used as row index and  \n\t// number of colors is directly used as column index).  \n\t// The entries in 0th row and 0th column are never used.  \n\tlong[][] dp = new long[n + 1][k + 1]; \n\t\n\t// Base cases  \n\t// If number of posts is 0 then there are 0 ways  \n\t// If number of posts is 1 then there are k ways  \n\tfor (long c = 1; c <= k; c++) \n\t\tdp[1][c] = 1; \n\t\n\t// Fill rest of the entries in table using recursive  \n\t// formula  \n\tfor (long i = 2; i <= n; i++) \n\t{ \n\t\tfor (long c = 1; c <= k; c++) \n\t\t{ \n\t\t\t// Ways when the last post has color c \n\t\t\tlong diffColorCount = (dp[i - 1][c] * (k - 1)); \n\t\t\t\n\t\t\t// Ways when the last two posts have same color c \n\t\t\tlong sameColorCount = dp[i - 1][c - 1]; \n\t\t\t\n\t\t\t// Total ways till i posts and last post has color c \n\t\t\tdp[i][c] = diffColorCount + sameColorCount; \n\t\t} \n\t} \n\t\n\t// Return total ways for n posts and k colors \n\treturn dp[n][k]; \n} ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\treturn same + diff;\n}",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color = k * (k - 1);\n\tlong same_color = k;\n\t\n\tfor (long i = 3; i <= n; i++)\n\t{\n\t\tlong temp = diff_color;\n\t\tdiff_color = (diff_color + same_color) * (k - 1);\n\t\tsame_color = temp;\n\t}\n\t\n\treturn diff_color + same_color;\n}",
    "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong same = k;\n\tlong diff = k * (k - 1);\n\t\n\tfor (long i = 3; i <= n; i++) {\n\t\tlong temp = diff;\n\t\tdiff = (same + diff) * (k - 1);\n\t\tsame = temp;\n\t}\n\t\n\treturn same + diff;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1) \n\t\treturn k;\n\tif (n == 2) \n\t\treturn k * k;\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\tlong total_counts = diff_color_counts + same_color_counts;\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = total_counts * (k - 1);\n\t\ttotal_counts = diff_color_counts + same_color_counts;\n\t}\n\treturn total_counts;\n}",
    "{ \n\t// Create a table to store results of subproblems. \n\tlong dp[][] = new long[n + 1][k + 1]; \n\tlong same, diff; ",
    "{\n\tif (n == 1)\n\t\treturn k;\n\tif (n == 2)\n\t\treturn k * k;\n\t\n\tlong diff_color_counts = k * (k - 1);\n\tlong same_color_counts = k;\n\t\n\tfor (long i = 3; i <= n; i++) \n\t{\n\t\tlong temp = diff_color_counts;\n\t\tdiff_color_counts = (diff_color_counts + same_color_counts) * (k - 1);\n\t\tsame_color_counts = temp;\n\t}\n\treturn (diff_color_counts + same_color_counts);\n}"
  ]
}