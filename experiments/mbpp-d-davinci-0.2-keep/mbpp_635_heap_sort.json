{
  "name": "mbpp_635_heap_sort",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to sort the given list.\n\t\n*/\nlong[] heap_sort(long[] iterable) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = heap_sort;\n\n    assert(candidate([1L, 3L, 5L, 7L, 9L, 2L, 4L, 6L, 8L, 0L]) == [0L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]);\n    assert(candidate([25L, 35L, 22L, 85L, 14L, 65L, 75L, 25L, 58L]) == [14L, 22L, 25L, 25L, 35L, 58L, 65L, 75L, 85L]);\n    assert(candidate([7L, 1L, 9L, 5L]) == [1L, 5L, 7L, 9L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong heap_size = 0;\n\tforeach(long i; iterable)\n\t{\n\t\theap_size++;\n\t\theap[heap_size] = i;\n\t\tlong j = heap_size;\n\t\twhile(j > 1 && heap[j] > heap[j/2])\n\t\t{\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[j/2];\n\t\t\theap[j/2] = temp;\n\t\t\tj = j/2;\n\t\t}\n\t}\n\t\n\tlong result_size = 0;\n\twhile(heap_size > 0)\n\t{\n\t\tresult_size++;\n\t\tresult[result_size] = heap[1];\n\t\theap[1] = heap[heap_size];\n\t\theap_size--;\n\t\tlong j = 1;\n\t\twhile(j <= heap_size)\n\t\t{\n\t\t\tlong k = j;\n\t\t\tif(2*j <= heap_size && heap[2*j] > heap[k])\n\t\t\t{\n\t\t\t\tk = 2*j;\n\t\t\t}\n\t\t\tif(2*j+1 <= heap_size && heap[2*j+1] > heap[k])\n\t\t\t{\n\t\t\t\tk = 2*j+1;\n\t\t\t}\n\t\t\tif(k == j)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[k];\n\t\t\theap[k] = temp;\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong[] heap_size = new long[1];\n\theap_size[0] = 0;\n\tfor (long i = 0; i < iterable.length; i++) \n\t{\n\t\theap_insert(heap, iterable[i], heap_size);\n\t}\n\tfor (long i = 0; i < iterable.length; i++) \n\t{\n\t\tresult[i] = heap_extract_max(heap, heap_size);\n\t}\n\treturn result;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tlong[] sorted = new long[iterable.length];\n\t\n\t// Copy the iterable to the heap\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\t// Build the heap\n\tfor (int i = 0; i < heap.length; i++)\n\t{\n\t\theapify(heap, i);\n\t}\n\t\n\t// Sort the heap\n\tfor (int i = 0; i < heap.length; i++)\n\t{\n\t\tsorted[i] = heap[0];\n\t\theap[0] = heap[heap.length - i - 1];\n\t\theapify(heap, 0, heap.length - i - 1);\n\t}\n\t\n\treturn sorted;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tlong[] result = new long[iterable.length];\n\t\n\tforeach(long i; 0..iterable.length)\n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\tforeach(long i; 0..iterable.length)\n\t{\n\t\tlong parent = (i - 1) / 2;\n\t\tlong child = i;\n\t\t\n\t\twhile(parent >= 0)\n\t\t{\n\t\t\tif(heap[parent] < heap[child])\n\t\t\t{\n\t\t\t\tlong temp = heap[parent];\n\t\t\t\theap[parent] = heap[child];\n\t\t\t\theap[child] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tchild = parent;\n\t\t\tparent = (parent - 1) / 2;\n\t\t}\n\t}\n\t\n\tlong index = iterable.length - 1;\n\t\n\twhile(index >= 0)\n\t{\n\t\tresult[index] = heap[0];\n\t\theap[0] = heap[index];\n\t\theap[index] = 0;\n\t\t\n\t\tlong parent = 0;\n\t\tlong child = 1;\n\t\t\n\t\twhile(child < index)\n\t\t{\n\t\t\tif(child + 1 < index && heap[child] < heap[child + 1])\n\t\t\t{\n\t\t\t\tchild++;\n\t\t\t}\n\t\t\t\n\t\t\tif(heap[parent] < heap[child])\n\t\t\t{\n\t\t\t\tlong temp = heap[parent];\n\t\t\t\theap[parent] = heap[child];\n\t\t\t\theap[child] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tparent = child;\n\t\t\tchild = 2 * child + 1;\n\t\t}\n\t\t\n\t\tindex--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong heap_size = 0;\n\t\n\tforeach(long i; iterable)\n\t{\n\t\theap_size++;\n\t\theap[heap_size] = i;\n\t\tlong j = heap_size;\n\t\twhile(j > 1 && heap[j] > heap[j/2])\n\t\t{\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[j/2];\n\t\t\theap[j/2] = temp;\n\t\t\tj = j/2;\n\t\t}\n\t}\n\t\n\tlong i = 0;\n\twhile(heap_size > 0)\n\t{\n\t\tresult[i] = heap[1];\n\t\ti++;\n\t\theap[1] = heap[heap_size];\n\t\theap_size--;\n\t\tlong j = 1;\n\t\twhile(j <= heap_size)\n\t\t{\n\t\t\tlong max_index = j;\n\t\t\tif(j*2 <= heap_size && heap[j*2] > heap[max_index])\n\t\t\t\tmax_index = j*2;\n\t\t\tif(j*2+1 <= heap_size && heap[j*2+1] > heap[max_index])\n\t\t\t\tmax_index = j*2+1;\n\t\t\tif(max_index == j)\n\t\t\t\tbreak;\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[max_index];\n\t\t\theap[max_index] = temp;\n\t\t\tj = max_index;\n\t\t}\n\t}\n\treturn result;\n}",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong heap_size = 0;\n\t\n\tforeach(long item; iterable) \n\t{\n\t\theap_size = heap_insert(heap, heap_size, item);\n\t}\n\t\n\tforeach(ref long item; result) \n\t{\n\t\titem = heap_extract(heap, heap_size);\n\t\theap_size--;\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tforeach(i, item; iterable)\n\t{\n\t\theap[i] = item;\n\t\theapify(heap, i);\n\t}\n\t\n\tlong[] result = new long[iterable.length];\n\tforeach(i, item; iterable)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[heap.length - 1 - i];\n\t\theapify(heap, heap.length - 1 - i);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tlong[] sorted = new long[iterable.length];\n\t\n\tforeach(long i; iterable)\n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\tfor(long i = 0; i < iterable.length; i++)\n\t{\n\t\tsorted[i] = heap[0];\n\t\theap[0] = heap[heap.length - 1];\n\t\theap.length--;\n\t\theapify(heap);\n\t}\n\t\n\treturn sorted;\n}",
    "{\n\tint n = iterable.length;\n\tfor (int i = n / 2 - 1; i >= 0; i--) \n\t{\n\t\theapify(iterable, n, i);\n\t}\n\tfor (int i = n - 1; i >= 0; i--) \n\t{\n\t\tlong temp = iterable[0];\n\t\titerable[0] = iterable[i];\n\t\titerable[i] = temp;\n\t\theapify(iterable, i, 0);\n\t}\n\treturn iterable;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tforeach(i, item; iterable)\n\t{\n\t\theap[i] = item;\n\t}\n\t\n\tfor(long i = heap.length / 2; i >= 0; i--)\n\t{\n\t\theap = heapify(heap, i);\n\t}\n\t\n\tfor(long i = heap.length - 1; i >= 0; i--)\n\t{\n\t\theap = swap(heap, 0, i);\n\t\theap = heapify(heap, 0);\n\t}\n\t\n\treturn heap;\n}",
    "{\n\tlong[] result;\n\tlong[] heap;\n\tlong[] tmp;\n\tlong i;\n\tlong j;\n\tlong k;\n\tlong n;\n\tlong tmp_value;\n\t\n\tn = iterable.length;\n\tresult = new long[n];\n\theap = new long[n];\n\t\n\tfor (i = 0; i < n; i++) \n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\tfor (i = n / 2 - 1; i >= 0; i--) \n\t{\n\t\tk = i;\n\t\ttmp_value = heap[i];\n\t\twhile (k * 2 + 1 < n) \n\t\t{\n\t\t\tj = k * 2 + 1;\n\t\t\tif (j < n - 1) \n\t\t\t{\n\t\t\t\tif (heap[j] < heap[j + 1]) \n\t\t\t\t{\n\t\t\t\t\tj += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_value < heap[j]) \n\t\t\t{\n\t\t\t\theap[k] = heap[j];\n\t\t\t\tk = j;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\theap[k] = tmp_value;\n\t}\n\t\n\tfor (i = n - 1; i > 0; i--) \n\t{\n\t\ttmp_value = heap[i];\n\t\theap[i] = heap[0];\n\t\tk = 0;\n\t\twhile (k * 2 + 1 < i) \n\t\t{\n\t\t\tj = k * 2 + 1;\n\t\t\tif (j < i - 1) \n\t\t\t{\n\t\t\t\tif (heap[j] < heap[j + 1]) \n\t\t\t\t{\n\t\t\t\t\tj += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_value < heap[j]) \n\t\t",
    "{\n\tlong[] result = new long[iterable.length];\n\tforeach(i, item; iterable)\n\t{\n\t\tresult[i] = item;\n\t}\n\t\n\tlong[] heap = new long[result.length];\n\t\n\tlong heap_size = 0;\n\t\n\tforeach(i, item; result)\n\t{\n\t\theap_size++;\n\t\theap[heap_size] = item;\n\t\tlong j = heap_size;\n\t\twhile(j > 1)\n\t\t{\n\t\t\tif(heap[j] > heap[j/2])\n\t\t\t{\n\t\t\t\tlong temp = heap[j];\n\t\t\t\theap[j] = heap[j/2];\n\t\t\t\theap[j/2] = temp;\n\t\t\t\tj = j/2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tforeach(i, item; result)\n\t{\n\t\tresult[i] = heap[1];\n\t\theap[1] = heap[heap_size];\n\t\theap_size--;\n\t\tlong j = 1;\n\t\twhile(j < heap_size)\n\t\t{\n\t\t\tif(heap[j] < heap[j*2] || heap[j] < heap[j*2+1])\n\t\t\t{\n\t\t\t\tif(heap[j*2] > heap[j*2+1])\n\t\t\t\t{\n\t\t\t\t\tlong temp = heap[j];\n\t\t\t\t\theap[j] = heap[j*2];\n\t\t\t\t\theap[j*2] = temp;\n\t\t\t\t\tj = j*2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlong temp = heap[j];\n\t\t\t\t\theap[j] = heap[j*2+1];\n\t\t\t\t\theap[j*2+1] = temp",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\t\n\t// build heap\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\theap[i] = iterable[i];\n\t\tint j = i;\n\t\twhile (j > 0)\n\t\t{\n\t\t\tint parent = (j - 1) / 2;\n\t\t\tif (heap[j] > heap[parent])\n\t\t\t{\n\t\t\t\tlong temp = heap[j];\n\t\t\t\theap[j] = heap[parent];\n\t\t\t\theap[parent] = temp;\n\t\t\t\tj = parent;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// sort heap\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\tresult[i] = heap[0];\n\t\theap[0] = heap[iterable.length - i - 1];\n\t\tint j = 0;\n\t\twhile (j < iterable.length - i - 1)\n\t\t{\n\t\t\tint left = 2 * j + 1;\n\t\t\tint right = 2 * j + 2;\n\t\t\tint largest = j;\n\t\t\tif (left < iterable.length - i - 1 && heap[left] > heap[largest])\n\t\t\t{\n\t\t\t\tlargest = left;\n\t\t\t}\n\t\t\tif (right < iterable.length - i - 1 && heap[right] > heap[largest])\n\t\t\t{\n\t\t\t\tlargest = right;\n\t\t\t}\n\t\t\tif (largest != j)\n\t\t\t{\n\t\t\t\tlong temp = heap[j];\n\t\t\t\theap[j] = heap[largest];\n\t\t\t\theap[largest] = temp;\n\t\t\t\tj = largest;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n",
    "{\n\tlong[] result = new long[iterable.length];\n\t\n\t// Create a heap\n\tHeap heap = new Heap();\n\t\n\t// Insert all elements into the heap\n\tforeach(elem; iterable)\n\t{\n\t\theap.insert(elem);\n\t}\n\t\n\t// Extract all elements from the heap\n\tfor(int i = 0; i < iterable.length; i++)\n\t{\n\t\tresult[i] = heap.extract_min();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong heap_size = 0;\n\t\n\tforeach(long i; iterable)\n\t{\n\t\theap_size++;\n\t\theap[heap_size] = i;\n\t\tlong j = heap_size;\n\t\twhile(j > 1 && heap[j] < heap[j/2])\n\t\t{\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[j/2];\n\t\t\theap[j/2] = temp;\n\t\t\tj = j/2;\n\t\t}\n\t}\n\t\n\tlong i = 0;\n\twhile(heap_size > 0)\n\t{\n\t\tresult[i] = heap[1];\n\t\theap[1] = heap[heap_size];\n\t\theap_size--;\n\t\tlong j = 1;\n\t\twhile(j <= heap_size/2)\n\t\t{\n\t\t\tlong k = 2*j;\n\t\t\tif(k < heap_size && heap[k] > heap[k+1])\n\t\t\t\tk++;\n\t\t\tif(heap[j] < heap[k])\n\t\t\t\tbreak;\n\t\t\tlong temp = heap[j];\n\t\t\theap[j] = heap[k];\n\t\t\theap[k] = temp;\n\t\t\tj = k;\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tlong[] result = new long[iterable.length];\n\t\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\tresult[i] = heap_pop(heap);\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] result = new long[iterable.length];\n\t\n\t// Create a heap\n\tHeap heap = new Heap(iterable);\n\t\n\t// Pop the heap and store the result in the array\n\tfor (int i = 0; i < iterable.length; i++)\n\t{\n\t\tresult[i] = heap.pop();\n\t}\n\t\n\treturn result;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tforeach(i,v; iterable)\n\t\theap[i] = v;\n\t\n\tfor(long i = (heap.length-1)/2; i >= 0; i--)\n\t\theapify(heap, i);\n\t\n\tfor(long i = heap.length-1; i >= 0; i--)\n\t{\n\t\tlong temp = heap[0];\n\t\theap[0] = heap[i];\n\t\theap[i] = temp;\n\t\theapify(heap, 0, i);\n\t}\n\t\n\treturn heap;\n}",
    "{\n\tlong[] heap = new long[iterable.length];\n\tlong[] result = new long[iterable.length];\n\t\n\tforeach(long i; iterable)\n\t{\n\t\theap[i] = iterable[i];\n\t}\n\t\n\tforeach(long i; heap)\n\t{\n\t\tlong parent = (i - 1) / 2;\n\t\tlong left = 2 * i + 1;\n\t\tlong right = 2 * i + 2;\n\t\t\n\t\tif(left < iterable.length && heap[left] > heap[i])\n\t\t{\n\t\t\tlong temp = heap[i];\n\t\t\theap[i] = heap[left];\n\t\t\theap[left] = temp;\n\t\t}\n\t\t\n\t\tif(right < iterable.length && heap[right] > heap[i])\n\t\t{\n\t\t\tlong temp = heap[i];\n\t\t\theap[i] = heap[right];\n\t\t\theap[right] = temp;\n\t\t}\n\t\t\n\t\tif(parent >= 0 && heap[parent] < heap[i])\n\t\t{\n\t\t\tlong temp = heap[i];\n\t\t\theap[i] = heap[parent];\n\t\t\theap[parent] = temp;\n\t\t}\n\t}\n\t\n\tlong j = 0;\n\t\n\tforeach(long i; heap)\n\t{\n\t\tresult[j] = heap[0];\n\t\theap[0] = heap[heap.length - 1];\n\t\theap[heap.length - 1] = 0;\n\t\t\n\t\tlong parent = (i - 1) / 2;\n\t\tlong left = 2 * i + 1;\n\t\tlong right = 2 * i + 2;\n\t\t\n\t\tif(left < iterable.length && heap[left] > heap[i])\n\t\t{\n\t\t\tlong temp = heap[i];\n\t\t\theap[i] = heap[left];\n\t\t\theap[left] = temp;\n\t\t}\n\t\t\n\t\tif(right",
    "{\n\tlong[] result = new long[iterable.length];\n\tlong[] heap = new long[iterable.length];\n\tlong[] heap_index = new long[iterable.length];\n\tlong heap_size = 0;\n\tlong i = 0;\n\tfor (i = 0; i < iterable.length; i++) \n\t{\n\t\theap_index[i] = -1;\n\t}\n\tfor (i = 0; i < iterable.length; i++) \n\t{\n\t\theap_insert(heap, heap_index, heap_size, iterable[i], i);\n\t\theap_size++;\n\t}\n\tfor (i = 0; i < iterable.length; i++) \n\t{\n\t\tresult[i] = heap_pop(heap, heap_index, heap_size);\n\t\theap_size--;\n\t}\n\treturn result;\n}"
  ]
}