{
  "name": "mbpp_735_toggle_middle_bits",
  "language": "d",
  "prompt": "import std.math;\nimport std.typecons;\n/*\n\n\tWrite a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\t\n*/\nlong toggle_middle_bits(long n) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = toggle_middle_bits;\n\n    assert(candidate(9L) == 15L);\n    assert(candidate(10L) == 12L);\n    assert(candidate(11L) == 13L);\n    assert(candidate(65L) == 127L);\n    assert(candidate(77L) == 115L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle = n & mask; \n\tmiddle = middle ^ mask; \n\treturn (first | middle | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = (n >> 1) & 1; \n\tlong mask = (1 << (n.bitLength - 1)) - 1; \n\treturn (n ^ mask) | (first << 1) | last; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1));\n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1;\n\treturn first_bit | (n ^ mask) | last_bit;\n}",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = (n >> 1) & 1; ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mask_bits = n & mask; \n\tmask_bits = mask_bits ^ mask; \n\treturn (mask_bits | first_bit | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = (n >> 1) & 1; \n    long mask = (1 << (n.bitLength - 2)) - 1; \n    long middle_bits = (n >> 2) & mask; \n    long res = (middle_bits ^ mask) << 2; \n    res = res | (first_bit << 1) | last_bit; \n    return res; \n} ",
    "{ \n\treturn (n ^ ((1 << (n.popCount - 2)) - 1)); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bit_size - 1));\n\t\n\tlong mask = (1 << (n.bit_size - 1)) - 1;\n\t\n\treturn (n ^ mask) | (first_bit << (n.bit_size - 1)) | last_bit;\n}",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the number of bits \n\t// to be toggled \n\tlong x = n.bitSize - 2; \n\t\n\t// XOR the number with \n\t// (1 << x) - 1 \n\treturn (n ^ ((1 << x) - 1)) | (first << (x)) | (last >> (x)); \n} ",
    "{ \n    long mask = (1L << (n.bitSize - 2)) - 1; \n    return (n ^ mask); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get all even bits of x \n\tlong even_bits = n & 0xAAAAAAAA; \n\t\n\t// Get all odd bits of x \n\tlong odd_bits = n & 0x55555555; \n\t\n\t// Right shift even bits \n\teven_bits >>= 1; \n\t\n\t// Left shift odd bits \n\todd_bits <<= 1; \n\t\n\t// Combine even and odd bits \n\treturn (even_bits | odd_bits); \n} ",
    "{\n\tlong first = n & 1;\n\tlong last = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\tlong middle = n & mask;\n\tmiddle = ~middle;\n\tmiddle = middle & mask;\n\treturn first | middle | last;\n}",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the number of bits \n\t// in the number \n\tlong num_bits = n.bitSize - 2; \n\t\n\t// XOR the number with (1 << num_bits) \n\t// to toggle the middle bits \n\tn = n ^ (1 << num_bits); \n\t\n\t// Set the first and last bit \n\t// of the number \n\tn = n | first; \n\tn = n | last; \n\t\n\treturn n; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn (first | middle | last); \n} ",
    "{ \n\t// Get the first and last bit of n \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits of n \n\tlong middle_bits = n & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Concatenate the first and last bit \n\t// with the toggled middle bits \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long x = 1; \n    long y = n; \n    while (x < y) { \n        n = n ^ (x | y); \n        x = x << 1; \n        y = y >> 1; \n    } \n    return n; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// having set bits at all the odd \n\t// positions. \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{\n\t// get the first and last bit\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\t\n\t// get the middle bits\n\tlong middle_bits = n & ~(1 << (n.bitSize - 1));\n\tmiddle_bits = middle_bits & ~1;\n\t\n\t// toggle the middle bits\n\tmiddle_bits = middle_bits ^ middle_bits;\n\t\n\t// combine the bits\n\treturn first_bit | middle_bits | last_bit;\n}",
    "{ \n\tlong mask = (1L << (n.bitLength - 2)) - 1; \n\treturn n ^ mask; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the number with the number \n\t// with all set bits except first and last \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong x = n; \n\tlong a = 1; \n\tlong b = 0; \n\twhile (x != 0) { \n\t\tb = b + (x & 1) * a; \n\t\ta = a << 1; \n\t\tx = x >> 1; \n\t} \n\treturn n ^ ((1 << (a - 1)) - 1); \n} ",
    "{ \n    // Calculate the position of first and last set bits \n    long first = log2(n & -n); \n    long last = log2(n & ~(n - 1)); \n  \n    // XOR the number with [2^first, 2^last] \n    return n ^ ((1 << last) - 1) ^ ((1 << first) - 1); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)) & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits ^= (1 << (n.bitSize - 2)) - 1; \n\t\n\t// Set the first and last bits \n\tmiddle_bits |= first_bit << (n.bitSize - 1); \n\tmiddle_bits |= last_bit >> (n.bitSize - 1); \n\t\n\treturn middle_bits; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 2)) | last_bit;\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n    long mask = (1L << (n.bitSize - 2)) - 1; \n    return (n ^ mask); \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the given number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the given number with a number \n\t// consisting of all 1's except the \n\t// first and last bit \n\treturn ((1 << num_bits) - 2) ^ n; \n} ",
    "{ \n    long mask = (1L << (n.bitLength - 2)) - 1; \n    return n ^ mask; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n\tint first_bit = n & 1; \n\tint last_bit = n & (1 << (int.sizeof * 8 - 1)); \n\tint mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\treturn (n ^ mask) | (first_bit << 1) | (last_bit >> 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle = n & mask; \n\tmiddle = middle ^ mask; \n\treturn first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\treturn n ^ mask; \n} ",
    "{ \n\tlong x = 1; \n\tlong y = n - 1; \n\tlong z = x ^ y; \n\treturn z; \n} ",
    "{ \n\t// Get all set bits except first and last \n\t// as they are fixed. \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\t\n\t// XOR the given number with mask. \n\treturn n ^ mask; \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 | (1 << (sizeof(n) * 8 - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Set the first and last bit \n\t// of the toggled number \n\tmiddle_bits = middle_bits | first_bit; \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{\n\tlong mask = 0b11;\n\tlong result = 0;\n\tlong i = 0;\n\twhile (n > 0) {\n\t\tif (i == 0 || i == 63) {\n\t\t\tresult = result | (n & mask);\n\t\t} else {\n\t\t\tresult = result | ((n & mask) ^ mask);\n\t\t}\n\t\tn = n >> 2;\n\t\ti += 2;\n\t}\n\treturn result;\n}",
    "{ \n    long mask = (1L << (n.bitSize - 2)) - 1; \n    return n ^ mask; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long rest = n & ~(1 << (int.sizeof * 8 - 1)); \n    rest = rest & ~1; \n    rest = rest ^ (rest >> 1); \n    return (rest | first | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    return (n ^ mask) | (first << 1) | (last >> 1); \n} ",
    "{ \n\t// To toggle all bits except first and last \n\t// we can XOR the number with 0...010101...010 \n\t// where number of 0s is one less than number \n\t// of bits in the given number \n\tlong x = n | (n >> 1); \n\tx = x | (x >> 2); \n\tx = x | (x >> 4); \n\tx = x | (x >> 8); \n\tx = x | (x >> 16); \n\treturn n ^ x; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) | 1; \n\treturn (n ^ ~mask) | (first_bit << (sizeof(n) * 8 - 1)) | (last_bit >> (sizeof(n) * 8 - 1)); \n} ",
    "{ \n    long mask = (1L << (n.bitLength - 2)) - 1; \n    return (n ^ mask); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{\n\t// Get the first and last bits\n\tlong first = n & 1;\n\tlong last = n & (1 << (n.bitSize - 1));\n\t\n\t// Shift the number to the right by 1\n\tn = n >> 1;\n\t\n\t// Toggle the bits\n\tn = n ^ (1 << (n.bitSize - 1));\n\t\n\t// Shift the number to the left by 1\n\tn = n << 1;\n\t\n\t// Set the first and last bits\n\tn = n | first;\n\tn = n | last;\n\t\n\treturn n;\n}",
    "{ \n\treturn n ^ ((1 << (n.popCount - 2)) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first bit \n\tlong first_bit = n & 1; \n\t\n\t// Get the last bit \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the number of bits to be toggled \n\tlong num_bits = sizeof(n) * 8 - 2; \n\t\n\t// XOR all bits except first and last bit \n\tlong xor_num = (1 << num_bits) - 1; \n\t\n\t// Toggle all bits except first and last bit \n\tlong toggled_num = n ^ xor_num; \n\t\n\t// Put the first and last bit back \n\ttoggled_num = (toggled_num | first_bit) | last_bit; \n\t\n\treturn toggled_num; \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 2)) | (last_bit >> (n.bitSize - 2));\n}",
    "{ \n\t// Calculate the position of first and last bits \n\tlong first_bit = log2(n & ~(n - 1)); \n\tlong last_bit = log2(n) + 1; \n\t\n\t// XOR the number with the XOR of [first_bit, last_bit] \n\treturn n ^ ((1L << last_bit) - 1) ^ ((1L << first_bit) - 1); \n} ",
    "{ \n\treturn n ^ ((1 << (n.popCount - 2)) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitLength - 1)); \n\tlong mask = (1 << (n.bitLength - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tmask = mask ^ (1 << 0); \n\treturn (n ^ mask) | (first_bit << 0) | (last_bit >> (n.bitSize - 1)); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 1)) - 1; \n\tmask = mask ^ (1 << 1); \n\treturn (n ^ mask) | (first_bit << 1) | (last_bit >> 1); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Return the result \n\treturn (first | middle | last); \n} ",
    "{ \n\t// Calculate the mask to toggle bits \n\t// from 2nd to (n-1)th bit \n\tlong mask = (1L << (n - 1)) - 1; \n\t\n\t// Toggle bits in the mask \n\tmask = mask ^ ((1L << (n - 1)) - 1); \n\t\n\t// Return the number with toggled \n\t// bits except first and last bit \n\treturn (n ^ mask); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong x = n & mask; \n\tx = x ^ (x >> 1); \n\treturn (x | (first_bit << (n.bitSize - 1)) | last_bit); \n} ",
    "{ \n    // Calculate the mask to toggle bits \n    // from the second bit to the second \n    // last bit \n    long mask = (1L << (n.bitLength - 1)) - 1; \n    mask = mask ^ (1L << 1); \n  \n    // Toggle bits of n except the first and \n    // the last bit \n    return n ^ mask; \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\treturn n ^ mask; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_of_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the number with a number \n\t// having all set bits except the \n\t// first and the last bit \n\treturn n ^ ((1 << num_of_bits) - 1); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)) & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Put the first and last bits back \n\tmiddle_bits = middle_bits | first_bit; \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\t// To toggle bits from 1 to \n\t// (len - 2) \n\tlong x = (1L << (n.popCount - 2)) - 1; \n\treturn n ^ x; \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); ",
    "{ \n\treturn (n ^ ((1 << (n.bitSize - 2)) - 1)); \n} ",
    "{ \n\t// Get all even bits of x \n\tlong even_bits = n & 0xAAAAAAAA; \n\t\n\t// Get all odd bits of x \n\tlong odd_bits = n & 0x55555555; \n\t\n\t// Right shift even bits \n\teven_bits >>= 1; \n\t\n\t// Left shift odd bits \n\todd_bits <<= 1; \n\t\n\t// Combine even and odd bits \n\treturn (even_bits | odd_bits); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\treturn (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\tmask = mask ^ (1 << 0);\n\treturn (n ^ mask) | (first_bit << 0) | (last_bit >> (n.bitSize - 1));\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get all even bits of x \n\tlong even_bits = n & 0xAAAAAAAA; \n\t\n\t// Get all odd bits of x \n\tlong odd_bits = n & 0x55555555; \n\t\n\t// Right shift even bits \n\teven_bits >>= 1; \n\t\n\t// Left shift odd bits \n\todd_bits <<= 1; \n\t\n\t// Combine even and odd bits \n\treturn (even_bits | odd_bits); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{ \n    long first = 1; \n    long last = n & 1; \n    long middle = n & ~(first | last); \n    middle = (middle ^ (middle >> 1)) >> 1; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)); \n\tmiddle_bits = middle_bits & ~1; \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Set the first and last bit \n\tmiddle_bits = middle_bits | first_bit; \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\tlong a = 1; \n\tlong b = n; \n\twhile (a < b) { \n\t\tn = n ^ (a | b); \n\t\ta <<= 1; \n\t\tb >>= 1; \n\t} \n\treturn n; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = ~((1 << (n.bitSize - 1)) | 1);\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\tlong mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = ~middle_bits; \n\tmiddle_bits = middle_bits & mask; \n\tlong result = first_bit | middle_bits | last_bit; \n\treturn result; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\tmask = mask ^ (1 << 0);\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n    // Calculate the position of first and last set bits \n    long first = n.trailingZeros; \n    long last = n.bitLength - 1 - n.leadingZeros; \n  \n    // If there are no bits to toggle or only one bit to toggle \n    if (first == last || first == last - 1) \n        return n; \n  \n    // Create a mask to toggle bits from first to last \n    long mask = (1L << last) - 1; \n    mask -= ((1L << first) - 1); \n  \n    // Toggle bits from first to last in n \n    return n ^ mask; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\treturn n ^ mask; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (mid | first | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return (first | middle | last); \n} ",
    "{ \n\tlong mask = 0; \n\tlong x = n; \n\twhile (x) { \n\t\tmask <<= 1; \n\t\tmask |= 1; \n\t\tx >>= 1; \n\t} \n\treturn n ^ mask; \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// XOR the first and last bits \n\tlong first_last_bits = first_bit ^ last_bit; \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = ~middle_bits; \n\t\n\t// Merge the first and last bits with the middle bits \n\treturn (first_last_bits | middle_bits); \n} ",
    "{ \n\tlong mask = (1L << (n.bitSize - 2)) - 1; \n\treturn (n ^ mask); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return (first | middle | last); \n} ",
    "{ \n\t// To toggle all bits except first and last \n\t// we can use the following expression \n\t// n ^ (n >> 1) \n\t// This expression will toggle all bits \n\t// except first and last. \n\t// To toggle first and last bits \n\t// we can use the following expression \n\t// n ^ (n >> 1) ^ (n >> 2) \n\t// This expression will toggle first \n\t// and last bits. \n\treturn (n ^ (n >> 1) ^ (n >> 2)); \n} ",
    "{\n\treturn (n ^ (n >> 1));\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_of_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// with all set bits except the \n\t// first and the last bits \n\treturn n ^ ((1L << num_of_bits) - 1); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the number with the number \n\t// obtained by left-shifting 1 by \n\t// num_bits - 2 \n\treturn n ^ (1 << (num_bits - 2)); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// XOR all the bits except first and last bit \n\tlong x = n ^ ((1 << (sizeof(n) * 8 - 1)) - 1); \n\t\n\t// Toggle all bits except first and last bit \n\tx = x ^ ((1 << (sizeof(n) * 8 - 1)) - 1); \n\t\n\t// Set the first and last bit \n\tx = x | first_bit; \n\tx = x | last_bit; \n\t\n\treturn x; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return first_bit | middle_bits | last_bit; \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 2)) - 1; \n\treturn (n ^ mask) | (first << (n.bitSize - 2)) | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitLength() - 1)); \n    long mask = (1 << (n.bitLength() - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = ~middle_bits; \n    middle_bits = middle_bits & mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bits of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\treturn (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// with all set bits except the \n\t// first and last one \n\treturn n ^ ((1L << num_bits) - 1); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the number with a number that has all \n\t// the even bits set and all the odd bits unset \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{\n\tlong mask = (1L << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (1L << (n.bitSize - 2));\n}",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\t\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\t\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = ~middle_bits; \n\t\n\t// Set the first and last bit \n\t// of the number \n\tmiddle_bits = middle_bits | (first_bit << (n.bitSize - 2)); \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\t// Calculate the number of bits \n\t// in the given number \n\tlong num_bits = floor(log2(n)) + 1; \n\t\n\t// XOR the given number with a number \n\t// consisting of all 1's except the \n\t// first and last bit \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n\t// Calculate the position of first set bit \n\t// from right side in binary representation \n\t// of n. \n\tlong first = 0; \n\twhile (n & 1 == 0) { \n\t\tn = n >> 1; \n\t\tfirst++; \n\t} ",
    "{\n\treturn n ^ (1 << (n.popCount - 2)) - 1;\n}",
    "{\n\treturn (n ^ ((1L << (n.popCount - 2)) - 1));\n}",
    "{ \n\t// calculating the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// calculating the middle bits \n\tlong middle_bits = n & ~(1 << (n.bitSize - 1)) & ~1; \n\t\n\t// toggling the middle bits \n\tmiddle_bits = ~middle_bits; \n\t\n\t// calculating the final number \n\tlong res = first_bit | middle_bits | last_bit; \n\t\n\treturn res; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = ~mid; \n\tmid = mid & mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong toggled_middle_bits = n ^ mask; \n\treturn (toggled_middle_bits | first_bit | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 2)); \n    long rest = n & ~(1 | (1 << (int.sizeof * 8 - 2))); \n    rest = rest ^ ((1 << (int.sizeof * 8 - 3)) - 1); \n    return first | rest | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    return (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tint num_bits = (int)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// consisting of all 1's except \n\t// the first and the last bit \n\treturn n ^ ((1 << (num_bits - 2)) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    return (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\t// Get the size of the number \n\tint size = n.sizeof * 8; \n\t\n\t// XOR the number with a number \n\t// having all set bits except \n\t// first and last bits \n\treturn n ^ ((1L << (size - 2)) - 1); \n} ",
    "{ \n\t// Get all set bits except first and last \n\t// using formula 2^(n-1) - 1 \n\tlong mask = (1 << (n - 1)) - 1; \n\t\n\t// XOR mask with n \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Calculate the position of first and last set bits \n\tlong first = log2(n & -n); \n\tlong last = log2(n & ~(n - 1)); \n\t\n\t// XOR the number with [2^first, 2^last] \n\treturn n ^ ((1 << last) - 1) ^ ((1 << first) - 1); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle = n & mask; \n\tmiddle = middle ^ mask; \n\treturn first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bits \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// XOR the first and last bits \n\tlong xor_bits = first_bit ^ last_bit; \n\t\n\t// Get the number of bits to be flipped \n\tlong num_bits = (sizeof(n) * 8 - 2); \n\t\n\t// XOR the number with the XOR bits \n\tlong xor_num = n ^ (xor_bits | (xor_bits << num_bits)); \n\t\n\t// Left shift the XOR bits \n\tlong left_shift = xor_bits << (num_bits); \n\t\n\t// OR the left shifted value with XOR of number \n\treturn (xor_num | left_shift); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tmask = mask - 1; \n\tlong middle = n & mask; \n\tmiddle = ~middle; \n\tmiddle = middle & mask; \n\treturn (first | middle | last); \n} ",
    "{ \n\t// Get the number of bits in the number \n\tint num_bits = (int)log2(n) + 1; \n\t// XOR with a number that has all 1's except \n\t// the first and last bit \n\treturn n ^ ((1 << num_bits) - 1); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = ~middle_bits; \n\t\n\t// Put the first and last bit back \n\tmiddle_bits = middle_bits | first_bit; \n\tmiddle_bits = middle_bits | last_bit; \n\t\n\treturn middle_bits; \n} ",
    "{ \n\tint first = n & 1; \n\tint last = n & (1 << (n.bitSize - 1)); \n\tint mask = (1 << (n.bitSize - 1)) - 1; \n\treturn (n ^ mask) | (first << (n.bitSize - 1)) | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ~(1 | (1 << (n.bitSize - 1))); \n\t\n\t// Toggle the middle bits \n\tmiddle = ~middle; \n\t\n\t// Put the first and last bit back \n\tmiddle = middle | first | last; \n\t\n\treturn middle; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the first and last bit of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the number of bits in the number \n\tlong num_bits = sizeof(n) * 8 - 1; \n\t\n\t// XOR the number with 1s \n\tlong xor_num = (1 << num_bits) - 1; \n\t\n\t// Toggle the middle bits \n\tlong middle_bits = (n ^ xor_num) & ~(first | last); \n\t\n\t// Return the result \n\treturn (n & ~xor_num) | middle_bits; \n} ",
    "{\n\treturn (n ^ (n >> 1)) & ~(1L << 63) & ~1L;\n}",
    "{ \n    long x = 1; \n    long y = (n >> 1); \n    long z = (n << 1); \n    long res = (x | y | z); \n    return res; \n} ",
    "{ \n\t// Get the first and last bit \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\t\n\t// Get the middle bits \n\tlong middle = n & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Toggle the middle bits \n\tmiddle = ~middle; \n\t\n\t// Update the first and last bit \n\tmiddle = middle & ((1 << (n.bitSize - 2)) - 1); \n\t\n\t// Update the first and last bit \n\tmiddle = middle | first; \n\tmiddle = middle | last; \n\t\n\treturn middle; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bit \n\t// of the number \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits \n\tlong middle_bits = n & ~(first_bit | last_bit); \n\t\n\t// Toggle the middle bits \n\tmiddle_bits = middle_bits ^ (middle_bits >> 1); \n\t\n\t// Return the result \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first_bit = n & 1; \n    long last_bit = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle_bits = n & mask; \n    middle_bits = middle_bits ^ mask; \n    return (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n\t// Get the number of bits in the number \n\tlong num_of_bits = (long)log2(n) + 1; \n\t\n\t// XOR the number with a number \n\t// having set bits at all places \n\t// except first and last position \n\treturn ((1 << num_of_bits) - 1) ^ ((1 << (num_of_bits - 2)) - 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return (first | mid | last); \n} ",
    "{ \n\t// Get the first and last bits of the number \n\tlong first = n & 1; \n\tlong last = n & (1 << (sizeof(n) * 8 - 1)); \n\t\n\t// Get the middle bits of the number \n\tlong middle = n & ~(first | last); \n\t\n\t// Toggle the middle bits \n\tmiddle = middle ^ (middle >> 1); \n\t\n\t// Combine the first, middle and last bits \n\treturn (first | middle | last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n\treturn (n ^ ((1L << (n.bitSize - 2)) - 1)); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (int.sizeof * 8 - 1)); \n    long mask = (1 << (int.sizeof * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    return (n ^ mask) | (first << 1) | (last >> 1); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long middle = n & mask; \n    middle = middle ^ mask; \n    return first | middle | last; \n} ",
    "{ \n    // Calculate the position of first and last \n    // set bits \n    long first = n & (-n); \n    long last = n & (~(-n)); \n  \n    // Calculate the position of middle bits \n    long middle = n & ~(first | last); \n  \n    // Toggle the middle bits \n    middle = middle ^ (~(-middle)); \n  \n    // Update the number \n    n = first | middle | last; \n  \n    return n; \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong first_bit = n & 1; \n\tlong last_bit = n & (1 << (n.popCount() - 1)); \n\tlong mask = (1 << (n.popCount() - 1)) - 1; \n\tlong middle_bits = n & mask; \n\tmiddle_bits = middle_bits ^ mask; \n\treturn (first_bit | middle_bits | last_bit); \n} ",
    "{ \n    // Calculate the position of first and last \n    // set bits \n    long first = n & (-n); \n    long last = log2(n & (~(n - 1))); \n  \n    // XOR the first and last bits \n    return ((n ^ first) ^ last); \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    return (n ^ mask) | (first << 1) | last; \n} ",
    "{\n\tint first_bit = n & 1;\n\tint last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n\t// Get all set bits except first and last \n\t// using formula 2^(n-1) + 2^(n-2) + ... + 2^1 \n\tlong mask = (1L << (n - 1)) | ((1L << (n - 1)) - 1); \n\t\n\t// XOR the number with mask \n\treturn (n ^ mask); \n} ",
    "{ \n\t// Find the first set bit from the left \n\tlong first = n & (-n); \n\t\n\t// Find the last set bit from the right \n\tlong last = log2(n & ~(-n)); \n\t\n\t// XOR the number with first and last bits \n\treturn n ^ first ^ last; \n} ",
    "{ \n    // Calculate the position of first and last set bits \n    long first = n & (-n); \n    long last = log2(n & ~(-n)); \n  \n    // XOR the first and last bits \n    return n ^ first ^ (1 << last); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 2)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 2)) | last_bit;\n}",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (int.sizeof * 8 - 2)); \n\tlong mask = (1 << (int.sizeof * 8 - 2)) - 1; \n\tlong mid = n & mask; \n\tmid = mid ^ mask; \n\treturn (first | mid | last); \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (n.bitSize - 1)); \n    long mask = (1 << (n.bitSize - 1)) - 1; \n    long mid = n & mask; \n    mid = mid ^ mask; \n    return first | mid | last; \n} ",
    "{ \n    long first = n & 1; \n    long last = n & (1 << (sizeof(n) * 8 - 1)); \n    long mask = (1 << (sizeof(n) * 8 - 2)) - 1; \n    long middle = n & mask; \n    middle = ~middle; \n    middle = middle & mask; \n    return first | middle | last; \n} ",
    "{\n\tlong first_bit = n & 1;\n\tlong last_bit = n & (1 << (n.bitSize - 1));\n\tlong mask = (1 << (n.bitSize - 1)) - 1;\n\treturn (n ^ mask) | (first_bit << (n.bitSize - 1)) | last_bit;\n}",
    "{\n    long first_bit = n & 1;\n    long last_bit = n & (1 << (n.bitSize - 1));\n    long mask = (1 << (n.bitSize - 1)) - 1;\n    long middle_bits = n & mask;\n    middle_bits = middle_bits ^ mask;\n    return (first_bit | middle_bits | last_bit);\n}",
    "{ \n\tlong first = n & 1; \n\tlong last = n & (1 << (n.bitSize - 1)); \n\tlong mask = (1 << (n.bitSize - 1)) - 1; \n\tlong middle = n & mask; \n\tmiddle = middle ^ mask; \n\treturn first | middle | last; \n} "
  ]
}