{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\n*/\nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = max_sub_array_sum_repeated;\n\n    assert(candidate([10L, 20L, -30L, -1L], 4L, 3L) == 30L);\n    assert(candidate([-1L, 10L, 20L], 3L, 2L) == 59L);\n    assert(candidate([-1L, -2L, -3L], 3L, 3L) == -1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_val = 0; \n    long final_sum = 0; \n  \n    // Find the sum of the first window of size n \n    for (long i = 0; i < n; i++) { \n        max_sum += a[i]; \n        final_sum += a[i]; \n    } \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    curr_sum = max_sum; \n    for (long i = n; i < n * k; i++) { \n        curr_val = curr_sum - a[i - n] + a[i]; \n        curr_sum = curr_val; \n        max_sum = max(max_sum, curr_val); \n    } \n  \n    return max(max_sum, (final_sum * (k - 2)) + curr_sum); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's \n    // algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2: Now find the maximum sum that \n    // is possible by looping through the \n    // (k-1) times and merging the result \n    // with kadane's sum which we got \n    // previously \n    for (long i = 1; i < k; i++) { \n        for (long j = 0; j < n; j++) { \n            long temp = a[j]; \n            a[j] = max(a[j], a[j] * -1); \n            max_sum = max(max_sum, max_sum + a[j]); \n            a[j] = temp; \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_ending_here = 0; \n    for (i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    max_wrap = max_wrap + max_ending_here; \n    if (k == 1) \n        return max_sum; \n    return max(max_sum, max_wrap * (k - 2) + max_sum); \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long e = 0; \n    long max_ending_here_new = 0; \n    long max_so_far_new = 0; \n    long max_ending_here_best = 0; \n    long max_so_far_best = 0; \n    long max_ending_here_old = 0; \n    long max_so_far_old = 0; \n    long sum_old = 0; \n    long sum_new = 0; \n    long sum_best = 0; \n    long sum_total = 0; \n    long max_sum_total = 0; \n    long max_sum_best = 0; \n    long max_sum_new = 0; \n    long max_sum_old = 0; \n    long max_ending_here_total = 0; \n    long max_so_far_total = 0; \n    long max_ending_here_best_total = 0; \n    long max_so_far_best_total = 0; \n    long max_ending_here_new_total = 0; \n    long max_so_far_new_total = 0; \n    long max_ending_here_old_total = 0; \n    long max_so_far_old_total = 0; \n    long sum_old_total = 0; \n    long sum_new_total = 0; \n    long sum_best_total = 0; \n    long sum_total_total = 0; \n    long max_sum_total_total = 0; \n    long max_sum_best_total = 0; \n    long max_sum_new_total = 0; \n    long max_sum_old_total = 0; \n    long max_ending_here_total_total = 0; \n    long",
    "{ \n    // Find sum of all elements of array. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n\t// Find sum of all elements of array. \n\tlong sum = 0; \n\tfor (long i = 0; i < n; i++) \n\t\tsum += a[i]; ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n        long sum = 0; \n        for (long i = 0; i < n; i++) \n            sum += a[i]; \n  \n        max_sum = max(max_sum, sum * k); \n  \n        // Case 3 \n        for (long i = 0; i < n; i++) { \n            max_ending_here = max_ending_here + a[i]; \n            max_sum = max(max_sum, max_ending_here); \n            max_ending_here = max(max_ending_here, 0); \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2 \n    max_ending_here = 0; \n    s = 0; \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here > max_sum) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 3 \n    long min_sum = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    s = 0; \n    for (int i = 0; i < n; i++) { \n        min_ending_here += a[i]; \n        if (min_so_far > min_ending_here) { \n            min_so_far = min_ending_here; \n            s = i + 1; \n        } \n        if (min_ending_here > 0) { \n            min_ending_here = 0; \n        } \n    } \n  \n    long max_wrap = 0; \n    max_wrap",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, (min_sum * k)); \n  \n    long max_wrap = 0; \n    long min_wrap = 0; \n    long curr_max = 0; \n    long curr_min = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_max += a[i]; \n        curr_min += a[i]; \n        max_wrap = max(max_wrap, curr_max); \n        if (curr_max < 0) \n            curr_max = 0; \n        if (curr_min > 0) \n            curr_min = 0; \n        min_wrap = min(min_wrap, curr_min); \n    } \n  \n    long ans = max(max_sum, (max_wrap + min_wrap) * (k - 1) + max_wrap); \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(sum, max_sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i; \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} \n  \nlong max_circular_subarray_sum(long[] a, long n) \n{ \n    long max_kadane = max_sub_array_sum(a, n); \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap +=",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = *max_element(a, a + n); \n  \n    if (max_element < 0) \n        return max_element; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k == 2) \n        return max(max_wrap, max_sum); \n  \n    return max(max_wrap, max_sum + (k - 2) * max_wrap); \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_elem < 0) \n        return max_elem; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    long curr_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        curr_wrap += a[i]; \n        if (curr_wrap < 0) \n            curr_wrap = 0; \n        max_wrap = max(max_wrap, curr_wrap); \n    } \n    return max(max_wrap, max_sum + max_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 1) \n        return max(max_sum, max_wrap); \n  \n    return max(max_sum, max_wrap + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    max_sum = max_sum + (k - 2) * sum; \n    return max_sum; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_modified(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    long curr_sum = max_sub_array_sum(a, n); \n    return max(max_sum, sum + curr_sum); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_modified(a, n, k",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0; \n  \n    // Find the sum of the original array \n    for (long i = 0; i < n; i++) \n    { \n        total_sum += a[i]; \n        max_sum = max(max_sum, a[i]); \n    } \n  \n    // Case 1 \n    curr_sum = total_sum * k; \n    max_sum = max(max_sum, curr_sum); \n  \n    // Case 2 \n    for (long i = 0; i < n; i++) \n    { \n        curr_prefix_sum += a[i]; \n        curr_suffix_sum += a[n - i - 1]; \n  \n        curr_sum = curr_prefix_sum +  \n                   (curr_suffix_sum - a[n - i - 1]) *  \n                   (k - 1); \n  \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} "
  ]
}