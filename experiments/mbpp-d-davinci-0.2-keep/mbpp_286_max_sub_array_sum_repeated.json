{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "d",
  "prompt": "import std.math;\n/*\n\n\tWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\t\n*/\nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "verbatim",
  "tests": "unittest\n{\n    alias candidate = max_sub_array_sum_repeated;\n\n    assert(candidate([10L, 20L, -30L, -1L], 4L, 3L) == 30L);\n    assert(candidate([-1L, 10L, 20L], 3L, 2L) == 59L);\n    assert(candidate([-1L, -2L, -3L], 3L, 3L) == -1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "completions": [
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_val = 0; \n    long final_sum = 0; \n  \n    // Find the sum of the first window of size n \n    for (long i = 0; i < n; i++) { \n        max_sum += a[i]; \n        final_sum += a[i]; \n    } \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    curr_sum = max_sum; \n    for (long i = n; i < n * k; i++) { \n        curr_val = curr_sum - a[i - n] + a[i]; \n        curr_sum = curr_val; \n        max_sum = max(max_sum, curr_val); \n    } \n  \n    return max(max_sum, (final_sum * (k - 2)) + curr_sum); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's \n    // algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2: Now find the maximum sum that \n    // is possible by looping through the \n    // (k-1) times and merging the result \n    // with kadane's sum which we got \n    // previously \n    for (long i = 1; i < k; i++) { \n        for (long j = 0; j < n; j++) { \n            long temp = a[j]; \n            a[j] = max(a[j], a[j] * -1); \n            max_sum = max(max_sum, max_sum + a[j]); \n            a[j] = temp; \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_ending_here = 0; \n    for (i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    max_wrap = max_wrap + max_ending_here; \n    if (k == 1) \n        return max_sum; \n    return max(max_sum, max_wrap * (k - 2) + max_sum); \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long e = 0; \n    long max_ending_here_new = 0; \n    long max_so_far_new = 0; \n    long max_ending_here_best = 0; \n    long max_so_far_best = 0; \n    long max_ending_here_old = 0; \n    long max_so_far_old = 0; \n    long sum_old = 0; \n    long sum_new = 0; \n    long sum_best = 0; \n    long sum_total = 0; \n    long max_sum_total = 0; \n    long max_sum_best = 0; \n    long max_sum_new = 0; \n    long max_sum_old = 0; \n    long max_ending_here_total = 0; \n    long max_so_far_total = 0; \n    long max_ending_here_best_total = 0; \n    long max_so_far_best_total = 0; \n    long max_ending_here_new_total = 0; \n    long max_so_far_new_total = 0; \n    long max_ending_here_old_total = 0; \n    long max_so_far_old_total = 0; \n    long sum_old_total = 0; \n    long sum_new_total = 0; \n    long sum_best_total = 0; \n    long sum_total_total = 0; \n    long max_sum_total_total = 0; \n    long max_sum_best_total = 0; \n    long max_sum_new_total = 0; \n    long max_sum_old_total = 0; \n    long max_ending_here_total_total = 0; \n    long",
    "{ \n    // Find sum of all elements of array. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} \n  \n// Driver code ",
    "{ \n\t// Find sum of all elements of array. \n\tlong sum = 0; \n\tfor (long i = 0; i < n; i++) \n\t\tsum += a[i]; ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n        long sum = 0; \n        for (long i = 0; i < n; i++) \n            sum += a[i]; \n  \n        max_sum = max(max_sum, sum * k); \n  \n        // Case 3 \n        for (long i = 0; i < n; i++) { \n            max_ending_here = max_ending_here + a[i]; \n            max_sum = max(max_sum, max_ending_here); \n            max_ending_here = max(max_ending_here, 0); \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2 \n    max_ending_here = 0; \n    s = 0; \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here > max_sum) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 3 \n    long min_sum = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    s = 0; \n    for (int i = 0; i < n; i++) { \n        min_ending_here += a[i]; \n        if (min_so_far > min_ending_here) { \n            min_so_far = min_ending_here; \n            s = i + 1; \n        } \n        if (min_ending_here > 0) { \n            min_ending_here = 0; \n        } \n    } \n  \n    long max_wrap = 0; \n    max_wrap",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, (min_sum * k)); \n  \n    long max_wrap = 0; \n    long min_wrap = 0; \n    long curr_max = 0; \n    long curr_min = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_max += a[i]; \n        curr_min += a[i]; \n        max_wrap = max(max_wrap, curr_max); \n        if (curr_max < 0) \n            curr_max = 0; \n        if (curr_min > 0) \n            curr_min = 0; \n        min_wrap = min(min_wrap, curr_min); \n    } \n  \n    long ans = max(max_sum, (max_wrap + min_wrap) * (k - 1) + max_wrap); \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(sum, max_sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i; \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} \n  \nlong max_circular_subarray_sum(long[] a, long n) \n{ \n    long max_kadane = max_sub_array_sum(a, n); \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap +=",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = *max_element(a, a + n); \n  \n    if (max_element < 0) \n        return max_element; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k == 2) \n        return max(max_wrap, max_sum); \n  \n    return max(max_wrap, max_sum + (k - 2) * max_wrap); \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_elem < 0) \n        return max_elem; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    long curr_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        curr_wrap += a[i]; \n        if (curr_wrap < 0) \n            curr_wrap = 0; \n        max_wrap = max(max_wrap, curr_wrap); \n    } \n    return max(max_wrap, max_sum + max_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 1) \n        return max(max_sum, max_wrap); \n  \n    return max(max_sum, max_wrap + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    max_sum = max_sum + (k - 2) * sum; \n    return max_sum; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_modified(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    long curr_sum = max_sub_array_sum(a, n); \n    return max(max_sum, sum + curr_sum); \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_modified(a, n, k",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0; \n  \n    // Find the sum of the original array \n    for (long i = 0; i < n; i++) \n    { \n        total_sum += a[i]; \n        max_sum = max(max_sum, a[i]); \n    } \n  \n    // Case 1 \n    curr_sum = total_sum * k; \n    max_sum = max(max_sum, curr_sum); \n  \n    // Case 2 \n    for (long i = 0; i < n; i++) \n    { \n        curr_prefix_sum += a[i]; \n        curr_suffix_sum += a[n - i - 1]; \n  \n        curr_sum = curr_prefix_sum +  \n                   (curr_suffix_sum - a[n - i - 1]) *  \n                   (k - 1); \n  \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_ending_here = max(max_ending_here, 0); \n        min_ending_here = min(min_ending_here, 0); \n        max_sum = max(max_sum, max_ending_here); \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    long max_wrap = total - min_sum; \n  \n    return max(max_wrap, max_sum + (k - 2) * total); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first element of previous \n    // window and adding last element of current window. \n    for (i = n; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, k-1); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    max_sum = curr_sum; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long max_i = 0; \n    long max_j = 0; \n    long max_len = 0; \n    long len = 0; \n    long max_ele = 0; \n  \n    // Find the maximum element in the array \n    for (i = 0; i < n; i++) \n        max_ele = max(max_ele, a[i]); \n  \n    // If maximum element is negative \n    if (max_ele < 0) \n        return max_ele * k; \n  \n    // Initialize the sliding window \n    i = 0; \n    j = 0; \n    sum = 0; \n    max_sum = 0; \n    len = 0; \n    max_len = 0; \n  \n    // Find the maximum sum subarray \n    while (j < n) { \n        sum += a[j++]; \n        len++; \n  \n        if (sum > max_sum) { \n            max_sum = sum; \n            max_i = i; \n            max_j = j; \n            max_len = len; \n        } \n  \n        if (sum < 0) { \n            sum = 0; \n            i = j; \n            len = 0; \n        } \n    } \n  \n    // If maximum sum is 0, then return maximum element \n    if (max_sum == 0) \n        return max_ele; \n  \n    // Initialize answer with maximum sum of subarray \n    // obtained using sliding window \n    long ans = max_sum; \n  \n    // Initialize sum of elements in the middle \n    // subarrays obtained after splitting the \n    // above maximum sum subarray \n    sum = max_sum; \n  \n    // Traverse in the array \n    while (max_j < n) { \n        // Update sum \n        sum = sum - a[max_i] + a[max_j]; \n",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    long curr_max = 0; \n  \n    for (i = 0; i < n; i++) { \n        curr_max += a[i]; \n        max_wrap += a[i]; \n        if (curr_max < 0) \n            curr_max = 0; \n    } \n  \n    if (max_wrap < 0) \n        return max_sum; \n  \n    return max(max_sum, max_wrap * k - curr_max); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        max_wrap = max(max_wrap, 0); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    return max(max_sum, max_wrap + (k - 2) * sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = 0; \n    long min_elem = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n  \n    // Find the sum of the original array \n    for (i = 0; i < n; i++) { \n        sum += a[i]; \n        max_elem = max(max_elem, a[i]); \n        min_elem = min(min_elem, a[i]); \n    } \n  \n    // Case 1 \n    max_sum = (k * sum); \n  \n    // Case 2 \n    max_sum = max(max_sum, (sum + (k - 2) * max_elem)); \n  \n    // Case 3 \n    max_sum = max(max_sum, (sum + (k - 2) * min_elem)); \n  \n    // Case 4 \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, (curr_sum + (k - 2) * max_elem)); \n        max_sum = max(max_sum, (curr_sum + (k - 2) * min_elem)); \n    } \n  \n    // Case 5 \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        for (j = i + 1; j < n; j++) { \n            curr_sum += a[j]; \n            max_sum = max(max_sum, (curr_sum + (k - 2) * max_elem)); \n            max_sum = max(max_sum, (curr_sum + (k - 2) * min_elem)); \n        } \n        curr_sum = 0; \n    } \n  \n    return max_sum",
    "{ \n\t// Find sum of the original array \n\tlong sum = 0; \n\tfor (long i = 0; i < n; i++) \n\t\tsum += a[i]; ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2 \n    max_ending_here = 0; \n  \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        max_sum += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    max_sum = max(max_sum, 0); \n  \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here > max_so_far) \n            max_so_far = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    // Case 3 \n    max_so_far = max(max_so_far, 0); \n  \n    // The final answer will be maximum of  \n    // sum of subarray in original array,  \n    // sum of subarray in rotated array,  \n    // sum of subarray created by corner elements. \n    return max(max_so_far, max_sum * (k - 2) + max_so_far); \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n    } \n  \n    long max_wrap = 0; \n    long min_wrap = 0; \n    long temp = 0; \n    for (long i = 0; i < n; i++) { \n        temp += a[i]; \n        max_wrap = max(max_wrap, temp); \n        if (temp < 0) \n            temp = 0; \n    } \n  \n    temp = 0; \n    for (long i = 0; i < n; i++) { \n        temp += a[i]; \n        min_wrap = min(min_wrap, temp); \n        if (temp > 0) \n            temp = 0; \n    } \n  \n    long max_wrap_sum = 0; \n    if (k > 1) \n        max_wrap_sum = (k - 2) * sum + max_wrap + min_wrap; \n  \n    return max(max_sum, max_wrap_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n  \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        a[i] = -a[i]; \n    } \n    max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_ending_here > max_wrap_sum) \n            max_wrap_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    max_sum = max(max_wrap_sum, max_so_far); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    long min_elem = a[0]; \n    long i; \n  \n    // Find maximum and minimum element in array \n    for (i = 0; i < n; i++) { \n        max_elem = max(max_elem, a[i]); \n        min_elem = min(min_elem, a[i]); \n    } \n  \n    // If all elements are same \n    if (max_elem == min_elem) \n        return (max_elem * k); \n  \n    // Find maximum sum subarray in k repetitions of array \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Case when all elements are negative \n    if (max_sum <= 0) \n        return max_sum; \n  \n    // Construct a temporary array with sum of prefix sums \n    long[] temp = new long[n]; \n    temp[0] = a[0]; \n    for (i = 1; i < n; i++) \n        temp[i] = temp[i - 1] + a[i]; \n  \n    // Case 1 \n    long case_1 = max_sum; \n  \n    // Case 2 \n    long case_2 = max_sum; \n    for (i = 0; i < n; i++) { \n        case_2 = max(case_2, temp[i] + (max_sum - temp[i]) * (k - 2)); \n    } \n  \n    // Case 3 \n    long case_3 = max_sum; \n    for (i = n - 1; i >= 0; i--) { \n        case_3 = max(case_3, temp[i] + (max_sum -",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    long max_sum_whole = 0; \n    for (long i = 0; i < n; i++) { \n        max_sum_whole += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    long curr_max = 0, curr_min = 0; \n    for (long i = 0; i < n; i++) { \n        curr_max = max(curr_max + a[i], 0L); \n        curr_min = min(curr_min + a[i], 0L); \n    } \n  \n    long max_circular_sum = max_sum_whole + curr_max; \n  \n    if (k == 1) \n        return max_sum; \n  \n    else if (k == 2) \n        return max(max_sum, max_circular_sum); \n  \n    else\n        return max(max_sum, max(max_circular_sum, \n                                max_sum_whole * (k - 2) + max_circular_sum)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n\tlong max_sum = 0; \n\tlong max_ending_here = 0; \n\tlong max_so_far = 0; \n\tlong start = 0; \n\tlong end = 0; \n\tlong s = 0; \n\t\n\tfor (long i = 0; i < n * k; i++) \n\t{ \n\t\tmax_ending_here += a[i % n]; \n\t\t\n\t\tif (max_so_far < max_ending_here) \n\t\t{ \n\t\t\tmax_so_far = max_ending_here; \n\t\t\tstart = s; \n\t\t\tend = i; \n\t\t} \n\t\t\n\t\tif (max_ending_here < 0) \n\t\t{ \n\t\t\tmax_ending_here = 0; \n\t\t\ts = i + 1; \n\t\t} \n\t} \n\t\n\tlong temp = max_so_far; \n\t\n\tfor (long i = 0; i < n * k; i++) \n\t{ \n\t\ttemp = temp - a[(i + end) % n]; \n\t\ttemp = temp + a[(i + start) % n]; \n\t\tmax_sum = max(temp, max_sum); \n\t} \n\t\n\treturn max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    return max(max_sum, max_wrap * (k - 2)); \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_sum < max_ending_here) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2 \n    max_ending_here = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_sum < max_ending_here) { \n            max_sum = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here > 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Print the subarray \n    for (long i = start; i <= end; i++) \n        cout << a[i % n] << \" \"; \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long max_element = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long start = 0; \n    long end = 0; \n  \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    max_element = maxElement(a, n); \n    if (sum > 0) \n        max_sum = max(max_so_far * k, \n                      max_so_far + sum * (k - 2)); \n    else\n        max_sum = max(max_so_far, max_element); \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_sum = max(max_sum, max_wrap_sum); \n  \n    if (max_sum > max_so_far) \n        return max_sum; \n    else\n        return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i >= k - 1) { \n            max_sum = max(max_sum, curr_sum); \n            curr_sum -= sum; \n        } \n    } \n    return max_sum; \n} ",
    "{ \n    // Find sum of original array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of the maximum sum subarray \n    // in a subarray of size n \n    long max_sum = max_sub_array_sum(a, n); \n  \n    // max sum is sum of elements when \n    // k is 1 \n    if (k == 1) \n        return max_sum; \n  \n    // case when k is more than 1 \n    return max(max_sum, sum * k); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        min_ending_here = min_ending_here + a[i]; \n        max_ending_here = max(max_ending_here, 0); \n        min_ending_here = min(min_ending_here, 0); \n        max_sum = max(max_sum, max_ending_here); \n    } \n  \n    long max_wrap = 0; \n    long min_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        min_wrap += a[i]; \n        max_wrap = max(max_wrap, 0); \n        min_wrap = min(min_wrap, 0); \n    } \n  \n    if (k == 1) \n        return max_sum; \n  \n    return max(max_sum, max_wrap + min_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_wrap = max(max_wrap, sum); \n    } \n    return max(max_sum, max_wrap * (k - 1) + max_sum); \n} ",
    "{ \n    // Find sum of all elements. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of elements in a circular manner. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result. \n    long max_val = curr_val; \n  \n    // Try all rotations one by one and find \n    // the maximum rotation sum. \n    for (long i = 1; i < n; i++) { \n        curr_val = curr_val + sum - n * a[n - i]; \n        max_val = max(max_val, curr_val); \n    } \n  \n    // Return maximum rotation sum divided \n    // by k. \n    return max_val / k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = start; i <= end; i++) \n        sum += a[i % n]; \n  \n    return sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0, sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    max_wrap = max_wrap + sum; \n    if (k == 1) \n        return max_sum; \n    return max(max_sum, max_wrap * (k - 2) + max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's algorithm \n    for (int i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // Case 2: Now find the maximum sum that is possible by \n    // including elements (repeated k times) before and after \n    // the elements included in kadane's algorithm above \n    long arr_sum = 0; \n    for (int i = 0; i < n; i++) { \n        arr_sum = arr_sum + a[i]; \n        a[i] = a[i] * k; \n    } \n  \n    // Case 2(a): \n    // Find the sum of middle k elements out of n elements. \n    // The middle k elements will be maximum sum \n    // possible for case 2(a). \n    // Middle k = (n-end+start) \n    long mid_sum = 0; \n    for (int i = end + 1; i < end + n - start + 1; i++) \n        mid_sum = mid_sum + a[i % n]; \n  \n    // Case 2(b): \n    // Find the sum of k elements (elements before \n    // start and elements after end) \n    long start_sum = 0, end_sum = 0; \n    for (int i = 0; i < k - (n - (end - start + 1)) % k; i++)",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = *max_element(a, a + n); \n    long min_elem = *min_element(a, a + n); \n    long total_sum = accumulate(a, a + n, 0); \n  \n    if (max_elem < 0) \n        return max_elem * k; \n  \n    if (min_elem > 0) \n        return min_elem * k; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    if ((k - 2) * total_sum > max_wrap) \n        return (k - 2) * total_sum; \n    else\n        return max_wrap; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_wrap) \n            max_wrap = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    if (k == 1) \n        return max_wrap; \n    long max_single = 0; \n    for (i = 0; i < n; i++) { \n        if (a[i] > max_single) \n            max_single = a[i]; \n    } \n    if (max_single < 0) \n        return max_single; \n    return max(max_wrap, max_sum + (k - 2) * max_wrap + max_single); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i = 0; \n    long j = 0; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n    } \n  \n    // Starting index of first window. \n    long start = 0; \n  \n    // Update maximum sum so far. \n    max_sum = max(max_sum, curr_sum); \n  \n    // Move the current window by one element. \n    for (i = 1; i < n * k; i++) { \n  \n        // Remove first element of previous window. \n        curr_sum -= a[i - 1]; \n  \n        // Add new element to current window. \n        curr_sum += a[(i + n - 1) % n]; \n  \n        // Update maximum sum so far. \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    long i, j; \n  \n    // Iterate through all subarrays \n    for (i = 0; i < n; i++) { \n  \n        // Initialize max_ending_here for every subarray \n        max_ending_here = 0; \n  \n        // Iterate through every subarray starting from i \n        for (j = i; j < n * k; j++) { \n            max_ending_here += a[j % n]; \n            max_sum = max(max_sum, max_ending_here); \n        } \n    } \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0, sum = 0; \n    for (int i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    long max_wrap = 0, wrap = 0; \n    for (int i = 0; i < n; i++) \n    { \n        wrap += a[i]; \n        if (max_wrap < wrap) \n            max_wrap = wrap; \n        if (wrap < 0) \n            wrap = 0; \n    } \n    if (k == 1) \n        return max_wrap; \n    return max(max_wrap, max_sum + (k - 2) * max_wrap + sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n    } \n  \n    if (total < 0) \n        return max(max_sum, min_sum + total * (k - 2)); \n  \n    return max(max_sum, total * k - min_sum); \n} ",
    "{ \n    long max_sum = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    long min_sum = min_element(a); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_sum, max_wrap); \n} ",
    "{ \n    // Find sum of the original array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of the modified array \n    // (k times the original array) \n    long max_sum = sum * k; \n  \n    // Find sum of the middle elements \n    // of the modified array \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) \n        curr_sum += a[i] * (k - 1); \n  \n    // Initialize maximum sum as \n    // maximum of the two sums \n    max_sum = max(max_sum, curr_sum); \n  \n    // Traverse middle elements of the modified array \n    for (long i = n; i < (k * n) - 1; i++) \n    { \n        // Update current sum by removing \n        // first element of previous subarray \n        // and adding last element of current subarray \n        curr_sum = curr_sum - a[i - n] + a[i]; \n  \n        // Update result if current sum is \n        // more than previous sum \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = 0; \n    long min_elem = 0; \n    long i = 0; \n    long j = 0; \n    long sum = 0; \n  \n    for (i = 0; i < n; i++) { \n        sum += a[i]; \n        max_elem = max(max_elem, a[i]); \n        min_elem = min(min_elem, a[i]); \n    } \n  \n    if (k == 1) \n        return sum; \n  \n    if (max_elem <= 0) \n        return max_elem * k; \n  \n    if (min_elem >= 0) \n        return sum * k; \n  \n    max_sum = 0; \n    curr_sum = 0; \n  \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long ans1 = max_sum; \n  \n    curr_sum = 0; \n    for (i = n - 1; i >= 0; i--) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long ans2 = max_sum; \n  \n    long ans3 = sum; \n  \n    return max(ans1 + ans2 + (k - 2) * sum, ans3); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = n; \n    long count = 0; \n  \n    // Find the sum of the original array \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find the sum of the subarray \n    // formed by repeating the given array \n    // k times \n    for (i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n  \n        // When size of the current subarray \n        // becomes equal to size of original \n        // array, compare curr_sum with max_sum \n        // and update max_sum if required \n        if ((i + 1) % n == 0) { \n            max_sum = max(max_sum, curr_sum); \n            curr_sum = 0; \n        } \n    } \n  \n    // Compare the sum of the complete array \n    // with max_sum and update max_sum if required \n    max_sum = max(max_sum, curr_sum); \n  \n    // Return maximum possible sum \n    return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[n - 1]) + \n                        a[n - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    long max_non_wrap = max_wrap; \n    max_wrap = max_wrap * k; \n    max_wrap = max(max_wrap, max_non_wrap); \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2 \n    long curr_max = max_so_far; \n    for (long i = 1; i < k; i++) { \n        curr_max = 0; \n        long temp = 0; \n        for (long j = 0; j < n; j++) { \n            temp += a[j]; \n            curr_max = max(curr_max, temp); \n        } \n        max_sum += curr_max; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n        max_sum = max_sum - (k - 1) * a[i]; \n    } \n    return max_val; \n} \n  ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i = 0; \n    for (i = 0; i < n * k; i++) \n    { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    long sum = 0; \n    for (i = start; i <= end; i++) \n        sum += a[i % n]; \n    return sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = 0; \n    long min_elem = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long l = 0; \n    long m = 0; \n  \n    // Finding sum of original array \n    for (i = 0; i < n; i++) { \n        sum += a[i]; \n        max_elem = max(max_elem, a[i]); \n        min_elem = min(min_elem, a[i]); \n    } \n  \n    // Finding maximum sum subarray \n    // using kadane's algorithm \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // If all elements of array are \n    // negative \n    if (max_sum == 0) \n        return max_elem; \n  \n    // Case 1 \n    long case_1 = max_sum; \n  \n    // Case 2 \n    long case_2 = max_sum + (sum * (k - 2)); \n  \n    // Case 3 \n    long case_3 = sum * (k - 1); \n  \n    // Case 4 \n    long case_4 = 0; \n    for (i = 0; i < n; i++) { \n        sum = 0; \n        for (j = i; j < n; j++) { \n            sum += a[j]; \n            if (sum > case_4) \n                case_4 = sum; \n        } \n    } \n  \n    // Case 5 \n    long case_5 = 0; \n    for (i = 0; i < n; i++) { \n        sum = 0; \n        for (",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    max_wrap = max_wrap + curr_sum; \n  \n    if (k == 1) \n        return max(max_sum, max_wrap); \n    return max(max_sum, max_wrap + (k - 2) * max_wrap); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_k_times(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = sum + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_sum, sum * k); \n",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n    long i; \n    for (i = 0; i < n * k; i++) \n    { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    max_wrap = max_wrap + sum; \n    if (k == 1) \n        return max_sum; \n    return max(max_sum, max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    max_sum = max_sum + (k - 2) * sum; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n    long sum = 0; \n  \n    // Find sum of all elements of array. \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of k subarrays each of size n. \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n  \n        // If i >= k-1, then curr_sum stores sum of last k-1 elements \n        // and 'sum' stores sum of all elements. \n        if (i >= k - 1) { \n            max_sum = max(max_sum, curr_sum); \n  \n            // Remove first element of current subarray. \n            curr_sum -= sum; \n        } \n    } \n  \n    // If k > size of array, then curr_sum will store sum of last n elements. \n    max_sum = max(max_sum, curr_sum); \n  \n    return max_sum; \n} \n  \n// Driver program to test above function ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum + max_wrap); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the sum of the first window of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by \n    // removing first element of previous \n    // window and adding last element of  \n    // current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    // Case 1: get the maximum sum using standard kadane's  \n    // algorithm \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    max_sum = max_so_far; \n  \n    // Case 2: Now find the maximum sum that  \n    // is possible by looping through the given array. \n    long curr_max = 0; \n    for (long i = 0; i < n; i++) { \n        curr_max = curr_max + a[i]; \n        max_sum = max(max_sum, curr_max); \n        curr_max = max(curr_max, 0); \n    } \n  \n    // Case 3: Maximum sum is possible by  \n    // concatenating the array k times \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    max_sum = max(max_sum, sum * k); \n  \n    // Case 4: We can get maximum sum by  \n    // concatenating two array. \n    // Initialize first and second half sum \n    long max_left_sum = INT_MIN; \n    long max_right_sum = INT_MIN; \n    long left_sum = 0, right_sum = 0; \n  \n    // Find the maximum sum in left part \n   ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    else\n        return max_sum; \n} ",
    "{ \n    // Find sum of all elements. \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of elements in a single rotation. \n    long rotation_sum = 0; \n    for (long i = 0; i < n; i++) \n        rotation_sum += (i * a[i]); \n  \n    // Find maximum rotation sum. \n    long max_rotation_sum = rotation_sum; \n    for (long i = 1; i < n; i++) { \n        rotation_sum += sum - n * a[n - i]; \n        max_rotation_sum = max(max_rotation_sum, rotation_sum); \n    } \n  \n    // Return maximum rotation sum divided by k. \n    return max_rotation_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first \n    // element of previous window and adding last element \n    // of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n  \n    return max(max_wrap, max_sum * k); \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_so_far = 0, max_ending_here = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    return max_so_far; \n} \n  \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n   ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (int i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of elements in a single rotation \n    long rotation_sum = 0; \n    for (int i = 0; i < n; i++) \n        rotation_sum += i * a[i]; \n  \n    // Initialize result \n    long max_sum = rotation_sum; \n  \n    // Try all rotations one by one and find \n    // the maximum rotation sum. \n    for (int j = 1; j < n; j++) \n    { \n        rotation_sum += sum - n * a[n - j]; \n        max_sum = max(max_sum, rotation_sum); \n    } \n  \n    // Return result \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    max_sum = max(max_sum, curr_sum); \n    return max_sum + (k - 2) * sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    long max_wrap_ending_here = 0; \n    for (i = 0; i < n; i++) \n    { \n        max_wrap_ending_here += a[i]; \n        if (max_wrap < max_wrap_ending_here) \n            max_wrap = max_wrap_ending_here; \n        if (max_wrap_ending_here > 0) \n            max_wrap_ending_here = 0; \n    } \n    long max_sum_k = max_wrap + max_sum; \n    if (max_sum_k < max_sum) \n        max_sum_k = max_sum; \n    return max_sum_k; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    return max_sum; \n} \nlong max_sub",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the sum of first window of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    for (i = n; i < n * k; i++) { \n  \n        // Update current sum \n        curr_sum += a[i % n] - a[(i - n) % n]; \n  \n        // Update result if required \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n  \n    // Finding sum of array \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of subarray \n    // containing first element \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Finding sum of subarray \n    // containing last element \n    curr_sum = 0; \n    for (i = n - 1; i >= 0; i--) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Finding sum of subarray \n    // containing maximum element \n    curr_sum = 0; \n    long max_element = a[0]; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (a[i] > max_element) { \n            max_element = a[i]; \n            j = i; \n        } \n    } \n  \n    // If maximum element is negative \n    if (max_element < 0) \n        return max_element * k; \n  \n    // Finding sum of subarray \n    // containing maximum element \n    // and not first and last element \n    curr_sum = 0; \n    for (i = j; i < n + j; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Finding sum of subarray \n    // containing first and last element \n    curr_sum = 0; \n    for (i = 0; i < 2 * n; i++) { ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the sum of first window of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Maintain maximum sum \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by \n    // removing first element of previous \n    // window and adding last element of \n    // current window. \n    for (i = n; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    long max_wrap = 0; \n    long wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        wrap += a[i]; \n        if (max_wrap < wrap) \n            max_wrap = wrap; \n    } \n    if (max_wrap > 0) \n        return max(max_wrap * k, max_sum); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_element = max(max_element, a[i]); \n    } \n    if (max_element <= 0) \n        return max_element; \n    for (long i = 0; i < n * k; i++) \n    { \n        curr_sum += a[i % n]; \n        max_sum = max(curr_sum, max_sum); \n        curr_sum = max(curr_sum, 0); \n    } \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        long next_val = curr_val - sum + a[i - 1] * n; \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous \n    // window and adding last element of current window. \n    curr_sum = max_sum; \n    for (i = n; i < n * k; i++) { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i = 0; \n    long j = 0; \n    long max_so_far = 0; \n    long sum = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    max_so_far = sum; \n  \n    for (i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long min_sum = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    long min_start = 0; \n    long min_end = 0; \n    long min_s = 0; \n  \n    for (i = 0; i < n; i++) { \n        min_ending_here += a[i]; \n  \n        if (min_so_far > min_ending_here) { \n            min_so_far = min_ending_here; \n            min_start = min_s; \n            min_end = i; \n        } \n  \n        if (min_ending_here > 0) { \n            min_ending_here = 0; \n            min_s = i + 1; \n        } \n    } \n  \n    min_sum = min_so_far; \n  \n    long wrap_sum = 0; \n    for (i = 0; i < n; i++) { \n        wrap_sum += a[i]; \n        a[",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i = 0; \n  \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (sum > max_sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (sum > max_sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k == 1) \n        return max_sum; \n  \n    return max(max_sum, max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap_sum = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    max_wrap_sum = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        max_wrap_sum += a[i]; \n        max_sum = max(max_sum, max_wrap_sum); \n        if (max_wrap_sum < 0) \n            max_wrap_sum = 0; \n    } \n  \n    return max(max_sum, max_so_far); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) { \n        long sum = 0; \n        for (long j = i; j < n; j++) { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n  \n    long sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n    } \n  \n    max_sum = max(max_sum, sum * k); \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_sum = max(max_sum, sum + (k - 1) * sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long sum = 0; \n  \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n        sum += a[i]; \n    } \n  \n    if (sum < 0) \n        return max(max_sum, min_sum + sum * (k - 2)); \n  \n    return max(max_sum, sum * k - min_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long total = 0; \n  \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n        max_sum = max(max_sum, max_ending_here); \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n        min_sum = min(min_sum, min_ending_here); \n        total += a[i]; \n    } \n  \n    if (total == min_sum) \n        return max(max_sum, min_sum * k); \n  \n    long ans = max(max_sum, (total * k - min_sum)); \n    ans = max(ans, max_sum + (total * (k - 2)) + min_sum); \n    return ans; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    max_wrap = max_wrap * k; \n    if (max_wrap > 0) \n        max_sum = max(max_sum, max_wrap); \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    // Iterate through the array \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n  \n        // If the current sum is less than 0, \n        // then set it to 0 \n        if (curr_sum < 0) \n            curr_sum = 0; \n  \n        // If the current sum is greater than \n        // the maximum sum, then update the \n        // maximum sum \n        else if (curr_sum > max_sum) \n            max_sum = curr_sum; \n    } \n  \n    // If the maximum sum is 0, then all \n    // the elements are negative \n    if (max_sum == 0) { \n        max_sum = a[0]; \n        for (long i = 1; i < n; i++) \n            if (a[i] > max_sum) \n                max_sum = a[i]; \n    } \n  \n    // Return the maximum sum \n    return max_sum * k; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap = 0; \n    long temp = 0; \n  \n    for (long i = 0; i < n; i++) { \n        temp += a[i]; \n        max_wrap = max(max_wrap, temp); \n        if (temp < 0) \n            temp = 0; \n    } \n  \n    max_wrap *= k; \n    max_sum = max(max_wrap, max_so_far); \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    curr_sum = max_sum; \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} \nlong max_sub_array_sum_repeated_kadane(long[] a, long n, long k) \n{ \n    long max_so_far = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    return max_so_far * k; \n} \nlong max_sub_array_sum_repeated_kadane_mod(long[] a, long n, long k) \n{ \n    long max_so_far = 0; \n    long max_ending_here = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here += a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated_k",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = *max_element(a.ptr, a.ptr + n); \n    long min_elem = *min_element(a.ptr, a.ptr + n); \n    long total_sum = accumulate(a.ptr, a.ptr + n, 0); \n  \n    if (max_elem < 0) \n        return max_elem * k; \n  \n    if (min_elem > 0) \n        return min_elem * k; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long ans1 = max_sum + (k - 2) * total_sum; \n    long ans2 = max_sum; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long ans3 = max_sum; \n  \n    return max(ans1, max(ans2, ans3)); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n    long result = max_sum + (k - 2) * sum; \n    return max(result, max_sum + sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n  \n    // k times repetition of array \n    for (i = 0; i < k; i++) { \n  \n        // finding maximum sum subarray \n        // using kadane's algorithm \n        curr_sum = 0; \n        for (j = 0; j < n; j++) { \n            curr_sum = max(a[j], curr_sum + a[j]); \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != n - 1) \n            max_sum = max(max_sum, curr_sum); \n        curr_sum = curr_sum % sum; \n    } \n  \n    long ans = max(max_sum, curr_sum); \n    return ans * k; \n} ",
    "{ \n    long max_sum = 0; \n    long current_sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_element = max(max_element, a[i]); \n        current_sum += a[i]; \n        if (current_sum < 0) \n            current_sum = 0; \n        max_sum = max(max_sum, current_sum); \n    } \n    if (max_sum == 0) \n        return max_element; \n    long sum_of_all_elements = 0; \n    for (long i = 0; i < n; i++) \n        sum_of_all_elements += a[i]; \n    long max_wrap = sum_of_all_elements * k; \n    long max_wrap_sum = sum_of_all_elements; \n    for (long i = 0; i < n; i++) \n    { \n        current_sum += a[i]; \n        if (current_sum < 0) \n            current_sum = 0; \n        max_wrap_sum = max(max_wrap_sum, current_sum); \n    } \n    return max(max_wrap + max_wrap_sum, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    // Find sum of all elements \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of k subarrays \n    // each of size n \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i == n - 1) \n            curr_sum = curr_sum - (sum * (k - 1)); \n  \n        max_sum = max(max_sum, curr_sum); \n  \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long min_ending_here = 0; \n    long min_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        max_ending_here += a[i]; \n        min_ending_here += a[i]; \n  \n        if (max_ending_here > max_sum) \n            max_sum = max_ending_here; \n  \n        if (min_ending_here < min_sum) \n            min_sum = min_ending_here; \n  \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n  \n        if (min_ending_here > 0) \n            min_ending_here = 0; \n    } \n  \n    if (sum > 0) \n        return max(max_sum, sum * k); \n  \n    return max(max_sum, min_sum + sum * (k - 1)); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n  \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum * k); \n    else\n        return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long min_sum = 0; \n    long min_ending_here = 0; \n    long min_so_far = 0; \n    long start1 = 0; \n    long end1 = 0; \n    long s1 = 0; \n  \n    // Case 2 \n    for (long i = 0; i < n; i++) { \n        min_ending_here = min_ending_here + a[i]; \n        if (min_so_far > min_ending_here) { \n            min_so_far = min_ending_here; \n            start1 = s1; \n            end1 = i; \n        } \n  \n        if (min_ending_here > 0) { \n            min_ending_here = 0; \n            s1 = i + 1; \n        } \n    } \n  \n    long max_wrap = 0; \n    long min_wrap = 0; \n  \n    // Case 3 \n    for (long i = 0; i < n; i++) { \n        max_wrap = max_wrap + a[i]; \n        min_wrap = min_wrap + a[i]; \n    } \n  \n    min_wrap = min_wrap + (k - 2) * min_sum; \n  ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    long i; \n    for (i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    long sum = 0; \n    for (i = end; i > start; i--) { \n        sum += a[i % n]; \n        if (sum == max_so_far) { \n            start = i % n; \n            break; \n        } \n    } \n    return max_so_far; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_so_far = a[0]; \n    long curr_max = a[0]; \n    long i; \n    for (i = 1; i < n; i++) { \n        curr_max = max(a[i], curr_max + a[i]); \n        max_so_far = max(max_so_far, curr_max); \n    } \n    return max_so_far; \n} \nlong max_sub_array_sum_circular(long[] a, long n) \n{ \n    long max_kadane = max_sub_array_sum(a, n); \n    long max_wrap = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    return max(max_sum, max_wrap * (k - 2)); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Find the max sum subarray in first window of size n \n    for (int i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    // max_so_far is the maximum sum of subarray in first window \n    // of size n. \n    max_sum = max_so_far; \n  \n    // Consider remaining windows \n    for (int i = 1; i < k; i++) { \n  \n        // Find max_ending_here in next window \n        long max_ending_here = 0; \n        for (int j = 0; j < n; j++) { \n            max_ending_here += a[j]; \n            if (max_ending_here > max_sum) \n                max_sum = max_ending_here; \n            if (max_ending_here < 0) \n                max_ending_here = 0; \n        } \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    long min_elem = a[0]; \n    for (long i = 0; i < n; i++) { \n        max_elem = max(max_elem, a[i]); \n        min_elem = min(min_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_elem < 0) \n        return max_elem; \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, 1); \n    long min_sum = min_sub_array_sum_repeated(a, n, 1); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    long ans1 = max_sum + (k - 2) * min_sum; \n    long ans2 = max_sum + (k - 2) * max_wrap; \n    long ans3 = max_wrap; \n    return max(ans1, max(ans2, ans3)); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long[] sum = new long[n]; \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum = (curr_sum + a[(int)(i)]) % k; \n        max_sum = max(max_sum, curr_sum); \n        sum[(int)(i)] = curr_sum; \n    } \n    for (long i = 0; i < n; i++) \n    { \n        for (long j = i + 1; j < n; j++) \n        { \n            long curr_sum = (sum[(int)(j)] - sum[(int)(i)] + k) % k; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n    return max_sum; \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum = (curr_sum + a[(int)(i)]) % n; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_k(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) \n    { \n        max_val = max(max_val, a[(int)(i)]); \n        a[(int)(i)] = (a[(int)(i)] % n + n) % n; \n    } \n    if (max_val <= 0) \n        return max_sum; \n    max_sum = max(max_sum",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum = sum + a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix = 0; \n    long curr_suffix = 0; \n    long max_prefix = 0; \n    long max_suffix = 0; \n    long total_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        total_sum += a[i]; \n        curr_prefix = max(curr_prefix, curr_sum); \n        max_prefix = max(max_prefix, curr_prefix); \n        curr_sum = min(curr_sum, 0); \n    } \n  \n    curr_sum = 0; \n  \n    for (long i = n - 1; i >= 0; i--) { \n        curr_sum += a[i]; \n        curr_suffix = max(curr_suffix, curr_sum); \n        max_suffix = max(max_suffix, curr_suffix); \n        curr_sum = min(curr_sum, 0); \n    } \n  \n    if (total_sum < 0) \n        max_sum = max(max_prefix + max_suffix, max_prefix); \n    else\n        max_sum = max(max_prefix + max_suffix, \n                      max_prefix + max_suffix + (k - 2) * total_sum); \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    return max_sum; \n} \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long m = 0; \n  \n    // Find sum of all elements of array \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of k subarrays \n    // each of size n \n    curr_sum = sum * k; \n  \n    // Find maximum sum of k subarrays \n    // each of size n \n    for (i = 0; i < n; i++) { \n  \n        // Find sum of k subarrays \n        // each of size n starting \n        // with i-th element \n        curr_sum = curr_sum - (sum - a[i]); \n  \n        // Update maximum sum \n        max_sum = max(max_sum, curr_sum); \n  \n        // Find sum of k subarrays \n        // each of size n starting \n        // with (i+1)-th element \n        curr_sum = curr_sum + (sum - a[i]); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = *max_element(a, a + n); \n  \n    if (max_elem <= 0) \n        return max_elem * k; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    max_wrap = max_wrap + curr_sum; \n  \n    return max(max_sum, max_wrap * (k - 2)); \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum_repeated(a, n, 1); \n    return max(max_wrap, max_sum); \n} \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    return max_sum; \n} \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum(a, n); \n    if (k == 1) \n        return max_sum; \n    long max_wrap = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return max(max_wrap, max_sum); \n}",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long current_sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            current_sum += a[j]; \n            if (current_sum > max_sum) \n                max_sum = current_sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0; \n  \n    for (long i = 0; i < n; i++) { \n        total_sum += a[i]; \n        curr_sum += i * a[i]; \n    } \n  \n    max_sum = curr_sum; \n  \n    for (long i = 1; i < k; i++) { \n        curr_prefix_sum = curr_prefix_sum + total_sum - n * a[n - 1]; \n        curr_suffix_sum = curr_suffix_sum + total_sum - n * a[0]; \n        curr_sum = curr_prefix_sum + curr_suffix_sum; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long max_element = *max_element(a, a+n); \n  \n    if (max_element < 0) \n        return max_element; \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (sum < 0) \n            sum = 0; \n        max_sum = max(max_sum, sum); \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    for (long i = 0; i < n; i++) { \n        sum += a[i]; \n        if (sum < 0) \n            sum = 0; \n        max_sum = max(max_sum, sum); \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k > 1) \n        max_sum = max(max_sum, max_wrap); \n  \n    return max_sum; \n} ",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n  \n    // Find the maximum sum subarray in  \n    // first window of size n. \n    for (long i = 0; i < n; i++) \n    { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    // Do for remaining windows. \n    for (long i = n; i < n * k; i++) \n    { \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find sum of first subarray \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Maintain maximum sum subarray found so far \n    max_sum = max(max_sum, curr_sum); \n  \n    // Find sum of remaining subarrays \n    for (i = 1; i < k; i++) { \n  \n        // Sum of next subarray is obtained by removing \n        // first element of previous subarray and adding \n        // last element of current subarray. \n        curr_sum = curr_sum - a[n - i] + a[i - 1]; \n  \n        // Update maximum sum subarray found so far \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n    long max_sum_i = 0; \n    long max_sum_j = 0; \n    long max_sum_so_far = 0; \n  \n    // Iterate over the array \n    while (i < n * k) { \n  \n        // Increment the sum \n        sum += a[j]; \n  \n        // If sum is greater than max_sum \n        if (sum > max_sum) { \n            max_sum = sum; \n            max_sum_i = i; \n            max_sum_j = j; \n        } \n  \n        // If sum is less than 0, then set sum to 0 \n        if (sum < 0) { \n            sum = 0; \n            j = i + 1; \n        } \n  \n        // Increment i and j \n        i++; \n        j = (j + 1) % n; \n    } \n  \n    // Store the maximum sum \n    max_sum_so_far = max_sum; \n  \n    // Iterate over the array \n    while (i < n * k) { \n  \n        // Increment the sum \n        sum += a[j]; \n  \n        // If sum is greater than max_sum \n        if (sum > max_sum) { \n            max_sum = sum; \n            max_sum_i = i; \n            max_sum_j = j; \n        } \n  \n        // If sum is less than 0, then set sum to 0 \n        if (sum < 0) { \n            sum = 0; \n            j = i + 1; \n        } \n  \n        // Increment i and j \n        i++; \n        j = (j + 1) % n; \n    } \n  \n    // Return the maximum sum \n    return max(max_sum_so_far, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_element = 0; \n    long sum_of_all_elements = 0; \n    long i = 0; \n    long j = 0; \n  \n    // Finding the maximum element in the array \n    for (i = 0; i < n; i++) \n    { \n        max_element = max(max_element, a[i]); \n        sum_of_all_elements += a[i]; \n    } \n  \n    // If all the elements in the array are negative \n    if (max_element < 0) \n        return max_element * k; \n  \n    // If there is only one element in the array \n    if (n == 1) \n        return a[0] * k; \n  \n    // Case 1: Maximum sum subarray is part of \n    //         one of the k-repeated arrays \n    for (i = 0; i < n * k; i++) \n    { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Case 2: Maximum sum subarray is not part of \n    //         any of the k-repeated arrays \n    curr_sum = 0; \n    for (i = 0; i < n * k; i++) \n    { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Case 3: Maximum sum subarray is a part of \n    //         k-repeated array and is not a part of \n    //         any other k-repeated array \n    long curr_prefix_sum = 0; \n    long curr_suffix_sum = 0; \n    long total_sum = 0",
    "{ \n\t// Compute sum of all subarrays \n\t// and store in prefix sum array. \n\tlong[] prefix_sum = new long[n]; \n\tprefix_sum[0] = a[0]; \n\tfor (long i = 1; i < n; i++) \n\t\tprefix_sum[i] = prefix_sum[i - 1] + a[i]; ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Compute next value using previous \n        // value in O(1) time \n        long next_val = curr_val - (sum - a[n - 1]) + \n                        a[n - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long max_wrap = 0; \n    long temp = 0; \n  \n    for (long i = 0; i < n; i++) { \n        temp += a[i]; \n        max_wrap = max(max_wrap, temp); \n        if (temp < 0) \n            temp = 0; \n    } \n  \n    max_wrap = max_wrap * k; \n    max_sum = max(max_wrap, max_so_far); \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) +  \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_elem = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_elem = max(max_elem, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum > 0) \n        return max_sum * k; \n    if (max_elem < 0) \n        return max_elem * k; \n    return 0; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_wrap = max(max_wrap, curr_sum); \n    } \n    if (max_wrap > 0) \n        return max(max_wrap, max_sum + (k - 2) * max_wrap); \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = max(curr_sum, curr_sum + sum * (k - 1)); \n  \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n  \n    // Find sum of first window of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    for (j = 1; j < k; j++) \n    { \n        long curr_sum1 = 0; \n        for (i = 0; i < n; i++) \n            curr_sum1 += a[(j * n + i) % n]; \n  \n        curr_sum = max(curr_sum, curr_sum1); \n    } \n  \n    return curr_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n  \n    for (long i = 0; i < k * n; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n        max_sum = max_sum - (k - 1) * a[i]; \n    } \n    return max_val; \n} ",
    "{ \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    long max_sum = sum; \n    for (long i = 0; i < n * (k - 1); i++) { \n        sum += a[i % n]; \n        sum -= a[(i + n) % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        long sum = 0; \n        for (long j = i; j < n; j++) \n        { \n            sum += a[j]; \n            if (sum > max_sum) \n                max_sum = sum; \n        } \n    } \n    return max_sum * k; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_wrap < sum) \n            max_wrap = sum; \n    } \n  \n    max_sum = max(max_sum, max_wrap); \n  \n    if (max_wrap < 0) \n        return max_sum; \n  \n    long max_wrap_sum = max_wrap; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_wrap_sum < sum) \n            max_wrap_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    return max(max_sum, max_wrap_sum + (k - 2) * max_wrap); \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_sum = 0; \n    long sum = 0; \n    long i; \n    for (i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n    return max_sum; \n} \n  \nlong max_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = max_sub_array_sum_repeated(a, n, k); \n    if (max_sum < 0) \n        return max_sum;",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long max_element = a[0]; \n    for (long i = 0; i < n; i++) \n    { \n        max_element = max(max_element, a[i]); \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    if (max_sum == 0) \n        return max_element; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    max_sum = max(max_sum, curr_sum + sum * (k - 2)); \n    return max_sum; \n} \nlong max_sub_array_sum_repeated_2(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0",
    "{ \n    // Find sum of original array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of the maximum sum subarray in \n    // first array. \n    long max_sum = max_sub_array_sum(a, n); \n  \n    // max sum is sum of elements when number \n    // of arrays are 1 \n    if (k == 1) \n        return max_sum; \n  \n    // Case 1: When k is odd \n    if (k % 2 != 0) \n        return max(max_sum, (sum * k + max_sum)); \n  \n    // Case 2: When k is even \n    return max(max_sum, (sum * k)); \n} \n  \n// Returns sum of maximum sum subarray in a[0..n-1]. \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_so_far = a[0]; \n    long curr_max = a[0]; \n  \n    for (long i = 1; i < n; i++) \n    { \n        curr_max = max(a[i], curr_max + a[i]); \n        max_so_far = max(max_so_far, curr_max); \n    } \n    return max_so_far; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    long j; \n  \n    // k times sum of all elements \n    long k_sum = 0; \n    for (i = 0; i < n; i++) \n        k_sum += a[i]; \n  \n    // Case 1 \n    for (i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    // Case 2 \n    curr_sum = 0; \n    for (i = 0; i < n * k; i++) { \n        curr_sum += a[i % n]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum > 0) \n            curr_sum = 0; \n    } \n  \n    // Case 3 \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum = 0; \n        for (j = i; j < ((i + 1) * k); j++) { \n            curr_sum += a[j % n]; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    // Case 4 \n    if (k_sum > 0) \n        return max(max_sum, k_sum); \n  \n    // Case 5 \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_sum < max_ending_here) \n            max_sum = max_ending_here; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n    } \n    long max_wrap = 0; \n    long min_wrap = 0; \n    for (i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        min_wrap += a[i]; \n        if (max_wrap < 0) \n            max_wrap = 0; \n        if (min_wrap > 0) \n            min_wrap = 0; \n    } \n    long max_wrap_sum = max_wrap; \n    if (k > 1) \n        max_wrap_sum = max(max_wrap_sum, min_wrap + max_wrap); \n    return max(max_sum, max_wrap_sum * (k - 2) + max_sum); \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    curr_sum = 0; \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum < 0) \n            curr_sum = 0; \n        max_sum = max(max_sum, curr_sum); \n    } \n    max_wrap = max_wrap + curr_sum; \n    if (k == 1) \n        return max(max_sum, max_wrap); \n    return max(max_sum, max_wrap + (k - 2) * max_wrap); \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    return max_so_far; \n} \n  \n// Driver Code ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = start; i <= end; i++) \n        sum += a[i % n]; \n  \n    return sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n\t// Find sum of all elements \n\tlong sum = 0; \n\tfor (long i = 0; i < n; i++) \n\t\tsum += a[i]; \n\t\n\t// Find sum of i*arr[i] for initial \n\t// configuration. \n\tlong curr_val = 0; \n\tfor (long i = 0; i < n; i++) \n\t\tcurr_val += i * a[i]; \n\t\n\t// Initialize result \n\tlong res = curr_val; \n\t\n\t// Compute values for other iterations \n\tfor (long i = 1; i < k; i++) \n\t{ \n\t\t// Compute next value using previous \n\t\t// value in O(1) time \n\t\tlong next_val = curr_val - (sum - a[i-1]) + \n\t\t\t\t\t\ta[i-1] * (n-1); \n\t\n\t\t// Update current value \n\t\tcurr_val = next_val; \n\t\n\t\t// Update result if required \n\t\tres = max(res, next_val); \n\t} \n\t\n\treturn res; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the maximum sum subarray in first window of size n \n    for (i = 0; i < n; i++) \n    { \n        curr_sum += a[i]; \n    } \n  \n    // Maintain maximum sum \n    max_sum = max(max_sum, curr_sum); \n  \n    // Compute sums of remaining windows by removing first element of previous window and adding last element of current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    long max_sum = sum; \n    for (long p = 1; p < k; p++) { \n        for (long i = 0; i < n; i++) { \n            long x = a[i] * (p * n + i + 1); \n            sum = sum - a[i] + x; \n            max_sum = max(max_sum, sum); \n        } \n    } \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n  \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    for (long i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (i != 0) \n            curr_sum = max(curr_sum, curr_sum + sum * (k - 1)); \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long sum = 0; \n    long i = 0; \n    long j = 0; \n  \n    // Finding sum of the original array \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Finding sum of the first subarray \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Finding sum of the middle subarrays \n    for (j = 2; j <= k - 1; j++) { \n        for (i = 0; i < n; i++) { \n            curr_sum = max(curr_sum + a[i], a[i]); \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    // Finding sum of the last subarray \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Finding sum of the middle subarrays \n    for (j = 2; j <= k - 1; j++) { \n        for (i = 0; i < n; i++) { \n            curr_sum = max(curr_sum + a[i], a[i]); \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    // Finding sum of the last subarray \n    curr_sum = 0; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    // Adding sum of the original array \n    // k-2 because we have already counted \n",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0, s = 0; \n    for (long i = 0; i < n * k; i++) \n    { \n        max_ending_here = max_ending_here + a[i % n]; \n        if (max_so_far < max_ending_here) \n        { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) \n        { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    for (long i = start; i <= end; i++) \n        max_sum = max_sum + a[i % n]; \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    long sum_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum_wrap += a[i]; \n        max_wrap = max(max_wrap, sum_wrap); \n        if (sum_wrap < 0) \n            sum_wrap = 0; \n    } \n  \n    if (k == 1) \n        return max(max_wrap, max_sum); \n  \n    long max_wrap_sum = sum_wrap; \n    max_wrap_sum = max(max_wrap_sum, max_wrap + sum * (k - 2)); \n  \n    return max(max_wrap_sum, max_sum); \n} \n  \nlong max_sub_array_sum_repeated(long[] a, long n, long k) \n{ \n    long max_sum = 0; \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        max_sum = max(max_sum, sum); \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    long sum_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum_wrap += a[i]; \n        max_wrap = max(max_wrap, sum_wrap); \n        if (sum_wrap < 0) \n            sum_wrap = 0; \n    } \n  \n    if (k == 1) \n        return max(max_wrap, max_sum); \n  \n    long max_wrap_sum = sum_",
    "{ \n    // Compute sum of all array elements \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Compute sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (long i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (long i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        long next_val = curr_val - (sum - a[i - 1]) + \n                        a[i - 1] * (n - 1); \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    for (long i = start; i <= end; i++) \n        max_sum += a[i % n]; \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    for (long i = 0; i < n; i++) \n        max_sum += a[i]; \n  \n    long max_val = max_sum; \n    for (long i = 0; i < n; i++) { \n        max_sum = max_sum + (k - 1) * a[i]; \n        max_val = max(max_val, max_sum); \n    } \n    return max_val; \n} \n  \nlong max_sub_array_sum(long[] a, long n) \n{ \n    long max_so_far = 0, max_ending_here = 0; \n    for (long i = 0; i < n; i++) { \n        max_ending_here = max_ending_here + a[i]; \n        if (max_ending_here < 0) \n            max_ending_here = 0; \n        if (max_so_far < max_ending_here) \n            max_so_far = max_ending_here; \n    } \n    return max_so_far; \n} \n  \nlong max_sub_array_sum_circular(long[] a, long n) \n{ \n    long max_kadane = max_sub_array_sum(a, n); \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n    max_wrap = max_wrap + max_sub_array_sum(a, n); \n    return (max_wrap > max_kadane) ? max_wrap : max_kadane; \n} \n  \nlong max_sub_array_sum_circular_repeated(long[] a, long n, long k) \n{ \n    long max_kadane = max_sub_array_sum_repeated(a, n, k); \n    long max_wrap = 0; \n    for (long i = 0; i < n",
    "{ \n    long max_sum = 0, sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    long max_wrap = 0; \n    for (long i = 0; i < n; i++) \n    { \n        max_wrap += a[i]; \n        a[i] = -a[i]; \n    } \n  \n    sum = 0; \n    for (long i = 0; i < n; i++) \n    { \n        sum += a[i]; \n        if (max_sum < sum) \n            max_sum = sum; \n        if (sum < 0) \n            sum = 0; \n    } \n  \n    max_wrap = max_wrap + sum; \n  \n    if (k == 1) \n        return max_sum; \n  \n    return max(max_wrap, max_sum); \n} ",
    "{ \n    long max_sum = 0; \n  \n    // Find sum of all subarrays and store in max_sum \n    for (long i = 0; i < n; i++) { \n        long curr_sum = 0; \n        for (long j = i; j < n; j++) { \n            curr_sum += a[j]; \n            max_sum = max(max_sum, curr_sum); \n        } \n    } \n  \n    // Multiply max_sum by k and return \n    return max_sum * k; \n} ",
    "{ \n    // Find sum of all elements \n    long sum = 0; \n    for (int i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of i*arr[i] for initial \n    // configuration. \n    long curr_val = 0; \n    for (int i = 0; i < n; i++) \n        curr_val += i * a[i]; \n  \n    // Initialize result \n    long res = curr_val; \n  \n    // Compute values for other iterations \n    for (int i = 1; i < k; i++) { \n        // Change value of arr[i%n] \n        // arr[i%n] = arr[i%n] * (n-i) \n        long next_val = curr_val - sum +  \n                        a[i % n] * n; \n  \n        // Update current value \n        curr_val = next_val; \n  \n        // Update result if required \n        res = max(res, next_val); \n    } \n  \n    return res; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0, end = 0; \n    long s = 0; \n  \n    for (long i = 0; i < n * k; i++) { \n        max_ending_here += a[i % n]; \n  \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n  \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n  \n    long sum = 0; \n    for (long i = end; i > start; i--) { \n        sum += a[i % n]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} \n  \n// Driver code ",
    "{ \n    // Find the sum of the original array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find the sum of the modified array \n    // (Note that sum can be negative) \n    long max_sum = sum; \n    for (long i = 0; i < n; i++) { \n        sum += (k - 1) * a[i]; \n        max_sum = max(max_sum, sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    // Find sum of all elements of array \n    long sum = 0; \n    for (long i = 0; i < n; i++) \n        sum += a[i]; \n  \n    // Find sum of middle n elements \n    // i.e. sum of elements from index \n    // n/2 to n-1 \n    long curr_sum = 0; \n    for (long i = n / 2; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Initialize result \n    long res = curr_sum; \n  \n    // Consider all subarrays starting \n    // from i = n/2 and ending at j = n-1. \n    // Update result if required \n    for (long i = n / 2 - 1; i >= 0; i--) { \n        curr_sum += sum - n * a[i + n / 2]; \n        res = max(res, curr_sum); \n    } \n  \n    // Return maximum sum of middle \n    // elements of all k subarrays \n    return res * k; \n} \n  \n// Driver code ",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n  \n    // Find the sum of the first window of size n \n    for (i = 0; i < n; i++) \n        curr_sum += a[i]; \n  \n    // Compute sums of remaining windows by  \n    // removing first element of previous  \n    // window and adding last element of  \n    // current window. \n    for (i = n; i < n * k; i++) \n    { \n        curr_sum += a[i % n] - a[(i - n) % n]; \n        max_sum = max(max_sum, curr_sum); \n    } \n  \n    return max_sum; \n} ",
    "{ \n    long max_sum = 0; \n    long max_ending_here = 0; \n    long max_so_far = 0; \n    long start = 0; \n    long end = 0; \n    long s = 0; \n  \n    // Case 1 \n    for (long i = 0; i < n; i++) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = s; \n            end = i; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i + 1; \n        } \n    } \n    max_sum = max_so_far; \n  \n    // Case 2 \n    if (k > 1) { \n        max_ending_here = 0; \n        for (long i = 0; i < n; i++) { \n            max_ending_here += a[i]; \n            if (max_ending_here < 0) { \n                max_ending_here = 0; \n            } \n        } \n        if (max_ending_here > 0) { \n            max_sum = max(max_sum, max_ending_here * k); \n        } \n    } \n  \n    // Case 3 \n    max_ending_here = 0; \n    for (long i = n - 1; i >= 0; i--) { \n        max_ending_here += a[i]; \n        if (max_so_far < max_ending_here) { \n            max_so_far = max_ending_here; \n            start = i; \n            end = s; \n        } \n        if (max_ending_here < 0) { \n            max_ending_here = 0; \n            s = i - 1; \n        } \n    } \n    max_sum = max(max_sum, max_so_far * k); \n  \n    // Case",
    "{ \n    long max_sum = 0; \n    long curr_sum = 0; \n    long i; \n    for (i = 0; i < n; i++) { \n        curr_sum += a[i]; \n        if (curr_sum > max_sum) \n            max_sum = curr_sum; \n        if (curr_sum < 0) \n            curr_sum = 0; \n    } \n    long sum = 0; \n    for (i = 0; i < n; i++) \n        sum += a[i]; \n    if (sum > 0) \n        max_sum = max(max_sum, sum * k); \n    else\n        max_sum = max(max_sum, sum); \n    long curr_prefix = 0; \n    for (i = 0; i < n; i++) { \n        curr_prefix += a[i]; \n        if (curr_prefix > max_sum) \n            max_sum = curr_prefix; \n        if (curr_prefix < 0) \n            curr_prefix = 0; \n    } \n    long curr_suffix = 0; \n    for (i = n - 1; i >= 0; i--) { \n        curr_suffix += a[i]; \n        if (curr_suffix > max_sum) \n            max_sum = curr_suffix; \n        if (curr_suffix < 0) \n            curr_suffix = 0; \n    } \n    return max_sum; \n} "
  ]
}