name: HumanEval_120_maximum
language: sh
prompt: "#!/bin/bash\n# Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n# of length k with the maximum k numbers in arr.\n# Example 1:\n\
  # >>> $(maximum \"-3 -4 5\" \"3\")\n# ['\"-4\"', '\"-3\"', '\"5\"']\n# Example 2:\n\
  # >>> $(maximum \"4 -4 4\" \"2\")\n# ['\"4\"', '\"4\"']\n# Example 3:\n# >>> $(maximum\
  \ \"-3 2 1 2 -1 -2 1\" \"1\")\n# ['\"2\"']\n# Note:\n# 1. The length of the array\
  \ will be in the range of [1, 1000].\n# 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\n#\n# $1 is a space-separated\
  \ list\n# $2 is an integer\nmaximum() {\n"
tests: "}\n\ncandidate() {\n    maximum \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"-3 -4 5\" \"3\") = \"-4 -3 5\" ]]\n    [[ $(candidate \"4 -4 4\"\
  \ \"2\") = \"4 4\" ]]\n    [[ $(candidate \"-3 2 1 2 -1 -2 1\" \"1\") = \"2\" ]]\n\
  \    [[ $(candidate \"123 -123 20 0 1 2 -3\" \"3\") = \"2 20 123\" ]]\n    [[ $(candidate\
  \ \"-123 20 0 1 2 -3\" \"4\") = \"0 1 2 20\" ]]\n    [[ $(candidate \"5 15 0 3 -13\
  \ -8 0\" \"7\") = \"-13 -8 0 0 3 5 15\" ]]\n    [[ $(candidate \"-1 0 2 5 3 -10\"\
  \ \"2\") = \"3 5\" ]]\n    [[ $(candidate \"1 0 5 -7\" \"1\") = \"5\" ]]\n    [[\
  \ $(candidate \"4 -4\" \"2\") = \"-4 4\" ]]\n    [[ $(candidate \"-10 10\" \"2\"\
  ) = \"-10 10\" ]]\n    [[ $(candidate \"1 2 3 -23 243 -400 0\" \"0\") = \"\" ]]\n\
  }\n\nrun_test"
completions: ["    local arr=\"$1\"\n    local k=\"$2\"\n    local max_arr\n    local\
    \ max_idx\n    local max_val\n    local idx\n    local val\n\n    max_arr=($arr)\n\
    \    k=$((k-(k%1)));\n\n    for ((idx=0; idx<k; idx++));\n    do\n        max_idx=$((max_idx+1))\n\
    \        if ((max_idx==0)); then\n            val=$max_arr[idx]\n        else\n\
    \            val=${max_arr[max_idx]}\n        fi\n        max_arr=($max_arr [${#max_arr[@]}-1])\n\
    \        if ((val>max_val));\n        then\n            max_val=${val}\n     \
    \       max_idx=0\n        else\n            max_arr=($max_arr [${#max_arr[@]}-1])\n\
    \        fi\n    done\n\n    echo \"${max_arr[@]}\"", "  local array=\"$1\"\n\
    \  local k=\"$2\"\n  local len=\"${#array}\"\n  local max_val=\"${array[0]}\"\n\
    \  local max_index=\"${array[1]}\"\n  local i\n\n  (( k = k % len )); echo \"\
    ${array[@]:0:k}\" >> \"${tmpdir}/${__FILE__}\"\n\n  for i in $(seq $((len - 1));\
    \ do\n    if [[ ${array[$i]} -gt ${max_val} ]]; then\n      max_val=\"${array[$i]}\"\
    \n      max_index=\"${i}\"\n    fi\n  done\n\n  echo \"${array[@]:$max_index}\"\
    \n  rm \"${tmpdir}/${__FILE__}\"", "    local arr k\n    local -i i max_idx max_val\n\
    \    IFS=' ' read -r -a arr <<< \"$1\"\n    k=\"${2:-0}\"\n\n    # Sort arr\n\
    \    for ((i=0; i<${#arr[@]}; ++i));\n    do \n        if [[ ${arr[i]} -gt ${arr[i+1]}\
    \ ]]; then\n            # Move the largest element to max_idx\n            arr[i]=${arr[i+1]}\n\
    \            arr[i+1]=${arr[i]}\n        fi\n    done\n\n    # Sort arr\n    for\
    \ ((i=0; i<${#arr[@]}-1; ++i));\n    do \n        if [[ ${arr[i]} -gt ${arr[i+1]}\
    \ ]]; then\n            # Move the largest element to max_idx\n            arr[i]=${arr[i+1]}\n\
    \            arr[i+1]=${arr[i]}\n        fi\n    done\n\n    # Sort arr\n    for\
    \ ((i=0; i<${#arr[@]}-1; ++i));\n    do \n        if [[ ${arr[i]} -lt ${arr[i+1]}\
    \ ]]; then\n            # Move the largest element to max_idx\n            arr[i]=${arr[i+1]}\n\
    \            arr[i+1]=${arr[i]}\n        fi\n    done\n\n    # Get the max number\n\
    \    max_idx=0\n    max_val=${arr[0]}\n    for ((i=1; i<${#arr[@]}; ++i)); do\n\
    \        if [[ ${arr[i]} -gt ${arr[i-1]} ]]; then\n            max_idx=$((max_idx\
    \ + 1))\n            max_val=${arr[i]}\n        fi\n    done\n\n    # Build result\n\
    \    IFS=$' '\n    local max_str=\"${arr[$max_idx]}\"\n    arr[$max_idx]=\"${arr[$max_idx+1]}\"\
    \n    arr[$max_idx+1]=\"${arr[$max_idx]}\"\n    arr[$max_idx]=\"${max_str}\"\n\
    \    IFS=$' ' \n    echo \"${arr[@]}\"", "    local arr=(\"$@\")\n    local len=${#arr[@]}\n\
    \    local k=$2\n    local ret=()\n    if [[ $len == 0 ]]; then\n        return\
    \ $ret\n    fi\n    local sorted_arr=($(sort -n -k $((k - 1)) -r <<< \"${arr[@]}\"\
    ))\n    while [[ $sorted_arr != '' ]]; do\n        arr=(\"${sorted_arr[@]}\")\n\
    \        local tmp=$(maximum \"${arr[@]}\" \"$k\")\n        if [[ $tmp != '' ]];\
    \ then\n            ret+=(\"$tmp\")\n        fi\n    done\n    echo \"${ret[@]}\"",
  "    local arr=($(echo \"${@}\" | tr \" \" \"\\n\" | sort -n -k1 -r))\n    local\
    \ k=\"${2:-0}\"\n    local output\n    # use for in range 1 to k\n    for i in\
    \ $(seq 1 \"${k}\"); do\n        output+=(\"${arr[$i]}\")\n    done\n    echo\
    \ \"${output[@]}\"", "    arr=$1\n    k=$2\n    arr=($(echo ${arr// /}))\n   \
    \ sortedArr=$(sort -n -k $k)\n    maxArr=$((k - 1))\n    echo $(echo ${sortedArr[${maxArr}]}\
    \ | sed \"s/$arr//\")", "    local arr=$1\n    local k=$2\n    local max_val\n\
    \    local tmp_arr=()\n    # k is larger than arr length\n    if [[ \"$k\" -lt\
    \ \"$#\" ]]; then\n        echo \"Invalid argument k: $k\"\n        return\n \
    \   fi\n    local i\n    # k is smaller than arr length\n    if [[ \"$k\" -gt\
    \ \"$#\" ]]; then\n        k=$((${#arr}+1))\n    fi\n    # Initialize result array\n\
    \    for ((i = 0; i < $k; i++)) {\n        tmp_arr+=(\"${arr[i]}\")\n    }\n \
    \   # Sort the result array in ascending order\n    tmp_arr+=(\"${arr[0]}\")\n\
    \    for ((i = 1; i < $k; i++)); do\n        max_val=\"${tmp_arr[i]}\"\n     \
    \   for ((j = $i; j > 0 && \"${tmp_arr[j]}\" > \"$max_val\"; j--)); do\n     \
    \       tmp_arr[j+1]=\"${tmp_arr[j]}\"\n        done\n        tmp_arr[$i]=\"$max_val\"\
    \n    done\n    echo ${tmp_arr[@]:0:$k}", "  local arr=$1\n  local k=$2\n  local\
    \ m=$((k-1))\n  local max\n  local maxval\n  local j\n  local i\n  local val\n\
    \  local ret\n\n  for j in $(seq 0 $((k-1)) -1); do\n    # find the max element\n\
    \    maxval=$(($(echo \"${arr[*]:$j}\" | sort -n | head -1)))\n    if [[ $maxval\
    \ != $max ]]; then\n      max=$maxval\n      ret=()\n    fi\n    if [[ $maxval\
    \ == $max ]]; then\n      val=$(echo \"${arr[*]:$j}\" | sort -n)\n      for i\
    \ in  $(seq 0 $((j+1))); do\n        if [[ $((j+i)) == $j ]]; then\n         \
    \ ret+=($val)\n        fi\n      done\n    fi\n  done\n  echo ${ret[@]}", "  \
    \  arr=( $1 )\n    k=$2", "    local arr=$1\n    local k=$2\n    local output\n\
    \    local i j max min\n    \n    arr=(${arr[@]})\n    \n    [[ -z ${arr[k]} ]]\n\
    \    [[ -z ${arr[-1]} ]]\n    \n    if [[ -n ${arr[0]} ]]; then\n        # Handle\
    \ the trivial case\n        arr[0]=\"\"\n        output=(-${arr[0]})\n    fi\n\
    \    \n    for ((i = 0; i < ${#arr[@]}; i++)); do\n        if [[ -z ${arr[i]}\
    \ ]]; then\n            # Handle the trivial case\n            arr[i]=\"\"\n \
    \           output+=(${arr[i]})\n            continue\n        fi\n    \n    \
    \    j=0\n        \n        while [[ -z ${arr[j]} && ${j} < ${#arr[@]} ]]; do\n\
    \            j=$((j+1))\n        done\n        \n        min=-1\n        max=-1\n\
    \        \n        while ((j > 0) && (${j} <= ${#arr[@]}) && (${j} < ${k})); do\n\
    \            i=$((j-1))\n            \n            if ((${arr[i]} < ${min}));\
    \ then\n                min=${arr[i]}\n            fi\n            \n        \
    \    if ((${arr[i]} > ${max})); then\n                max=${arr[i]}\n        \
    \    fi\n            \n            j=$((j+1))\n        done\n        \n      \
    \  arr[i]=\"${max}\"\n        output+=(${arr[i]})\n        \n        if [[ -z\
    \ ${arr[i+1]} ]]; then\n            # Handle the trivial case\n            arr[i+1]=\"\
    \"\n            output+=(${arr[i+1]})\n        fi\n    done\n    \n    [[ -z ${arr[-1]}\
    \ ]] && output+=(${arr[-1]})\n    \n    echo \"${output[@]}\"", "    local arr=\"\
    $1\"\n    local k=\"$2\"\n    echo \"${arr[@]}\" | sed -n \"s/^\\(${arr[@]:0:k}\\\
    )\\s*\\(.*\\)/\\2/p\"", "    arr=$1\n    shift\n    arr=$(echo $arr | sed 's/\
    \ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo\
    \ $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n\
    \    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\
    \",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr\
    \ | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n   \
    \ arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\"\
    ,\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr |\
    \ sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo\
    \ $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n\
    \    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\
    \",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr\
    \ | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n   \
    \ arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\"\
    ,\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr |\
    \ sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo\
    \ $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n\
    \    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\
    \",\\\"/g')\n    arr=$(echo $arr | sed 's/ /\\\",\\\"/g')\n    arr=$(echo $arr\
    \ | sed '", "  local arr=(\"$@\")\n  local k=\"$2\"\n  local result=()\n  local\
    \ i=0\n\n  # if k is bigger than length of array\n  if (( \"${k:0:1}\" > \"${#arr[@]}\"\
    \ )); then\n    return 0\n  fi\n\n  # reverse the array\n  for i in \"${arr[@]}\"\
    ;\n  do\n    ((i++))\n  done\n  ((i--))\n\n  # remove k elements and reverse array\
    \ again\n  for ((i--)); do \n    ((result=(${result[@]} ${arr[i]}))\n  done\n\n\
    \  # reverse the array again\n  for i in \"${arr[@]}\";\n  do\n    ((i++))\n \
    \ done\n\n  # sort array in descending order\n  IFS=$'\\n' arr=($(sort -rnr <<<\
    \ \"${result[@]}\"))\n\n  # remove the duplicate elements\n  while IFS='\\n' read\
    \ -r elem; do\n    arr=(${arr[@]/$elem})\n  done <<< \"${arr[@]}\"\n\n  # remove\
    \ trailing newline\n  arr=(\"${arr[@]:0:$k}\")\n\n  # reverse the array again\n\
    \  for i in \"${arr[@]}\";\n  do\n    ((i++))\n  done\n  ((i--))\n\n  # return\
    \ result\n  echo \"${arr[@]}\"", "    arr=$(echo $1 | tr \" \" \"\\n\")\n    num=$(echo\
    \ $2 | tr \" \" \"\\n\")\n    len=$((${#arr[@]} + 1))\n    \n    if [[ $len <=\
    \ 1 ]]; then\n        echo $arr\n        return\n    fi\n    \n    # get the highest\
    \ number\n    arr=($(sort -n -r <<<\"${arr[@]:0:${len}}\"))\n    \n    if [[ -z\
    \ $num ]]; then\n        echo $arr\n        return\n    fi\n    \n    # get the\
    \ number of numbers to sort\n    num=$(echo $num | tr \" \" \"\\n\")\n    \n \
    \   # get length of arr\n    len=$((${#arr[@]} + 1))\n    \n    if [[ $num -gt\
    \ ${#arr[@]} ]]; then\n        echo $arr\n        return\n    fi\n    \n    #\
    \ get highest number in arr\n    if [[ $num -eq 1 ]]; then\n        arr=($(sort\
    \ -n -r <<<\"${arr[@]:1:$num}\"))\n        echo $arr\n        return\n    fi\n\
    \    \n    # get the median value\n    arr=($(sort -n -r <<<\"${arr[@]:$((len/2)):$num}\"\
    ))\n    \n    echo $arr", "    local arr\n    local k\n    arr=$1\n    k=$2\n\
    \    \n    if [ -z \"$arr\" -o -z \"$k\" ]; then\n        echo \"Empty array\"\
    \n        return 0\n    fi\n\n    if [ $k -gt $(echo \"$arr\" | wc -l) ]; then\n\
    \        echo \"Value of k is greater than length of array\"\n        return 0\n\
    \    fi\n\n    local tmp\n    local max_arr\n    max_arr=()\n\n    for (( i =\
    \ 0; i < $(echo \"$arr\" | wc -l); i++ )); do\n        tmp=$(echo \"$arr\" | cut\
    \ -d\" \" -f$i)\n        \n        if [ \"$k\" -lt $(echo \"$tmp\" | wc -l) ];\
    \ then\n            max_arr+=(\"$tmp\")\n            k=$((k-1))\n        fi\n\
    \    done\n    \n    max_arr+=(\"$tmp\")\n    echo \"${max_arr[@]}\"", "  local\
    \ arr=$1\n  local k=${2:-1000}\n  local max_arr\n  local i \n  \n  if [[ -z $arr\
    \ ]] || [[ -z $k ]]; then\n    echo \"No arguments for maximum\"\n    return 0\n\
    \  fi\n  \n  # Parse the string as an integer array\n  IFS=\"-\" read -a arr <<<\
    \ \"$arr\"\n  \n  # Sort by the maximum\n  max_arr=()\n  for ((i = 0; i < k; i++));\
    \ do\n    max_arr+=(\"${arr[i]}\")\n  done\n  max_arr+=(\"${arr[0]}\")\n  \n \
    \ # Convert to a string\n  echo \"${max_arr[@]}\"", "    local arr=$1\n    local\
    \ k=$2\n\n    if [ $k -lt 1 -o $k -lt 1000 ]; then\n        echo \"invalid input:\
    \ k < 1 || k >1000 or k is invalid.\"\n        return 1\n    fi\n\n    local max\n\
    \    local -i cnt=0\n    local -i max_cnt=0\n\n    while [ \"$cnt\" -lt \"$k\"\
    \ ]; do\n        local el=\"$( echo \"$arr\" | head -$(( $cnt + 1 )) | tail -1\
    \ )\"\n        local tmp_max\n        local -i tmp_max_cnt\n\n        if [[ \"\
    $el\" == \"$max\" ]]; then\n            tmp_max_cnt=$(( $tmp_max_cnt + 1 ))\n\
    \            if [ $tmp_max_cnt -eq 0 ]; then\n                tmp_max_cnt=1\n\
    \            fi\n        else\n            tmp_max=\"\\\"$el\\\"\"\n         \
    \   tmp_max_cnt=1\n        fi\n\n        if [ \"$tmp_max_cnt\" -eq \"$max_cnt\"\
    \ ]; then\n            max=\"$tmp_max\"\n            max_cnt=$tmp_max_cnt\n  \
    \      else\n            if [ \"$cnt\" -gt \"$max_cnt\" ]; then\n            \
    \    max=\"$tmp_max\"\n                max_cnt=$tmp_max_cnt\n            fi\n\
    \        fi\n\n        (( cnt+=1 ))\n    done\n\n    echo \"$max\"", "    local\
    \ arr n\n    arr=$1\n    shift\n    n=$1\n    while (( \"$#\" )); do\n       \
    \ n=$(( $n > $(( ${#arr[@]} / 2 )) ? $n : $(( ${#arr[@]} / 2 )) ))\n        arr=(\
    \ \"${arr[@]/$n/}\" )\n    done\n    printf '%s\\n' \"${arr[@]}\"", "    # Convert\
    \ string $1 into array of numbers\n    read -a array <<< \"$1\"\n\n    # Initialize\
    \ max to -1000\n    max=-1000\n\n    # Go through each element of array from last\
    \ to first index\n    for (( index=${#array[@]}; index>0; index-- )); do\n   \
    \     # Check if current element is larger than current max\n        if [[ ${array[index]}\
    \ -gt ${max} ]]; then\n            # If so, update max\n            max=${array[index]}\n\
    \        fi\n    done\n\n    # Return sorted array\n    echo \"${array[@]:0:$max}\"",
  "    local a=\"$1\"\n    local k=\"$2\"\n    local max\n    local m\n    local x\n\
    \    local len\n\n    if [[ ${#a} != $k ]]; then\n        echo \"[ERROR] Given\
    \ array $1 is not long enough.\"\n        echo \"Usage: $(maximum '-3 2 1 2 -1\
    \ -2 1' 1)\"\n        exit 1\n    fi\n    \n    len=$(echo $a | wc -w)\n    #\
    \ echo \"$len $k\"\n    max=$(echo \"$a\" | awk 'BEGIN {max = -999999999999999999;\
    \ m = 0} \n              {if ($1 > max) { max = $1; m = $0; } \n             \
    \ else if ($1 < max) { if (m > 0) print m; m = 0; } \n              else m = $0}\
    \ \n              END {if (m > 0) print m}')\n    \n    echo $max", "    local\
    \ arr=( $1 )\n    local k=( $2 )\n    local i=0\n    local max=\"\"\n    local\
    \ cur=\"\"\n    while (( i < k )); do\n        if [ \"$cur\" != \"\" ]; then\n\
    \            max=$(echo $max \"\\\"$cur\\\"\"; )\n        fi\n        cur=$(echo\
    \ \"${arr[i]}\" | tr -d '\\n')\n        i=$(expr $i + 1)\n    done\n    echo $max",
  "    local a b\n    local -a max\n    local i\n    read -r -a arr <<<\"$1\"\n  \
    \  read -r -a k <<<\"$2\"\n    if [[ ${#arr[@]} < 1 || ${#k[@]} < 1 || ${#arr[@]}\
    \ > 1000 || ${#k[@]} > 1000 ]]; then\n        echo \"Invalid input\"\n       \
    \ return 1\n    fi\n    for ((i=0; i<${#arr[@]}; i+=1)); do\n        if [[ ${arr[i]}\
    \ -gt ${max[i]} ]]; then\n            max[i]=${arr[i]}\n        elif [[ ${arr[i]}\
    \ -lt ${max[i]} ]]; then\n            if [[ ${arr[i]} != ${max[i]} ]]; then\n\
    \                echo \"Error: ${max[i]} is not the maximum\"\n              \
    \  return 1\n            fi\n        fi\n    done\n    for ((j=0; j<${#max[@]};\
    \ j++)); do\n        echo \"${max[j]}\"\n    done", "    arr=($(echo $1 | tr -s\
    \ ' ' \"\\n\"));\n    num=$(echo $2 | sed 's/ /\\n/g');\n    k=$((num-1));\n \
    \   mapfile -t arr2 < <(sort -t ' ' -k$k <<<\"$1\");\n    sort -t ' ' -k$k <<<\"\
    ${arr2[$k]} $2\" | tail -$k", "    local arr=$1\n    local k=$2\n    local max=$((k\
    \ > ${#arr}-1 ? ${#arr}-1 : k))\n    local i\n    local arr1\n    arr1=()\n  \
    \  for i in $(seq 0 $((${#arr}-1)))\n    do\n        arr1+=(\"${arr[$i]}\")\n\
    \    done\n    arr1=(${arr1[@]/#/$((${#arr1[@]} > $max ? $max : ${#arr1[@]}))})\n\
    \    arr=(${arr1[@]})\n    return $arr", "  local arr=$1\n  local k=$2\n  local\
    \ result\n  result=$(echo ${arr[@]} | sort -n | tail -n ${k})\n  echo ${result[@]}",
  "    local arr=$1\n    local k=$2\n\n    local sortedArr\n    local num\n    local\
    \ max\n\n    sortedArr=$($(echo \"${arr[@]}\" | tr ' ' '+' | sort -n | head -n\
    \ ${k}))\n    max=$((${#arr[@]}-1))\n\n    if [ ${#arr[@]} -gt 1 ]; then\n   \
    \     for (( i=${k}; i< ${#arr[@]}; i++ )); do\n            num=$(echo \"${sortedArr[$i]}\"\
    \ | sed 's/\"//g' | cut -d '+' -f1)\n\n            if [ \"$num\" -gt ${arr[$((num-1))]}\
    \ ]; then\n                max=$((num-1))\n            fi\n        done\n    fi\n\
    \n    arr=($(echo \"${sortedArr[$max]}\" | sed 's/\"//g' | cut -d '+' -f1))\n\
    \    arr=($(echo \"${arr[@]}\" | tr ' ' '+' | sort -n | head -n ${k}))\n\n   \
    \ echo \"${arr[@]}\"", "  local arr\n  arr=$1\n  shift\n  local k\n  k=$1\n  shift\n\
    \  local max\n  max=$(echo $((k*k*k*k*k)) | bc -l)\n  max=$((max-1))\n  local\
    \ i\n  local array\n  array=()\n  local temp\n  temp=$(echo $max | bc -l)\n  echo\
    \ ${arr[@]} | while read i; do\n    array=(\"${array[@]}\" \"\\\"$i\\\"\")\n \
    \ done\n  sort -n ${array[@]} | sed -n ${max}p", "    local arr=$1\n    local\
    \ k=$2\n    arr=($arr)\n    local i\n\n    local max=\n    local j\n    for ((i\
    \ = 0; i < ${#arr[@]}; i++)); do\n        j=$i\n        while ((j < ${#arr[@]})\
    \ && (${arr[j]} < ${arr[i]})); do\n            j=$j\n        done\n        max=$(echo\
    \ ${arr[$j]} | sed -n -e 's/^\\([0-9][0-9]*\\)$/\\1/p')\n        arr=(${arr[@]:$j})\n\
    \    done\n    echo \"${arr[@]}\"", "    local arr\n    local k \n    arr=$@\n\
    \    num=${arr[*]}\n    if [ -z \"$num\" ]; then\n        echo \"$num\"\n    else\n\
    \        k=$2\n        maximum \"${num:$((${#num} - $k))}\" $k\n    fi", "   \
    \ local arr=$1\n    local k=$2\n    local -a sorted\n    local max\n\n    sorted=(\
    \ $(sort -n <<<\"$arr\") )\n    max=$(( ${#sorted[@]} - k ))\n    if [[ ${#sorted[@]}\
    \ -gt $k ]]\n    then\n        sorted=( $(sort -nr <<<\"$arr\") )\n        max=${#sorted[@]}\n\
    \    fi\n\n    sorted=( $(eval echo \"{${sorted[@]:0:$max}}\") )\n\n    echo \"\
    ${sorted[@]}\"", "    local arr=( \"${@}\" )\n    local max_k\n    max_k=0\n \
    \   for (( i = 0; i < ${#arr[@]} && ${max_k} < ${2}; i++ )); do\n        local\
    \ ele=\"${arr[i]}\"\n        if [[ ${ele} -gt ${arr[i]} ]]; then\n           \
    \ arr[i]=${ele}\n            max_k=$((max_k+1))\n        fi\n    done\n    local\
    \ arr1=()\n    local ele1\n    for (( i = 0; i < ${max_k}; i++ )); do\n      \
    \  arr1+=( \"${arr[i]}\" )\n    done\n    arr1+=( \"${arr[0]}\" )\n    arr1=(\
    \ \"${arr1[@]}\" )\n    echo \"${arr1[@]}\"", "    local arr=\"$1\"\n    local\
    \ k=\"$2\"\n    local m\n\n    # check k\n    if [[ $k -lt 1 || $k -gt 1000 ]];\
    \ then\n        echo \"Wrong k: $k\"\n        return 1\n    fi\n\n    # convert\
    \ k to a list of digits\n    local digits=$(( 10#$k ))\n\n    # initialize max\
    \ array\n    local max=()\n\n    while (( ${#arr} > 0 )) ; do\n        local elem=\"\
    $(echo \"${arr}\" | awk '{print substr($0, index($0, $1), 1) }')\"\n\n       \
    \ # put elem to the max\n        (( ${#max} > ${#elem} )) && max+=(\"${elem}\"\
    )\n\n        # pop elem from the arr\n        arr=\"${arr%$elem}\"\n\n       \
    \ # decrease the k\n        k=\"${k%$elem}\"\n    done\n\n    # convert max to\
    \ string\n    m=\"${max[*]}\"\n    echo \"[\\\"${m}\\\"]\"", "  local arr=$1\n\
    \  local k=$2\n\n  local length=`expr ${#arr}`\n\n  if [[ ${length} -lt ${k} ]];\
    \ then\n    return 0\n  fi\n\n  local max_index=0\n  local max_value=\"\"\n\n\
    \  for i in $(seq ${length} -1 ${k}); do\n    local value=`expr ${arr[$i]}`\n\
    \    if [[ -z \"${value}\" ]]; then\n      continue\n    fi\n    if [[ ${value}\
    \ -gt ${max_value} ]]; then\n      max_index=$(expr ${i} - 1)\n      max_value=${value}\n\
    \    fi\n  done\n\n  local result\n  eval \"result=(\\${arr[@]:(${max_index}+${k})})\"\
    \ \n  echo ${result[@]}", "    local arr=$1 k=$2\n    if [ -z $arr ]; then\n \
    \       echo \"Usage: $0 'arr k'\" >&2\n        return 1\n    fi\n    if [ $k\
    \ -lt 1 -o $k -lt $((${#arr[@]} - 1)) ]; then\n        echo \"Usage: $0 'arr k'\"\
    \ >&2\n        return 1\n    fi\n    local maximums=()\n    for ((i = 0; i < ${#arr[@]};\
    \ i++)); do\n        local j=0\n        while [ $((${#maximums[@]})) -lt $k ];\
    \ do\n            if [ ${maximums[$j]} -gt ${arr[$i]} ]; then\n              \
    \  maximums[$j]=${arr[$i]}\n            else\n                local j=$((j + 1))\n\
    \            fi\n        done\n    done\n    for ((i = 0; i < ${#maximums[@]};\
    \ i++)); do\n        echo ${maximums[$i]}\n    done", "    local arr=$1\n    local\
    \ k=$2\n    local max=$(echo $arr | sed 's/,/\" \"/g' | sort -rn | head -n $k)\n\
    \    for ((i=$(echo $arr | sed 's/,/\" \"/g' | sort -n); i < $k; ++i)); do\n \
    \       local cur=$(echo $arr | sed 's/,/\" \"/g' | sort -rn | head -n $i)\n \
    \       local next=$(echo $arr | sed 's/,/\" \"/g' | sort -rn | tail -n 1)\n \
    \       if [[ \"$cur\" -gt \"$next\" ]]; then\n            max=$(echo $arr | sed\
    \ 's/,/\" \"/g' | sort -rn | head -n $i)\n        fi\n    done\n    echo \"$max\"",
  "    local arr=\"$1\"\n    local k=\"$2\"\n    local result\n    local count\n \
    \   local index\n    local i\n    local tmp\n    local num\n    local numStr\n\
    \    local first\n    local second\n    local third\n    local fourth\n    local\
    \ fifth\n    local sixth\n    local firstNum\n    local secondNum\n    local thirdNum\n\
    \    local fourthNum\n    local fifthNum\n    local sixthNum\n    local firstNumStr\n\
    \    local secondNumStr\n    local thirdNumStr\n    local fourthNumStr\n    local\
    \ fifthNumStr\n    local sixthNumStr\n\n    IFS=' ' read -r -a arr <<< \"$arr\"\
    \n    numStr=\"$arr[@]\"\n    IFS=- read -r -a numArr <<< \"$numStr\"\n    num=${#numArr[@]}\n\
    \    first=$((num-1)) \n    second=$((num-1)) \n    third=$((num-1)) \n    fourth=$((num-1))\
    \ \n    fifth=$((num-1)) \n    sixth=$((num-1)) \n\n    for index in \"${!arr[@]}\"\
    ; do\n        if [[ $index -lt $k ]]; then\n            [[ \"${!arr[$index]}\"\
    \ -gt \"$first\" ]] && first=\"${!arr[$index]}\"\n        fi\n    done\n\n   \
    \ for index in \"${!arr[@]}\"; do\n        if [[ $index -lt $k ]]; then\n    \
    \        [[ \"${!arr[$index]}\" -gt \"$second\" ]] && second=\"${!arr[$index]}\"\
    \n        fi\n    done\n\n    for index in \"${!arr[@]}\"; do\n        if [[ $index\
    \ -lt $k ]]; then\n            [[ \"${!arr[$index]}\" -gt \"$third\" ]] && third=\"\
    ${!arr[$index]}\"\n        fi\n    done\n\n    for index in \"${!arr[@]}\"; do\n\
    \        if [[ $index -lt $k ]]; then\n            [[ \"${!arr[$index]}\" -gt\
    \ \"$fourth\" ]] && fourth=\"${!arr[$index]}\"\n        fi\n    done\n\n    for\
    \ index in \"${!arr[@]}\"; do\n        if [[ $index -lt $k ]]; then\n        \
    \    [[ \"${!arr[$index]}\" -gt \"$fifth\" ]] && fifth=\"${!arr[$index]}\"\n \
    \       fi\n    done\n\n    for index in \"${!arr[@]}\"; do\n        if [", " \
    \   local arr=($1);\n    local k=$2\n    local arr_rev=($(sort -r \"$arr\"))\n\
    \    local output\n\n    if [ \"$k\" -lt 0 ] || [ \"$k\" -gt 1000 ]; then\n  \
    \      echo \"Error! The size of k should be in the range of [1, 1000].\"\n  \
    \      return 1\n    fi\n\n    if [ \"$k\" -eq 1 ]; then\n        output=($arr_rev)\n\
    \    elif [ \"$k\" -gt 1 ]; then\n        local i\n        output=()\n       \
    \ for i in $(seq 1 \"$k\"); do\n            local max_val=${arr_rev[$((i*$2))]}\n\
    \            local max_index=$((i*$2))\n            local max_val_index=$((i*2))\n\
    \            if [ \"$max_val\" == \"$max_val_index\" ]; then\n               \
    \ local max_val_index=$((i*2))\n            fi\n            if [ \"$max_index\"\
    \ -gt \"$max_val_index\" ]; then\n                max_val=$((max_val-1))\n   \
    \         fi\n            output+=($max_val)\n        done\n    else\n       \
    \ output=()\n        for i in $(seq 1 \"$k\"); do\n            local max_val=${arr_rev[$((i*$2))]}\n\
    \            if [ \"$max_val\" != \"1\" ]; then\n                output+=($max_val)\n\
    \            fi\n        done\n    fi\n\n    if [ \"$k\" -gt 1 ]; then\n     \
    \   for i in $(seq 1 \"$((k-1))\"); do\n            output+=(${arr_rev[$((i-1))]})\n\
    \        done\n    fi\n\n    echo \"${output[@]}\"", "    k=$2\n    if [ ${#1}\
    \ == 0 ]; then\n        echo \"$1\"\n    elif [ $k -gt ${#1} ]; then\n       \
    \ echo \"$1\"\n    elif [ $k -lt 0 ]; then\n        echo \"$1\"\n    elif [ $k\
    \ -lt 1 ]; then\n        echo \"\"\n    else\n        arr=($(echo $1 \"|\" \"\
    ${arr[@]:0:$k-${#arr[$k]}}\"|sort))\n        echo ${arr[@]:0:$k}\n    fi", "\t\
    local arr=$1\n\tlocal k=$2\n\tlocal maxArr\n\tlocal i\n\tlocal max\n\tmaxArr=()\n\
    \tmax=k\n\n\twhile [ $k -lt $((${#arr[@]} - 1)) ]\n\tdo\n\t\tmax=$((${max} + 1))\n\
    \tdone\n\n\tfor i in $(seq 1 $max)\n\tdo\n\t\tmaxArr[$((${max} - ($i - 1)))]=${arr[$i]}\n\
    \tdone\n\n\tarr=( \"${maxArr[@]}\" )", "    local arr=$1\n    local k=$2\n   \
    \ arr=$(echo $arr | tr \" \" \"\\n\" | sort -n | head -n $k)\n    echo ${arr[@]}",
  "    arr=($1)\n    shift\n    max=()\n    for i in \"${arr[@]}\"\n    do\n     \
    \   (( ${#max[@]} < i )) && max+=(\"$i\")\n    done\n    printf '[%s]\\n' \"${max[@]:0:$2}\"",
  "    local arr=$1\n    local k=$2\n    local n=$#\n    local max\n\n    if [ \"\
    $n\" -lt \"$k\" ]; then\n        echo \"Error - $n arguments given. k should be\
    \ in [1, $n]\"\n        return\n    fi\n\n    max=$arr\n    local i\n    for ((i=1;\
    \ i<=$((n-1)); i+=1)); do\n        if [[ \"$arr\" -gt \"$max\" ]]; then\n    \
    \        max=$arr\n        fi\n        arr=$[$arr+1]\n    done\n    \n    echo\
    \ $max", "    arr=( $(echo $1 | tr \" \" \"\\n\") )\n    length=${#arr[*]}\n \
    \   if [ \"$length\" -le \"$2\" ]\n    then\n        echo []\n    elif [ \"$length\"\
    \ -gt \"$2\" ]\n    then\n        arr[$2]=$(maximum ${arr[@]:3:$length} $2)\n\
    \        arr[$2]=$(echo $arr[$2] | tr \" \" \"\\n\")\n        arr[$2]=$(echo $arr[$2]\
    \ | tr \" \" \" \")\n        arr[$2]=$(echo $arr[$2] | tr \" \" \",\")\n     \
    \   echo ${arr[*]} | tr \" \" \",\"\n    else\n        echo $(echo $arr[$2] |\
    \ tr \" \" \",\")\n    fi", "    local array=$1\n    local k=$2\n    local length=${#array[@]}\n\
    \    local largest\n    local max\n    local index\n    for (( i = 0; i < length;\
    \ i++ )); do\n        index=$i\n        if [[ ${array[$index]} -gt $max ]]; then\n\
    \            max=${array[$index]} \n        fi\n    done\n    local result\n \
    \   for (( j = 0; j < k; j++ )); do\n        if [[ ${array[$index]} -gt $max ]];\
    \ then\n            result+=(${array[$index]})\n        fi\n        index=$((\
    \ $index + 1 ))\n    done\n    echo \"${result[@]}\"", "    # Convert input into\
    \ a list\n    arr=$1\n    arrLength=$#\n    echo ${arr[*]}", "    local arr=$1\n\
    \    local k=$2\n    arr=(${arr// / })\n    sort -n -k $((k)) ${arr[@]:0:$((k-1))} ",
  "    local arr=$1\n    local k=$2\n    local arrlen=$((${#arr}-1))\n    if [ ${k}\
    \ -gt ${arrlen} ]\n    then\n        echo \"Wrong parameters: k > arrlen\"\n \
    \       return 1\n    fi\n    local output\n    output=$(echo ${arr} | tr ' '\
    \ '\\n' | sort -n | tail -${k})\n    echo ${output}", "    local arr=( $1 )\n\
    \    local k=$2\n    local m=$k\n    # k <= 0\n    if [ \"$k\" -lt 0 ]; then\n\
    \        k=0\n    fi\n    # k >= len(arr)\n    if [ \"$k\" -gt ${#arr[@]} ]; then\n\
    \        k=${#arr[@]}\n    fi\n    # k must be in [1, length(arr)]\n    if [ \"\
    $k\" -lt 1 -o \"$k\" -gt ${#arr[@]} ]; then\n        echo \"$arr\"\n        return\
    \ $arr\n    fi\n    # sort descending order\n    local max=( $(sort -n -t $'\\\
    t' -k ${m}k -r -n \"${arr[@]:0:$k}\") )\n    # restore the original order\n  \
    \  local tmp=( ${arr[@]} )\n    for ((i=1; i<${#max[@]}; i++)); do\n        tmp[${i}]=${max[$i]}\n\
    \    done\n    arr=${tmp[@]}\n    echo \"${arr[@]:0:$k}\"", "  local a=$1 k=$2\n\
    \  local -i i\n  local -a sorted\n  local max\n  \n  if [ \"$k\" -lt \"1\" ] ||\
    \ [ \"$k\" -gt \"100\" ]; then\n    echo \"\"\n    echo \"Error: k must be in\
    \ the range of [1, 1000]\"\n    return 1\n  fi\n\n  for i in \"${a[@]}\"; do\n\
    \    sorted+=(\"$i\")\n  done\n  sorted=( \"${sorted[@]}\" )\n  max=$sorted[1]\n\
    \  local j=1;\n\n  for i in \"${sorted[@]:2}\"; do\n    if [ \"$max\" -lt \"$i\"\
    \ ]; then\n      max=$i\n      j=$i\n    fi\n  done\n\n  local last;\n  local\
    \ c;\n\n  if [ \"$k\" -gt \"$j\" ]; then\n    echo \"\"\n    echo \"Error: k must\
    \ be less than or equal to length of arr\"\n    return 1\n  fi\n\n  echo \"\"\n\
    \  echo \"max=$max\"\n  echo \"j=$j\"\n  echo \"k=$k\"\n\n  local j1;\n  local\
    \ j2;\n  local j3;\n  local j4;\n\n  j3=$j;\n  j4=$j;\n\n  if [ \"$k\" -eq \"\
    $j\" ]; then\n    local j1;\n    local j2;\n    local j3;\n    local j4;\n\n \
    \   j3=$j;\n    j4=$j;\n\n    while [ \"$j3\" -lt \"$j4\" ] do\n      if [ $j3\
    \ -lt \"$j\" ]; then\n        j1=$j3;\n        j2=$j3;\n      else\n        j2=$j4;\n\
    \      fi\n      j3=$j4;\n\n      if [ $j4 -lt \"$j\" ]; then\n        j4=$j;\n\
    \      fi\n    done\n    local j1;\n    local j2;\n    local j3;\n    local j4;\n\
    \n    j3=$j;\n    j4=$j;\n\n    while [ \"$j3\" -lt \"$j4\" ] do\n      if [ $j3\
    \ -lt \"$j\" ]; then\n        j1=$j3;\n        j2=$j3;\n      else\n        j2=$j4;\n\
    \      fi\n      j3=$j4;\n\n      if [ $j4 -lt \"$j\" ]; then\n        j4=$j;\n\
    \      fi\n    done\n  fi\n  j1=$j;\n  j2=$j;\n  local c;\n\n  while [ \"$j1\"\
    \ -le \"$j2\" ] do\n    if [ $j1 -lt ", "  local arr=$1\n  local k=$2\n  local\
    \ tmp=()\n  local len=$((${#arr} + 1))\n  local i=0\n  local max_so_far=0\n\n\
    \  # the loop below is O(log(arr))\n  while [ $i -lt $len ]; do\n    if [[ \"\
    $arr[$i]\" -gt \"$max_so_far\" ]]; then\n      max_so_far=$arr[$i]\n    fi\n \
    \   tmp[$i]=$max_so_far\n    ((i++))\n  done\n\n  printf '%s\\n' \"${tmp[@]:0:$k}\"",
  "  local arr=\"$1\"\n  local k=\"$2\"\n  local max\n  local i j maxVal\n\n  if [\
    \ \"$k\" -lt 1 ] || [ \"$k\" -gt 1000 ]; then\n    echo \"Wrong input: k must\
    \ be in range [1, 1000]\"\n    return 1\n  fi\n\n  if [ -z \"$arr\" ]; then\n\
    \    echo \"Wrong input: arr is empty\"\n    return 1\n  fi\n\n  if [ \"$k\" -gt\
    \ \"$#arr\" ]; then\n    echo \"Wrong input: k should be less than the length\
    \ of arr\"\n    return 1\n  fi\n\n  maxVal=$(echo $arr | cut -d \" \" -f $((k-1)))\n\
    \  max=0\n  i=1\n  j=1\n  while [ -n \"$maxVal\" ] && [ $i -le $k ]; do\n    maxVal=$(echo\
    \ $arr | cut -d \" \" -f $i)\n    if [ \"$maxVal\" -gt \"$max\" ]; then\n    \
    \  max=$maxVal\n    fi\n    i=$((i+1))\n  done\n  if [ \"$i\" -eq \"$k\" ]; then\n\
    \    echo \"$max\"\n  else\n    echo \"$max\" \"$(echo $arr | cut -d \" \" -f\
    \ $((i-1)))\"\n  fi", "    local arr=\"$1\"\n    local k=\"$2\"\n\n    local i=1\n\
    \    local j=0\n    local m=\"\"\n    local max=\n    local x=\"\"\n\n    max=\n\
    \    for x in \"${arr[@]}\"; do\n        if [ $i -lt $k ] ; then\n           \
    \ max=`expr ${max} ${x} +`\n        else\n            m=`expr ${m} ${x} +`\n \
    \       fi\n        i=`expr ${i} + 1`\n    done\n    for j in `seq 0 $(( ${#arr[@]}\
    \ - 1 ))`; do\n        if [ \"${arr[$j]}\" = \"${max}\" ]; then\n            arr[j]=${max}\n\
    \        fi\n    done\n    for j in `seq 0 $(( ${#arr[@]} - 1 ))`; do\n      \
    \  if [ \"${arr[$j]}\" = \"${m}\" ]; then\n            arr[j]=${m}\n        fi\n\
    \    done\n\n    arr=( \"${arr[@]}\" )\n    echo ${arr[@]}", "    local arr=$1\n\
    \    local k=$2\n    # Sort the array in ascending order.\n    local sorted_arr=$(echo\
    \ \"$arr\" | sort -n -k)\n    # Find out the largest k numbers in the array.\n\
    \    local max_arr=\"\"\n    local max_k=0\n    for (( i=1; i<k; i++ )); do\n\
    \        # If the array consists of only one number, this number is itself,\n\
    \        # and the array is sorted in descending order. Otherwise, find the\n\
    \        # largest element in the array.\n        local elem=$(echo \"${sorted_arr}\"\
    \ | tail -n \"$i\" | head -n 1)\n        local elem_k=$(echo \"${sorted_arr}\"\
    \ | head -n \"$i\" | tail -n 1)\n        if [[ ${elem} == ${elem_k} ]]; then\n\
    \            local elem_i=$(echo \"${sorted_arr}\" | tail -n \"$i\" | head -n\
    \ 1)\n            max_k=$i\n            max_arr=\"${elem_i} ${elem_k}\"\n    \
    \    else\n            max_arr=\"${max_arr} ${elem}\"\n        fi\n    done\n\
    \    echo \"${max_arr}\"", "    local arr=$1\n    local k=$2\n    if [ \"${arr:0:1}\"\
    \ == \"-\" ]; then\n        arr=${arr:1}\n        k=${k:1}\n    fi\n    local\
    \ arr_sorted=( $(sort -n -r -k ${k} <<<${arr}) )\n    local result\n    for ((\
    \ i=0; i<${#arr_sorted[@]}; i++ )); do\n        if [ ${arr_sorted[i]} -gt ${arr_sorted[i-1]}\
    \ ]; then\n            result=( \"${result[@]}\" $arr_sorted[i] )\n        else\n\
    \            result=( \"${result[@]}\" $arr_sorted[i-1] )\n        fi\n    done\n\
    \    echo \"${result[@]}\"", "    local arr=\"$1\"\n    local k=\"$2\"\n    if\
    \ [[ ${#arr} -ne ${#k} ]];\n    then\n        return 0\n    fi\n    local -a arr_sorted\n\
    \    local i max\n    # Sort the array\n    for ((i=0; i<${#arr[@]}; ++i)); do\n\
    \        arr_sorted[$i]=$((${arr[$i]} > ${arr_sorted[$i]}+$k)) && \\\n       \
    \ arr_sorted[$i]=\"${arr_sorted[$i]} ${arr[$i]}\"\n    done\n    # Get the max\
    \ k values\n    for ((i=0; i<${#arr_sorted[@]}; ++i)); do\n        if [[ \"$max\"\
    \ -eq \"${arr_sorted[$i]}\" ]];\n        then\n            max=${arr_sorted[$i]}\n\
    \        fi\n    done\n    echo ${arr_sorted[@]:0:$((${#arr_sorted[@]}>${k}))}",
  "  local arr=$1 k=$2\n  local -n max_str=max_str\n  local -n min_str=min_str\n \
    \ local -n max_val=$max_val\n  local -n min_val=$min_val\n  local -n i=$i\n  local\
    \ -n j=$j\n  local -n result=$result\n  local -n k=k\n\n  for i in $(seq 1 $k);\
    \ do\n    local cur_val=$((${max_val} - ${min_val}))\n    if [[ -z ${max_str+i}\
    \ ]]; then\n      max_str+i=${arr:$i:1}\n    fi\n    if [[ -z ${min_str+i} ]];\
    \ then\n      min_str+i=${arr:$i:1}\n    fi\n    if [[ ${max_str+i} -gt $cur_val\
    \ ]]; then\n      max_str+i=${arr:$i:1}\n    fi\n    if [[ ${min_str+i} -le $cur_val\
    \ ]]; then\n      min_str+i=${arr:$i:1}\n    fi\n  done\n  \n  result=$(echo \"\
    ${arr}\" | sed -n -e \"s/^\\(${min_str}\\)\\(${max_str}\\).*/\\2\\1/gp\")\n  echo\
    \ \"${result[@]}\"", "    local -n arr_opt=$1\n    local -n arr=$2\n    local\
    \ -n arr_len=$((arr_opt))\n    local -i max_len=0\n    local -i i\n    local -r\
    \ opt\n    local opt_idx=0\n    local -n opt_len=$((arr_len))\n    for ((i=0;\
    \ i<${opt_len}; i++)); do\n        opt=$(eval ${arr_opt}[${i}])\n        if [[\
    \ ${opt} -gt ${arr} ]]; then\n            opt_idx=$i\n            arr_opt=${arr_opt}[:${i}]\n\
    \            break\n        fi\n    done\n    while [[ ${opt_idx} -lt ${opt_len}\
    \ ]] && [[ -n ${arr_opt} ]]; then\n        opt=$(eval ${arr_opt}[${opt_idx}])\n\
    \        ((max_len++))\n        arr_opt=${arr_opt}[${opt_idx}]\n        ((opt_idx++))\n\
    \    done\n    arr_opt=${arr_opt}[:${opt_idx}]\n    printf '%s\\n' ${arr_opt}",
  "    arr=$1\n    k=$2\n\n    arr=(`echo $arr | tr \" \" \" \"`)\n    k=`echo $k\
    \ | tr '[:upper:]' '[:lower:]'`\n    k=`echo $k | tr \"a-z\" \"A-Z\"`\n    k=`echo\
    \ $k | tr \"0-9\" \"-\"`\n    k=`echo $k | tr \"-\" \" \"`\n\n    arr=`echo $arr\
    \ | tr \" \" \"\\n\"`\n    arr=(`echo $arr | tr -d \"\\n\"`)\n\n    max=0\n  \
    \  maxIndex=0\n    num=`echo $arr | wc -w`\n\n    for i in `seq 0 $(($num-1))`\n\
    \    do\n        if `echo $arr[$i] | awk '{print $1}'` -gt $max\n        then\n\
    \            max=`echo $arr[$i] | awk '{print $1}'`\n            maxIndex=$i\n\
    \        fi\n    done\n\n    arr=(`echo $arr | awk -v ind=$maxIndex 'BEGIN{while((getline<ind)>0){a[++c]=$1;}}\
    \ {print a[c]}'`)\n\n    k=$((k-1))\n    if [ \"$k\" -lt \"0\" ]\n    then\n \
    \       echo `echo $arr | head -$k`\n    else\n        echo `echo $arr | tail\
    \ -$k`\n    fi", "    local -n arr=$1\n    local num=$2\n    local -a arr2\n \
    \   local -n max=$3\n    local -n maxIndex\n    local -n maxVal\n    local i\n\
    \    local j\n    local len=${#arr[@]}\n    local maxIndex=$((len - num))\n  \
    \  arr2=()\n    for i in $(seq 0 $((num - 1))); do\n\tarr2+=(\"${arr[$i]}\")\n\
    \    done\n    if [ \"$num\" -gt \"$len\" ]; then\n\tprintf \"The length is not\
    \ within range (1-1000)\\n\"\n\treturn 0\n    fi\n    for j in $(seq 0 $maxIndex);\
    \ do\n\tif [ \"${arr2[$j]}\" -gt \"$maxVal\" ]; then\n\t    maxVal=\"${arr2[$j]}\"\
    \n\t    maxIndex=$j\n\tfi\n    done\n    for i in $(seq 0 $maxIndex); do\n\tarr[$i]=${arr2[$i]}\n\
    \    done\n    arr=( \"${arr[@]:0:$maxIndex}\" )\n    if [ \"$max\" -gt \"$len\"\
    \ ]; then\n\tprintf \"The value is not within range (-1000,1000)\\n\"\n\treturn\
    \ 0\n    fi\n    echo \"${arr[@]}\"", "  local arr1=$(words \"$1\")\n  local len1=${#arr1[@]}\n\
    \  local len2=${2:-10}\n  local len3=${3:-10}\n\n  if [ $len1 -lt $len3 ]\n  then\n\
    \    local len4=$len1\n  else\n    local len4=$len3\n  fi\n\n  local max=$(mktemp\
    \ -t maximum.XXXXXX)\n  trap \"rm -f '$max'\" EXIT\n  local k=0\n  local maxlen=0\n\
    \  local maxnum=0\n\n  local arr2=($(for ((i=0; i < $len4; ++i)) do echo -n \"\
    $i\"; done))\n\n  while [ $k -lt $len2 ]\n  do\n    for ((i=0; i < $len4; ++i));\
    \ do\n      if [ \"${arr1[i]}\" -gt \"$maxnum\" ]; then\n        maxnum=${arr1[i]}\n\
    \        maxlen=$i\n      fi\n    done\n    k=$(($k+1))\n    arr2=($(for ((i=0;\
    \ i < $len4; ++i)) do echo -n \"$i\"; done))\n  done\n\n  echo $((len2 + 1))\n\
    \  for ((i=$((len4+1)); $i -lt $maxlen; --i)); do\n    arr2[$i]=${arr2[${#arr2[@]}\
    \ -1]}\n  done\n\n  echo $arr2\n  rm -f '$max'", "  local arr i\n  IFS=\" \"\n\
    \  arr=$1\n  i=\"${2}\"\n  while [[ ${#arr} -lt $i ]]; do\n    arr+=(\"${arr[1]}\"\
    )\n  done\n  printf '%s\\n' \"${arr[@]:0:$i}\"", "    k=$1\n    shift\n    # k\
    \ is less than 0\n    if [ $k -lt 0 ]\n    then\n        echo \"Usage: $(basename\
    \ $0) [k arr]\"\n        exit 1\n    fi\n    if [ $k -lt 1 ]\n    then\n     \
    \   k=1\n    fi\n\n    array=( $@ )\n    sorted=( $( sort -n \"${array[@]}\" |\
    \ tail -n $k ) )\n    echo \"${sorted[*]:1}\"", "  local -n arr=$1\n  local k=$2\n\
    \  k=$((k>${#arr}?${#arr}:k))\n  local i result=()\n  for i in $(seq 0 $((k-1))\
    \ -1 ); do\n    result[$i]=${arr[$i]}\n  done\n  result[$((k-1))]=\"${arr[$((k-1))]}\"\
    \n  echo ${result[*]}", "  arr=$1\n  k=$2\n  local arrLen=${#arr}\n  local maxArr\n\
    \  local sortedArr maxArrLen maxVal\n  sortedArr=\"\"\n  maxArrLen=0\n  maxVal=0\n\
    \n  for ((i=1; i<=arrLen; i++))\n  do\n    local currentVal=${arr[i]}\n    local\
    \ j=0\n    local k\n    while ((j<=k) && (currentVal > maxVal))\n    do\n    \
    \  maxVal=${arr[j]}\n      j=$((j+1))\n    done\n\n    if [ \"$j\" -eq \"$k\"\
    \ ]\n    then\n      sortedArr+=${arr[i]}\n    else\n      maxArrLen=$((maxArrLen\
    \ + 1))\n      maxArr+=${arr[i]}\n    fi\n  done\n\n  printf \"%s\\n\" \"${maxArr[@]:0:maxArrLen}\"",
  "    arr=$1\n    k=$2\n    if [[ ${#arr} -eq 0 || ${#arr} -gt 1000 ]]; then\n  \
    \      echo \"Usage: $(basename $0) <arr> <k>\"\n        exit 1\n    elif [[ -z\
    \ \"$k\" ]]; then\n        echo \"Usage: $(basename $0) <arr> <k>\"\n        exit\
    \ 1\n    elif [[ ${k} -lt 1 || ${k} -gt 1000 ]]; then\n        echo \"Usage: $(basename\
    \ $0) <arr> <k>\"\n        exit 1\n    elif [[ \"$k\" -gt ${#arr} ]]; then\n \
    \       echo \"Usage: $(basename $0) <arr> <k>\"\n        exit 1\n    fi\n   \
    \ echo \"${arr}\" | sort -n | tail -n $((k - 1))", "    arr=$1\n    num=$(echo\
    \ $2 | sed 's/ //g')\n    k=$num\n    arr=$($* 2>/dev/null| tr -d '\\r')\n   \
    \ arr=$(echo $arr | tr -d '\\n')\n    arr=$(echo $arr | sed 's/,//g')\n    arr=$(echo\
    \ $arr | sed 's/\"//g')\n    arr=$(echo $arr | sed 's/ //g')\n    echo $arr",
  "    local arr=$1; shift\n    local k=$1; shift\n    local knum\n\n    if (( $#\
    \ -lt 1 )); then\n        knum=$k\n    else\n        knum=$(echo $k | wc -w)\n\
    \    fi\n\n    # sort -n -k1 arr | awk 'BEGIN{OFS=\"\\\"\"; print \"['\"} {print\
    \ $1}' | head -n $knum\n    local a\n    local count\n    local i\n    local j\n\
    \    local len\n    local max\n\n    local junk=$(echo $arr | awk 'BEGIN{OFS=\"\
    \\\"\"; print \"['\"} {print $1}')\n    local junk2\n    local junk3\n\n    len=$((\
    \ ${#arr} - $(( ${#arr} % $knum )) ))\n    # echo \"len is $len\"\n    if (( $len\
    \ < 1 )); then\n        echo \"$arr\"\n        return\n    fi\n    # echo \"len\
    \ is $len\"\n    if (( $len == 0 )); then\n        echo \"$arr\"\n        return\n\
    \    fi\n\n    while (( $knum > 0 )); do\n        junk2=$(echo $junk | awk 'BEGIN{OFS=\"\
    \\\"\"; print \"['\"} {print $1}')\n        junk3=$(echo $junk2 | awk 'BEGIN{OFS=\"\
    \\\"\"; print \"['\"} {print $1}')\n        a=( $junk3 )\n        knum=$(( $knum\
    \ - 1 ))\n        junk=$(echo $junk2 | awk 'BEGIN{OFS=\"\\\"\"; print \"['\"}\
    \ {print $1}')\n        junk2=$(echo $junk | awk 'BEGIN{OFS=\"\\\"\"; print \"\
    ['\"} {print $1}')\n        junk3=$(echo $junk2 | awk 'BEGIN{OFS=\"\\\"\"; print\
    \ \"['\"} {print $1}')\n        # echo \"junk is $junk\"\n        # echo \"junk2\
    \ is $junk2\"\n        # echo \"junk3 is $junk3\"\n        # echo \"a is $a\"\n\
    \        count=$(echo $junk3 | wc -w)\n        # echo \"count is $count\"\n  \
    \      # echo \"junk3 is $junk3\"\n        if (( $count < $knum )); then\n   \
    \         echo \"$junk3\"\n        elif (( $count == $knum )); then\n        \
    \    max=$(echo $junk3 | head -n $count)\n            echo \"$max\"\n        elif\
    \ (( $count > $knum )); then\n            echo \"$junk", "  local -r arr=$1\n\
    \  local -r k=$2\n  echo \"${arr[@]}\" | sort -k ${k}rn | head -n ${k}", "   \
    \ local arr i\n    arr=$(echo $1 | sed 's/ /\" \"/g')\n    if [ $# -eq 2 ]; then\
    \ \n        k=$(echo $2 | sed 's/ /\" \"/g')\n        arr=$(sort -n | sed -n 's/^/\"\
    $k\" /gp' | head -1)\n    else\n        arr=$(sort -n | sed -n 's/^/\"$k\" /gp'\
    \ | head -1)\n    fi\n    echo ${arr}", "    local arr=$1\n    local k=$2\n  \
    \  local sortedArr\n    local max\n    local i\n    local maxIndex\n\n    # Check\
    \ for the valid range of k\n    if (( k > $2 )); then\n        echo \"Error: k\
    \ must be less than or equal to $2\" >&2\n        return 1\n    fi\n\n    # Sort\
    \ the array\n    sortedArr=($(sort -n <<<\"$arr\"))\n\n    # Find the maximum\
    \ number\n    max=${sortedArr[0]}\n    maxIndex=0\n    for ((i=0; i < ${#sortedArr[@]};\
    \ i++)); do\n        if (( $max < ${sortedArr[$i]} )); then\n            max=${sortedArr[$i]}\n\
    \            maxIndex=$i\n        fi\n    done\n\n    # Rearrange the array with\
    \ the maximum value first\n    for ((i=0; i<${#sortedArr[@]}; i++));\n    do\n\
    \        local j=$((maxIndex+1))\n        sortedArr[j]=${sortedArr[$i]}\n    done\n\
    \n    # Print the array\n    echo \"${sortedArr[@]}\"", "\tlocal arr=(\"$@\")\n\
    \tlocal k=\"$2\"\n\tlocal res\n\t\n\tif [[ \"$k\" < 0 || \"$k\" > 1000 ]]; then\n\
    \t\techo \"Invalid k: $k\"\n\t\treturn\n\tfi\n\n\tres=()\n\tlocal i\n\tfor i in\
    \ \"${arr[@]}\"; do\n\t\tif [[ \"$i\" < 0 ]]; then\n\t\t\techo \"Invalid element\
    \ $i: negative\"\n\t\t\treturn\n\t\tfi\n\t\tif [[ \"$i\" -gt \"$k\" ]]; then\n\
    \t\t\techo \"Invalid element $i: must be < k\"\n\t\t\treturn\n\t\tfi\n\t\tarr[i]=\"\
    $i\"\n\tdone\n\tarr=(\"${arr[@]:k}\")\n\techo \"${arr[@]}\"", "  # Your code here\n\
    \  arr=$1\n  k=$2\n  local sortedArr\n  sortedArr=($(sort -n -k $((k+1)) <<<$arr))\n\
    \  echo ${sortedArr[@]:0:$k}", "  local arr k res len\n  read -a arr <<< \"$1\"\
    \n  read k\n  if [[ $k -lt 0 || $k -gt ${#arr[@]} ]]; then\n    k=$(( ${#arr[@]}\
    \ ))\n  fi\n  res=$( printf \"[%s]\" ${arr[@]:0:k} )\n  len=$(( k ))\n  (( len\
    \ > 0 )) || { echo >&2 \"Usage: $(basename ${BASH_SOURCE[0]}) <arr> [k]\"; return\
    \ 1}\n  for i in $( seq 1 $k ); do\n    if [[ ${arr[$i]} -gt ${arr[$(( $i - 1\
    \ ))]} ]]; then\n      res=\"$res$arr[$i]\"\n      arr[$i]=$arr[$(( $i - 1 ))]\n\
    \    fi\n  done\n  res=\"$res$( printf \"[%s]\" \"${arr[@]:$(( k ))}\" )\"\n \
    \ echo \"$res\"", "    local arr=$1\n    local k=$2\n    local output\n    output=$(sort\
    \ -n \"$arr\" |\n        awk -v k=\"$k\" '\n            BEGIN {\n            \
    \    max=0\n                j=0\n            }\n            {\n              \
    \  if ($0 > max && j < k) {\n                    max = $0\n                  \
    \  j = $0\n                }\n                else if ($0 < max && $0 < j) {\n\
    \                    max = $0\n                    j = $0\n                }\n\
    \            }\n            END {\n                printf \"%s\\n\", $0\n    \
    \        }\n        '\n    )", "    local arr=$1\n    local k=$(echo $2 | wc -w)\n\
    \    echo $(echo $2 | sed 's/ /\" \" /g' | sort -n | tail -n +$k)", "    # arr\
    \ is the array of integers\n    # k is the length of arr\n    arr=$1\n    # k\
    \ is in range [1, 1000]\n    if [[ $# -lt 2 ]]; then\n        echo \"Usage: $(basename\
    \ $0) <integers> <k>\"\n        return 1\n    fi\n    # arr is in range of [-1000,\
    \ 1000]\n    k=$2\n    # k is in range [1, 1000]\n    if [[ $k -lt 1 || $k -gt\
    \ 1000 ]]; then\n        echo \"Usage: $(basename $0) <integers> <k>\"\n     \
    \   return 1\n    fi\n    # k is in range [1, 1000]\n    arr=($arr)\n    # sort\
    \ arr\n    arr=($(sort -n -k $((k)) ${arr[*]})\n    # arr is in range of [-1000,\
    \ 1000]\n    arr=(\"${arr[@]}\")\n    echo \"${arr[@]}\"", "    k=$2\n    arr=$1\n\
    \    arr=($(echo \"${arr[*]}\" | sed -e \"s/[\\[\\]]//g\" -e \"s/^\\s*//\" -e\
    \ \"s/\\s*$//\"))\n    arr=($(echo \"${arr[*]}\" | sed -e \"s/[,\\[\\]]//g\" -e\
    \ \"s/^\\s*//\" -e \"s/\\s*$//\"))\n    echo ${arr[@]} | sort -n -k $((k-1))",
  "    local arr=( $1 )\n    local k=$2\n    local i\n    local max_k\n    local result\n\
    \n    echo \"$arr\"\n\n    IFS=$'\\n' arr=( \"$arr\" )\n    max_k=-1\n\n    for\
    \ (( i=0; i<${#arr[@]}; i++ )); do\n        # echo \"$i\"\n        if [[ ${arr[i]}\
    \ -gt ${max_k} ]]; then\n            max_k=${arr[i]}\n        fi\n    done\n\n\
    \    # echo \"$max_k\"\n\n    IFS=$'\\n' max_k=( \"$max_k\" )\n    max_k=\"${max_k}\"\
    \n    IFS=$'\\n' result=( \"$max_k\" )\n\n    echo \"$result\"", "  local array=\"\
    $1\"\n  local k=\"$2\"\n  local res=($(sort -n -k ${k},${array}))\n  if [ ${#res[@]}\
    \ -ne ${k} ]; then\n    echo \"${array}\" | ${JQ} --arg k \"${k}\" --arg res \"\
    ${res[*]}\"\n  else\n    echo \"${res[*]}\"\n  fi", "    local IFS=$'\\n';\n \
    \   local arr=$1 k=$2 max=($k) res=($k);\n    for i in {1..${#arr[*]}}; do\n \
    \       local j=0;\n        for j in $(seq ${k}); do\n            local tmp=${arr[$((j+$i-1))]};\n\
    \            if [ $j -gt $((k-1)) ]; then\n                max[$j]=\"$tmp\";\n\
    \            fi;\n        done\n        res[$i]=$max[$k];\n    done;\n    echo\
    \ \"${res[@]}\" | tr '\\n' ' ';", "    local arr=()\n    local k\n    for (( i\
    \ = 0; i < $#; i++ )); do\n\tarr+=( $( echo \"$1\" | tr \"[:space:]\" \" \" )\
    \ )\n    done\n    k=$2\n    maximum-array arr \"$k\"", "    local arr=$1\n  \
    \  local k=$2\n    local res=()\n    while [[ -z ${arr[*]} ]]; do\n        arr+=(\"\
    $k\")\n    done\n    for (( i=0; i<${#arr[*]} && $i<${#arr[@]}/$k; i++ )); do\n\
    \        arr[i]=$(echo $arr[i] | tr \" \" \"-\")\n    done\n    for (( i=0; i<${#arr[@]}/$k;\
    \ i++ )); do\n        local j=$(( $i + $k ))\n        if [[ $j -gt $(( ${#arr[@]}\
    \ - 1 )) ]]; then\n            j=$(( ${#arr[@]} - 1 ))\n        fi\n        if\
    \ [[ $(( ${#arr[@]} % $k )) != 0 ]]; then\n            j=$(( ${#arr[@]} % $k ))\n\
    \        fi\n        res+=(\"${arr[j]}\")\n        arr=(${arr[@]:0:j})\n    done\n\
    \    echo \"${res[@]}\"", "    local array=$1\n    local k=$2\n\n    local max_array\
    \ max_k max_i max_j\n    local n i j\n\n    # k is a positive integer\n    if\
    \ ! [[ \"$k\" =~ ^[0-9]+$ ]]; then\n        # k is not an integer\n        return\
    \ 1\n    fi\n\n    # k is less than or equal to length of arr\n    if ! [[ \"\
    $k\" -le \"$#\" ]]; then\n        # k is too large (over length of array)\n  \
    \      return 1\n    fi\n\n    # Initialize max_array and max_k\n    max_array=()\n\
    \    max_k=${k}\n\n    # Initialize max_i and max_j\n    max_i=${#array}\n   \
    \ max_j=0\n    \n\n    # Loop until array is sorted\n    while [[ $max_i -ge 0\
    \ ]]; do\n        # Initialize n\n        n=0\n\n        # Loop until all elements\
    \ of arr are visited\n        while [[ $n -lt $max_i ]]; then\n            \n\
    \            # Loop until all elements (including those in max_array) have \n\
    \            # been visited\n            while [[ $n -lt $max_k && ${#max_array[@]}\
    \ -gt 0 ]]; then\n                \n                # Loop until nth element of\
    \ max_array is visited\n                while [[ ${#max_array[@]} -ge 1 && ${max_array[$n-1]}\
    \ -gt 0 ]]; then\n                    \n                    # Initialize i and\
    \ j to nth element\n                    i=$n\n                    j=$((n+1))\n\
    \n                    # Loop until i > j and arr[i] is in max_array\n        \
    \            while [[ $i -gt $j && ${#max_array[@]} -gt 0 && ${max_array[i]} -gt\
    \ 0 && ${max_array[j]} -gt 0 ]]; then\n                        \n            \
    \            # Initialize i and j to nth element of max_array\n              \
    \          i=$((i+1))\n                        j=$((j+1))\n\n                \
    \        # Update n to nth element of max_array\n                        n=$((n+1))\n\
    \                    done\n                \n                # If n is greater\
    \ than max_k, then update max_k\n                elif [[ $n -gt $max_k ]]; then\n\
    \                    max_k=$n\n                fi\n            done\n        \n\
    \            # If n is greater than max_k, then update max_k\n            if [[\
    \ $n -gt $max_k ]]; then\n                max_k=$n\n            fi\n         \
    \   \n            \n            # Loop until all elements of arr are visited\n\
    \            while [[ $n -lt $max_i ]]; then\n                \n             \
    \   # Initialize i and j to nth element\n                i=$n\n              \
    \  j=$((n+1))\n\n                # Loop until i > j", "  local n=$1\n  local k=$2\n\
    \  local l\n  l=$(eval echo \\$(echo \"$n\" | grep -o ' -[0-9]+ -[0-9]+ ' | sort\
    \ -n | head -n \"$k\"))\n  echo \"$l\"", "    local arr=($1)\n    local k=$2\n\
    \    local maximum\n    local j\n    \n    if (( k > ${#arr[@]} )); then\n   \
    \     echo \"Error: k is out of range [0, ${#arr[@]}]!\"\n        return 1\n \
    \   fi\n    \n    maximum=\n    for j in $(seq 1 $k); do\n        local i\n  \
    \      local tmp\n        \n        for (( i = 0; i < ${#arr[@]} - $j + 1; i++\
    \ )); do\n            tmp=${arr[$(( i + j ))]}\n            \n            if ((\
    \ tmp > $maximum )); then\n                maximum=$tmp\n            fi\n    \
    \    done\n    done\n    \n    echo ${maximum[@]}", "    local arr=( $1 )\n  \
    \  local num=$2\n    local max_list=($(sort -nr -k$num $arr))\n    echo $max_list",
  "    arr=(${1//[[:space:]]})\n    k=${2//[[:space:]]}\n    local max=$(sort -n <<<${arr[@]:k})\n\
    \    echo -n ${max[@]:0:${k}}", "    local i res=()\n    for (( i=0; i < $#; i++\
    \ )); do\n        res[i]=\"$(echo $i | cut -d \" \" -f 1)\"\n    done\n\n    for\
    \ (( i=0; i < $#; i++ )); do\n        for (( j=$i+1; j < $#; j++ )); do\n    \
    \        [[ \"$res[$i]\" -gt \"$res[$j]\" ]] && res[i]=\"${res[$j]}\" || res[j]=\"\
    ${res[$i]}\"\n        done\n    done\n\n    for (( j=0; j<$#; j++ )); do\n   \
    \     echo \"${res[j]}\"\n    done", "    local arr=($1)\n    local k=$2\n   \
    \ local maxarr=()\n    local i\n    local j\n    local temp\n    local max\n \
    \   local str\n    \n    while ((i <= k)) || [[ $i -lt 0 ]]; do\n        i=$((i+1))\n\
    \    done\n    \n    for ((i=1; $i -le $((k-1)); i=$((i+1))))\n    do\n      \
    \  max=$(echo $max \"$arr[$i]\" | bc)\n    done\n\n    for ((i=1; $i -le $((k-1));\
    \ i=$((i+1)))\n    do\n        if [[ \"$arr[$i]\" -gt \"$max\" ]]\n        then\n\
    \            str=\"$max\"\n            max=\"$arr[$i]\"\n        else\n      \
    \      str=\"$arr[$i]\"\n        fi\n    done\n    \n    for ((j=0; $j -le $((k-1));\
    \ j=$((j+1)))\n    do\n        temp=$(echo $max | bc)\n        if [ \"$temp\"\
    \ -gt \"$str\" ]\n        then\n            str=\"$temp\"\n        fi\n    done\n\
    \    \n    for ((j=0; $j -le $((k-1)); j=$((j+1)))\n    do\n        temp=$(echo\
    \ $max | bc)\n        if [ \"$temp\" -gt \"$str\" ]\n        then\n          \
    \  maxarr[$j]=\"$temp\"\n        else\n            maxarr[$j]=\"$str\"\n     \
    \   fi\n    done\n\n    echo ${maxarr[@]}", "    arr=$1\n    key=$2\n    if [\
    \ -z \"$arr\" -o -z \"$key\" ]; then\n        echo \"Usage: $(basename $0) <array>\
    \ <k>\"\n        return\n    fi\n\n    arr=($arr)\n    key=$(($key - 1))\n   \
    \ k=${#arr[$key]}\n    sorted=()\n    for ((i=0; i<$key; i++)); do\n        sorted+=(\"\
    ${arr[i]}\")\n    done\n    echo \"${sorted[@]:0:$k}\"", "    local arr=\"$1\"\
    \n    local k=\"$2\"\n    local max_arr=()\n    local max_num=-1\n    local j\n\
    \    for (( i = 1; i <= ${#arr}; i++ )); do\n        if [[ ${arr[i]} -gt $max_num\
    \ ]]; then\n            max_arr=(\"${max_arr[@]}\" ${arr[i]})\n            max_num=${arr[i]}\n\
    \        fi\n    done\n    local str=\"${max_arr[@]}\"\n    for (( j = 1; j <=\
    \ ${k}; j++ )); do\n        str=\"${str},${max_arr[$j]}\"\n    done\n    echo\
    \ \"${str}\"", "  local arr=($1)\n  local k=$2\n  local max=\"${arr[0]}\"\n  local\
    \ i=1\n  while [ $i -lt $k ]\n  do\n    local ele=${arr[$i]}\n    if [ $ele -gt\
    \ $max ]; then\n      max=$ele\n    fi\n    i=$((i+1))\n  done\n  printf '%s\\\
    n' \"$max\"", "    local i arr\n    IFS=' ' read -r -a arr <<<\"$1\"\n    local\
    \ k\n    k=\"$2\"\n    [[ -z $k ]] && k=\"${#arr[@]}\"\n    local arrlen=\"$((k\
    \ > ${#arr[@]} ? ${#arr[@]} : k))\"\n    local output\n    local max\n    local\
    \ maxlen\n    local maxindex\n    max=\"$(nl=\"\\n\"\n        for ((i=1; i<=$arrlen;\
    \ i++)) ; do\n            local m\n            m=\"${arr[$((i-1))]}\"\n      \
    \      [[ -z $m ]] && m=\"0\"\n            [[ -n ${arr[$i]} ]] && m=\"${arr[$i]}\"\
    \n            [[ \"$m\" = \"$n\" ]] && m=0\n            [[ \"$m\" = \"$max\" ]]\
    \ && m=0\n            [[ -n \"$m\" ]] && max=\"$m\" && maxlen=$i && maxindex=\"\
    $i\"\n        done\n        nl=)\n    if [[ -z $max ]]; then\n        output=\"\
    $max\"\n    elif [[ -z $maxlen ]]; then\n        output=\"${max}\"\n    elif [[\
    \ $maxindex -gt $k ]]; then\n        output=\"${max}\"\n    else\n        output=\"\
    $(\n            for ((i=0; i<=$maxindex; i++)) ; do\n                if [[ -n\
    \ ${arr[$i]} ]]; then\n                    if [[ \"$(nl=\"$\\n\"\n           \
    \             [ \"$(nl=${arr[$i]})\" = \"$(nl=${arr[$((i-1))]})\" ]]\n       \
    \                 nl=$)\" ]]; then\n                        local m\n        \
    \                m=\"${arr[$i]}\"\n                        [[ \"$m\" < \"$max\"\
    \ ]] && output=\"$max\"\n                    else\n                        output=\"\
    ${arr[$i]}\"\n                    fi\n                fi\n            done\n \
    \           \"$max\"\n        )\"\n    fi\n    echo \"$output\"", "    local arr=\"\
    $1\"\n    local k=\"$2\"\n    local result i\n    IFS=' ' read -r -a array <<<\"\
    $arr\"\n    local count=0\n    for i in \"${array[@]}\"\n    do\n        if ((\
    \ k > count )); then\n            result=( ${result[@]} \"$i\" )\n           \
    \ count=$(( k - 1 ))\n        else\n            result=( ${result[@]} \"$i\" )\n\
    \        fi\n    done\n    printf \"%s\\n\" \"${result[@]}\"", "    local array=$1\n\
    \    local k=$2\n    if [[ \"$#\" -ne 2 ]]\n    then\n        echo \"wrong parameter\"\
    \ 1>&2\n        return 1\n    fi\n    local i=0\n    local max=$(echo $array |\
    \ tr -s ' ' | cut -d ' ' -f 1 | sort -n)\n    local output\n\n    while [ \"$i\"\
    \ -lt \"$k\" ]\n    do\n        output=$(echo $max | cut -d ' ' -f 1)\n      \
    \  i=$((i + 1))\n        max=$(echo $array | cut -d ' ' -f $i | sort -n)\n   \
    \ done\n    echo $output", "    local arr=$1\n    local k=$2\n    local max\n\
    \    local i\n    local val\n    \n    # Write your code here\n    arr=(${arr//[(\
    \ )]/ })\n    k=${k//[( )]/ }\n    max=$arr[k]\n    for((i=0;i<${#arr[@]};i++))\n\
    \    do\n        val=${arr[i]}\n        if($val>$max)\n        then\n        \
    \    max=`expr $val`\n        fi\n    done\n    echo -n ${arr[@]:0:$k}\n    arr=(\
    \ ${arr[@]:$((k-1)):${#arr[@]} })\n    echo ${arr[@]:0:$k}", "    local arr=$1\n\
    \    local k=$2\n    local max=0\n    local index\n    local element\n    local\
    \ temp\n    local new_arr\n\n    arr=( ${arr[@]} )\n\n    for((i=0;i<${#arr[@]};++i));\
    \ do\n        element=${arr[$i]}\n        if((${element} > ${max})); then\n  \
    \          max=${element}\n        fi\n    done\n\n    for((i=0;i<${#arr[@]};++i));\
    \ do\n        element=${arr[$i]}\n        if((${element} > ${max})); then\n  \
    \          index=$(expr $i + 1)\n            temp=$(( index * ${#arr[@]} ))\n\
    \            new_arr=$arr[$((${#arr[@]} - ${index}))]\n            new_arr[$i]=$arr[$i]\n\
    \            arr[$((${#arr[@]} - ${index}))]=$temp\n            arr[$i]=$new_arr\n\
    \        fi\n    done\n\n    for((i=0;i<${#arr[@]};++i)); do\n        element=${arr[$i]}\n\
    \        if((${element} > ${max})); then\n            arr[$i]=$max\n        fi\n\
    \    done\n\n    arr=( ${arr[@]} )\n\n    for((i=0;i<${#arr[@]};++i)); do\n  \
    \      element=${arr[$i]}\n        if((${element} > ${max})); then\n         \
    \   max=${element}\n        fi\n    done\n\n    for((i=0;i<${#arr[@]};++i)); do\n\
    \        element=${arr[$i]}\n        if((${element} > ${max})); then\n       \
    \     index=$(expr $i + 1)\n            temp=$(( index * ${#arr[@]} ))\n     \
    \       new_arr=$arr[$((${#arr[@]} - ${index}))]\n            new_arr[$i]=$arr[$i]\n\
    \            arr[$((${#arr[@]} - ${index}))]=$temp\n            arr[$i]=$new_arr\n\
    \        fi\n    done\n\n    for((i=0;i<${#arr[@]};++i)); do\n        element=${arr[$i]}\n\
    \        if((${element} > ${max})); then\n            arr[$i]=$max\n        fi\n\
    \    done\n\n    echo \"${arr[@]}\"", "  local array=$1\n  local k=$2\n\n  local\
    \ output\n  output=$( \\\n      sort -n -r \"$array\" \\\n      | head -n \"$k\"\
    \ \\\n      | sed 's/^/\"'\"/g' | sed 's/$/\"'\"/g')\n  echo $output", "    local\
    \ -n arr=$1\n    local -n k=$2\n    local -a max=()\n\n    while (( k <= ${#arr[@]}\
    \ )); do\n        max+=(\"${arr[$k]}\")\n        k=$(( $k + 1 ))\n    done\n \
    \   \n    echo ${max[@]:1:${#max[@]}}", "    local arr=( $1 )\n    local k=$2\n\
    \n    local arr_sorted=($(sort -g <<< \"${arr[*]}\"))\n    local max_length=0\n\
    \n    local k=$(expr ${k} - 1)\n    local max_element=\"${arr_sorted[$k]}\"\n\
    \    local j=0\n\n    for (( i=0; i<${#arr_sorted[@]}; ++i )); do\n        if\
    \ [[ \"$max_element\" == \"${arr_sorted[i]}\" ]]; then\n            (( ++j ))\n\
    \        else\n            if [[ ${j} -eq ${k} ]]; then\n                arr_sorted+=(\"\
    ${max_element}\")\n                break\n            else\n                arr_sorted+=(\"\
    ${max_element}\")\n                j=0\n            fi\n            max_element=\"\
    ${arr_sorted[$i]}\"\n        fi\n    done\n\n    echo \"${arr_sorted[@]}\"", " \
    \   local arr=$1\n    local k=$2\n    local new_arr=()\n    local max=0\n    local\
    \ min=0\n    local len=${#arr[@]}\n    local i=0\n    local max_index=0\n    local\
    \ max_number=0\n    while [ $i -lt $len ]; do\n        local tmp_num=$((${arr[$i]}-${arr[$((i+1))]}))\n\
    \        if [ $tmp_num -gt $max ]; then\n            max=$tmp_num\n          \
    \  max_index=$i\n        fi\n        (( i++))\n    done\n    echo ${new_arr[@]}\n\
    \    while [ $k -lt $len ]; do\n        local tmp_num=$((${arr[$max_index]}+${arr[$((k+1))]}))\n\
    \        if [ $tmp_num -gt $max ]; then\n            max=$tmp_num\n          \
    \  max_index=$(expr $max_index + 1)\n        fi\n        (( k++ ))\n    done\n\
    \    local tmp_num=$((${arr[$max_index]}+${arr[$((k+1))]}))\n    if [ $tmp_num\
    \ -gt $max ]; then\n        new_arr=(${new_arr[@]} ${arr[$max_index]}$)\n    elif\
    \ [ $tmp_num -gt $min ]; then\n        new_arr=(${new_arr[@]} ${arr[$max_index]}$)\n\
    \        (( k-- ))\n    fi\n    while [ $k -lt $len ]; do\n        local tmp_num=$((${arr[$max_index]}+${arr[$((k+1))]}))\n\
    \        if [ $tmp_num -gt $min ]; then\n            min=$(expr $min+$tmp_num)\n\
    \            (( k-- ))\n        fi\n    done\n    if [ $min -ne $max ]; then\n\
    \        new_arr=(${new_arr[@]} ${arr[$max_index]}$)\n    fi\n    echo ${new_arr[@]}",
  "  local arr=(${1//[[:space:]]/ })\n  local k\n  local _\n  for ((i=1; i<${#arr[@]};\
    \ i++)); do\n    _=arr[i]\n    arr[i]=\"${arr[i]//$'-'/-}\"\n    arr[i]=\"${arr[i]//$'\\\
    000'/\\000}\"\n    k=\"$((k+1))\"\n  done\n  printf '%s\\n' \"${arr[@]:0:$k}\"",
  "    local arr=( $1 )\n    local k=${2:-1}\n    local len=${#arr[@]}\n\n    if [[\
    \ $len -ge 1000 ]]; then\n        echo \"too long\"\n    elif [[ $k -lt 0 ]];\
    \ then\n        echo \"too small\"\n    elif [[ $k -lt $len ]]; then\n       \
    \ echo \"too small\"\n    else\n        local res\n        res=()\n        local\
    \ i \n        for ((i=0; i<k; i++)) \n        do\n            res[${#res[@]}]=\"\
    ${arr[i]}\"\n        done\n        echo \"${res[@]}\"\n    fi", "    arr=( $(eval\
    \ echo \"\\\\$($1)\") )\n    [[ \"${#arr[@]}\" -ge \"$2\" ]] || return 1\n   \
    \ local max=0\n    local -i cnt=0\n    for ((i=0; i < ${#arr[@]}; i++)); do\n\
    \        if [[ $cnt -eq $2 ]]; then\n            echo \"${arr[$i]}\"\n       \
    \     break\n        fi\n        [[ $arr[$i] > $max ]] || max=$arr[$i]\n     \
    \   [[ $cnt -le $2 ]] || cnt=$((cnt+1))\n    done", "    # arr is the \"input\"\
    \ list with one string per line\n    local arr k\n    # set flag to make sure\
    \ all items in the list are integers\n    local flag=false\n    # set maximum\
    \ to empty list\n    local maximum=()\n    # split arr into arr and k\n    arr=($1)\n\
    \    k=$2\n    # loop through arr and check each element is an integer\n    for\
    \ ((i = 0; i < ${#arr[@]}; i++)); do\n        # if the element is a string, then\
    \ it cannot be an integer\n        if [[ ${arr[$i]} == \"string\" ]]; then\n \
    \           echo \"ERROR: Array element $i contains a string instead of a number\"\
    \n            exit 1\n        fi\n        # if the element is an integer, then\
    \ add it to a running maximum\n        if [[ $arr[$i] =~ ^-?[0-9]+$ ]]; then\n\
    \            flag=true\n            maximum+=(\"$arr[$i]\")\n        fi\n    done\n\
    \    # if the loop completes without exiting, then there are some invalid elements\n\
    \    if $flag; then\n        echo \"ERROR: Array contains invalid elements\"\n\
    \        exit 1\n    fi\n    # sort maximum\n    maximum=$(sort -n \"${maximum[@]}\"\
    )\n    # return maximum\n    echo \"$maximum\"", "    local arr=$1\n    local\
    \ k=$2\n    local max_arr=()\n    local max_val=0\n    local i=0 j=0\n    while\
    \ [[ $i -lt ${#arr[@]} && $j -lt $k ]]; do\n        if [[ $arr[$i] -gt $max_val\
    \ ]]; then\n            max_val=$arr[$i]\n        fi\n        max_arr[$j]=$arr[$i]\n\
    \        i=$(($i+1))\n        j=$(($j+1))\n    done\n    if [[ $i -ge ${#arr[@]}\
    \ ]]; then\n        local j=$(($k-${#arr[@]}))\n        local k=$k-1\n       \
    \ while [[ $i -lt ${#arr[@]} && $j -lt $k ]]; do\n            max_arr[$j]=$arr[$i]\n\
    \            i=$(($i+1))\n            j=$(($j+1))\n        done\n    fi\n    echo\
    \ $max_arr", "    local arr=$1\n    local k=$2\n    local res=()\n\n    for ((i=0;\
    \ i<${#arr[@]}; i++)); do\n        if [[ $arr[$i] > $k ]]; then\n            res+=(${arr[$i]})\n\
    \        fi\n    done\n    echo ${res[@]}", "\tdeclare -a arr=();\n\tfor i in\
    \ $@;\n\tdo\n\t\tarr+=(\"$i\");\n\tdone\n\tlocal len=${#arr[@]}\n\tlet k=len-1;\n\
    \tlocal result=($(sort -n <<<\"${arr[@]:0:k}\") $(sort -n <<<\"${arr[@]:k}\")\
    \ );\n\techo $result;", "  arr=($(echo $1 | tr \" \" \",\"))\n  k=$2\n  [[ -z\
    \ \"$k\" ]] && k=$(( ${#arr[@]} - 1 ))\n  echo \"${arr[@]:0:$k}\"", "  local arr=$1\n\
    \  local k=$2\n\n  if [ $k -lt 0 -o $k -lt ${#arr[@]} ]; then\n    echo \"The\
    \ length of the array should be in the range of [1, ${#arr[@]}]\"\n    return\
    \ 1\n  fi\n\n  local result=()\n  local i\n  local count=0\n\n  for ((i=0; i<k;\
    \ i++)); do\n    if [[ ${arr[i]} -gt ${arr[i+1]} ]]; then\n      local j=$((i+1))\n\
    \      result=(\"${result[@]}\" ${arr[j]})\n      arr=(\"${arr[@]:j:1}\")\n  \
    \  else\n      arr=(\"${arr[@]:i:1}\")\n      result=(\"${result[@]}\" ${arr[i]})\n\
    \      break\n    fi\n  done\n\n  printf \"%s\" \"${result[@]}\"", "  local arr=(\
    \ \"${@}\" );\n  local max_elements=0;\n  local max_num=$(echo \"${arr[@]}\" |\
    \ wc -l | cut -d \" \" -f 1);\n  local i=0;\n  local j=0;\n  local max_element=\"\
    -1000\";\n  while [ $i -lt ${#arr[@]} ]; do\n    if [[ ${arr[$i]} -gt $max_num\
    \ ]]; then\n      max_element=${arr[$i]};\n      j=$i;\n    fi\n    i=$((i + 1));\n\
    \  done\n  local result=();\n  while [ $j -lt $max_elements ]; do\n    result+=(${arr[$j]});\
    \ j=$((j + 1));\n  done\n  echo $result;", "    local arr=$1\n    local k=$2\n\
    \    local arrlen=${#arr}\n    local klen=${#k}\n\n    local max=0\n\n    if [[\
    \ $arrlen < 1 || klen < 1 ]]; then\n        echo >&2 \"The length of array must\
    \ be greater than 0\"\n        exit 1\n    elif [[ $arrlen -gt $klen ]]; then\n\
    \        echo >&2 \"Length of k must be smaller than length of array\"\n     \
    \   exit 1\n    elif [[ $k -gt $arrlen ]]; then\n        echo >&2 \"Length of\
    \ array must be smaller than length of k\"\n        exit 1\n    else\n       \
    \ local m\n        for (( m=0; m<$klen; m++ )); do\n            if [[ $arr[$m]\
    \ -gt $max ]]; then\n                max=$arr[$m]\n            fi\n        done\n\
    \    fi\n\n    echo $max", "  local IFS=$'\\n'\n  local -a arr=( $1 )\n  local\
    \ k=$2\n\n  k=${k:-0}\n  local res\n  local max\n  local -a maxidx\n  local -a\
    \ maxval\n  local -a index\n\n  res=( $maxval )\n  maxidx=( ${#arr[@]} - 1 )\n\
    \  maxval=${arr[0]}\n\n  maxidx[$(( k - 1 ))]=-1\n  while (( k >= 0 )); do\n \
    \   if [[ ${arr[$index]} -gt ${maxval} ]]; then\n      maxidx[$(( k - 1 ))]=${index}\n\
    \      maxval=${arr[$index]}\n    fi\n    (( k-- ))\n    (( index-- ))\n  done\n\
    \  maxidx[$(( k + 1 ))]=${index}\n  res=${res[*]}\n  for (( i=0; i<${#maxidx[@]};\
    \ i++ )); do\n    arr[$maxidx[$i]]=${arr[$maxidx[$i]]}\n  done\n  res=( ${res[@]/#/\"\
    ${arr[$maxidx[$(( k - 1 ))]}\"} ) #remove unmatched quotes\n  res=( ${res[@]/#/\"\
    ${arr[$maxidx[$(( k + 1 ))]}\"} ) #remove unmatched quotes\n  res=( ${res[@]//,/'\
    \ '} ) #replace comma with space\n  res=( ${res[@]/#/ } ) #remove leading space\n\
    \  res=( ${res[@]/#/ } ) #remove trailing space\n  res=( ${res[@]/%/' '} ) #replace\
    \ space with comma\n  res=( ${res[@]/#/ } ) #remove leading space\n  res=( ${res[@]/%/'\
    \ '} ) #replace space with comma\n  res=( ${res[@]/%/ } ) #remove trailing space\n\
    \  res=( ${res[@]/%/ } ) #remove trailing space\n  res=( ${res[@]/\\\"/ } ) #replace\
    \ double-quotes with single-quotes\n  res=( ${res[@]/\\\"/ } ) #replace double-quotes\
    \ with single-quotes\n  res=( ${res[@]/#/ } ) #remove trailing space\n  res=(\
    \ ${res[@]/%/ } ) #remove trailing space\n  res=( ${res[@]/#/ } ) #remove ", " \
    \   arr=$1\n    k=$2\n    arr=($(echo $arr | sed 's/,/\" \"/g'))\n    arr=($(echo\
    \ $arr | sed 's/ /\",\"/g'))\n    arr=($(echo $arr | sed 's/$/\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/^/\"/'))\n    arr=($(echo $arr | sed 's/$/\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/\"//g'))\n    arr=($(echo $arr | sed 's/ /\",\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/^/\"/'))\n    arr=($(echo $arr | sed 's/,/\" \"/g'))\n    arr=($(echo\
    \ $arr | sed 's/$/\"/g'))\n    arr=($(echo $arr | sed 's/\"//g'))\n    arr=($(echo\
    \ $arr | sed 's/ /\",\"/g'))\n    arr=($(echo $arr | sed 's/^/\"/'))\n    arr=($(echo\
    \ $arr | sed 's/,/\" \"/g'))\n    arr=($(echo $arr | sed 's/$/\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/\"//g'))\n    arr=($(echo $arr | sed 's/ /\",\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/^/\"/'))\n    arr=($(echo $arr | sed 's/,/\" \"/g'))\n    arr=($(echo\
    \ $arr | sed 's/$/\"/g'))\n    arr=($(echo $arr | sed 's/\"//g'))\n    arr=($(echo\
    \ $arr | sed 's/ /\",\"/g'))\n    arr=($(echo $arr | sed 's/^/\"/'))\n    arr=($(echo\
    \ $arr | sed 's/,/\" \"/g'))\n    arr=($(echo $arr | sed 's/$/\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/\"//g'))\n    arr=($(echo $arr | sed 's/ /\",\"/g'))\n    arr=($(echo\
    \ $arr | sed 's/^/\"/'))\n    arr=($(echo $arr | sed 's/,/\" \"/g'))\n    arr=($(echo\
    \ $arr | sed 's/$/\"/g'))\n    arr=($(echo $arr | sed 's/\"//g'))\n    arr=($(echo\
    \ $arr | sed 's/ /\",\"/g'))\n    arr=($(echo $arr | sed 's/", "  echo \"$1\"\
    \ | awk '{n=split($1,a,\" \"); asort(a,a[n]); print a[n]}'", "    arr=($1) \n\
    \    len=${#arr[@]}\n    for ((i=1; i <= len; i++)); do\n        if (( ${arr[$i]}\
    \ < ${arr[$((i-1))]} )); then\n            arr[i]=${arr[$((i-1))]}\n        fi\n\
    \    done\n    for ((j=0; j<len; j++)); do\n        if (( ${arr[j]} > ${arr[$((j-1))]}\
    \ )); then\n            arr[j]=${arr[$((j-1))]}\n        fi\n    done\n    echo\
    \ ${arr[@]}", "    echo \"$1\" | awk '{\n        for (i = 1; i <= NF; i++) {\n\
    \            arr[i]=$i;\n        }\n        for (i = 1; i <= NF; i++) {\n    \
    \        if(i == $2) {\n                j=i;\n            }\n            if(i\
    \ == $2 && j > $2) {\n                j=i;\n            }\n        }\n       \
    \ for (i = 1; i <= NF; i++) {\n            if(i <= j) {\n                arr[i]\
    \ = arr[i - 1]\n            }\n            if(i >= j) {\n                arr[i]\
    \ = arr[j - 1]\n            }\n        }\n        for (i = 1; i <= NF; i++) {\n\
    \            if(i == $2) {\n                print \"\\\"\"arr[i]\"\\\"\"\n   \
    \         }\n        }\n    }' | tr -d '\"'", "  local arr=$1\n  local k=$2\n\
    \  local maxArr\n  local maxArrLength\n  local count\n  \n  maxArr=$(echo \"$arr\"\
    \ | sort -rnk 2 | head -$k -n)\n  maxArrLength=$(echo \"$maxArr\" | wc -c)\n \
    \ \n  if [ $maxArrLength -gt $k ]; then\n    maxArr=($(echo \"$maxArr\" | head\
    \ -$k -n | tail -n +$(( $k - $maxArrLength ))))\n  fi\n  \n  if [ $maxArrLength\
    \ -gt $k ]; then\n    echo $(echo \"$maxArr\" | tail -n 1)\n  else\n    echo $(echo\
    \ \"$maxArr\" | head -n 1)\n  fi", "    local arr=$1\n    local k=$2\n    local\
    \ sorted_arr=$( echo $arr | tr \" \" \",\" | sort -n | cut -d\",\" -f1 )\n   \
    \ local j=0\n    for i in $(seq 0 $(( ${#sorted_arr} - $k )))\n    do\n      \
    \  echo ${sorted_arr[$i]}\n        (( j++ ))\n    done", "    local arr k x\n\
    \    arr=$1\n    k=$2\n    x=\"\"\n    while [[ $k -lt $(($#arr)) ]]; do\n   \
    \     x=\"$x ${arr[$k]}\"\n        k=$((k+1))\n    done\n    echo \"$x\"", " \
    \   local a b\n    read -a a <<< \"$1\"\n    b=$(echo $a | sort -n -r\"$2\")\n\
    \    echo \"$b\"", "  local arr=$1\n  local k=$2\n\n  local sorted\n  local sorted_size\n\
    \  local max_idx\n  local max_val\n\n  sorted=( $( printf \"%s\\n\" \"${arr[@]}\"\
    ))\n  sorted_size=${#sorted[@]}\n\n  if (( sorted_size < k )) ; then\n    # case\
    \ 1: return an empty array if sorted_size < k\n    return \"\"\n  elif (( sorted_size\
    \ == k )) ; then\n    # case 2: return a sorted array if sorted_size == k\n  \
    \  echo \"${sorted[@]}\"\n  else\n    # case 3: split the list into two parts\n\
    \    # A = [arr[0], arr[k-1]]\n    # B = [arr[1:k-1], arr[k]]\n    # sort A first,\
    \ then sort B\n    A=$(maximum \"${sorted[@]:0:(length-2)}\" \"${k}\")\n    B=$(maximum\
    \ \"${sorted[@]:(length-2):(length-1)}\" \"${k}\")\n    # now concatenate A and\
    \ B\n    echo \"${A[@]}\" \"${B[@]}\"\n  fi", "  local arr=($1) k\n  local length=\"\
    ${#arr[@]}\"\n  if (( \"${length}\" < 1 )); then\n    echo \"Usage: $(basename\
    \ \"${BASH_SOURCE[0]}\") <array> <k>\"\n    exit 1\n  fi\n  (( \"${k}\" > \"${length}\"\
    \ )) || return\n  local max\n  local cur\n  max=\"-${k}0000\"\n  cur=\"${max}\"\
    \n  for i in $(seq 0 \"${length}\" -1 ); do\n    if (( \"${arr[i]}\" > \"${cur}\"\
    \ )); then\n      cur=\"${arr[i]}\"\n    fi\n  done\n  printf \"%s\\n\" \"${max}\"\
    \ \"${cur}\"", "  local arr=( $(echo $1 | tr ' ' ',') )\n  local k=$(echo $2 |\
    \ tr '[:lower:]' '[:upper:]')\n  local sorted=$(echo $1 | tr ' ' ',' | sort -n\
    \ | tail -$k)\n  for ((i=0; i<${#sorted[@]}; i++)); do\n    [[ ${sorted[$i]} >\
    \ ${sorted[$((i+1))] } ]] || return $sorted\n  done", "    local arr k max_arr\n\
    \    arr=$1; shift\n    k=$1; shift\n    max_arr=()\n    while [ -n \"${arr}\"\
    \ ]; do\n        k=$((k-1))\n        if [ \"$k\" -le \"$k\" ]; then\n        \
    \    max_arr+=(\"${arr}\")\n            arr=$(($arr + 1))\n            continue\n\
    \        fi\n    done\n    echo \"${max_arr[@]:0:k}\"", "  arr=( $1 )\n  num=$2\n\
    \  length=$(( ${#arr[@]} + ${num} ))\n  i=0\n  max=(\"\")\n  for (( i=0; i<${num};\
    \ i++ )); do\n    if [[ $i -eq ${num} ]]; then\n      max+=( ${arr[@]:i} )\n \
    \     break\n    fi\n    max+=( ${arr[@]:i} )\n    arr=( ${arr[@]:i} )\n  done\n\
    \  echo ${max[@]}", "  arr=(\"${@:2}\")\n  k=$2\n  arr=( $(sort -n <<<\"$1\")\
    \ )\n  result=( )\n  for (( i=0; i<$k; i++ )); do\n    max=${arr[i]}\n    shift\n\
    \    for (( j=0; j<$k; j++ )); do\n      [ ${arr[j]} -gt $max ] && { max=\"${arr[j]}\"\
    ; break; }\n    done\n    result+=( \"$max\" )\n  done\n  echo $(IFS=' '; echo\
    \ \"${result[*]}\")", "    local arr=($(echo $1 | sed 's/ //g'))\n    local k=$2\n\
    \    local length=${#arr[@]}\n    local maxNums=()\n    local j=0\n    local maxIndex=0\n\
    \    local numStr\n\n    if (( k > length )); then\n        echo \"error: k should\
    \ be less than or equal to length of array\" 1>&2\n        return 1\n    elif\
    \ (( k == 0 )); then\n        echo \"error: k should be positive\" 1>&2\n    \
    \    return 1\n    fi\n\n    for i in $(seq 0 $((k - 1))); do\n        numStr=\"\
    ${arr[i]}\"\n        (( j < length && arr[j] >= numStr ? j=j+1 : j=0 ))\n\n  \
    \      if (( j < length )); then\n            if (( arr[j] > arr[j+1] )); then\n\
    \                maxNums+=(${arr[j+1]})\n            else\n                maxNums+=(${arr[j]})\n\
    \            fi\n        fi\n    done\n\n    maxNums+=(${arr[$((k-1))]})\n   \
    \ maxIndex=$((k-1))\n\n    for i in $(seq 0 $((k - 2))); do\n        numStr=\"\
    ${arr[i]}\"\n        (( j < length && arr[j] >= numStr ? j=j+1 : j=0 ))\n\n  \
    \      if (( j < length )); then\n            if (( arr[j] > maxNums[0] && arr[j]\
    \ < maxNums[1] )); then\n                maxIndex=$((j-1))\n                maxNums=(${arr[$maxIndex]})\n\
    \            elif (( arr[j] > maxNums[1] )); then\n                maxNums+=(${arr[j+1]})\n\
    \            fi\n        fi\n    done\n\n    echo \"${maxNums[*]}\" | sed 's/\"\
    //g'", "    arr=$1\n    k=$(echo \"$2\" | awk '{print $1}')\n    arr=($(echo \"\
    $arr\" | grep -E \"^-?[0-9]{1,}\"))\n    arr=($(echo \"$arr\" | sort -r))\n  \
    \  k=$(echo \"$k\" | awk '{print $1}')\n    arr=($(echo \"$arr\" | grep -E \"\
    ^-?[0-9]{1,}\"))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo \"$arr\"\
    \ | awk -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo\
    \ \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n\
    \    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\"\
    \ | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo\
    \ \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n\
    \    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print\
    \ $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk\
    \ -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo\
    \ \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n\
    \    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\"\
    \ | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n    arr=($(echo\
    \ \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print $1$2}'))\n\
    \    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk -F\\\" '{print\
    \ $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo \"$arr\" | awk\
    \ -F\\\" '{print $1$2}'))\n    arr=($(echo \"$arr\" | sort -r))\n    arr=($(echo\
    \ \"$arr\" | awk -F\\\" ", "    local arr\n    local k\n    local max_arr\n\n\
    \    IFS=' ' read -ra arr <<< \"$1\"\n    k=\"$2\"\n    max_arr=()\n    for ((i\
    \ = 0; i < k; i++)); do\n        max_arr[i]=$((${arr[i]}>${arr[i+1]}?${arr[i]}:${arr[i+1]}))\n\
    \    done\n    IFS=' ' read -ra arr <<< \"${max_arr[@]}\"\n    arr=( \"${arr[@]/#/${max_arr[@]}}\"\
    \ )\n    echo \"${arr[@]}\"", "    local arr=\"$1\"\n    local k=\"$2\"\n    if\
    \ [ ! \"$arr\" ] || [ ! \"$k\" ] ; then\n        echo \"${arr[@]} and ${k} are\
    \ both required\"\n        return 1\n    fi\n    arr=( $arr )\n    k=( $k )\n\
    \    local arr1=\"${arr[@]}\"\n    local maxlen=\"${#arr[@]}\"\n    if [ \"$k\"\
    \ -lt \"$maxlen\" ] ; then\n        k=\"$maxlen\"\n    fi\n    local maxarr=()\n\
    \    local i\n    for (( i=1; i<k; i++ )); do\n        maxarr+=( $(tail -1 ${arr1[i]}))\n\
    \    done\n    echo \"${maxarr[@]}\"", "\tlocal arr=$1\n\tlocal k=$2\n\tlocal\
    \ output\n\tarr=$(echo \"${arr}\" | tr \" \" \"\\n\")\n\tk=$(echo \"${k}\" | tr\
    \ \"\\n\" \" \")\n\toutput=$(cat <<-EOF\n\tlet n=${#arr[*]}\n\tfor i in $(seq\
    \ $((n - k + 1)) -1 0)\n\tdo\n\t\techo ${arr[$i]}\n\tdone\n\tEOF\n\t)\n\techo\
    \ \"${output}\"", "    local array=\"$1\"\n    local num=\"$2\"\n    \n    local\
    \ temp\n    local res\n    \n    if [ \"$num\" -gt \"0\" ]; then\n        res=()\n\
    \        \n        IFS=' ' read -a array <<< \"$array\"\n        \n        for\
    \ idx in \"${!array[@]}\"; do\n            curr=${array[$idx]}\n            \n\
    \            if [ \"$idx\" -ge \"$num\" ]; then\n                temp=( \"$temp\"\
    \ )\n                temp+=( \"$curr\" )\n            else\n                if\
    \ [ \"$temp\" == \"\" ]; then\n                    temp=( \"$curr\" )\n      \
    \          else\n                    temp=( \"$temp\" \"$curr\" )\n          \
    \      fi\n            fi\n        done\n        \n        res=( ${temp[@]} )\n\
    \    fi\n    \n    return $res", "    local IFS=\" \"\n    local arr=(\"${@:3}\"\
    )\n    local num=(\"${@:4}\")\n    local max=()\n    local i\n    local maxidx\n\
    \    local str\n\n    IFS=$'\\n'\n    for (( i=0; i < ${#arr[@]}; i++ )); do\n\
    \        maxidx=0\n        max=(\"${max[@]}\" \"$max\")\n        if [[ \"${arr[i]}\"\
    \ -gt \"${max[maxidx]}\" ]]; then\n            maxidx=$(( ${i} + 1 ))\n      \
    \      max=${max[@]:0:maxidx}\n        fi\n        max=\"${max[@]:maxidx}\" \"\
    ${arr[i]}\"\n    done\n\n    IFS=$IFS\n    max=\"${max[@]:1:${#max[@]}}\"\n  \
    \  printf '%s\\n' \"${max[@]}\"", "  declare -a arr=(\"${@:3}\")\n  local -i len=${#arr[@]}\n\
    \  local -i i\n  local max\n  local temp\n  \n  [[ \"$2\" -lt 0 || \"$2\" -gt\
    \ $len ]] && return 1\n  \n  for i in $(seq 0 \"$2\"); do\n    temp=${arr[$i]}\n\
    \    arr[$i]=${arr[$2]}\n    arr[$2]=${temp}\n  done\n\n  max=\"\"\n  local cur\n\
    \  \n  for ((i=1; i<len; i++)) do\n    cur=\"${arr[i]}\"\n    [[ -z \"$max\" ]]\
    \ && max=\"$cur\"\n    [[ \"$cur\" -gt \"$max\" ]] && max=\"$cur\"\n  done\n \
    \ \n  echo \"$max\"", "\tlocal -r arr=$1\n\tlocal -r k=$2\n\t\n\tlocal -i len=${#arr[@]}\n\
    \t\n\tlocal i j\n\t\n\tlocal max\n\t\n\tif [[ ${len} < ${k} ]]; then\n\t\treturn\
    \ 0\n\tfi\n\t\n\tlocal tmp\n\t\n\tfor i in $(seq 0 $((${#arr[@]}-1)) )\n\tdo\n\
    \t\tlocal j=$((i+1))\n\t\tlocal tmp=${arr[i]}\n\t\t\n\t\tif (( j < ${k} )); then\n\
    \t\t\tif [[ ${arr[j]} -gt ${tmp} ]]; then\n\t\t\t\ttmp=${arr[j]}\n\t\t\tfi\n\t\
    \tfi\n\t\t\n\t\tarr[i]=${arr[j]}\n\t\tarr[j]=${tmp}\n\tdone\n\t\n\tmax=($(echo\
    \ \"${arr[*]}\" | sort -nr -k 1,1))\n\t\n\tprintf \"%s\\n\" \"${max[@]}\"", " \
    \ local arr=\"$1\"\n  local k=\"$2\"\n  local n\n  local max\n  local i\n  local\
    \ str\n\n  # Convert to integer array\n  IFS=$' \\t\\n' read -r -a arr <<<\"$arr\"\
    \n\n  # Initialize max and i\n  max=0\n  i=0\n\n  # Loop through array and find\
    \ maximum number\n  for((i=0;i<${#arr[@]};i++)); do\n    [[ \"$arr[$i]\" -gt \"\
    $max\" ]] && ((max=arr[$i]) && i=$i)\n  done\n\n  # Reverse the array to find\
    \ minimum number\n  str=\"\"\n  for((i=${#arr[@]};i>0;i--)); do\n    ((i>0)) &&\
    \ str+=\"$arr[$i-1] \"\n  done\n\n  # Sort max to minimum number and remove it\
    \ from array\n  arr=(\"${arr[@]/$max/$str}\")\n  unset arr[$i]\n\n  # If k is\
    \ not set, return the array\n  if [[ -z \"$k\" ]]; then\n    echo \"${arr[@]}\"\
    \n    return 0\n  fi\n\n  # If k is greater than or equal to array length, return\
    \ array\n  if [[ -n \"$k\" ] && [[ \"$k\" -gt \"${#arr[@]}\" ]]; then\n    echo\
    \ \"${arr[@]}\"\n    return 0\n  fi\n\n  # If k is less than or equal to array\
    \ length, return kth element\n  if [[ -n \"$k\" ] && [[ \"$k\" -lt \"${#arr[@]}\"\
    \ ]]; then\n    echo \"${arr[$((k-1))]}\"\n    return 0\n  fi\n\n  # If k is unset\
    \ or greater than array length, return kth element\n  if [[ -z \"$k\" ]]; then\n\
    \    echo \"${arr[$((k-1))]}\"\n    return 0\n  fi", "  local i\n  local arr=(\
    \ $1 )\n  local k=( $2 )\n\n  sort -n -k ${k}\n  i=1\n  while [ $i -lt ${#arr[@]}\
    \ ]; do\n    if [ $i -lt $k ]; then\n      arr[$i]\n      (( i++ ))\n    fi\n\
    \  done\n\n  echo ${arr[@]}", "    local arr=($1)\n    local k=$2\n    if [ $#\
    \ -ne 2 ]; then\n        echo \"Usage: $(basename $0) array-as-string k\"\n  \
    \      return 1\n    fi\n    local result\n    if [ $arr -eq \"\" ]; then\n  \
    \      echo \"Array is empty.\"\n        return 1\n    fi\n    # k > length(arr)\n\
    \    if [ $k -gt \"${#arr}\" ]; then\n        echo \"Error: k should be less than\
    \ the length of the array.\"\n        return 1\n    fi\n    if [ $k -lt 1 ]; then\n\
    \        echo \"Error: k should be positive.\"\n        return 1\n    fi\n   \
    \ for i in \"${arr[@]}\"; do\n        if [ $i -gt $k ]; then\n            result=$i\n\
    \            break\n        fi\n    done\n    echo \"$result\"", "    local arr=\"\
    $1\"\n    local k=\"$2\"\n    local -i len=\"${#arr}\"\n\n    local -a ret\n\n\
    \    # Special case for k = 1 or k = 0\n    if [ \"$k\" -eq 1 ] || [ \"$k\" -eq\
    \ 0 ]; then\n        # In order to not change the original array, clone it\n \
    \       local -n _arr=\"$arr\" _\n        local i\n\n        # Insert k elements\
    \ in the empty array\n        for i in \"${!_arr[@]}\"; do\n            _arr+=($i)\n\
    \        done\n\n        # Sort the array\n        sort -nr _arr\n\n        #\
    \ Return the first k elements\n        ret=$(IFS=\" \" ; echo \"${!_arr[@]:0:$k}\"\
    )\n    else\n        local -n _arr=\"$arr\" _\n        local -i j\n\n        #\
    \ Find the maximum number of k elements in the array\n        local -i max_k\n\
    \        max_k=0\n        for i in \"${!_arr[@]}\"; do\n            if [ \"$max_k\"\
    \ -eq \"$k\" ]; then\n                ret+=(${_arr[i]})\n                ((k--))\n\
    \            else\n                max_k=$((max_k+1))\n                ret+=(${_arr[i]})\n\
    \            fi\n        done\n    fi\n\n    return \"${ret[@]}\"", "  local -r\
    \ arr=$1\n  local -r k=$2\n  local -n max=${arr[@]}\n  local -n maxlen=${#max[@]}\n\
    \  [[ $maxlen == $k ]] || return 0\n  local -n i\n  local -n maxnum\n  local -a\
    \ maxnums\n  maxnums=()\n  local -n temp\n  local -r result\n  for ((i = 0; i\
    \ < $k; ++i)); do\n    maxnum=${max[i]}\n    if (( ${#maxnums[@]} > ${#maxnum}\
    \ )); then\n      maxnums=($maxnums)\n      maxnum=$maxnums[${#maxnums[@]}]\n\
    \    elif (( ${#maxnums[@]} < ${#maxnum} )); then\n      maxnums=(\"$maxnum\"\
    \ \"$maxnums[${#maxnums[@]}-1]\")\n    fi\n    maxnums[${#maxnums[@]}]=$maxnum\n\
    \  done\n  result=()\n  for ((i = 0; i < $k; ++i)); do\n    temp=${max[i]}\n \
    \   if (( ${#result[@]} < ${#temp} )); then\n      result=(\"$result\" \"$temp\"\
    )\n    elif (( ${#result[@]} > ${#temp} )); then\n      (( ${#result[@]} > ${#temp}\
    \ )) && result=(\"$result\" \"$temp\")\n    else\n      result=(\"$result\" \"\
    $maxnum\")\n    fi\n  done\n  [[ ${#result[@]} -gt $k ]] && result=(\"${result[@]:0:$k}\"\
    )\n  echo -n \"[\"\n  printf \"\\\"%s\\\"\" \"${result[@]}\"\n  echo \"]\"", " \
    \   local -n arr=$1\n    local -n k=$2\n    local -n result\n    k=$(( k > 0 &&\
    \ k < ${#arr[@]} ? k : ${#arr[@]} ))\n    local -a temp_arr\n    temp_arr=()\n\
    \    for (( i = 1; i <= k; i++ )); do\n        temp_arr+=( \"${arr[$((i-1))]}\"\
    \ )\n    done\n    temp_arr+=( \"${arr[$((k-1))]}\" )\n    result=( $(sort -n\
    \ <<< \"${temp_arr[@]}\") )\n    echo ${result[@]}", "  local arr=$1\n  local\
    \ k=$2\n  local result=$(eval \"echo \\\"${arr[*]} | sort -n -k ${k},${k} \\\n\
    \    | head -n ${k}\\\"\")\n  echo $result", "  local arr=$1\n  local k=$2\n \
    \ local max_arr\n  local max_k\n  local i\n  local j\n  max_k=0\n  max_arr=()\n\
    \  for i in ${arr[@]}; do\n    ((j=0))\n    while ((j<k)) && ((i<${#arr[@]}) ||\
    \ (${arr[i]}<0)); do\n      if ((${arr[i]}>0)); then\n        ((j++))\n      else\n\
    \        ((i--))\n      fi\n    done\n    if ((${i}==0)); then\n      max_arr+=(\"\
    $i\")\n      if ((j==k)); then\n        max_k=$i\n        break\n      fi\n  \
    \  fi\n  done\n  echo \"${max_arr[@]}\"", "    local arr\n    local k\n    arr=$1\n\
    \    k=${2:-0}\n    [[ \"${arr}\" =~ ^\"*\"$ ]] || arr=$(echo ${arr// / })\n \
    \   sort ${arr[@]} -o ${arr[@]}\n    local i=0\n    local j=0\n    local result\n\
    \    local max\n    for ((i=0; i<${#arr[@]}; ++i)); do\n        if [[ ${k} ==\
    \ ${i} ]]; then\n            if [[ ${result} != \"\" ]]; then\n              \
    \  echo \"${result}\"\n            fi\n            result=$((result+1))\n    \
    \    fi\n        max=${arr[i]}\n        if [[ ${i} == ${j} ]]; then\n        \
    \    if [[ ${result} != \"\" ]]; then\n                if [[ ${max} > ${result}\
    \ ]]; then\n                    echo \"${result}\"\n                fi\n     \
    \       fi\n            result=$((result+1))\n        fi\n        if [[ ${max}\
    \ > ${arr[i]} ]]; then\n            echo \"${max}\"\n            result=$((result+1))\n\
    \        fi\n    done\n    if [[ ${result} != \"\" ]]; then\n        echo \"${result}\"\
    \n    fi", "  local arr=( $1 )\n  local k=( $2 )\n  local output\n  local index\n\
    \  # Make sure k is in range\n  [[ \"${k}\" -gt 0 ]] && [[ \"${k}\" -lt 1000 ]]\
    \ && return 1\n  output=$(mktemp)\n  # Write k numbers into tmp file\n  for index\
    \ in \"${arr[@]}\"; do\n    printf '%s\\n' \"$index\" > \"$output\"\n  done\n\
    \  # sort tmp file\n  sort -n -k 1,1 \"$output\" > \"$output\"\n  # Return k largest\
    \ numbers in sorted output\n  readarray -n \"${k}\" output < \"$output\"\n  rm\
    \ \"$output\"\n  return 0", "  local arr=$1\n  local k=${2:-0}\n\n  if [ ${#arr[@]}\
    \ -gt 0 ]; then\n    local i\n    local sorted\n    local max\n    \n    # Sort\
    \ the array \n    for i in $(seq 0 ${#arr[@]}); do\n      local j\n      if [\
    \ $i -eq 0 ]; then\n        sorted=\"${arr[$i]}\"\n      elif [ ${arr[$i]} -gt\
    \ $sorted ]; then\n        sorted=\"${arr[$i]}\"\n      fi\n    done\n\n    #\
    \ Remove elements larger than k\n    local temp\n    local n\n    for j in $(seq\
    \ 0 $(( ${#arr[@]} - k ))); do\n      if [ $j -le ${#sorted} ]; then\n       \
    \ if [[ $arr[$j] -gt $sorted ]]; then\n          temp=\"${arr[$j]}\"\n       \
    \   arr[$j]=${arr[$(( $j + 1 ))]}\n          arr[$(( $j + 1 ))]=${temp}\n    \
    \    fi\n      fi\n    done\n\n    # Remove the remaining elements\n    for j\
    \ in $(seq 0 $(( ${#arr[@]} - k ))); do\n      arr[$j]=${arr[$(( $j + 1 ))]}\n\
    \    done\n\n    # Return the result array\n    echo \"$arr[@]\" | tr ' ' ','\n\
    \  else\n    echo \"Usage: $(basename $0) <array> <k>\"\n  fi", "    local arr=$1\n\
    \    local k=$2\n\n    local tmp\n    local count\n    local max\n    local maxCount\n\
    \n    for i in $(seq 1 $k); do\n        tmp=$(echo $arr | cut -d ' ' -f $((i *\
    \ 2 - 1)))\n        count=$(($(echo $tmp | wc -c | awk -F'[' -v n=$i '{ print\
    \ $n }') ))\n        max=$tmp\n        maxCount=$count\n    done\n\n    echo \"\
    $max\"\n", "    local arr=(\"$@\")\n    local k=\"$2\"\n    local output\n\n \
    \   for (( i=1;i<=k;i++ )); do\n        local j=$(( $(sort -n \"${arr[@]}\" |\
    \ head -n \"$i\" | tail -n 1) ))\n        output+=(${arr[$i]})\n        arr[$i]=$j\n\
    \    done\n\n    echo \"${output[@]}\"", "    local arr k i\n    IFS=' ' read\
    \ -r -a arr <<< \"$1\"\n    k=\"$2\"\n    [[ \"$k\" -le \"$k\" ]] || return 1\n\
    \    [[ \"$k\" -eq \"$k\" ]] && return 1\n    for ((i = 0; i < \"${#arr[@]}\"\
    ; ++i)); do\n        [[ ${arr[i]} -gt \"${arr[i]}.$k\" ]] || return 1\n    done\n\
    \    IFS=$' \\t\\n'", "    arr=$1\n    k=$2\n    # convert to integer arr\n  \
    \  arr=( $(echo $arr | tr -d ' ' | tr '-' '\\n' | sort -n) )\n    # check k\n\
    \    if [ -z \"$k\" ]; then\n        k=$(( ${#arr[@]} - 1 ))\n    fi\n    # check\
    \ k range\n    if [ $k -lt 0 -o $k > ${#arr[@]} ]; then\n        echo \"Bad k:\
    \ ${k}\"\n        echo \"Exit...\"\n        return 1\n    fi\n    # sort array\
    \ k\n    sorted=( $(echo $arr | sort -k $k ) )\n    # return sorted array\n  \
    \  echo ${sorted[@]:0:$k}", "    arr=$1\n    size=${#arr[@]}\n    k=${2:-1}\n\
    \    if [ $size -eq 0 ]\n    then\n        echo \"arr is empty\"\n        return\n\
    \    fi\n    if [ $size -eq 1 ]\n    then\n        echo \"$arr[0]\"\n        return\n\
    \    fi\n    if [ $k -lt 0 ] || [ $size -eq 0 ]\n    then\n        echo \"arr\
    \ must have non-negative integers and no less than 1\"\n        return\n    fi\n\
    \    if [ $k -ge $size ]\n    then\n        echo \"k must be less than $size or\
    \ arr must have no less than $size numbers\"\n        return\n    fi\n    arr=($arr)\n\
    \    arr_new=()\n    arr_max_1=()\n    arr_max_2=()\n    arr_max_3=()\n    arr_max_4=()\n\
    \    for i in $(seq 0 $((${#arr[@]}-1)))\n    do\n        arr_max=$((${arr[$i]}>${arr[$i+1]}?${arr[$i]}:${arr[$i+1]}))\n\
    \        if [ ${arr_max} -gt ${arr_max_1[i]} ]\n        then\n            arr_max_1[i]=${arr_max}\n\
    \            arr_new+=${arr[$i]}\n        elif [ ${arr_max} -gt ${arr_max_2[i]}\
    \ ]\n        then\n            arr_max_2[i]=${arr_max}\n            arr_new+=${arr[$i]}\n\
    \        elif [ ${arr_max} -gt ${arr_max_3[i]} ]\n        then\n            arr_max_3[i]=${arr_max}\n\
    \            arr_new+=${arr[$i]}\n        elif [ ${arr_max} -gt ${arr_max_4[i]}\
    \ ]\n        then\n            arr_max_4[i]=${arr_max}\n            arr_new+=${arr[$i]}\n\
    \        fi\n    done\n    arr_max_1=$(printf \"%s\\n\" \"${arr_max_1[@]}\")\n\
    \    arr_max_2=$(printf \"%s\\n\" \"${arr_max_2[@]}\")\n    arr_max_3=$(printf\
    \ \"%s\\n\" \"${arr_max_3[@]}\")\n    arr_max_4=$(printf \"%s\\n\" \"${arr_max_4[@]}\"\
    )\n    if [ $arr_max_4 -eq ${arr_max_3} ]\n    then\n        echo \"${arr_new[@]}\"\
    \n    elif [ $arr_max_4 -eq ${arr_max_2} ]\n    then\n        echo \"${arr_max_1[@]}\
    \ ${arr_new[@]}\"\n    elif [ $arr_max_4 ", "  # Initialize result\n  local maxval=$1\n\
    \  local maxvalcount=0\n  # Read each element of arr and increment count\n  for\
    \ i in $2; do\n    if [[ -z \"$maxval\" ]]; then\n      maxval=$i\n      maxvalcount=1\n\
    \    elif [[ \"$i\" -gt \"$maxval\" ]]; then\n      maxval=$i\n      maxvalcount=1\n\
    \    else\n      maxvalcount=$((maxvalcount+1))\n    fi\n  done\n  \n  # Return\
    \ the result\n  echo \"$maxval\"\n  echo \"$maxvalcount\"", "    local arr=($(eval\
    \ echo $1)); shift\n    local k=$1; shift\n    local len=$#\n    if [[ ${len}\
    \ -gt 999 ]] || [[ ${len} -lt 1 ]] || [[ ${k} -lt 0 ]]; then\n        echo \"\
    Wrong parameter input!\"\n        return 1\n    fi\n    local max=\n    for i\
    \ in $(seq 1 $len); do\n        local key=$(eval echo ${arr[$i]})\n        local\
    \ value=$(eval echo ${arr[$((i-1))]})\n        if [[ ${key} -gt ${value} ]]; then\n\
    \            max=$(eval echo ${arr[$i]})\n        fi\n    done\n    echo \"${arr[@]:0:$k}\
    \ $max\"", "  local arr=\"$1\"\n  local k=\"$2\"\n  local tmp=\"\"\n  local i\n\
    \  local max\n  local maxi=0\n  for ((i=0; i<k; i++)); do\n    local tmp2=\"$tmp\"\
    \n    local tmp3=\"$tmp2\"\n    local tmp4\n    for ((j=0; j<k; j++)); do\n  \
    \    if [[ -n \"$arr\" ]]; then\n        if [[ \"$j\" -eq \"$i\" ]]; then\n  \
    \        tmp4=\"$arr\"\n        else\n          tmp4=\" $arr\"\n        fi\n \
    \       tmp3=\" $tmp3\"\n      fi\n    done\n    tmp=\"$tmp3\"\n    arr=\"$tmp4\"\
    \n  done\n  for ((i=0; i<k; i++)); do\n    max=\"$(eval echo \"$max$i\")\"\n \
    \ done\n  echo \"$max\"", "    local -a arr=$1\n    local -i k=$2\n    local -a\
    \ result\n    local -i start=0\n\n    for ((start=0; start<k; start+=k)) {\n \
    \       result=()\n        for ((i=start; i<k; i+=k)) {\n            result+=(\"\
    ${arr[i]:(-k)}\")\n        }\n        result=(\"${result[@]}\")\n    }", "   \
    \ local arr=\"$1\"\n    local k=\"$2\"\n    local ret\n\n    declare -i i=0\n\
    \    while (( i < k )); do\n        (( i++ ))\n        arr+=\" \"\n    done\n\n\
    \    IFS=\" $\"\n    arr=( ${arr} )\n    echo ${arr[@]}\n    for (( i = 0; i <\
    \ k; i++ )); do\n        ret=\"$ret\" \"${arr[i]}\"\n    done\n\n    echo ${ret}\n\
    \    return 0", "    local arr=$1\n    local k=$2\n    local m=0\n    local maxs=()\n\
    \    while [[ ${#arr} -gt ${k} ]]; do\n        local max=$(echo \"${arr[@]:0:k}\"\
    \ | tr '\\n' ' ')\n        maxs[${m}]=${max}\n        arr=(\"${arr[@]:k}\")\n\
    \        ((m++))\n    done\n    for ((i=k; i<${#maxs[@]}; i++))\n    do\n    \
    \    arr+=(\"${maxs[$i]}\")\n    done\n    echo \"${arr[@]}\"", "    local arr=(\
    \ \"${@}\" )\n    local k=\"${2}\"\n    local max_arr\n    local max_index\n \
    \   local i\n    local length\n\n    length=${#arr[@]}\n\n    if [ $length -lt\
    \ 1 ] ; then \n        echo 1\n        return\n    fi\n\n    # Sort the array\n\
    \    arr=($(sort -n ${arr[@]}))\n\n    # Get the maximum element\n    max_arr=${arr[0]}\n\
    \    max_index=0\n\n    # Compare every element in the array\n    for i in $(seq\
    \ 1 $length) ; do\n        if [ ${arr[i]} -gt $max_arr ]; then\n            max_arr=${arr[i]}\n\
    \            max_index=i\n        fi\n    done\n\n    # Get the largest k elements\n\
    \    arr=(${arr[@]:0:$((k-1))})\n    arr=(${arr[@]:$((k-1))})\n\n    echo \"${arr[@]}\"",
  "    local arr\n    local k\n\n    arr=$1\n    shift\n    k=$1\n    shift\n\n  \
    \  local out\n    out=()\n\n    local i\n    for i in $(seq 1 $((k - 1))); do\n\
    \        out+=$((arr[i - 1] > arr[i]))\n    done\n    out+=(${arr[0]} > ${arr[k\
    \ - 1]})\n\n    local out1\n    out1=${out[*]}\n    for i in $(seq 1 $((k - 1)));\
    \ do\n        out1=$((out1 + arr[i]))\n    done\n    out1+=${arr[k - 1]}\n\n \
    \   echo $out1", "  local arr=$1\n  local k=$2\n  local maxArr\n  local maxK\n\
    \  local index\n  local indexMax\n  local max\n  local len\n  local curElem\n\n\
    \  maxArr=$arr\n  maxK=$k\n  indexMax=$((${#maxArr} - 1))\n  index=$((${#maxK}\
    \ - 1))\n\n  if [ $indexMax -lt 0 -o $indexMax -gt $index ]; then\n    echo \"\
    Error: k should be in the range [0, ${#maxArr}].\"\n    exit 1\n  fi\n\n  if [\
    \ $indexMax -eq 0 ]; then\n    echo \"No elements left.\"\n  else\n    while [\
    \ $index -gt 0 ];\n    do\n      max=$(( ${maxArr[$index]} > ${maxArr[$indexMax]}\
    \ ? ${maxArr[$index]} : ${maxArr[$indexMax]} ))\n      maxArr[$index]=${maxArr[$indexMax]}\n\
    \      maxArr[$indexMax]=$max\n      indexMax=$((indexMax - 1))\n      index=$((index\
    \ - 1))\n    done\n  fi\n  maxArr=(${maxArr[@]})\n  echo \"${maxArr[@]}\"", " \
    \   local arr=(\"$@\")\n    local k=\"$2\"\n    # sort in descending order\n \
    \   local sorted=($(sort -n -r <<<\"$arr[@]\"))\n    # get the first k elements\n\
    \    local sorted=($(echo \"${sorted[@]:0:$k}\" | sort -nr))\n    # remove the\
    \ last element if it is less than the first element\n    local sorted=(${sorted[@]:0:${#sorted[@]}-1})\n\
    \    # add the prefix '[' and suffix ']'\n    local sorted=(${sorted[@]}')\n \
    \   echo \"${sorted[@]}\"", "    local arr=\"$1\"\n    local k=\"$2\"\n    local\
    \ i max result\n    for ((i=0; i<k; i++)); do\n        max=$(echo $arr | grep\
    \ -Eo '(\\-?[0-9]+)')\n        [ -z $max ] && break\n        arr=$arr | sed -E\
    \ 's/(\\-?[0-9]+)/\"&\"/g'\n        result+=\"'$max'\\n\"\n    done\n    echo\
    \ \"${result::-1}\"", "  local arr k\n  arr=$(echo $1 | sed 's/ /\" \"/g' | awk\
    \ '{split($1,a,\"-\")}')\n  k=$(echo $2 | awk '{print $1}')\n  while ((k--))\n\
    \  do\n    arr=(\"${arr[@]:0:1}\" \"${arr[@]:k})\"\n  done\n  echo \"${arr[@]}\"",
  "    arr=$1\n    k=$2\n    arr=($arr)\n    arr=($(awk '{for(i=1;i<=NF;i++){a[i]=a[i]$i;}END{print\
    \ max}' <<< \"$arr\" ))\n    echo \"${arr[@]:0:k}\"", "  arr=$1\n  k=$2\n  i=1\n\
    \  MAX=-1\n\n  while [ $i -lt $k ]; do\n    while [ $i -lt $k ] && [[ ${arr[$i]}\
    \ -gt $MAX ]] || [[ ${arr[$i]} -eq $MAX ]]; then\n      MAX=${arr[$i]}\n     \
    \ ((i++))\n    done\n\n    arr[$i]=${arr[$i]}\n    ((i++))\n\n  done\n\n  echo\
    \ ${arr[@]:0:$k}", "    local arr=$1\n    local k=$2\n    local tmp\n\n    arr=($arr)\n\
    \    for i in {0..k-1}; do\n        tmp=${arr[i]}\n        arr[i]=$tmp\n    done\n\
    \n    printf '['\n    for i in ${arr[@]}; do\n        printf '\"%s\" ' $i\n  \
    \  done\n    printf ']\\n'", "\tlocal -n arr=\"$1\"\n\tlocal k=\"$2\"\n\n\t[ \"\
    ${k}\" -gt \"${#arr}\" ] && return 0\n\n\tlocal n=0\n\tlocal -a sorted=()\n\n\t\
    while (( n < k )); do\n\t\tlocal elem=${arr[n]}\n\t\t(( n++ ))\n\n\t\t[ \"${elem}\"\
    \ -gt \"${arr[0]}\" ] && local -a tmp=(\"${arr[@]:0:n}\")\n\t\tsorted+=(${tmp[@]})\n\
    \tdone\n\n\tsorted+=(${arr[@]:k})\n\n\tprintf '%s\\n' \"${sorted[@]}\"", "   \
    \ local i k arr max result\n    arr=\"$1\"\n    k=\"$2\"\n    max=$(echo $arr\
    \ | tr \" \" \",\" | awk '{for(i=1;i<=NF;i++) if ($i>max) max=$i;print $max}')\n\
    \    for ((i=1;i<=k;i++)); do\n        result=$(echo $arr | awk -v k=$i '{for(i=1;i<=NF;i++)\
    \ if ($i>=k) print $i}')\n        result=$(echo $result | tr \" \" \",\" | sort\
    \ -n | awk '{if(NF>1) print $0}')\n        result=$(echo $result | tr \" \" \"\
    ,\" | sed 's/,$//')\n        result=$(echo $result | tr -d '\",\"')\n        result=$(echo\
    \ $result | tr '\"' \"\\\"\")\n        result=$(echo $result | sed 's/,$//')\n\
    \        result=$(echo $result | sed 's/\"//g')\n        result=$(echo $result\
    \ | tr '-' ',')\n        result=$(echo $result | sed 's/,$//')\n        echo \"\
    $result\"\n    done", "    arr=$1\n    k=$2\n    max=$(echo $arr | tr \" \" \"\
    \\n\" | sort -n -r -k ${k})\n    echo $max", "  local arr=$1; shift\n  local k=$1;\
    \ shift\n  local out\n  local i\n\n  out=$(echo \"$arr\" | sed 's/^ *//g; s/ *$//g;\
    \ s/ /,/g')\n  IFS=, set -- \"$out\"\n\n  k=$(( (k > 0) ? (k) : 1 ))\n  k=\"$(($k\
    \ - 1))\"\n\n  local max\n  local i\n  local j\n  local j1\n  local k\n  local\
    \ v1\n  local v2\n\n  for ((i = 0; i < ${#arr[@]}; ++i)); do\n    j1=$(( i - k\
    \ ))\n    j=$(( j1 + k ))\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n\
    \    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[\
    \ -z ${arr[j]} ]]; then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]];\
    \ then\n      continue\n    fi\n\n    if [[ -z ${arr[j]} ]]; then\n      ", " \
    \   local arr=$1; shift\n    local k=$1; shift\n\n    arr=(${arr[@]})\n    [[\
    \ ${#arr[@]} -lt $k ]] && { echo \"$0: invalid input (k)\" && exit 1; }\n    [[\
    \ ${#arr[@]} -gt $k ]] && { echo \"$0: invalid input (k)\" && exit 1; }\n\n  \
    \  # Sort the array\n    local temp\n    local i\n    for ((i=0; i<$((${#arr[@]}\
    \ - $k)); i++)); do\n        temp=${arr[i]}\n        arr[i]=${arr[i+1]}\n    \
    \    arr[i+1]=${temp}\n    done\n\n    # Convert the array to a string\n    local\
    \ result\n    IFS=' ' read -r -a result <<< \"${arr[*]}\"\n\n    # Output the\
    \ result\n    printf '%s\\n' \"${result[@]:$k}\"", "  local arr=\"$1\"\n  local\
    \ k=\"$2\"\n\n  local arr_length=${#arr[@]}\n  local max_arr_length=${#arr_max[@]}\n\
    \n  local j=0\n  local max_j=0\n  local i=0\n  local max_i=0\n\n  local tmp\n\n\
    \  while [ $i -lt $k ]; do\n    tmp=${arr[$i]}\n    arr_max[$max_i]=${arr[$i]}\n\
    \    max_i++\n    max_j=$((max_j+1))\n    arr_max[$max_i]=${arr[$i]}\n    i=$((i+1))\n\
    \  done\n\n  while [ $j -lt $max_j ]; do\n    arr[$j]=${arr_max[$max_j]}\n   \
    \ j=$((j+1))\n  done\n  arr[$j]=${arr_max[$max_j]}\n\n  # echo \"arr: ${arr[@]}\"\
    \n  # echo \"arr_max: ${arr_max[@]}\"", "  local arr=\"$1\"\n  local k=\"$2\"\n\
    \  local out\n  arr=($(echo ${arr} | sed -e \"s/^ *//\" -e \"s/ *$//\"))\n  IFS='\
    \ ' read -r -a arr <<<\"${arr[@]}\"\n  local sorted=()\n  for (( i=0; i<k; ++i));\
    \ do\n    local min\n    min=\"${arr[i]}\"\n    local max\n    max=\"${arr[i]}\"\
    \n    for (( j=i+1; j<k; ++j); do\n      local max2\n      max2=\"${arr[j]}\"\n\
    \      if (( \"${min}\" = \"${max2}\" )) ; then\n        max=\"${max2}\"\n   \
    \   else\n        if (( \"${min}\" > \"${max}\" )) ; then\n          min=\"${max}\"\
    \n        fi\n        if (( \"${max}\" = \"${max2}\" )) ; then\n          max=\"\
    ${max2}\"\n        else\n          if (( \"${min}\" > \"${max2}\" )) ; then\n\
    \            max=\"${max2}\"\n          fi\n        fi\n      fi\n    done\n \
    \   sorted+=($min)\n  done\n  IFS=', ' read -r -a sorted <<<\"${sorted[*]}\"\n\
    \  echo \"${sorted[*]}\"", "    local arr=\"$1\"\n    local k=\"$2\"\n    \n \
    \   local str\n    local j=0\n    local i\n    local max\n\n    # Remove space\n\
    \    arr=\"${arr//[[:space:]]/}\"\n\n    # Array length check\n    if [ ${#arr}\
    \ -lt 1 ]; then\n        return $arr\n    fi\n\n    # Make sure that k is in [0,\
    \ arr length)\n    if [ ${k} -lt 0 -o -z ${arr} ]; then\n        k=0\n    fi\n\
    \n    # Array sorting\n    for (( i=0; i<${#arr}; i++ )); do\n        if [ ${arr[$i]}\
    \ -gt ${arr[$(( i+1 ))]} ]; then\n            str=\"${arr[$i]}\"\n           \
    \ arr[$i]=\"${arr[$(( i+1 ))]}\"\n            arr[$(( i+1 ))]=\"${str}\"\n   \
    \     fi\n    done\n\n    # Max k loop\n    for (( i=1; i<${k}; i++ )); do\n \
    \       max=$(echo \"${arr[@]:-$i}\" | sort)\n        str=\"${max}\"\n       \
    \ arr=(${arr[@]:-$(( i ))})\n        arr=(${arr[@]:${#arr[@]}-1})\n        arr=(${arr[@]:0})\n\
    \n        for (( j=0; j<${#arr[@]}; j++ )); do\n            if [ ${arr[j]} -gt\
    \ $str ]; then\n                str=\"${arr[j]}\"\n            fi\n        done\n\
    \n        arr=(${arr[@]:0})\n    done\n\n    # Remove last item in the list\n\
    \    arr=(${arr[@]:1})\n\n    # Array length check\n    if [ ${#arr[@]} -lt $k\
    \ ]; then\n        return $arr\n    fi\n\n    echo \"${arr[@]}\"", "    local\
    \ arr=$1 k=$2\n    local result\n    local count=0\n    result=()\n    # sort\
    \ arr\n    arr=($(echo \"$arr\" | sort -r))\n    while [ $count -lt $k ]; do\n\
    \        # find largest number in arr\n        # max is -1, not largest number\n\
    \        max=$(( ${arr[$count]} > max ? ${arr[$count]} : max ))\n        ((count++))\n\
    \    done\n    # append max to result\n    result +=($max)\n    echo \"$result\"",
  "    arr=$1\n    arr_size=$2\n    arr_size=${arr_size}\n    sorted_list=( )\n  \
    \  \n    for(( i=1; i<$arr_size; i++ )); do\n        curr=$arr[i]\n        sorted_list+=(\
    \ $curr )\n    done\n    \n    sorted_list=($(sort -n -k 1 <<< \"$sorted_list\"\
    ))\n    max_num=$(echo $sorted_list[$(( $(( ${#sorted_list[@]} - 1 )) ))]  | cut\
    \ -d ' ' -f 1)\n    \n    for(( i=0; $i <= $arr_size; i++ )); do\n        if [\
    \ \"$sorted_list[$i]\" -gt \"$max_num\" ]; then\n            max_num=$(echo $sorted_list[$i]\
    \  | cut -d ' ' -f 1)\n        fi\n    done\n    \n    echo $sorted_list[$(( $((\
    \ ${#sorted_list[@]} - 1 )) ))]", "    local arr=(\"${@:2}\")\n    local k=(\"\
    ${@:3}\")\n    local new_arr=\"\"\n    local max_idx=0\n    local cur_idx=0\n\
    \    while [ $cur_idx < $k ]; do\n        local cur=${arr[$cur_idx]};\n      \
    \  if [ \"$cur\" -gt $max_idx ]; then\n            new_arr=\"$new_arr \\\"$cur\\\
    \"\"\n            max_idx=\"$cur\"\n        fi\n        (( cur_idx+=1 ))\n   \
    \ done\n    echo $new_arr", "\techo \"$1\" | sed -r 's/^[^-]*-([^-]*)-[^-]*$/\\\
    1/'\n\tlocal i\n\tlocal max\n\tlocal list\n\tlist=$1\n\tmax=$2\n\ti=1\n\twhile\
    \ [ \"$i\" -le \"$max\" ]; do\n\t\tlist=\"$list $1\"\n\t\ti=$((i+1))\n\tdone\n\
    \techo $list", "    arr=(`echo $1` && echo `echo $2`)\n    arr1=`echo ${arr[*]}\
    \ | tr \" \" \"\\n\"`\n    echo `echo $arr1 | sort -n -r | head -n $2`", "  local\
    \ arr=$1\n  local k=$2\n  \n  local count=0\n  local max=\n  \n  for ((i=0;i<k;i++))\n\
    \  do\n    max=$(echo \"$arr\" | sort -n | tail -n 1)\n    arr=$(echo \"$arr\"\
    \ | sed -n \"${i}p\")\n    count=$((count+1))\n  done\n  \n  echo ${arr}", " \
    \   local arr=\"$1\"\n    local k=\"$2\"\n    local output\n    output=$(eval\
    \ echo \"\\$(echo \\\"\\${arr[*]:0:$k}\\\" | sort -r -n -k $(($k-1)))\")\n   \
    \ echo \"$output\"", "    local arr=$1\n    local k=$2\n    if [ $k -lt $1 ]\n\
    \    then\n        k=$(($k+1))\n    fi\n\n    if [ $k -lt 1 ]\n    then\n    \
    \    echo \"$arr\"\n        return\n    fi\n\n    local j=0\n    local max=$arr[j]\n\
    \n    while [ $j -le $k ]\n    do\n        if [ \"$arr[$j]\" -gt \"$max\" ]\n\
    \        then\n            max=$arr[j]\n        fi\n\n        j=$(($j+1))\n  \
    \  done\n\n    echo \"$max\"", "    local arr k\n    IFS=$'\\t' arr=($1) k=$2\n\
    \    local tmp\n    local -a max_k\n    local -i -i maxlen=0\n    local maxval\n\
    \    local maxpos\n    local result\n    # Sort the array arr\n    local -a sorted\n\
    \    sorted=($(sort -n <<<\"${arr[@]}\" | head -n ${k}))\n    # Traverse the sorted\
    \ array and get the maximum k\n    for i in \"${!sorted[@]}\"; do\n        tmp=${sorted[i]}\n\
    \        if [[ $tmp > $maxval ]]; then\n            maxval=$tmp\n            maxpos=$i\n\
    \        fi\n    done\n    # Get the result and store it into max_k\n    result=()\n\
    \    for i in $(seq 0 $((${#arr[@]} - 1))); do\n        if [[ ${arr[$i]} == $maxval\
    \ ]]; then\n            result+=(\"${arr[$i]}\")\n        else\n            break\n\
    \        fi\n    done\n    # Return the result as an array and print it\n    max_k=(\"\
    ${result[@]:0:$k}\")\n    for i in $(seq 0 $((${#max_k[@]} - 1))); do\n      \
    \  printf '\"%s\" ' \"${max_k[i]}\"\n    done\n    printf '\\n'", "    local IFS='\
    \ '\n    local arr=($1)\n    local k=$2\n    local output\n\n    [[ $k -lt 0 ||\
    \ $k -lt $((${#arr[@]})) ]] && return 1\n    [[ ${#arr[@]} -eq $k ]] && return\
    \ 0\n\n    local j=0\n    for ((i=1; i<${#arr[@]}; i++)); do\n        [[ ${arr[i]}\
    \ -gt $((${arr[i-1]})) ]] && j=$i || break\n    done\n\n    [[ $i == $j ]] ||\
    \ return 1\n    output=$(for i in $(seq 1 $k); do echo -n \"${arr[i]}\"; done)\n\
    \    [[ -n $output ]] && echo \"$output\" || return 1", "    local arr=\"$1\"\n\
    \    local k=\"$2\"\n    local sorted=\"$3\"\n    local max_idx=$(( k - 1 ))\n\
    \    local max_val\n\n    arr=( $arr )\n    sorted=( $sorted )\n\n    while ((\
    \ k >= 1 )); do\n        max_val=${sorted[$max_idx]}\n        max_idx=$(( max_idx\
    \ - 1 ))\n\n        sorted[$max_idx]=$max_val\n        k=$(( k - 1 ))\n\n    done\n\
    \n    sorted[$max_idx]=\"${sorted[$max_idx]}\"\n    sorted=\"${sorted[@]}\"\n\
    \    echo \"$sorted\"", "    local arr=(\"${@:2}\")\n    local k=\"$1\"\n    local\
    \ tmp\n    local max\n    local i\n    local x\n    \n    max=-1\n    for ((i=0;\
    \ i<k; i++)); do\n        x=$(echo \"${arr[i]}\" | awk '{print -$1*$2}')\n   \
    \     if [ \"$x\" -gt \"$max\" ]; then\n            max=$x\n        fi\n    done\n\
    \    \n    arr=($(echo \"${arr[*]}\" | awk '{print -$1*$2}'))\n    \n    [[ \"\
    ${max}\" -gt \"$k\" ]] && \\\n        tmp=\"${arr[@]:0:k}\"\n    \n    [[ \"${max}\"\
    \ -ge \"$k\" ]] && \\\n        tmp=\"${arr[@]:((k-1)):((k-1))}\"\n    \n    arr=(\"\
    ${tmp[@]}\")\n    \n    echo \"${arr[@]}\"", "    local arr=$1; shift; local k=$1;\
    \ shift\n    local max_value; local max_index\n    max_value=${arr[0]}; max_index=0\n\
    \    for (( i=1; i<${#arr[@]}; i++ )); do\n        if [ ${arr[$i]} -gt ${max_value}\
    \ ]; then\n            max_value=${arr[$i]}; max_index=i\n        fi\n    done\n\
    \    printf \"\\\"${arr[$max_index]}\\\" \"", "    arr=$1\n    k=$2\n    max_arr=$((\
    \ ${#arr[@]}-1 ))\n    # handle if k is less than 0\n    if [ ${k} -lt 0 ]; then\
    \ \n        echo ${arr[@]}\n        return\n    fi\n    # handle if k is greater\
    \ than length of arr\n    if [ ${k} -gt ${max_arr} ]; then\n        echo ${arr[@]}\n\
    \        return\n    fi\n    # handle if k is equal to length of arr\n    if [\
    \ ${k} -eq ${max_arr} ]; then\n        echo ${arr[@]}\n        return\n    fi\n\
    \n    # sort arr\n    arr=($(sort -g ${arr[@]} ))\n    # handle if k is greater\
    \ than length of arr\n    if [ ${k} -gt ${max_arr} ]; then\n        echo ${arr[@]}\n\
    \        return\n    fi\n    # handle if k is equal to length of arr\n    if [\
    \ ${k} -eq ${max_arr} ]; then\n        echo ${arr[@]}\n        return\n    fi\n\
    \    # handle if k is less than length of arr\n    if [ ${k} -lt ${max_arr} ];\
    \ then\n        echo ${arr[@]}\n        return\n    fi\n\n    # sort arr again\n\
    \    arr=($(sort -g ${arr[@]} ))\n    # handle if k is greater than length of\
    \ arr\n    if [ ${k} -gt ${max_arr} ]; then\n        echo ${arr[@]}\n        return\n\
    \    fi\n    # handle if k is equal to length of arr\n    if [ ${k} -eq ${max_arr}\
    \ ]; then\n        echo ${arr[@]}\n        return\n    fi\n    # handle if k is\
    \ less than length of arr\n    if [ ${k} -lt ${max_arr} ]; then\n        echo\
    \ ${arr[@]}\n        return\n    fi", "  local arr=$1\n  local k=$2\n  local output\n\
    \  output=($(sort -n ${arr} |\n    head -$k |\n    sed -n 's/^\\(.*\\).*$/\\1/p'\
    \ |\n    tr '\\n' ' '))\n  echo ${output[@]}", "    local arr=( ${1//\\\"/} );\
    \ #remove all quotes\n    local k=${2-1}\n    local arr2\n    for (( i=0; i<${#arr[@]};\
    \ i++ ));\n    do\n        arr2=${arr[i]}\n        if [[ ${arr[i]} -gt ${arr2}\
    \ ]]; then\n            arr2=${arr[i]}\n        fi\n    done\n    arr=(${arr[@]/$arr2})\n\
    \    for (( i=0; i<${k}; i++ ));\n    do\n        arr=(\"${arr[@]/$arr2}\")\n\
    \    done\n    arr=(${arr[@]/$'\"\"'})\n    echo ${arr[@]}", "    local -n arr=$1\n\
    \    local -i k=$2\n    local -a sorted\n    local i=0\n\n    sorted=( $(echo\
    \ $arr | tr ' ' '\\n' | sort -n | head -$k | tr -d '\\n' ) )\n    i=$(expr $k\
    \ - 1)\n    for(( ;i < ${#arr[@]};i++)); do\n        local -n x=${sorted[$i]}\n\
    \        if(( $(echo \"${sorted[$i]} <= ${x}\" | bc) )) ; then\n            sorted[$i]=${sorted[$i]}\n\
    \            i=$((i + 1))\n        else\n            sorted[$i]=${x}\n       \
    \     break\n        fi\n    done\n\n    echo \"${sorted[@]}\"", "    local arr=$1\n\
    \    local k=$2\n    arr=($(echo $arr))\n    arr=($(sort -n ${arr[@]}))\n    local\
    \ ret=${arr[@]:0:$k}\n    echo ${ret[@]}", "\tlocal arr=\"$1\"\n\tlocal k=\"$2\"\
    \n\tlocal length=\"$(array_size \"$arr\")\"\n\tlocal max_array\n\tlocal max_element\n\
    \tlocal max_index\n\tlocal max_element\n\t\n\tlet max_index=k\n\tlet k=$((k-1))\n\
    \t\n\tmax_array=()\n\tmax_element=-1\n\t\n\tfor i in \"${arr[@]:0:$k}\"; do\n\t\
    \t[ \"${i}\" -gt \"${max_element}\" ] && max_element=${i}\n\tdone\n\t\n\tmax_array+=($max_element)\n\
    \t\n\tfor i in \"${arr[@]:$((k+1)):$length}\"; do\n\t\t[ \"${i}\" -gt \"${max_element}\"\
    \ ] && max_element=${i}\n\tdone\n\t\n\tmax_array+=($max_element)\n\t\n\techo \"\
    ${max_array[@]}\"", "    arr=$1\n    len=${#arr[@]}\n    if [[ $len -ne $2 ]];\
    \ then\n        echo \"Invalid input\"\n        return 1\n    fi\n    sortedArr=()\n\
    \    for i in `seq 1 $len`\n    do\n        sortedArr+=${arr[$i]}\n    done\n\
    \    echo \"${sortedArr[0]}\"", "  local IFS=\\  \n  read -a arr <<<\"$1\"\n \
    \ local k\n  ((k=\"$2\"))\n  k=$((k>${#arr[@]} || k=1))\n  if ((k>1)); then \n\
    \    echo \"$arr[$k]\"; \n  else\n    echo \"$arr\";\n  fi", "  local arr=\"$1\"\
    \n  local k=\"$2\"\n  [[ -z $arr ]] && arr=()\n  [[ -z $k ]] && k=1000\n  local\
    \ result=$(printf '%s' \"${arr[@]}\" | sort -n | tail -n $((k - 1)) | head -n\
    \ 1)\n  [[ -z $result ]] && result=()\n  echo \"$result\"", "    if [ $# -lt 2\
    \ ]\n    then\n        echo \"Error: insufficient input!\"\n        exit 1\n \
    \   fi\n\n    arr=( $1 )\n    len=${#arr[@]}\n    num=$(echo $len | cut -c 1-3)\n\
    \    min=$(echo $len | cut -c 4-5)\n\n    if [ ${len} -le 3 ]\n    then\n    \
    \    echo \"Error: invalid array length!\"\n        exit 1\n    fi\n\n    if [[\
    \ ${len} -le $(( ${num} + 2 )) ]]\n    then\n        echo \"Error: invalid array\
    \ length!\"\n        exit 1\n    fi\n\n    if [ $min -gt 3 ]\n    then\n     \
    \   echo \"Error: min cannot be greater than 3!\"\n        exit 1\n    fi\n\n\
    \    arr=( ${arr[@]} | sed -e \"s/ //g\")\n    arr=( ${arr[@]} | sed -e \"s/ //g\"\
    )\n    arr=( ${arr[@]} | sed -e \"s/ //g\")\n    arr=( ${arr[@]} | sed -e \"s/\
    \ //g\")\n\n    arr=( ${arr[@]} | sed -e \"s/^[[:digit:]]*//g\")\n\n    if [ $min\
    \ -gt ${#arr[@]} ]\n    then\n        echo \"Error: min cannot be greater than\
    \ ${#arr[@]}!\"\n        exit 1\n    fi\n\n    if [ $num -gt ${#arr[@]} ]\n  \
    \  then\n        echo \"Error: num cannot be greater than ${#arr[@]}!\"\n    \
    \    exit 1\n    fi\n\n    if [ $min -gt $num ]\n    then\n        echo \"Error:\
    \ min cannot be greater than num!\"\n        exit 1\n    fi\n\n    if [ $num -gt\
    \ $(( $len + $min )) ]\n    then\n        echo \"Error: num + min cannot be greater\
    \ than ${len + min}!\"\n        exit 1\n    fi\n\n    arr=( ${arr[@]} | sed -e\
    \ \"s/^[[:digit:]]*//g\")\n    arr=( ${arr[@]} | sed -e \"s/^[[:digit:]]*//g\"\
    )\n    arr=( ${arr[@]} | sed -e \"s/^[[:digit:]]*//g\")\n    arr=( ${arr[@]} |\
    \ sed -e \"s/^[[:digit:]]*//g\")\n    arr=( ${arr[@]} | sed -e \"s/^[[:digit:]]*//g\"\
    )\n\n    if [ ${num} -gt 0 ]\n    then\n        arr=( ", "    # Write your code\
    \ here.\n    if [ $# -ne 2 ] ; then\n        echo \"ERROR: $(basename $0) takes\
    \ 2 arguments\"\n        exit 1\n    fi\n    local arr=(${1:-})\n    local k=$2\n\
    \    local len=$((${#arr[@]}))\n    local temp\n    local i=0\n    local result=(${arr[@]:0:k})\n\
    \    while [ $i -lt $k ] ; do\n        temp=$(echo $result | sort -n -k $((i-1)))\
    \ ; result[$i]=$temp\n        ((++i))\n    done\n    for ((j=$((k-1)); j<$len;\
    \ j++)); do\n        if [[ ${result[$j]} -gt ${result[$((k-1))]} ]] ; then\n \
    \           result[$j]=${result[$((k-1))]}\n        fi\n    done\n    echo $result\
    \ | sed 's/\\\"//g'", "    local arr=( \"$@\" )\n    local len=${#arr[@]}\n  \
    \  local k=$2\n    if [ \"$len\" -lt \"$k\" ]; then k=$len; fi\n    local sorted\n\
    \n    sorted=()\n    while [ \"$k\" -gt 0 ]; do\n        local head=${arr[$((k-1))]}\n\
    \        local tail=${arr[$((k))]}\n        if [ \"$tail\" -gt \"$head\" ]; then\n\
    \            arr=( \"${arr[@]:0:$k}\" \"$head\" \"${arr[@]:$k}\" )\n        else\n\
    \            arr=( \"${arr[@]:0:$k}\" \"$tail\" \"$head\" )\n        fi\n    \
    \    k=$((k-1))\n    done\n    sorted=( \"${sorted[@]}\" )\n    arr=( \"${arr[@]}\"\
    \ )\n\n    echo \"${sorted[@]}\""]
stop_tokens:
- "\n}"
