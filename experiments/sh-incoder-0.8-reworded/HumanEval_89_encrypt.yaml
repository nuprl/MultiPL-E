name: HumanEval_89_encrypt
language: sh
prompt: "#!/bin/bash\n# Create a function encrypt that takes a string as an argument\
  \ and\n# returns a string encrypted with the alphabet being rotated. \n# The alphabet\
  \ should be rotated in a manner such that the letters \n# shift down by two multiplied\
  \ to two places.\n# For example:\n# >>> $(encrypt \"hi\")\n# \"lm\"\n# >>> $(encrypt\
  \ \"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> $(encrypt \"gf\")\n# \"kj\"\n# >>> $(encrypt\
  \ \"et\")\n# \"ix\"\n#\n# $1 is a string\nencrypt() {\n"
tests: "}\n\ncandidate() {\n    encrypt \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"hi\") = \"lm\" ]]\n    [[ $(candidate \"asdfghjkl\") = \"ewhjklnop\"\
  \ ]]\n    [[ $(candidate \"gf\") = \"kj\" ]]\n    [[ $(candidate \"et\") = \"ix\"\
  \ ]]\n    [[ $(candidate \"faewfawefaewg\") = \"jeiajeaijeiak\" ]]\n    [[ $(candidate\
  \ \"hellomyfriend\") = \"lippsqcjvmirh\" ]]\n    [[ $(candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) = \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" ]]\n    [[ $(candidate \"\
  a\") = \"e\" ]]\n}\n\nrun_test"
completions: ["  local string=\"$1\"\n  local alphabet=abcdefghijklmnopqrstuvwxyz\n\
    \  local index=0\n  local count=0\n  local encrypted=''\n\n  for letter in $string;\
    \ do\n    local currentChar=`echo $letter | sed \"s/[a-z]/$alphabet/\" | sed \"\
    s/\\(.\\)\\(.\\)/\\2\\1/g\"`\n    if [ \"$currentChar\" != \"$letter\" ]; then\
    \ \n      index=$((index + 2))\n    fi\n    let count++\n    encrypted+=\"$alphabet[$index]\"\
    \n  done\n  echo \"$encrypted\"", "\tlocal str=\"$1\"\n\tlocal alphabet=abcdefghijklmnopqrstuvwxyz\n\
    \tlocal num=$(echo $alphabet|wc -w)\n\tlocal shift=${alphabet:1:$((num-1))}\n\t\
    local out=\"\"\n\tfor ((i=${#str}-1; i>=0; i--)) do\n\t\tout+=\"$alphabet[$((${alphabet:i:1}${num})${shift}:${alphabet:i:1})]\"\
    \n\tdone\n\techo \"$out\"", "    echo \"$1\" | sed -e \"s/.*/\\$(printf '%2.2x'\
    \ $(for ((i=0;i<=9;i++)); do echo -n 'a'; done))/g\"", "  local string=\"$1\"\n\
    \  local result=\"\"\n  local count\n  for (( count=0; count < ${#string}; count+=2\
    \ )); do\n    local first=${string:$count:2}\n    local second=${string:$count+1:2}\n\
    \    result+=\"${alphabet[$first]}${alphabet[$second]}\"\n  done\n  echo \"$result\"",
  '  echo $1 | tr a-z n-za-mN-Za-M', "  local str=$1\n  local chars=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  local rotated_chars=\"zyxwvutsrqpomnlgkjihgfedcba\"\n  local c\n  local idx\n\
    \n  for ((idx=0; idx<${#chars}; idx++)); do\n    c=${chars:$idx:1}\n    c=${c:0:2}\n\
    \    \n    printf \"%s\" \"$c\"\n\n    local next_idx\n    for (( next_idx=$idx\
    \ + 1 ; next_idx < ${#chars} ; next_idx++ )); do\n      local next_c=${chars:$next_idx:1}\n\
    \      local next_c=${next_c:0:2}\n      \n      if [ \"$c\" = \"$next_c\" ];\
    \ then \n        break\n      else\n        printf \"%s\" \"${rotated_chars:$next_idx:1}\"\
    \n      fi\n    done\n  done", "\techo \"$1\" | awk '{\n\t\tfor (i=1;i<=NF;i++)\
    \ {\n\t\t\tprintf \"%s\", toupper($i%26); \n\t\t\t$i=$i/26; \n\t\t}\n\t}'", " local\
    \ a=\"$1\"\n  local b=\"${a//[^a]}\"\n  echo \"${b//[^c]}${b//[^b]}\"", "  local\
    \ str=$1\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local output=\"\"\
    \n  local i\n  local j\n  for ((i = 0; i < ${#str}; i++)) ; do\n    local c=${str:$i:1}\n\
    \    local k\n    for ((j = 0; j < ${#alphabet}; j++)) ; do\n      if [ $j -eq\
    \ 0 ] ; then\n        k=${alphabet:$j:1}\n      else\n        k=${alphabet:$j:2}\n\
    \      fi\n      if [ $c -eq $k ] ; then\n        output=\"${output}${alphabet:$j:1}\"\
    \n      else\n        output=\"${output}${alphabet:$j:3}\"\n        break\n  \
    \    fi\n    done\n  done\n  echo $output", "        local string=\"$1\"\n   \
    \     local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n        local alphabet_with_one=\"\
    abcdefghijklmnopqrstuvwxyz\"\n        local alphabet_with_four=\"abcdefghijklmnopqrstuvwxyz4\"\
    \n        local alphabet_with_five=\"abcdefghijklmnopqrstuvwxyz5\"\n        local\
    \ alphabet_with_nine=\"abcdefghijklmnopqrstuvwxyz9\"\n        local alphabet_with_ten=\"\
    abcdefghijklmnopqrstuvwxyz0\"\n        local alphabet_with_thirty=\"abcdefghijklmnopqrstuvwxyz3\"\
    \n        local alphabet_with_sixty=\"abcdefghijklmnopqrstuvwxyz6\"\n        local\
    \ alphabet_with_hundred=\"abcdefghijklmnopqrstuvwxyzz\"\n        local alphabet_with_thousand=\"\
    abcdefghijklmnopqrstuvwxyzzz\"\n        local alphabet_with_tenthousand=\"abcdefghijklmnopqrstuvwxyzzzz\"\
    \n        local alphabet_with_hundredthousand=\"abcdefghijklmnopqrstuvwxyzzzzz\"\
    \n        local alphabet_with_onethousand=\"abcdefghijklmnopqrstuvwxyzzzzzz\"\n\
    \        local alphabet_with_onehundred=\"abcdefghijklmnopqrstuvwxyzzzzzzz\"\n\
    \        local alphabet_with_onehundredthousand=\"abcdefghijklmnopqrstuvwxyzzzzzzzz\"\
    \n        local alphabet_with_onethousandhundred=\"abcdefghijklmnopqrstuvwxyzzzzzzzzz\"\
    \n        local alphabet_with_onethousandthousand=\"abcdefghijklmnopqrstuvwxyzzzzzzzzzz\"\
    \n        local alphabet_with_onehundredthousandhundred=\"abcdefghijklmnopqrstuvwxyzzzzzzzzzzz\"\
    \n        local alphabet_with_tenthousandhundredthousand=\"abcdefghijklmnopqrstuvwxyzzzzzzzzzzzz\"\
    \n        local alphabet_with_onehundredthousandthousandhundred=\"abcdefghijklmnopqrstuvwxyzzzzzzzzzzzzzz\"\
    \n        local alphabet_with_onethousandthousandthous", "  local string=$1\n\
    \  local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n \
    \ local encrypted=\"\"\n  for c in $string; do\n    encrypted=\"${encrypted}${alphabet:1:${#alphabet}-2}${c:2:1}${alphabet:2:${#alphabet}-2}\"\
    \n  done\n  echo \"${encrypted}\"", "    local string=$1\n    local alphabet=$2\n\
    \    local encryption\n\n    # First turn the string into an array of individual\
    \ characters\n    # Turn it into an array.\n    local stringArray=($string)\n\
    \    # Create a variable to hold the encrypted string\n    local encryptedString=''\n\
    \    # Loop through each character\n    for ((i=0; i<${#stringArray[@]}; i=i+2));\
    \ do\n        encryption=$(( (alphabet[${stringArray[i]}]-2)*(${stringArray[i+1]}-2)\
    \ + (alphabet[${stringArray[i+1]}]-2) * (alphabet[${stringArray[i]}]-2)) )\n \
    \       # Add the encrypted letter to the encrypted string\n        encryptedString+=\"\
    ${alphabet[${stringArray[i]}]}\"\n        # Add the encrypted letter to the encrypted\
    \ string\n        encryptedString+=\"${alphabet[${encryption}]}\"\n    done\n\
    \    # Return the encrypted string\n    echo $encryptedString", "  local message=$1\n\
    \  local alphabet=\"$2\"\n  # Shift every letter down by 2 places\n  local shifts=\"\
    a b c d e f g h i j k l m n o p q r s t u v w x y z\"\n  local output\n  output=$(for\
    \ index in ${!alphabet}; do echo \"${alphabet:index:2}\";done)\n  output=$(for\
    \ letter in ${output}; do echo \"${shifts:letter:2}\"; done)\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  output=\"${output//\
    \ /}\"\n  output=\"${output// /}\"\n  output=\"${output// /}\"\n  ", "   local\
    \ string=${1}\n\n   # get the alphabet to rotate from\n   alphabet=${1}\n\n  \
    \ # get the number of places to rotate by\n   places=${2:-1}\n\n   # get the alphabet\
    \ length\n   alphabetLength=${#alphabet}\n\n   # get the number of chars to shift\n\
    \   shiftCount=${#string}\n   \n   if [[ \"${shiftCount}\" -gt \"${alphabetLength}\"\
    \ ]]; then\n      echo \"ERROR: Unable to shift letters by ${shiftCount}. Length\
    \ of alphabet ${alphabetLength}\"\n      exit 1\n   fi\n\n   # loop through the\
    \ string\n   for (( i=0; i<${#string}; i++ )); do\n      # get the current char\
    \ from the string\n      currentChar=${string:$i:1}\n\n      # get the char at\
    \ the current index in the alphabet\n      currentAlphaChar=${alphabet:$((i%alphabetLength)):1}\n\
    \n      # shift it down\n      shiftedChar=${alphabet:$((i%alphabetLength)):1}\n\
    \n      # append the char to the rotated string\n      string+=\"${shiftedChar}\"\
    \n      alphabet+=\"${currentAlphaChar}\"\n   done\n\n   # return the string\n\
    \   echo \"${string}\"", "    local str=\"$1\"\n    local alphabet=abcdefghijklmnopqrstuvwxyz\n\
    \    local rotations=${alphabet:0:${#alphabet}-2}\n    echo \"${str}\" | tr \"\
    $rotations\" \"${alphabet:2:${#alphabet}}\" ", "  local i\n  local result\n  local\
    \ char\n  local rot\n  local prev\n  local prevchar\n  local string\n  local temp\n\
    \  local char1\n  local char2\n  local char3\n  local char4\n  local char5\n \
    \ local char6\n  local char7\n  local char8\n  local char9\n  local char10\n \
    \ local char11\n  local char12\n  local char13\n  local char14\n  local char15\n\
    \  local char16\n  local char17\n  local char18\n  local char19\n  local char20\n\
    \  local char21\n  local char22\n  local char23\n  local char24\n  local char25\n\
    \  local char26\n  local char27\n  local char28\n  local char29\n  local char30\n\
    \  local char31\n  local char32\n  local char33\n  local char34\n  local char35\n\
    \  local char36\n  local char37\n  local char38\n  local char39\n  local char40\n\
    \  local char41\n  local char42\n  local char43\n  local char44\n  local char45\n\
    \  local char46\n  local char47\n  local char48\n  local char49\n  local char50\n\
    \  local char51\n  local char52\n  local char53\n  local char54\n  local char55\n\
    \  local char56\n  local char57\n  local char58\n  local char59\n  local char60\n\
    \  local char61\n  local char62\n  local char63\n  local char64\n  local char65\n\
    \  local char66\n  local char67\n  local char68\n  local char69\n  local char70\n\
    \  local char71\n  local char72\n  local char73\n  local char74\n  local char75\n\
    \  local char76\n  local char77\n  local char78\n  local char79\n  local char80\n\
    \  local char81\n  local char82\n  local char83\n  local char84\n  local char85\n\
    \  local char86\n  local char87\n  local char88\n  local char89\n  local char90\n\
    \  local char91\n  local char92\n  local char93\n  local char94\n  local char95\n\
    \  local char96", "    local string=\"$1\"\n    local output\n\n    # Flip the\
    \ letters in the string.\n    output=$(sed 's/.*/\\L\\1\\L/2' <<<\"$string\")\n\
    \n    # Rotate the letters down by two and multiply by 2.\n    output=$(sed 's/.*/\\\
    1\\L\\2\\L/2' <<<\"$output\")\n\n    # Rotate the letters up by two and multiply\
    \ by 2.\n    output=$(sed 's/.*/\\L\\1\\L/2' <<<\"$output\")\n\n    # Return the\
    \ result as a string.\n    echo \"$output\"", "    echo \"$1\" | sed -e 's/./&\\\
    n/g' | tr '[A-Z]' '[a-z]' | grep -v \"^$\" | tr '\\n' '\\n' | sed -e \"s/^/$1/\"\
    \ | tr '\\n' '!'", "  local input=\"$1\"\n\n  # Create a variable called \"alpha\"\
    \ that contains the alphabet \n  # shifted down by two multiplied to two places\n\
    \  local alpha=\"$(printf 'abcdefghijklmnopqrstuvwxyz' | sed 's/./\\002&/g' |\
    \ sed 's/\\002/g' | sed 's/\\002&/g')\"\n  \n  # Create a variable called \"alphabet\"\
    \ that contains the alphabet \n  # shifted down by one place.\n  local alphabet=\"\
    $(printf 'abcdefghijklmnopqrstuvwxyz' | sed 's/./\\001&/g')\"\n\n  # Create a\
    \ variable called \"output\" that contains the encrypted text.\n  local output\n\
    \  \n  # Use awk to find all the characters in the input string\n  # and append\
    \ them to an array called \"output\"\n  output=\"$(echo $input | awk '{printf\
    \ \"%s\", $0}')\"\n  \n  # Find the length of the input string\n  local length=${#output}\n\
    \n  # Create a variable called \"i\" that will be used to \n  # loop through the\
    \ input string\n  local i\n  \n  # Use \"for\" loop to loop through the input\
    \ string\n  for ((i=1; i<=$((length-1)); i++)); do\n    \n    # Append the character\
    \ \"i\" from the input string to the \n    # array called \"output\"\n    output=\"\
    ${output}${alphabet:$((i%${#alphabet})):1}\"\n  \n    # Use \"shift\" command\
    \ to \"shift\" the alphabet\n    shift\n  \n    # Shift the alphabet down by two\
    \ by adding \"2\" at the \n    # end of this command\n    alpha=\"${alpha:0:1}${alpha:1:1}\"\
    \n    shift\n  \n    # Shift the alphabet down by one by adding \"1\" at the \n\
    \    # end of this command\n    alphabet=\"${alphabet:0:1}${alphabet:1:1}\"\n\
    \  \n  done\n\n  # Create a variable called \"i\" that will be used to \n  # loop\
    \ through the output string\n  local j\n  \n  # Use \"for\" loop to loop through\
    \ the output string\n  for ((j=1; j<=length; j++)); do\n    \n    # Append the\
    \ character \"j\" from the output string to the \n    # array called \"output\"\
    \n    output=\"${output}${alpha:$((j%${#alpha})):1}\"\n  \n    # Shift the alphabet\
    \ down by one by adding \"1\" at the \n    # end of this command\n    shift\n\
    \  \n  done\n\n  # Return the output string\n  echo $output", "    local string=\"\
    $1\"\n    local alphabet=abcdefghijklmnopqrstuvwxyz\n    local result=\"\"\n \
    \   for (( i=0; i<${#string}; i++ )); do\n        result=\"${result}${alphabet:(($i\
    \ % ${#alphabet})):2}${string:$i:1}\"\n    done\n    echo \"$result\"", "    local\
    \ STR=$1\n    local LETTERS=\"abcdefghijklmnopqrstuvwxyz\"\n    local LETTERS_REVERSE=\"\
    nopqrstuvwxyzabcdefghijklm\"\n\n    # first shift letters down the alphabet\n\
    \    STR=\"${STR,,}\"\n\n    # then rotate letters up by 2 places \n    # this\
    \ is done by subtracting the string \"abcde\" from the \n    # string \"abcdefghijklmnopqrstuvwxyz\"\
    \ and then adding \"cdefghijklmnopqrstuvwxyz\" back \n    STR=\"${LETTERS${STR,,}#${LETTERS_REVERSE${LETTERS${STR,,}}}\"\
    \n\n    # finally return the string\n    echo \"$STR\"", "    string=\"$1\"\n\
    \    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    # Create a string of the length\
    \ becuase we will be iterating through it.\n    length=$((${#string} + 1))\n \
    \   # Initialize the counter to 0\n    i=0\n\n    for j in $alphabet; do\n   \
    \     # Increment the counter\n        ((i++))\n        # Take the letter in the\
    \ string at position $i and then \n        # add two to it so that it is shifted\
    \ down by two.\n        letter=$(echo $string | cut -d \"$j\" -f $i)\n       \
    \ # Append the letter to the new string\n        encrypted+=$(echo \"$letter\"\
    +\"2\" | bc)\n        # Decrement the counter.\n        ((i--))\n    done\n  \
    \  # Add one to the length of the string to account for \n    # the fact that\
    \ when we rotate we will be moving down and \n    # one position from the end.\n\
    \    length=$(expr $length + 1)\n    # End the loop as we will be moving the string\
    \ down.\n    encrypted+=\"00\"\n    # Create the new string.\n    encrypted=\"\
    \"$(for j in ${!length}; do echo -n \"${encrypted:$j:1}\"; done)", "    local\
    \ ROTATIONS='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_'\n\
    \    local ENCRYPTED_STRING=\"\"\n    local STRING=\"$1\"\n    local FIRST_LETTER=\"\
    $STRING\"\n    local SECURED_LETTER=$ROTATIONS\n    local SECURED_LETTER_ROTATED=`echo\
    \ $SECURED_LETTER | sed \"s/.\\(.\\)/\\1\\\\\\n/g\"`\n    local NEXT_LETTER=`echo\
    \ $SECURED_LETTER_ROTATED | sed \"s/\\(.\\)/\\1\\\\\\n/g\"`\n    local NEXT_LETTER_ROTATED=`echo\
    \ $NEXT_LETTER | sed \"s/.\\(.\\)/\\1\\\\\\n/g\"`\n    local NEXT_ROTATION=`echo\
    \ $NEXT_LETTER_ROTATED | sed \"s/\\(.\\)/\\1\\\\\\n/g\"`\n    local ROTATED_SECURED_LETTER=`echo\
    \ $SECURED_LETTER_ROTATED | sed \"s/$STRING/$NEXT_ROTATION/g\"`\n    local ROTATED_SECURED_LETTER_ROTATED=`echo\
    \ $ROTATED_SECURED_LETTER |sed \"s/.\\(.\\)/\\1\\\\\\n/g\"`\n    local ROTATED_SECURED_LETTER_ROTATED_ROTATED=`echo\
    \ $ROTATED_SECURED_LETTER_ROTATED |sed \"s/.\\(.\\)/\\1\\\\\\n/g\"`\n    local\
    \ SECURED_LETTER_ROTATED_ROTATED=`echo $ROTATED_SECURED_LETTER_ROTATED_ROTATED\
    \ |sed \"s/.\\(.\\)/\\1\\\\\\n/g\"`\n    local SECURED_LETTER_PLACE=`echo $ROTATED_SECURED_LETTER_ROTATED_ROTATED\
    \ |sed \"s/.\\(.\\)/\\1/g\"`\n    local FIRST_LETTER_PLACE=`echo $ROTATED_SECURED_LETTER_ROTATED_ROTATED\
    \ |sed \"s/.\\(.\\)/\\1/g\"`\n    local NEXT_LETTER_PLACE=`echo $ROTATED_SECURED_LETTER_ROTATED_ROTATED\
    \ |sed \"s/.\\(.\\)/\\1/g\"`\n    local NEXT_ROTATION_PLACE=`echo $ROTATED_SECURED_LETTER_ROTATE",
  "  while [ $# -gt 1 ]; do\n    CHARS=${1:0:1}\n    CHARS=${CHARS}\n    CHARS=${CHARS}\n\
    \    CHARS=${CHARS}\n    shift\n  done\n  echo $1 | tr '[A-Z]' '[a-z]' | rev |\
    \ cut -d\" \" -f1 | rev", "    local string=\"$1\"\n    local encrypted=\"\"\n\
    \n    local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \n    # rotate string alphabet by two places\n    alphabet+=\"Z\"\n\n    # append\
    \ new letter after last character in alphabet\n    alphabet+=\"$1\"\n\n    # remove\
    \ first letter\n    alphabet=\"${alphabet:0:1}\"\n\n    for (( i = 0; i < ${#alphabet};\
    \ i++ )); do\n        local letter=\"${alphabet:i:1}\"\n        local shifted=\"\
    ${letter:2:1}\"\n        encrypted+=\"${shifted}\"\n    done\n\n    echo \"$encrypted\"",
  "  alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  shift\n\n  while [ $1 ]; do\n    echo\
    \ ${alphabet:1:2}${1:0:1}${alphabet:2:1}${1:1:1}${alphabet:2:2}${1:2:2}${alphabet:2:3}${1:3:3}${alphabet:2:4}${1:4:4}${alphabet:2:5}${1:5:5}${alphabet:2:6}${1:6:6}${alphabet:2:7}${1:7:7}${alphabet:2:8}${1:8:8}${alphabet:2:9}${1:9:9}${alphabet:2:10}${1:10:10}${alphabet:2:11}${1:11:11}${alphabet:2:12}${1:12:12}${alphabet:2:13}${1:13:13}${alphabet:2:14}${1:14:14}${alphabet:2:15}${1:15:15}${alphabet:2:16}${1:16:16}${alphabet:2:17}${1:17:17}${alphabet:2:18}${1:18:18}${alphabet:2:19}${1:19:19}${alphabet:2:20}${1:20:20}${alphabet:2:21}${1:21:21}${alphabet:2:22}${1:22:22}${alphabet:2:23}${1:23:23}${alphabet:2:24}${1:24:24}${alphabet:2:25}${1:25:25}${alphabet:2:26}${1:26:26}${alphabet:2:27}${1:27:27}${alphabet:2:28}${1:28:28}${alphabet:2:29}${1:29:29}${alphabet:2:30}${1:30:30}${alphabet:2:31}${1:31:31}${alphabet:2:32}${1:32:32}${alphabet:2:33}${1:33:33}${alphabet:2:34}${1:34:34}${alphabet:2:35}${1:35:35}${alphabet:2:36}${1:36:36}${alphabet:2:37}${1:37:37}${alphabet:2:38}${1:38:38}${alphabet:2:39}${1:39:39}${alphabet:2:40}${1:40:40}${alphabet:2:41}${1:41:41}${alphabet:2:42}${1:42:42}${alphabet:",
  "  local str=\"$1\"\n  local strArr=($str)\n  local strLen=${#strArr[@]}\n  local\
    \ x\n  for (( x = 0; x < strLen; x++ )); do\n    strArr[$x]=$(shuf -i \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+[]{};:'\\\
    \"<>,./|\\\\\" -n 1)\n  done\n  local strNew=\"${strArr[*]}\"\n  echo \"${strNew[@]}\"",
  "    local encrypted_string=\"\"\n    # create a variable that holds the number\
    \ of characters in the string\n    local encrypted_string_length=${#1}\n    #\
    \ create the counter\n    local counter=0\n    while [ $counter -lt $encrypted_string_length\
    \ ]\n    do\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_string_length}\n        encrypted_string=${encrypted_string}${encrypted_string_length}\n\
    \        encrypted_string=${encrypted_string}${encrypted_string_length}\n    \
    \    encrypted_string=${encrypted_string}${encrypted_", "    local str=\"$1\"\n\
    \    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local len=${#alphabet}\n\
    \    local shift=2\n    while [[ \"$str\" ]]; do\n        local index=${alphabet:0:(${#alphabet}-1)}\n\
    \        str=${str:0:(${#str}-1)}\n        alphabet=${alphabet:1:(${#alphabet}-1)}\n\
    \        alphabet=${alphabet:0:(${#alphabet}-1)}\n    done\n    local reverse=${alphabet}\n\
    \    local reverselen=${#reverse}\n    while [[ \"$reverse\" ]]; do\n        reverse=${reverse:0:(${#reverse}-1)}\n\
    \        reverselen=${#reverse}\n    done\n    local out=\"\"\n    for (( index=0;\
    \ index<$len; index+=1 )); do\n        local char=${str:index}\n        local\
    \ newchar=${reverse:$reverselen}\n        reverse=${newchar}\n        reverselen-=1\n\
    \        local outchar=${alphabet:$index}\n        out+=$outchar\n    done\n \
    \   return $out", "  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local chars\n\
    \  local ret=\n\n  chars=$(tr '[:upper:]' '[:lower:]' <<< $1)\n  echo \"$chars\"\
    \ | while read -u 9\n  do\n    local ch\n    ch=\"$(($RANDOM % ${#alphabet}))\"\
    \n    echo \"${alphabet:$ch:2}\"\n  done\n  echo \"$ret\"", "    local alphabet=$1\n\
    \    alphabet=$(echo \"$alphabet\" | sed -e 's/\\(.*\\)a/\\1\\1aa/' | sed -e 's/\\\
    (.*\\)e/\\1ee\\1/' | sed -e 's/\\(.*\\)i/\\1i\\1\\e/' | sed -e 's/\\(.*\\)o/\\\
    1o\\1\\i/' | sed -e 's/\\(.*\\)u/\\1u\\1\\o/' | sed -e 's/\\(.*\\)a/\\1aa/' |\
    \ sed -e 's/\\(.*\\)e/\\1ee\\1/' | sed -e 's/\\(.*\\)i/\\1i\\1\\e/' | sed -e 's/\\\
    (.*\\)o/\\1o\\1\\i/' | sed -e 's/\\(.*\\)u/\\1u\\1\\o/' | sed -e 's/\\(.*\\)a/\\\
    1aa/' | sed -e 's/\\(.*\\)e/\\1ee\\1/' | sed -e 's/\\(.*\\)i/\\1i\\1\\e/' | sed\
    \ -e 's/\\(.*\\)o/\\1o\\1\\i/' | sed -e 's/\\(.*\\)u/\\1u\\1\\o/' | sed -e 's/\\\
    (.*\\)a/\\1aa/' | sed -e 's/\\(.*\\)e/\\1ee\\1/' | sed -e 's/\\(.*\\)i/\\1i\\\
    1\\e/' | sed -e 's/\\(.*\\)o/\\1o\\1\\i/' | sed -e 's/\\(.*\\)u/\\1u\\1\\o/' |\
    \ sed -e 's/\\(.*\\)a/\\1aa/' | sed -e 's/\\(.*\\)e/\\1ee\\1/' | sed -e 's/\\\
    (.*\\)i/\\1i\\1\\e/' | sed -e 's/\\(.*\\)o/\\1o\\1\\i/' | sed -e 's/\\(.*\\)u/\\\
    1u\\1\\o/' | sed -e 's/\\(.*\\)a/\\1aa/' | sed -e 's/\\(.*\\)e/\\1ee\\1/' | sed\
    \ -e 's/\\(.*\\)i/\\1i\\1\\e/' | sed -e 's/\\(.*\\)o/\\1o\\1\\i/' | sed -e 's/\\\
    (.*\\)u/\\1u\\1\\o/' | sed -e 's/\\(.*\\)a/\\1aa/' | sed -e '", "  # Get input\
    \ from stdin\n  read -r $1\n\n  # Create an array of the characters in $1 that\
    \ are not in $2\n  not_in_chars=$(echo $1 | tr '[:upper:]' '[:lower:]' | sed 's/./\\\
    \\&/g')\n\n  # For each letter in $1, replace it with $2 and shift all the letters\n\
    \  # over by two places.\n  for letter in $not_in_chars ; do\n    char=\"$2\"\n\
    \    shift 2\n    \n    # Add $char to $1 by replacing it with the letter that\
    \ was shifted\n    # and shift it over by two places.\n    char+=\"${letter}\"\
    \n    echo \"$char\"\n  done", "    local ALPHABET_SIZE=$(echo $1 | cut -c-1)\n\
    \    local ALPHABET=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local OUT=\n    local\
    \ N=\n    local I=\n    local J=0\n    local ROTATION=\n\n    for I in \"${1:0:$ALPHABET_SIZE}\"\
    ; do\n        OUT=$OUT${ALPHABET:$I:1}\n    done\n    for J in $(echo $1 | cut\
    \ -c-2 | sed 's/[0-9][0-9]*//g'); do\n        ROTATION=$ROTATION${ALPHABET:0:$((J+2))}\n\
    \        ROTATION=$ROTATION${ALPHABET:$((J+2))}\n    done\n\n    echo \"$OUT${ROTATION}\"",
  "    echo \"encrypting: $1\"\n    echo $1 | md5sum | awk '{print $1}' | tr '[:upper:]'\
    \ '[:lower:]'", "  local letters=$1\n  local alpha=\"a b c d e f g h i j k l m\
    \ n o p q r s t u v w x y z\"\n  local n=\"${#letters}\"\n  local result=\"\"\n\
    \  local i=0\n  while (( $i < n )) do\n    local char=${letters:i:1}\n    local\
    \ char2=${letters:i:1}\n    local char3=${letters:i:1}\n    local char4=${letters:i:1}\n\
    \    local char5=${letters:i:1}\n    local char6=${letters:i:1}\n    local char7=${letters:i:1}\n\
    \    local char8=${letters:i:1}\n    local char9=${letters:i:1}\n    local char10=${letters:i:1}\n\
    \    local char11=${letters:i:1}\n    local char12=${letters:i:1}\n    local char13=${letters:i:1}\n\
    \    local char14=${letters:i:1}\n    local char15=${letters:i:1}\n    local char16=${letters:i:1}\n\
    \    local char17=${letters:i:1}\n    local char18=${letters:i:1}\n    local char19=${letters:i:1}\n\
    \    local char20=${letters:i:1}\n    local char21=${letters:i:1}\n    local char22=${letters:i:1}\n\
    \    local char23=${letters:i:1}\n    local char24=${letters:i:1}\n    local char25=${letters:i:1}\n\
    \    local char26=${letters:i:1}\n    local char27=${letters:i:1}\n    local char28=${letters:i:1}\n\
    \    local char29=${letters:i:1}\n    local char30=${letters:i:1}\n    local char31=${letters:i:1}\n\
    \    local char32=${letters:i:1}\n    local char33=${letters:i:1}\n    local char34=${letters:i:1}\n\
    \    local char35=${letters:i:1}\n    local char36=${letters:i:1}\n    local char37=${letters:i:1}\n\
    \    local char38=${letters:i:1}\n    local char39=${letters:i:1}\n    local char40=${letters:i:1}\n\
    \    local char41=${letters:i:1}\n    local char42=${letters:i:1}\n    local char43=${letters:i:1}\n\
    \    local char44=${letters:i:1}\n    local char45=${letters:", "  local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local input=\"$1\"\n  local output\n\n  output=\"\
    ${input}\" # Copy the input\n  local count\n  \n  for c in \"${alphabet}\"; do\n\
    \    ((count=$((${#input} - 1))))\n    case \"$input\" in\n      \"$c\") echo\
    \ \"$output\" | sed \"s/${c}/${c}a${c}/g\";;\n      \"${c}a\") echo \"$output\"\
    \ | sed \"s/${c}/${c}b${c}/g\";;\n      \"${c}b\") echo \"$output\" | sed \"s/${c}/${c}c${c}/g\"\
    ;;\n      \"${c}c\") echo \"$output\" | sed \"s/${c}/${c}d${c}/g\";;\n      \"\
    ${c}d\") echo \"$output\" | sed \"s/${c}/${c}e${c}/g\";;\n      \"${c}e\") echo\
    \ \"$output\" | sed \"s/${c}/${c}f${c}/g\";;\n      \"${c}f\") echo \"$output\"\
    \ | sed \"s/${c}/${c}g${c}/g\";;\n      \"${c}g\") echo \"$output\" | sed \"s/${c}/${c}h${c}/g\"\
    ;;\n      \"${c}h\") echo \"$output\" | sed \"s/${c}/${c}i${c}/g\";;\n      \"\
    ${c}i\") echo \"$output\" | sed \"s/${c}/${c}j${c}/g\";;\n      \"${c}j\") echo\
    \ \"$output\" | sed \"s/${c}/${c}k${c}/g\";;\n      \"${c}k\") echo \"$output\"\
    \ | sed \"s/${c}/${c}l${c}/g\";;\n      \"${c}l\") echo \"$output\" | sed \"s/${c}/${c}m${c}/g\"\
    ;;\n      \"${c}m\") echo \"$output\" | sed \"s/${c}/${c}n${c}/g\";;\n      \"\
    ${c}n\") echo \"$output\" | sed \"s/${c}/${c}o${c}/g\";;\n      \"${c}o\") echo\
    \ \"$output\" | sed \"s/${c}/${c}p${c}/g\";;\n      \"${c}p\") echo \"$output\"\
    \ | sed \"s/${c}/${c}q${c}/g\";;\n      \"${c", "    local string=\"$1\"\n   \
    \ local shift=2\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local\
    \ alphabet2=\"${alphabet}2\"\n    local encrypted=\"\"\n\n    # Loop through the\
    \ string character by character and add them to\n    # the encrypted string\n\
    \    for (( i=0; i < ${#string}; i++ )); do\n        encrypted+=\"${alphabet2[$((\
    \ ${#string} - i - 1 )) + ( ${i} % ${#alphabet2} )]}\"\n    done\n\n    # Return\
    \ the encrypted string\n    echo $encrypted", "    local string=$1\n    local\
    \ alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet2=\"nopqrstuvwxyzabcdefghijklm\"\
    \n    local alphabet3=\"vwxyzabcdefghijklmnopqrstuv\"\n    local alphabet4=\"\
    uvwxyzabcdefghijklmnopqrst\"\n    local alphabet5=\"wxyzabcdefghijklmnopqrstuv\"\
    \n    local alphabet6=\"xyzabcdefghijklmnopqrstuv\"\n    local alphabet7=\"zabcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet8=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet9=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet10=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet11=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet12=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet13=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet14=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet15=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet16=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet17=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet18=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet19=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet20=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet21=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet22=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet23=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet24=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet25=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet26=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet27=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet28=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet", "\t\
    local str=$1\n\tlocal alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tlocal temp=\"\"\n\tlocal i=0\n\tlocal j=0\n\tlocal output=\"\"\n\n\t# Add\
    \ the first letter in the alphabet to output\n\toutput=\"${alphabet:0:1}${output}\"\
    \n\n\t# Get the rest of the letters\n\twhile [ $i -lt ${#str} ]; do\n\t\t# Increment\
    \ our index\n\t\t(( i=i+1 ))\n\t\t# Get the current letter\n\t\ttemp=\"${str:$i:1}\"\
    \n\n\t\t# Shift the letters down by 2\n\t\t(( j=j+2 ))\n\n\t\t# Add our letter\
    \ to the output\n\t\toutput=\"${alphabet:$j:1}${output}\"\n\tdone\n\n\t# Add the\
    \ final letter to the output\n\toutput=\"${output}${alphabet:$i:1}\"\n\techo \"\
    ${output}\"", "    # Alphabet that we will use to encrypt the string\n    alpha=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    # Initializations\n    encrypted=\"\"\n    alpha_count=0\n\
    \    # Step through each character in string\n    for c in $1\n    do\n      #\
    \ Increment the alpha_count\n      alpha_count=$((alpha_count+2))\n      # Convert\
    \ the character into its position \n      # in the alphabet\n      pos=$(echo\
    \ $alpha | sed 's/./&/'$alpha_count'/g')\n      # Add the character to the encrypted\
    \ string\n      encrypted=$(echo $encrypted $pos)\n    done\n    # Echo the encrypted\
    \ string\n    echo \"$encrypted\"", "  local alphabet=\"$2\"\n  echo \"$(cat $1)\"\
    \ | sed -e \"s/./$(echo $alphabet|sed -e \"s/.{2,}//g\")/\" | tr \"$(echo $alphabet|sed\
    \ -e \"s/.{2,}//g\")\" \"$alphabet\"", "  # The variable alphabet has 26 letters.\n\
    \  alphabet=abcdefghijklmnopqrstuvwxyz\n  # Initialize a variable called ciphertext\
    \ to an empty string.\n  ciphertext=''\n\n  # Loop through the string character\
    \ by character, and append\n  # the encrypted character to the ciphertext string.\n\
    \  for (( i = 1; i <= ${#1}; i++ ))\n  do\n    # Get the character at position\
    \ $i of the string.\n    character=${1:$i:1}\n\n    # The character at the current\
    \ position is being added to ciphertext.\n    ciphertext=${ciphertext}${alphabet:$((i+2)):1}\n\
    \  done\n\n  # Print the encrypted string to the console.\n  echo $ciphertext",
  "  local string=$1\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local index=0\n\
    \  local rotated_alphabet=\n\n  # rotate every letter in alphabet by two places\n\
    \  while [[ ${alphabet:0:1} != \"z\" ]]; do\n    ((index++))\n    rotated_alphabet=\"\
    ${rotated_alphabet}${alphabet:0:1}${alphabet:1:1}\"\n    alphabet=\"${alphabet:1:1}${alphabet:2:1}\"\
    \n  done\n\n  # rotate string by two places\n  while [[ ${string:0:1} != \"z\"\
    \ ]]; do\n    ((index++))\n    rotated_string=\"${rotated_string}${string:0:1}${string:1:1}\"\
    \n    string=\"${string:1:1}${string:2:1}\"\n  done\n\n  # shift rotated alphabet\
    \ down by two places to account for shifts\n  # in alphabet due to letter rotations\n\
    \  index=0\n  while [[ ${rotated_alphabet:0:1} != \"z\" ]]; do\n    ((index++))\n\
    \    rotated_alphabet=\"${rotated_alphabet}${rotated_alphabet:0:1}${rotated_alphabet:1:1}\"\
    \n  done\n\n  # shift rotated string down by two places to account for shifts\n\
    \  # in string due to letter rotations\n  index=0\n  while [[ ${rotated_string:0:1}\
    \ != \"z\" ]]; do\n    ((index++))\n    rotated_string=\"${rotated_string}${rotated_string:0:1}${rotated_string:1:1}\"\
    \n  done\n\n  # return rotated string\n  echo \"${rotated_string}${rotated_alphabet}\"",
  "    local str=\"$1\"\n\n    local c=\"\"\n    local i=$1\n    while [ \"$i\" -gt\
    \ \"0\" ]; do\n        c=\"${c}${c}${i%26}\"\n        i=\"${i/26}\"\n    done\n\
    \n    echo \"$c\"", "  local -i i\n  local alphabet\n  \n  alphabet=( $(printf\
    \ \"abcdefghijklmnopqrstuvwxyz\" ) )\n  for i in {2..${#1}}; do\n    # Increment\
    \ the alphabet by 2 to encrypt the string.\n    alphabet+=( $(printf \"i%s\" ${alphabet[i\
    \ - 1]} ) )\n  done\n  \n  # Return the rotated string.\n  printf \"%s\" \"${alphabet[*]}\"\
    \ | tr -d '\\n'", "   local rot=$(( $RANDOM % 4 ))\n   local c=\"\"\n   for ((\
    \ i=0; i<${#1}; i++ )); do\n      ((c++))\n      local a=$(printf \"%c\" \"$i\"\
    )\n      local b=${a:$rot:1}\n      local c=${a:$(( $i - $rot ))}\n      echo\
    \ \"$c$b\"\n   done", "  local alphabet=\"$(echo \"$1\" | sed -E 's/([a-z])/\\\
    1\\2/g')\"\n  local encrypted=\"\"\n  local i\n  for i in \"${alphabet}\"; do\n\
    \    encrypted=\"${encrypted}$(i)\"\n  done\n  echo \"$encrypted\"", "  local\
    \ tmp=${1//?} #removes any chars beginning with a question mark \n  local tmp=${tmp,,}\
    \ #removes any chars ending with a comma\n  tmp=${tmp^^} #removes any chars beginning\
    \ with a question mark\n  local tmp=${tmp,,} #removes any chars ending with a\
    \ comma\n  local tmp=${tmp%%??} #removes any chars beginning with a question mark\n\
    \  local tmp=${tmp%%,*} #removes any chars ending with a comma\n  local tmp=${tmp:0:1}\
    \ #removes any chars beginning with comma\n  local tmp=${tmp:1}\n  local tmp=${tmp:1:2}\
    \ #removes any chars beginning with comma\n  local tmp=${tmp:2:1} #removes any\
    \ chars beginning with comma\n  local tmp=${tmp:2:2} #removes any chars beginning\
    \ with comma\n  local tmp=${tmp:2:3} #removes any chars beginning with comma\n\
    \  local tmp=${tmp:2:4} #removes any chars beginning with comma\n  local tmp=${tmp:2:5}\
    \ #removes any chars beginning with comma\n  local tmp=${tmp:2:6} #removes any\
    \ chars beginning with comma\n  local tmp=${tmp:2:7} #removes any chars beginning\
    \ with comma\n  local tmp=${tmp:2:8} #removes any chars beginning with comma\n\
    \  local tmp=${tmp:2:9} #removes any chars beginning with comma\n  local tmp=${tmp:2:10}\
    \ #removes any chars beginning with comma\n  local tmp=${tmp:2:11} #removes any\
    \ chars beginning with comma\n  local tmp=${tmp:2:12} #removes any chars beginning\
    \ with comma\n  local tmp=${tmp:2:13} #removes any chars beginning with comma\n\
    \  local tmp=${tmp:2:14} #removes any chars beginning with comma\n  local tmp=${tmp:2:15}\
    \ #removes any chars beginning with comma\n  local tmp=${tmp:2:16} #removes any\
    \ chars beginning with comma\n  local tmp=${tmp:2:17} #removes any chars beginning\
    \ with comma\n  local tmp=${tmp:2:18} #removes any chars beginning with comma\n\
    \  local tmp=${tmp:2:19} #removes any chars beginning with comma\n  ", "    local\
    \ encrypted_string=\"$1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n\
    \    local number_of_characters=${#encrypted_string}\n    local number_of_rotations=\"\
    10\"\n    # Rotate the encrypted string two times\n    # each time shifting the\
    \ character down by 2 \n    # multiplied by 2 shifted down by one to account for\
    \ the \n    # alphabet being rotated two times\n    local encrypted_rotated=\"\
    $(encrypt \"$encrypted_string\" \"${alphabet}\" \"${number_of_characters}\" \"\
    ${number_of_rotations}\")\"\n\n    # Return the encrypted string\n    echo \"\
    $encrypted_rotated\"", "  local encrypted_string\n  # Encrypt string with rotated\
    \ alphabet\n  local alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x\
    \ y z)\n  local rotate_alphabet=(x y z A B C D E F G H I J K L M N O P Q R S T\
    \ U V W X Y Z)\n  local i=${#alphabet[@]}\n  local j=0\n  local jstr=\"\"\n  local\
    \ jidx=0\n  local k=1\n  local output\n\n  while [ $k -le $i ]\n  do\n    j=$((\
    \ k + 2 ))\n    jstr=$jstr$(( j - 1 ))\n    encrypted_string=$encrypted_string$((\
    \ alphabet[ $j - 2 ] ))\n    jidx=$(( k - 1 ))\n    alphabet[ $j - 2 ]=$rotate_alphabet[\
    \ $jidx ]\n    k=$(( k + 1 ))\n  done\n  output=$encrypted_string", " local string=\"\
    $1\"\n local alphabet=abcdefghijklmnopqrstuvwxyz\n for (( i=1; i<${#alphabet};\
    \ i++ )); do\n  string=\"${alphabet:$i:2}${string}\"\n done\n echo ${string:0:1}",
  "  local string=$1\n  local alphabet=abcdefghijklmnopqrstuvwxyz\n  local result=\"\
    \"\n  local i\n  local k\n  \n  # shift the alphabet down by two each time\n \
    \ for (( i=0; i<${#alphabet[@]}; i=i+2 )); do\n    k=$(echo $alphabet | sed -n\
    \ -e \"s/${alphabet[$i]}/${alphabet[$((i+1))]}/g\")\n    result+=\"${k}\"\n  done\n\
    \  \n  # shift the string down by two each time\n  for (( i=0; i<${#string}; i=i+2\
    \ )); do\n    k=$(echo $string | sed -n -e \"s/${string[$i]}/${string[$((i+1))]}/g\"\
    )\n    result+=\"${k}\"\n  done\n  \n  echo \"$result\"", "  local str=\"$1\"\n\
    \  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local newStr=\"\"\n  for ((\
    \ i=0; i < ${#str}; i++ )); do\n    local letter=${str:$i:1}\n    local i=$((${#alphabet}\
    \ + ${letter} + 1))\n    local j=$((${#alphabet} - ${#alphabet} % ${#letter}))\n\
    \    newStr+=\"${alphabet:$j:1}\"\n  done\n  echo $newStr", "    local string=\"\
    $1\"\n    local shift=\"1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local result=\"\"\n    while [[ \"$string\" != \"\" ]]; do\n        local\
    \ index=$(echo $alphabet|sed 's/\\(.*\\)a/\\1/g')\n        local value=$(echo\
    \ $alphabet|sed 's/\\(.*\\)b/\\1/g')\n        local newValue=$(echo $alphabet|sed\
    \ 's/\\(.*\\)c/\\1/g')\n        local newIndex=$(echo $alphabet|sed 's/\\(.*\\\
    )d/\\1/g')\n        local newShift=$(echo $alphabet|sed 's/\\(.*\\)e/\\1/g')\n\
    \        local newAlphabet=$(echo $alphabet|sed 's/\\(.*\\)f/\\1/g')\n       \
    \ local newString=\"\"\n        local i=0\n        \n        while [ \"$i\" -lt\
    \ \"$index\" ];\n        do\n            i=$(( i + $shift ))\n        done\n\n\
    \        while [ \"$i\" -ge \"0\" ];\n        do\n            newString=$newString$newValue\n\
    \            i=$(( i - $shift ))\n        done\n\n        result=$result$newString\n\
    \        string=$(echo $string|sed 's/\\(.*\\)a/\\1/g')\n        string=$(echo\
    \ $string|sed 's/\\(.*\\)b/\\1/g')\n        string=$(echo $string|sed 's/\\(.*\\\
    )c/\\1/g')\n        string=$(echo $string|sed 's/\\(.*\\)d/\\1/g')\n        string=$(echo\
    \ $string|sed 's/\\(.*\\)e/\\1/g')\n        string=$(echo $string|sed 's/\\(.*\\\
    )f/\\1/g')\n    done\n\n    echo $result", "    local LETTERS=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local ROTATIONS=\"bdefghijmnopqtuvwxyz\"\n    local ENCRYPTED\n    local\
    \ LETTER_INDEX\n    local ROTATION_INDEX\n    local STRING_INDEX\n\n    STRING_INDEX=$1\n\
    \    ROTATION_INDEX=$(( $STRING_INDEX / 2 ))\n    LETTER_INDEX=$(( $ROTATION_INDEX\
    \ * 2 ))\n    ENCRYPTED=\"${LETTERS}${ROTATIONS}${LETTERS:0:$LETTER_INDEX}${ROTATIONS:$LETTER_INDEX:1}\"\
    \n\n    echo $ENCRYPTED", "    local letters=\"$1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local letters_rotate=\"${alphabet:2:${#alphabet}:2}${alphabet:1:${#alphabet}:1}${alphabet:0:${#alphabet}:1}\"\
    \n    echo -n \"$1\" | sed -e 's/^.\\(.*\\)/\\1/g' -e 's/.*/'\"$letters_rotate\"\
    '/' | sed -e 's/.*/'\"$letters_rotate\"'/g'", "    local string=$1\n    local\
    \ alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local\
    \ length=${#alphabet}\n    local count=0\n    local character=\"\"\n    local\
    \ result=\"\"\n\n    for (( count = 0; count < length; count++ )); do\n      \
    \  character=${string:$count:1}\n        result=${result:$count:$count}${alphabet:$((character+1)):1}\n\
    \    done\n\n    echo $result", "    local str=\"$1\"\n    # Find the length of\
    \ the string\n    local len=${#str}\n    # Initialize a counter\n    local count=1\n\
    \    # Loop through the string, one letter at a time\n    while [[ $count -le\
    \ $len ]]; do\n        # Shift the letter down by two places\n        local letter=${str:$((count-1))}\n\
    \        local letter2=${letter:0:2}\n        echo \"$letter2${letter:2}\"\n \
    \       # Increment the counter\n        ((count++))\n    done", "    # Encode\
    \ $1 with ord() to get the ASCII code of each letter in $1\n    letters=$(echo\
    \ \"$1\" | iconv -f utf-8 -t ascii//transliterate)\n    size=$(echo \"$1\" | wc\
    \ -c)\n    # Iterate over each letter in $letters using a for loop.\n    for ((i=1;\
    \ i<$size; i++))\n    do\n        char=$(echo \"$letters\" | cut -c $i)\n    \
    \    # If char is in the alphabet, \n        if [[ \"$char\" == @*@* ]]\n    \
    \    then\n            # add char to the end of the alphabet\n            alphabet+=${alphabet[$((i-1))]}\n\
    \            # shift alphabet to remove char from the beginning of alphabet\n\
    \            alphabet+=${alphabet[$((i-2))]}\n        else\n            # add\
    \ the letter to the beginning of the alphabet\n            alphabet+=${alphabet[$((i-1))]}\n\
    \        fi\n    done\n    echo \"${alphabet[@]}\"", "  local string=$1\n  local\
    \ alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local encrypted=\"\"\n\n  for i in\
    \ $(seq 0 ${#alphabet}); do\n    encrypted=\"${encrypted}${alphabet:$i:2}${alphabet:0:$i}\"\
    \n  done\n\n  echo \"$encrypted\"", "        local alphabet=\"$(echo $1 | sed\
    \ 's/[^a-zA-Z0-9]//g')\"\n        local result=\"\"\n        local i\n       \
    \ for i in \"${alphabet}\"; do\n                local j=\"${alphabet}\"\n    \
    \            ((j+=1))\n                if [[ \"$i\" == \"$j\" ]]; then\n     \
    \                   continue\n                fi\n                if [[ ${alphabet:((${#j}-1)):1}\
    \ == \"$i\" ]]; then\n                        result=\"$result$j\"\n         \
    \               alphabet=\"$(echo $j | sed 's/[^a-zA-Z0-9]//g')\"\n          \
    \              continue\n                fi\n                result=\"$result$i\"\
    \n        done\n        echo \"$result\"", "  # Get all the characters in the\
    \ string\n  alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  string=\"$1\"\n  # Create\
    \ an array of the characters in the string\n  arr=(${string//[$'\\t\\r\\n']//})\n\
    \  # Create an array of the alphabet characters in the string\n  arr2=(${alphabet//[$'\\\
    t\\r\\n']//})\n  # Loop through each character in the string\n  for ((i=0;i<${#arr[@]};++i));\
    \ do\n    arr2[$((i%${#arr2[@]}))]=${arr2[$((i%${#arr2[@]}))]}\n  done\n  # Loop\
    \ through each character in the string\n  for ((i=0;i<${#arr[@]};++i)); do\n \
    \   arr[$((i%${#arr[@]}))]=${arr[$((i%${#arr[@]}))]}\n  done\n  # Return the string\
    \ with the characters rotated the right way\n  printf \"%s\" \"${arr2[*]}\"",
  "  local chars=(\n    \"b\" \"e\" \"c\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\"\
    \ \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\"\
    \ \"z\"\n  )\n  local shift=4\n  local input=$1\n  local output=\"\"\n  \n  for\
    \ char in $input; do\n    local i=0\n    while [ \"$i\" -lt \"$shift\" ]; do\n\
    \      if [ $i -eq \"$shift\" ]; then\n        shift\n      fi\n      output+=$chars[$((\
    \ $chars[$i]+$shift ))]\n      i=$(( i+1 ))\n    done\n  done\n  \n  echo $output",
  "  local string=$1\n  local alphabet=$2\n  local count=0\n  local lastchar\n  local\
    \ result\n  \n  # First rotate all characters of the string by the count (which\
    \ \n  # is incremented by 2 each time)\n  for char in $string; do\n    lastchar=$char\n\
    \    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \  \n  done\n  \n  # Now shift the rotated string to the start of the string\n\
    \  for index in $( seq 0 0 ); do\n    count=$((count+2))\n    char=${alphabet:$count:2}\n\
    \    lastchar=${alphabet:$count:2}\n    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n\
    \    lastchar=${alphabet:$count:2}\n    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n\
    \    lastchar=${alphabet:$count:2}\n    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n\
    \    lastchar=${alphabet:$count:2}\n    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n\
    \    lastchar=${alphabet:$count:2}\n  \n  done\n  \n  # Now concatenate the rotated\
    \ string with the rest of the string\n  result=$string\n  \n  for char in $string;\
    \ do\n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n    lastchar=${alphabet:$count:2}\n\
    \    \n    char=${alphabet:$count:2}\n    count=$((count+2))\n", "  # Convert\
    \ the string to an array of chars\n  mapfile -t chars < <(printf '%s\\n' \"$1\"\
    )\n\n  # Create a counter variable initialized to 1\n  declare -i counter=1\n\
    \  # Create an empty string to store encrypted characters\n  declare -i encrypted=\"\
    \"\n\n  # Loop through each character in the string\n  for char in \"${chars[@]}\"\
    ; do\n    # Convert each character in the string to uppercase\n    char=\"$(tr\
    \ '[:upper:]' '[:lower:]' <<< \"$char\")\"\n    # Append the character to the\
    \ encrypted string\n    encrypted+=\"${char:0:1}${char:1:2}${char:2:2}${char:3:2}${char:4:2}\"\
    \n    # Increment the counter by 2\n    i=$((i + 2))\n    # If the counter exceeds\
    \ $i, then increase the counter and \n    # re-append the character\n    if [[\
    \ $i -ge ${#chars[@]} ]]; then\n      i=$((1))\n      encrypted+=\"${char:0:1}${char:1:2}${char:2:2}${char:3:2}${char:4:2}\"\
    \n    fi\n  done\n\n  # Return the encrypted string\n  echo \"$encrypted\"", " \
    \       local encrypted_string=$1\n        local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet=\"123456\"\n        local alphabet2=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet2=\"7890\"\n        local num_alphabet3=\"123456789\"\
    \n        local num_alphabet4=\"0123456789\"\n        local num_alphabet5=\"012345\"\
    \n        local num_alphabet6=\"0987654321\"\n        local num_alphabet7=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet8=\"1234567890123\"\n        local num_alphabet9=\"\
    0123456789\"\n        local num_alphabet10=\"0123456789\"\n        local num_alphabet11=\"\
    0123456789\"\n        local num_alphabet12=\"0123456789\"\n        local num_alphabet13=\"\
    1234567890123\"\n        local num_alphabet14=\"abcdefghijklmnopqrstuvwxyz\"\n\
    \        local num_alphabet15=\"123456789\"\n        local num_alphabet16=\"123456789\"\
    \n        local num_alphabet17=\"987654321\"\n        local num_alphabet18=\"\
    987654321\"\n        local num_alphabet19=\"987654321\"\n        local num_alphabet20=\"\
    abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet21=\"123456789\"\n   \
    \     local num_alphabet22=\"abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet23=\"\
    123456789\"\n        local num_alphabet24=\"abcdefghijklmnopqrstuvwxyz\"\n   \
    \     local num_alphabet25=\"abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet26=\"\
    abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet27=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet28=\"abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet29=\"\
    abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet30=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet31=\"abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet32=\"\
    abcdefghijklmnopqrstuvwxyz\"\n        local num_alphabet33=\"abcdefghijklmnopqrstuvwxyz\"\
    \n        local num_alphabet34=\"abcdefghijklmnopqrstuvw", "  local s=$1\n  local\
    \ alphabet=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n  local output=\"\
    \"\n  for ((i = 0; i < ${#s}; i++))\n  do\n    output=$output${alphabet[$((${#alphabet}-1+${i})%${#alphabet}))]}\n\
    \  done\n  echo \"$output\"", "  local string=\"$1\"\n  local new=\"\"\n  for\
    \ ((i=0; i<${#string}; i++)); do\n    new=\"${new}${ROTATION[$((${#string}-1)-$i)]}${string:$i:1}\"\
    \n  done\n  echo \"$new\"", "    local input=$1\n    local output=\"\"\n    local\
    \ index=0\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    \n    for ((\
    \ index=0; index<$#; index++ )); do\n        local letter=$((index%26))\n    \
    \    local letter_index=$((index/26))\n    \n        local rotation=$((letter_index*2+1))\n\
    \        if [ \"$letter\" -eq \"$letter_index\" ]; then\n            rotation=$((rotation-2))\n\
    \        fi\n    \n        local letter_to_add=\"\"\n    \n        for (( rot=0;\
    \ rot<$rotation; rot++ )); do\n            letter_to_add=${alphabet:$((alphabet.len-1)-rot):1}\n\
    \        done\n    \n        local letter_index=$((letter_index+1))\n    \n  \
    \      output=${output}${output}${letter}${letter_to_add}\n    done\n    \n  \
    \  echo \"$output\"", "    local str=\"$1\"\n    local newstr=\"\"\n    local\
    \ newchar=\"\"\n    local n\n    for (( n=0; n < ${#str}; n++ )); do\n       \
    \ newchar=$(echo $((${#str}-n+${n})%${#str}))\n        newstr=\"$newstr${newchar}\"\
    \n    done\n    echo \"$newstr\"", "  local string=\"$1\"\n  local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local length=\"${#string}\"\n  local result\n\n\
    \  result=''\n  for (( i=0; i<${#alphabet}; i++ )); do\n    case \"$string\" in\n\
    \      ${alphabet:$i:2}* )\n        result=\"${result:${alphabet:$((i+2)):1}}\"\
    \n        shift 2\n        ;;\n    esac\n  done\n\n  echo \"$result\"", "  local\
    \ alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local alphabet2=\"opqrstuvwxyzabcdefghijklmnop\"\
    \n  local alphabet3=\"opqrstuvwxyzabcdefghijklmnopqrst\"\n  local letters=\"$(echo\
    \ $1 | sed -E \"s/[a-z]//g\")\"\n  local chars=\"$(echo $letters | sed -E \"s/[A-Z]//g\"\
    )\"\n  local letters_rotated=\"$(echo $chars | sed -E \"s/[A-Za-z]//g\")\"\n \
    \ local letters_rotated_length=\"${#letters_rotated}\"\n  local encrypted=\"\"\
    \n\n  for (( i=0; i<$letters_rotated_length; i++ )); do\n    encrypted=\"${encrypted}$((\
    \ ${alphabet2[$letters_rotated[$i]%${#alphabet2}]} ))\"\n  done\n\n  echo \"$encrypted\"",
  "  # Convert to uppercase and remove any spaces to ensure a letter \n  # appears\
    \ twice\n  alphabet=$(echo $1 | tr '[:upper:]' '[:lower:]')\n  alphabet=${alphabet//\
    \ /}\n  alphabet=${alphabet//\\ #}\n  echo $alphabet\n  \n  # Rotate each letter\n\
    \  for (( i=1; i<$2; i++ )); do\n    letter=${alphabet:i:1}\n    alphabet=${alphabet:1:1}\n\
    \    alphabet=${alphabet:0:1}\n    alphabet=${letter}${alphabet}\n  done\n\n \
    \ echo $alphabet", "    local STRING=\"$1\"\n    local CHAR_STRING=\"${STRING:\
    \ -1}\"\n    local ROTATE=\"$(\n        echo \"${CHAR_STRING}\"\n        | awk\
    \ '{printf \"%.2s%.2s\\n\", $1, $2}'\n        | awk '{print substr($0,length($0)-1)}'\n\
    \        | sed 's/$/p/' \n    )\"\n\n    local LETTERS=\"$(\n        echo \"${ROTATE}\"\
    \n        | awk '{for (i=2;i<length($0);i++) {printf \"%.2s%.2s\\n\", substr($0,i,1),\
    \ substr($0,i,2)}}'\n    )\"\n\n    echo \"${LETTERS}\" | awk '{for (i=1; i<length($0);\
    \ i++) {printf \"%.2s%.2s\\n\", substr($0,i,1), substr($0,i,2)}}'", "    local\
    \ string=\"$1\"\n    local alphabet=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n\
    \    local size=${#alphabet}\n    local i=0\n    local new_str=\"\"\n    for char\
    \ in $string; do\n        new_str+=\"${alphabet:((i%size)+2)}\"\n        ((i=i+1))\n\
    \    done\n    echo $new_str", "  local letters=\"${1}\"\n  local alphabet=\"\
    ${letters}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local new_letters=\"\
    \"\n  local new_alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local i=${#letters}\n  while [ $i -gt 0 ]; do\n    local c=\"${letters:$i:1}\"\
    \n    local e=\"${alphabet:$(( $i - 2 )):1}\"\n    local d=\"${alphabet:$(( $i\
    \ + 2 )):1}\"\n    local letters=\"${letters:0:$i}${e}${c}${d}\"\n    i=$(( $i\
    \ - 1 ))\n  done\n  echo $new_letters", "    local str=\"$1\"\n    local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local n=$((${#str} + 1))\n    local result=\"\
    \"\n    local shift=2\n    local j=0\n\n    for ((i=0; i<${#str}; i++)); do\n\
    \        local tmp=${str:$i:1}\n        local idx=$((${alphabet}${str}:$i+1))\n\
    \        local c=${alphabet:$idx:1}\n        result=\"${result}${c}\"\n    done\n\
    \    echo \"$result\"", "    # Check to see if alphabet is rotated or already\
    \ in correct order.\n    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    length=${#1}\n\
    \    letter=$1\n\n    # Check to see if alphabet contains the letter given and\
    \ rotate the letter to correct position.\n    if [[ $alphabet =~ ^${alphabet:$((length+1))}$\
    \ ]]\n    then\n        letter=${alphabet:$((length+1))}\n    fi\n\n    echo $letter",
  "  local alphabet=\"$(rot $1 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\"\
    )\"\n  echo \"${alphabet:2:${#alphabet}:2}\"", "  local string=$1\n  local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local alphabet2=\"cdefghijklmnopqrstuvwxyzab\"\
    \n  local index=0\n  local output=\"\"\n  local count=0\n  \n  while [[ $(echo\
    \ ${string} | grep ${alphabet:$((${#alphabet}-2))}:${#alphabet}:${#alphabet})\
    \ > 0 ]]; do\n    count=$((${count}+1))\n    index=$((${index}+2))\n    alphabet=${alphabet:$((${#alphabet}-2))}\n\
    \  done\n  \n  while [[ $(echo ${string} | grep ${alphabet2:$((${#alphabet}-2))}:${#alphabet}:${#alphabet})\
    \ > 0 ]]; do\n    count=$((${count}+1))\n    index=$((${index}+2))\n    alphabet2=${alphabet2:$((${#alphabet}-2))}\n\
    \  done\n  \n  if [[ $count -gt 0 ]]; then\n    for ((i=0;i<$count;i++))\n   \
    \ do\n      output=${output:${alphabet:$((${#alphabet}-1))}:${alphabet:$((${#alphabet}-2)):1}:1}\n\
    \    done\n  fi\n  \n  if [[ $count -gt 0 ]]; then\n    for ((i=0;i<$count;i++))\n\
    \    do\n      output=${output:${alphabet2:$((${#alphabet2}-1))}:${alphabet2:$((${#alphabet2}-2)):1}:1}\n\
    \    done\n  fi\n  \n  if [[ $count -gt 0 ]]; then\n    for ((i=0;i<$count;i++))\n\
    \    do\n      output=${output:${alphabet:0:$((${#alphabet}-2))}:${alphabet:0:$((${#alphabet}-1)):1:1}\n\
    \    done\n  fi\n  \n  if [[ $count -gt 0 ]]; then\n    for ((i=0;i<$count;i++))\n\
    \    do\n      output=${output:${alphabet2:0:$((${#alphabet2}-2))}:${alphabet2:0:$((${#alphabet2}-1)):1:1}\n\
    \    done\n  fi\n  \n  echo $output", "  local string=$1\n  local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local key=\"0123456789\"\n  local result=''\n\
    \  local i=${#string}\n  local j=0\n  for i in ${alphabet}; do\n    local j=$((j+2))\n\
    \    local char=\"${string}\"\n    local letter=\"${char:j}\"\n    result=\"${result}${letter:1}\"\
    \n  done\n  echo \"$result\"", "  local string=\"$1\"\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  local result=\"\"\n  local i\n  for i in \"${alphabet}\"; do\n    result=\"\
    ${result}${string:i:2}\"\n  done\n  echo \"${result}\"", "  local string=\"$1\"\
    \n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local encrypted=\"\"\n  local\
    \ c\n\n  local i=0\n  local j=0\n  for c in \"${string}\"; do\n    (( i+=2 ))\n\
    \    (( j+=2 ))\n    (( c=${alphabet:$i:$j} ))\n    (( encrypted+=$c ))\n  done\n\
    \n  echo \"$encrypted\"", "  local string=\"$1\"\n  local alphabet=\"$2\"\n  local\
    \ length=${#alphabet}\n  local encrypted=\"\"\n  local index=0\n\n  while [ $index\
    \ -lt $length ]; do\n    encrypted=${encrypted}${alphabet:$index:2}\n    index=$(($index+2))\n\
    \  done\n  encrypted=${encrypted}${alphabet:$index:1}\n  echo \"$encrypted\"",
  "    echo \"$1\" | sed -e 's/./&\\12/g' | awk '{print substr($0,0,2)substr($0,1,2)substr($0,2,2)substr($0,4,2)substr($0,6,2)substr($0,8,2)substr($0,10,2)substr($0,12,2)substr($0,14,2)substr($0,16,2)substr($0,18,2)substr($0,20,2)substr($0,22,2)substr($0,24,2)substr($0,26,2)substr($0,28,2)substr($0,30,2)substr($0,32,2)substr($0,34,2)substr($0,36,2)substr($0,38,2)substr($0,40,2)substr($0,42,2)substr($0,44,2)substr($0,46,2)substr($0,48,2)substr($0,50,2)substr($0,52,2)substr($0,54,2)substr($0,56,2)substr($0,58,2)substr($0,60,2)substr($0,62,2)substr($0,64,2)substr($0,66,2)substr($0,68,2)substr($0,70,2)substr($0,72,2)substr($0,74,2)substr($0,76,2)substr($0,78,2)substr($0,80,2)substr($0,82,2)substr($0,84,2)substr($0,86,2)substr($0,88,2)substr($0,90,2)substr($0,92,2)substr($0,94,2)substr($0,96,2)substr($0,98,2)substr($0,100,2)substr($0,102,2)substr($0,104,2)substr($0,106,2)substr($0,108,2)substr($0,110,2)substr($0,112,2)substr($0,114,2)substr($0,116,2)substr($0,118,2)substr($0,120,2)substr($0,122,2)substr($0,124,2)substr($0,126,2)substr($0,128,2)substr($0,130,2)substr($0,132,2)substr($0,134,2)substr($0,136,2)substr($0,138,2)substr($0,140,2)substr($0,142,2)substr($0,144,2)substr($0,146,2)substr($0,148,2)substr($0,150,2)substr($0,152,2)substr($0,154,2)substr($0,156,2)substr($0,158,2)substr($0,160,2)substr($0,162,2)substr($0,164,2)substr($0,166,2)substr($0,168,2)substr($0,170,2)substr($0,",
  "  local string=\"$1\"\n  local alphabet='abcdefghijklmnopqrstuvwxyz'\n  local count\n\
    \  local key\n  \n  # Create a variable called key that contains the key we want.\n\
    \  key=$(( 10#${string} | cut -c1 ))\n\n  # Create a variable called count that\
    \ counts through the alphabet and\n  # appends the letter it finds up to a total\
    \ of four.\n  count=0\n  while [[ $count -lt 4 ]]; do\n    count=$(( count+1 ))\n\
    \    key=$(( key + 1 ))\n  done\n  \n  # Return the encrypted value.\n  echo \"\
    $alphabet[$key]${alphabet[$(( $key+$(( $key&1 )) ))]}\"", "  echo $1 |gawk '{for(i=length($1)-1;i>0;i--)print\
    \ $(i-1); print}'", "    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    [[ -z \"\
    $1\" ]] && echo \"No argument supplied\" && exit 1\n    [[ \"$1\" =~ \"$alphabet\"\
    \ ]] && echo \"Not a valid argument\" && exit 1\n    \n    # Encrypt the string\
    \ using XOR encryption and shift each letter by 2 places.\n    # In other words:\n\
    \    # \n    # XOR encryption is performed on the ASCII values from the first\
    \ letter \n    # onward. \n    # \n    # An example XOR encryption algorithm is\
    \ shown below.\n    # If the value of each character in the string is equal to\
    \ the letter \n    # in the alphabet shift the value down by 2 places i.e. 2 letters\
    \ move \n    # down. \n    # If the value is unequal then XOR encryption is performed\
    \ on the ASCII \n    # value of the character.\n    #\n    \n    # Get the length\
    \ of the string\n    len=$(echo \"$1\" | wc -c)\n    # XOR encryption on each\
    \ letter of the string.\n    res=\"\"\n    for ((i=0; i<$len; i++)); do\n    \
    \    xor=${1:i:1}\n        echo \"$xor ${1:i:1}\"\n        xor=${xor^^}\n    \
    \    echo -n \"$xor\"\n        echo \"$res\"\n    done", "    echo $1\n    echo\
    \ $1\n    echo $1\n    echo $1\n    echo $1", "  # Get the length of the input\
    \ string\n  local length=\"$1\"\n  \n  # Create the result string\n  local result=\"\
    \"\n  \n  # Loop through each character in the string\n  for (( i = 0; i < ${#length};\
    \ i++ )); do\n    # Get the value of the i-th character in the string\n    local\
    \ val=\"${1:0:1}${1:1:1}${1:2:1}${1:3:1}${1:4:1}\"\n  \n    # Get the index of\
    \ the current character to rotate by\n    local index=$(( $i % $length ))\n  \n\
    \    # Rotate the current character by the index\n    local rotval=\"${val:0:1}${val:1:1}${val:2:1}${val:3:1}${val:4:1}\"\
    \n  \n    # Add the rotated character to the result string\n    result=\"${result}${rotval:0:1}${rotval:1:1}${rotval:2:1}${rotval:3:1}${rotval:4:1}\"\
    \n  done\n  \n  echo \"$result\"", "  local alphabet='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local string=$1\n  local output=''\n  local current\n  local len=${#string}\n\
    \  \n  echo \"string: $string\"\n  \n  for current in ${string:0:len/2}; do\n\
    \    output=$output${alphabet:$((current+2)):1}\n  done\n  \n  for current in\
    \ ${string:len/2:len}; do\n    output=$output${alphabet:$((current+2)):1}\n  done\n\
    \  \n  echo \"output: $output\"", "  # Convert the argument into an array and\
    \ shift it left by 2 places\n  local -a c=(${1:?$1 is missing.})\n  c=(${c[@]/2})\n\
    \  # Convert the array into a string\n  local -i str=\"${#c[@]}\"\n  local -a\
    \ i\n  local -a j\n  local -a k\n  local -a c\n  local -i j\n\n  # Loop from 1\
    \ to string length\n  for ((j=0; j<str; j++)); do\n    i=(${#c[@]})\n    k=(${c[@]})\n\
    \    for ((i=0; i<${#k[@]}; i++)); do\n      j=$(($j+2))\n      c[i]=$k[$j]\n\
    \    done\n  done\n  # Convert the string back into an array and return the result\n\
    \  echo ${c[*]}", "    local alphabet=\"${1}\"\n    local string=\"${2}\"\n  \
    \  local length=\"${#1}\"\n    local rot=\"\"\n    for (( i=1 ; i <= length ;\
    \ i++ )) ; do\n        rot += \"${alphabet:$((i-1)):2}${alphabet:$((i-1)):2}\"\
    \n    done\n    echo \"$rot\"", "  local chars=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ23456789\"\
    ;\n  local charsrot=\"$chars$chars\"\n  local charsrot2=\"$charsrot$chars\"\n\
    \  local newchars=\"$charsrot2$charsrot\"\n  local newcharsrot=\"$newchars$newchars\"\
    \n  local newcharsrot2=\"$newcharsrot$newchars\"\n  local charsrot3=\"$charsrot2$charsrot$chars\"\
    \n  local charsrot4=\"$charsrot3$charsrot\"\n  local newchars3=\"$charsrot4$charsrot\"\
    \n  local newcharsrot3=\"$newchars3$newcharsrot\"\n  local newcharsrot4=\"$newcharsrot3$newcharsrot\"\
    \n  local charsrot5=\"$charsrot4$charsrot$chars\"\n  local charsrot6=\"$charsrot5$charsrot\"\
    \n  local newchars5=\"$charsrot6$charsrot\"\n  local newcharsrot5=\"$newchars5$newcharsrot\"\
    \n  local newcharsrot6=\"$newcharsrot5$newcharsrot\"\n  local charsrot7=\"$charsrot6$charsrot$chars\"\
    \n  local charsrot8=\"$charsrot7$charsrot\"\n  local newchars7=\"$charsrot8$charsrot\"\
    \n  local newcharsrot7=\"$newchars7$newcharsrot\"\n  local newcharsrot8=\"$newcharsrot7$newcharsrot\"\
    \n  local charsrot9=\"$charsrot8$charsrot$chars\"\n  local charsrot10=\"$charsrot9$charsrot\"\
    \n  local newchars9=\"$charsrot10$charsrot\"\n  local newcharsrot9=\"$newchars9$newcharsrot\"\
    \n  local newcharsrot10=\"$newcharsrot9$newcharsrot\"\n  local charsrot11=\"$charsrot10$charsrot$chars\"\
    \n  local charsrot12=\"$charsrot11$charsrot\"\n  local new", "  local string=\"\
    $1\"\n  local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-=!@#$%^&*()_+;:,.<>?/\"\
    \n  local size=${#alphabet}\n  local result=\"\"\n  for (( i=0; i<${#string};\
    \ i++ )); do\n    result=\"${result}${alphabet:0:$size}\"\n    alphabet=\"${alphabet:$size:$size}\"\
    \n    alphabet=\"${alphabet:0:$size}\"\n  done\n  echo $result", "    alphabet=$1\n\
    \    echo $($(alphabet=$1 alphabet=$((alphabet+=2)) alphabet=$((alphabet*=2))\
    \ alphabet=${alphabet:0:1} alphabet=${alphabet:1:2} alphabet=${alphabet:2:3}))",
  "    # Shift the alphabet by two letters down\n    # And add the two shifted letters\
    \ again\n    local LETTERS=\"abcdefghijklmnopqrstuvwxyz\"\n    local LETTERS2=\"\
    ${LETTERS%????}\"\n    local LETTERS3=\"${LETTERS2%????}\"\n    local LETTERS4=\"\
    ${LETTERS3%????}\"\n    local LETTERS5=\"${LETTERS4%????}\"\n    local LETTERS6=\"\
    ${LETTERS5%????}\"\n    local LETTERS7=\"${LETTERS6%????}\"\n    local LETTERS8=\"\
    ${LETTERS7%????}\"\n    local LETTERS9=\"${LETTERS8%????}\"\n    local LETTERS10=\"\
    ${LETTERS9%????}\"\n    local LETTERS11=\"${LETTERS10%????}\"\n    local LETTERS12=\"\
    ${LETTERS11%????}\"\n    local LETTERS13=\"${LETTERS12%????}\"\n    local LETTERS14=\"\
    ${LETTERS13%????}\"\n    local LETTERS15=\"${LETTERS14%????}\"\n    local LETTERS16=\"\
    ${LETTERS15%????}\"\n    local LETTERS17=\"${LETTERS16%????}\"\n    local LETTERS18=\"\
    ${LETTERS17%????}\"\n    local LETTERS19=\"${LETTERS18%????}\"\n    local LETTERS20=\"\
    ${LETTERS19%????}\"\n    local LETTERS21=\"${LETTERS20%????}\"\n    local LETTERS22=\"\
    ${LETTERS21%????}\"\n    local LETTERS23=\"${LETTERS22%????}\"\n    local LETTERS24=\"\
    ${LETTERS23%????}\"\n    local LETTERS25=\"${LETTERS24%????}\"\n    local LETTERS26=\"\
    ${LETTERS25%????}\"\n    local LETTERS27=\"${LETTERS26%????}\"\n    local LETTERS28=\"\
    ${LETTERS27%????}\"\n    local LETTERS29=\"${LETTERS28%????}\"\n    local LETTERS30=\"\
    ${LETTERS29%????}\"\n    local LETTERS31=\"${LETTERS", "    # get the string as\
    \ a variable $1 and store it in the variable $1\n    # this way $1 can be used\
    \ as an argument within the function\n    # this also means that we aren't creating\
    \ a global variable here\n    local -n \"$1=$1\"\n\n    # create the variable\
    \ $encrypted\n    # this will be the encrypted version of the string $1\n    local\
    \ encrypted\n\n    # loop over all the characters in the variable $1\n    # increment\
    \ the $i by 2 \n    for i in $(seq 0 $(expr $1 \\| wc -c)) \n    do\n        encrypted+=$(echo\
    \ $1 | sed -n ${i}p) # add the value of $1 ($1) to $encrypted\n    done\n    \n\
    \    # return the value of $encrypted\n    return $encrypted", "    local string=\"\
    $1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local alphabet_len=${#alphabet}\n\
    \    local alpha=0\n    local newstring=''\n    local len=$((${#string} + ${#alphabet}\
    \ - 1))\n    local shifts=${#string} + ${#alphabet} - 2\n    local lastchar\n\n\
    \    while [ $len -gt 0 ]; do\n        ((alpha++))\n        newstring+=\"${alphabet[$((alpha-shifts))]}\"\
    \n        len=$((len-2))\n    done\n\n    lastchar=$(echo $string | cut -c1-1)\n\
    \    newstring+=\"${alphabet[$((${alphabet}$((shifts)-1)))]}\"\n    newstring+=\"\
    ${alphabet[$((alpha-shifts + 1))]}\"\n    newstring+=\"$lastchar\"\n    echo \"\
    $newstring\"", "    local string=$1\n    local alphabet=\"${alphabet:-abcdefghijklmnopqrstuvwxyz}\"\
    \n    local alphabetsize=${#alphabet}\n    # Shift every character by 2 places\
    \ down\n    for ((i=0;i<${#string};i++)); do \n        local shift=\"${alphabetsize-1}\"\
    ;\n        local character=${string:$i:1}\n        # Shift every other character\
    \ by 2 places down\n        for ((j=0;j<${#character};j++)); do\n            if\
    \ [[ \"$j\" -eq \"0\" ]]; then\n                shift=\"${alphabetsize-2}\"\n\
    \            fi\n            local newcharacter=$(\n                let \"shift+j+2\"\
    \n                echo \"${alphabet:$shift}\"\n            )\n        done\n \
    \       echo ${newcharacter} \n    done", "  local alphabet=$2\n  shift\n  local\
    \ output=\"\"\n  for char in $1; do\n    output=\"${output}${alphabet:$(echo \"\
    ${alphabet}${char}\" | cut -c1-2):$(echo \"${alphabet}${char}\" | cut -c3-2)}\"\
    \n  done\n  echo \"${output}\"", "  # Make sure the argument is a string\n  if\
    \ [[ ! -z \"$1\" ]]; then\n    # Make sure the argument is 8 chars or longer\n\
    \    if [[ \"$1\" =~ ^.{8}$ ]]; then\n      echo \"$1\" | sed -e 's/./&1/g' |\
    \ sed -e 's/1$/&2/g' | \\\n        sed -e 's/1$//g' | sed -e 's/&1/&3/g' | sed\
    \ -e 's/&3/&2/g' | \\\n        sed -e 's/&2/&1/g'\n    else\n      echo \"$1\"\
    \ | sed -e 's/./&1/g' | sed -e 's/1$/&2/g' | \\\n        sed -e 's/1$//g' | sed\
    \ -e 's/&1/&3/g' | sed -e 's/&3/&2/g' | \\\n        sed -e 's/&2/&1/g' | sed -e\
    \ 's/&1/&3/g'\n    fi\n  else\n    echo \"$1\" | sed -e 's/./&1/g' | sed -e 's/1$/&2/g'\
    \ | \\\n      sed -e 's/1$//g' | sed -e 's/&1/&3/g' | sed -e 's/&3/&2/g' | \\\n\
    \      sed -e 's/&2/&1/g' | sed -e 's/&1/&3/g' | sed -e 's/&3/&2/g'\n  fi", " \
    \   local ALPHABET=$(python -c \"import string; print string.ascii_letters[2:${#1}]]\"\
    )\n    local STRING=\"$1\"\n    local RESULT=\"\"\n    for i in $(seq -s \" \"\
    \ 1 $((${#STRING}-2))); do\n        local LETTER=\"${STRING:i:1}\"\n        RESULT+=\"\
    ${LETTER}${ALPHABET:i:1}\"\n    done\n    RESULT=\"${RESULT:1}\"\n    echo \"\
    ${RESULT}\"", "    local alphabet=\"$1\"\n    local length=\"${#alphabet}\"\n\
    \    local index=\"${length}\"\n\n    for (( i=0; i<$length; i++ )); do\n    \
    \    ((index -= 2)) && printf \"%s\" \"${alphabet:$index:1}\"\n    done\n\n  \
    \  # Pad it out with the empty strings\n    for (( i=0; i<$length; i++ )); do\n\
    \        printf \"%s\" \"${alphabet:$index:1}\"\n    done", "    local alphabet=\"\
    $2\"\n    local str=\"$1\"\n    local len=\"${#str}\"\n    local i\n    local\
    \ newstr=\"\"\n    # loop through all letters in the alphabet\n    for ((i = 0;\
    \ i <= len; i++)); do\n        newstr+=\"${str::${i}:${i}${len}}${alphabet:$(($i\
    \ + 2)):2}\"\n    done\n    # now return the encrypted string\n    echo \"$newstr\"",
  "  local str=\"$1\"\n  local alpha=\"abcdefghijklmnopqrstuvwxyz\"\n  local alpha_num=\"\
    1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local c=0\n  local result=\"\"\n  local\
    \ i\n\n  for i in \"${str//?}\"; do\n    local j=${i:0:1}\n    local k=$alpha_num:$((c+${i#1}))\n\
    \    local l=${alpha:$j:1}\n    local m=${alpha_num:${l#1}}\n    result+=\"${m}\"\
    \n    shift\n    c=$((c+2))\n  done\n\n  echo \"$result\"", "    local ROTATIONS=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabet=\"mnopqrstuvwxyz\"\n    local\
    \ password=\"$1\"\n    local encrypted=\"$2\"\n    local i=1\n    local j=1\n\
    \    local p=1\n    while [ $i -le $((${#password}-1)) ]; do\n        encrypted=$encrypted${ROTATIONS[$((\
    \ ${#password}-$i ))]}\n        i=$(( ${#password}-$i ))\n        j=$(( j+1 ))\n\
    \    done\n    encrypted=${encrypted:0:1}${ROTATIONS[$(( $((${#encrypted}/2))\
    \ ))]}${encrypted:$(( ${#encrypted}-1 ))}\n    encrypted=${encrypted:0:1}${alphabet[$((\
    \ ${#encrypted}-1 ))]}${encrypted:$(( ${#encrypted}-1 ))}\n    encrypted=${encrypted:0:1}${alphabet[$((\
    \ ${#encrypted}-1 ))]}${ROTATIONS[$(( ${#encrypted}-1 ))]}\n    echo \"$encrypted\"",
  "    local alphabet=\"$1\" \n    local c=''\n    local alphabetSize=12\n    for\
    \ ((i=0; i < ${#alphabet}; i++)); do\n        c=${alphabet:i:1}\n        alphabet=\"\
    ${alphabet:1:i-1}${alphabet:i+1}${alphabet:i+2}\"\n    done\n    printf \"$c\"",
  "    local string=$1\n    local alphabet=${2:-abcdefghijklmnopqrstuvwxyz}\n    local\
    \ len=${#string}\n    local key=0\n    local c=''\n    local shift=0\n    for\
    \ (( i=0; i<len; i++ )); do\n        c=\"${string[$i]}\"\n        key=$((key*2)%len+key)\n\
    \        if [[ $c != $alphabet[$key] ]]; then\n            shift=$((++shift))\n\
    \        fi\n        string=$((c+alphabet[$key])${string:$i:1})\n    done\n  \
    \  printf \"$string\"", "    # $2 will hold the length of the alphabet we will\
    \ be using\n    len=$2\n    alphabet=$1\n    # $2 will hold the length of the\
    \ encrypted string after rotation\n    len_encrypted=`expr $len - 1`\n\n    #\
    \ loop through the alphabet\n    for (( i=len; i >= 0; i-- )); do\n        # $3\
    \ will hold the new letter after rotation\n        let=\"$(expr $i + 1 \\* $len)\"\
    \n        # $4 will hold the encrypted letter\n        let=\"$(expr ${alphabet:$i:1}$let)\"\
    \n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n   \
    \     # $3 will hold the encrypted letter\n        let=\"$(expr ${alphabet:$len_encrypted:1}$let)\"\
    \n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n   \
    \     let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n       \
    \ let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"\
    ${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\
    \n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n   \
    \     let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n       \
    \ let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"\
    ${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\
    \n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n   \
    \     let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n       \
    \ let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"\
    ${let:0:1}${let:1}\"\n        let=\"${let:0:1}${let:1}\"\n        let=\"${let:0:1}${",
  "  local input=$1\n  local alphabet='abcdefghijklmnopqrstuvwxyz'\n  local c=''\n\
    \  local temp\n\n  for c in \"${alphabet:0:1}\"; do\n    temp=${input:0:1}\n \
    \   input=${input:1:1}\n    echo \"${temp}${c}${input}\"\n  done", "    echo \"\
    $1\" | gsed -e \"s/\\(.\\)$/$(gsed -e 's/\\(.\\)\\(.\\)/\\1\\2/' <<< \"$1\") \\\
    1/\"", "    local s=$1\n    local c=''\n    for ((i=0; i<${#s}; i++)); do\n  \
    \      c=${c}${s:$i:1}\n    done\n    echo ${c}", "  # The alphabet is rotated\
    \ down by two letters multiplied by\n  # two\n  local alphabet=\"azertyuiopqsdfghjklmwxcvbn\"\
    \n  local length=\"${#1}\"\n  local string=\"${1}\"\n  # Loop through the string\
    \ and shift each letter in the alphabet by\n  # 2 places, then add that letter\
    \ at the end of the string.\n  local cipher=\"\"\n  while [ $length -gt 0 ]; do\n\
    \    local i\n    local j\n    for (( i=0; i<${#string}\"; i++ )); do\n      j=$((i\
    \ + 1))\n      local letter=\"${string:$i:1}\"\n      # Shift the letter down\
    \ by 2 places\n      local letter=\"${alphabet:$j:1}\"\n      cipher=\"$cipher\
    \ ${letter}\"\n    done\n    local string=\"${string:0:$i}\"\n    cipher=\"$cipher\
    \ ${alphabet:$((i + 1)):1}\"\n    length=$((length - 1))\n  done\n  # Cut off\
    \ the string if only 1 letter\n  cipher=\"$cipher ${alphabet:$((${#string} + 1)):1}\"\
    \n  # Replace spaces with an underscore\n  cipher=\"${cipher// /_}\"\n  echo \"\
    $cipher\"", "  local STR=$1\n  local CIPHER=\"$(python -c \"import string;print\
    \ ''.join($($(PYTHON_INTERPRETER) <<<\"import string;import base64;print base64.b32encode($STR.encode('utf-8')).decode('utf-8')\"\
    )[2:].rsplit('$', 1)[0]\")\"\n  local ENCIPHER=\"$(python -c \"import string;print\
    \ ''.join($($(PYTHON_INTERPRETER) <<<\"import string;import base64;print base64.b32decode($CIPHER.encode('utf-8')).decode('utf-8')\"\
    )[2:].rsplit('$', 1)[0]\")\"\n  echo $ENCIPHER", "    local chars=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local result=\"\"\n    local length=\"${#1}\"\n    \n    for ((i=0; i<length;\
    \ i++)) \n    do\n        result=\"${result}${chars:$i:2}\"\n    done\n    \n\
    \    echo ${result}", "    local str=\"$1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabet2=\"nopqrstuvwxyzabcdefghijklm\"\n    local len=${#str}\n\n\
    \    # Shift down the letters by 2 multipled to 2 places to encrypt\n    for ((\
    \ i=0;i<len;i++ )); do\n        local n=\"${alphabet:$i:1}\"\n        local m=\"\
    ${alphabet2:$((i+2)):1}\"\n        local r=\"${m}${n}\"\n        local x=\"${r//[!a-z]/.}\"\
    \n        str=\"${str:0:$i}${x}${str:$(($i+1)):1}\"\n    done\n    echo \"$str\"",
  "    local char=\"$1\"\n    local charArray=(\"$char\")\n    local count\n    local\
    \ result\n    local n\n    for (( count = 0; count < ${#charArray}; count = count\
    \ + 1 )); do\n        local n\n        n=$(( $count + 2 ))\n        charArray[$n]=$charArray[$n]\n\
    \    done\n    local n\n    for (( n = 0; n < ${#charArray}; n = n + 1 )); do\n\
    \        local char\n        char=${charArray[$n]}\n        result=\"$result$char\"\
    \n    done\n    echo \"$result\"", "    local string=$1\n    local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local count=0\n    local newstring=\"\"\n  \
    \  local length=0\n    local char\n\n    while [ ${#string} -gt 0 ]\n    do\n\
    \        char=${string:0:1}\n        if [ \"$char\" == \"$alphabet\" ]\n     \
    \   then\n            newstring+=\"${alphabet:$count:1}\"\n            length=$((length\
    \ + 1))\n            count=$((count + 1))\n        fi\n        shift\n    done\n\
    \n    if [ \"$count\" == \"0\" ]\n    then\n        echo \"$newstring\"\n    else\n\
    \        echo \"$newstring${alphabet:$count:1}\"\n    fi", "  local string=$1\n\
    \  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n\n  # Rotate the alphabet by\
    \ two\n  local alphabet2=\"${alphabet}\"\n  alphabet2=${alphabet2:2:2}\n\n  #\
    \ We need to move each character by two.\n  # The first character will be moved\
    \ twice to the left of the \n  # current position, while the next character will\
    \ be moved twice \n  # to the right of the current position. This will move the\
    \ \n  # current letter down by two positions so the next letter will \n  # be\
    \ moved two positions to the left of the current letter.\n  for (( i=0; i < ${#string};\
    \ i++ )); do\n    local current=${string:$i:1}\n    local new=${alphabet2:$i:1}\n\
    \n    # If the new current is less than the old current position, we need to \n\
    \    # move the new current to the left of the old current position. If it's \n\
    \    # greater than the old current position, then move it to the right \n   \
    \ # of the old current position. \n    if [ $(( ${#current} < ${#new} )) == 0\
    \ ]; then\n      new=${current}${new}\n    elif [ $(( ${#current} > ${#new} ))\
    \ == 0 ]; then\n      new=${new}${current}\n    fi\n\n    # Append the new current\
    \ to the current string\n    string=\"${string/$current/$new}\"\n  done\n\n  #\
    \ Return the string with the new alphabet\n  echo \"$string\"", "  local string\
    \ count\n  string=\"$1\"\n  count=$(echo $string | wc -w)\n  shift\n  char=$(echo\
    \ $string | head -n 1)\n  echo $char\n  for (( i=1; i<$count; i++ )); do\n   \
    \ char=$(echo $string | head -n $i)\n    string=\"$char$string\"\n    char=$(echo\
    \ $string | tail -n 1)\n    string=\"$char$string\"\n  done\n  echo ${string::-2}",
  "  local msg=$1\n  local temp\n  local n\n  local i\n  local j\n  local c\n  local\
    \ l\n  temp=$msg\n  n=$(echo $temp|wc -w)\n  echo -n\n  while [ $n -gt 0 ]; do\n\
    \    i=$(echo $temp|cut -d' ' -f1)\n    j=$(echo $temp|cut -d' ' -f2)\n    c=$((\
    \ $(expr $i + $(expr $j - 2)) ))\n    l=$(echo $temp|cut -d' ' -f3)\n    temp=$(echo\
    \ $temp|sed \"s/$i $j $l/$i $j $c/g\")\n    n=$(echo $temp|wc -w)\n  done\n  echo\
    \ -n $temp", "  local plain=$1\n  local alphabet=$2\n  local cipher=\n  for c\
    \ in $plain; do\n    cipher=\"$cipher$(($alphabet[$c])$(($alphabet[$c])%26))\"\
    \n  done\n  echo $cipher", "    local str=\"$1\"\n    local shift=\"$(echo $str\
    \ | sed 's/.//g')\"\n    local c=\"\"\n    for i in $shift; do\n        c=$(($c+${alphabet[$i]}))\n\
    \    done\n    echo \"$c\"", "    local str=\"$1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local c\n    local ret\n    local n\n    local i\n    local last\n    local\
    \ letter\n    last=$(expr $str | wc -w)\n    n=0\n    for c in $str; do\n    \
    \    i=$(( ${#alphabet}-1 ))\n        while [ $i -gt 0 ]; do\n            if [\
    \ $n = 0 ]; then\n                let=\"$(expr ${alphabet}[$(( $i - 1 ))]^2)\"\
    \n            else\n                let=\"$(expr ${alphabet}[$(( $i - 2 ))]^2)\"\
    \n            fi\n            i=$(( $i - 1 ))\n            ret=\"$(expr ${ret}${let})\"\
    \n            n=$(( $n + 1 ))\n        done\n        ret=\"$(expr ${ret}${alphabet}[$((\
    \ ${#alphabet} - 1 ))]^2)\"\n        n=$(( $n + 1 ))\n    done\n    echo \"$ret\"",
  "    local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n \
    \   local alphabetLen=${#alphabet}\n    local str=${1}\n    local newstr=\"\"\n\
    \    local i=0 j=0\n    while (( i < ${#str} )) ; do\n        j=0\n        while\
    \ (( j < ${alphabetLen} )) ; do\n            (( i++ ))\n            (( j++ ))\n\
    \            (( newstr=\"${newstr}${alphabet:$j:2}\" ))\n        done\n    done\n\
    \    echo ${newstr}", "  local str=\"$1\"\n  local tmp=$(($(echo \"${str}\" |\
    \ wc -w)*2))\n  local ret=\"\"\n  for ((i=0; i<${#str}; i+=2)); do \n    local\
    \ ii=${str:$i:2}\n    local jj=${str:$((i+1)):2}\n    local c=${str:$ii:1}\n \
    \   local d=${str:$jj:1}\n    ret+=\"${c}-${d}\"\n  done\n  echo \"${ret}\"",
  "    local STRING=$1\n    local ROTATIONS=$2\n    local ENCRYPTED=\n    local LETTERS=\n\
    \    local ROTATE\n    local ROTATE_STRING\n\n    ROTATIONS=`echo $ROTATIONS |\
    \ sed -e 's/%/\\\\n/g'`\n    ROTATE=`echo $ROTATIONS | cut -d: -f2`\n\n    # Find\
    \ the number of letters to rotate, starting with two.\n    for LETTERS in {2..1}\n\
    \    do\n        ROTATE_STRING=`echo $ROTATIONS | sed -n -e \"s/.\\($LETTERS\\\
    )/ \\${\\($LETTERS\\)-$ROTATE}p\"`\n\n        ROTATED=`echo $STRING | $ROTATE_STRING`\n\
    \n        ROTATED=`echo $ROTATED | tr -d \"\\n\"`\n\n        ENCRYPTED+=$ROTATED\n\
    \    done\n    \n    return $ENCRYPTED", "    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local shift=2\n    local str=\"$1\"\n    local str=\"${str^^}\"\n    local\
    \ length=\"${#str}\"\n    local new=\"\"\n    local index=0\n    while [[ ${index}\
    \ -lt ${length} ]]; do\n        new=\"${new}${str}\"\n        index=$((index+shift))\n\
    \    done\n    echo ${new:0:1}${new:1}${new:2:1}${new:3:1}${new:4:1}${new:5:1}",
  "    local plain=$1\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local\
    \ count\n    local index\n    local output=\"\"\n    local output2\n    \n   \
    \ # Loop through plain, count the letters, \n    # and append them to output\n\
    \    for index in \"${!plain}\"; do\n        ((count[$index]))\n        output+=$((count[$index]))\n\
    \    done\n    \n    # Append a second loop to add the letters to output2\n  \
    \  for index in \"${!plain}\"; do\n        ((count[$index]))\n        output2+=$((count[$index]))\n\
    \    done\n    \n    # Loop through output2 starting with the 2nd letter, \n \
    \   # and append the letters to output\n    for index in $(seq 2 ${#output2});\
    \ do\n        output+=$output2[index]\n    done\n\n    # Return output\n    echo\
    \ \"$output\"", "    local str=\"$1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local shift=6\n    local temp=$(for i in `seq 1 ${#str}`; do\n         \
    \   echo ${alphabet:$((${i} % ${#alphabet})):$((${i} % ${#alphabet})):1}\n   \
    \     done)\n    while ((${#str} > 0)); do\n        str=${str:0:$((${#str} % ${#alphabet})):1}\n\
    \        echo ${temp}${str}${temp:0:1}\n    done", "  local str=$1\n  local chars=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local newchars=\"zyxwvutsrqponmlkjihgfedcba\"\n\
    \  local res=\"\"\n\n  local len=${#str}\n  local i\n  for i in $(seq 0 $((len-2)));\
    \ do\n    local j\n    for j in $(seq 0 $((len-1))); do\n      if [ ${str}$i =\
    \ ${newchars}$j ]; then\n        local x=$((${newchars}$j))\n        if [ ${str}$i\
    \ = ${chars}${x} ]; then\n          local y=$((${x}))\n          res=\"${res}${chars#$y}\"\
    \n        else\n          local z=$((${newchars}${x}))\n          res=\"${res}${z}\"\
    \n        fi\n      fi\n    done\n  done\n\n  echo $res", "    local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local alphabetLen=${#alphabet}\n    local input=${1:-}\n\
    \    local output=\"\"\n    local index\n    local shift\n\n    for (( index=0;\
    \ index<${#input}; index+=1 )); do\n        local current=${input:$index:1}\n\
    \        local next=${input:$(($index + 1))}\n        if [[ \"$current\" == \"\
    $next\" ]]; then\n            shift\n            continue\n        fi\n      \
    \  index=$((${index}-1))\n        shift\n        local newIndex\n        newIndex=${#alphabet}\n\
    \        newIndex=$((${newIndex}-2))\n        newIndex=$((${newIndex}+${shift}))\n\
    \        alphabet=${alphabet:$newIndex:1}\n        output+=\"${alphabet}${current}\"\
    \n    done\n    echo \"$output\"", "  echo \"$1\" | awk '{print substr($1,length($1)/2,2),substr($1,1,length($1)/2),substr($1,length($1)/2)+2}'\
    \ | tr -d \"\\n\"", "  # Encrypt alphabet and shift the letters by 2 places.\n\
    \  echo \"${alphabet[$1]}\"\n  local c=\"${alphabet[$1]}\"\n  alphabet[$1]=\"\
    ${alphabet[$2]}\"\n  alphabet[$2]=$c", "  local string=\"$1\"\n  local alpha=\"\
    abcdefghijklmnopqrstuvwxyz\"\n  local alpha_count=\"$(echo -n \"$alpha\" | sed\
    \ -n 's/./ /gp')\"\n  local alpha_max=\"$(echo $alpha_count | awk '{print sqrt($1)}')\"\
    \n  local alpha_max2=\"$(echo $alpha_max | awk '{print $1/2}')\"\n  local alpha_max3=\"\
    $(echo $alpha_max | awk '{print $1/3}')\"\n\n  # This loop divides up the string\
    \ into letters so that a letter\n  # is counted twice if it is at even position\n\
    \  local count=0\n  local letters=\"${string}\"\n  while [[ \"$letters\" != \"\
    \" ]]; do\n    if [[ \"$count\" -eq \"$alpha_max2\" ]]; then\n      alpha_count=\"\
    $(echo $alpha_count | awk '{print $1/2}')\"\n      alpha_max=\"$(echo $alpha_max\
    \ | awk '{print $1/2}')\"\n      alpha_max2=\"$(echo $alpha_max2 | awk '{print\
    \ $1/2}')\"\n      alpha_max3=\"$(echo $alpha_max3 | awk '{print $1/3}')\"\n \
    \   fi\n    ((count++))\n    letters=\"${letters:1}\"\n  done\n  alpha_max=\"\
    $(echo $alpha_max | awk '{print $1/2}')\"\n\n  local alpha_count2=\"$(echo $alpha_count\
    \ | awk '{print sqrt($1)}')\"\n  local alpha_count3=\"$(echo $alpha_count | awk\
    \ '{print $1/3}')\"\n  local alpha_count4=\"$(echo $alpha_count | awk '{print\
    \ $1/4}')\"\n  alpha_count=\"$(echo $alpha_count | awk '{print sqrt($1)}')\"\n\
    \n  local alpha_max2=\"$(echo $alpha_max | awk '{print $1/2}')\"\n  local alpha_max3=\"\
    $(echo $alpha_max | awk '{print $1/3}')\"\n  local alpha_max4=\"$(echo $alpha_max\
    \ | awk '{print $1/4}')\"\n  alpha_max=\"$(echo $alpha_max | awk '{print $1/2}')\"\
    \n\n  local alpha_count5=\"$(echo $alpha_count | awk '{print sqrt($1)}')\"\n \
    \ local alpha_count6=\"$(echo $alpha_count | awk '{print $1/6}')\"\n  alpha_max=\"\
    $(echo $alpha_max | awk '{print $1/2}')\"\n\n  local alpha_count7=\"$(echo $alpha_count\
    \ | awk", "  # Get command line parameter\n  shift\n  # Loop through each letter\n\
    \  for i in $(seq 0 $((${#1}-1)))\n  do\n    # Determine if letter at position\
    \ $i is odd and then subtract 2 \n    # from the alphabet position then shift\
    \ the letter down by 2\n    if (($(($i % 2)) )) \n    then\n      new_alphabet=${alphabet:$(($((i+1)-2))):2}\n\
    \      # Rotate the letter\n      alphabet=${alphabet:0:$((${#alphabet} - $((i+1)-2))):1}\n\
    \      # Shift the letter by 2\n      alphabet=${alphabet:1:1}\n    else\n   \
    \   # Shift the letter by 1\n      alphabet=${alphabet:1:1}\n    fi\n  done\n\
    \  echo ${alphabet}", "    local input\n    local alphabet\n    local output\n\
    \    \n    input=\"$1\"\n    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    \n \
    \   mapfile -t output < <(printf \"%s\" $input)\n    \n    mapfile -t tmp < <(printf\
    \ \"%s\" \"$alphabet\"|sed \"s/./& &/g;s/ /& /g;s/ & /2 &/g;s/ 2 /2 &/g;s/ 2 2\
    \ /3 &/g;s/ 3 /3 &/g;s/ 3 3 /4 &/g;s/ 4 /4 &/g;s/ 4 4 /5 &/g;s/ 5 /5 &/g;s/ 5\
    \ 5 /6 &/g;s/ 6 /6 &/g;s/ 6 6 /7 &/g;s/ 7 /7 &/g;s/ 7 7 /8 &/g;s/ 8 /8 &/g;s/\
    \ 8 8 /9 &/g;s/ 9 /9 &/g;s/ 9 9 /10 &/g;s/ 10 /10 &/g;s/ 10 10 /11 &/g;s/ 11 /11\
    \ &/g;s/ 11 11 /12 &/g;s/ 12 /12 &/g;s/ 12 12 /13 &/g;s/ 13 /13 &/g;s/ 13 13 /14\
    \ &/g;s/ 14 /14 &/g;s/ 14 14 /15 &/g;s/ 15 /15 &/g;s/ 15 15 /16 &/g;s/ 16 /16\
    \ &/g;s/ 16 16 /17 &/g;s/ 17 /17 &/g;s/ 17 17 /18 &/g;s/ 18 /18 &/g;s/ 18 18 /19\
    \ &/g;s/ 19 /19 &/g;s/ 19 19 /20 &/g;s/ 20 /20 &/g;s/ 20 20 /21 &/g;s/ 21 /21\
    \ &/g;s/ 21 21 /22 &/g;s/ 22 /22 &/g;s/ 22 22 /23 &/g;s/ 23 /23 &/g;s/ 23 23 /24\
    \ &/g;s/ 24 /24 &/g;s/ 24 24 /25 &/g;s/ 25 /25 &/g;s/ 25 25 /26 &/g;s/ 26 /26\
    \ &/g;s/ 26 26 /27 &", "   local str=\"$1\"\n   local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n   local n=0\n   local strlen=$(expr length \"$str\")\n   for (( i=0; i<strlen;\
    \ i++ )); do\n      n=$(($n % $strlen))\n      echo \"${str}${alphabet:$n:1}\"\
    \n      (( n++ ))\n   done", "    local string=$1\n    # declare an array containing\
    \ all 26 letters of the alphabet\n    local alphabet=(a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z)\n    # declare a variable to hold the letters one\
    \ by one in the array\n    local letter\n    # declare a variable to hold the\
    \ encrypted letter\n    local encrypted_letter\n    # declare a variable for the\
    \ number of characters to encrypt\n    local number_of_chars\n    # declare an\
    \ array to hold all the rotated alphabets\n    local rotated_alphabet=(j k l m\
    \ n o p q r s t u v w x y z a)\n    # declare a variable for the number of characters\
    \ to decrypt\n    local number_of_chars_rotated\n    # declare an array to hold\
    \ all the unrotated alphabets\n    local unrotated_alphabet=(a b c d e f g h i\
    \ j k l m n o p q r s t u v w x y z)\n    # declare a variable for the number\
    \ of characters to decrypt\n    local number_of_chars_unrotated\n    # declare\
    \ a variable for the number of characters\n    local number_of_chars_unencrypted_or_rotated\n\
    \    # declare a variable for the number of characters in the original string\n\
    \    local number_of_chars\n    # declare an array to hold all the shifted alphabets\n\
    \    local shifted_alphabet=(j k l m n o p q r s t u v w x y z a)\n    # declare\
    \ a variable for the number of characters in the rotated string\n    local number_of_chars_rotated\n\
    \    # declare an array to hold all the unshifted alphabets\n    local unshifted_alphabet=(a\
    \ b c d e f g h i j k l m n o p q r s t u v w x y z)\n    # declare a variable\
    \ for the number of characters in the unrotated string\n    local number_of_chars_unrotated\n\
    \    # declare a variable for the number of characters in the unencrypted string\n\
    \    local number_of_chars_unencrypted\n\n    # if the length of the string is\
    \ less than 26 characters, \n    # then just return it and exit\n    if [ ${#string}\
    \ -lt 26 ]; then\n        echo \"$string\"\n        exit 1\n    fi\n\n    # for\
    \ each character in the string\n    for character in ${string//?}; do\n      \
    \  # if the character is alphabetic\n        if [[ ${alphabet[*]} =~ $character\
    \ ]]; then\n            # shift that character down the alphabet\n           \
    \ # by 2 places and put that character in the array\n            # at that location\n\
    \            alphabet[${#alphabet[*]}-1]=${alphabet[${#alphabet[*]}-1]", "  echo\
    \ \"$1\" | tr '[:upper:]' '[:lower:]' | sed -e \"s/\\(.*\\)\\(.\\)\\(.\\)\\2\\\
    1.*\\(.*\\)\\(.\\)\\(.*\\)\\2\\1.*\\(.*\\)\\(.\\)\\(.*\\)\\2\\1.*/\\2\\3.\\1\\\
    4.\\5/g\"", "    local string=\"$1\"\n\n    # rotate the letters two places down\n\
    \    local string=\"${string,,}\"\n    local string=\"${string/a/b}\"\n    local\
    \ string=\"${string/c/d}\"\n    local string=\"${string/e/f}\"\n    local string=\"\
    ${string/g/h}\"\n    local string=\"${string/i/j}\"\n    local string=\"${string/k/l}\"\
    \n    local string=\"${string/m/n}\"\n    local string=\"${string/o/p}\"\n\n \
    \   # put it back together\n    echo \"${string}\"", "  local str=\"${1}\"\n \
    \ local rotations=0\n  while [ \"$rotations\" -lt \"$alphabet\" ] \n  do\n   \
    \ rotations=$(expr $rotations + 2)\n    local alphabet=${alphabet:1:$((${#alphabet}-2))}\n\
    \  done\n  local encrypted=\"\"\n  for ((i=0; i<${#str}; i++)); do\n    encrypted=\"\
    ${encrypted}${alphabet:$i:1}${str:$i:1}\"\n  done\n  echo \"${encrypted}\"", " \
    \   string=${1}\n    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    encrypted=\"\
    \"\n    while [ $# -gt 0 ]\n    do\n        letter=$((${#string} - 1))\n     \
    \   letter=${string:$letter:1}\n        letter=${alphabet:$letter:2}\n       \
    \ encrypted=\"$encrypted$letter\"\n        string=${string:0:$letter}\n      \
    \  shift\n    done\n    echo $encrypted", "        ENCRYPT=$1\n        shift\n\
    \        ENCRYPTED_STRING=\"\"\n        while [ \"$1\" != \"\" ]; do\n       \
    \         ENCRYPTED_STRING+=\"$1\"\n                ENCRYPTED_STRING+=\"$(encrypt\
    \ \"$ENCRYPT$1\")\"\n                shift\n        done\n        echo \"$ENCRYPTED_STRING\"",
  "    local str=\"$1\"\n    local rot=\"\"\n    while [ \"${#str}\" -gt 0 ]; do\n\
    \        # Shift the letter down by two and then add it to the rotation string.\n\
    \        rot=\"${rot:+$rot:}$((${#rot}+2)):\"\n        \n        # Append the\
    \ letter to the string.\n        str=\"${str:0:1}${rot}${str:1}\"\n    done\n\
    \    echo \"${str}\"", "    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  \
    \  local i\n    local j\n    local n\n\n    echo $1\n    shift\n    echo $1\n\
    \    shift\n    echo $1\n    shift\n    echo $1\n\n    while [ $1 ]; do\n    \
    \    i=$((${#alphabet}-1))\n        j=$((${#alphabet}-1))\n        n=$((${#alphabet}-2))\n\
    \        alphabet=\"${alphabet:0:${#alphabet}-2}\"\n        alphabet=\"${alphabet:0:${#alphabet}-2}\"\
    \n        echo ${alphabet}\n        echo ${alphabet:${#alphabet}-2}\n        echo\
    \ ${alphabet:${#alphabet}-${#alphabet}-1}\n        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-2}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-1}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-2}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-1}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-2}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-1}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-2}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-1}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-2}\n\
    \        echo ${alphabet:${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${#alphabet}-${",
  "    local input=$1\n    local result=''\n\n    for (( c=0; c<${#input}; c++ ));\
    \ do\n        result+=\"${alphabet:$((c*2)):1}\"\n    done\n\n    echo -e \"$result\"",
  "  local string=\"$1\"\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local\
    \ newstring=\"\"\n  local rotation=0\n\n  while [[ ${#string} -gt 0 ]]; do\n \
    \   local lastchar=${string:(-1)}\n    newstring+=${alphabet:$rotation:$lastchar}\n\
    \    let rotation=rotation+1\n    string=${string:0:${#string}-1}\n  done\n  echo\
    \ ${newstring}", "    # Your code here\n    local string=\"$1\"\n    local alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    local rotation=$((${#alphabet} - 2))\n    local\
    \ output=\"\"\n\n    for ((i=0; i<${#string}; i++ )); do\n        local char=${string:$i:1}\n\
    \        local offset=$((${#alphabet} - ${#char}))\n        if [ \"$offset\" -eq\
    \ 0 ]; then\n            char=$alphabet\n        fi\n        output+=\"${char:$((\
    \ ${#alphabet} - ${#char} )):1}\"\n    done\n\n    echo $output", "  # $1 is the\
    \ first argument.\n  # $2 is the second argument\n  local a\n  local b\n  local\
    \ c\n  local d\n  local e\n  local f\n  local g\n  local h\n  local i\n  local\
    \ j\n  local k\n  local l\n  local m\n  local n\n  local o\n  local p\n  local\
    \ q\n  local r\n  local s\n  local t\n  local u\n  local v\n  local w\n  local\
    \ x\n  local y\n  local z\n  # Alphabet rotation by two\n  a=\"${1}\"\n  a=\"\
    ${a//a/a}\"\n  a=\"${a//b/c}\"\n  a=\"${a//c/b\"}\n  a=\"${a//d/d}\"\n  a=\"${a//d/c}\"\
    \n  a=\"${a//e/e}\"\n  a=\"${a//e/d}\"\n  a=\"${a//f/f}\"\n  a=\"${a//f/e}\"\n\
    \  a=\"${a//f/d}\"\n  a=\"${a//g/g}\"\n  a=\"${a//g/f}\"\n  a=\"${a//g/g}\"\n\
    \  a=\"${a//g/g}\"\n  a=\"${a//h/h}\"\n  a=\"${a//h/i}\"\n  a=\"${a//h/j}\"\n\
    \  a=\"${a//h/k}\"\n  a=\"${a//h/l}\"\n  a=\"${a//h/m}\"\n  a=\"${a//h/n}\"\n\
    \  a=\"${a//h/o}\"\n  a=\"${a//h/p}\"\n  a=\"${a//h/q}\"\n  a=\"${a//h/r}\"\n\
    \  a=\"${a//h/s}\"\n  a=\"${a//h/t}\"\n  a=\"${a//h/u}\"\n  a=\"${a//h/v}\"\n\
    \  a=\"${a//h/w}\"\n  a=\"${a//h/x}\"\n  a=\"${a//h/y}\"\n  a=\"${a//h/z}\"\n\
    \  a=\"${a//i/i}\"\n  a=\"${a//i/j}\"\n  a=\"${a//i/k}\"\n  a=\"${a//i/l}\"\n\
    \  a=\"${a//i/m}\"\n  a=\"${a//i/n}\"\n  a=\"${a//i/o}\"\n  a=\"${a//i/p}\"\n\
    \  a", "\tlocal string=$1\n\tlocal alphabet=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n\
    \tlocal result=\"\"\n\tfor i in $string; do\n\t\tresult+=\"${alphabet[$((${alphabet:$((${#alphabet}-1))})-${alphabet:$((${#alphabet}-2))}:$((${#alphabet}-2))+${#i})]}\"\
    \n\tdone\n\techo $result", "    local letter=\"$1\"\n    local alphabet='abcdefghijklmnopqrstuvwxyz'\n\
    \    local rotated\n    \n    rotated=$( echo \"$letter\" | sed -r -e \"s/(.)\\\
    1/\\1\\2/\" -e \"s/(.)\\3\\1/\\3\\2/\" -e \"s/(.)\\4\\1/\\4\\2/\" -e \"s/(.)\\\
    5\\1/\\5\\2/\" -e \"s/(.)\\2\\1/\\2\\5/\" -e \"s/(.)\\5\\1/\\5\\2/\" -e \"s/(.)\\\
    3\\2/\\3\\5/\" -e \"s/(.)\\3\\3\\1/\\4\\5/\" -e \"s/(.)\\4\\1/\\4\\5/\" -e \"\
    s/(.)\\2\\1/\\2\\5/\" -e \"s/(.)\\4\\1/\\4\\5/\" -e \"s/(.)\\5\\1/\\5\\2/\" -e\
    \ \"s/(.)\\5\\1/\\5\\2/\" -e \"s/(.)\\3\\2/\\3\\5/\" -e \"s/(.)\\4\\2/\\4\\5/\"\
    \ -e \"s/(.)\\3\\3\\1/\\4\\5/\" -e \"s/(.)\\4\\1/\\4\\5/\" -e \"s/(.)\\2\\1/\\\
    2\\5/\" -e \"s/(.)\\3\\2/\\3\\5/\" -e \"s/(.)\\4\\2/\\4\\5/\" -e \"s/(.)\\4\\\
    3\\1/\\5\\2/\" -e \"s/(.)\\2\\1/\\2\\5/\" -e \"s/(.)\\4\\1/\\4\\5/\" -e \"s/(.)\\\
    5\\1/\\5\\2/\" -e \"s/(.)\\5\\1/\\5\\2/\" -e \"s/(.)\\3\\2/\\3\\5/\" -e \"s/(.)\\\
    3\\3\\1/\\4\\5/\" -e \"s/(.)\\4\\1/\\4\\5/\" -e \"s/(.)\\2\\1/\\2\\5/\" -e \"\
    s/(.)\\3\\2/\\3\\5/\" -e \"s/(.)\\4\\2/\\4\\5/\" -e \"s/(.)\\3\\3\\1/\\4\\5/\"\
    \ -e \"s/(.)\\4\\1/\\4\\5/\" -e \"s/(.)\\2\\1/\\2\\5/\" -e \"s/(.)\\4\\1/\\4\\\
    5/\" -e \"s/(.)\\5\\1/\\5\\2/\" -e \"s/(.)\\5\\1/\\5\\2/\" -e \"s/(.)\\3\\2/\\\
    3\\5/\" -e \"s/(.)\\4\\2/\\4\\5/\" -e \"s/(.", "    local string=\"$1\"\n    local\
    \ alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local length=\"${#string}\"\n \
    \   local length2=\"${#alphabet}\"\n    local index=0\n    local string2=\"\"\n\
    \    local letter\n\n    while (( \"$index\" < \"$length\" )) ; do\n        letter=\"\
    ${string:$index:1}\"\n        string2=\"${string2:1}${alphabet:0:$((index*2))}\"\
    \n        letter=\"${letter:0:1}${letter:1:1}\"\n        string2=\"${string2:1}${letter}\"\
    \n        ((index++))\n    done\n\n    echo \"$string2\"", "    local input=\"\
    $1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local output=\"\"\
    \n    \n    for (( i=0; i<${#input}; i++ )); do\n        local char=\"${input:$i:1}\"\
    \n        local outputChar=\"${alphabet:$((${#alphabet}*2)+$((${#alphabet}-${#char}-1)))}\"\
    \n        output=\"${output}${outputChar}\"\n    done\n    \n    echo \"$output\"",
  "  # Define variables\n  string=\"$1\"\n  alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  # Rotate alphabet by two each pass\n  alphabet=$(echo $alphabet | sed 's/\\\
    (..\\)/\\1/g')\n  alphabet=$(echo $alphabet | sed 's/\\(.\\)/\\1/g')\n  \n  #\
    \ Loop and rotate string with alphabet\n  for ((i=0; i<$((${#string})); i++));\
    \ do\n    string=$(echo $string | sed \"s/.\\(.\\)/\\1${alphabet}\\2/\")\n  done\n\
    \  echo $string", "    local string=\"$1\"\n    local alphabet_size=${#string}\n\
    \    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local shift=7\n\n    local\
    \ newString=\"\"\n    local currentChar=\"${string:0:1}\"\n    local newChar=\"\
    ${alphabet:${alphabet_size-2:2}}\"\n\n    local i\n    for (( i=0; i<alphabet_size;\
    \ i++ )); do\n        if [ \"${string:i:1}\" = \"a\" ]; then\n            newString=\"\
    ${newString}${alphabet:0:1}${alphabet:1:1}\"\n        elif [ \"${string:i:1}\"\
    \ = \"b\" ]; then\n            newString=\"${newString}${alphabet:1:1}${alphabet:2:1}\"\
    \n        elif [ \"${string:i:1}\" = \"c\" ]; then\n            newString=\"${newString}${alphabet:2:1}${alphabet:0:1}\"\
    \n        elif [ \"${string:i:1}\" = \"d\" ]; then\n            newString=\"${newString}${alphabet:1:1}${alphabet:2:2}${alphabet:3:1}\"\
    \n        elif [ \"${string:i:1}\" = \"e\" ]; then\n            newString=\"${newString}${alphabet:2:1}${alphabet:2:2}${alphabet:1:1}\"\
    \n        elif [ \"${string:i:1}\" = \"f\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:0:1}${alphabet:1:1}\"\
    \n        elif [ \"${string:i:1}\" = \"g\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:1:1}${alphabet:2:1}\"\
    \n        elif [ \"${string:i:1}\" = \"h\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:2:1}${alphabet:0:1}\"\
    \n        elif [ \"${string:i:1}\" = \"i\" ]; then\n            newString=\"${newString}${alphabet:3:1}${alphabet:2:2}${alphabet:1:1}\"\
    \n        elif [ \"${string:i:1}\" = \"j\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:3:1}${alphabet:0:1}\"\
    \n        elif [ \"${string:i:1}\" = \"k\" ]; then\n            newString=\"${newString}${alphabet:3:1}${alphabet:2:2}${alphabet:1:1}\"\
    \n        elif [ \"${string:i:1}\" = \"l\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:2:1}${alphabet:0:1}\"\
    \n        elif [ \"${string:i:1}\" = \"m\" ]; then\n            newString=\"${newString}${alphabet:2:2}${alphabet:3:1}${alphabet:1:1}",
  "    # Your code goes here\n    l=$1\n    \n    s=$(echo $l | rev | cut -c 2-)\n\
    \    e=$(echo $l | rev | cut -c 1-)\n    \n    echo $e | cat -n | rev | cut -c\
    \ 2-\n    ", "    # Convert to uppercase and store in variable $a\n    a=$(awk\
    \ '{print $NF}' <<< \"$1\")\n\n    # Shift all the letters in the string down\
    \ by two letters to make them \n    # all double as long as the total is double\
    \ the length of the string\n    b=$(awk '{print $(NF-1)}{print $(NF)}' <<< \"\
    $a\")\n    \n    # Return the result of concatenating the two strings\n    echo\
    \ \"$b\"", "  local cipherText=$1\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  local currentAlphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local output=\"\"\n\
    \n  while [ \"$cipherText\" != \"\" ]; do\n    output=\"${output}$( echo \"$cipherText\"\
    \ | sed \"s/$alphabet/$currentAlphabet/2\" | sed \"s/$currentAlphabet/$alphabet/2\"\
    \ | tr '[a-z]' '[A-Z]')\"\n    cipherText=\"${cipherText#*$alphabet}\"\n    currentAlphabet=\"\
    ${alphabet}\"\n    currentAlphabet=\"${currentAlphabet#*$cipherText}\"\n    cipherText=\"\
    ${cipherText%$cipherText}\"\n  done\n\n  echo $output", "  local string=$1\n \
    \ local alphabet=abcdefghijklmnopqrstuvwxyz\n  local newalphabet=\n  \n  newalphabet=\"\
    \n  \n  for i in `seq ${#alphabet}`\n  do\n    local newstring=$newalphabet$string$alphabet\n\
    \    alphabet=$newalphabet\n    newalphabet=$newalphabet\n  done\n  newalphabet=$alphabet\n\
    \  \n  echo \"$newalphabet\"", "    local string=\"$1\"\n    local rotation=\"\
    $2\"\n    local alphabet=\"a b c d e f g h i j k l m n o p q r s t u v w x y z\"\
    \n    local encrypted=\"\"\n    local rotations=$(echo \"$rotation\" | tr \" \"\
    \ \"\\n\")\n    for rotation in $rotations ; do\n        encrypted+=\"$(echo \"\
    $string\" | sed -E 's/'${rotation}'/'${alphabet}'/g' | tr \" \" \"\\n\")\"\n \
    \   done\n    echo $encrypted", "    local alphabet=\"$2\"\n    local input=\"\
    $1\"\n    local output=\"\"\n\n    # Add $input to output\n    while read -r letter;\
    \ do\n        local offset=$(echo \"$alphabet\" | md5sum | cut -f1 -d' ')\n  \
    \      local index=$((offset / 2))\n        local result=\"${alphabet:$index:1}\"\
    \n        alphabet=\"${alphabet:0:$index}${result}${alphabet:$index+1:1}\"\n \
    \       output=\"$output$letter\"\n    done\n\n    # Add output to end of alphabet\n\
    \    local last=\"${alphabet:0:1}\"\n    alphabet=\"${alphabet:1:1}${last}${output}\"\
    \n\n    # Write the new alphabet to a file\n    local new_alphabet=$(mktemp)\n\
    \    echo \"$alphabet\" > \"$new_alphabet\"\n\n    # Call encrypt again\n    encrypt\
    \ \"$output\" \"$new_alphabet\"", "  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  local alphabet2=\"abcdefghijklmnopqrstuvwxyz\"\n  local i\n  local j\n  local\
    \ k\n  local key\n  local output\n  local string\n  string=$1\n  output=\"\"\n\
    \  for ((i=${#string}-1; i>=0; i--)); do\n    j=$((alphabet2[i] % ${#alphabet}))\n\
    \    k=$((alphabet2[j] % ${#alphabet}))\n    output=$output${alphabet2[i]}${alphabet2[j]}\n\
    \    alphabet2[i]=${alphabet2[j]}\n    alphabet2[j]=${alphabet2[k]}\n    alphabet2[k]=${alphabet2[i]}\n\
    \  done\n  echo \"${output}\" ", "  local string=$1\n  local alphabet=$2\n  local\
    \ length=$3\n\n  local output\n  for (( i=0; i<${#string}; i++ )); do\n    local\
    \ j=0\n    local char\n    char=${string:$i:1}\n    for (( j=0; j<length; j++\
    \ )); do\n      if [[ \"${alphabet:$j:1}\" == \"${char}\" ]]; then\n        output=\"\
    ${output}${alphabet:$j:2}${alphabet:$j:3}\"\n        break\n      else\n     \
    \   output=\"${output}${alphabet:$j:3}\"\n      fi\n    done\n  done\n  echo \"\
    $output\"", "  local string=\"$1\"\n  local alphabet=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local length=\"${#string}\"\n  local encrypted=\"\"\n\n  for (( i=0 ; i <\
    \ length ; i++ )); do\n    local index=$(( i + 1 ))\n    encrypted=\"$encrypted$alphabet[$((\
    \ index % alphabet ))]\"\n  done\n\n  printf \"$encrypted\"", "    # Write your\
    \ encrypt/decrypt code here\n    # Example: \n    # >>> alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    # >>> alphabet[alphabet.index(\"f\")] = alphabet[alphabet.index(\"e\") -\
    \ 2] + alphabet[alphabet.index(\"f\")] \n    # >>> alphabet[alphabet.index(\"\
    l\")] = alphabet[alphabet.index(\"m\") + 1] + alphabet[alphabet.index(\"l\")]\n\
    \    # >>> alphabet\n    # >>> \"abcdefghijklmnopqrstuvwxyz\"\n    \n    # Shift\
    \ the letters by two, wrapping to beginning\n    # of the alphabet if the first\
    \ letter is rotated\n    rotate_letters=\"\"\n    \n    # Get the first letter\n\
    \    letter=$1\n    \n    # Do the shifting\n    # >>> alphabet[alphabet.index(\"\
    f\")] = alphabet[alphabet.index(\"e\") - 2] + alphabet[alphabet.index(\"f\")]\n\
    \    rotate_letters+=\"e\"\n    rotate_letters+=\"h\"\n    rotate_letters+=\"\
    j\"\n    rotate_letters+=\"l\"\n    rotate_letters+=\"m\"\n    rotate_letters+=\"\
    n\"\n    rotate_letters+=\"o\"\n    rotate_letters+=\"p\"\n    rotate_letters+=\"\
    q\"\n    rotate_letters+=\"r\"\n    rotate_letters+=\"s\"\n    rotate_letters+=\"\
    t\"\n    rotate_letters+=\"u\"\n    rotate_letters+=\"v\"\n    rotate_letters+=\"\
    w\"\n    rotate_letters+=\"x\"\n    rotate_letters+=\"y\"\n    rotate_letters+=\"\
    z\"\n    rotate_letters+=\"a\"\n    rotate_letters+=\"b\"\n    rotate_letters+=\"\
    c\"\n    rotate_letters+=\"d\"\n    rotate_letters+=\"e\"\n    rotate_letters+=\"\
    f\"\n    rotate_letters+=\"g\"\n    rotate_letters+=\"h\"\n    rotate_letters+=\"\
    i\"\n    rotate_letters+=\"j\"\n    rotate_letters+=\"k\"\n    rotate_letters+=\"\
    l\"\n    rotate_letters+=\"m\"\n    rotate_letters+=\"n\"\n    rotate_letters+=\"\
    o\"\n    rotate_letters+=\"p\"\n    rotate_letters+=\"q\"\n    rotate_letters+=\"\
    r\"\n    rotate_letters+=\"s\"\n    rotate_letters+=\"t\"\n    rotate_letters+=\"\
    u\"\n    rotate_letters+=\"v\"\n    rotate_letters+=\"w\"\n    rotate_letters+=\"",
  "  local string=\"$1\"\n\n  # The array containing the alphabet needs to be rotated\
    \ \n  # two places so that each letter is shifted down by two multiplied\n  #\
    \ by two and then added to the previous.\n  local alphabet=(a b c d e f g h i\
    \ j k l m n o p q r s t u v w x y z)\n  local result=\"\"\n\n  # Iterate through\
    \ the string and perform each character encryption\n  local i\n  for (( i=0; i<${#string[@]};\
    \ ++i )); do\n    local char=${string[i]}\n    local char_next=${string[i+1]}\n\
    \    local char_prev=${string[i-1]}\n\n    # The index of the character in the\
    \ alphabet array in the \n    # rotated alphabet array is equal to the index of\
    \ the rotated\n    # alphabet array minus the index of the character. Since the\n\
    \    # alphabet is rotated two places each letter index will be\n    # multiplied\
    \ by two and then added to the previous. If the current\n    # character is equal\
    \ to the last character in the string, the\n    # index will be equal to the length\
    \ of the rotated alphabet. Since\n    # the alphabet is rotated two places then\
    \ the result will either\n    # be two or four characters long, depending on whether\
    \ there are\n    # two or four characters to shift. \n    result+=\"${alphabet[$((\
    \ $(( ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) )) + ( ${alphabet[$((\
    \ ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) ])} )]}\"\n\n   \
    \ # Shift the letters down by two multiplied by two. The first letter\n    # is\
    \ shifted down by 2 by multiplying it by two. Since the previous\n    # letter\
    \ was shifted by two, two plus two equals four.\n    result+=\"${alphabet[$((\
    \ ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) + ${alphabet[$((\
    \ ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) ])} * 2]}\"\n\n \
    \   # Add the character to the next letter. Two plus two equals four.\n    result+=\"\
    ${alphabet[$(( ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) + ${alphabet[$((\
    \ ${alphabet[$(( ${#alphabet[@]} - 1 )) % ${#alphabet[@]} )) ])} * 2 + 1]}\"\n\
    \n    # Add the character to the previous letter. The previous letter is\n   \
    \ # shifted by two by adding it to the previous ", "  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  local string=\"$1\"\n  local output=\"\"\n  local index=0\n  local nextIndex=0\n\
    \  local shiftedIndex=0\n  local lastIndex=0\n  local temp=\"\"\n  local num\n\
    \  local i\n  \n  while [ \"$string\" != \"\" ]; do\n    num=${string:0:1}\n \
    \   string=${string:1}\n    \n    # shift down the letters\n    shiftedIndex=$((\
    \ index + 2 ))\n    \n    if [ \"$shiftedIndex\" -lt \"$lastIndex\" ] \n    then\n\
    \      # We need to shift down past the last letter\n      lastIndex=$shiftedIndex\n\
    \      temp=${alphabet:$shiftedIndex:1}\n      output=\"$output$temp\"\n    fi\n\
    \    \n    index=$(( index + 1 ))\n    nextIndex=$(( index + 1 ))\n    \n  done\n\
    \  \n  output=\"$output$alphabet:$lastIndex:1\"\n  output=\"$output$alphabet:0:$((\
    \ lastIndex + 1 ))\"\n  \n  # shift up the letters\n  shiftedIndex=$(( index +\
    \ 2 ))\n  \n  if [ \"$shiftedIndex\" -lt \"$lastIndex\" ] \n  then\n    # shift\
    \ up past the final letter\n    lastIndex=$shiftedIndex\n    temp=${alphabet:$lastIndex:1}\n\
    \    output=\"$output$temp\"\n  fi\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  \n  output=\"$output$alphabet:$lastIndex:1\"\
    \n  output=\"$output$alphabet:0:$(( lastIndex + 1 ))\"\n  ", "    local str=$1\n\
    \    local chars=abcdefghijklmnopqrstuvwxyz\n    local temp=\"\"\n    local i\n\
    \    for ((i=0; i<${#str}; i++))\n    do\n        temp=${chars:$i:$((i+2))}\n\
    \        echo ${temp}\n    done", "    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    character=$1\n    length=${#character}\n    # Rotate the character\n   \
    \ # Character 'a' rotates 1 space to the left (alphabet rotates 1 space to the\
    \ left)\n    # Character 'z' rotates 26 spaces to the left (alphabet rotates 26\
    \ spaces to the left)\n    character=$((character+${alphabet}%26))\n    character=$((character+${alphabet}%26))\n\
    \    \n    # Output the string\n    echo \"${alphabet:$character:2}${alphabet:$((character+26)):1}\"",
  "  local str=\"$1\" \n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local count=\"\
    ${#alphabet}\"\n  local index=0\n  local result\n  local i\n\n  for (( i=0; i\
    \ < ${#str}; i++ )); do\n    result=\"${result}${alphabet:$index:1}\"\n    index=$((\
    \ $index + 2 ))\n  done\n  echo \"$result\"", "  local encrypted=\"\"\n  while\
    \ [ $1 ]; do\n    encrypted+=$1 \n    shift\n  done\n  echo \"$encrypted\"", " \
    \ # This code solves the problem of rotating characters\n  # The code first checks\
    \ if the string is empty, if it is, return empty string\n  if [ -z \"$1\" ]; then\
    \ return 1; fi\n  # This variable will hold the current letter of the alphabet\n\
    \  # For example the first letter is 'a', then 'a' will be appended to 'a'\n \
    \ # This variable will start with the alphabet and will be rotated down\n  temp=${1}\n\
    \  # This variable will hold the alphabet after rotating\n  alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n  # This loop will run until the length of the string is 0\n  while [ -z \"\
    $temp\" ]; do\n    temp=\"${alphabet}\"\n    alphabet=${alphabet:0:1}${alphabet:1:2}${alphabet:2:3}${alphabet:3:4}${alphabet:5:6}${alphabet:6:7}${alphabet:7:8}${alphabet:8:9}${alphabet:9:10}\n\
    \  done\n  # This loop will run until the length of the string is 1 \n  while\
    \ [ -z \"$temp\" ]; do\n    temp=\"${alphabet}\"\n    alphabet=${alphabet:0:1}${alphabet:1:2}${alphabet:2:3}${alphabet:3:4}${alphabet:5:6}${alphabet:6:7}${alphabet:7:8}${alphabet:8:9}${alphabet:9:10}\n\
    \  done\n  # This loop will run until the length of the string is 2\n  while [\
    \ -z \"$temp\" ]; do\n    temp=\"${alphabet}\"\n    alphabet=${alphabet:0:1}${alphabet:1:2}${alphabet:2:3}${alphabet:3:4}${alphabet:5:6}${alphabet:6:7}${alphabet:7:8}${alphabet:8:9}${alphabet:9:10}\n\
    \  done\n  # This loop will run until the length of the string is 3\n  while [\
    \ -z \"$temp\" ]; do\n    temp=\"${alphabet}\"\n    alphabet=${alphabet:0:1}${alphabet:1:2}${alphabet:2:3}${alphabet:3:4}${alphabet:5:6}${alphabet:6:7}${alphabet:7:8}${alphabet:8:9}${alphabet:9:10}\n\
    \  done\n  # This loop will run until the length of the string is 4\n  while [\
    \ -z \"$temp\" ]; do\n    temp=\"${alphabet}\"\n    alphabet=${alphabet:0:1}${alphabet:1:2}${alphabet:2:3}${alphabet:3:4}${alphabet:5:6}${alphabet:6:7}${alphabet:7:8",
  "    ROTATED_ALPHABET=$(echo \"$1\" | sed 's/^\\(.\\)\\(.\\)\\(.\\)\\(.*\\)\\(.*\\\
    )$/\\2\\3\\4\\5\\1\\6/')\n    echo \"$ROTATED_ALPHABET\"", "    local alphabet=\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    local key=$((26));\n\
    \    local alphabetLength=${#alphabet};\n\n    local output=\"\";\n    while [\
    \ -n \"$1\" ]; do\n        local c=${alphabet:$(( $(( $1 + $key ) % $alphabetLength\
    \ ))):0:1};\n        local i=$(( $1 + $key / $alphabetLength ));\n        local\
    \ newChar=${alphabet:$(( $i % $alphabetLength ))};\n        output=\"$output$c$newChar\"\
    ;\n        shift;\n    done;\n    output=\"${output:0:1}\";\n\n    echo $output;",
  "    local encrypted=''\n\n    # Loop over all the characters in the string and\
    \ add the encrypted\n    # version to the encrypted variable\n    for ((i=0;i<=$1;i++))\n\
    \    do\n        encrypted+=$(( $(( (65 - $i) % 26 )) % 26 + 65 ))\n    done\n\
    \n    # Return the encrypted string\n    echo $encrypted", "    local string=$1\n\
    \    local alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \    local newstring\n    local count=0\n    for c in $string\n    do\n      \
    \  local newcount=0\n        for j in $alphabet\n        do\n            newcount=$((newcount+1))\n\
    \            if [ $newcount -eq 3 ]\n            then\n                newcount=0\n\
    \                ((count++))\n            fi\n            newstring+=$j\n    \
    \    done\n    done\n    echo \"$newstring\"", "    local STR=$1\n    local CHARS=${STR}\n\
    \    local LETTERS=\"\"\n    local LETTERS_CASE=\"\"\n    local INDEX=0\n    \n\
    \    # Get the individual characters of STR\n    for I in ${STR}; do\n       \
    \ LETTERS+=\"${CHARS[INDEX]}\"\n        INDEX=$((INDEX+1))\n    done\n    \n \
    \   # Rotate each character by the number that corresponds to each character\n\
    \    ROTATE=0\n    for I in ${LETTERS}; do\n        ROTATE=$((${ROTATE}+1))\n\
    \        LETTERS_CASE+=\"${LETTERS:$I}:${LETTERS:$((I+ROTATE)):1}\"\n        ROTATE=$((${ROTATE}-1))\n\
    \    done\n    \n    # Return the rotated string as a string\n    echo \"${LETTERS_CASE}\"",
  "    local string=\"$1\"\n\n    local letter\n    local letterCount\n    local newLetter\n\
    \    local newLetterCount\n    local newString\n    local newStringCount\n   \
    \ local stringCount\n    local stringShiftDownCount\n    local stringShiftUpCount\n\
    \n    stringCount=${#string}\n    stringShiftDownCount=0\n    stringShiftUpCount=0\n\
    \    newStringCount=0\n    newString=\"\"\n    letterCount=0\n    letter=\"\"\n\
    \    \n    \n    while [ ${stringCount} -gt 0 ]; do\n        if [ ${letterCount}\
    \ -gt ${#LETTERS} ]; then\n            letter=${LETTERS[${letterCount}]}\n   \
    \         letterCount=0\n        else\n            letter=${LETTERS[${letterCount}]}\n\
    \            letterCount=$(( letterCount + 1 ))\n        fi\n        \n      \
    \  if [ ${letterCount} -eq ${#LETTERS} ]; then\n            letter=${LETTERS[${#LETTERS}-1]}\n\
    \            letterCount=0\n        fi\n        \n        newLetter=\"${letter%?}\"\
    \n        \n        \n        if [ ${newStringCount} -gt ${#LETTERS} ]; then\n\
    \            newLetter=\"${LETTERS[${newStringCount}]}\"\n            newStringCount=0\n\
    \        fi\n        \n        newString=\"${newString}${newLetter}\"\n      \
    \  newStringCount=$(( newStringCount + 1 ))\n        \n        if [ ${newStringCount}\
    \ -eq ${#LETTERS} ]; then\n            newString=\"${LETTERS[${#LETTERS}-1]}\"\
    \n            newStringCount=0\n        fi\n        \n        stringCount=$((\
    \ stringCount - 1 ))\n    done\n    \n    if [ ${stringCount} -eq 0 ]; then\n\
    \        echo \"${newString}\"\n    else\n        echo \"${newString}\"\n    fi",
  "    # Initialize the alphabet\n    local alphabet=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    # Initialize the string\n    local string=\"$1\"\n    # Initialize the result\
    \ string \n    local result=\"\"\n    # Initialize the index\n    local index=0\n\
    \    # Go through each character in the string\n    while [ ${#string} -gt 0 ];\
    \ do\n        # Add in the appropriate number of characters in the alphabet\n\
    \        result=\"${result}${alphabet:(($index)*2):2}${string:(($index)*2+1):1}\"\
    \n        index=$((index+1))\n    done\n    # Return the result\n    echo \"$result\"",
  "  local string=$1\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local encrypted=\"\
    \"\n\n  for c in $(echo $string | sed -e 's/\\(.\\)/\\1/g'); do\n    encrypted=\"\
    $encrypted${alphabet:$((${#alphabet}-2))}:$c\"\n  done\n  echo $encrypted", " \
    \ local str=\"$1\"\n  local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n  local num=${#str}\n\
    \  local rot=\"\"\n  local i\n  for ((i = 0; i < num; i++)); do\n    local key=${alphabet:$i:$((i+1)):1}\n\
    \    local idx=$((alphabet ${#alphabet} - $key))\n    local t=$((idx + key%${#alphabet}))\n\
    \    rot=\"${rot}${alphabet:$t:1}\"\n  done\n  echo \"$rot\"", "    local string=\"\
    $1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local encrypted=\"\
    \"\n    # Go through the string one character at a time.\n    for (( i=0; i<${#string};\
    \ i++ )); do\n        # The current character should be saved.\n        original=${string:$i:1}\n\
    \        # If there is an original character, \n        # it should be added to\
    \ the final string.\n        if [ -n \"${original}\" ]; then\n            local\
    \ index=${alphabet:$(( ${#alphabet} - ${#original} - 2 )):1}\n            local\
    \ shifted=${alphabet:$(( ${#alphabet} - ${#original} - 2 )):$(( ${#alphabet} -\
    \ ${#original} - 2 ))]\n            encrypted+=\"${index}${shifted}\"\n      \
    \  fi\n    done\n    echo \"${encrypted}\"", "  alphabet=(a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z)\n  result=$1\n  for alphabet in $(encrypt $2)\n\
    \  do\n    result=${result:0:1}${alphabet:2}${result:1}\n  done\n  echo \"$result\"",
  "    local alphabet=\"$1\"\n    local shift=2\n    local string=${2:-}\n    local\
    \ encrypted=\"\"\n    for i in $string; do\n        encrypted=\"$encrypted$(($((${#alphabet}+1)-${#i})${alphabet}${i:0:1}))\"\
    \n    done\n    echo \"$encrypted\"", "    local encrypted_string=\"\"\n    local\
    \ current_letter=\"\"\n    local next_letter=\"\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\
    \n    local i\n    local j\n    for i in $*; do\n        # Set the current letter\
    \ equal to the current letter in the \n        # alphabet and increment the index\
    \ by one\n        current_letter=$alphabet[i]\n        ((i++))\n        # Set\
    \ the next letter equal to the next letter in the \n        # alphabet and increment\
    \ the index by one\n        next_letter=$alphabet[j]\n        ((j++))\n      \
    \  # Add the current letter to the encrypted string with the \n        # encrypted\
    \ string ending with a newline\n        encrypted_string=$encrypted_string$current_letter\n\
    \        encrypted_string=$encrypted_string$next_letter\n        encrypted_string=$encrypted_string$'\\\
    n'\n        # Clear the current letter and the next letter variables\n       \
    \ current_letter=\"\"\n        next_letter=\"\"\n    done\n    echo $encrypted_string",
  "    # Initialize variable\n    alphabet=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    # Create a variable called encrypted that holds the encrypted \n    # string\
    \ and initialize it with the empty string\n    encrypted=\"\"\n\n    # If the\
    \ first character of the input string is an uppercase \n    # letter, remove the\
    \ first letter of the input string. \n    # For example: $(encrypt \"gf\")\n \
    \   # >>> gf\n    # >>> $(encrypt \"gf\")\n    # >>> e\n    # >>> $(encrypt \"\
    gf\")\n    # >>> k\n    \n    # If the first character of the input string is\
    \ a lowercase \n    # letter, remove the first letter of the input string. \n\
    \    # For example: $(encrypt \"gf\")\n    # >>> gf\n    # >>> $(encrypt \"gf\"\
    )\n    # >>> g\n    # >>> $(encrypt \"gf\")\n    # >>> f\n    \n    # If the first\
    \ character of the input string is a digit, \n    # remove the first letter of\
    \ the input string. \n    # For example: $(encrypt \"gf\")\n    # >>> gf\n   \
    \ # >>> $(encrypt \"gf\")\n    # >>> g\n    # >>> $(encrypt \"gf\")\n    # >>>\
    \ f\n    \n    # If the first character of the input string is a special \n  \
    \  # character, remove the first letter of the input string. \n    # For example:\
    \ $(encrypt \"gf\")\n    # >>> gf\n    # >>> $(encrypt \"gf\")\n    # >>> g\n\
    \    # >>> $(encrypt \"gf\")\n    # >>> f\n    \n    # If the first character\
    \ of the input string is a whitespace \n    # character, remove the first letter\
    \ of the input string. \n    # For example: $(encrypt \"gf\")\n    # >>> gf\n\
    \    # >>> $(encrypt \"gf\")\n    # >>> g\n    # >>> $(encrypt \"gf\")\n    #\
    \ >>> f\n    \n    # Add the first letter of the input string to the \n    # encrypted\
    \ string. \n    # For example: $(encrypt \"gf\")\n    # >>> gf\n    # >>> $(encrypt\
    \ \"gf\")\n    # >>> g\n    # >>> $(encrypt \"gf\")\n    # >>> f\n    \n    #\
    \ Add \"a\" to the encrypted string. \n    # For example: $(encrypt \"gf\")\n\
    \    # >>> gf\n    # >>> $(encrypt \"gf\")\n    # >>> g\n    # >>> $(encrypt \"\
    gf\")\n    # >>> f\n    \n    # Add \"b\" to the encrypted string. \n    # For\
    \ example: $(encrypt \"gf\")\n    # >>> gf\n    # >>> $(encrypt \"gf\")\n    #\
    \ >>> g\n    # >>> $(encrypt \"", "    local alpha=$1\n    local count=1\n   \
    \ local string=$2\n    local result\n    \n    while [ \"$string\" != \"\" ];\
    \ do\n        \n        local current_letter=${string:0:1}\n        \n       \
    \ # Rotate every other letter by two places. \n        if [ \"$count\" -eq 1 ];\
    \ then\n            current_letter=$(echo \"$current_letter\" | sed 's/./\\U&/g')\n\
    \        fi\n        \n        local new_letter=$(echo $current_letter | sed 's/\\\
    (.\\)/\\U\\1/')\n        \n        result=\"${result}${new_letter}\"\n       \
    \ \n        string=$(echo $string | sed \"s/$current_letter/$new_letter/\")\n\
    \        \n        (( count++ ))\n    done\n    \n    echo \"$result\"", "   \
    \ local string=$1\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n\n    local\
    \ encrypted=\"\"\n    while [ \"$string\" != \"\" ]; do\n        local first_letter=${string:0:1}\n\
    \        local last_letter=${string:${#string}}\n        encrypted=\"$encrypted${alphabet:$((first_letter\
    \ + first_letter % 26)):2}${alphabet:$((last_letter - last_letter % 26)):2}\"\n\
    \        string=${string#*$last_letter}\n    done\n    echo \"$encrypted\"", " \
    \   # Define variables and assign defaults values\n    shift\n    alphabet=\"\
    abcdefghijklmnopqrstuvwxyz\"\n    result=\"${alphabet:0:1}${alphabet:1:1}${alphabet:2:1}${alphabet:3:1}${alphabet:4:1}${alphabet:5:1}${alphabet:6:1}${alphabet:7:1}\"\
    \n\n    # Iterate through each character in $1\n    for (( i=0; i < ${#1}; i++\
    \ )); do\n        # Swap character at index $i with character at index $(($i+2))\n\
    \        alphabet=\"${alphabet:0:i}${alphabet:i+2}${alphabet:(i+3):1}\"\n    done\n\
    \n    # Return encrypted string\n    echo \"${result}\"", "  local str=\"$1\"\n\
    \  # Convert string to lower case.\n  str=\"$(echo \"$str\" | tr '[:lower:]' '[:upper:]')\"\
    \n  # Create an empty string.\n  result=''\n  # Iterate through the string.\n\
    \  for ((i = 0; i < ${#str}; i++)); do\n    # Save the first character.\n    first=${str:$i:1}\n\
    \    # Get the last character and save it.\n    last=${str:$((i+1)):1}\n    #\
    \ Move the first character down the alphabet by 2\n    # to move down by 2 each\
    \ time. \n    first+=\"${first:2}\"\n    # Move the last character down the alphabet\
    \ by 2\n    # to move down by 2 each time. \n    last+=\"${last:2}\"\n    # If\
    \ the first two letters are the same, then the\n    # last two letters are the\
    \ same and so on. \n    if [[ \"${first,,}\" == \"${last,,}\" ]]; then\n     \
    \ # Add two spaces.\n      first+=\" \"\n      last+=\" \"\n    fi\n    # Add\
    \ the letter to the result string.\n    result+=\"${first}\"\n    result+=\"${last}\"\
    \n  done\n  # Return the result string.\n  echo \"$result\"", "        local string=$1\n\
    \        local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n        local tmp=\"\"\
    \n\n        for i in ${string//[!a-z]/*}; do\n                tmp=${alphabet:0:${#alphabet}-2}\n\
    \                alphabet=${alphabet:${#alphabet}-2}\n                alphabet+=\"\
    x\"\n                tmp+=\"${alphabet:1:${#alphabet}-1}\"\n                alphabet=${alphabet:1:${#alphabet}-1}\n\
    \                alphabet+=\"${alphabet:0:1}\"\n                alphabet+=\"${alphabet:${#alphabet}-1:1}\"\
    \n                tmp+=\"${tmp,,}\"\n                alphabet=${alphabet:1:${#alphabet}-1}\n\
    \                alphabet+=\"${alphabet:0:1}\"\n                alphabet+=\"${alphabet:${#alphabet}-1:1}\"\
    \n                tmp+=\"${alphabet:1:${#alphabet}-1}\"\n                alphabet=${alphabet:0:${#alphabet}-2}\n\
    \                alphabet+=\"${alphabet:1:${#alphabet}-2}\"\n                alphabet+=\"\
    ${alphabet:0:${#alphabet}-2}\"\n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\
    \n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\n               \
    \ tmp+=\"${alphabet:0:${#alphabet}-2}\"\n                alphabet+=\"${alphabet:1:${#alphabet}-2}\"\
    \n                alphabet+=\"${alphabet:0:${#alphabet}-2}\"\n               \
    \ alphabet+=\"${alphabet:${#alphabet}-2:1}\"\n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\
    \n                tmp+=\"${alphabet:0:${#alphabet}-2}\"\n                alphabet+=\"\
    ${alphabet:1:${#alphabet}-2}\"\n                alphabet+=\"${alphabet:0:${#alphabet}-2}\"\
    \n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\n               \
    \ alphabet+=\"${alphabet:${#alphabet}-2:1}\"\n                tmp+=\"${alphabet:0:${#alphabet}-2}\"\
    \n                alphabet+=\"${alphabet:1:${#alphabet}-2}\"\n               \
    \ alphabet+=\"${alphabet:0:${#alphabet}-2}\"\n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\
    \n                alphabet+=\"${alphabet:${#alphabet}-2:1}\"\n               \
    \ tmp+=\"${alphabet:0:${#alphabet}-2}\"\n                alphabet+=\"${alphabet:1:${#alphabet}-2}\"\
    \n                alphabet+=\"${alphabet:0:${#alphabet}-2}\"\n", "    local str=\"\
    $1\"\n    local alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    local new_alphabet=\"\
    \"\n    local count\n    local output\n    local i\n\n    # Create a dictionary\
    \ to hold the key value pairs of the alphabet\n    for k in \"${alphabet}\"; do\n\
    \        new_alphabet+=\"$k$k\"\n    done\n\n    count=0\n    while [ $count -lt\
    \ $((${#str}-1)) ]; do\n        # Set the i-th letter to upper case and add it\
    \ to our new alphabet\n        output=\"${new_alphabet:0:2}\"\n        output+=\"\
    $(echo ${str:$count} |\n            tr '[:upper:]' '[:lower:]')\"\n        output+=\"\
    $(echo ${str:$((count+1))} |\n            tr '[:upper:]' '[:lower:]')\"\n\n  \
    \      # Increment the count by two\n        count=$((count+2))\n\n        # Append\
    \ the result to our dictionary\n        new_alphabet+=\"$output\"\n    done\n\n\
    \    # Return the output using the new alphabet\n    echo ${new_alphabet}", " \
    \ echo \"$1\" | tr abcdefghijklmnopqrstuvwxyz \"$(\n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyz'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyza'\
    \ 'abcdefghijklmnopqrstuvwxyzb' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvwxyzb'\
    \ 'abcdefghijklmnopqrstuvwxyza' | \n      echo \"$1\" | tr 'abcdefghijklmnopqrstuvw",
  "  local string=$1\n  local alphabet='abcdefghijklmnopqrstuvwxyz'\n  local rotated=''\n\
    \  local length=${#string}\n\n  while [ ${#string} -gt 0 ]; do\n    local index=${#alphabet}-1\n\
    \    local letter=${string:$((${#string}-${#alphabet}+1))}\n    rotated=${alphabet:$index:${alphabet:$index:${#alphabet}}}${rotated}\n\
    \    length=$((${#string} - ${#rotated}))\n    string=${string:0:${#string}-${#rotated}}\n\
    \  done\n\n  echo ${rotated:0:${#alphabet}}", "  # Get string to be encrypted\n\
    \  string=$1\n  # Encrypt with ROT13 where each letter is shifted down by two\n\
    \  echo $(echo $string | sed 's/./& /g' | sed 's/ /+/g' | sed 's/./& /g' | awk\
    \ '{print tolower($0)}'  | sed 's/./ /g' | sed 's/./& /g' | awk '{print tolower($0)}'\
    \  | sed 's/./ /g' | sed 's/./& /g' | awk '{print tolower($0)}') | sed 's/./&\
    \ /g' | sed 's/ /+/g' | sed 's/./& /g' | awk '{print tolower($0)}'  | sed 's/./\
    \ /g' | sed 's/./& /g' | awk '{print tolower($0)}') | sed 's/./ /g' | sed 's/./&\
    \ /g' | awk '{print tolower($0)}'", "    local encrypted=\n    local alphabet=\n\
    \    local i=\n    local j=\n    local result=''\n    local n=$#\n    # Make sure\
    \ we got the right number of arguments.\n    if [ $n -eq 1 ]\n    then\n     \
    \   echo \"Usage: $0 string [alphabet]\"\n        return 1\n    elif [ $n -gt\
    \ 2 ]\n    then\n        echo \"Usage: $0 string [alphabet]\"\n        return\
    \ 1\n    fi\n    # Get the arguments and store them in variables.\n    shift\n\
    \    while [[ $# -gt 0 ]]\n    do\n        alphabet=\"$1\"\n        shift\n  \
    \      shift\n        encrypted=$( echo $alphabet | sed 's/\\(.*\\)/\\1\\2/g'\
    \ )\n        if [ \"$#\" -eq 0 ]\n        then\n            echo \"Usage: $0 string\
    \ [alphabet]\"\n            return 1\n        fi\n    done\n    # Make an alphabet\
    \ by rotating it twice.\n    alphabet=$(echo $alphabet | sed 's/\\(.*\\)/\\1/g'\
    \ )\n    alphabet=$(echo $alphabet | sed 's/\\(.\\)\\(.*\\)/\\2\\1/g' )\n    #\
    \ Get the length of the string.\n    length=$(echo $encrypted | wc -w)\n    #\
    \ Loop through the string. Starting at index 0, loop through each \n    # character\
    \ by taking a character, then adding one to the index, and \n    # then adding\
    \ that character to the result variable. \n    for ((i = 0; $i < $length; i++\
    \ ))\n    do\n        # get the character at index i\n        char=`echo $encrypted\
    \ | sed 's/\\(.*\\)/\\1/'`\n        # Add the character at index i to the result\
    \ variable\n        result=\"${result}${char}\"\n    done\n    # return the result\
    \ variable.\n    echo \"$result\"\n    return 0", "    local temp=\"$1\"\n   \
    \ local key=\"\"\n    local strlen=${#temp}\n    local i\n\n    key=$(perl -e\
    \ 'print map {chr($_)} $ARGV[0]' \"$key\")\n    \n    for ((i=0;i<strlen-1;i++));\
    \ do\n        echo \"${temp:$i:2}${key:$((i+1)):2}${temp:$(($i+1)):2}\"\n    done",
  "    local STRING=$1\n    local LETTERS=abcdefghijklmnopqrstuvwxyz\n    local LETTERS2=`echo\
    \ $LETTERS | sed 's/\\(.\\)\\(.\\)/\\1\\2/g'`\n    local LETTERS2\n    local ROTATED=\"\
    \"\n    for L in $LETTERS; do\n        ROTATED=$ROTATED$L\n    done\n    for L\
    \ in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2;\
    \ do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n     \
    \   ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n\
    \    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n\
    \    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in\
    \ $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2;\
    \ do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n     \
    \   ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n\
    \    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n\
    \    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in\
    \ $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2;\
    \ do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n     \
    \   ROTATED=$ROTATED$L\n    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n\
    \    done\n    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n\
    \    for L in $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in\
    \ $LETTERS2; do\n        ROTATED=$ROTATED$L\n    done\n    for L in $LETTER"]
stop_tokens:
- "\n}"
