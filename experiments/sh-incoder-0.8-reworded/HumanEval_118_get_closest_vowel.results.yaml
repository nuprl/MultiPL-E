language: sh
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal string=$1\n\
    \tlocal vowels=$(echo \"${string}\" | tr \"a-z\" \"A-Z\")\n\tlocal consonants=$(echo\
    \ \"${string}\" | tr \"A-Z\" \"a-z\")\n\tfor vowel in $vowels; do\n\t\tlocal consonants_count=$(echo\
    \ $consonants | grep -c \"$vowel\")\n\t\tlocal consonants_count_1=$(echo $consonants\
    \ | awk '{print $1}' | grep -c \"$vowel\")\n\t\tif [[ \"$consonants_count\" -eq\
    \ \"$consonants_count_1\" ]]; then\n\t\t\techo \"$vowel\"\n\t\t\tbreak\n\t\telse\n\
    \t\t\techo \"$vowel\"\n\t\tfi\n\tdone\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    vowels=($(echo\
    \ '$1' | tr [a-z] [A-Z]))\n    vowel_chars=($(echo '$1' | tr [A-Z] [A-Z][a-z]))\n\
    \    vowel_chars=$(echo $vowel_chars | tr [a-z] [A-Z])\n    for ((i=0; i<${#vowels[@]};\
    \ i++)); do\n        ((ii=${#vowel_chars[@]})-1)\n        for ((j=0; j<${#vowel_chars[@]};\
    \ j++)); do\n            if [[ \"$i\" -eq \"$j\" ]]; then\n                break\n\
    \            fi\n            if [ \"$vowel_chars\" == \"$vowel_chars\" ]; then\n\
    \                break\n            fi\n            if [[ \"$i\" -eq \"$((j+1)-1)\"\
    \ ]]; then\n                break\n            fi\n            if [[ \"$vowel_chars\"\
    \ == \"$vowel_chars\" ]]; then\n                break\n            fi\n      \
    \      if [[ \"$i\" -eq \"$ii+1\" ]]; then\n                break\n          \
    \  fi\n            if [[ \"$vowel_chars\" == \"$vowel_chars\" ]]; then\n     \
    \           break\n            fi\n            if [[ \"$i\" -eq \"$((ii+1))\"\
    \ ]]; then\n                break\n            fi\n            if [[ \"$vowel_chars\"\
    \ == \"$vowel_chars\" ]]; then\n                break\n            fi\n      \
    \      if [[ \"$i\" -eq \"$ii\" ]]; then\n                break\n            fi\n\
    \        done\n        if [[ \"$j\" -eq \"$((j+1))\" ]]; then\n            break\n\
    \        fi\n    done\n    if [[ \"$j\" -ge 0 ]]; then\n        echo $vowels[0]\n\
    \    else\n        echo $\"\"\n    fi\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp80ta1937.sh: line 23: syntax error near unexpected token `-1''

    /tmp/tmp80ta1937.sh: line 23: `        ((ii=${#vowel_chars[@]})-1)''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal string=$1\n\
    \tlocal vowels=\"a e i o u A\"\n\tfor (( i=1; i<${#string}; i++ )); do\n\t\tlocal\
    \ vowel=${vowels:i:1}\n\t\tif [[ ${string[$i]} == ${vowel} ]]; then\n\t\t\techo\
    \ \"${vowel}\"\n\t\t\treturn ${vowel}\n\t\tfi\n\tdone\n\treturn \"\"\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpms8jb0kk.sh: line 28: return: : numeric argument required

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: -1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local vowel=\"\
    [aeiouAEIOU]\"\n    local consonant=\"[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\"\
    \n    local left=\"$1\"\n    local right=\"${1:0:${#left}}\"\n    local i=${#right}\n\
    \    local vowels=${vowel}\n    local consonants=${consonant}\n    while [ ${i}\
    \ -gt 0 ]; do\n        local index=0\n        for (( i=1; i<${#right}; i++ ));\
    \ do\n            if [[ ${right:$i:1} == ${consonants} ]]; then\n            \
    \    index=$i\n                break\n            fi\n        done\n        if\
    \ [[ ${left} == ${vowels} ]]; then\n            echo $index\n            return\
    \ $index\n        fi\n        if [[ ${left} == ${consonants} ]]; then\n      \
    \      echo $index\n            return $index\n        fi\n        (( i-- ))\n\
    \    done\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") =\
    \ \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\"\
    ) = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\"\
    ) = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=22 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=13 encoding='utf-8'>
  timestamp: 1660055188
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local str=\"\
    $1\"\n  local vowels=\"aeiouAEIOU\"\n\n  for vowel in $vowels; do\n    local vowel_pos=\"\
    $((${str}.length - ${#vowel} - 1))\"\n    local vowel_start_index=\"$((${str}.length\
    \ - 1))\"\n\n    # find the vowel from the right side of the word (case sensitive)\n\
    \    local index=\"$((${vowel_pos} + 1))\"\n    if [ \"${str:$index:1}\" == \"\
    ${vowel}\" ]; then\n      echo \"$vowel\"\n      break\n    fi\n\n    # find the\
    \ vowel from the left side of the word (case sensitive)\n    local index_back=\"\
    $((${vowel_start_index} - 1))\"\n    if [ \"${str:$index_back:1}\" == \"${vowel}\"\
    \ ]; then\n      echo \"$vowel\"\n      break\n    fi\n  done\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpd3u9x7_5.sh: line 23: yogurt.length - 10 - 1: syntax error: invalid
    arithmetic operator (error token is ".length - 10 - 1")

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local vowels=\"\
    aeiouyAEIOUY\"\n  local c=${1:0:1}\n  local s=${1:1:1}\n  local v=${vowels:$c:$c}\n\
    \  [[ \"$s\" = \"z\" ]] && { [[ ${#s} -le 1 ]] && return \"\"; }\n  local w=${vowels:$s:$s}\n\
    \  [[ \"$w\" = \"z\" ]] && return \"\"\n  [[ \"$v\" = \"$w\" ]] && return $v\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal vowel_arr=(\"\
    a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal consonant_arr=(\"b\" \"c\" \"d\" \"f\"\
    \ \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"r\" \"s\" \"t\" \"v\"\
    \ \"w\" \"x\" \"y\" \"z\")\n\tlocal consonant_count=${#consonant_arr[@]}\n\tlocal\
    \ consonant_count1=${#consonant_arr[@]}\n\tlocal consonant_count2=${#consonant_arr[@]}\n\
    \tlocal consonant_count3=${#consonant_arr[@]}\n\tlocal consonant_count4=${#consonant_arr[@]}\n\
    \tlocal vowel_count=${#vowel_arr[@]}\n\tlocal vowel_count1=${#vowel_arr[@]}\n\t\
    local vowel_count2=${#vowel_arr[@]}\n\tlocal vowel_count3=${#vowel_arr[@]}\n\t\
    local vowel_count4=${#vowel_arr[@]}\n\tlocal vowel_arr1=(\"A\" \"E\" \"I\" \"\
    O\" \"U\");\n\tlocal vowel_arr2=(\"a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal vowel_arr3=(\"\
    \xC0\" \"E\" \"I\" \"O\" \"U\");\n\tlocal vowel_arr4=(\"A\" \"E\" \"I\" \"O\"\
    \ \"U\");\n\tlocal vowel_arr5=(\"a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal vowel_arr6=(\"\
    A\" \"E\" \"I\" \"O\" \"U\");\n\tlocal vowel_arr7=(\"a\" \"e\" \"i\" \"o\" \"\
    u\");\n\tlocal vowel_arr8=(\"A\" \"E\" \"I\" \"O\" \"U\");\n\tlocal vowel_arr9=(\"\
    a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal vowel_arr10=(\"A\" \"E\" \"I\" \"O\" \"\
    U\");\n\tlocal vowel_arr11=(\"a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal vowel_arr12=(\"\
    A\" \"E\" \"I\" \"O\" \"U\");\n\tlocal vowel_arr13=(\"a\" \"e\" \"i\" \"o\" \"\
    u\");\n\tlocal vowel_arr14=(\"A\" \"E\" \"I\" \"O\" \"U\");\n\tlocal vowel_arr15=(\"\
    a\" \"e\" \"i\" \"o\" \"u\");\n\tlocal vowel_arr16=(\"A\" \"E\" \"I\" \"O\" \"\
    U\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaqlxxcs9.sh: line 67: unexpected EOF while looking for matching
    `"''

    /tmp/tmpaqlxxcs9.sh: line 71: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  # your code\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptkhydkqi.sh: line 20: syntax error near unexpected token `}''

    /tmp/tmptkhydkqi.sh: line 20: `}''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local vowel_1=$(grep\
    \ -o '[^AEIOUaeiou]' <<< $1 | sort -k 2r | head -1)\n  local vowel_2=$(grep -o\
    \ '[^AEIOUaeiou]' <<< $1 | sort -k 2r | tail -1)\n  echo ${vowel_1:1:${#vowel_1}-1}-${vowel_2:1:${#vowel_2}-1}\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  if [[ -z $1 ||\
    \ $1 == \"\" ]]; then\n    return 0\n  fi\n  local vowels=\"a e i o u AE II OE\
    \ UO\"\n  local c=$1\n  local i=1\n  local j=$((${#c}-1))\n  while [ \"$i\" -le\
    \ \"$j\" ]; do\n    local v=${vowels:$i:1}\n    if [[ ${c:$j:1} = $v ]]; then\n\
    \      i=$((i+1))\n      j=$((j-1))\n      ((j--))\n    else\n      if [ $i -eq\
    \ 0 ]; then\n        i=$((j+1))\n      fi\n      ((i++))\n      if [ $i -eq 0\
    \ ]; then\n        i=1\n      fi\n    fi\n  done\n  local vowel=${vowels:$i:1}\n\
    \  return $vowel\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"\
    full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp4gdx7qqj.sh: line 43: return: o: numeric argument required

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local vowels=\"\
    a\xE8\xE9\xEA\xEBi\xEE\xEFo\xF4\u0153\xF9\xFC\u014D\xFB\"\n    local input_str=$1\n\
    \    local vowel=$(echo $input_str | sed -e 's/\\(.\\)$/\\1/g')\n    echo $vowel\n\
    \    local last_consonant=$(echo $input_str | sed -e 's/.*\\(.\\)/\\1/g')\n  \
    \  local last_vowel=$(echo $last_consonant | sed -e 's/\\(.\\)$/\\1/g')\n    echo\
    \ $last_vowel\n\n    if [[ ! -z $input_str ]]; then\n        if [[ \"$last_consonant\"\
    \ = \"$vowels\" ]]; then\n            echo $last_vowel\n        else\n       \
    \     echo $last_vowel | sed -e 's/[^aeiou]//g'\n        fi\n    else\n      \
    \  echo $last_vowel\n    fi\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate\
    \ \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\techo -n \"[INFO]\
    \ Start Finding Vowel In ${1}\"\n\tlocal vowel_found_in_beginning_or_ending=false\n\
    \tlocal consonant_one_or_both_ending=false\n\tlocal consonant_one_or_both_begining=false\n\
    \tlocal vowel_on_the_left_side=false\n\tlocal consonant_one_or_both_begining_one_or_both_ending=false\n\
    \tlocal consonant_one_or_both_ending_in_the_right_side=false\n\tlocal consonant_one_or_both_ending_in_the_left_side=false\n\
    \tlocal left_side_consonant=$1\n\tlocal right_side_consonant=$(echo ${1} | sed\
    \ 's/[Ee]$//')\n\tlocal consonant_one_or_both_ending_in_the_right_side=$(echo\
    \ ${right_side_consonant} | sed 's/[Ee]$//')\n\tlocal consonant_one_or_both_ending_in_the_left_side=$(echo\
    \ ${left_side_consonant} | sed 's/[Ee]$//')\n\tlocal consonant_one_or_both_begining_one_or_both_ending=$(echo\
    \ ${left_side_consonant} | sed 's/[Cc]$//')\n\tlocal consonant_one_or_both_begining=$(echo\
    \ ${left_side_consonant} | sed 's/[Cc]$//')\n\tlocal left_side_consonant_is_a_vowel=$(echo\
    \ $consonant_one_or_both_begining | grep -iq [vV])\n\tlocal consonant_one_or_both_begining_one_or_both_ending=$(echo\
    \ $consonant_one_or_both_begining | grep -iq [vV])\n\tlocal vowel_found_in_beginning_or_ending=$(echo\
    \ $consonant_one_or_both_begining_one_or_both_ending | grep -iq [vV])\n\tlocal\
    \ vowel_found_in_beginning_or_ending_in_the_right_side=$(echo $consonant_one_or_both_ending_in_the_right_side\
    \ | grep -iq [vV])\n\tlocal vowel_found_in_beginning_or_ending_in_the_left_side=$(echo\
    \ $consonant_one_or_both_ending_in_the_left_side | grep -iq [vV])\n\tlocal vowel_on_the_left_side=$(echo\
    \ $consonant_one_or_both_begining_one_or_both_ending | grep -iq [vV])\n\tif [[\
    \ ${#left_side_consonant} != 0 ]]; then\n\t\tif [[ ${#left_side_con\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7yrgebpr.sh: line 41: unexpected token `newline'', conditional
    binary operator expected

    /tmp/tmp7yrgebpr.sh: line 41: syntax error near `}''

    /tmp/tmp7yrgebpr.sh: line 41: `}''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local i vowels\
    \ vowel vowel_i result=\"\"\n    vowels=\"a e i o u\"\n    for ((i=0;i<${#1};++i));\
    \ do\n        [[ \"${1:$i:1}\" == [[:upper:]]  ]] || continue\n        [[ \"${1:$i:1}\"\
    \ == [[:lower:]]  ]] || continue\n        vowel=\"${1:$i:1}\"\n        [[ \"${vowels:$i:1}\"\
    \ == \"$vowel\" ]] && break\n        ((i++))\n    done\n    [[ \"$i\" -gt 0 ]]\
    \ || return 0\n    vowel_i=\"${1:$i:1}\"\n    while [[ \"${vowels:$((i-1)):1}\"\
    \ == \"$vowel_i\" ]]; do\n        ((i--))\n    done\n    if [[ \"${vowels:$i:1}\"\
    \ == \"$vowel_i\" ]]; then\n        result=\"${vowels:$((i-1)):1}\"\n    fi\n\
    \    echo \"$result\"\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate\
    \ \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local vowels=\"\
    aeiou\"\n    local a=\"$1\"\n    local vowel=\"${vowels//[^[:lower:]]/}\"\n  \
    \  local vowel_index=\"$(( ${a#\"$vowel\"} ))\"\n    local vowel_offset=\"$((\
    \ ${a#$vowel} ))\"\n    local vowel_length=\"$(( ${#a} - ${vowel_index} - ${vowel_offset}\
    \ ))\"\n\n    local vowel_left=\"$(( ${a#\"$vowel\"} ))\"\n    local vowel_right=\"\
    $(( ${a#$vowel} ))\"\n\n    local offset=\"$(( ${vowel_index} - 1 ))\"\n    local\
    \ length=\"$(( ${vowel_length} - 1 ))\"\n    local vowel_left_offset=\"$(( ${a#\"\
    $vowel\"} ))\"\n    local vowel_right_offset=\"$(( ${a#$vowel} ))\"\n\n    if\
    \ [[ ${offset} -gt 0 && ${offset} -lt ${vowel_length} ]]; then\n        local\
    \ lower_offset=\"$(( ${vowel_index} - 1))\"\n        local upper_offset=\"$((\
    \ ${vowel_index} + 1 ))\"\n        local lower_length=\"$(( ${#a} - ${lower_offset}\
    \ - ${vowel_offset} ))\"\n        local upper_length=\"$(( ${#a} - ${upper_offset}\
    \ - ${vowel_offset} ))\"\n\n        local offset2=\"$(( ${offset} - 1 ))\"\n \
    \       local length2=\"$(( ${length} - 1 ))\"\n\n        local lower_offset_2=\"\
    $(( ${lower_offset} - 1))\"\n        local upper_offset_2=\"$(( ${lower_offset}\
    \ + 1 ))\"\n\n        local lower_offset_2=\"$(( ${lower_offset_2} - 1 ))\"\n\
    \        local upper_offset_2=\"$(( ${upper_offset_2} + 1 ))\"\n\n        local\
    \ offset_2=\"$(( ${offset} -1 ))\"\n        local length_2=\"$(( ${length} -1\
    \ ))\"\n\n        local offset_3=\"$(( ${offset} + 1 ))\"\n        local length_3=\"\
    $(( ${length} + 1 ))\"\n\n        local offset_4=\"$(( ${offset} + 2 ))\"\n  \
    \      local length_4=\"$(( ${length} + 2 ))\"\n\n        local offset_5=\"$((\
    \ ${offset} + 3 ))\"\n        local length_5=\"$(( ${length} + 3 ))\"\n\n    \
    \    local offset_6=\"$(( ${offset} + 4 ))\"\n        local length_6=\"$((\n}\n\
    \ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\"\
    \ ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\
    \" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"\
    a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") =\
    \ \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv0i9fk07.sh: line 62: unexpected EOF while looking for matching
    `)''

    /tmp/tmpv0i9fk07.sh: line 87: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal vowels=\"\
    a e i o u\"\n\tlocal string=${1:-}\n\tlocal vowel_count=0\n\tlocal cons_count=0\n\
    \tlocal cons_index=0\n\tlocal vowel_index=0\n\t\n\t\n\tfor vowel in ${vowels};\
    \ do\n\t\tlet vowel_count=vowel_count+1\n\tdone\n\n\tfor cons in ${string}; do\n\
    \t\tlet cons_count=cons_count+1\n\tdone\n\t\n\tif [ ${cons_count} = 0 ]; then\n\
    \t\treturn \"\"\n\tfi\n\n\tfor cons in ${string}; do\n\t\tif [ ${cons} = ${string%$cons}\
    \ ]; then\n\t\t\tcons_index=${cons_index}+1\n\t\tfi\n\tdone\n\n\tfor vowel in\
    \ ${vowels}; do\n\t\tif [ ${vowels} = ${string%$vowel} ]; then\n\t\t\tvowel_index=${vowel_index}+1\n\
    \t\tfi\n\tdone\n\n\tif [ ${cons_count} = ${cons_index} ]; then\n\t\tif [ ${vowel_count}\
    \ = ${vowel_index} ]; then\n\t\t\techo \"${vowel}\"\n\t\telse\n\t\t\techo \"${string}\"\
    \n\t\tfi\n\telse\n\t\treturn \"\"\n\tfi\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpc1iuxs5w.sh: line 40: [: yogurt: unary operator expected

    /tmp/tmpc1iuxs5w.sh: line 46: [: too many arguments

    /tmp/tmpc1iuxs5w.sh: line 46: [: too many arguments

    /tmp/tmpc1iuxs5w.sh: line 46: [: too many arguments

    /tmp/tmpc1iuxs5w.sh: line 46: [: too many arguments

    /tmp/tmpc1iuxs5w.sh: line 46: [: too many arguments

    /tmp/tmpc1iuxs5w.sh: line 58: return: : numeric argument required

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal a=\"$1\"\
    \n\tlocal b=\"x\"\n\tlocal c=\"y\"\n\tlocal d=\"z\"\n\tlocal e=\"A\"\n\tlocal\
    \ f=\"E\"\n\tlocal g=\"I\"\n\tlocal h=\"O\"\n\tlocal i=\"U\"\n\tlocal j=\"a\"\n\
    \tlocal k=\"e\"\n\tlocal l=\"i\"\n\tlocal m=\"o\"\n\tlocal n=\"u\"\n\tlocal o=\"\
    A\"\n\tlocal p=\"E\"\n\tlocal q=\"I\"\n\tlocal r=\"O\"\n\tlocal s=\"U\"\n\tlocal\
    \ t=\"y\"\n\tlocal u=\"a\"\n\tlocal v=\"e\"\n\tlocal w=\"i\"\n\tlocal x=\"o\"\n\
    \tlocal y=\"u\"\n\tlocal z=\"a\"\n\n\tlocal vowel1=\"$a\"\n\tlocal vowel2=\"$b\"\
    \n\tlocal vowel3=\"$c\"\n\tlocal vowel4=\"$d\"\n\tlocal vowel5=\"$e\"\n\tlocal\
    \ vowel6=\"$f\"\n\tlocal vowel7=\"$g\"\n\tlocal vowel8=\"$h\"\n\tlocal vowel9=\"\
    $i\"\n\tlocal vowel10=\"$j\"\n\tlocal vowel11=\"$k\"\n\tlocal vowel12=\"$l\"\n\
    \tlocal vowel13=\"$m\"\n\tlocal vowel14=\"$n\"\n\tlocal vowel15=\"$o\"\n\tlocal\
    \ vowel16=\"$p\"\n\tlocal vowel17=\"$q\"\n\tlocal vowel18=\"$r\"\n\tlocal vowel19=\"\
    $s\"\n\tlocal vowel20=\"$t\"\n\tlocal vowel21=\"$u\"\n\tlocal vowel22=\"$v\"\n\
    \tlocal vowel23=\"$w\"\n\tlocal vowel24=\"$x\"\n\tlocal vowel25=\"$y\"\n\tlocal\
    \ vowel26=\"$z\"\n\n\tlocal vowel_array=(\"$vowel1\" \"${vowel2}\" \"${vowel3}\"\
    \ \"${vowel4}\" \"${vowel5}\" \"${vowel6}\" \"${vowel7}\" \"${vowel8}\" \"${vowel9}\"\
    \ \"${vowel10}\" \"${vowel11}\" \"${vowel12}\" \"${vowel13}\" \"${vowel14}\" \"\
    ${vowel15}\" \"${vowel16}\" \"${vowel17}\" \"${vowel18}\" \"${vowel19}\" \"${vowel20}\"\
    \ \"${vowel21}\" \"${vowel22}\" \"${vowel23}\" \"${vowel24}\" \"${vowel25}\" \"\
    ${vowel26}\")\n\tlocal first_index=0\n\tlocal second_index\n}\n\ncandidate() {\n\
    \    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal word=$1\n\
    \tlocal vowels=\"a e i o u y AE II OO UU YY\"\n\tlocal vowels_len=$(echo $vowels\
    \ | wc -l)\n\tlocal count=0\n\tlocal result=\"\"\n\tlocal vowel_found\n\n\t# loop\
    \ through all vowels\n\tfor v in $vowels; do\n\t\t# loop through all characters\
    \ in word\n\t\tfor i in $word; do\n\t\t\t# count vowel position\n\t\t\tcount=$(echo\
    \ $i | awk -F '$v' '{print index($0,$0)}')\n\t\t\t# check if vowel position is\
    \ greater than zero \n\t\t\tif [ \"$count\" -gt 0 ]; then\n\t\t\t\tvowel_found=1\n\
    \t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\t# check if vowel was found\n\t\tif [ \"\
    $vowel_found\" -eq \"1\" ]; then\n\t\t\t# find closest vowel to the right\n\t\t\
    \tresult=$(echo $v | awk 'BEGIN {printf \"%c\", (index(\"$v\", $word))}')\n\t\t\
    \tbreak\n\t\tfi\n\tdone\n\n\techo $result\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local str=\"\
    $1\"\n  local len=\"${#str}\"\n  local i=1\n  local j=1\n\n  # loop until end\
    \ of string\n  while (( i < len )); do\n\n    # check if it is the last char\n\
    \    if (( i == len )); then\n      (( j=0 ))\n    else\n      (( j=1 ))\n   \
    \ fi\n\n    # check if it is a vowel\n    if [[ \"$str\" =~ '^[aeiouAEIOU].*[aeiouAEIOU]$'\
    \ ]]; then\n      echo \"$j\"\n      break\n    fi\n    (( i++ ))\n  done\n}\n\
    \ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\"\
    \ ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\
    \" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"\
    a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") =\
    \ \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n\tlocal vowels=\"\
    ${1}\"\n\tvowels=${vowels//[aeiou]/}\n\tlocal count=1\n\tlocal counts=($(echo\
    \ $vowels | awk '{print $1}'))\n\tlocal flag\n\tfor (( i=${#counts[*]} - 1; ;\
    \ )); do\n\t\tif [ $i -eq 0 ]; then\n\t\t\tbreak;\n\t\tfi\n\t\tif [[ \"$count\"\
    \ -lt \"$counts[$i]\" ]]; then\n\t\t\tflag=1\n\t\telse\n\t\t\tflag=0\n\t\tfi\n\
    \t\tlet count=$((count + 1))\n\tdone\n\tif [ \"$flag\" -eq 1 ]; then\n\t\techo\
    \ ${vowels:$(( i - 1 )):$(( i + 1 ))}\n\telse\n\t\techo \"\"\n\tfi\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpsswveaca.sh: line 35: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local string=$1\n\
    \  local vowels=\"aAeEoOuU\"\n  local vowel_count=$(echo $vowels | grep -c \"\
    ^$string\\$\")\n  if [ ${vowel_count} -eq 0 ]; then\n    return \n  fi\n  local\
    \ vowel_met_count\n  vowel_met_count=0\n  for i in $(echo $vowels | tr a-z A-Z);\
    \ do\n    if [[ $string =~ $i ]]; then\n      vowel_met_count=$((vowel_met_count\
    \ + 1))\n    fi\n  done\n  if [ ${vowel_met_count} -gt 1 ]; then\n    return \n\
    \  fi\n  local consonant_count\n  consonant_count=0\n  for i in $(echo $vowels\
    \ | tr a-z A-Z | sed 's/[0-9]//g'); do\n    if [[ $string =~ $i ]]; then\n   \
    \   consonant_count=$((consonant_count + 1))\n    fi\n  done\n  if [ ${consonant_count}\
    \ -eq 1 ]; then\n    local vowel_found_count\n    vowel_found_count=0\n    for\
    \ i in $(echo $vowels | tr a-z A-Z); do\n      if [[ $string =~ $i ]]; then\n\
    \        vowel_found_count=$((vowel_found_count + 1))\n      fi\n    done\n  \
    \  if [ ${vowel_found_count} -eq 1 ]; then\n      echo $string\n      return\n\
    \    fi\n  fi\n  local consonant_found_count\n  consonant_found_count=0\n  for\
    \ i in $(echo $vowels | tr a-z A-Z | sed 's/[0-9]//g'); do\n    if [[ $string\
    \ =~ $i ]]; then\n      consonant_found_count=$((consonant_found_count + 1))\n\
    \    fi\n  done\n  if [ ${consonant_found_count} -eq 2 ]; then\n    local vowel_found_count\n\
    \    vowel_found_count=0\n    for i in $(echo $vowels | tr a-z A-Z); do\n    \
    \  if [[ $string =~ $i ]]; then\n        vowel_found_count=$((vowel_found_count\
    \ + 1))\n      fi\n    done\n    if [ ${vowel_found_count} -eq 2 ]; then\n   \
    \   echo $string\n      return\n    fi\n  fi\n  echo $string\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local string=$1\n\
    \    local i=0 consonant_count=0\n    local vowel_count=0\n    while [ $i -le\
    \ ${#string} ]; do\n        consonant=$(expr match \"${string:$i:1}\" \".[bcdfghjklmnpqrstvwxyz]\"\
    )\n        vowel=$(expr match \"${string:$i:1}\" \".[aeiou]\")\n        if [[\
    \ $consonant == [aeiou] ]]; then \n            vowel_count=$((vowel_count+1))\n\
    \        fi\n        if [[ $consonant == [bcdfghjklmnpqrstvwxyz] ]]; then \n \
    \           consonant_count=$((consonant_count+1))\n        fi\n        i=$((i+1))\n\
    \    done\n    if [[ $vowel_count -gt 1 ]]; then \n        vowel_found=$((vowel_count-1))\n\
    \        vowel_found=$(expr expr \"${string:$i:${#vowel_found}}\"  \"${string:$((i-1))}\"\
    \ )\n        if [[ $vowel_found -gt 0 ]]; then \n            echo $vowel_found\n\
    \        fi\n    else \n        echo \"0\"\n    fi\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local x=\"\
    $1\"\n    if [ \"$x\" == \"$1\" ]; then return $x; fi\n    local y=\"$x\"\n  \
    \  while [[ \"$y\" != \"\" ]]; do\n        local z=`echo \"$y\" | sed 's/^[[:alpha:]]//g'`\n\
    \        if [[ \"$z\" == \"a\" ]]; then \n            y=$(echo \"$y\" | sed 's/[[:alpha:]]/a/g')\n\
    \            x=$x $(echo \"$y\" | sed 's/^/a/')\n        elif [[ \"$z\" == \"\
    e\" ]]; then \n            y=$(echo \"$y\" | sed 's/[[:alpha:]]/e/g')\n      \
    \      x=$x $(echo \"$y\" | sed 's/^/e/') \n        elif [[ \"$z\" == \"i\" ]];\
    \ then \n            y=$(echo \"$y\" | sed 's/[[:alpha:]]/i/g')\n            x=$x\
    \ $(echo \"$y\" | sed 's/^/i/') \n        elif [[ \"$z\" == \"o\" ]]; then \n\
    \            y=$(echo \"$y\" | sed 's/[[:alpha:]]/o/g')\n            x=$x $(echo\
    \ \"$y\" | sed 's/^/o/') \n        elif [[ \"$z\" == \"u\" ]]; then \n       \
    \     y=$(echo \"$y\" | sed 's/[[:alpha:]]/u/g')\n            x=$x $(echo \"$y\"\
    \ | sed 's/^/u/') \n        elif [[ \"$z\" == \"A\" ]]; then \n            y=$(echo\
    \ \"$y\" | sed 's/[[:alpha:]]/A/g')\n            x=$x $(echo \"$y\" | sed 's/^/A/')\
    \ \n        elif [[ \"$z\" == \"E\" ]]; then \n            y=$(echo \"$y\" | sed\
    \ 's/[[:alpha:]]/E/g')\n            x=$x $(echo \"$y\" | sed 's/^/E/') \n    \
    \    elif [[ \"$z\" == \"I\" ]]; then \n            y=$(echo \"$y\" | sed 's/[[:alpha:]]/I/g')\n\
    \            x=$x $(echo \"$y\" | sed 's/^/I/') \n        elif [[ \"$z\" == \"\
    O\" ]]; then \n            y=$(echo \"$y\" | sed 's/[[:alpha:]]/O/g')\n      \
    \      x=$x $(echo \"$y\" | sed 's/^/O/') \n        elif [[ \"$z\" == \"U\" \n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpod5grodo.sh: line 51: syntax error in conditional expression

    /tmp/tmpod5grodo.sh: line 52: syntax error near `}''

    /tmp/tmpod5grodo.sh: line 52: `}''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    [[ -z \"$1\"\
    \ ]] && { echo \"Usage: $(basename $0) WORD\" >&2; exit 1; }\n    [[ $(echo \"\
    $1\" | wc -c) -gt 1 ]] && { echo \"Usage: $(basename $0) WORD\" >&2; exit 1; }\n\
    \    \n    local vowels=(\"a\" \"e\" \"i\" \"o\" \"u\")\n    local vowel_index=1\n\
    \    local vowel_found=\n    local vowel_dist=\n    local vowel_consonant_right=$(expr\
    \ length \"$1\" - 1)\n    local vowel_consonant_left=vowel_index\n    local vowel_consonant_found=\n\
    \n    # Search for vowel in right side of the word using binary search\n    while\
    \ [[ vowel_consonant_right -gt 0 ]]; do\n        ((vowel_consonant_found += 1))\n\
    \        ((vowel_dist += 1))\n        ((vowel_index += 1))\n\n        local vowel=${vowels[$vowel_index]}\n\
    \        if [[ \"$1\" == *\"$vowel\" ]]; then\n            vowel_found=\"$vowel\"\
    \n            vowel_consonant_found=\"$(( vowel_consonant_found + 1 ))\"\n   \
    \     fi\n\n        ((vowel_consonant_left -= 1))\n    done\n\n    [[ -z \"$vowel_found\"\
    \ ]] && { echo \"No vowel found in the right side of the word.\" >&2; exit 1;\
    \ }\n    echo \"$vowel_found\"\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[\
    \ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n \
    \   [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n\
    \    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\"\
    \ ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\"\
    \ ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") =\
    \ \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Usage: tmpp1ebqid9.sh WORD

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local string=$1\n\
    \    if [ -z \"$string\" ] ; then\n        echo \"No string provided\"\n     \
    \   return 1\n    fi\n    # Get the number of consonants in the string\n    local\
    \ num_consonants=$(echo $string | wc -c)\n    # Store the vowel list\n    local\
    \ vowel_list=\"AEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIOUYAEIO\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv8_98jcn.sh: line 48: unexpected EOF while looking for matching
    `"''

    /tmp/tmpv8_98jcn.sh: line 52: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local string=\"\
    $1\"\n  local vowels=\"a e i o u\" \n  local firstconsonant=\"$2\"\n  local secondconsonant=\"\
    $3\"\n  local index=$(( (${#string} + 1) / 2 ))\n  local result=\"\"\n  \n  case\
    \ \"$string\" in\n    [!a-zA-Z] )\n      echo \"Wrong input\"\n      return 1\n\
    \    ;;\n    *[!a-z]*[a-z]*[!a-z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpghi8rjtd.sh: line 31: syntax error near unexpected token `newline''

    /tmp/tmpghi8rjtd.sh: line 31: `    *[!a-z]*[a-z]*[!a-z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!a-zA-Z]*[!''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: -1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local vowels=(\"\
    a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\");\n  local string=$1;\n\
    \  local result=\"\";\n  local i=${#string};\n  local j=$((i-1));\n  local consonant=${string:$i:1};\n\
    \  while [ $i -gt 0 ]; do\n    local consonant1=${string:$i:1};\n    local consonant2=${string:$j:1};\n\
    \    local consonant3=${string:$(($i+1)):1};\n    if [ \"$consonant\" = \"$consonant1\"\
    \ ] || [ \"$consonant\" = \"$consonant2\" ] || [ \"$consonant\" = \"$consonant3\"\
    \ ]; then\n      if [ \"$consonant\" = \"$consonant1\" ]; then\n        result=\"\
    $consonant\";\n      else\n        result=\"${result}$consonant\";\n      fi;\n\
    \      i=$(($i-1));\n      j=$(($i-1));\n    fi;\n  done;\n  echo \"$result\"\n\
    }\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"\
    u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") =\
    \ \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\")\
    \ = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=21 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=16 encoding='utf-8'>
  timestamp: 1660055188
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local vowels=\"\
    aAiIuU\"\n    local string=${1:?'[get_closest_vowel] Argument cannot be null.'}\n\
    \    local consonants=${string:0:1}\n\n    local len=${#string}\n    local start=0\n\
    \    local end=0\n\n    for (( i=0; i < len; i++ )); do\n        if [[ ${vowels:(-1)}\
    \ == ${string:$i} ]]; then\n            end=$((i+1))\n            break\n    \
    \    fi\n    done\n\n    # print start/end indexes for debugging\n    echo $start\n\
    \    echo $end\n\n    # return empty string if there's no vowel in the string\n\
    \    if [[ $end -eq $start ]]; then\n        return \"\"\n    fi\n\n    # find\
    \ the closest vowel from right to the left\n    local vowel=${string:$end}\n \
    \   local vowel_length=$(expr len -1 )\n    if [[ $end -le $vowel_length ]]; then\n\
    \        local vowel_before=${string:0:$end-1}\n        if [[ \"$vowel_before\"\
    \ =~ [aeiouAEIOU] ]]; then\n            local vowel_after=${string:$end+1}\n \
    \           if [[ \"$vowel_after\" =~ [aeiouAEIOU] ]]; then\n                local\
    \ closest_vowel=${vowel_before}${vowel}${vowel_after}\n                return\
    \ $closest_vowel\n            fi\n        fi\n    fi\n}\n\ncandidate() {\n   \
    \ get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\"\
    ) = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\"\
    ) = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\"\
    ) = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\"\
    ) = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\"\
    ) = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpfrsea2_l.sh: line 40: return: : numeric argument required

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local vowel=$1\n\
    \    local count=1\n    local vowels=\"a e i o u\" #vowels\n    local rest=\"\
    \ \"\n    local curr \n    \n    if [[ \"$vowel\" =~ (^| )[aA]($| )([aA][^aA]*)(^|\
    \ )([aeiouy])($| ) ]]\n    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[eE]($| )([eE][^eE]*)(^| )([aeiouy])($| ) ]]\n\
    \    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[iI]($| )([iI][^iI]*)(^| )([aeiouy])($| ) ]]\n\
    \    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[oO]($| )([oO][^oO]*)(^| )([aeiouy])($| ) ]]\n\
    \    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[s]($| )([sS][^sS]*)(^| )([aeiouy])($| ) ]]\n\
    \    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[uU]($| )([uU][^uU]*)(^| )([aeiouy])($| ) ]]\n\
    \    then curr=\"${BASH_REMATCH[3]}\"; rest=\"${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[4]}\"\
    ;\n    elif [[ \"$vowel\" =~ (^| )[yY]($| )([yY][^yY]*)(^| )([aeiou\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbwrsya6u.sh: line 37: unexpected EOF while looking for matching
    `)''

    /tmp/tmpbwrsya6u.sh: line 62: unexpected argument to conditional binary operator

    /tmp/tmpbwrsya6u.sh: line 62: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 2
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local string=\"\
    $1\"\n  [[ \"$string\" =~ ^[a-zA-Z]+$ ]] || return\n  local vowels=\"aeiouyui\"\
    \n  local count=\"101\"\n  local last=\"${#string}\"\n  local vowel\n  local first\n\
    \  [[ \"$last\" -gt \"$count\" ]] || return\n  first=${string:0:1}\n  second=${string:1:1}\n\
    \  [[ $first =~ $vowels ]] || return\n  [[ $second =~ $vowels ]] || return\n \
    \ [[ -z $3 ]] || vowel=$3\n  while [[ $last -gt 0 ]]; do\n    [[ \"$string\" =~\
    \ $vowel ]] || break\n    first=${string:0:1}\n    second=${string:1:1}\n    [[\
    \ $first =~ $vowels ]] || break\n    [[ $second =~ $vowels ]] || break\n    [[\
    \ \"$last\" -gt \"$count\" ]]  && return\n    last=$(( last - 1 ))\n    first=${string:0:1}\n\
    \    second=${string:1:1}\n    [[ $first =~ $vowels ]] || break\n    [[ $second\
    \ =~ $vowels ]] || break\n    [[ \"$last\" -gt \"$count\" ]] || return\n    last=$((\
    \ last - 1 ))\n    first=${string:0:1}\n    second=${string:1:1}\n    [[ $first\
    \ =~ $vowels ]] || break\n    [[ $second =~ $vowels ]] || break\n    [[ \"$last\"\
    \ -gt \"$count\" ]]  && return\n    last=$(( last - 1 ))\n    first=${string:0:1}\n\
    \    second=${string:1:1}\n    [[ $first =~ $vowels ]] || break\n    [[ $second\
    \ =~ $vowels ]] || break\n    [[ \"$last\" -gt \"$count\" ]]  && return\n    last=$((\
    \ last - 1 ))\n    first=${string:0:1}\n    second=${string:1:1}\n    [[ $first\
    \ =~ $vowels ]] || break\n    [[ $second =~ $vowels ]] || break\n    [[ \"$last\"\
    \ -gt \"$count\" ]] || return\n    last=$(( last - 1 ))\n    first=${string:0:1}\n\
    \    second=${string:1:1}\n    [[ $first =~ $vowels ]] || break\n    [[ $second\
    \ =~ $vowels ]] || break\n    [[ \"$last\" -gt \"$count\" ]]  && return\n    last=$((\
    \ last - 1 ))\n\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"\
    full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfyzq8vch.sh: line 71: syntax error near unexpected token `}''

    /tmp/tmpfyzq8vch.sh: line 71: `}''

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local string=\"\
    ${1}\"\n    local vowels=\"a e i o u\"\n    local vowel_count=0\n    local vowel_index=0\n\
    \    local vowel_met_condition=0\n    for (( i=1; i <= ${#string}; i++ )); do\n\
    \        local char=\"${string:$i:1}\"\n        if [[ \"$char\" =~ [aeiou] ]];\
    \ then\n            vowel_count=$((vowel_count+1))\n            vowel_met_condition=1\n\
    \            if [[ \"$vowel_index\" -eq 0 ]]; then\n                ((vowel_index=$i))\n\
    \            fi\n        fi\n    done\n    if [[ \"$vowel_met_condition\" -eq\
    \ 1 ]]; then\n        local vowel=\"$(printf \"${vowels:$((vowel_index-1)):1}\"\
    )\"\n        echo \"$vowel\"\n    else\n        echo \"\"\n    fi\n}\n\ncandidate()\
    \ {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local -i pos=0\n\
    \    local vowels=(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"\
    )\n    local -i j=0\n    local word=$1\n    local vowel\n\n    while (( $j < ${#word}\
    \ )) ; do\n        vowel=${word:$j:1}\n        if (( ${#vowel} != 1 )) ; then\n\
    \            pos=$j\n            break\n        fi\n        (( j++ ))\n    done\n\
    \n    while (( $pos > 0 )) ; do\n        (( j-- ))\n        vowel=${word:$j:1}\n\
    \        if (( ${#vowel} != 1 )) ; then\n            pos=$j\n            break\n\
    \        fi\n    done\n\n    if (( ${#word} > $pos )) ; then\n        word=${word:0:$pos}\n\
    \    fi\n    echo $vowels\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate\
    \ \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local word=${1}\n\
    \    local result=${2}\n    # check consonants first\n    local count=0\n    for\
    \ char in $(echo $word | tr -cd '[:upper:]'); do\n        if [ \"$char\" == \"\
    a\" ]; then\n            count=$((count + 1))\n        fi\n        if [ \"$char\"\
    \ == \"e\" ]; then\n            count=$((count + 1))\n        fi\n        if [\
    \ \"$char\" == \"i\" ]; then\n            count=$((count + 1))\n        fi\n \
    \       if [ \"$char\" == \"o\" ]; then\n            count=$((count + 1))\n  \
    \      fi\n        if [ \"$char\" == \"u\" ]; then\n            count=$((count\
    \ + 1))\n        fi\n    done\n    echo $count > $result \n}\n\ncandidate() {\n\
    \    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate\
    \ \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate\
    \ \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate\
    \ \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate\
    \ \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate\
    \ \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate\
    \ \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpa3bqdj7g.sh: line 40: $result: ambiguous redirect

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local input=\"\
    $1\"\n\n  # if input length is 0 return empty\n  [ \"$#\" -eq 0 ] && return 0\n\
    \n  # if input length is 1 return first char\n  [ \"$#\" -eq 1 ] && return \"\
    $input\"[0]\n\n  # count consonants in input\n  local inputCount=${#input}\n \
    \ local consonantCount=0\n\n  # iterate through input\n  for (( index=0; index<inputCount;\
    \ index++ )); do\n    # count consonants\n    local inputChar=${input:${index}:1}\n\
    \    consonantCount=$((${consonantCount}+${#inputChar}))\n  done\n\n  # iterate\
    \ through input\n  for (( index=0; index<consonantCount; index++ )); do\n    #\
    \ check whether current vowel is in a word\n    if [[ \"$input\" =~ \"$vowel\"\
    [${index}]* ]]; then\n      # return vowel\n      return \"${input:${index}:1}\"\
    \n    fi\n  done\n\n  # if there is no vowel in word return empty string\n  return\
    \ \"\"\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate \"full\") =\
    \ \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate \"eAsy\"\
    ) = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate \"bad\"\
    ) = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate \"ab\"\
    ) = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate \"quick\"\
    ) = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate \"Asia\"\
    ) = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp8s0sfnqf.sh: line 25: return: yogurt[0]: numeric argument required

    '
  stdout: ''
  timestamp: 1660055183
- exit_code: 1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n    local string=\"\
    $1\"\n    local vowels=(a e i o u)\n    local i\n    local c\n    local j\n  \
    \  local c\n    local k\n    for ((i = 0; i < ${#string}; i++)); do\n        c=${string:$i:1}\n\
    \        if [[ $c =~ [aeiou] ]]; then\n            for ((j = i-1; j <= i+1; j++));\
    \ do\n                k=${string:$j:1}\n                if [[ $k =~ [aeiou] ]];\
    \ then\n                    c=${string:$j:1}\n                    ((j=i+1))\n\
    \                    break\n                fi\n            done\n        fi\n\
    \    done\n    if [[ $c =~ [aeiou] ]]; then\n        $(cat <<< \"$c\" | sort -u)\n\
    \    else\n        echo \"\"\n    fi\n}\n\ncandidate() {\n    get_closest_vowel\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n\
    \    [[ $(candidate \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\"\
    \ ]]\n    [[ $(candidate \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\
    \" ]]\n    [[ $(candidate \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") =\
    \ \"o\" ]]\n    [[ $(candidate \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") =\
    \ \"\" ]]\n    [[ $(candidate \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\"\
    ) = \"i\" ]]\n    [[ $(candidate \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\"\
    ) = \"o\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660055183
- exit_code: -1
  program: "#!/bin/bash\n# You are given a word. Your task is to find the closest\
    \ vowel that stands between \n# two consonants from the right side of the word\
    \ (case sensitive).\n# Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n# find any vowel met the above condition. \n# You\
    \ may assume that the given string contains English letter only.\n# Example:\n\
    # >>> $(get_closest_vowel \"yogurt\")\n# \"u\"\n# >>> $(get_closest_vowel \"FULL\"\
    )\n# \"U\"\n# >>> $(get_closest_vowel \"quick\")\n# \"\"\n# >>> $(get_closest_vowel\
    \ \"ab\")\n# \"\"\n#\n# $1 is a string\nget_closest_vowel() {\n  local vowels=\"\
    aeiou\"\n  local string=$1\n  local vowel_index=$((${#string} - 1))\n  local vowel_found=''\n\
    \  local previous_char=''\n  local next_char=''\n  local char=$string\n\n  while\
    \ [ \"$char\" != '' ]; do\n    if [ \"${char:0:1}\" == \"$vowel_index\" ]; then\n\
    \      vowel_found=\"$vowel_found$char\"\n    fi\n    previous_char=\"$char\"\n\
    \    char=\"${char:$((${#char} - 1))}\"\n    next_char=\"$char\"\n\n  done\n\n\
    \  echo $vowel_found\n}\n\ncandidate() {\n    get_closest_vowel \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"yogurt\") = \"u\" ]]\n    [[ $(candidate\
    \ \"full\") = \"u\" ]]\n    [[ $(candidate \"easy\") = \"\" ]]\n    [[ $(candidate\
    \ \"eAsy\") = \"\" ]]\n    [[ $(candidate \"ali\") = \"\" ]]\n    [[ $(candidate\
    \ \"bad\") = \"a\" ]]\n    [[ $(candidate \"most\") = \"o\" ]]\n    [[ $(candidate\
    \ \"ab\") = \"\" ]]\n    [[ $(candidate \"ba\") = \"\" ]]\n    [[ $(candidate\
    \ \"quick\") = \"\" ]]\n    [[ $(candidate \"anime\") = \"i\" ]]\n    [[ $(candidate\
    \ \"Asia\") = \"\" ]]\n    [[ $(candidate \"Above\") = \"o\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=43 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=41 encoding='utf-8'>
  timestamp: 1660055188
