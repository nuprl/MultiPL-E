language: sh
name: HumanEval_99_closest_integer
results:
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ NUM=$1\n    local ROUND\n    ROUND=1 # Set ROUND to be a positive number to\
    \ round\n    local MIN\n    MIN=0 # Set MIN to 0\n    local MAX\n    MAX=1000000000000000\
    \ # Set MAX to 1000000000000000\n    local CLOSEST_RESULT\n    CLOSEST_RESULT=$1\
    \ # Set CLOSEST_RESULT to the number we started with\n    while [[ $ROUND -le\
    \ 100 ]] || [[ $ROUND -ge 99 ]] ; do\n        local RESULT\n        RESULT=$(($ROUND+$MIN+$MAX))\
    \ # Add MIN to ROUND and MAX to ROUND\n        if [[ $RESULT -gt $CLOSEST_RESULT\
    \ ]]; then\n            CLOSEST_RESULT=$RESULT\n        fi\n        local TEST\n\
    \        TEST=$(echo $RESULT)\n        if [[ $TEST -ge $1 ]]; then\n         \
    \   MAX=$RESULT\n        else\n            MIN=$RESULT\n        fi\n        ROUND=$(($ROUND+1))\n\
    \    done\n    echo \"$CLOSEST_RESULT\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=11 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=9 encoding='utf-8'>
  timestamp: 1660057029
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ a=\"${1#-}\"\n    local b=\"${1%-}\"\n    local c=\"${2#-}\"\n    local d=\"\
    ${2%-}\"\n\n    if [[ \"$a\" == \"$d\" ]];\n    then\n        echo -n \"0\"\n\
    \    else\n        echo \"$(expr \"$a\" : \"$b\")\"\n    fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ NUM=$1\n  local RESULT=0\n\n  # Get difference between NUM and RESULT to ensure\
    \ integer rounding\n  NUM=\"${NUM%.*}\"\n  RESULT=\"${RESULT%.*}\"\n\n  local\
    \ NUMNUMNUM\n  if [ $RESULT -gt 0 ]; then\n    NUMNUMNUM=\"-$NUM\"\n  else\n \
    \   NUMNUMNUM=\"$NUM\"\n  fi\n\n  # Sum all possible differences between the two\
    \ numbers\n  local SUM=0\n  for ((i=0;i<5;i++)); do\n    local DIFF=\"$i\"\n \
    \   if (( i > 0 ));then\n      DIFF=\"$((DIFF+1))\"\n    fi\n    ((SUM+=${DIFF}${NUMNUMNUM}${DIFF}))\n\
    \  done\n\n  # Get absolute difference\n  RESULT=\"${RESULT%+$SUM}\"\n\n  echo\
    \ \"$RESULT\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=$1\n  local diff1=0\n  local diff2=0\n  local diff\n  local num1=\"${val%.*}\"\
    \n  local num2=\"${val##*.}\"\n  # Handle special case for equidistant numbers.\n\
    \  if [ \"${val}\" == \"0\" ]; then\n    return 0;\n  fi\n  # Find the difference\
    \ between the two numbers as float\n  diff=\"$(echo \"${num2}-${num1}\" | bc)\"\
    \n  # Handle special case for equality.\n  if [ \"${diff}\" == \"0\" ]; then\n\
    \    return 0\n  fi\n  # Handle special case for equidistant numbers, where the\
    \ difference\n  # is positive.\n  if [ \"${diff}\" == \"+inf\" ]; then\n    return\
    \ 0\n  fi\n  # Handle special case for equidistant numbers, where the difference\n\
    \  # is negative.\n  if [ \"${diff}\" == \"-inf\" ]; then\n    return 0\n  fi\n\
    \  # The difference between the two numbers is positive, so return the\n  # greater\
    \ integer.\n  if [ \"${diff}\" > 0 ]; then\n    echo \"${num1}\"\n  else\n   \
    \ echo \"${num2}\"\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\tlocal\
    \ a=\"${1}.0\"\n\tlocal b=\"-${1}.0\"\n\tlocal diff tmp\n\n\t# a is closest to\
    \ b if they are equal and differ by less than 1\n\tdiff=`echo \"${b} - ${a}\"\
    |bc -l`\n\tif [ ${diff} == \"${1}\" ] && [ ${diff} != \"1\" ]; then\n\t\tdiff=`echo\
    \ \"${a} - ${b}\"|bc -l`\n\t\tif [ ${diff} == \"${1}\" ]; then\n\t\t\tdiff=\"\
    1\"\n\t\telse\n\t\t\tdiff=\"-1\"\n\t\tfi\n\tfi\n\n\t# if the difference is still\
    \ zero, return the original number\n\tif [ \"${diff}\" == \"0\" ]; then\n\t\t\
    echo $1\n\telse\n\t\ttmp=\"${b}\"\n\t\techo \"${tmp}${diff}\"\n\tfi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  awk -F.\
    \ '{print $1}' <<< \"$1\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=\"$1\"\n  local min\n  local max\n  local middle\n  local output\n\n  if\
    \ [[ \"$val\" == *\".\"* ]]; then\n    # Remove any decimal places\n    num=$(echo\
    \ \"$val\" | sed -e 's/\\..*$//')\n    # If the number is all digits, just return\
    \ the number\n    if [[ \"$num\" == *[^[:digit:]]* ]]; then\n      return \"$val\"\
    \n    fi\n    middle=$(( (num / 2) | 0 ))\n    max=$(expr \"$middle\" + 1)\n \
    \   min=$(expr \"$middle\" - 1)\n  else\n    num=$(echo \"$val\" | sed -e 's/^\\\
    ..*//')\n    middle=$(( (num / 2) | 0 ))\n    max=$(expr \"$middle\" + 1)\n  \
    \  min=$(expr \"$middle\" - 1)\n  fi\n\n  output=$(\n    if [ \"$max\" -gt \"\
    $min\" ];\n    then\n      expr \"$max\" - \"$min\"\n    else\n      expr \"$max\"\
    \ - \"$num\"\n    fi\n  )\n  echo \"$output\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ value=\"$1\"\n    local num=$((10#$1))\n    local closest=$(( 10#$((num % 10))\
    \ ))\n\n    while [[ $closest -eq 0 ]]\n    do\n        num=${num/10}\n      \
    \  closest=$(( 10#$((num % 10)) ))\n    done\n    echo \"$value\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=21 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=8 encoding='utf-8'>
  timestamp: 1660057029
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=\"${1}\"\n  local integer\n  integer=$((string+0))\n  while [[ ${integer}\
    \ -le ${string} ]]; do\n    integer=$((integer+1))\n  done\n  echo $integer\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ NUMBER=\"$1\"\n    local TOLERANCE=10\n    local MIN_INTEGER=1\n    local MAX_INTEGER=100\n\
    \    local MAX_ABS=\"$(expr ${MAX_INTEGER} - ${MIN_INTEGER})\"\n    local NUMBER_FORMAT=\"\
    %d\"\n\n    # Convert the input to an integer.\n    local N=\"${NUMBER}\"\n  \
    \  local S=\"${N%%,*}\"\n    local P=\"${N#*,}\"\n    local TOTAL_DIGITS=\"$(expr\
    \ ${P} / ${TOLERANCE})\"\n    local TRUNCATE_DIGITS=\"$(expr ${S} / ${TOLERANCE})\"\
    \n    local INT_DIGIT_ONE=\"$(expr ${S} - ${TRUNCATE_DIGITS} )\"\n    local INT_DIGIT_ZERO=\"\
    $(expr ${S} - ${TRUNCATE_DIGITS} + ${TOTAL_DIGITS} )\"\n    local INT_DIGIT=\"\
    $(expr ${S} + ${TOTAL_DIGITS} + ${TOLERANCE} )\"\n\n    if [[ \"$S\" -gt \"0\"\
    \ ]]; then\n        if (( ${S} == ${TRUNCATE_DIGITS} ))\n        then\n      \
    \      INT_DIGIT=\"-${INT_DIGIT_ZERO}\"\n        else\n            INT_DIGIT=\"\
    -${INT_DIGIT_ONE}\"\n        fi\n    fi\n    if [[ \"${INT_DIGIT}\" -gt \"${MAX_ABS}\"\
    \ ]]; then\n        INT_DIGIT=\"$(expr ${INT_DIGIT} - ${MAX_ABS})\"\n    fi\n\
    \    if [[ \"${INT_DIGIT}\" -lt \"${MIN_INTEGER}\" ]]; then\n        INT_DIGIT=\"\
    $(expr ${INT_DIGIT} + ${MIN_INTEGER})\"\n    fi\n    if [[ \"${INT_DIGIT}\" -gt\
    \ \"${MAX_INTEGER}\" ]]; then\n        INT_DIGIT=\"$(expr ${INT_DIGIT} - ${MAX_INTEGER})\"\
    \n    fi\n    echo ${INT_DIGIT}\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ num=$1\n    # echo \"num is: $num\"\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\\
    )/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\"\
    \ | sed 's/^-\\?\\([1-9]\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ val=\"${1}\"\n    local min=0\n    local max=$((${val}-10000))\n    local res=$(echo\
    \ \"${val} * $((${max} - min)) / 10000\" | bc)\n    echo ${res}\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ x=$1 #local variable\n    echo \"$x\" # debug\n    # Trim leading and trailing\
    \ whitespace\n    x=${x#\"${x%%.*}\"}\n    x=${x%%\"${x#*.}\"}\n    # Get the\
    \ sign of the number\n    x=${x#-}\n    x=${x%%-}\n    # Figure out the integer\
    \ value of the number\n    x=${x%%%.*}\n    x=${x##*/}\n    local int_val=$((10#${x}))\n\
    \    # If the number is not equidistant from two integers, round it away\n   \
    \ # from zero\n    if [[ ${x} -eq ${int_val} ]]; then\n        int_val=$((int_val+1))\n\
    \    fi\n    echo \"${int_val}\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ str=\"$1\"\n    local i1=\"$2\"\n    local i2=\"$3\"\n    local diff\n    local\
    \ i\n    diff=\"$((i1-i2))\"\n    if [ $diff -gt 0 ]; then\n        i=$((i1+1))\n\
    \    elif [ $diff -lt 0 ]; then\n        i=$((i2-1))\n    else\n        i=$i1\n\
    \    fi\n    echo \"$i\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057024
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x=\"$1\"\n  local prefix=\"-${x}\"\n  local suffix=\"+${x}\"\n  local closest=1000000000\n\
    \  local closest_num=$(closest_float \"$1\") || exit 1\n  local diff\n  diff ()\
    \ {\n    local x=\"$1\"\n    local y=\"$2\"\n    test \"$y\" = \"$x\" && return\
    \ 0\n    test \"$y\" = \"$prefix\" && return 1\n    test \"$y\" = \"$suffix\"\
    \ && return -1\n    return 1\n  }\n  while diff \"$closest_num\" \"$x\" ; do\n\
    \    closest_num=$(closest_float \"$closest_num\")\n  done\n  diff \"$closest_num\"\
    \ \"$x\" &> /dev/null\n  diff \"$closest_num\" \"$prefix\" &> /dev/null\n  diff\
    \ \"$closest_num\" \"$suffix\" &> /dev/null\n  return $(($closest_num + $diff\
    \ - 1))\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp939aq8ve.sh: line 22: closest_float: command not found

    '
  stdout: ''
  timestamp: 1660057024
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Input\
    \ validation\n  if [[ \"$1\" == \"-?\" || \"$1\" == \"--help\" || \"$1\" == \"\
    -h\" || \"$1\" == \"--version\" || \"$1\" == \"-v\" ]]; then\n    echo \"$($FUNCNAME\
    \ $0 [OPTION]... VALUE)...\"\n    echo \"  Options:\"\n    echo\n    echo \" \
    \   -h, --help         Print this help message and exit\"\n    echo \"    -v,\
    \ --version      Print version information and exit\"\n    echo \"    -?, --help\
    \         Print this help message and exit\"\n    exit 0\n  fi\n  local STRING=\"\
    $1\"\n  local MIN\n  local MAX\n  local DIVISOR\n  local NUMBER\n  local NEXT\
    \ OLD DIVISOR\n  # Parse and validate input\n  # Make sure we have a valid integer\
    \ string as a first argument\n  case \"${STRING}\" in\n    -*)\n      echo \"\
    $FUNCNAME: error: invalid argument '$STRING' -- not a number\" >&2\n      exit\
    \ 1\n    ;;\n    *[!0-9]*)\n      echo \"$FUNCNAME: error: invalid argument '$STRING'\
    \ -- not a number\" >&2\n      exit 1\n    ;;\n    *)\n      # Convert to integer\n\
    \      NUMBER=\"${STRING}\"\n      ;;\n  esac\n  MIN=\"0\"\n  MAX=\"9\"\n  # Parse\
    \ the number\n  while [[ \"$NUMBER\" =~ (^|)([!0-9]+)($|) ]]; do\n    # Get the\
    \ divisor\n    OLD=\"${BASH_REMATCH[2]}\"\n    DIVISOR=\"${BASH_REMATCH[3]}\"\n\
    \    # Make sure the divisor is valid and greater than zero\n    if [[ ${DIVISOR}\
    \ =~ ^[!0-9]+$ ]]; then\n      if [[ \"${MIN}\" == \"0\" ]]; then\n        MIN=\"\
    ${DIVISOR}\"\n      else\n        MAX=\"${DIVISOR}\"\n      fi\n    fi\n    #\
    \ Make sure the number is greater than zero\n    if [[ \"${NUMBER}\" =~ ^[0-9]+$\
    \ ]]; then\n      # Make sure the number is less than the maximum\n      if [[\
    \ \"$NUMBER\" -gt \"$MAX\" ]]; then\n        echo \"$FUNCNAME: error: argument\
    \ '$1' out of range: maximum is '$MAX'\" >&2\n        exit 1\n      fi\n     \
    \ # Make sure the number is less than the minimum\n      if [[ \"$NUMBER\" -lt\
    \ \"$MIN\" ]]; then\n        echo \"$FUNCNAME: error: argument '$1' out of range:\
    \ minimum is '$MIN'\" >&2\n        exit 1\n      fi\n      # Make sure the number\
    \ is equidistant from \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp98nkzfom.sh: line 78: syntax error near unexpected token `}''

    /tmp/tmp98nkzfom.sh: line 78: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value\n  value=\"$1\"\n  local number=\"$1\"\n  if (( $# != 1 )); then\n   \
    \   echo \"Usage: $(basename $0) [-n number] [-f format]\"\n      return 1\n \
    \ fi\n  local minval=\"$1\"\n  local minvalstr=\"$minval\"\n  minvalstr=\"${minvalstr%.*}\"\
    \n  local maxval=\"$1\"\n  local maxvalstr=\"$maxval\"\n  maxvalstr=\"${maxvalstr%.*}\"\
    \n  local n=\"$1\"\n  local nstr=\"$n\"\n  nstr=\"${nstr%.*}\"\n  if [ \"$maxval\"\
    \ == \"-inf\" ] || [ \"$minval\" == \"inf\" ]; then\n      echo \"You passed an\
    \ infinite number\"\n      return 1\n  fi\n  local mindiff=\"1e18\"\n  local maxdiff=\"\
    -1e18\"\n  local mindiffstr=\"-1e18\"\n  local maxdiffstr=\"1e18\"\n  if [ \"\
    $minval\" != \"$maxval\" ]; then\n      mindiff=$(( ($minval - $maxval) ))\n \
    \     maxdiff=$(( ($maxval - $minval) ))\n      mindiffstr=$(( ($mindiff) ))\n\
    \      maxdiffstr=$(( ($maxdiff) ))\n      if [ \"$mindiff\" == 0 ]; then\n  \
    \        maxdiffstr=\"-1\"\n      fi\n  fi\n  if [ \"$mindiff\" -gt \"$maxdiff\"\
    \ ]; then\n      echo \"${minvalstr}.${mindiffstr} and ${maxvalstr}.${maxdiffstr}\
    \ are equidistant\"\n      return 1\n  fi\n  if [ \"$mindiffstr\" == \"-1\" ];\
    \ then\n      mindiffstr=\"0\"\n  fi\n  if [ \"$maxdiffstr\" == \"-1\" ]; then\n\
    \      maxdiffstr=\"0\"\n  fi\n  local minint=\"$minvalstr\"\n  local maxint=\"\
    $maxvalstr\"\n  local mindiffint=\"$mindiffstr\"\n  local maxdiffint=\"$maxdiffstr\"\
    \n  if [ \"$minval\" != \"$maxval\" ]; then\n      minint=$(( ($minval - $maxval)\
    \ ))\n      maxint=$(( ($maxval - $minval) ))\n      mindiffint=$(( ($mindiff\
    \ + $mindiffstr) ))\n      maxdiffint=$(( ($maxdiff - $maxdiffstr) ))\n      if\
    \ [ \"$mindiffint\" == \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmplsb0c7pz.sh: line 71: syntax error near unexpected token `}''

    /tmp/tmplsb0c7pz.sh: line 71: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\t# This\
    \ code makes a few assumptions:\n\t# - All numbers are positive\n\t# - All numbers\
    \ are equidistant from two integers\n\t# - All numbers are non-negative\n\t# -\
    \ All numbers are non-zero and non-decimal\n\t# - All numbers are of same number\
    \ of digits\n\t# - No leading zeros are allowed\n\t# - No leading zeros or negative\
    \ signs are allowed\n\t# - All numbers have same number of digits\n\t# - No leading\
    \ zeros are allowed\n\t# - No leading zeros or negative signs are allowed\n\t\
    # - All numbers have same number of digits\n\t# - All numbers consist of same\
    \ number of digits\n\t# - The function must return an int\n\t\n\t# Convert the\
    \ string to a number\n\tread -p \"$1\" number_to_test <<< \"$1\"\n\tnumber_to_test=$((number_to_test))\n\
    \t\n\t# This array will hold the digits of a given number\n\tdig_array=()\n\t\n\
    \t# First we take each digit of the given number\n\t# Note: To get the last digit\
    \ we subtract 1 from the length\n\tfor i in $(seq 1 $((${#number_to_test} - 1)))\n\
    \tdo\n\t\t# Add the digit to the array\n\t\tdig_array[$i]=$((${number_to_test%%%.*}${number_to_test#*%.}))\n\
    \t\t# Remove the digit from the number\n\t\tnumber_to_test=$((${number_to_test#*${dig_array[$i]}}))\n\
    \tdone\n\t\n\t# Take the difference of the number and the sum of the array\n\t\
    # then round up to the nearest integer\n\tdig_difference=$((${number_to_test}-${dig_array[@]}))\n\
    \tdig_sum=$((${#dig_array[@]}+1))\n\t\n\t#if $dig_sum > $number_to_test\n\t#then\n\
    \t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\t\n\t\n\t#if [ $dig_sum -gt $number_to_test\
    \ ]\n\t#then\n\t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\t\n\t\n\t#if [ $dig_sum\
    \ -gt $number_to_test ]\n\t#then\n\t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\
    \t\n\t#echo \"$dig_sum\"\n\t\n\tif [ \"$dig_sum\" -gt \"$number_to_test\" ]; then\n\
    \t\tdig_sum=$((number_to_test + 1))\n\tfi\n\t\n\t\n\t\n\t#if [ -z \"$dig_sum\"\
    \ -o \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local digits=${number//./ }\n    if [ \"$number\" == \"$digits\"\
    \ ]; then\n        echo $1\n        return\n    fi\n\n    # Check if number is\
    \ equidistant from two integers\n    local a=$(( 10#$digits - 5 ))\n    local\
    \ b=$(( 10#$digits + 5 ))\n    # Check if given number is equidistant from two\
    \ integers\n    local c=$(( 10#$number - 5 ))\n    local d=$(( 10#$number + 5\
    \ ))\n    # Check if $a is closer to $b than $c and $d\n    if (( $a > $b ));\
    \ then\n        local tmp=$a\n        a=$b\n        b=$tmp\n    fi\n    if ((\
    \ $c > $d )); then\n        local tmp=$c\n        c=$d\n        d=$tmp\n    fi\n\
    \    # $a is closer to $b or $c than $d\n    if [ $a -gt $b ] || [ $c -gt $d ];\
    \ then\n        echo $a\n        return\n    fi\n    # $b is closer to $c than\
    \ $d\n    if [ $b -gt $c ] || [ $d -gt $a ]; then\n        echo $b\n        return\n\
    \    fi\n    # $c is closer to $d than $a\n    if [ $c -gt $d ] || [ $d -gt $a\
    \ ]; then\n        echo $c\n        return\n    fi\n    # Given number is equidistant\
    \ from two integers\n    echo $d\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprvz3t1_4.sh: line 26: 10#14 5 - 5 : syntax error in expression
    (error token is "5 - 5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\tlocal\
    \ value=$1\n\tlocal closest\n\tlocal num1=$(awk -F. '{ print $1 }' <<< $value)\n\
    \tlocal num2=$(awk -F. '{ print $2 }' <<< $value)\n\tlocal diff=$(( num1 - num2\
    \ ))\n\n\tif [ \"$diff\" = \"$((num1 * -1))\" ]; then\n\t\tclosest=$(( num1 +\
    \ 1 ))\n\telse\n\t\tclosest=$(( num1 - 1 ))\n\tfi\n\n\techo \"$closest\"\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local min=$(( $(( $number | gawk '{ print $1 }') - 1 ))\n  local\
    \ max=$(( $(( $number | gawk '{ print $1 }') + 1 )))\n  local closest\n\n  local\
    \ current=$(( $number ))\n  local closest2=$(( $(( $number | gawk '{ print $1\
    \ }') + 1 )))\n  local closest3=$(( $(( $number | gawk '{ print $1 }') - 1 )))\n\
    \  local diff\n\n  for (( i = 0; i < $max; i++ )); do\n    diff=$(( $current -\
    \ $closest2 ))\n    if (( $diff < 0 )); then\n      closest2=$(( $closest2 + 1\
    \ ))\n    else\n      closest2=$(( $closest2 - 1 ))\n    fi\n    diff=$(( $current\
    \ - $closest3 ))\n    if (( $diff < 0 )); then\n      closest3=$(( $closest3 -\
    \ 1 ))\n    else\n      closest3=$(( $closest3 + 1 ))\n    fi\n    diff=$(( $current\
    \ - $closest ))\n    if (( $diff < 0 )); then\n      closest=$(( $closest - 1\
    \ ))\n    else\n      closest=$(( $closest + 1 ))\n    fi\n  done\n  echo $((\
    \ $closest2 | gawk '{ print $1 }' ))\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7ww9tbv1.sh: line 19: unexpected EOF while looking for matching
    `)''

    /tmp/tmp7ww9tbv1.sh: line 65: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local numbers=$(echo \"$number\" | tr \",\" \" \")\n    local\
    \ min=$(( ${numbers//,/ - } ))\n    local max=$(( ${numbers//,/ - } ))\n    if\
    \ [[ $max -ge $min ]]; then\n        local max=$(( ${max} + 1 ))\n        local\
    \ min=$(( ${min} - 1 ))\n    fi\n    echo $(echo \"${number}\" | awk -F. -v max=$max\
    \ -v min=$min 'BEGIN { print \"'\"$min\"'\" } $1 == $2 { print $3 } END { print\
    \ \"'\"$max\"'\" }')\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n      \
    \  local -r input=\"${1}\"\n        if [[ -z \"$input\" ]] || [[ \"$input\" =\
    \ *\"-\"* ]] ; then\n                echo \"$1\" >&2\n                return 1\n\
    \        fi\n        local digits=$(echo \"$input\" | sed -e 's/^\\(.\\).*$/\\\
    1/')\n        local last=${digits:(-1)}\n        local diff\n        local lastdiff\n\
    \        local cur\n        local num\n        local ret\n        for (( cur =\
    \ 0; cur <= 9; cur++ )); do\n                num=${digits:$((cur))}\n        \
    \        if (( \"$num\" < \"$last\" )) ; then\n                        last=$num\n\
    \                        diff=$(( last - last % 10 ))\n                      \
    \  lastdiff=$(( last - last % 10 ))\n                else\n                  \
    \      diff=$(( 10 - last % 10 ))\n                        lastdiff=$(( 10 - last\
    \ % 10 ))\n                        last=$num\n                fi\n           \
    \     if (( \"$diff\" = \"0\" )) ; then\n                        if (( \"$lastdiff\"\
    \ != \"0\" )) ; then\n                                diff=$(( lastdiff % 10 ))\n\
    \                        fi\n                        ret=$(( 10 + last + diff\
    \ ))\n                        echo \"$ret\"\n                        break\n \
    \               fi\n        done\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp6ix6aq68.sh: line 41: ((: 9 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: < 1 : syntax error: operand expected (error
    token is "< 1 ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 9 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    /tmp/tmp6ix6aq68.sh: line 32: ((: <  : syntax error: operand expected (error token
    is "<  ")

    /tmp/tmp6ix6aq68.sh: line 41: ((: 10 = 0 : attempted assignment to non-variable
    (error token is "= 0 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=\"$1\"\n  (( $# > 0 )); # ensure arguments are given to this function\n\
    \  local prev=\"$(closest_integer $2)\"\n  local diff=${#val}\n  local maxdiff\n\
    \  local cur\n  local nums\n\n  if [ -z \"$prev\" ]; then\n    prev=0\n  fi\n\n\
    \  case \"$val\" in\n    [0-9.]*)\n      nums=\"$(echo $val |sed 's/\\./\\\\\\\
    ./g')\"\n      break\n  esac\n  prev=${prev%.*}\n  if [[ \"$diff\" -gt \"$maxdiff\"\
    \ ]]; then\n    maxdiff=$diff\n  fi\n  (( diff-- ))\n  for (( cur=1; cur<=${#nums};\
    \ cur++ )); do\n    diff =$(echo \"$prev*($((cur-1)/${#nums}))\" |bc)\n    if\
    \ [ \"$diff\" -gt \"$maxdiff\" ]; then\n      maxdiff=$diff\n    fi\n    (( prev=\"\
    $cur\" ))\n  done\n  (( maxdiff-- ))\n  if [[ \"$maxdiff\" -eq 0 ]]; then\n  \
    \  echo \"0\"\n  else\n    echo \"$prev\"\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=35 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=18 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=\"${1}\"\n  [[ \"${num}\" =~ ^[+-]?[0-9]+$ ]] || return 0\n  local -n num=${num}\n\
    \  local num2=$(( (${num} / 2) + 0.5 ))\n  local num3=$(( (${num2} / 2) + 0.5\
    \ ))\n  [[ ${num} -eq ${num2} ]] || return 0\n  [[ ${num} -eq ${num3} ]] || return\
    \ 0\n  echo \"${num}\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp3uk0dcu_.sh: line 20: local: `10'': invalid variable name for name
    reference

    /tmp/tmp3uk0dcu_.sh: line 21: (10 / 2) + 0.5 : syntax error: invalid arithmetic
    operator (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  val=$(echo\
    \ $1 | awk '{print $1}')\n  prevval=$(echo $1 | awk '{print $2}')\n\n  integer=$(echo\
    \ \"$val\" | cut -d \".\" -f 1)\n  diff=$(echo \"$prevval - $integer\" | bc)\n\
    \  if [[ $diff -eq 0 ]]; then\n    echo $integer\n  else\n    echo $(($integer\
    \ + $diff))\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=\"$1\"\n    local difference=\n\n    # See if the number is already an\
    \ integer.\n    if [[ \"$number\" =~ ^-?[0-9]+$ ]]; then\n        echo \"$number\"\
    \n        return\n    fi\n\n    # See if the number is close to zero, and if so,\
    \ return 0.\n    if [ \"$number\" == \"0\" ]; then\n        echo \"0\"\n     \
    \   return\n    fi\n\n    # Get the difference between the current number and\
    \ the next \n    # number in the sequence.\n    if [ \"$number\" == \"$next\"\
    \ ];then\n        difference=0\n    else\n        difference=\"$(( number - next\
    \ ))\"\n    fi\n\n    # Round the difference away from zero, if it exists.\n \
    \   if [ \"$difference\" -lt \"0.5\" ]; then\n        difference=\"0$difference\"\
    \n    fi\n\n    # Convert the difference to an integer.\n    difference=\"$(echo\
    \ -e \"${difference}\" | bc)\"\n\n    # See if the difference is equidistant from\
    \ two numbers. \n    if [ \"$difference\" -gt \"0\" ]; then\n        # Yes, return\
    \ the number that is closer to zero.\n        echo \"$next\"\n        return\n\
    \    fi\n\n    # No, so return the number that is furthest from zero.\n    echo\
    \ \"$number\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpdw5tegju.sh: line 38: 14.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # We\
    \ accept any numeric string\n  local string=$1\n  # Convert to an array that we\
    \ can modify\n  local arr=(${string//,/ })\n  # Initialize the minimum difference\n\
    \  local mindiff=${arr[1]}\n  # Initialize the current difference\n  local diff=${arr[1]}\n\
    \  # Initialize the minimum difference\n  local mindiff=${arr[1]}\n  # Now loop\
    \ over the array\n  for index in ${!arr[@]}; do\n    # Update our current difference\n\
    \    diff=$((${arr[$index]} - ${arr[index]}))\n    # See if we should update\n\
    \    if [[ \"${diff}\" -lt \"${mindiff}\" ]]; then\n      # Update the minimum\
    \ difference\n      mindiff=${diff}\n      # Update the minimum difference index\n\
    \      mindiffindex=\"${index}\"\n    fi\n  done\n  # If we found a min difference\n\
    \  if [[ \"${mindiff}\" -eq 0 ]]; then\n    # Return current value\n    echo \"\
    ${arr[@]}\"\n  else\n    # Return closest value\n    echo \"${arr[@]:0:${mindiffindex}}\"\
    \n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7bngxxyh.sh: line 31: 14.5 - 14.5: syntax error: invalid arithmetic
    operator (error token is ".5 - 14.5")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value=$1\n\n  (( ${value//[^0-9]/} < 0 )) || return 0\n  # Remove everything\
    \ but digits (no decimal point) and add one to\n  # avoid negative numbers\n \
    \ local n=$((${value//[^0-9]/}+1))\n  (( ${n} < $1 )) && return 0\n  (( ${n} >\
    \ $1 )) && return 0\n  (( ${n} == $1 )) && return 0\n  (( ${n} == ${value//[0-9]/}\
    \ )) && return 0\n\n  local factors=$(echo \"$1/10\" | bc)\n  (( ${factors} >\
    \ ${value//[0-9]/} )) && return 0\n  (( ${factors} < ${value//[0-9]/} )) && return\
    \ 1\n  (( ${factors} == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo\
    \ \"$1/100\" | bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors}\
    \ < ${value//[0-9]/} )) && return 1\n  (( ${factors} == ${value//[0-9]/} )) &&\
    \ return 0\n\n  local factors=$(echo \"$1/1000\" | bc)\n  (( ${factors} > ${value//[0-9]/}\
    \ )) && return 0\n  (( ${factors} < ${value//[0-9]/} )) && return 1\n  (( ${factors}\
    \ == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo \"$1/10000\" |\
    \ bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors} < ${value//[0-9]/}\
    \ )) && return 1\n  (( ${factors} == ${value//[0-9]/} )) && return 0\n\n  local\
    \ factors=$(echo \"$1/100000\" | bc)\n  (( ${factors} > ${value//[0-9]/} )) &&\
    \ return 0\n  (( ${factors} < ${value//[0-9]/} )) && return 1\n  (( ${factors}\
    \ == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo \"$1/1000000\"\
    \ | bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors} <\
    \ ${value//[0-9]/} )) && return 1\n  (( ${factors} == ${value//[0-9]/\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgnjxopmg.sh: line 57: unexpected EOF while looking for matching
    `)''

    /tmp/tmpgnjxopmg.sh: line 74: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ integer=$1\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpne6jo1na.sh: line 19: integer: command not found

    /tmp/tmpne6jo1na.sh: line 20: integer: command not found

    /tmp/tmpne6jo1na.sh: line 21: integer: command not found

    /tmp/tmpne6jo1na.sh: line 22: integer: command not found

    /tmp/tmpne6jo1na.sh: line 23: integer: command not found

    /tmp/tmpne6jo1na.sh: line 24: integer: command not found

    /tmp/tmpne6jo1na.sh: line 25: integer: command not found

    /tmp/tmpne6jo1na.sh: line 26: integer: command not found

    /tmp/tmpne6jo1na.sh: line 27: integer: command not found

    /tmp/tmpne6jo1na.sh: line 28: integer: command not found

    /tmp/tmpne6jo1na.sh: line 29: integer: command not found

    /tmp/tmpne6jo1na.sh: line 30: integer: command not found

    /tmp/tmpne6jo1na.sh: line 31: integer: command not found

    /tmp/tmpne6jo1na.sh: line 32: integer: command not found

    /tmp/tmpne6jo1na.sh: line 33: integer: command not found

    /tmp/tmpne6jo1na.sh: line 34: integer: command not found

    /tmp/tmpne6jo1na.sh: line 35: integer: command not found

    /tmp/tmpne6jo1na.sh: line 36: integer: command not found

    /tmp/tmpne6jo1na.sh: line 37: integer: command not found

    /tmp/tmpne6jo1na.sh: line 38: integer: command not found

    /tmp/tmpne6jo1na.sh: line 39: integer: command not found

    /tmp/tmpne6jo1na.sh: line 40: integer: command not found

    /tmp/tmpne6jo1na.sh: line 41: integer: command not found

    /tmp/tmpne6jo1na.sh: line 42: integer: command not found

    /tmp/tmpne6jo1na.sh: line 43: integer: command not found

    /tmp/tmpne6jo1na.sh: line 44: integer: command not found

    /tmp/tmpne6jo1na.sh: line 45: integer: command not found

    /tmp/tmpne6jo1na.sh: line 46: integer: command not found

    /tmp/tmpne6jo1na.sh: line 47: integer: command not found

    /tmp/tmpne6jo1na.sh: line 48: integer: command not found

    /tmp/tmpne6jo1na.sh: line 49: integer: command not found

    /tmp/tmpne6jo1na.sh: line 50: integer: command not found

    /tmp/tmpne6jo1na.sh: line 51: integer: command not found

    /tmp/tmpne6jo1na.sh: line 52: integer: command not found

    /tmp/tmpne6jo1na.sh: line 53: integer: command not found

    /tmp/tmpne6jo1na.sh: line 54: integer: command not fo'
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ _number=\"$1\"\n  local _equidistant=\"false\"\n  local _last=\"\"\n  local\
    \ _dist=\"\"\n  local _out=\"\"\n\n  [[ \"$_number\" =~ ^-?[0-9][0-9]*\\.[0-9]+$\
    \ ]] || _equidistant=\"true\"\n  local _number=\"${_number%.*}\"\n  [[ \"$_number\"\
    \ =~ ^-?[0-9][0-9]*\\.[0-9]+$ ]] || _equidistant=\"true\"\n  local _number=\"\
    ${_number%.*}\"\n\n  [[ \"$_number\" =~ ^-?[0-9]+$ ]] || _equidistant=\"true\"\
    \n  local _number=\"${_number%.*}\"\n  [[ \"$_number\" =~ ^-?[0-9]+$ ]] || _equidistant=\"\
    true\"\n\n  # Check to see if there is a number greater than the given value\n\
    \  if [[ -n \"$_number\" && \"$_number\" -gt 0 ]]; then\n    _last=\"$_number\"\
    \n    if [[ $_equidistant == \"true\" ]]; then\n      _dist=\"1\"\n    else\n\
    \      _dist=\"0\"\n    fi\n  fi\n\n  # Check to see if there is a number less\
    \ than the given value\n  if [[ -n \"$_number\" && \"$_number\" -lt 0 ]]; then\n\
    \    _last=\"$_number\"\n    if [[ $_equidistant == \"true\" ]]; then\n      _dist=\"\
    1\"\n    else\n      _dist=\"0\"\n    fi\n  fi\n\n  # Check to see if there is\
    \ a number equal to the given value\n  if [[ -n \"$_number\" && \"$_number\" ==\
    \ \"$(_number)\" ]]; then\n    _last=\"$_number\"\n    if [[ $_equidistant ==\
    \ \"true\" ]]; then\n      _dist=\"1\"\n    else\n      _dist=\"0\"\n    fi\n\
    \  fi\n\n  # Check to see if there is a number greater than or equal to the given\
    \ value\n  if [[ -n \"$_number\" && \"$_number\" -ge \"$(_number)\" ]]; then\n\
    \    _last=\"$_number\"\n    if [[ $_equidistant == \"true\" ]]; then\n      _dist=\"\
    1\"\n    else\n      _dist=\"0\"\n    fi\n  fi\n\n  # Check to see if there is\
    \ a number less than or equal to the given value\n  if [[ -n \"$_number\" && \"\
    $_number\" -le \"$(_number)\" ]]; then\n    _last=\"$_number\"\n    if [[ $_equidistant\
    \ == \"true\" ]]; then\n      _dist=\"1\"\n    else\n      _dist=\"0\"\n    fi\n\
    \  fi\n\n  # Check to see if there is a number equal to or greater than the \n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpx3sue5o1.sh: line 54: _number: command not found

    /tmp/tmpx3sue5o1.sh: line 64: _number: command not found

    /tmp/tmpx3sue5o1.sh: line 74: _number: command not found

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=${1}\n\n  # The variable $string will now contain one or more numbers\
    \ that\n  # are equidistant from each other.\n  local numbers=$(echo ${string}\
    \ | sed 's/[^0-9.]//g')\n  # The variable numbers now contains only numbers that\
    \ are\n  # equidistant from each other.\n\n  # The variable $numbers now contains\
    \ only numbers.\n  # If there are no numbers in $numbers, the variable will contain\
    \ a\n  # single number that is the sum of all digits in $string. For\n  # example,\
    \ if $numbers is \"14.5\" then $numbers contains 14 as a\n  # number because 14.5\
    \ is equidistant from 14 as well as 15.\n  if [[ ${numbers} =~ [0-9] ]]; then\n\
    \    local number=${numbers}\n  else\n    local number=0\n    local sum=0\n  \
    \  for n in ${numbers}; do\n      ((sum+=n))\n    done\n    local number=$(echo\
    \ ${sum})\n  fi\n\n  local closest=$(echo $string | sed \"s/${number}//g\")\n\n\
    \  local rounded_closest=$(( closest + $(( $(( closest % 1 )) - 1 )) ))\n\n  echo\
    \ $rounded_closest\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local min\n  local max\n  local number1\n  local number2\n  local\
    \ returnnumber\n  local diff\n  local difference\n\n  # Strip any leading zeros\
    \ from number\n  number=${number%.*}\n\n  # If the number is empty\n  if [ ${#number}\
    \ -eq 0 ]; then\n    return 0\n  fi\n\n  # Get max and min\n  max=${number}\n\
    \  min=${number}\n\n  # Set min/max to zero\n  min=0\n  max=0\n\n  # Get min and\
    \ max from number\n  for number in ${number//.}; do\n    ((min+=number))\n   \
    \ ((max-=number))\n  done\n\n  # If min == max then return number\n  if ((min\
    \ == max)); then\n    return 0\n  fi\n\n  # Get the first number\n  number1=${number}\n\
    \n  # Get the second number\n  number2=${number}\n\n  # Get difference between\
    \ them\n  diff=$((number2-number1))\n\n  # If diff is bigger than 0, add one\n\
    \  if (( diff > 0 )); then\n    diff=$((diff + 1))\n  fi\n\n  # Return difference\
    \ with closest integer\n  returnnumber=$((min + diff))\n\n  # Return number with\
    \ closest integer\n  echo \"$returnnumber\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=${1}\n    local integer=${string}\n    if [[ \"${integer}\" =~ ^-?[0-9]+$\
    \ ]]; then\n        integer=\"${integer}.0\"\n    fi\n    local digits=$(echo\
    \ \"${integer}\" | sed -e 's/^\\(-?[0-9]+\\)$/.\\1/')\n    local remainder=${integer%%${digits}}\n\
    \    local quotient=$(echo \"${integer}/${digits}\")\n    local quotient2=0\n\
    \    while [[ \"${quotient}\" -gt \"${quotient2}\" ]]; do\n        quotient2=$((\
    \ ${quotient} + 2 ))\n    done\n    if [[ $quotient != ${quotient2} ]]; then\n\
    \        quotient=\"${quotient2}\"\n    fi\n    echo ${quotient}\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprzcfx2f7.sh: line 27: [[: 10.0/10.0: syntax error: invalid arithmetic
    operator (error token is ".0/10.0")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # The\
    \ first argument should be a string\n  local STRING=$1\n  local NUMBERS=(${STRING//[^0-9\\\
    .]/})\n\n  # Remove non-numeric characters\n  local STRING_FULL=$(echo \"${STRING}\"\
    \ | tr -cd '[:digit:]')\n  local NUMBER_START=${STRING_FULL#${STRING_FULL%%[^0-9]}*}\n\
    \  local NUMBER_END=${STRING_FULL%${STRING_FULL%%[^0-9]}*}\n  local NUMBERS_START=(${NUMBER_START//[^0-9\\\
    .]/})\n  local NUMBERS_END=(${NUMBER_END//[^0-9\\.]/})\n\n  # Convert start and\
    \ end numbers to integers\n  local NUMBER_START=$((${NUMBER_START}+0))\n  local\
    \ NUMBER_END=$((${NUMBER_END}+0))\n\n  # Get the difference between the start\
    \ and end numbers\n  local DIFF_START=$((${NUMBER_START}-${NUMBERS_START}))\n\
    \  local DIFF_END=$((${NUMBER_END}-${NUMBERS_END}))\n\n  # Return the difference\
    \ if it is smaller than the difference\n  # between the two closest integers,\
    \ and return the closest integer\n  # otherwise.\n  if [[ ${DIFF_START} -le ${DIFF_END}\
    \ ]]; then\n    echo ${NUMBER_START}\n  else\n    echo ${NUMBER_END}\n  fi\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpxp4t5ds7.sh: line 34: 0-: syntax error: operand expected (error
    token is "-")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=\"$1\"\n    local min=\"$(echo \"${string}\" | cut -d \".\" -f1)\"\n\
    \    local max=\"$(echo \"${string}\" | cut -d \".\" -f2)\"\n    local num\n \
    \   if [ \"${min}\" == \"${max}\" ] ; then\n        num=\"${min}\"\n    else\n\
    \        if [ \"${min}\" -le \"${max}\" ] ; then\n            num=\"$min\"\n \
    \       else\n            local difference\n            difference=\"$(( $(echo\
    \ \"${min} - ${max}\" | bc -l) / 2 ))\"\n            num=\"$(( ${max} - ${difference}\
    \ + ${min} ))\"\n        fi\n    fi\n    echo $num\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Parse\
    \ the argument\n  local number=$1\n  # Get the current timestamp\n  local timestamp=$(date\
    \ +%s)\n  # Split the number at the period\n  local first=${number%.*}\n  local\
    \ second=${number#*.}\n  # Get the integer part of the first number\n  local integer=${first##*.}\n\
    \  # Get an integer comparison for the first number\n  local comp=(( ${first}\
    \ == ${first}+0 ))\n  # If the first number has a period\n  if [[ \"$integer\"\
    \ == \"0\" ]]; then\n    # Return it as-is if the second number is also 0\n  \
    \  if [[ \"$second\" == \"0\" ]]; then\n      echo $first\n    else\n      # Get\
    \ the difference between the two numbers\n      local diff=$(( ${second} - ${first}\
    \ ))\n      # If the second number is positive and the first is negative,\n  \
    \    # return the first number as the difference\n      if (( comp )) && [[ $diff\
    \ -gt 0 ]]; then\n        echo $first\n      else\n        # Otherwise, return\
    \ the first number and the second number\n        echo $first\n        echo $second\n\
    \      fi\n    fi\n  # If the first number does not have a period\n  else\n  \
    \  # Get the difference between the two numbers\n    local diff=$(( ${second}\
    \ - ${first} ))\n    # If the second number is negative, and the first is positive,\n\
    \    # return the second number as the difference\n    if (( comp )) && [[ $diff\
    \ -gt 0 ]]; then\n      echo $second\n    # If the second number is positive and\
    \ the first is negative,\n    # return the first number as the difference\n  \
    \  elif (( comp )) && [[ $diff -lt 0 ]]; then\n      echo $first\n    # Otherwise,\
    \ return the first number and the second number\n    else\n      echo $first\n\
    \      echo $second\n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmppvuaq0ji.sh: line 28: syntax error near unexpected token `(''

    /tmp/tmppvuaq0ji.sh: line 28: `  local comp=(( ${first} == ${first}+0 ))''

    /tmp/tmppvuaq0ji.sh: line 50: -  : syntax error: operand expected (error token
    is "-  ")

    /tmp/tmppvuaq0ji.sh: line 51: syntax error near unexpected token `}''

    /tmp/tmppvuaq0ji.sh: line 51: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value\n  local round\n\n  # Get the value passed in as the first argument, split\
    \ it at any points\n  # of whitespace and strip it of leading and trailing whitespace.\n\
    \  value=\"$1\" | tr -s ' ' | awk '{print $1}'\n\n  # Convert value to an integer\n\
    \  value=$(( \"$value\" ))\n\n  # See if the value is equidistant from two integers\n\
    \  round=$(closest_integer \"$value\")\n  if [ -z \"$round\" ]; then\n    echo\
    \ \"$value\"\n  else\n    echo -n \"$value\"\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=16 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=5 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ n=\"$1\"\n  local i=\"$(( ${n} + 1 ))\"\n  while (( ${i} > 0 )); do\n    if\
    \ (( ${n} > ${i} )); then\n      n=\"${i}\"\n    fi\n    (( i-- ))\n  done\n \
    \ echo \"$n\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=\"${1}\"\n  local num2=\"$1\"\n  local zero=\"$((num - num2))\"\n  local\
    \ distance=\"$((num2 - num))\"\n  local rounding_distance=\"$((distance - 1))\"\
    \n  local closest_int=\"$((zero + rounding_distance))\"\n  if [[ \"$closest_int\"\
    \ == \"$zero\" ]]\n  then\n    echo $closest_int\n  else\n    echo $closest_int\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ value=$1\n    local integer\n    local sign=1\n    local difference\n    local\
    \ maxdiff\n    local roundto\n    # If the number is less than zero, set it to\
    \ zero and increment the\n    # sign.\n    if [[ $value -lt 0 ]]; then\n     \
    \   sign=0\n        value=$(( 0 - value ))\n    fi\n    # Iterate over the integer\
    \ values, round them and compare them.\n    for integer in $(seq 1 $(( 10#$value\
    \ )) ); do\n        # Round the value to the closest integer.\n        value=$((\
    \ 10#$value + $sign*((10#$integer-1) % 10) ))\n        # Calculate the difference\
    \ between the given number and the\n        # rounded number.\n        difference=$((\
    \ 10#$value - $integer ))\n        # If the difference is greater than or equal\
    \ to zero and the\n        # current number is also less than the rounded number,\
    \ the number\n        # should be returned.\n        if [[ $difference -ge 0 ]]\
    \ && [[ $value -lt $integer ]]; then\n            break\n        fi\n        #\
    \ If there are still more numbers to check, then the number should\n        #\
    \ be returned if the difference is greater than or equal to\n        # maxdiff,\
    \ since that means that the difference between this and\n        # the previous\
    \ number is greater than zero.\n        if [[ $difference -gt $maxdiff ]]; then\n\
    \            maxdiff=$difference\n            roundto=$integer\n        fi\n \
    \   done\n    # Return the rounded number.\n    echo \"$value\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=\"${1}\"\n  local distance\n\n  # Make sure that number is numeric\n\
    \  if ! [[ $number =~ ^-?[0-9]+$ ]]; then\n    echo \"Invalid input. String must\
    \ be numeric.\" >&2\n    exit 1\n  fi\n\n  # Calculate distance between the two\
    \ numbers\n  if [ \"$number\" == \"0\" ]; then\n    distance=\"1\"\n  elif [ \"\
    $number\" == \"1\" ]; then\n    distance=\"0\"\n  else\n    distance=$(echo \"\
    $number\" | bc)\n  fi\n\n  # If distance is negative, round away from zero.\n\
    \  # If distance is zero, rounding away from zero is meaningless\n  if [ \"$distance\"\
    \ == \"-$distance\" ]; then\n    echo \"0\"\n  elif [ \"$distance\" == \"$distance\"\
    \ ]; then\n    echo \"$number\"\n  else\n    echo \"$(( $number + $distance ))\"\
    \n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Invalid input. String must be numeric.

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=\"$1\"\n  local first=$(echo \"$number\" | awk '{print $1}')\n  local\
    \ second=$(echo \"$number\" | awk '{print $2}')\n  local diff=$(( ($second-$first)\
    \ + abs($second-$first) ))\n  echo $(( diff < 0 ? $first : $second ))\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmp4v167y.sh: line 21: (-10) + abs(-10) : syntax error in expression
    (error token is "(-10) ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\tlocal\
    \ number=$1\n\t# Make sure we're dealing with a number, not a string\n\t[[ $number\
    \ =~ ^[0-9]+$ ]] || return 1\n\tlocal original=$number\n\t# Make sure the original\
    \ is non-negative\n\t[[ $number =~ ^-[0-9]+$ ]] || return 1\n\t# Make sure we're\
    \ dealing with integers\n\t[[ $number =~ ^[0-9]+\\.[0-9]+$ ]] || return 1\n\t\
    # Make sure the original is positive (a floating-point number may be\n\t# considered\
    \ positive)\n\t[[ $number =~ ^[0-9]+\\.[0-9]+$ ]] || return 1\n\tlocal difference\n\
    \tlocal round\n\tlocal rounded_number\n\tlocal rounded_difference\n\tlocal rounded_round\n\
    \n\tdifference=$(($number - $original))\n\t# This check is probably useless since\
    \ we already checked that the\n\t# original is non-negative, but it does ensure\
    \ that the difference is\n\t# not negative.\n\t[[ $difference =~ ^-[0-9]+$ ]]\
    \ || return 1\n\t# Round away from zero by adding 0.5\n\tdifference=$(($difference\
    \ + 0.5))\n\t# Round the difference down to an integer\n\tround=$((${difference%%.*}))\n\
    \t# Round the original down to an integer\n\trounded_number=$(($original - $round))\n\
    \n\t# If the difference was 0, return the original number\n\tif [[ ${difference}\
    \ == 0 ]]; then\n\t\treturn 0\n\telse\n\t\t# If the difference was negative, return\
    \ the original number\n\t\tif [[ ${difference} < 0 ]]; then\n\t\t\treturn 0\n\t\
    \t# If the difference was positive, round to integer and return\n\t\telse\n\t\t\
    \treturn $rounded_number\n\t\tfi\n\tfi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Make\
    \ sure the input is indeed a string\n  typeset -i number=\"$1\"\n  # Make sure\
    \ the first character is a number\n  [[ \"$number\" =~ ^[0-9]+$ ]]\n  # Remove\
    \ all non numeric characters\n  number=\"${number//[^0-9]/}\"\n  # If there are\
    \ no digits in the string, return it\n  [[ ${#number} -eq 0 ]]\n  # If there is\
    \ one digit, return it\n  [[ ${#number} -eq 1 ]]\n  # If the number is positive,\
    \ add 1 to it\n  # If the number is negative, subtract 1 from it\n  case \"${number}\"\
    \ in\n    \"1\" | \"+1\")\n      number=$(($number + 1))\n      ;;\n    \"-1\"\
    \ | \"-1\")\n      number=$(($number - 1))\n      ;;\n    *)\n      number=$(($number\
    \ - 1))\n      ;;\n  esac\n  # Make sure the number is greater than 0\n  [[ -z\
    \ $number ]] && number=\"0\"\n  # Return the result\n  echo \"$number\"\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ STRING=\"$1\"\n    local NUM=\"${STRING%%[!0-9]*}\"\n    local MOD=\"${NUM%%[^!0-9]*}\"\
    \n    if [[ -z \"$MOD\" ]]; then\n        local MOD=\"$NUM\"\n    fi\n    local\
    \ MODNUM=\"$(echo -e \"${MOD}\" | tr -cd '[:digit:]')\"\n    local MODMODNUM=\"\
    $(echo -e \"${MODNUM}\" | tr -cd '[:digit:]')\"\n    local MODMODMODNUM=\"$(echo\
    \ -e \"${MODMODNUM}\" | tr -cd '[:digit:]')\"\n    local RESULT=\"$(echo -e \"\
    ${NUM}\" | tr -cd '[:digit:]')\"\n    if [[ \"$RESULT\" -ge \"$MODMODNUM\" ]];\
    \ then\n        local NEWRESULT=\"$RESULT\"\n    else\n        if [[ \"$RESULT\"\
    \ -ge \"$MODNUM\" ]]; then\n            local NEWRESULT=\"$MODMODNUM\"\n     \
    \   else\n            if [[ \"$RESULT\" -ge \"$MODMODNUM\" ]]; then\n        \
    \        local NEWRESULT=\"$MODMODMODNUM\"\n            else\n               \
    \ if [[ \"$RESULT\" -ge \"$MODNUM\" ]]; then\n                    local NEWRESULT=\"\
    $MODMODNUM\"\n                else\n                    local NEWRESULT=\"$MODMODMODNUM\"\
    \n                fi\n            fi\n        fi\n    fi\n    echo \"$NEWRESULT\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=${1}\n\n  # If there are no integers, return empty string\n  if [ -z\
    \ \"$string\" ]; then\n    return \"\"\n  fi\n\n  # Split string by decimal point\n\
    \  local integers=$(echo $string | sed 's/[^0-9\\.]//g')\n\n  # If there is only\
    \ one integer, return it\n  if [ ! -z \"$integers\" ]; then\n    return $integers\n\
    \  fi\n\n  # If there are two or more integers, get closest to 0\n  if [ $((${#integers}\
    \ % 2)) -eq 0 ]; then\n    local result=0\n    local base=${#integers}\n    local\
    \ digits=${#integers}\n    local digit\n    local difference\n\n    # Find two\
    \ closest integer to each other\n    for (( digit=0; digit < digits-1; digit++\
    \ )); do\n      if [ $((${integers%.}${digit})) = $((${integers%.}${digit+1}))\
    \ ]; then\n        local tmp=$((${integers%.}${digit+1}))\n        local distance=$(closest_integer\
    \ \"0.$tmp\")\n\n        if [ -z \"$distance\" ]; then\n          distance=$(closest_integer\
    \ \"0.$tmp\")\n        fi\n\n        difference=$(( ${digit}-distance ))\n   \
    \     break\n      fi\n    done\n\n    # If difference is negative, result is\
    \ lower\n    if [ -n \"$difference\" ]; then\n      result=$(( $difference*${base}+$base+${digits-1}))\n\
    \    else\n      result=$(( $digits+1 ))\n    fi\n    return $result\n  fi\n\n\
    \  # If there is only two integers, return it\n  if [ $((${#integers} % 2)) -eq\
    \ 0 ]; then\n    return $((${integers} % 2))\n  fi\n\n  # If there are three or\
    \ more integers, return nearest to zero\n  if [ $((${#integers} % 3)) -eq 0 ];\
    \ then\n    local result=0\n    local base=${#integers}\n    local digits=${#integers}\n\
    \    local digit\n    local difference\n    local tmp1\n    local tmp2\n\n   \
    \ # Find two closest integers to each other\n    for (( digit=0; digit < digits-1;\
    \ digit++ )); do\n      tmp1=$((${integers%.}${digit}))\n      tmp2=$((${integers%.}${digit+1}))\n\
    \      if [ $((${integers%.}${digit})) = $((${integers%.}${digit+1})) ]; then\n\
    \        difference=$(( $digit-$((${digit\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptz6mgx56.sh: line 85: unexpected EOF while looking for matching
    `)''

    /tmp/tmptz6mgx56.sh: line 102: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ value=$1\n    local sign=\n    # Find the sign of the number\n    if [ $value\
    \ == \"-\" ];then\n        sign=\n    else\n        sign=\n    fi\n\n    local\
    \ number=\"$(echo \"${value}\" | bc)\"\n    local closest\n    local closestCount\n\
    \    local nextNumber\n    local nextNumberCount\n\n    if [ \"${number}\" ==\
    \ \"0\" ];then\n        closest=\"0\"\n    elif [ \"${number}\" == \"1\" ];then\n\
    \        closest=\"1\"\n    elif [ \"${number}\" == \"9\" ];then\n        closest=\"\
    9\"\n    else\n        closest=\"$(echo \"${sign}${number}\" | bc | cut -d '.'\
    \ -f 1)\"\n    fi\n\n    local i=2\n    local closestCount=0\n    while [ \"${closest}\"\
    \ == \"${i}\" ];do\n        local nextNumber=\"$(echo \"${sign}${i}\" | bc)\"\n\
    \        local nextNumberCount=0\n        if [ \"${nextNumber}\" == \"0\" ];then\n\
    \            nextNumberCount=0\n        elif [ \"${nextNumber}\" == \"1\" ];then\n\
    \            nextNumberCount=1\n        elif [ \"${nextNumber}\" == \"9\" ];then\n\
    \            nextNumberCount=9\n        else\n            nextNumberCount=$(echo\
    \ \"${nextNumber}\" | bc | cut -d '.' -f 1)\n        fi\n\n        if [ \"$nextNumberCount\"\
    \ -gt \"$closestCount\" ];then\n            closest=\"$nextNumber\"\n        \
    \    closestCount=$nextNumberCount\n        fi\n\n        i=$((i+1))\n    done\n\
    \n    echo \"${closest}\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ STRING=$1\n\n  # Strip trailing period\n  local STRIPPED=${STRING%.}\n  local\
    \ N=${STRIPPED##*\\.}\n  if (( $N == 0 )); then\n    N=$(( $STRING == 0 ? 10 :\
    \ 10 ))\n  fi\n\n  # Strip leading zeroes\n  local ZEROED=$(echo $STRIPPED | sed\
    \ -e 's/^0\\([0-9]*\\)/\\1/')\n  local INT_TO_TEST=$(( $ZEROED ))\n\n  # This\
    \ for loop checks every other integer before returning the\n  # integer that is\
    \ closest to the provided one. For example\n  # closest_integer(\"14.5\") returns\
    \ 14 and closest_integer(\"-14.5\")\n  # returns -14\n  for (( NI = 1; NI <= 10;\
    \ NI++ )); do\n    local INT=$(( $INT_TO_TEST + $NI ))\n    # If the integer is\
    \ equidistant from two integers, return the \n    # one that is farthest from\
    \ zero.\n    if (( $INT < 0 )); then\n      if (( $NI == 0 )); then\n        INT=$N\n\
    \      fi\n    else\n      if (( $NI > 0 )); then\n        INT=$N\n        break\n\
    \      fi\n    fi\n  done\n\n  # Convert to string\n  echo $INT\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp712cqe5e.sh: line 29: 14.5 : syntax error: invalid arithmetic operator
    (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ IFS='.' read -r -a array <<<\"$1\"\n  local cutoff=\"$2\"\n  local diff max\n\
    \  diff=\"${array[0]}${array[1]}\"\n  max=\"${array[1]}\"\n  for i in \"${array[@]:2}\"\
    ; do\n    (( diff += i ))\n    if (( diff > cutoff )); then\n      diff=$(( diff\
    \ - cutoff ))\n      max=\"$i\"\n    fi\n  done\n  echo \"$max\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp1ae1zt97.sh: line 18: local: `-r'': not a valid identifier

    /tmp/tmp1ae1zt97.sh: line 18: local: `-a'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=\"$1\"\n    local result=\"$1\"\n    local last=\"$1\"\n    local diff\n\
    \    while [ $last = \"$1\" ]; do\n        diff=\"$(echo \"$number - $result\"\
    \ | bc)\"\n        if [[ $diff -lt 0 ]]; then\n            result=\"$result\"\n\
    \        elif [[ $diff -gt 0 ]]; then\n            result=\"$result\"\n      \
    \      ((result++))\n        fi\n        last=\"$result\"\n        ((result++))\n\
    \    done\n    echo \"$result\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ NUM=\"$1\"\n  local MIN=\"$2\"\n  local MAX=\"$3\"\n  local CLOSEST=\"$(echo\
    \ \"${NUM}\" | awk -F. -v min=\"${MIN}\" -v max=\"${MAX}\" 'BEGIN { \n    # Find\
    \ difference between the numbers\n    dif = ( max - min )\n    # Handle \"equal\"\
    \ numbers\n    if ( dif == 0 ) return max\n    # Find the nearest integer\n  \
    \  for( i = 1; i <= diff; i++ ) if ( dif / i == i ) { \n      n = ( dif / i )\
    \ * i\n      break\n    } \n    # Handle \"farthest\" numbers\n    if ( i == diff\
    \ ) return -max\n    # Find the closest integer\n    for( i = diff; i <= 1; i--\
    \ ) if ( dif / i == i ) {\n      n = ( dif / i ) * i\n      break\n    }\n  }')\"\
    \n  echo \"${CLOSEST}\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:5:     if ( dif == 0 ) return max

    awk: cmd. line:5:                     ^ `return'' used outside function context

    awk: cmd. line:12:     if ( i == diff ) return -max

    awk: cmd. line:12:                      ^ `return'' used outside function context

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ STRING=$1\n    if [[ \"$STRING\" =~ ^[0-9]*$ ]]; then\n        local NUM=$((\
    \ $(echo \"$STRING\" | cut -d \".\" -f1) ))\n        local NUM2=$(( $(echo \"\
    $STRING\" | cut -d \".\" -f2) ))\n        local DIFF=$(( ${NUM}-${NUM2} ))\n \
    \       if (( ${DIFF} < 0 )); then\n            NUM2=$(( ${NUM} + ( ${DIFF} %\
    \ ${NUM2} )))\n        fi\n        echo $(( ${NUM2} + ${DIFF} / ${NUM} ))\n  \
    \  else\n        echo \"Error: input was not a number\"\n    fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=$1\n  # Remove the leading sign, if any\n  local int_string=${string:${#string}-1}\n\
    \  # Check if there is any number at all before the decimal point\n  if [[ ${string:0:1}\
    \ = - ]]; then\n    echo \"ERROR: Number with leading '-' is not an integer.\"\
    \n    exit 1\n  fi\n  local last_char=${string:(-1)}\n  if [[ ${last_char} = .\
    \ ]]; then\n    echo \"ERROR: Number with trailing '.' is not an integer.\"\n\
    \    exit 1\n  fi\n  # Check there are no digits before the decimal point\n  if\
    \ [[ ${string:0:1} = - ]]; then\n    echo \"ERROR: Number with leading '-' is\
    \ not an integer.\"\n    exit 1\n  fi\n  # Check if there is any number at all\
    \ after the decimal point\n  if [[ ${string:(-1)} = . ]]; then\n    echo \"ERROR:\
    \ Number with trailing '.' is not an integer.\"\n    exit 1\n  fi\n  # Remove\
    \ the decimal point\n  local new_string=${string:0:-1}\n  # Convert it to a decimal\n\
    \  local int=\"${new_string}\"\n  local dec=\"${string:(-1)}\"\n  # If the number\
    \ is too large (greater than 9223372036854775807), then no integer\n  # is guaranteed\
    \ to exist, so return 0\n  if (( int > 9223372036854775807 )); then\n    local\
    \ ret=0\n  elif (( int < -9223372036854775808 )); then\n    local ret=0\n  else\n\
    \    local dec=${int}\n    local ret=$(echo $dec | bc)\n    if (( $ret == 0 ));\n\
    \    then\n      echo \"ERROR: Number '${new_string}' is not an integer and cannot\
    \ be converted to an integer.\"\n      exit 1\n    fi\n  fi\n  echo \"${ret}\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ NUMBER=$1\n    local FARTHER=3\n    local NEXT=15\n    local MODULO=0\n    local\
    \ RESULT=\"$NUMBER\"\n\n    while [ \"$NUMBER\" -gt \"$RESULT\" ] && [ \"$NUMBER\"\
    \ -ne \"$NEXT\" ]; then\n        MODULO=$((NUMBER % $RESULT))\n        RESULT=$((NUMBER\
    \ - MODULO))\n        NEXT=$((NEXT + MODULO))\n\n        if [ \"$RESULT\" -eq\
    \ \"$FARTHER\" ]; then\n            RESULT=\"$NUMBER\"\n        fi\n        if\
    \ [ \"$NUMBER\" -eq \"$FARTHER\" ]; then\n            RESULT=\"$NEXT\"\n     \
    \   fi\n    fi\n    echo \"$RESULT\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjebrowrk.sh: line 24: syntax error near unexpected token `then''

    /tmp/tmpjebrowrk.sh: line 24: `    while [ "$NUMBER" -gt "$RESULT" ] && [ "$NUMBER"
    -ne "$NEXT" ]; then''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ n=$1\n  local maxdiff=10\n  # check if n is an integer\n  local intcheck\n \
    \ if [[ $n =~ ^-?[0-9]+$ ]]; then\n    # check if the number is an integer, and\
    \ less than 2^31-1\n    if [[ $n =~ ^-?[0-9]+$ ]] && [[ $n -lt 2^31-1 ]]; then\n\
    \      # check if the number is negative\n      local isneg\n      isneg=$(echo\
    \ $n | awk '{exit ( $0 ~ /^\\-/ )}')\n      if [[ $isneg ]]; then\n        n=$(($n\
    \ - $maxdiff))\n      else\n        n=$(($n + $maxdiff))\n      fi\n      intcheck=1\n\
    \    else\n      echo \"ERROR: Expected a positive number, but got $n\"\n    \
    \  return 1\n    fi\n  else\n    echo \"ERROR: Expected a positive number, but\
    \ got $n\"\n    return 1\n  fi\n  local prevint=-1\n  local prevdiff=-1\n  local\
    \ numdiff=-1\n  local num=0\n  local numstr\n  while true; do\n    num=$(expr\
    \ $n \\* 10 + 1)\n    numstr=$(printf \"%04d\" $num)\n    if [ \"$numstr\" ==\
    \ \"$n\" ]; then\n      break\n    fi\n    # check if the number is an integer,\
    \ and less than 2^31-1\n    if [[ $numstr =~ ^-?[0-9]+$ ]] && [[ $numstr -lt 2^31-1\
    \ ]]; then\n      # check if the number is negative\n      local isneg\n     \
    \ isneg=$(echo $numstr | awk '{exit ( $0 ~ /^\\-/ )}')\n      if [[ $isneg ]];\
    \ then\n        numstr=$(($numstr - $maxdiff))\n      else\n        numstr=$(($numstr\
    \ + $maxdiff))\n      fi\n      intcheck=1\n    else\n      echo \"ERROR: Expected\
    \ a positive number, but got $numstr\"\n      return 1\n    fi\n    if [ \"$prevint\"\
    \ == \"$num\" ]; then\n      numdiff=$((numdiff + 1))\n    else\n      if [ \"\
    $prevint\" == \"$numdiff\" ]; then\n        prevdiff=$((prevdiff + 1))\n     \
    \ else\n        prevdiff=1\n      fi\n      numdiff=1\n      numstr=$(printf \"\
    %04d\" $num)\n      prevint=$num\n    fi\n    if [ $numdiff -gt $maxdiff ]; then\n\
    \      maxdiff=$numdiff\n    fi\n  done\n  echo $numstr\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n      \
    \  local value=\"${1}\"\n        local val=${value}\n        local diff=0\n  \
    \      # Strip leading zeros, if any\n        value=${value#0}\n        value=${value%%.*}\n\
    \        val=${val#0}\n        val=${val%%.*}\n\n        while [ -n \"$value\"\
    \ ]\n        do\n                val2=$(( val + diff ))\n                val3=$((\
    \ val + diff ))\n                val4=$(( val + diff ))\n\n                # Avoid\
    \ negative values\n                if [ -n \"$val2\" ] && [ \"$val2\" -gt \"$val\"\
    \ ]\n                then\n                        diff=$(( $val2 - val ))\n \
    \                       val=$val2\n                elif [ -n \"$val3\" ] && [\
    \ \"$val3\" -gt \"$val\" ]\n                then\n                        diff=$((\
    \ $val3 - val ))\n                        val=$val3\n                elif [ -n\
    \ \"$val4\" ] && [ \"$val4\" -gt \"$val\" ]\n                then\n          \
    \              diff=$(( $val4 - val ))\n                        val=$val4\n  \
    \              else\n                        diff=0\n                fi\n    \
    \    done\n        echo \"$val\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=58 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=45 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ str=$1\n  local num=$(echo $str |awk '{print $1; exit}')\n  local digits=$((10#${str%%%.*}))\n\
    \  local digits_count=$(echo $digits |wc -w)\n  local digits_sum=$(($digits *\
    \ $digits_count))\n  local digits_diff=$(($digits - $digits_sum))\n  local closest_integer=$(($((10#$digits_sum/$digits_count)*$digits_count))\
    \ \\\n                             -1 \\\n                             -$digits_diff)\n\
    \  if (( $closest_integer < 0 ))\n  then\n    closest_integer=$((10#$closest_integer))\n\
    \  fi\n  echo $closest_integer\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpzlkwe6mv.sh: command substitution: line 26: syntax error near unexpected
    token `-1''

    /tmp/tmpzlkwe6mv.sh: command substitution: line 26: `($((10#$digits_sum/$digits_count)*$digits_count))                              -1                              -$digits_diff''

    /tmp/tmpzlkwe6mv.sh: line 27: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ NUM=$1\n    local FIRST_INTEGER=0\n    local SECOND_INTEGER=0\n    local MID_VALUE=0\n\
    \n    if [[ -z \"$NUM\" ]]; then\n        echo >&2 \"Usage: $(basename \"$0\"\
    ) [number]\"\n        return 1\n    fi\n\n    # Convert to decimal\n    local\
    \ DEC=`echo \"$NUM\" | bc -l`\n    # Check for negative\n    if [[ \"$NUM\" <\
    \ 0 ]]; then\n        DEC=$((-$DEC))\n    fi\n\n    local FIRST_INTEGER=0\n  \
    \  local SECOND_INTEGER=0\n\n    # Loop until we find a better match\n    while\
    \ [[ \"$FIRST_INTEGER\" -lt \"$DEC\" ]] || [[ \"$SECOND_INTEGER\" -lt \"$DEC\"\
    \ ]]; do\n        FIRST_INTEGER=$(( $FIRST_INTEGER + 1 ))\n        SECOND_INTEGER=$((\
    \ $SECOND_INTEGER + 1 ))\n\n        MID_VALUE=$(( $NUM - $DEC ))\n    fi\n\n \
    \   # Round the result away from zero\n    if [[ \"$MID_VALUE\" -eq 0 ]]; then\n\
    \        local NEG_DEC=$(( 1 -$DEC ))\n        NEG_DEC=$(( $NEG_DEC + 1 ))\n \
    \       local NEG_NUM=$(( -$MID_VALUE ))\n\n        FIRST_INTEGER=$(( 0 ))\n \
    \       SECOND_INTEGER=$(( 1 ))\n\n        while [[ \"$FIRST_INTEGER\" -lt \"\
    $NEG_DEC\" ]] || [[ \"$SECOND_INTEGER\" -lt \"$NEG_DEC\" ]]; do\n            FIRST_INTEGER=$((\
    \ $FIRST_INTEGER + 1 ))\n            SECOND_INTEGER=$(( $SECOND_INTEGER + 1 ))\n\
    \        done\n    fi\n\n    echo $(( $FIRST_INTEGER ))\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpp0y22xnh.sh: line 44: syntax error near unexpected token `fi''

    /tmp/tmpp0y22xnh.sh: line 44: `    fi''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  [[ \"\
    $1\" =~ ^-?[0-9]+$ ]] || return 1\n  local d=0\n  local e=0\n  local x=$1\n  local\
    \ y=1\n  while (( x > y )); do\n    x=y\n    y=d\n    d=$((d + 1))\n    e=$((e\
    \ + 1))\n  done\n  local final=$(( x - y))\n  [[ $d -gt $e ]] && return $(( final\
    \ - abs( final - x )))\n  return $(( final - abs( final - y )))\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfdq1hd8q.sh: line 31: final - abs( final - y ): syntax error in
    expression (error token is "( final - y )")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ x=$1;\n    local max=$((${#x} + 1));\n    for ((i=1; i<=max; i++)); do\n   \
    \     [[ ${#x} -eq ${i} ]] && break;\n        local d=$(expr $x - $i);\n     \
    \   [[ ${d} -le 0 ]] && break;\n        local diff=$(expr $i + 1);\n        [[\
    \ ${#diff} -eq ${i} ]] && diff=0;\n        local d=$(expr $d - $diff);\n     \
    \   local i=$(expr $i - 1);\n        [[ -z ${i} ]] && break;\n    done;\n    echo\
    \ $i;\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=50 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=48 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    if\
    \ [ ! -z \"$1\" ]; then\n        local x=\"$1\"\n        # Check if the number\
    \ is equidistant\n        local y\n        if [ \"$1\" == \"$x\" ]; then\n   \
    \         # If the number is equidistant, return it\n            return 0\n  \
    \      else\n            # Get the two numbers and find the closest integer\n\
    \            x=$($x | cut -d\\. -f1)\n            y=$($x | cut -d\\. -f2)\n  \
    \          if [ \"$y\" == \"$x\" ]; then\n                # If the two numbers\
    \ are equidistant, round them away from zero\n                x=$($x | cut -d\\\
    . -f1)\n                x=${x:-0}\n            fi\n        fi\n        # Return\
    \ the number\n        return $x\n    fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  if [ -z \"$number\" ]\n  then\n    return 0\n  fi\n  local closest_num=$((\
    \ $number + $number / 2 ))\n  local closest_integer=$(( $closest_num % $number\
    \ ))\n  local decimal=$(( $closest_num / $number ))\n  if [ -z $decimal ]\n  then\n\
    \    echo \"$closest_integer\"\n  else\n    echo \"$closest_integer $decimal\"\
    \n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n\n  # make sure it is numeric\n  [[ \"$number\" =~ ^[0-9]+$ ]] ||\
    \ return 1\n\n  # make sure it isn't too small or too big\n  local lowerBound=10\n\
    \  local upperBound=10e200\n\n  # get the lower and upper bounds\n  while [[ \"\
    $number\" -lt \"$lowerBound\" || \"$number\" -gt \"$upperBound\" ]]; do\n    ((\
    \ lowerBound = $lowerBound + 1 ))\n    (( upperBound = $upperBound - 1 ))\n  done\n\
    \n  # now return the closest integer\n  local closestInt=\n  while [[ \"$number\"\
    \ -eq \"$closestInt\" ]]; do\n    (( closestInt = ( $closestInt + 1 )))\n  done\n\
    \n  echo \"$closestInt\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpf0ufpkd5.sh: line 28: [[: 10e200: value too great for base (error
    token is "10e200")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  (( $# > 1 )) && echo \"Too many arguments\"\n  (( $# < 1 )) &&\
    \ echo \"Too few arguments\"\n  local i=0 closest=$number prev_closest=$number\n\
    \  local closest2=$number prev_closest2=$number\n  (( $# == 1 )) && echo \"Too\
    \ few arguments\"\n  local -n result=$( closest_integer $2 )\n  result=$result\n\
    \  (( $result == 0 )) && return $result\n  while [ $i -lt 10 ]; do\n    closest=$(($closest+$(($closest-$prev_closest))))\n\
    \    prev_closest=$closest\n    closest2=$(($closest2+$(($closest2-$prev_closest2))))\n\
    \    prev_closest2=$closest2\n    i=$((i+1))\n  done\n  (( $closest < $closest2\
    \ )) && return $closest\n  (( $closest > $closest2 )) && return $closest2\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=29 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=6 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ NUM=\"$1\"\n  local CLOSEST\n  CLOSEST=$NUM\n  local NUM2\n  NUM2=$(echo \"\
    $NUM + 1\" | bc)\n  if [ \"$NUM\" = \"$NUM2\" ]; then\n    CLOSEST=$NUM\n  else\n\
    \    local NUM3\n    NUM3=$(echo \"$NUM - 1\" | bc)\n    if [ \"$NUM\" = \"$NUM3\"\
    \ ]; then\n      CLOSEST=$NUM\n    fi\n  fi\n  echo \"$CLOSEST\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Convert\
    \ $1 to a float\n  num=$(echo \"$1\" | tr '[:upper:]' '[:lower:]')\n  num=$(echo\
    \ \"$num\" | sed -e 's/^\\([0-9]*\\).*$/0\\1/')\n  num=$(echo \"$num\" | sed -e\
    \ 's/^0*//')\n  num=$(echo \"$num\" | sed -e 's/^\\([-+]*\\)\\([0-9]*\\).*/\\\
    2\\1/')\n  num=$(echo \"$num\" | sed -e 's/^0*//')\n  num=$(echo \"$num\" | sed\
    \ -e 's/^-\\([0-9]*\\)\\([0-9]*\\).*/\\2\\1/')\n  num=$(echo \"$num\" | sed -e\
    \ 's/^-*//')\n  num=$(echo \"$num\" | sed -e 's/^-*//')\n\n  # Convert the number\
    \ to a base 10 number\n  num=$(echo \"$num\" | sed -e 's/^\\([0-9]*\\)\\([-+]*\\\
    )\\([0-9]*\\)\\([-+]*\\)\\([0-9]*\\).*$/\\2\\/\\1\\/\\3/')\n\n  # Round the number\
    \ up or down\n  num=$(echo \"$num\" | sed -e 's/^\\([-+]*\\)\\([0-9]*\\)$/\\1\\\
    /\\1/')\n  num=$(echo \"$num\" | sed -e 's/^\\([0-9]*\\)$/\\1/')\n\n  # Convert\
    \ the number to a base 10 number\n  num=$(echo \"$num\" | sed -e 's/^\\([-+]*\\\
    )\\([0-9]*\\)\\([-+]*\\)\\([0-9]*\\)$/\\1\\/\\3/')\n\n  # Return the number\n\
    \  echo \"$num\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [\
    \ -z \"$1\" ]; then\n    echo\n  fi\n  local number=$1\n  local min=$(($((${number%.*}-0))));\n\
    \  local max=$(($((${number%.*}-0))));\n  if [ $number -gt $min ]; then\n    echo\
    \ \"$number\"\n  else\n    echo \"$max\"\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp03e1qsqd.sh: line 24: [: 14.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=\"$1\"\n  # Check if number is either \"0\" or is empty\n  [[ \"$number\"\
    \ =~ ^(0|)$ ]] || return 1\n  # Check if the given number is a float\n  [[ \"\
    $number\" =~ ^(-)?([0-9]*\\.[0-9]+)$ ]] || return 1\n  # Split string into integer\
    \ and decimal part\n  local integer_part=$1\n  local decimal_part=$2\n  # Check\
    \ if decimal part is empty\n  [[ \"$decimal_part\" =~ ^(-)$ ]] || return 1\n \
    \ # Check if the integer part is negative\n  [[ \"$integer_part\" =~ ^(-)$ ]]\
    \ || integer_part=$1\n  # Check if decimal part is negative\n  [[ \"$decimal_part\"\
    \ =~ ^(-)$ ]] || decimal_part=$2\n  # Check if decimal part is zero\n  [[ \"$decimal_part\"\
    \ =~ ^(0)$ ]] || return 1\n  # Split integer and decimal part\n  local integer=$1\n\
    \  local decimal=$2\n  # Check if decimal part is a float\n  [[ \"$decimal\" =~\
    \ ^(-)?([0-9]*\\.[0-9]+)$ ]] || return 1\n  # Check if the integer part is negative\n\
    \  [[ \"$integer\" =~ ^(-)$ ]] || integer=$1\n  # Check if decimal part is negative\n\
    \  [[ \"$decimal\" =~ ^(-)$ ]] || decimal=$2\n  # Check if the decimal part is\
    \ zero\n  [[ \"$decimal\" =~ ^(0)$ ]] || return 1\n  # Check if decimal part is\
    \ an integer\n  [[ \"$decimal\" =~ ^(-)?([0-9]+)$ ]] || return 1\n  # Find closest\
    \ integer if decimal part is integer\n  local closest\n  if [[ $decimal -eq \"\
    $integer\" ]]; then\n    closest=$integer\n  else\n    closest=$(( $decimal <\
    \ $integer ? $integer : $decimal ))\n  fi\n  echo $closest\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ STRING=$1\n  local NUMBER=0\n  local MIN_VALUE=1000000000 # Minimum possible\
    \ number\n  local MAX_VALUE=0 # Maximum possible number\n  local EXIT_CODE=0 #\
    \ Standard exit code\n  local DIFF\n  local NEXT\n  local NEXT_MAX\n  local NEXT_MIN\n\
    \  local PREV\n  local PREV_MAX\n  local PREV_MIN\n  # Parse the string\n  NEXT_MAX=0\n\
    \  NEXT_MIN=0\n  PREV_MAX=0\n  PREV_MIN=0\n  for NEXT in $STRING; do\n    case\
    \ \"$NEXT\" in\n      \"-\")\n        DIFF=$(( $(( MAX_VALUE - $NEXT )) ))\n \
    \     ;;\n      \"+\")\n        DIFF=$(( $(( $NEXT + MIN_VALUE )) ))\n      ;;\n\
    \      \".\")\n        DIFF=0\n      ;;\n      *)\n        DIFF=$(( $( (( $NEXT\
    \ + MIN_VALUE )) < $(( MAX_VALUE - MIN_VALUE )) ) ))\n      ;;\n    esac\n   \
    \ if [ $DIFF -gt 0 ] ; then\n      break\n    elif [ $DIFF -le 0 ] ; then\n  \
    \    DIFF=$(( $DIFF + 1 ))\n    fi\n    case \"$DIFF\" in\n      0)\n        DIFF=1\n\
    \        ;;\n      1)\n        DIFF=2\n        ;;\n      2)\n        DIFF=3\n\
    \        ;;\n      3)\n        DIFF=4\n        ;;\n      4)\n        DIFF=5\n\
    \        ;;\n      5)\n        DIFF=6\n        ;;\n      6)\n        DIFF=7\n\
    \        ;;\n      7)\n        DIFF=8\n        ;;\n      8)\n        DIFF=9\n\
    \        ;;\n      9)\n        DIFF=10\n        ;;\n      *)\n        DIFF=$((\
    \ $DIFF + 1 ))\n        ;;\n    esac\n    case \"$DIFF\" in\n      0)\n      \
    \  DIFF=1\n        ;;\n      1)\n        DIFF=2\n        ;;\n      2)\n      \
    \  DIFF=3\n        ;;\n      3)\n        DIFF=4\n        ;;\n      4)\n      \
    \  DIFF=5\n        ;;\n      5)\n        DIFF=6\n        ;;\n      6)\n      \
    \  DIFF=7\n        ;;\n      7)\n        DIFF=8\n        ;;\n      8)\n      \
    \  DIFF=9\n        ;;\n      9)\n        DIFF=10\n        ;;\n    e\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjm23hpex.sh: line 121: syntax error near unexpected token `newline''

    /tmp/tmpjm23hpex.sh: line 121: `    e''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [\
    \ $# -ne 1 ]; then\n    echo \"Usage: $(basename $0) number\"\n    echo \"The\
    \ number must be a string\"\n    exit 1\n  fi\n\n  local string=\"$1\"\n  local\
    \ num=\"-1\"\n\n  if [[ ${string} =~ ^[+-]?([0-9]+|[0-9]*\\.[0-9]+)$ ]]; then\n\
    \    local num=\"$1\"\n  elif [[ ${string} =~ ^[0-9]+\\.[0-9]+$ ]]; then\n   \
    \ local num=\"${string%.*}\"\n  else\n    echo \"${string} is not a number\"\n\
    \    exit 1\n  fi\n\n  local max=\"$(( 10 * ${num} ))\"\n\n  if [[ ${num} -eq\
    \ 1 ]]; then\n    echo \"0\"\n  elif [[ ${num} -gt ${max} ]]; then\n    echo \"\
    ${max}\"\n  elif [[ ${num} -lt 0 ]]; then\n    echo \"0\"\n  else\n    local mod=\"\
    ${num%%/*}\"\n\n    while [[ ${mod} -gt 0 ]]; do\n      if [[ ${mod} -le ${max}\
    \ ]]; then\n        echo \"${mod}\"\n        break\n      fi\n      mod=\"${mod%/*}\"\
    \n    done\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpp899munq.sh: line 36: 10 * 14.5 : syntax error: invalid arithmetic
    operator (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=\"$1\"\n  # Check that the string is a number\n  [[ \"$number\" =~ ^[0-9]+$\
    \ ]] || return 1\n  # Check that it isn't too big or too small\n  [[ \"$number\"\
    \ -le \"0\" ]] && return 1 || [[ \"$number\" -gt \"0\" ]] && return 1\n  # Check\
    \ that the number is equidistant from zero\n  local base=\"$((${number%%.*} +\
    \ 1))\"\n  local base2=\"$((${base%%.*} + 1))\"\n  (( $base2 > $base )) && return\
    \ 1\n  (( $number < 0 )) && return 1\n  (( $number > 0 )) && return $base\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ input_number=$1\n    local closest_integer=$(grep -Po \"[0-9]+\\.?[0-9]*$\"\
    \ <<< \"$input_number\" | sort -n | tail -n 1)\n    echo \"$closest_integer\"\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # We\
    \ use the fact that the difference between $1 and $2 is at most one\n  # million\n\
    \  (( \"$1\" - \"$2\" ))\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpvgeij6ba.sh: line 20: ((: 10 -  : syntax error: operand expected
    (error token is "-  ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=$1\n  local val=${val%.*}\n  local factor=1\n  if [[ $val = \"0\" ]]; then\n\
    \    echo \"0\"\n    return\n  fi\n  while (( val > 0 )) ; do\n    (( val = val\
    \ / factor ))\n    (( factor *= 10 ))\n  done\n  (( val == 0 ))\n  echo $val\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ str=$1\n  local a=\"${str%.*}\"\n  local b=\"${str##*.}\"\n  local c=\"${str%.*}\"\
    \n  local d=\"${str##*.}\"\n  local e=\"${str##*.}\"\n  local f=\"${str##*.}\"\
    \n  local g=\"${str##*.}\"\n  local h=\"${str##*.}\"\n  local i=\"${str##*.}\"\
    \n\n  local j=\"${a}${b}${c}${d}${e}${f}${g}${h}${i}\"\n  local k=\"$j\"\n  local\
    \ l=$(( ${j} > ${k} ? ${j} : ${k} ))\n  echo \"$l\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  # Parse number into its integer part.\n  local integer=\"${number%%.*}\"\
    \n  # Parse number into its decimal part.\n  local decimal_part=\"${number#$integer}\"\
    \n  # Round the decimal part away from zero.\n  local rounded_decimal_part=$(echo\
    \ \"${decimal_part}\" | bc -c)\n  # Add it back on to the integer part.\n  local\
    \ rounding_result=\"$integer$rounded_decimal_part\"\n  # Convert the rounded decimal\
    \ part back to a string.\n  echo \"${rounding_result}\"\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=\"$1\"\n    local max=0\n    local min=1\n    local difference\n    local\
    \ closest_integer\n    local temp\n\n    if [[ $string =~ ^-?[0-9]+(.[0-9]+)?$\
    \ ]]; then\n        # number starts with -?\n        temp=$(echo \"${string}\"\
    \ | sed -e 's/^\\(-?[0-9]\\+\\)\\(\\.\\)\\([0-9]*\\)/\\1/g')\n        # Remove\
    \ \"-\" from beginning\n        case \"${temp}\" in\n            (-*)\n      \
    \          temp=\"${temp:1}\"\n                ;;\n            (*)\n         \
    \       # Keep \"-\"\n                ;;\n        esac\n    else\n        case\
    \ \"$string\" in\n            (*)\n                echo \"$string\"\n        \
    \        ;;\n        esac\n        return\n    fi\n\n    while true; do\n    \
    \    if [[ $string -eq \"$min\" || $string -eq \"$max\" ]]; then\n           \
    \ echo \"$string\"\n            break\n        fi\n        if [[ $string -eq \"\
    $max\" ]]; then\n            if (( max - min == 1 )); then\n                echo\
    \ \"$max\"\n                break\n            fi\n            (( max++ ))\n \
    \           (( min-- ))\n            difference=$(echo \"$max\" \"$min\" | bc)\n\
    \        fi\n        if [[ $string -eq \"$min\" ]]; then\n            if (( min\
    \ - max == 1 )); then\n                echo \"$min\"\n                break\n\
    \            fi\n            (( min++ ))\n            (( max-- ))\n          \
    \  difference=$(echo \"$max\" \"$min\" | bc)\n        fi\n        difference=$(echo\
    \ \"$difference\" | awk '{print $1}')\n        if (( $difference < 1 )); then\n\
    \            closest_integer=\"$max\"\n            break\n        fi\n       \
    \ if (( $difference > 1 )); then\n            closest_integer=\"$min\"\n     \
    \       break\n        fi\n    done\n    echo $closest_integer\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=40 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=31 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  [[ -z\
    \ \"$1\" ]] && echo \"No number given to closest_integer\" && return 1\n  \n \
    \ # Convert input to a number to make sure we're working with a number\n  [[ -z\
    \ \"$1\" ]] && return 1\n  local input_number=\"$(echo \"$1\" | sed -e 's/\\./\\\
    \\./g' -e 's/,/\\\\./g')\"\n  \n  # Make sure the number is at least two digits\
    \ long\n  [[ -z \"$input_number\" || (${#input_number} < 2 )&& \"$input_number\"\
    \ != \"-0\" && \"$input_number\" != \"-000\" && \"$input_number\" != \"-.\" ]]\n\
    \    && echo \"$1 is not a positive integer\" >&2\n    && return 1\n  \n  # Check\
    \ if the input is a valid number\n  [[ \"$input_number\" =~ ^-?[0-9]+$ ]]\n  \
    \  && echo \"$1 is not a valid number\" >&2\n    && return 1\n  \n  # If the input\
    \ number is equal to zero then return zero\n  if [[ \"$input_number\" == \"0\"\
    \ ]]; then\n    echo 0\n    return\n  fi\n  \n  # If the input number is equal\
    \ to one, return one\n  if [[ \"$input_number\" == \"1\" ]]; then\n    echo 1\n\
    \    return\n  fi\n  \n  # Create a variable with the input number as a string\n\
    \  local input_number_as_string=\"$input_number\"\n  \n  # Make sure the input\
    \ number is three or more characters long\n  if [[ \"$input_number_as_string\"\
    \ == \"0000\" ]] || [[ \"$input_number_as_string\" == \"-0\" ]] || [[ \"$input_number_as_string\"\
    \ == \"-000\" ]]; then\n    local input_number_as_string_without_leading=\"0${input_number_as_string}\"\
    \n    local input_number_as_string_without_trailing=\"${input_number_as_string_without_leading%.*}\"\
    \n    local input_number_as_string_without_trailing_leading_zero=\"${input_number_as_string_without_trailing}0\"\
    \n    \n    if [[ \"$input_number_as_string\" == \"$input_number_as_string_without_trailing_leading_zero\"\
    \ ]]; then\n      echo 0\n      return\n    fi\n  fi\n  \n  # Rearrange the integer\
    \ part to make comparisons easier\n  local input_number_as_string_rearranged=\"\
    0$input_number_as_string\"\n  \n  # Get all the integer parts of the input number\
    \ as strings\n  local input_number_as_string_rearranged_with_leading_zeros=$(echo\
    \ \"$input_number_as_string_rearranged\" | sed -e 's/^0*\\([0-9][0-9]*\\).*/\\\
    1/')\n  local input_number_as_string_rearranged_with_no_leading_zeros=\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp201dl5_q.sh: line 26: syntax error near unexpected token `&&''

    /tmp/tmp201dl5_q.sh: line 26: `    && echo "$1 is not a positive integer" >&2''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local integer_array=()\n    local max_value\n    local max_idx\n\
    \    local diff\n\n    if ! [[ \"$number\" =~ ^[0-9]+$ ]]; then\n        echo\
    \ \"$1 is not a valid number\" >&2\n        return 1\n    fi\n\n    # Convert\
    \ the string to a list of integers\n    integer_array=($number)\n\n    # If the\
    \ first number is an integer, return it\n    if [[ \"$integer_array\" =~ ^[0-9]+$\
    \ ]]; then\n        echo \"$integer_array\"\n        return 0\n    fi\n\n    #\
    \ Sort our list of numbers in reverse order\n    integer_array=(\"${integer_array[@]}\"\
    \ )\n    integer_array=(\"${integer_array[@]}\" )\n    integer_array=(\"${integer_array[@]}\"\
    \ )\n    integer_array=(\"${integer_array[@]}\" )\n    integer_array=(\"${integer_array[@]}\"\
    \ )\n    integer_array=(\"${integer_array[@]}\" )\n\n    # Find the maximum value\
    \ of the array\n    max_value=${integer_array[@]:0:1}\n    max_idx=0\n\n    for\
    \ (( i=0; i<${#integer_array[@]}; i++ )); do\n        if [ \"${integer_array[$i]}\"\
    \ -gt \"$max_value\" ]; then\n            max_value=${integer_array[$i]}\n   \
    \         max_idx=$i\n        fi\n    done\n\n    # If the number is equidistant\
    \ from two integers, round it\n    # away from zero.\n    if [[ ${integer_array[$max_idx]}\
    \ -eq ${integer_array[$max_idx-1]} ]]; then\n        max_idx=$(( max_idx + 1 ))\n\
    \    fi\n\n    # Convert the new list of integers back to a string\n    integer_array=()\n\
    \    for (( i=0; i <= $max_idx; i++ )); do\n        integer_array=( \"${integer_array[@]}\"\
    \ $(( ${integer_array[$i]}-1 )) )\n    done\n\n    integer_array=( \"${integer_array[@]}\"\
    \ )\n\n    # Return the string\n    echo \"${integer_array[0]}\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '14.5 is not a valid number

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=$1\n  local numbers=(\"$string\")\n  local round\n  local closest\n\n\
    \  round=$(echo \"${numbers[@]}\" | awk '{print $1}' | sed 's/-//g' | cut -d-\
    \ -f1)\n  for number in \"${numbers[@]}\"; do\n    local diff=$(( ${number} +\
    \ round ))\n    if [[ \"$diff\" -gt \"$closest\" ]]; then\n      closest=$diff\n\
    \    fi\n  done\n  echo $closest\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ VAL=$1\n    local NEIGHBORS=\"2 4 6 8 10 12\"\n    local NEIGHBOR=\"$NEIGHBORS\"\
    \n    local NEIGHBOR_INDEX=0\n    local NEIGHBOR_POS=1\n    while [ \"$NEIGHBOR\"\
    \ != \"$VAL\" ] ; do\n        local NEIGHBOR_POS=$((NEIGHBOR_POS+1))\n       \
    \ if [ \"$NEIGHBOR_POS\" -lt \"$#NEIGHBORS\" ] ; then\n            NEIGHBOR=\"\
    $NEIGHBORS\"\n        else\n            NEIGHBOR=\"$NEIGHBORS[$NEIGHBOR_POS]\"\
    \n        fi\n        NEIGHBOR_INDEX=$((NEIGHBOR_INDEX+1))\n        if [ \"$NEIGHBOR_INDEX\"\
    \ -eq \"$((NEIGHBORPOS-1))\" ] ; then\n            NEIGHBOR_POS=1\n        fi\n\
    \    done\n    echo \"$NEIGHBOR\"\n}\n\ncandidate() {\n    closest_integer \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[\
    \ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n\
    \    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n\
    }\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=42 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=15 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=\"$1\"\n  local diff=\"$2\"\n  local int=\"$3\"\n  if [[ $diff = \"+\" ||\
    \ $diff = \"-\" ]]; then\n    local shift=-1\n  elif [[ $diff = \"+\" ]]; then\n\
    \    shift=1\n    shift\n  else\n    shift\n  fi\n  # echo \"$val\"\n  # echo\
    \ \"$int\"\n  # echo \"$diff\"\n  val=$(($val + $shift))\n  (( diff > 0 )) &&\
    \ val=$(($val + $int)) || val=$(($val - $int))\n  # echo \"$val\"\n  val=\"$(($val\
    \ / 1))\"\n  # echo \"$val\"\n  echo \"$val\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpolqmm65i.sh: line 32: 10 + : syntax error: operand expected (error
    token is "+ ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ NUM=\"${1#-}\"\n    local ZERO=\"${NUM}\"\n    local DENOMINATOR\n    local\
    \ DENOMINATOR_REMAINDER\n    local NEWNUM\n\n    if [ \"${NUM}\" -eq \"${ZERO}\"\
    \ ]; then\n        return 0\n    fi\n\n    # Break up the number into its individual\
    \ digits\n    local NUMBER=\"${NUM}\"\n    local DIGITS=\"\"\n    while [ \"${NUMBER}\"\
    \ -ge 0 ]; do\n        DIGITS=\"${DIGITS}${NUMBER%?}\"\n        NUMBER=\"${NUMBER//?}\"\
    \n    done\n\n    # Remove any leading zeros\n    while [ \"${DIGITS}\" == \"\
    0\" ]; do\n        DIGITS=\"${DIGITS#-}\"\n    done\n\n    # Break up the number\
    \ into its individual digits\n    local DIGITS=\"${DIGITS}\"\n    local FIRST_DIGIT=\"\
    ${DIGITS}\"\n\n    if [ \"${DIGITS}\" -gt 0 ]; then\n        local FIRST_DIGIT=\"\
    ${DIGITS}\"\n        local SECOND_DIGIT=\"${DIGITS#-}\"\n        if [ \"${FIRST_DIGIT}\"\
    \ -gt \"${SECOND_DIGIT}\" ]; then\n            local SECOND_DIGIT=\"${SECOND_DIGIT}\"\
    \n            FIRST_DIGIT=\"${FIRST_DIGIT}\"\n        fi\n    else\n        SECOND_DIGIT=\"\
    0\"\n    fi\n\n    if [ \"${FIRST_DIGIT}\" -gt \"${SECOND_DIGIT}\" ]; then\n \
    \       FIRST_DIGIT=\"${FIRST_DIGIT}\"\n        SECOND_DIGIT=\"${SECOND_DIGIT}\"\
    \n    else\n        SECOND_DIGIT=\"${SECOND_DIGIT}0\"\n    fi\n\n    # Calculate\
    \ the difference between the first and second digits\n    local DIFF=\"${FIRST_DIGIT}-${SECOND_DIGIT}\"\
    \n    local DIFF_REMAINDER=\"${DIFF}\"\n    while [ \"${DIFF}\" -gt 0 ]; do\n\
    \        DIFF_REMAINDER=\"${DIFF_REMAINDER}${DIFF}\"\n        DIFF=\"${DIFF//?}\"\
    \n    done\n\n    # Now we have the difference between the two numbers and also\
    \ the remainder,\n    # so calculate the closest integer to that number\n    if\
    \ [ \"${DIFF}\" -eq \"0\" ]; then\n        NEWNUM=\"0\"\n    else\n        local\
    \ NEWNUM=\"${FIRST_DIGIT}${DIFF_REMAINDER}\"\n    fi\n\n    # Turn it into a positive\
    \ number if the original number was negative\n    if [ \"${ZERO}\" -lt \"${NEWNUM}\"\
    \ ]; then\n        NEWNUM=\"${NEWNUM}+\"\n    fi\n\n    return \"$NEWNUM\"\n}\n\
    \ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  awk 'BEGIN\
    \ {\n    # Convert all numbers to decimals\n    for(i=1; i<=NF; i++) $i=$i/10\n\
    \  }\n  { \n    # Sort them by absolute value\n    for (i=1; i<=NF; i++) {\n \
    \     if ($i == \"-\" || $i == \"+\") \n        next\n      else if ($i < $(i-1))\
    \ {\n        swap=$i\n        next\n      }\n      else if ($i == $(i-1)) \n \
    \       break\n    }\n    # Swap the first number in the array with the last number\n\
    \    $i = swap\n  }\n  END {\n    # Convert the array back to a string\n    for\
    \ (i=1; i<=NF; i++) $i = sprintf(\"%d\", $i)\n    printf \"%s\" \"$1\"\n  }'\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=46 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=20 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local integer\n    integer=$(( ( (number % 1) * ( 1 + number\
    \ % 1 ) ) / 2 ))\n    if [ \"$number\" -eq \"$integer\" ] ; then\n        # integer\
    \ equals $number, so return it\n        echo $integer\n    else\n        # integer\
    \ doesn't equal $number, but it's closer to zero,\n        # so return it\n  \
    \      echo $integer\n    fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  number=$1\n\
    \  echo \"$number\" | awk -F'.' '{print $1}' | sort | uniq -c | awk '{if ($1 >\
    \ 1) print $1}'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if ((\
    \ $1 == \"NaN\" )) ; then\n    echo \"NaN\"\n  else\n    if [[ \"$1\" == *\"-\"\
    * ]] ; then\n      echo \"$((${1//-/}%+1))\"\n    else\n      echo \"$((${1//./}%+1))\"\
    \n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo\
    \ $(echo $1 |sed -e 's/^-//g' -e 's/^\\+//' -e 's/\\([0-9]*\\)[^0-9]*\\([0-9]*\\\
    )/\\1\\2/')\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ num=\"${1}\"\n    if [[ $num =~ ^[0-9]+$ ]]; then\n        local digits=\"${num//[!0-9.]}\"\
    \n        local number=\"${digits:0:1}\"\n        local decimal=\"${digits:1}\"\
    \n        local nearest_integer=\"${number}.${decimal}\"\n        if [[ $nearest_integer\
    \ =~ ^-[0-9]+$ ]]; then\n            nearest_integer=\"${nearest_integer//-/0}\"\
    \n        fi\n        local nearest_integer=\"${nearest_integer//+/ }\"\n    \
    \    local nearest_integer=\"${nearest_integer//\\./}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//+/\
    \ }\"\n        local nearest_integer=\"${nearest_integer//\\./}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpd1polajf.sh: line 57: syntax error near unexpected token `}''

    /tmp/tmpd1polajf.sh: line 57: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local smallest\n  local largest\n  local number2\n  local number3\n\
    \  local smallest_diff\n  local largest_diff\n  smallest=`echo $number | awk '{\
    \ print $1 }'`\n  largest=`echo $number | awk '{ print $2 }'`\n  smallest_diff=`echo\
    \ $smallest - $number | awk '{ print $1 }'`\n  largest_diff=`echo $largest - $number\
    \ | awk '{ print $1 }'`\n  if [ $smallest_diff -ne 0 ]; then\n    number2=`echo\
    \ $number | awk -v smallest_diff=$smallest_diff \\\n        '{ print $1 }'`\n\
    \    number3=`echo $number | awk -v largest_diff=$largest_diff \\\n        '{\
    \ print $1 }'`\n    if [ $smallest_diff -eq 0 ]; then\n      return $number2\n\
    \    else\n      return $number3\n    fi\n  elif [ $largest_diff -ne 0 ]; then\n\
    \    number2=`echo $number | awk -v largest_diff=$largest_diff \\\n        '{\
    \ print $1 }'`\n    number3=`echo $number | awk -v smallest_diff=$smallest_diff\
    \ \\\n        '{ print $1 }'`\n    if [ $largest_diff -eq 0 ]; then\n      return\
    \ $number2\n    else\n      return $number3\n    fi\n  else\n    number2=`echo\
    \ $number | awk '{ print $1 }'`\n    number3=`echo $number | awk '{ print $2 }'`\n\
    \    if [ $number2 -eq $number ]; then\n      return $number3\n    elif [ $number3\
    \ -eq $number ]; then\n      return $number2\n    else\n      return 0\n    fi\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ val=\"$1\"\n    local min=\"$2\"\n    local max=\"$3\"\n    local diff\n   \
    \ local closest\n    local prev\n    local num\n    local str\n    local ret\n\
    \    # Convert the value to an integer.\n    num=\"$(echo \"$val\" | sed 's/[\\\
    .\\-\\+]//g')\"\n    if [ $num -ge $max ] && [ $num -le $min ]; then\n       \
    \ # Number is in range.\n        return $num\n    elif [ $num -gt $max ]; then\n\
    \        # Number is greater than the max value.\n        diff=$(( $max - $num))\n\
    \        prev=$(( $min - $diff ))\n        # Check if closest number is less than\
    \ the given value.\n        if [ \"$diff\" -gt 0 ] && [ \"$num\" -gt \"$prev\"\
    \ ] && [ \"$num\" -le \"$min\" ]; then\n            return $min\n        elif\
    \ [ \"$diff\" -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"$num\" -ge \"$max\"\
    \ ]; then\n            return $max\n        elif [ \"$num\" -eq \"$prev\" ]; then\n\
    \            # Check if difference is zero before returning.\n            if [\
    \ \"$diff\" = 0 ]; then\n                return $min\n            elif [ \"$diff\"\
    \ != 0 ]; then\n                # Return closest number.\n                return\
    \ $num\n            fi\n        fi\n    elif [ $num -le $min ]; then\n       \
    \ # Number is less than the min value.\n        diff=$(( $num - $min))\n     \
    \   prev=$(( $max - $diff ))\n        # Check if closest number is greater than\
    \ the given value.\n        if [ \"$diff\" -gt 0 ] && [ \"$num\" -gt \"$prev\"\
    \ ] && [ \"$num\" -le \"$max\" ]; then\n            return $max\n        elif\
    \ [ \"$diff\" -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"$num\" -ge \"$min\"\
    \ ]; then\n            return $min\n        elif [ \"$num\" -eq \"$prev\" ]; then\n\
    \            # Check if difference is zero before returning.\n            if [\
    \ \"$diff\" = 0 ]; then\n                return $max\n            elif [ \"$diff\"\
    \ != 0 ]; then\n                # Return closest number.\n                return\
    \ $num\n            fi\n        fi\n    elif [ \"$num\" -eq \"$min\" ]; then\n\
    \        # Number is equal to min.\n        diff=$(( $min - $num ))\n        prev=$((\
    \ $max - $diff ))\n        # Check if closest number is greater than the given\
    \ value.\n        if [ \"$diff\" -gt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"\
    $num\" -le \"$max\" ]; then\n            return $max\n        elif [ \"$diff\"\
    \ -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"$num\" \n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpj_nqchpi.sh: line 76: syntax error near unexpected token `}''

    /tmp/tmpj_nqchpi.sh: line 76: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # The\
    \ $1 is our value that we are looking for\n  # The $2 represents the largest number\n\
    \  # The $3 represents the smallest number\n\n  # First we convert the value to\
    \ float\n  FLOAT_VALUE=$(echo \"$1\" | sed 's/\\./\\\\./g')\n  FLOAT_VALUE=$(echo\
    \ \"$FLOAT_VALUE\" | sed 's/ //g')\n\n  # Now we try to get the closest integer\n\
    \  CLOSEST_INTEGER=$(echo \"$FLOAT_VALUE\" | bc)\n  CLOSEST_INTEGER=$(echo \"\
    $CLOSEST_INTEGER\" | sed 's/^0/-')\n\n  # Now we convert the string to an int\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^-/0')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp344bmy5k.sh: line 45: unexpected EOF while looking for matching
    `''''

    /tmp/tmp344bmy5k.sh: line 62: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ val=\"$1\"\n    local int_val=${val//[^0-9]}\n    local num_val=${int_val//\\\
    .}\n\n    # Return closest integer to the input number\n    if [ -z \"$num_val\"\
    \ ]; then\n        echo \"Invalid Input\"\n    elif [ \"$int_val\" -eq \"$val\"\
    \ ]; then\n        # Value is equidistant from two integers\n        int_val=\"\
    $num_val\"\n    fi\n\n    echo \"$int_val\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpi7p2pjbd.sh: line 25: [: 14.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ NUM=$1\n  local RESULT\n  if [[ $NUM =~ ^[0-9]+$ ]]; then\n    RESULT=$(echo\
    \ \"$NUM\" | sed -e 's/^\\([0-9][0-9]*\\)\\+[0-9]*$/\\1/')\n    if [[ $RESULT\
    \ =~ ^-?[0-9]+$ ]]; then\n      RESULT=$(echo \"$RESULT * -1\" | bc)\n    fi\n\
    \  else\n    RESULT=$(echo \"$NUM\" | bc)\n  fi\n  echo $RESULT\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ input=$1\n    # Convert input to an integer since bash doesn't have floats.\n\
    \    input=${input//[^0-9]/}\n    local max\n    local closest\n    local diff\n\
    \n    # If the input is empty, return \"0\".\n    [[ ! -z \"$input\" ]] || return\
    \ 0\n\n    # If the input contains a single digit, return the integer.\n    #\
    \ Otherwise return the \"max\" variable as input.\n    [[ ${input%%[^0-9]} ==\
    \ [0-9] || ${input%%[^0-9]} == [0-9][0-9] ]] || max=$input\n    closest=$max\n\
    \n    # Get the difference between the closest and the input number.\n    # The\
    \ diff variable is set to zero if it is the same as the input.\n    diff=$(echo\
    \ \"$input\" - \"$closest\" | bc -l)\n    [[ ! -z \"$diff\" ]] || diff=0\n\n \
    \   # If the difference is negative, subtract 1 from the closest variable\n  \
    \  # and add 1 to the input variable.\n    if [ \"$diff\" -lt 0 ]\n    then\n\
    \        closest=$(echo \"$closest\" - 1)\n        input=$(echo \"$input\" + 1)\n\
    \    fi\n\n    # If the difference is zero, return the same variable.\n    # Otherwise,\
    \ return the closest variable as the input.\n    [ \"$diff\" -eq 0 ] || return\
    \ $closest\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=$1\n  # Remove leading and trailing whitespace\n  val=`echo $val | tr -d\
    \ ' \\t'`\n  # Handle negative numbers\n  if [ \"$val\" == \"-$val\" ]; then\n\
    \    val=\"-0$val\"\n  fi\n  # Handle decimal numbers\n  if [ \"$val\" == \"$val\"\
    \ ] || [ \"$val\" == \"$val.0\" ]; then\n    val=\"$val.0\"\n  fi\n  # Convert\
    \ string to integer with base 10\n  val=\"${val#\"$prefix\"}\"\n  val=\"${val%\"\
    $postfix\"}\"\n  if [ $val -gt $max ]; then\n    val=$max\n  fi\n  if [ $val -lt\
    \ $min ]; then\n    val=$min\n  fi\n  echo -n \"$val\"\n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpie42pku1.sh: line 32: [: 10.0: unary operator expected

    /tmp/tmpie42pku1.sh: line 35: [: 10.0: unary operator expected

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ int_string=$1\n  local int_num=\"$(echo -e \"${int_string}\" | sed 's/^ *//g'\
    \ | tr -d '\"')\"\n  local int_num2=\"$(echo -e \"${int_num}\" | sed 's/^ *//g'\
    \ | tr -d '\"')\"\n  local int_dif=\"$(expr ${int_num} - ${int_num2})\"\n  local\
    \ int_result=\"$((${int_dif}/2))\"\n  echo \"${int_result}\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Convert\
    \ the argument to a floating point value\n  input=$1\n  value=$(echo \"$input\"\
    |tr -dc '0-9')\n  value=$(echo \"$value\"|bc)\n  base=${input%%.*}\n  if [[ \"\
    $input\" =~ ^-?[0-9]$ ]]; then\n    if [[ \"$input\" =~ -?[1-9][0-9]*$ ]]; then\n\
    \      input=$(echo \"$base+$input\"|bc)\n    fi\n  fi\n  input=$(echo \"$input\"\
    |bc)\n  if [ \"$input\" -gt \"$value\" ]; then\n    value=$input\n  fi\n  output=$((\
    \ value + 1 ))\n  echo $output\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x=\"$1\"\n  local prev=\"$1\"\n  local next=\"$1\"\n\n  if [[ \"$x\" == \"0\"\
    \ ]]; then\n    echo \"0\"\n  elif [[ -z \"$prev\" ]]; then\n    echo \"$x\"\n\
    \  else\n    while true; do\n      prev=\"$prev\"\n      if [[ $prev -gt \"$next\"\
    \ ]]; then\n        next=\"$x\"\n        break\n      fi\n      if [[ \"$prev\"\
    \ -eq \"$x\" ]]; then\n        echo \"$x\"\n        break\n      fi\n    done\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=51 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=28 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=$1\n    local diff\n    local closest_diff\n    local closest_integer\n\
    \    local diff\n    local integer\n    local num\n    integer=$(($(( $(( 10#$string\
    \ + 1 ) - 10#$string ) / 10 )) ))\n    if [[ $integer -eq 0 ]]; then\n       \
    \ return 0\n    fi\n    num=$(( $string % 10 ))\n    diff=$(($(( 10#$string -\
    \ $(( 10#$num )) - 1 )) ))\n    closest_diff=$(($(( 10#$closest_integer - $closest_integer\
    \ / 10 )) ))\n    closest_integer=$(( $closest_integer + 1 ))\n    while [ $closest_diff\
    \ -le 0 ]; do\n        (($diff < 0)) && return $(( 10#$closest_integer ))\n  \
    \      (($diff == 0)) && return $(( 10#$closest_integer ))\n        (($diff >\
    \ 0)) && return $(( 10#$closest_integer + 1 ))\n        (($diff == 1)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff > 1)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff == 2)) && return $(( 10#$closest_integer + 1 ))\n  \
    \      (($diff > 2)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ == 3)) && return $(( 10#$closest_integer + 1 ))\n        (($diff > 3)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff == 4)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff > 4)) && return $(( 10#$closest_integer + 1 ))\n   \
    \     (($diff == 5)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ > 5)) && return $(( 10#$closest_integer + 1 ))\n        (($diff == 6)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff > 6)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff == 7)) && return $(( 10#$closest_integer + 1 ))\n  \
    \      (($diff > 7)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ == 8)) && return $(( 10#$closest_integer + 1 ))\n        (($diff > 8)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff == 9)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpqjbefrpt.sh: line 55: syntax error near unexpected token `}''

    /tmp/tmpqjbefrpt.sh: line 55: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=\"$1\"\n    if [[ \"${string}\" =~ ^[0-9]+$ ]]; then\n        local integer=\"\
    ${string}\"\n    else\n        echo \"Input is not a number: '$string'\"\n   \
    \     return 1\n    fi\n    local result\n    local num1=\"${integer}\"\n    local\
    \ num2=\"$(( ($(expr \"$integer\" - \"${integer}\") * (-1)) | bc -l))\"\n    result=\"\
    $(( ($(expr \"$integer\" - \"${integer}\") * (-1)) | bc -l))\"\n    if [[ \"${integer}\"\
    \ == *\".\"* ]]; then\n        integer=\"${integer%%.*}\"\n        num1=\"${integer}\"\
    \n    fi\n    if [[ \"${num1}\" < \"${num2}\" ]]; then\n        result=\"$num1\"\
    \n    elif [[ \"${num1}\" > \"${num2}\" ]]; then\n        result=\"$num2\"\n \
    \   fi\n    echo \"$result\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=${1}\n    local number=${string}\n    # if the number is already an integer,\
    \ just return it\n    [[ \"$string\" =~ ^[0-9]+$ ]] && echo \"$string\" || return\
    \ 1\n    # make sure it's a positive number\n    [[ \"$string\" =~ ^[+-]([0-9]+)?$\
    \ ]] || return 1\n    # if the number is positive, check if it's closer to zero\
    \ than to either of the\n    # numbers involved, if it is, the one closer to zero\
    \ should return\n    if [[ ${number} -lt 0 ]]; then\n        # first check whether\
    \ it's closer to zero\n        local number1=${number}\n        local number2=${number}\n\
    \        if [[ ${number} -lt $number1 ]]; then\n            number1=$number\n\
    \        else\n            number2=$number\n        fi\n        if [[ ${number1}\
    \ -lt 0 && ${number2} -lt 0 ]]; then\n            number=${number1}\n        elif\
    \ [[ ${number1} -lt 0 && ${number2} -gt 0 ]]; then\n            number=${number2}\n\
    \        fi\n    fi\n    echo \"$number\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  declare\
    \ -i n=\"$1\" count=0\n  # Make sure the number is numeric\n  [ \"$n\" = \"${n%%.*}\"\
    \ ] || return 1\n  n=${n%.*}\n  if [ $n -eq 0 ]; then\n    return $n\n  fi\n \
    \ local base=0\n  # Loop through all possible bases until we find a one that doesn't\
    \ have an\n  # exact match\n  for base in {10..16}; do\n    if [ \"${#n}\" -eq\
    \ \"${#base}\" ]; then\n      continue\n    fi\n    # Make sure the base has at\
    \ least two characters\n    if [ \"${#base}\" -le 2 ]; then\n      return 1\n\
    \    fi\n    local i\n    # Loop through the string until we find the first character\
    \ that doesn't\n    # match the base\n    for (( i=0; i<${#base}; i++ )); do\n\
    \      if [ \"${n:$i:1}\" != \"${base:i:1}\" ]; then\n        count=$(expr ${n}\
    \ - $i)\n        break\n      fi\n    done\n    if [ $count -eq 0 ]; then\n  \
    \    break\n    fi\n  done\n  local closest\n  # Loop through all possible bases\
    \ until we find one that has exact\n  # match\n  for base in {10..16}; do\n  \
    \  if [ \"${#n}\" -eq \"${#base}\" ]; then\n      continue\n    fi\n    # Make\
    \ sure the base has at least two characters\n    if [ \"${#base}\" -le 2 ]; then\n\
    \      return 1\n    fi\n    local i\n    # Loop through the string until we find\
    \ the first character that does\n    # match the base\n    for (( i=0; i<${#base};\
    \ i++ )); do\n      if [ \"${n:$i:1}\" = \"${base:i:1}\" ]; then\n        closest=$(expr\
    \ ${n} - $i)\n        break\n      fi\n    done\n    if [ $closest -eq 0 ]; then\n\
    \      break\n    fi\n  done\n  # The closest integer is the greatest integer\
    \ between the base and the number\n  # that hasn't been parsed\n  local closest\n\
    \  for base in {10..16}; do\n    if [ \"${#n}\" -eq \"${#base}\" ]; then\n   \
    \   continue\n    fi\n    local i\n    local j\n    local closest\n    for ((\
    \ i=0; i<${#base}; i++ )); do\n      if [ \"${n:$i:1}\" = \"${base:i:1}\" ]; then\n\
    \        closest=$(expr ${n} - $i)\n        break\n      fi\n    done\n    for\
    \ (( j=0; j<${#n}; j++ )); do\n\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpt29gs_a2.sh: line 91: syntax error near unexpected token `}''

    /tmp/tmpt29gs_a2.sh: line 91: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=\"$1\"\n\n    local -a integers\n    integers=( $string )\n\n    local\
    \ integer\n    integer=${integers[$(( ${#integers[@]} - 1 ))]}\n    integer=\"\
    ${integer%.*}\"\n\n    if [[ ${integer} -eq $string ]]; then\n      integer=$((\
    \ ${integer} + 1 ))\n    else\n      integer=$(( ${integer} ))\n    fi\n\n   \
    \ echo \"$integer\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local integers=$($(printf \"%s $2 $3 $4\" $number $2 $3 $4)|grep\
    \ -Eo \"[0-9]+\")\n    local minmax=$($(printf \"%s $2 $3 $4\" $number $2 $3 $4)|grep\
    \ -Eo \"[0-9.]+\")\n    local min=$(($(echo \"$minmax ${integers[*]}\"|awk '{print\
    \ $1*($2-$3)+$4}')))\n    local max=$(($(echo \"$minmax ${integers[*]}\"|awk '{print\
    \ $1*($2-$3)-$4}')))\n    echo \"$((${number%%.*}-$min+$max))\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpskq5y70a.sh: line 19: 10: command not found

    /tmp/tmpskq5y70a.sh: line 20: 10: command not found

    /tmp/tmpskq5y70a.sh: line 19: 14.5: command not found

    /tmp/tmpskq5y70a.sh: line 20: 14.5: command not found

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=${1}\n  local integer closest\n  local number diff\n  local negative\
    \ negative_index\n  local positive_index\n\n  negative_index=0\n  positive_index=0\n\
    \  negative=false\n  positive=false\n  diff=0\n  # Loop through the string, incrementing\
    \ negative_index if needed\n  for number in \"${string//,/ }\"; do\n    (( negative_index++\
    \ ))\n    if [[ \"${number}\" = -* ]]; then\n      negative=true\n    fi\n   \
    \ (( positive_index++ ))\n    if [[ \"${number}\" = -* ]]; then\n      negative=true\n\
    \    fi\n    (( diff += ${number} ))\n  done\n\n  # Return closest integer based\
    \ on positive_index and negative_index\n  # If the difference between the two\
    \ is negative, return -negative_index\n  # If the difference between the two is\
    \ positive, return positive_index\n  # Otherwise return diff itself\n  if [[ \"\
    ${diff}\" = -* ]]; then\n    if [[ \"${negative}\" == true ]]; then\n      ((\
    \ negative_index -= 1 ))\n    else\n      (( positive_index -= 1 ))\n    fi\n\
    \  fi\n  if [[ \"${diff}\" = * ]]; then\n    if [[ \"${negative}\" == true ]];\
    \ then\n      (( negative_index -= 1 ))\n    else\n      (( positive_index -=\
    \ 1 ))\n    fi\n  fi\n  closest=${string%${string//,/ }}\n  closest=${closest//-/}\n\
    \  closest=${closest//+/}\n  if [[ \"${diff}\" > 0 ]]; then\n    closest=\"${closest}+\"\
    \n  fi\n  if [[ \"${diff}\" < 0 ]]; then\n    closest=\"${closest}-\"\n  fi\n\
    \  return \"${closest}\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpdnadvqkh.sh: line 69: return: +: numeric argument required

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  declare\
    \ number=$1\n  declare integer\n\n  integer=$(echo \"$number\" | sed 's/\\./\\\
    +/')\n  integer=$(echo \"$number\" | sed 's/-/-+/')\n  integer=$(echo \"$number\"\
    \ | sed 's/+/-+/')\n  integer=$(echo \"$number\" | sed 's/^[+-]/0\\+/')\n  integer=$(echo\
    \ \"$number\" | sed 's/[+-]$//')\n  integer=$(echo \"$number\" | sed 's/^\\+\\\
    +/0\\+/')\n  integer=$(echo \"$number\" | sed 's/\\+$//')\n\n  echo \"$integer\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ input=$1\n    if [[ \"$input\" =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        local\
    \ digits=${#input}\n        if [ \"$digits\" -gt 3 ]; then\n            local\
    \ sign=$(( 10#$digits - 2 ))\n            local decimal=${input%%.*}\n       \
    \     local integer=$(printf \"%0*d\" \"$sign\" \"$decimal\")\n            local\
    \ nearest_integer=$(( 10#$integer + $sign ))\n            # Make sure that the\
    \ integer is really an integer (and not a\n            # fraction)\n         \
    \   if (( \"$nearest_integer\" < $integer )); then\n                nearest_integer=$((\
    \ $nearest_integer + 1 ))\n            fi\n            echo $nearest_integer\n\
    \        else\n            echo $input\n        fi\n    else\n        echo 1\n\
    \    fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ i\n    local diff\n    local farthest_integer\n    local diff_index\n    local\
    \ integer_part\n    local decimals\n    local decimals_index\n    local decimals_part\n\
    \    local decimals_part_index\n\n    integer_part=\"${1}\"\n    decimals=\"${integer_part:(-$((${#integer_part}-1))):1}\"\
    \n    decimals_part=\"${decimals:1}\"\n\n    # Calculate difference between original\
    \ and integer part\n    diff=\"$(( ${#integer_part} - ${#decimals_part} ))\"\n\
    \    if [ -n \"${diff}\" ]; then\n        echo \"${integer_part}.0\"\n       \
    \ return\n    fi\n\n    diff_index=\"$(echo \"${integer_part}\" | tr -cd '0123456789')\"\
    \n    decimals_part_index=\"$(echo \"${decimals_part}\" | tr -cd '0123456789')\"\
    \n\n    # If the difference is equidistant, round away from zero.\n    if [ \"\
    ${diff_index}\" -eq \"${decimals_part_index}\" ]; then\n        (( diff -- = 0\
    \ ))\n    fi\n    if [ \"${diff_index}\" -lt \"${decimals_part_index}\" ]; then\n\
    \        farthest_integer=\"${integer_part}\"\n    else\n        farthest_integer=\"\
    ${decimals_part}\"\n    fi\n    echo \"${farthest_integer}\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value=\"$1\"\n  if ! test -d .; then\n    echo 0\n  else\n    local digits=$(echo\
    \ \"${value}\" | sed 's/[^0-9]*//g')\n    local first=\"${digits}\"\n    local\
    \ second=\"${digits}.0\"\n    local sign=\"${digits}\"\n    local firstLength=${#first}\n\
    \    local secondLength=${#second}\n    local signLength=${#sign}\n    local distance=${firstLength}\n\
    \n    if [ \"$firstLength\" -gt \"$secondLength\" ]; then\n      first=\"${first%.*}\"\
    \n      second=\"${second%.*}\"\n      sign=\"${sign%.*}\"\n      firstLength=${#first}\n\
    \      secondLength=${#second}\n      signLength=${#sign}\n      distance=${firstLength}\n\
    \    fi\n\n    if [ \"$secondLength\" -gt \"$firstLength\" ]; then\n      first=\"\
    ${first%.*}\"\n      second=\"${second%.*}\"\n      sign=\"${sign%.*}\"\n    \
    \  firstLength=${#first}\n      secondLength=${#second}\n      signLength=${#sign}\n\
    \      distance=${secondLength}\n    fi\n\n    if [ \"$firstLength\" -gt \"$signLength\"\
    \ ]; then\n      first=\"${first%.*}\"\n      sign=\"${sign%.*}\"\n      firstLength=${#first}\n\
    \      signLength=${#sign}\n      distance=${firstLength}\n    fi\n\n    if [\
    \ \"$signLength\" -gt \"$firstLength\" ]; then\n      first=\"${first%.*}\"\n\
    \      sign=\"${sign%.*}\"\n      firstLength=${#first}\n      signLength=${#sign}\n\
    \      distance=${signLength}\n    fi\n\n    local closest\n    if [ \"$distance\"\
    \ -gt \"$2\" ]; then\n      closest=\"$first$((signLength-distance))$sign\"\n\
    \    elif [ \"$distance\" -lt \"$2\" ]; then\n      closest=\"$second$((distance-signLength))$sign\"\
    \n    else\n      closest=\"$value\"\n    fi\n    echo ${closest}\n  fi\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpi4xn39eu.sh: line 68: [: : integer expression expected

    /tmp/tmpi4xn39eu.sh: line 70: [: : integer expression expected

    /tmp/tmpi4xn39eu.sh: line 68: [: : integer expression expected

    /tmp/tmpi4xn39eu.sh: line 70: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local min\n  local max\n  local distance\n  local closest\n\n \
    \ min=${number%%.*}\n  max=${number#*.}\n\n  if (( min < 0 )) ; then\n    # If\
    \ the number begins with a minus, remove it\n    min=${number#*-}\n    max=${number%%-*}\n\
    \  fi\n\n  if (( max > 0 )) ; then\n    # If the number begins with a plus, remove\
    \ it\n    max=${number#+*}\n    min=${number%%+*}\n  fi\n\n  if (( ${#min} > ${#max}\
    \ )) ; then\n    # If the two numbers have different lengths, fail\n    distance=${#min}\n\
    \  else\n    distance=${#max}\n  fi\n\n  if (( distance > 1 )) ; then\n    # If\
    \ the two numbers are equidistant, round away from zero\n    closest=$(( ${number}+${min}/10\
    \ ))\n  else\n    # If the two numbers are equidistant, round towards the integer\n\
    \    closest=$(( ${number}+${min} ))\n  fi\n\n  echo \"$closest\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ integer=$1\n  local diff\n  diff =$(echo \"$integer\" | bc)\n  local diffInt\n\
    \  diffInt=$(( diff*10 ))\n  local diffDbl\n  diffDbl=$(( diff*10 ))\n  if [ \"\
    $diffInt\" -ge \"10\" ]; then\n      diffInt=$(( diffInt-1 ))\n      diffDbl=$((\
    \ diffDbl+1 ))\n  fi\n  if [ \"$diffDbl\" -ge \"10\" ]; then\n      diffDbl=$((\
    \ diffDbl-1 ))\n      diffInt=$(( diffInt+1 ))\n  fi\n  if [ \"$diffInt\" -ge\
    \ \"1\" ]; then\n      diffInt=0\n      diffDbl=0\n  fi\n  if [ \"$diffDbl\" -ge\
    \ \"1\" ]; then\n      diffDbl=0\n      diffInt=0\n  fi\n  echo $(( diffInt+diffDbl\
    \ ))\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'diff: missing operand after ''=10''

    diff: Try ''diff --help'' for more information.

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x $2\n  x=\"$1\"\n  y=\"$x\"\n  echo \"$(( ( ( ( ( ( $x | cut -c -3 ) - $y |\
    \ cut -c -2 ) ) \\\n            - $y | cut -c -1 ) - $y | cut -c -1 ) + 1 ))\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ input=\"$1\"\n    if [[ \"${input}\" = \"--help\" ]]; then\n        echo \"\
    This script returns the closest integer to an integer input. \\\nIf the number\
    \ input is a float, a decimal point is added before rounding.\"\n        exit\
    \ 0\n    fi\n\n    if [[ \"$input\" =~ ^[0-9]+(\\.[0-9]+)?$ ]]; then\n       \
    \ local input_int=\"${BASH_REMATCH[0]}\"\n        local input_decimal=\"${BASH_REMATCH[1]}\"\
    \n        if [[ $(( ${#input_decimal} )) -gt 0 ]]; then\n            local input_int_dec=\"\
    ${input_int}.${input_decimal}\"\n            local input_int_dec2=\"${input_int_dec}\"\
    \n        else\n            local input_int_dec=\"${input_int}\"\n           \
    \ local input_int_dec2=\"${input_int_dec}\"\n        fi\n        # Check if input\
    \ integer is equidistant from two integers\n        if [[ ${#input_int_dec} -gt\
    \ ${#input_int_dec2} ]]; then\n            if [[ $(( ${#input_decimal} )) -gt\
    \ 0 ]]; then\n                local input_int_dec2_dec=\"${input_int_dec2}.${input_decimal}\"\
    \n                local input_int_dec2_dec2=\"${input_int_dec2_dec}\"\n      \
    \      else\n                local input_int_dec2_dec=\"${input_int_dec2}\"\n\
    \                local input_int_dec2_dec2=\"${input_int_dec2_dec}\"\n       \
    \     fi\n            local output_int=${#input_int_dec2}\n            local output_decimal=\"\
    ${input_int_dec2_dec2}${output_int}\"\n        else\n            local output_int=${#input_int_dec}\n\
    \            local output_decimal=\"${input_int_dec}${output_int}\"\n        fi\n\
    \        echo \"$output_decimal\"\n    else\n        echo \"Error: Input must\
    \ be a number\"\n    fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value\n  local base\n  local distance\n  local closest\n  local quotient\n \
    \ local remainder\n  local rounded\n  local result\n  local digit\n  local quotientString\n\
    \  local remainderString\n\n  value=$1\n  base=$(echo \"${value}\" | sed -e \"\
    s/[^0-9.]//g\")\n  if [ -z \"${base}\" ]; then base=1; fi\n  distance=$(echo \"\
    ${value}\" | sed -e \"s/^.\\([0-9]*\\)$/\\1/\")\n  if [ -z \"${distance}\" ];\
    \ then distance=0; fi\n  closest=$(echo \"${distance}\" | bc)\n  if [ \"${closest}\"\
    \ -lt 1 ]; then closest=1; fi\n\n  quotient=$(echo \"${closest} / ${base}\" |\
    \ bc)\n  quotientString=$(echo \"${quotient}\" | sed -e \"s/^.\\([0-9]*\\)$/\\\
    1/\")\n  remainder=$(echo \"${quotient} - ${quotientString}\" | bc)\n  remainderString=$(echo\
    \ \"${remainder}\" | sed -e \"s/^.\\([0-9]*\\)$/\\1/\")\n  if [ \"${quotient}\"\
    \ -gt \"${quotientString}\" ]; then rounded=\"1\"; else\n    rounded=\"0\"\n \
    \ fi\n  if [ \"${remainder}\" -gt \"${remainderString}\" ]; then rounded=\"1\"\
    ; else\n    rounded=\"0\"\n  fi\n  if [ \"${rounded}\" -eq \"0\" ]; then rounded=\"\
    1\"; fi\n\n  if [ \"${rounded}\" -eq \"1\" ]; then\n    result=$(echo \"${value}\"\
    \ | sed -e \"s/^.\\([0-9]*\\)$/\\1/\")\n  else\n    result=\"${value}\"\n  fi\n\
    \  echo ${result}\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    /tmp/tmpflplr9nq.sh: line 42: [: : integer expression expected

    /tmp/tmpflplr9nq.sh: line 45: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ STRING=$1\n  # Remove all non-digit characters\n  STRING=${STRING/[!0-9]/}\n\
    \  # If no digits exist in the string, return it.\n  if [ ${#STRING} -eq 0 ];\
    \ then\n    return 0\n  fi\n  # If there is more than one digit, then sort them\
    \ and take the first\n  # one.\n  if [[ ${#STRING} -eq 1 ]]; then\n    local NUMBER=$1\n\
    \    if [[ $NUMBER =~ ^[+-]?[0-9]+$ ]]; then\n      # Number starts with at least\
    \ one digit\n      local DIGIT=$(echo $NUMBER | sed -e 's/^\\([0-9]\\+\\).*$/\\\
    1/')\n      # Test if digit exists in the string\n      local INDEX=${STRING:${#DIGIT}}\n\
    \      local DIGIT=${STRING:${INDEX:1}}\n      if [[ ${#DIGIT} -gt 0 ]]; then\n\
    \        echo $DIGIT\n      else\n        echo 0\n      fi\n    else\n      echo\
    \ 0\n    fi\n  else\n    if [ $STRING -le 0 ] || [ $STRING -ge 9 ]; then\n   \
    \   echo $STRING\n    else\n      echo 0\n    fi\n  fi\n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Get\
    \ the value\n  val=$1\n\n  # Convert it to an integer if needed\n  val=${val//[^0-9]}\n\
    \  val=${val//.}\n  val=${val//+}\n\n  # If it looks like a number, use it\n \
    \ [[ \"${val}\" =~ ^[0-9]+$ ]] || return $val\n\n  # If the value is negative,\
    \ subtract it\n  [[ $val -gt 0 ]] && val=$((val - 1))\n\n  # Scan from greatest\
    \ to least and return the closest\n  # integer to that value\n  val=$((val+1))\n\
    \  while (( val > 0 )); do\n    (( val = val / 10 ))\n  done\n  while (( val <\
    \ 0 )); do\n    (( val = val * 10 ))\n  done\n  echo \"$val\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local closest=`expr ${number} \\* 10`\n    local remainder\n\
    \    local delta\n\n    while true; do\n        remainder=`expr $number % $closest`\n\
    \        delta=`expr $remainder \\- $closest`\n        if [ $delta -le 0 ]; then\n\
    \            closest=$remainder\n            break\n        elif [ $delta -ge\
    \ 0 ]; then\n            closest=$remainder\n        fi\n        number=$(( $number\
    \ / 10 ))\n    done\n\n    return $closest\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ VALUE=$1\n  local TOLERANCE\n  local TOLERANCE_INT\n  local NORM_NUM\n  local\
    \ CLOSEST\n  TOLERANCE=$(echo \"0.$(( 10#$TOLERANCE ))\" | bc)\n  TOLERANCE_INT=$(echo\
    \ \"$TOLERANCE * $(( 10#1 ))\" | bc)\n  NORM_NUM=$(echo \"$VALUE * $(( 10#1 ))\"\
    \ | bc)\n  CLOSEST=$(( $(echo \"($NORM_NUM + $TOLERANCE_INT + $TOLERANCE_INT)\"\
    \ | bc) ))\n  (( $(echo \"$VALUE * $(( 10#1 )) < $CLOSEST\" | bc) )) && echo $CLOSEST\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local number_string=$(echo \"${number}\" | tr -dc '0-9')\n  local\
    \ first_number_string=$(echo \"${number_string}\" | head -n 1)\n  local second_number_string=$(echo\
    \ \"${number_string}\" | tail -n 1)\n\n  if [[ ${first_number_string} -ne ${second_number_string}\
    \ ]]; then\n    local diff=$(( (\"${number}\" - \"${first_number_string}\") \\\
    \n              / (\"${second_number_string}\" - \"${first_number_string}\") +\
    \ 1 ))\n    local closest=$(( \"${diff}\" > 0 ? \"${first_number_string}\" : \"\
    ${second_number_string}\" ))\n    echo \"${closest}\"\n  else\n    echo ${number}\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Check\
    \ if the first argument is a number\n  [[ -z $1 ]] && echo \"$0: missing argument\"\
    \ && exit 1\n  [[ ! -z \"$1\" ]] && local number=$1\n\n  # Check if first argument\
    \ is a float or not\n  [[ \"$number\" =~ ^[0-9]+\\.[0-9]+$ ]] || echo \"$0: argument\
    \ is not a number: $number\" && exit 1\n\n  # Check if the given number is a float\n\
    \  if [[ $number =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    local int_part=$(echo \"$number\"\
    \ | awk '{print $1}')\n    local dec_part=$(echo \"$number\" | awk '{print $2}')\n\
    \n    # If first digit is non-zero, the number is negative\n    if [[ \"$int_part\"\
    \ -ne \"0\" ]]; then\n      int_part=-$int_part\n      dec_part=-$dec_part\n \
    \   fi\n\n    local closest\n    closest=$(echo \"$int_part*$dec_part\" | bc)\n\
    \    # Round it away from zero\n    closest=$(bc <<< \"scale=0;$closest;$dec_part\"\
    )\n    echo \"$closest\"\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=$1\n  val=\"$(printf '%s\\n' \"$val\" | tr -d '[\\.,]' | tr '[:upper:]'\
    \ '[:lower:]')\"\n  local min=$((10#$val))\n  local max=$((10#$val))\n  local\
    \ step=$((10#$max))\n  local round=0\n  while [[ $min -le $val ]]; do\n    ((min+=$step))\n\
    \    round=$((min%10))\n  done\n  local rounds=0\n  while [[ $min -le $max ]];\
    \ do\n    ((min+=$step))\n    round=$((min%10))\n    ((rounds++))\n  done\n  ((min--))\n\
    \  if (( rounds == 0 )); then\n    min=$min\n  else\n    ((min++))\n  fi\n  ((max--))\n\
    \  if (( rounds == 0 )); then\n    max=$max\n  else\n    ((max--))\n  fi\n  echo\
    \ $(( min + $round ))\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x y\n\n  x=$1\n  y=$(echo $x | cut -d \".\" -f 1)\n  (( x==y )) && echo \"$x\"\
    \n  (( y<x )) && echo $x\n  (( x<y )) && echo $y\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpnquif_5k.sh: line 22: ((: 14.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    /tmp/tmpnquif_5k.sh: line 23: ((: 14.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    /tmp/tmpnquif_5k.sh: line 24: ((: 14.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ -n NUMBER=$1\n  local -n MAX=`echo $NUMBER | cut -d. -f1`\n  local -n MIN=`echo\
    \ $NUMBER | cut -d. -f2`\n  local -n MOD=`echo $MAX - $MIN`\n  local -n RES=`echo\
    \ $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n TEMP=`echo $RES % $MOD`\n\
    \  local -n DIFF=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n\
    \ MOD=`echo $TEMP % $MOD`\n  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo\
    \ $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n\
    \  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local\
    \ -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo\
    \ $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER\
    \ | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo $TEMP % $MOD`\n \
    \ local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN\
    \ {print $1*$2-$3}'`\n  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo\
    \ $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n\
    \  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local\
    \ -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo\
    \ $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER\
    \ | awk -F. 'BEGIN {\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpldhgabk1.sh: line 46: unexpected EOF while looking for matching
    ``''

    /tmp/tmpldhgabk1.sh: line 63: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x\n  x=\"${1}\"\n  local closest\n  local closestdiff\n  local mindiff\n  local\
    \ mindiffdiff\n  local int\n  local num\n  local numdiff\n  num=\"${x}\"\n  numdiff=\"\
    0\"\n  numdiffdiff=\"0\"\n  while [ \"${num}\" != \"0\" ]; do\n    int=\"${num}\"\
    \n    int=\"${int%.*}\"\n    if [ \"${int}\" = \"0\" ]; then break; fi\n    closest=\"\
    ${int}\"\n    closestdiff=\"0\"\n    mindiff=\"${closest}\"\n    mindiffdiff=\"\
    0\"\n    while [ \"${closest}\" != \"0\" ]; do\n      num=\"${num}.${closest}\"\
    \n      numdiff=\"${numdiff}.${closestdiff}\"\n      numdiffdiff=\"${numdiffdiff}.${mindiffdiff}\"\
    \n      closest=\"${closest%%.*}\"\n      closestdiff=\"${closestdiff%%.*}\"\n\
    \      mindiff=\"${mindiff}.${closest}\"\n      mindiffdiff=\"${mindiffdiff}.${closestdiff}\"\
    \n    done\n    local result\n    if [ \"${mindiff}\" -lt \"${x}\" ]; then break;\
    \ fi\n    num=${mindiff}\n    numdiff=${mindiffdiff}\n  done\n  echo \"${x}\"\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=25 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=10 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local closest\n    # Round number away from zero\n    number=${number%.*}\n\
    \    closest=$(( ${number} - ${number%%.*} ))\n    # Handle special cases\n  \
    \  if [[ \"$number\" == \"0\" ]]; then\n        closest=0\n    elif [[ \"$number\"\
    \ == \"-0\" ]]; then\n        closest=-0\n    elif [[ \"$number\" == \"-0\" ]];\
    \ then\n        closest=--0\n    fi\n    echo $closest\n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=\"$1\"\n  local integer=\"$2\"\n  local direction=\"$3\"\n  if [ \"$direction\"\
    \ == \"up\" ]; then\n    # If the value is greater than the integer then return\
    \ integer.\n    if [ \"$number\" -gt \"$integer\" ]; then\n      echo \"$integer\"\
    \n    fi\n  fi\n  if [ \"$direction\" == \"down\" ]; then\n    # If the value\
    \ is less than the integer then return integer.\n    if [ \"$number\" -lt \"$integer\"\
    \ ]; then\n      echo \"$integer\"\n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=\"$1\"\n  shift\n  local min=\"$1\"\n  shift\n  local max=\"$1\"\n  shift\n\
    \  local diff\n\n  # make sure given numbers are all integers\n  if [[ $num =~\
    \ ^[0-9]+$ ]]; then\n    local diff\n    local min\n    local max\n    diff=$(echo\
    \ \"$num - $min\" | bc -l)\n    if [[ $diff -gt 0 ]]; then\n      min=$(( min\
    \ + 1 ))\n      diff=$(echo \"$num - $min\" | bc -l)\n    fi\n    if [[ $diff\
    \ -lt 0 ]]; then\n      max=$(( max + 1 ))\n      diff=$(echo \"$max - $num\"\
    \ | bc -l)\n    fi\n    if [[ $diff -eq 0 ]]; then\n      echo \"$min\"\n    else\n\
    \      echo \"$max\"\n    fi\n  else\n    echo \"$num\"\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ num=$1\n    local prev=$((num-1))\n    local next=$((num+1))\n    if [ \"$prev\"\
    \ == \"$num\" -o \"$next\" == \"$num\" ]; then\n        echo \"$num\"\n      \
    \  return 0\n    fi\n    if [ \"$prev\" == \"$next\" ]; then\n        echo \"\
    $num\"\n        return 0\n    fi\n\n    if [ \"$prev\" == \"0\" -o \"$num\" ==\
    \ \"0\" ]; then\n        echo \"0\"\n        return 0\n    fi\n\n    local temp=$((num+1))\n\
    \    local temp2=$((num-1))\n    local temp3=$((num-1))\n    local temp4=$((num+1))\n\
    \    local temp5=$((num+1))\n    local temp6=$((num+1))\n    local temp7=$((num+1))\n\
    \    local temp8=$((num+1))\n    local temp9=$((num+1))\n    local temp10=$((num+1))\n\
    \    local temp11=$((num+1))\n    local temp12=$((num+1))\n    local temp13=$((num+1))\n\
    \    local temp14=$((num+1))\n    local temp15=$((num+1))\n\n    while true; do\n\
    \        if [ \"$prev\" == \"$temp\" ]; then\n            echo \"$temp\"\n   \
    \         return 0\n        fi\n\n        if [ \"$next\" == \"$temp\" ]; then\n\
    \            echo \"$temp\"\n            return 0\n        fi\n\n        if [\
    \ \"$prev\" == \"$temp3\" ]; then\n            echo \"$temp3\"\n            return\
    \ 0\n        fi\n\n        if [ \"$next\" == \"$temp3\" ]; then\n            echo\
    \ \"$temp3\"\n            return 0\n        fi\n\n        if [ \"$prev\" == \"\
    $temp7\" ]; then\n            echo \"$temp7\"\n            return 0\n        fi\n\
    \n        if [ \"$next\" == \"$temp7\" ]; then\n            echo \"$temp7\"\n\
    \            return 0\n        fi\n\n        if [ \"$prev\" == \"$temp9\" ]; then\n\
    \            echo \"$temp9\"\n            return 0\n        fi\n\n        if [\
    \ \"$next\" == \"$temp9\" ]; then\n            echo \"$temp9\"\n            return\
    \ 0\n        fi\n\n        if [ \"$prev\" == \"$temp11\" ]; then\n           \
    \ echo \"$temp11\"\n            return 0\n        fi\n\n        if [ \"$next\"\
    \ == \"$temp11\" ]; then\n            echo \"$temp11\"\n            return 0\n\
    \        fi\n\n        if [ \"$prev\" == \"$temp13\" ]; then\n            echo\
    \ \"$temp13\"\n            return 0\n        fi\n\n        if [ \"$next\" == \"\
    $temp13\" ]; then\n            echo \"$temp13\"\n            return 0\n      \
    \  fi\n\n        if [ \"$prev\" == \"$temp15\" ]; then\n            \n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp3w9xelpl.sh: line 114: syntax error near unexpected token `}''

    /tmp/tmp3w9xelpl.sh: line 114: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ string=\"$1\"\n    if [[ $string == +([[:digit:]]) ]]; then\n        echo \"\
    $string\"\n        return\n    fi\n    local -n string=\"$1\"\n    local -n number=\"\
    ${string#-}\"\n    local -n number=\"${number%+}\"\n    local -n number=\"${number#+}\"\
    \n    local -n number=\"${number%%.*}\"\n    local -n number=\"${number%.*}\"\n\
    \    echo \"$number\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpvc_dh1eq.sh: line 23: local: `14.5'': invalid variable name for
    name reference

    /tmp/tmpvc_dh1eq.sh: line 24: local: `14.5'': invalid variable name for name reference

    /tmp/tmpvc_dh1eq.sh: line 25: local: `'': not a valid identifier

    /tmp/tmpvc_dh1eq.sh: line 26: local: `'': not a valid identifier

    /tmp/tmpvc_dh1eq.sh: line 27: local: `'': not a valid identifier

    /tmp/tmpvc_dh1eq.sh: line 28: local: `'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\tlocal\
    \ string=\"$1\"\n\tlocal prev_integer\n\tlocal number\n\tlocal next_integer\n\t\
    prev_integer=\"$(echo \"$string\" | sed 's/^ *//')\"\n\tnumber=\"$(echo \"$string\"\
    \ | sed 's/ *$//')\"\n\tnext_integer=\"$(echo \"$number\" | sed 's/^ *//')\"\n\
    \tif [[ \"$prev_integer\" -gt \"$next_integer\" ]]; then\n\t\techo $prev_integer\n\
    \telse\n\t\techo $next_integer\n\tfi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8sat1i7v.sh: line 25: [[: 14.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ VALUE=$1\n    local MIN=$2\n    local MAX=$3\n    local RESULT\n    local FARTHER\n\
    \    local ABOVE\n    local ABOVE2\n    local BELOW\n    local BELOW2\n    local\
    \ CLOSEST\n    local CLOSEST2\n    local ABOVEDIFF\n    local BELOWDIFF\n    local\
    \ CLOSESTDIFF\n    local ABOVEDIFF2\n    local BELOWDIFF2\n    local CLOSESTDIFF2\n\
    \    local NUM\n    local MAXDIFF\n    local MAXDIFF2\n    local MAXDIFF3\n  \
    \  local MAXDIFF4\n    local NUM2\n    NUM=${VALUE}\n    MAXDIFF=${MAX}\n    MAXDIFF2=${MAX}\n\
    \    MAXDIFF3=${MAX}\n    MAXDIFF4=${MAX}\n    NUM2=${VALUE}\n    ABOVE=$(( ${NUM}\
    \ + ${MIN} ))\n    BELOW=$(( ${NUM} - ${MIN} ))\n    CLOSEST=$(( ${NUM} - ${MAX}\
    \ ))\n    ABOVE2=$(expr ${ABOVE} + 1)\n    BELOW2=$(expr ${BELOW} + 1)\n    CLOSEST2=$(expr\
    \ ${CLOSEST} + 1)\n    ABOVEDIFF=$(( ${ABOVE} - ${ABOVE2} ))\n    ABOVEDIFF2=$((\
    \ ${ABOVE} - ${ABOVE2} ))\n    BELOWDIFF=$(( ${BELOW} - ${BELOW2} ))\n    BELOWDIFF2=$((\
    \ ${BELOW} - ${BELOW2} ))\n    CLOSESTDIFF=$(( ${CLOSEST} - ${CLOSEST2} ))\n \
    \   CLOSESTDIFF2=$(( ${CLOSEST} - ${CLOSEST2} ))\n    if [ ${ABOVE} -lt ${MIN}\
    \ ]; then\n        RESULT=${ABOVE}\n    else\n        if [ ${ABOVE} -eq ${MAX}\
    \ ]; then\n            RESULT=${ABOVE2}\n        else\n            if [ ${BELOW}\
    \ -lt ${MIN} ]; then\n                RESULT=${BELOW}\n            else\n    \
    \            if [ ${BELOW} -eq ${MAX} ]; then\n                    RESULT=${BELOW2}\n\
    \                else\n                    if [ ${CLOSEST} -lt ${MIN} ]; then\n\
    \                        RESULT=${CLOSEST}\n                    else\n       \
    \                 if [ ${CLOSEST} -eq\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpqihhz9xa.sh: line 75: syntax error near unexpected token `}''

    /tmp/tmpqihhz9xa.sh: line 75: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x\n  local y diff rounded_x\n  x=$1\n  y=$2\n  diff=$(echo \"scale=8; $x-$y\"\
    \ | bc)\n  rounded_x=$(( ($x + $y) / 2 ))\n  echo $rounded_x if [[ $rounded_x\
    \ -eq $x ]] || [[ $rounded_x -eq $y ]]; then\n    return 0\n  else\n    echo $rounded_x\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp2qe8_lvq.sh: line 24: syntax error near unexpected token `then''

    /tmp/tmp2qe8_lvq.sh: line 24: `  echo $rounded_x if [[ $rounded_x -eq $x ]] ||
    [[ $rounded_x -eq $y ]]; then''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x=\"$1\"\n  local -n y=$2\n  local -n i=0\n  local -n min_diff\n  local -n d\n\
    \n  y=${y%:*}\n\n  while true; do\n    ((i++))\n    ((d=x*i+y))\n    diff=$((\
    \ d - y%d ))\n    [[ -n \"$min_diff\" ]] && [[ \"$diff\" -lt \"$min_diff\" ]]\
    \ || min_diff=$diff\n    [[ $diff -eq 0 ]] && break\n    ((y+=d%:))\n  done\n\n\
    \  echo \"$x\"\n  [[ -n \"$min_diff\" ]] && echo \"$min_diff\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpv2ofnh50.sh: line 19: local: `'': not a valid identifier

    /tmp/tmpv2ofnh50.sh: line 20: local: `0'': invalid variable name for name reference

    /tmp/tmpv2ofnh50.sh: line 28: ((: `10'': not a valid identifier

    /tmp/tmpv2ofnh50.sh: line 29: d - y%d : division by 0 (error token is "d ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # Split\
    \ $1 into individual components and convert them into\n  # integers.\n  local\
    \ -a components\n  IFS='.' read -r -a components <<<\"$1\"\n  local -a components_sorted\n\
    \  IFS='.' read -r -a components_sorted <<<\"${components[@]}\" \\\n    | sort\
    \ -n -k 1 --random-sort\n  local -a numbers\n  local -a numbers_sorted\n  local\
    \ -a closest_integers\n  local -a closest_integers_sorted\n  local -a rounding_factor\n\
    \  local -a rounded_values\n  local -a rounded_values_sorted\n  local -a rounded_integers\n\
    \  local -a rounded_integers_sorted\n  for component in \"${components[@]}\";\
    \ do\n    local -a components\n    if [ -z \"$component\" ]; then\n      # Handle\
    \ a zero input by returning the original input.\n      closest_integers_sorted+=(\"\
    $1\")\n      rounded_values_sorted+=(\"$1\")\n      rounded_integers_sorted+=(\"\
    $1\")\n      continue\n    fi\n    local -a components_sorted\n    IFS='.' read\
    \ -r -a components_sorted <<<\"${components[@]}\" \\\n      | sort -n -k 1 --random-sort\n\
    \    local -a components\n    local -a numbers_sorted\n    local -a closest_integers_sorted\n\
    \    local -a rounding_factor\n    local -a rounded_values\n    local -a rounded_values_sorted\n\
    \    local -a rounded_integers\n    local -a rounded_integers_sorted\n    # If\
    \ the component has a number in it\n    if [ -n \"${components_sorted[0]}\" ];\
    \ then\n      # Take the lowest of the two numbers and round it towards zero.\n\
    \      local number=\"${components_sorted[0]}\"\n      local rounded_number=\"\
    ${number}.0\"\n      local rounded_number=\"${rounded_number//\\.[0-9]*$/.}\"\n\
    \      # Take the absolute value of that number.\n      number=\"${number:-0}\"\
    \n      rounded_number=\"${rounded_number:-0}\"\n      # If that number is equidistant\
    \ from two integers, round it away\n      # from zero.\n      if (( number < rounded_number\
    \ )); then\n        rounded_number=\"$(( $number + $rounded_number + 1 ))\"\n\
    \      fi\n      # Add that number to the numbers array.\n      numbers_sorted+=(\"\
    $number\")\n      # \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpm4g3cdih.sh: line 71: syntax error near unexpected token `}''

    /tmp/tmpm4g3cdih.sh: line 71: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ input=$1\n  local output=$(input)\n  local remainder\n  local closest_integer=0\n\
    \  local closest_double=0\n  while [[ -n $output ]]; do\n    remainder=$(( $output\
    \ % 1 ))\n    closest_integer=$(( $closest_integer + 1 ))\n    closest_double=$((\
    \ $closest_double + ( $output / $remainder ) ))\n    output=$( (( $output / 1\
    \ )) - 1 )\n  done\n  echo \"$closest_integer\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp1rzr3_qs.sh: line 19: input: command not found

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=$1\n  local integers\n  local min\n  local max\n  integers=$(echo $num |\
    \ sed \"s/^\\([0-9]*\\)\\.\\([0-9]*\\)/\\1 \\2/\")\n  min=$(echo \"$integers\"\
    \ | cut -d \" \" -f1)\n  max=$(echo \"$integers\" | cut -d \" \" -f2)\n  if [\
    \ -z \"$max\" ]; then\n    echo \"$min\"\n  else\n    if [ \"$min\" -le \"$max\"\
    \ ]; then\n      echo $(echo \"$min + 1\" | bc)\n    else\n      echo $(echo \"\
    $min - 1\" | bc)\n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local number=${number%.*}\n    local diff=$(expr $(echo \"($number\
    \ - $2) / $1\" | bc -l))\n    local closest=\n    local sign=\n    if [ $diff\
    \ -lt 0 ]; then\n      closest=$(( $number + $diff ))\n      sign=-\n    elif\
    \ [ $diff -gt 0 ]; then\n      closest=$(( $number - $diff ))\n      sign=\n \
    \   else\n      closest=$number\n      sign=\n    fi\n    echo $(( $closest *\
    \ $sign ))\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgbzf7h07.sh: line 233: syntax error near unexpected token `}''

    /tmp/tmpgbzf7h07.sh: line 233: `}''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ num=\"$1\"\n    local min=\"$2\"\n    local max=\"$3\"\n    local diff\n   \
    \ local diff_reset\n    local diff_reset_val\n    local closest_integer\n    local\
    \ closest_integer_val\n    local closest_integers\n    local closest_integer_vals\n\
    \n    diff=`echo \"$max-$min\" | bc`\n    if [ \"$diff\" -eq 0 ]\n    then\n \
    \       closest_integer=\"$min\"\n    elif [ \"$diff\" -gt 0 ]\n    then\n   \
    \     closest_integer=`echo \"$min+$diff/2\" | bc`\n    else\n        closest_integer=`echo\
    \ \"$max-$diff/2\" | bc`\n    fi\n    closest_integers=\"$closest_integer $closest_integer\
    \ $closest_integer $closest_integer\"\n    closest_integer_vals=$( echo \"$closest_integers\"\
    \ | tr ' ' '\\n' | sort -rn | tr '\\n' ' ')\n    closest_integer_val=$( echo \"\
    $closest_integer_vals\" | head -1 | tr -d '\\n')\n    closest_integer_vals=$(\
    \ echo \"$closest_integer_vals\" | tail -1 | tr -d '\\n')\n    diff_reset=$( echo\
    \ \"$diff/2\" | bc)\n    diff_reset_val=$( echo \"$diff_reset\" | tr -d '\\n'\
    \ | tr ' ' '\\n' | sort -rn | tr '\\n' ' ')\n    if [ \"$diff_reset_val\" -gt\
    \ 0 ]\n    then\n        closest_integers=$( echo \"$closest_integer_vals\" |\
    \ sed -ie \"s/$closest_integer_val $closest_integer_val $closest_integer_val $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_vals/\" )\n   \
    \ fi\n    closest_integer_vals=$( echo \"$closest_integers\" | tr ' ' '\\n' |\
    \ sort -rn | tr '\\n' ' ')\n    closest_integer_val=$( echo \"$closest_integer_vals\"\
    \ | head -1 | tr -d '\\n')\n    closest_integer_vals=$( echo \"$closest_integer_vals\"\
    \ | tail -1 | tr -d '\\n')\n    if [ \"$diff_reset_val\" -gt 0 ]\n    then\n \
    \       closest_integers=$( echo \"$closest_integer_vals\" | sed -ie \"s/$closest_integer_val\
    \ $closest_integer_val $closest_integer_val $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_val/$\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmph22h9eob.sh: line 67: unexpected EOF while looking for matching
    `"''

    /tmp/tmph22h9eob.sh: line 71: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [[\
    \ $1 =~ ^[+-]?[0-9]+\\.?[0-9]*$ ]]; then\n    local first=\"$1\"\n    # Make sure\
    \ that the first argument looks like a number\n    if ! [[ $first =~ ^[+-]?[0-9]+\\\
    .?[0-9]*$ ]]; then\n      echo \"$1 does not look like an integer\" >&2\n    \
    \  return 1\n    fi\n    # Make sure that the second argument looks like a number\n\
    \    if ! [[ $2 =~ ^[+-]?[0-9]+\\.?[0-9]*$ ]]; then\n      echo \"$2 does not\
    \ look like an integer\" >&2\n      return 1\n    fi\n    # Round away from zero\
    \ and make sure that its a number\n    # Round away from zero means you get closer\
    \ to the closest integer.\n    # For example: closest_integer(\"14.5\", \"14.4\"\
    ) should return 15\n    # closest_integer(\"-14.5\", \"14.4\") should return -15\n\
    \    if [[ $((first+second)) -gt 0 ]]; then\n      if [[ $((first+second)) -lt\
    \ $((first+first)) ]]; then\n        local closest=$((first+second))\n      elif\
    \ [[ $((first+second)) -lt 0 ]]; then\n        local closest=$((first+second))\n\
    \      else\n        local closest=$((first+second))\n      fi\n      if [[ $((first+second))\
    \ -eq $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   fi\n      local closest=$((closest))\n    else\n      if [[ $((first+second))\
    \ -lt $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   elif [[ $((first+second)) -lt 0 ]]; then\n        local closest=$((first+second))\n\
    \      else\n        local closest=$((first+second))\n      fi\n      if [[ $((first+second))\
    \ -eq $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   fi\n      local closest=$((closest))\n    fi\n    echo $closest\n  else\n\
    \    echo \"$1 does not look like an integer\" >&2\n    return 1\n  fi\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ' does not look like an integer

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo\
    \ \"$1\" | awk -v x=$1 -v n=3 -v d=$(($n - 1)) '{\n\tprint $1 < 0 ? $x - $d :\
    \ $x + $d;\n    }'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:2: (FILENAME=- FNR=1) fatal: attempt to access field -1

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ IFS=.\n    # split $1 into integer and fraction parts\n    local n=$(echo $1\
    \ | cut -d . -f 1-2)\n    local f\n    local parts=()\n    # loop through all\
    \ parts of $n\n    for part in $n; do\n        # split $part into an integer part\
    \ and fraction part\n        local int_part=$(echo $part | cut -d . -f 1)\n  \
    \      local frac_part=$(echo $part | cut -d . -f 2- | sed 's/^0*//')\n      \
    \  # round frac_part up based on the integer\n        frac_part=$(bc <<< \"$frac_part\
    \ + $int_part\")\n        # push the rounded up fraction part into the array\n\
    \        parts+=(\"$frac_part\")\n    done\n    # round $parts up to the nearest\
    \ integer\n    parts=$(echo $parts | tr \" \" \"\\n\" | sort -n | tail -1)\n \
    \   # concatenate integer and fractional parts back together and return\n    echo\
    \ \"${parts[0]}.$parts\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ value_string=$1\n    local sign=$(echo $value_string | awk '{print $1}')\n \
    \   local value=$(echo $value_string | awk '{print $2}')\n    local diff\n   \
    \ local rounding_diff\n\n    # If the given number was already an integer, return\
    \ it\n    if [[ ${value} == ${value} ]]; then\n        echo \"$value_string\"\n\
    \        return 0;\n    fi\n\n    # If the given number is negative, round it\
    \ to the\n    # closest integer below zero.\n    if [[ $sign == \"-\" ]]; then\n\
    \        value=$(echo $value | bc -l)\n        rounding_diff=$(echo $((value +\
    \ 0.5)) | bc -l)\n        diff=$(echo $((rounding_diff - value)) | bc -l)\n  \
    \  fi\n\n    # Convert the given string to an integer.\n    value=$(echo $value\
    \ | bc -l)\n\n    # If the given value is less than 0, return it as-is\n    if\
    \ [[ $diff -lt 0 ]]; then\n        echo \"$value_string\"\n        return 0;\n\
    \    fi\n\n    # If the given value is larger than $value, return it\n    if [[\
    \ $diff -gt $value ]]; then\n        echo \"$value_string\"\n        return 0;\n\
    \    fi\n\n    # If we got here, the given value is not equidistant from\n   \
    \ # two integers, so return the integer closest to zero.\n    diff=$(echo $((diff\
    \ + 0.5)) | bc -l)\n    rounding_diff=$(echo $((diff - value)) | bc -l)\n    diff=$(echo\
    \ $((rounding_diff - value)) | bc -l)\n\n    echo \"$value_string\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  [[ \"$number\" =~ ^-?[0-9]+$ ]] || return 1\n  local closest\n\
    \  local closestNumber\n  local minDiff\n  local numString\n\n  minDiff=1\n  numString=$number\n\
    \  while [[ \"$numString\" =~ ^-?[0-9]+$ ]]; do\n    closestNumber=$(( $numString|$(echo\
    \ \"$numString - $closest\"|bc -l) ))\n    closest=$closestNumber\n    minDiff=$((\
    \ $minDiff|$(echo \"$numString - $closest\"|bc -l) ))\n    numString=$(echo \"\
    $closestNumber + 1\"|bc -l )\n  done\n\n  echo \"$closest\"\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    /tmp/tmp2nfcjrkl.sh: line 28: 10| : syntax error: operand expected (error token
    is "| ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  if [[ $# -eq 1 ]]; then\n    echo \"$1\"\n  else\n    # Remove\
    \ all non-digits to avoid floating point problems\n    local number2=\"${number//[^0-9.]/}\"\
    \n    echo \"$(expr $(echo \"$number2 - $number\" | bc -l) / $(echo \"$number2\
    \ - $number\" | bc -l))\"\n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=\"$1\"\n  local number=\"$2\"\n  local closest\n  local diff\n  local\
    \ closestdiff\n  local prevdiff\n\n  # Convert input string to numeric value\n\
    \  read -r number < <(echo \"$string\" | tr '.' ' ')\n  prevdiff=-1\n  closestdiff=-1\n\
    \  closest=$number\n\n  # Iterate over numbers\n  for number in $(seq 1 $((${#number}\
    \ - 1))); do\n    diff=$((${number} - number))\n\n    if [[ $diff -eq 0 || diff\
    \ -eq $((${#number} - 1)) ]]; then\n      # If diff is zero, then we've found\
    \ the closest number\n      # so exit the loop\n      echo \"$number\"\n     \
    \ return\n    fi\n\n    if [[ $diff -gt $prevdiff ]]; then\n      prevdiff=$diff\n\
    \      closestdiff=$diff\n      closest=$number\n    fi\n  done\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ val=\"$1\"\n  if [ -z \"$val\" ]; then\n    echo \"ERROR: Argument $1 is not\
    \ set.\" 1>&2\n    return 1\n  fi\n  local -a integers=( )\n  local integer\n\
    \  integer=\"$(echo \"$val\" |\n      awk 'BEGIN {\n          FS = \":\"\n   \
    \       for (i = 1; i <= NF; i++) {\n              nums[i] = $1\n            \
    \  printf \"%s\\t\", nums[i]\n          }\n      }\n      function distance(a,\
    \ b) {\n          sum = 0\n          for (i = 1; i <= NF; i++) {\n           \
    \   sum += $i * $i\n          }\n          sq = sum * sum\n          return sq\
    \ * (a - b) * (a - b) / (sqrt sq)\n      }\n      function closest() {\n     \
    \     for (index = 1; index <= NF; index++) {\n              dist = distance(index-1,\
    \ index)\n              if (dist > distance(a,b)) {\n                  a = index\n\
    \              }\n          }\n      }\n      closest(5)\n      closest(6)\n \
    \     closest(7)\n      closest(8)\n      closest(9)\n      closest(10)\n    \
    \  closest(11)\n      closest(12)\n      closest(13)\n      closest(14)\n    \
    \  closest(15)\n      closest(16)\n      closest(17)\n      closest(18)\n    \
    \  closest(19)\n      closest(20)\n      closest(21)\n      closest(22)\n    \
    \  closest(23)\n      closest(24)\n      closest(25)\n      closest(26)\n    \
    \  closest(27)\n      closest(28)\n      closest(29)\n      closest(30)\n    \
    \  closest(31)\n      closest(32)\n      closest(33)\n      closest(34)\n    \
    \  closest(35)\n      closest(36)\n      closest(37)\n      closest(38)\n    \
    \  closest(39)\n      closest(40)\n      closest(41)\n      closest(42)\n    \
    \  closest(43)\n      closest(44)\n      closest(45)\n      closest(46)\n    \
    \  closest(47)\n      closest(48)\n      closest(49)\n      closest(50)\n    \
    \  closest(51)\n      closest(52)\n      closest(53)\n      closest(54)\n    \
    \  closest(55)\n      closest(56)\n      closest(57)\n      closest(58)\n    \
    \  closest(59)\n      closest(60)\n      closest(61)\n      closest(62)\n    \
    \  closest(63)\n      close\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmphoucpkzl.sh: line 26: unexpected EOF while looking for matching
    `''''

    /tmp/tmphoucpkzl.sh: line 125: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ val=$1\n    local minval=0\n    local maxval=${#val}\n    local lastval=${#val}\n\
    \    local rounding=0\n    while [ $lastval -gt $minval ]; do\n        lastval=$((lastval-1))\n\
    \    done\n    while [ $lastval -gt $maxval ]; do\n        lastval=$((lastval+1))\n\
    \    done\n    local roundval=$((lastval+rounding))\n    if [ $val -eq $roundval\
    \ ]; then\n        echo $roundval\n        return\n    fi\n    while [ $minval\
    \ -le $maxval ]; do\n        local midval=$((minval+maxval)/2)\n        local\
    \ diff=$((midval-val))\n        if [ $diff -eq 0 ]; then\n            echo $roundval\n\
    \            echo $roundval\n            return\n        elif [ $diff -eq $((minval-roundval))\
    \ ]; then\n            minval=$((midval))\n        elif [ $diff -eq $((maxval-roundval))\
    \ ]; then\n            maxval=$((midval))\n        fi\n    done\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=17 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=52 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ -a arr=( $1 )\n  local closest\n  for n in \"${arr[@]}\"; do\n    (( closest+=n\
    \ ))\n  done\n  closest=$(echo \"$closest\" | bc)\n  [[ $closest -eq 0 ]] && closest=$((\
    \ 10#1 ))\n  (( $closest > $2 )) && closest=$(( $closest - 1 ))\n  echo \"$closest\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpli6u3csr.sh: line 25: ((: 10 >  : syntax error: operand expected
    (error token is ">  ")

    /tmp/tmpli6u3csr.sh: line 21: ((: 14.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    /tmp/tmpli6u3csr.sh: line 25: ((: 1 >  : syntax error: operand expected (error
    token is ">  ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [\
    \ \"$#\" -eq 1 ]\n  then\n    number=$1\n  else\n    echo \"Need one argument.\"\
    \n    exit 1\n  fi\n\n  case \"$number\" in\n    (-?[0-9]+)([.][0-9]+)?([eE][-+]?[0-9]+)?)\n\
    \      echo \"$number\"\n      ;;\n    *)\n      echo \"$number\" | sed -e 's/^\
    \ *//' -e 's/ *$//'\n      ;;\n  esac\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1i5kvl27.sh: line 27: syntax error near unexpected token `?''

    /tmp/tmp1i5kvl27.sh: line 27: `    (-?[0-9]+)([.][0-9]+)?([eE][-+]?[0-9]+)?)''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=\"$1\"\n    local num=\"${number%.*}\"\n    local num=\"${num#*-}\"\n\
    \    local num=\"${num%.0}\"\n    local num=\"${num%.}\"\n    local num=\"${num#.}\"\
    \n    local num=\"${num#,}\"\n    local num=\"${num%,}\"\n    local num=\"${num#+}\"\
    \n    local num=\"${num%+}\"\n    local num=\"${num#-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=$1\n  local numstring=\"${string%.*}\"\n  local num=\"${numstring#*.}\"\
    \n  local closest=\"${string#$num}\"\n  local int\n  if [ -z \"$closest\" ]\n\
    \  then\n    closest=\"${closest}\"\n  fi\n  local num2\n  num2=$(echo $closest\
    \ | sed -e \"s/^0//\" -e \"s/^-//\")\n  local diff\n  diff=$(echo \"${closest}\
    \ - ${num2}\"| bc)\n  local diffabs\n  diffabs=$(echo \"${diff}\" | bc | xargs\
    \ | head -1)\n  if [ -z \"$diffabs\" ]\n  then\n    int=\"${closest}\"\n  else\n\
    \    int=\"${closest}+${diffabs}\"\n  fi\n  echo \"$int\"\n}\n\ncandidate() {\n\
    \    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 2: syntax error

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local integer_result=0\n  local previous_result=0\n  local diff\n\
    \n  while [[ $integer_result -eq 0 ]]; do\n    integer_result=$(( $(( $number\
    \ / 10 )) % 10 ))\n    previous_result=$(( $(( $number / 10 )) % 10 ))\n    diff=$((\
    \ $number - $previous_result ))\n    number=$(( $number - diff ))\n  done\n  echo\
    \ \"$integer_result\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ value\n  local -n x=\"$1\"\n  x=${x//./}\n  local -n y=\"$1\"\n  y=${y//./}\n\
    \  local -n z=\"$1\"\n  z=${z//./}\n  if [ \"$x\" -eq \"$y\" ]\n  then\n    if\
    \ [ \"$x\" -eq \"$z\" ]\n    then\n      echo \"$x\"\n    else\n      local -n\
    \ f=\"$x\"\n      f=$(( ${f} - 1 ))\n      echo \"$f\"\n    fi\n  else\n    if\
    \ [ \"$x\" -eq \"$z\" ]\n    then\n      local -n g=\"$y\"\n      g=$(( ${g} -\
    \ 1 ))\n      echo \"$g\"\n    else\n      local -n h=\"$z\"\n      h=$(( ${h}\
    \ - 1 ))\n      echo \"$h\"\n    fi\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpsq7lcgfx.sh: line 19: local: `10'': invalid variable name for name
    reference

    /tmp/tmpsq7lcgfx.sh: line 21: local: `10'': invalid variable name for name reference

    /tmp/tmpsq7lcgfx.sh: line 23: local: `10'': invalid variable name for name reference

    /tmp/tmpsq7lcgfx.sh: line 25: [: : integer expression expected

    /tmp/tmpsq7lcgfx.sh: line 36: [: : integer expression expected

    /tmp/tmpsq7lcgfx.sh: line 42: local: `'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local digits=$(( 10#$number ))\n  local factor=10\n  local quotient\n\
    \  local distance\n  local result\n  local difference\n  local closest\n\n  local\
    \ previous\n  local current\n  local previousDistance\n  local currentDistance\n\
    \n  local min\n  local max\n  local maxDistance\n\n  local range\n  local maxDistance\n\
    \  local minDistance\n  local maxDifference\n  local minDifference\n\n  local\
    \ digitCount\n\n  while (( digits >= 10 )); do\n    digitCount=$(( 10#$digits\
    \ ))\n    digits=( ( 10#$digits ) - 1 )\n    factor=$(muldiv $factor 10)\n\n \
    \   if [ $digits == 0 ]; then\n      break\n    fi\n  done\n\n  # Check if the\
    \ number is actually an integer\n  if [ $digits -lt 10 ]; then\n    echo \"Error:\
    \ Number must be an integer.\" > /dev/stderr\n    return 1\n  fi\n\n  # Round\
    \ away from zero if equidistant to two other integers\n  if [ -z \"$min\" ] ||\
    \ [ -z \"$max\" ]; then\n    previous=$(muldiv $number $factor)\n    previous=(\
    \ ( 10#$previous ) - 1 )\n    previous=$(( 10#$previous ))\n\n    if [ \"$previous\"\
    \ = \"$number\" ]; then\n      echo \"$number\" > /dev/stderr\n      return $number\n\
    \    fi\n\n    while [ \"$previous\" -gt \"$min\" ] && [ \"$previous\" -lt \"\
    $max\" ]; then\n      previous=$(muldiv $previous $factor)\n      previous=( (\
    \ 10#$previous ) - 1 )\n      previous=$(( 10#$previous ))\n    done\n\n    if\
    \ [ \"$previous\" == \"$min\" ]; then\n      min=$number\n    elif [ \"$previous\"\
    \ == \"$max\" ]; then\n      max=$number\n    fi\n  fi\n\n  if [ \"$min\" = \"\
    $max\" ]; then\n    echo \"$number\" > /dev/stderr\n    return $number\n  fi\n\
    \n  range=$(( 10#$max - $min ))\n  maxDistance=$(( 10#$range/2 ))\n\n  while [\
    \ \"$min\" -lt \"$max\" ] && [ \"$min\" -lt \"$maxDistance\" ]; then\n    current=$(muldiv\
    \ $number $factor)\n    currentDistance=$(( 10#$current/2 ))\n\n    if [ \"$min\"\
    \ = \"$current\" ]; then\n      echo \"$number\" > /dev/stderr\n      return $number\n\
    \    fi\n\n    if [ \"$minDistance\" -eq \"$currentDistance\" ]; then\n      min=$number\n\
    \    fi\n\n    if [ \"$maxDistance\" -eq \"$currentDistance\" ]; then\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpd1krzxj4.sh: line 46: syntax error near unexpected token `(''

    /tmp/tmpd1krzxj4.sh: line 46: `    digits=( ( 10#$digits ) - 1 )''

    /tmp/tmpd1krzxj4.sh: line 47: muldiv: command not found

    /tmp/tmpd1krzxj4.sh: line 49: [: ==: unary operator expected

    /tmp/tmpd1krzxj4.sh: line 52: syntax error near unexpected token `done''

    /tmp/tmpd1krzxj4.sh: line 52: `  done''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: -1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=$1\n    local output=$(\n        # Round number down\n        if [[ ${number}\
    \ -lt 1 ]]; then\n            ${number}\n        fi\n        # Divide by 2 until\
    \ number is odd\n        while [[ \"${number}%2\" == \"1\" ]]; do\n          \
    \  number=$((${number}/2))\n        done\n        # Divide by 2 until number is\
    \ even\n        while [[ \"${number}%2\" != \"0\" ]]; do\n            number=$((${number}/2))\n\
    \        done\n        # Return result (rounded away from zero)\n        ${number#0}\n\
    \    )\n    echo \"$output\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=53 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=4 encoding='utf-8'>
  timestamp: 1660057030
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  if [[ \"${number}\" =~ ^-?[0-9]+$ ]]; then\n    if [[ \"$number\"\
    \ -gt \"$number1\" ]] || [[ \"$number\" -lt \"$number2\" ]]; then\n      number1=$number\n\
    \    else\n      number2=$number\n    fi\n  else\n    echo \"${number} is not\
    \ a number\"\n    return 1\n  fi\n  local closest_integer=$(( number1 + number2\
    \ ))\n  echo $closest_integer\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ v=$1\n  local i=`echo $v | awk -F. '{print $1}'`\n  local j=`echo $v | awk -F.\
    \ '{print $2}'`\n  local k=`echo $v | awk -F. '{print $3}'`\n  if [ \"$i\" ==\
    \ \"$j\" ]; then\n    if [ \"$i\" == \"$k\" ]; then\n      i=$(( $i + 1 ))\n \
    \   else\n      i=$(( $i - 1 ))\n    fi\n  else\n    if [ \"$j\" == \"$k\" ];\
    \ then\n      j=$(( $j + 1 ))\n    else\n      j=$(( $j - 1 ))\n    fi\n  fi\n\
    \  echo $i\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n\tlocal\
    \ NUMBER=$1\n\tlocal CLOSEST_VALUE=$2\n\tlocal NUMBER_FLOAT=$(( ${NUMBER} / 10\
    \ ))\n\tlocal NUMBER_INT=$(( ${NUMBER} % 10 ))\n\n\tlocal CLOSEST_INTEGER=$((\
    \ ${CLOSEST_VALUE} - ${NUMBER_FLOAT} ))\n\n\tlocal CLOSEST_INTEGER_STRING=$((\
    \ ${CLOSEST_INTEGER} + ${NUMBER_INT} ))\n\tlocal CLOSEST_INTEGER_STRING=\"$( printf\
    \ \"%03d\" ${CLOSEST_INTEGER_STRING} )\"\n\n\techo \"${CLOSEST_INTEGER_STRING}\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ number=\"${1}\"\n    local diff\n\n    local min1=\"${1}\"\n    local min2=\"\
    ${min1}\"\n    local max1=\"${number}\"\n    local max2=\"${number}\"\n    local\
    \ difference1=\"${1}\"\n    local difference2=\"${1}\"\n\n    # Calculate the\
    \ difference between the numbers\n    while [[ \"${min1}\" > \"${max1}\" ]]; do\n\
    \        ((difference1++))\n        ((min1--))\n    done\n    while [[ \"${min2}\"\
    \ > \"${max2}\" ]]; do\n        ((difference2--))\n        ((max2++))\n    done\n\
    \n    # Calculate the difference between the two\n    difference1=\"$((difference1\
    \ - difference2))\"\n    if [[ -z \"${difference1}\" ]]; then\n        return\
    \ 1\n    fi\n\n    # Get the closest integer\n    diff=\"$((min1 + difference1))\"\
    \n\n    case \"${diff}\" in\n        0)\n            echo \"${number}\"\n    \
    \    ;;\n        -0)\n            echo \"${min1}\"\n        ;;\n        *)\n \
    \           echo \"${min1}\"\n        ;;\n    esac\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpudu7ka33.sh: line 39: 14.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ IFS=.\n  echo \"${1%%-*}\"\n  local num=\"${1#*-}\"\n  local num2=${1#*.}\n\
    \  local numdiff=$(( num - num2 ))\n  if [ -z \"$num2\" ]; then\n    echo \"0\"\
    \n  fi\n  local numstr=$(( numdiff + num2 ))\n  local numstr2=$(printf \"%.0f\"\
    \ $numstr)\n  echo \"$numstr2\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local diff\n  local diff1\n  local diff2\n\n  echo \"${number}|$(echo\
    \ \"${number}\" | awk -F. '{print $1}')\"\n  echo \"${number}|$(echo \"${number}\"\
    \ | awk -F. '{print $1}')\"\n  diff=$((10#${number}|$(echo \"${number}\" | awk\
    \ -F. '{print $1}')))\n  diff1=$((${number}|$(echo \"${number}\" | awk -F. '{print\
    \ $1}')))\n  diff2=$((10#${number}|$(echo \"${number}\" | awk -F. '{print $1}')))\n\
    \  echo \"${diff}|${diff1}|${diff2}\"\n\n  # If diff < 0, then we're in the negative\
    \ direction so we need to add\n  # 10 to diff. Otherwise, we're in the positive\
    \ direction, so it's the\n  # opposite.\n  if (( diff < 0 )); then\n    ((diff\
    \ += 10))\n  else\n    ((diff -= 10))\n  fi\n\n  echo \"${diff}|${diff1}|${diff2}\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=\"$1\"\n  local diff\n  local min\n\n  # convert input string to float\n\
    \  local float_val=\"$string\"\n  float_val=\"$((float_val / 10))\"\n\n  # if\
    \ first integer is greater than second integer\n  if [[ $string -gt $(( $string\
    \ + .5 )) ]]; then\n    # return second integer\n    echo $string\n    return\n\
    \  fi\n\n  # if first integer is less than second integer\n  if [[ $string -lt\
    \ $(( $string - .5 )) ]]; then\n    # return second integer\n    echo $string\n\
    \    return\n  fi\n\n  # if values are equidistant from two integers\n  # determine\
    \ which one is closer\n  if [ $(( $string - $float_val )) -le $(( $float_val -\
    \ $string )) ]; then\n    # return first integer\n    echo $string\n    return\n\
    \  fi\n\n  # if values are equidistant from two integers\n  # determine which\
    \ one is closer\n  if [ $(( $string - $float_val )) -ge $(( $float_val - $string\
    \ )) ]; then\n    # return second integer\n    echo $string\n    return\n  fi\n\
    \n  # if values are equidistant from two integers\n  # determine which one is\
    \ closer\n  if [ $string -eq $float_val ]; then\n    echo $string\n    return\n\
    \  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1z86p91i.sh: line 27: 10 + .5 : syntax error: operand expected
    (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local\
    \ num=$1\n    local min\n    local max\n    min=$((${num}-1))\n    max=$((${num}+1))\n\
    \    # find min and max if they're integers\n    # otherwise find min and max\
    \ if they're floats\n    if [[ $((${min#0}%1)) == 1 && $((${max#0}%1)) == 1 ]];\
    \ then\n        local tmp_min=$((${min#0}))\n        local tmp_max=$((${max#0}))\n\
    \        local tmp_num\n        tmp_num=$(expr ${tmp_max} - ${tmp_min} + 1)\n\
    \        local tmp_ans\n        tmp_ans=$(expr ${num} - ${tmp_min})\n        #\
    \ find the closest number\n        local min_diff\n        local min_idx\n   \
    \     min_diff=$((${tmp_num} - ${num}))\n        min_idx=$((${tmp_ans} - ${num}))\n\
    \        if [[ ${min_diff} -eq 0 ]]; then\n            echo ${tmp_num}\n     \
    \   elif [[ ${min_diff} -gt 0 ]]; then\n            echo ${num}\n        elif\
    \ [[ ${min_diff} -lt 0 ]]; then\n            echo ${tmp_ans}\n        fi\n   \
    \ elif [[ $((${min#%.*}%1)) == 0 && $((${max#%.*}%1)) == 0 ]]; then\n        local\
    \ tmp_num\n        tmp_num=$(expr ${max} - ${min} + 1)\n        local tmp_ans\n\
    \        tmp_ans=$(expr ${num} - ${min})\n        # find the closest number\n\
    \        local min_diff\n        local min_idx\n        min_diff=$((${tmp_num}\
    \ - ${num}))\n        min_idx=$((${tmp_ans} - ${num}))\n        if [[ ${min_diff}\
    \ -eq 0 ]]; then\n            echo ${tmp_num}\n        elif [[ ${min_diff} -gt\
    \ 0 ]]; then\n            echo ${num}\n        elif [[ ${min_diff} -lt 0 ]]; then\n\
    \            echo ${tmp_ans}\n        fi\n    elif [[ $((${min#%.*}%1)) == 0 &&\
    \ $((${max#%.*}%1)) != 0 ]]; then\n        local tmp_num\n        tmp_num=$(expr\
    \ ${max} - ${min} + 1)\n        local tmp_ans\n        tmp_ans=$(expr ${num} -\
    \ ${min})\n        # find the closest number\n        local min_diff\n       \
    \ local min_idx\n        min_diff=$((${tmp_num} - ${num}))\n        min_idx=$((${tmp_ans}\
    \ - ${num}))\n        if [[ ${min_diff} -\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0dlnp4ry.sh: line 71: conditional binary operator expected

    /tmp/tmp0dlnp4ry.sh: line 71: syntax error near `-''

    /tmp/tmp0dlnp4ry.sh: line 71: `        if [[ ${min_diff} -''

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ NUM=\"$1\"\n  local NUM2=\"${NUM}.0\"\n  NUM2=($NUM2)\n  local DIVISOR\n  local\
    \ RESULT\n  local MIN\n  local MAX\n  local REM\n  REM=$(( (${#NUM2[@]}-1) / 2\
    \ ))\n  while true; do\n    DIVISOR=$(( ${NUM2[$REM]} - ${NUM2[$((REM-1))]} ))\n\
    \    RESULT=$(( ${NUM} / $DIVISOR ))\n    if [ \"$RESULT\" = \"$NUM\" ]; then\n\
    \      MIN=$REM\n      MAX=$(( ${#NUM2[@]} - 1 ))\n    elif [ \"$RESULT\" -gt\
    \ \"$NUM\" ]; then\n      MIN=$(( ${#NUM2[@]} - 1 ))\n      MAX=$REM\n    else\n\
    \      MIN=$(( ${#NUM2[@]} - 1 ))\n      MAX=$REM\n    fi\n    break\n  done\n\
    \  if [ \"$MIN\" = \"$MAX\" ]; then\n    echo \"$NUM\"\n  else\n    echo \"${NUM}${NUM2[$MIN]}\"\
    \n  fi\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpj_9wqpsk.sh: line 28: 10.0 - 10.0 : syntax error: invalid arithmetic
    operator (error token is ".0 - 10.0 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ number=$1\n  local numbers=$( echo \"$number\" | sed 's/-?[0-9]\\([0-9.]*\\\
    )/\\1/' )\n  local closest=$(\n    case \"$number\" in\n      # If the input is\
    \ less than two, return it.\n      \"$number\"|\"\")\n      echo \"$number\"\n\
    \      ;;\n      \"$numbers\"|\"\")\n      echo \"$number\"\n      ;;\n      *)\n\
    \      local dist\n      local min\n      # Find the closest number that's not\
    \ greater than the number\n      # we're looking for.\n      min=$( echo \"$numbers\"\
    \ | sed 's/^[^-]*-\\(.*\\)/\\1/' )\n      dist=`echo \"$number-$min\" | bc`\n\
    \      echo \"$min\"\n      ;;\n    esac\n  )\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ num=\"${1}\"\n  (( num_sign=${num%%-*}; num=${num##*-} ))\n  # Make sure that\
    \ $num ends in decimal point\n  if [ \"$num_sign\" = \"-\" ]; then\n    num=$((\
    \ 10#$num + 1 ))\n  else\n    num=$(( 10#$num - 1 ))\n  fi\n  # Test to see if\
    \ $num is equidistant from two integers\n  # Note: if two integers have a difference\
    \ of less than 0.0001 then\n  # they are equidistant\n  local diff\n  if (( diff\
    \ )); then\n    if (( diff < 0.0001 )); then\n      echo \"$num\"\n    else\n\
    \      echo \"0\"\n    fi\n  else\n    echo $num\n  fi\n}\n\ncandidate() {\n \
    \   closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn3z4gqys.sh: line 19: ((: num_sign=10; num=10 : syntax error: invalid
    arithmetic operator (error token is "; num=10 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo\
    \ -n \"$1\"\n    local -n num=$1\n    local -n prev=\"$num\"\n    local -n max\n\
    \    local -n dist\n    local -n pos\n    local -n closest\n\n    num=$(echo \"\
    $num\" | sed 's/\\./ /' | bc)\n    max=$(($num))\n    prev=0\n\n    while [ \"\
    $max\" -gt \"$prev\" ]; do\n        ((dist=$((max-prev)))) # calculate the distance\
    \ between `max` and `prev`\n        pos=$(( prev + dist/2 )) # calculate the position\
    \ of `max` within `prev`\n        closest=\"$pos\"\n        if [ \"$dist\" -eq\
    \ \"$max\" ]\n        then\n            closest=$(( prev + dist ))\n        fi\n\
    \        prev=$pos\n        max=$(( $max -1 ))\n    done\n    echo \"$closest\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpcbd8heqn.sh: line 19: local: `10'': invalid variable name for name
    reference

    /tmp/tmpcbd8heqn.sh: line 20: local: `'': not a valid identifier

    /tmp/tmpcbd8heqn.sh: line 27: `0'': not a valid identifier

    /tmp/tmpcbd8heqn.sh: line 19: local: `14.5'': invalid variable name for name reference

    /tmp/tmpcbd8heqn.sh: line 20: local: `'': not a valid identifier

    /tmp/tmpcbd8heqn.sh: line 27: `0'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ x=\"$1\"\n  if [[ $x =~ (^-?[0-9]+(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$) ]]; then\n\
    \    local num=\"$(echo \"$x\" | sed 's/^-?//;s/^\\.//')\"\n    local max=\"$(echo\
    \ \"$x\" | sed 's/^-?//;s/^\\.//')\"\n    while (( \"$num\" > \"$max\" )) ; do\n\
    \      max=$(( max + 1 ))\n    done\n    while (( \"$num\" < \"$max\" )) ; do\n\
    \      max=$(( max - 1 ))\n    done\n    echo \"$max\"\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpz46n6ews.sh: line 22: ((: 14.5 > 14.5 : syntax error: invalid arithmetic
    operator (error token is ".5 > 14.5 ")

    /tmp/tmpz46n6ews.sh: line 25: ((: 14.5 < 14.5 : syntax error: invalid arithmetic
    operator (error token is ".5 < 14.5 ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ input=\"$1\"\n  local integer=\"\"\n  local closest=\"\"\n  local distance=\"\
    \"\n\n  if [ -z \"$input\" ] || [ \"${#input}\" -gt 2 ]; then\n    echo \"$0:\
    \ Event argument missing or invalid or empty\" >&2\n    exit 1\n  fi\n\n  input=\"\
    $input\"\n  integer=\"${input%%.*}\"\n\n  # Remove \".\" if present (no fractional\
    \ part)\n  if [ -z \"$integer\" ]; then\n    integer=\"$input\"\n  fi\n\n  # Remove\
    \ \"-\" if present (no negative sign allowed)\n  if [ -z \"$integer\" ]; then\n\
    \    integer=\"$input\"\n  fi\n\n  # Remove leading zeroes\n  if [ -z \"$integer\"\
    \ ]; then\n    integer=\"$input\"\n  fi\n\n  # Remove trailing zeroes\n  if [\
    \ -z \"$integer\" ]; then\n    integer=\"$input\"\n  fi\n\n  # Get length of integer\
    \ part\n  length=$(echo \"$integer\" | wc -w)\n\n  # Remove \".\" if present\n\
    \  if [ -z \"$integer\" ]; then\n    integer=\"$input\"\n  fi\n\n  case \"$integer\"\
    \ in\n    -*)\n      echo \"$0: Invalid decimal input \\\"$integer\\\"\" >&2\n\
    \      exit 1\n    ;;\n    *)\n      integer \"$length\"\n    ;;\n  esac\n}\n\n\
    candidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmppsn75w1l.sh: line 65: integer: command not found

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ VALUE=\"$1\"\n\n  if [ \"$VALUE\" == \"\" ]; then\n    VALUE=\"0\"\n  fi\n\n\
    \  local DIVISOR=\n  local CLOSEST_VALUE=\"$VALUE\"\n  local CLOSEST_DIVISOR=0\n\
    \  local CLOSEST_DIVISOR_PRECISION=0\n  local CLOSEST_DIVISOR_REMAINDER=0\n  local\
    \ CLOSEST_DIVISOR_OFFSET=-1\n\n  for DIVISOR in $(seq \"$VALUE\" 1 0 1); do\n\
    \    local DIVISOR_PRECISION=$(( 10#$DIVISOR ))\n    local DIVISOR_REMAINDER=$((\
    \ 10#$DIVISOR % 10#$VALUE ))\n    local DIVISOR_OFFSET=$(( 10#$DIVISOR % 10#$VALUE\
    \ ))\n\n    if [ \"$DIVISOR_PRECISION\" -gt \"$CLOSEST_DIVISOR_PRECISION\" ];\
    \ then\n      CLOSEST_DIVISOR_PRECISION=\"$DIVISOR_PRECISION\"\n      CLOSEST_DIVISOR_REMAINDER=\"\
    $DIVISOR_REMAINDER\"\n      CLOSEST_DIVISOR_OFFSET=\"$DIVISOR_OFFSET\"\n     \
    \ CLOSEST_DIVISOR=\"$DIVISOR\"\n    fi\n\n    if [ \"$CLOSEST_DIVISOR\" -gt \"\
    $CLOSEST_VALUE\" ]; then\n      CLOSEST_VALUE=\"$CLOSEST_DIVISOR\"\n    fi\n\n\
    \    if [ \"$CLOSEST_DIVISOR_OFFSET\" -ge \"0\" ]; then\n      break\n    fi\n\
    \  done\n\n  echo \"$CLOSEST_DIVISOR\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "seq: extra operand \u20181\u2019\nTry 'seq --help' for more information.\n"
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local\
    \ string=\"$1\"\n  local integer=\"${string}\"\n  local number=\"1\"\n  local\
    \ factor=\"$2\"\n\n  while [[ \"$integer\" -gt \"$number\" ]]; do\n    number=$((\
    \ $number * $factor ))\n  done\n  echo \"$number\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmplwn2a3vs.sh: line 24: 1 *  : syntax error: operand expected (error
    token is "*  ")

    '
  stdout: ''
  timestamp: 1660057025
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
    \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
    \ away from zero means that if the given number is equidistant\n# from two integers,\
    \ the one you should return is the one that is the\n# farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"\
    -14.5\") should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if [[\
    \ \"$1\" = \"-.*\" ]]; then\n    echo \"$(( $(echo \"$1\" | tr '.' '+' | bc -l)\
    \ / $2 ))\"\n  else\n    echo \"$(( ( $1 < $2 ) ? $1 : $2 ))\"\n  fi\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmhnhbfk6.sh: line 21: ( 10 <  ) ? 10 :  : syntax error: operand
    expected (error token is ") ? 10 :  ")

    '
  stdout: ''
  timestamp: 1660057025
