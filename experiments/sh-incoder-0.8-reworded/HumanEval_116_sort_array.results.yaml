language: sh
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -r array=\"$1\"\n    local -r i\n    local -a\
    \ sorted_array=()\n\n    while IFS= read -r -d '' i; do\n        binary_number=\"\
    $(echo \"${i}\" | cut -d ' ' -f1)\"\n        decimal=\"$(echo \"${i}\" | cut -d\
    \ ' ' -f2)\"\n        ones=\"$(echo \"${binary_number}\" | wc -c)\"\n        if\
    \ [[ ${ones} -gt 1 ]]; then\n            sorted_array+=(\"$(echo \"${i}\" | sed\
    \ -r \"s/${binary_number}$//g\")\")\n        elif [[ ${decimal} -gt 0 ]]; then\n\
    \            sorted_array+=(\"$(echo \"${i}\" | sed -r \"s/${binary_number}$//g\"\
    )\")\n        fi\n    done <<< \"${array}\"\n\n    IFS= read -r -d '' -u ${sorted_array[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpyaq0b_75.sh: line 19: i: readonly variable

    /tmp/tmpyaq0b_75.sh: line 30: read: -u: option requires an argument

    read: usage: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars]
    [-p prompt] [-t timeout] [-u fd] [name ...]

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=\"$1\"\n  shift\n  local -n arr=\"$1\"\n \
    \ local -n ones=\"${arr}_ones\"\n  local -n sort=\"_sort\"\n  local -n output=\"\
    $1\"\n  local -n len=\"${#arr}\"\n  local -n res=\"\"\n  local -i cnt\n  local\
    \ s\n  local i\n  local k\n  local z\n  local t\n  local n\n  local bin\n\n  output=\"\
    $(printf '%s\\n' \"${arr[@]}\")\"\n\n  (( \"${#output}\" <= 1 )) && return 0\n\
    \  (( \"${#output}\" > $(( $(( ${#ones} * 8 )) / $(( $(( $(( $(( ${#ones} / 8\
    \ )) + 1 )) )) )) )) )) && return 0\n  (( \"${#output}\" > $(( $(( ${#ones} *\
    \ 8 )) / $(( $(( $(( $(( ${#ones} / 8 )) + 1 )) )) )) )) )) && return 1\n\n  output=\"\
    $( printf '%s\\n' \"${output}\" )\"\n  output=\"${output//$'\\n'/','}\"\n\n  z=\"\
    $(echo \"${output}\" | sed -e 's/^[\\t]*//g' -e 's/,$//g')\"\n  if [ -z \"${z}\"\
    \ ]; then\n    output=\"\"\n  fi\n\n  printf -v \"arr\" -a arr '%q' \"${output}\"\
    \n  printf -v \"ones\" -a ones '%q' \"${arr}_ones\"\n  printf -v \"sort\" -a sort\
    \ '%q' \"_sort\"\n\n  arr=\"$(echo \"${arr}\" | sed -e 's/^[\\t]*//g' -e 's/,$//g')\"\
    \n  ones=\"$(echo \"${ones}\" | sed -e 's/^[\\t]*//g' -e 's/,$//g')\"\n  sort=\"\
    $(echo \"${sort}\" | sed -e 's/^[\\t]*//g' -e 's/,$//g')\"\n\n  printf -v \"output\"\
    \ -a output '%q' \"${arr[@]}\"\n\n  for (( i=1; i<${#arr}; i++ )); do\n    cnt=0\n\
    \    for (( j=0; j<${#ones}; j++ )); do\n      (( ${ones:j:1} == ${arr:i:1} ))\
    \ && let cnt=${cnt}+1\n    done\n    (( cnt \n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpy_b5_vnq.sh: line 61: unexpected EOF while looking for matching
    `)''

    /tmp/tmpy_b5_vnq.sh: line 81: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array_str=$1\n  local arr\n  arr=($array_str)\n\
    \  local i\n  for ((i=1;i<${#arr[@]};i++)); do\n    local num_ones=\"$(printf\
    \ \"%b\" \"${arr[$i]}\" | wc -m)\"\n    local num_decimal=\"${arr[$i]}\"\n   \
    \ if [ \"$num_ones\" -gt \"$num_decimal\" ]; then\n      arr[$i]=\"$num_ones\"\
    \n    else\n      arr[$i]=\"$num_decimal\"\n    fi\n  done\n  printf \"\\\"%s\\\
    \"\\n\" \"${arr[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=$1\n    local tempArray=()\n    local\
    \ output=\"\"\n    local temp=\"\"\n    local sortedArray=()\n    local count\n\
    \    local currentIndex\n\n    IFS=$'\\n' read -a tempArray <<< \"${input}\"\n\
    \n    for currentIndex in \"${!tempArray[@]}\"; do\n        if [ \"$currentIndex\"\
    \ -eq \"$currentIndex\" ]; then\n            count=$(( $count + 1 ))\n       \
    \ else\n            count=$(( $count ))\n        fi\n    done\n\n    for i in\
    \ $(seq \"$count\"); do\n        currentIndex=$(( $currentIndex + 1 ))\n     \
    \   currentIndex=$(( $currentIndex % $count ))\n        sortedArray=(\"${sortedArray[@]}\"\
    \ \"$tempArray[$currentIndex]\")\n    done\n\n    for i in \"${!sortedArray[@]}\"\
    ; do\n        if [ \"$sortedArray[$i]\" -eq 0 ]; then\n            if [ \"$i\"\
    \ -eq \"$i\" ]; then\n                output=\"$output \\\"\\\"\\\"${sortedArray[$i]}\\\
    \"\\\"\\\"\"\n            else\n                output=\"$output \\\"${sortedArray[$i]}\\\
    \"\"\n            fi\n        else\n            if [ \"$i\" -eq \"$i\" ]; then\n\
    \                output=\"$output \\\"${sortedArray[$i]}\\\"\"\n            else\n\
    \                output=\"$output \\\"\\\"\\\"${sortedArray[$i]}\\\"\\\"\\\"\"\
    \n            fi\n        fi\n    done\n\n    echo \"$output\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp5qv1s32g.sh: line 40: [: 1 5 2 3 4[0][0]: integer expression expected

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local arrayList=$(IFS=$'\\n' echo\
    \ \"$array\")\n  local length=\"$#\" #length of array\n  local result #storing\
    \ result\n  for ((i=0;i<$length;i++)); do\n    if [[ $arrayList =~ (^|.* )($i)\
    \ ]]; then\n      local index=$(( $i + 1 ))\n      result+=($(echo $arrayList\
    \ | sed \"s/$i /$index /\"))\n      arrayList=$(echo $arrayList | sed \"s/$index\
    \ */$i /\")\n    fi\n  done\n  echo \"${result[@]}\"\n}\n\ncandidate() {\n   \
    \ sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\"\
    ) = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\"\
    \ ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local item\n  items=($1)\n  for i in \"${!items[@]}\"\
    ; do\n    if [ \"${items[$i]}\" == \"1\" ]; then\n      items[$i]=\"0\"\n    else\n\
    \      items[$i]=\"1\"\n    fi\n  done\n  echo \"${items[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=\"$1\"\n    if ! array=(\"$array\"); then\n\
    \        echo >&2 \"Usage: $(basename \"$0\") [array]\"\n        exit 1\n    fi\n\
    \    for number in \"${array[@]}\"; do\n        if [ \"${number}\" == \"1\" ];\
    \ then \n            echo \"$number\"\n        else\n            echo \"$(( $(echo\
    \ \"$number\" | bc -l ) + 1 ))\"\n        fi\n    done\n}\n\ncandidate() {\n \
    \   sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3\
    \ 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6\
    \ -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS= read -r -a array <<< \"$1\"\n    local\
    \ -a sorted\n    for element in \"${array[@]}\"; do\n        case \"$element\"\
    \ in\n            *)\n                sorted+=(\"$element\")\n               \
    \ ;;\n        esac\n    done\n    sorted=( \"${sorted[@]/#/\\\"${array[0]}\\\"\
    \"/}\" )\n    echo -n \"$(printf '\"%s\" \"%s\" ' \"${sorted[@]}\")\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv2il6pbf.sh: line 41: unexpected EOF while looking for matching
    `"''

    /tmp/tmpv2il6pbf.sh: line 45: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local var\n    local sorted_var\n    local i\n   \
    \ local count_of_ones\n    local dec\n    local dec_string\n    local result_string\n\
    \    local arr\n    arr=( $1 )\n    sorted_var=( )\n    result_string=\"[\"\n\
    \    for (( i = 0; i < ${#arr[@]}; i++ )); do\n        count_of_ones=$(grep -o\
    \ 1 <<< \"${arr[i]}\")\n        dec=$(( $count_of_ones * 10 ))\n        dec_string=$((\
    \ ${dec#0} * 10 ))\n        sorted_var[$i]=\"$dec_string\"\n    done\n    sorted_var=($(sort\
    \ -n <<<\"${sorted_var[*]}\")) # Sort numerically\n    for (( i = 0; i < ${#sorted_var[@]};\
    \ i++ )); do\n        var=${sorted_var[$i]}\n        result_string=$result_string\"\
    '$var'\"\n        if (( i < ${#sorted_var[@]} - 1)); then\n            result_string=$result_string\"\
    \ \"\n        fi\n    done\n    result_string=$result_string\"]\"\n    echo $result_string\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpe237iriw.sh: line 28: * 10 : syntax error: operand expected (error
    token is "* 10 ")

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=' '\n    local -n ar=$1\n    local -n rs=$2\n\
    \n    local res\n    local max\n    local s\n    local p\n    local n\n\n    #\
    \ find max length\n    max=0\n    for s in ${ar[@]}; do\n        n=$(echo \"$s\"\
    \ | wc -c)\n        if [ \"$n\" -gt \"$max\" ]; then\n            max=\"$n\"\n\
    \        fi\n    done\n\n    # rearrange\n    for p in $(seq 0 $((max-1))); do\n\
    \        s=${ar[$p]}\n        n=$(echo \"$s\" | wc -c)\n        for (( i=1; i<=$n;\
    \ i++ )); do\n            rs=$rs'\"'${s:i:1}'\n        done\n    done\n\n    echo\
    \ \"$rs\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp9xj09smc.sh: line 39: unexpected EOF while looking for matching
    `''''

    /tmp/tmp9xj09smc.sh: line 63: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=' ' arr=( $1 )\n    local -n arrSorted\n\
    \    arrSorted=( ${arr[@]} ); echo \"${arrSorted[@]}\"\n    local -a arrOut=()\n\
    \    local -i cnt\n    cnt=0\n    for i in ${arrSorted[@]}; do\n        local\
    \ j\n        for j in $(seq 0 $((${#arrSorted[@]} -1))); do\n            [[ \"\
    $i\" = \"$arrSorted[$j]\" ]] && break\n        done\n        if [ \"$j\" != \"\
    $((${#arrSorted[@]} -1))\" ]; then\n            arrOut[$cnt]=\"$i\"\n        \
    \    cnt=$(( $cnt + 1 ))\n        fi\n    done\n    arrOut[$cnt]=\"$i\"\n    echo\
    \ \"${arrOut[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp2tsff5qh.sh: line 17: warning: arrSorted: removing nameref attribute

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local tmp\n\n    arr=\"\"\n\
    \n    for element in \"${array}\"; do\n        if [[ $element == +([[:digit:]])\
    \ ]]; then\n            arr=\"$arr ${element}\"\n        else\n            arr=\"\
    $arr $element\"\n        fi\n    done\n\n    IFS=' ' read -r -a array <<< \"$arr\"\
    \n\n    local n=0\n    for i in \"${array[@]}\"; do\n        let \"n++\"\n   \
    \     case \"$n\" in\n            1)  echo \"$i\"\n                    tmp=\"\
    $i\"\n                    ;;\n            2)  echo \"${i/$tmp/10}\"\n        \
    \            tmp=\"$i/$tmp/10\"\n                    ;;\n            *)  echo\
    \ \"${i/$tmp/10}\"\n                    tmp=\"$i/$tmp/10\"\n                 \
    \   ;;\n        esac\n    done\n\n    IFS=' '\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=$1\n  local output\n  local output2\n  local\
    \ num_ones=0\n  local num_zeros=0\n  local decimal=0\n  local decimal2\n\n  for\
    \ idx in ${#array[@]}; do\n    local el=${array[idx]}\n    local el2\n    if [[\
    \ ${el} =~ ^-?[0-9]+$ ]]; then\n      decimal=$(echo \"${el}\" | awk '{print ($1\
    \ * 10^($2 - 1)) + ($2 * 10^($3 - 1))}')\n      decimal2=$(echo \"${el}\" | awk\
    \ '{print ($1 * 10^($2 - 1)) - ($2 * 10^($3 - 1))}')\n      if [[ ${decimal2}\
    \ > ${decimal} ]]; then\n        decimal2=$decimal\n      fi\n      num_ones=$((${num_ones}\
    \ + ${decimal2}))\n    elif [[ ${el} =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n      decimal=$(echo\
    \ \"${el}\" | awk '{print ($1 * 10^($2 - 1)) + ($2 * 10^($3 - 1))}')\n      decimal2=$(echo\
    \ \"${el}\" | awk '{print ($1 * 10^($2 - 1)) + ($2 * 10^($3 - 1))}')\n      if\
    \ [[ ${decimal2} > ${decimal} ]]; then\n        decimal2=$decimal\n      fi\n\
    \      num_ones=$((${num_ones} + ${decimal2}))\n    elif [[ ${el} =~ ^-?[0-9]+\\\
    .[0-9]+\\.[0-9]+$ ]]; then\n      decimal=$(echo \"${el}\" | awk '{print ($1 *\
    \ 10^($2 - 1)) + ($2 * 10^($3 - 1)) + ($3 * 10^($4 - 1))}')\n      decimal2=$(echo\
    \ \"${el}\" | awk '{print ($1 * 10^($2 - 1)) + ($2 * 10^($3 - 1)) + ($3 * 10^($4\
    \ - 1))}')\n      if [[ ${decimal2} > ${decimal} ]]; then\n        decimal2=$decimal\n\
    \      fi\n      num_ones=$((${num_ones} + ${decimal2}))\n    elif [[ ${el} =~\
    \ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n      decimal=$(echo \"${el}\"\
    \ | awk '{print ($1 * 10^($2 - 1)) + ($2 * 10^($3 - 1)) + ($3 * 10^($4 - 1)) +\
    \ ($4 * 10^($5 - 1))}')\n      decimal2=$(echo \"${el}\" | awk '{print ($1 * 10^($2\
    \ - 1)) + ($2 * 10^($3 - 1)\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpc0eqnl37.sh: line 49: unexpected EOF while looking for matching
    `''''

    /tmp/tmpc0eqnl37.sh: line 69: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local -n size=${array##*,}\n\
    \    local -n res=()\n    local -i cnt=0\n    local -i len=${#array}\n    local\
    \ -i i\n    local bin=\"\"\n    local digit=\"\"\n\n    for ((i=0; i<len; ++i));\
    \ do\n        digit=${array:$i:1}\n        bin=${digit:0:1}\n        if [ \"${digit:0:1}\"\
    \ == \"1\" ]; then\n            ((cnt+=1))\n        fi\n\n        if [ \"${bin}\"\
    \ != \"$bin\" ]; then\n            if [ \"$cnt\" -gt 0 ]; then\n             \
    \   res=(\"${res[@]/$cnt/}\")\n                cnt=0\n            fi\n       \
    \ fi\n\n        if [ \"$cnt\" -gt 0 ]; then\n            res=(\"${res[@]/$cnt/}\"\
    )\n            cnt=0\n        fi\n\n        res=(\"${res[@]/$digit/}\")\n    done\n\
    \n    printf '%s\\n' \"${res[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmptgh2t2tc.sh: line 16: local: `1 5 2 3 4'': invalid variable name
    for name reference

    /tmp/tmptgh2t2tc.sh: line 17: local: res: reference variable cannot be an array

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n    local input_arr=(${input//[[:space:]]/\
    \ })\n    local num_ones\n    local i\n    local out\n\n    for (( i=0; i<${#input_arr[@]};\
    \ i++ )); do\n        if (( ${input_arr[i]} == 1 )); then\n            num_ones++\n\
    \        else\n            if (( num_ones > 0 )); then\n                if ((\
    \ num_ones != 1 )); then\n                    out+=\"\\\"\"\n                fi\n\
    \                out+=\"${input_arr[i]}\"\n                (( num_ones-- ))\n\
    \            else\n                out+=\"\\\"${input_arr[i]}\"\n            fi\n\
    \        fi\n    done\n    echo ${out}\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpskagvt4e.sh: line 23: num_ones++: command not found

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"$1\" | tr -d '\\n' | sort -n | sed 's/^/\"\
    /;s/.$//' | sed 's/.$//'\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Use -n to sort numerically, so that \"5\" < \"9\"\n\
    \  sort -n \"$1\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sort: cannot read: ''1 5 2 3 4'': No such file or directory

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n\n    # To keep the number of\
    \ operations low, we will use awk:\n    # - awk has O(n) complexity for sorting\
    \ (linear time for n items)\n    # - awk has O(1) complexity for string manipulation\
    \ (constant time for string length)\n    # - awk has O(logn) complexity for string\
    \ concatenation (constant time for concatenation length)\n    # - awk has O(1)\
    \ complexity for comparisons (constant time for comparisons)\n    # - awk has\
    \ O(n) complexity for string replacement (linear time for n replacements)\n  \
    \  # - awk has O(1) complexity for substring (linear time for first position occurrence)\n\
    \n    # Sort array and put sorted elements to string\n    local sorted=\"$(awk\
    \ '{for(i=1;i<=NF;i++){if($i==\"1\")print;else print $i}}' <<< \"$array\")\"\n\
    \n    # Find index of largest sequence of 0s starting at 0\n    local index=$(echo\
    \ \"$sorted\" | grep -o '0*' | sort -n | tail -1)\n\n    # Add quote characters\
    \ to start and end of string for each of the sorted elements\n    sorted=\"$(echo\
    \ \"$sorted\" | sed \"s/^/$array/\" | sed \"s/$index/$array/\" <<< \"$sorted\"\
    )\"\n\n    # Remove quotes around sorted elements\n    echo \"${sorted//\\\"}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: 'sed: -e expression #1, char 0: no previous regular expression

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    # Extract integer from string\n    # >>> $(extract_int\
    \ \"$1\")\n    # [1, '5', '2', '3', '4']\n    local input=$(extract_int \"$1\"\
    )\n\n    # Initialize result\n    # >>> $(get_result \"$input\")\n    # ['\"1\"\
    ', '\"5\"', '\"2\"', '\"3\"', '\"4\"']\n    local result=$(get_result \"$input\"\
    )\n\n    # Sort elements\n    # >>> $(sort_array \"$input\")\n    # ['\"0\"',\
    \ '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n    local tmp=$(for item in $input; do\n\
    \        local count=$(extract_int \"$item\")\n        local dec=$(printf \"%d\"\
    \ \"$count\" | bc)\n        local cmp=$(printf \"$dec\" | sort -n | tail -n 1)\n\
    \        if [ \"$cmp\" = \"0\" ]; then\n            echo \"$item\"\n        else\n\
    \            echo \"$item\"\n        fi\n    done)\n\n    # Append result to input\n\
    \    # >>> $(append_result \"$input\" \"$result\")\n    # ['\"1\"', '\"5\"', '\"\
    2\"', '\"3\"', '\"4\"']\n    local tmp2=\"$input$result\"\n\n    # Remove trailing\
    \ characters\n    # >>> $(get_result \"5 0 4 2 3 1\")\n    # ['\"0\"', '\"1\"\
    ', '\"2\"', '\"3\"', '\"4\"', '\"5\"']\n    local result2=$(get_result \"5 0 4\
    \ 2 3 1\")\n\n    # Merge result\n    # >>> $(append_result \"$input\" \"$result2\"\
    )\n    # ['\"1\"', '\"2\"', '\"3\"', '\"4\"', '\"5\"']\n    local final=$(for\
    \ item in $tmp2; do\n        local count=$(extract_int \"$item\")\n        local\
    \ dec=$(printf \"%d\" \"$count\" | bc)\n        local cmp=$(printf \"$dec\" |\
    \ sort -n | tail -n 1)\n        if [ \"$cmp\" = \"0\" ]; then\n            echo\
    \ \"$item\"\n        else\n            echo \"$item\"\n        fi\n    done)\n\
    \n    echo \"$final\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpndincxw8.sh: line 18: extract_int: command not found

    /tmp/tmpndincxw8.sh: line 23: get_result: command not found

    /tmp/tmpndincxw8.sh: line 47: get_result: command not found

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local line=$1\n    local numOdd=\"$( echo $line |\
    \ wc -l )\"\n    local numEven=\"$( echo $line | wc -l )\"\n    echo \"$( echo\
    \ $line | sed 's/ /\",\"/g' )\"\n\n    # Add quotes and backticks for odd elements\n\
    \    while [ $numOdd -ge 1 ]\n    do\n        local x=\"$( echo $line | sed -e\
    \ 's/ /\",\"/g' -e 's/\\([^)]*\\)/\"\\1\"/g' )\" # add quotes and backticks to\
    \ odd elements\n        line=\"$( echo $line | sed -e \"s/$x/$x\\`\"; echo $line\
    \ )\"\n        numOdd=\"$( echo $line | wc -l )\"\n    done\n\n    # Add quotes\
    \ and backticks for even elements\n    for (( i=2; i <= $numEven; i++ )); do\n\
    \        local x=\"$( echo $line | sed -e 's/ /\",\"/g' -e 's/\\([^)]*\\)/\"\\\
    1\"/g' )\" # add quotes and backticks to even elements\n        line=\"$( echo\
    \ $line | sed -e \"s/$x/$x\\`\"; echo $line )\"\n    done\n\n    echo \"$line\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=32 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=10 encoding='utf-8'>
  timestamp: 1660056502
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local i j\n    local array\n    local sorted\n   \
    \ array=$1\n    sorted=\"\"\n\n    while [ ${#array} -gt 0 ]; do\n        i=${#array}\n\
    \        while [ \"$i\" -gt 0 ]; do\n            # Check if array element has\
    \ '1' in it\n            if [ \"${array:$i:1}\" == \"1\" ] ; then\n          \
    \      # If number of ones in binary representation is greater,\n            \
    \    # sort based on binary value\n                if [ \"$j\" -ne 0 ] ; then\n\
    \                    if [ \"$i\" -gt \"$j\" ] ; then\n                       \
    \ sorted+=\"$i\"\n                        array=${array:0:$i}\n              \
    \          i=$(( $i - 1 ))\n                    else\n                       \
    \ sorted+=\"$j\"\n                        array=${array:$i:$j}\n             \
    \           i=$(( $i - 1 ))\n                        j=$(( $j - 1 ))\n       \
    \             fi\n                else\n                    sorted+=\"$i\"\n \
    \                   array=${array:0:$i}\n                    i=$(( $i - 1 ))\n\
    \                fi\n            fi\n        done\n        j=$i\n    done\n\n\
    \    echo \"${sorted}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=17 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=27 encoding='utf-8'>
  timestamp: 1660056502
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local sorted=()\n    local\
    \ i=0 j=0\n    local len=${#array[@]}\n    local zeros=0\n\n    while [[ $i -lt\
    \ $len ]]; do\n        if [[ ${array[$i]} = \"0\" ]]; then\n            zeros+=1\
    \ \n        fi\n        i=$((i+1))\n    done\n\n    while [[ $j -lt $len ]]; do\n\
    \        if [[ ${array[$j]} = \"0\" ]]; then\n            zeros+=1 \n        fi\n\
    \        j=$((j+1))\n    done\n\n    while [[ $i -gt $j ]]; do\n        if [[\
    \ ${array[$i]} = \"0\" ]]; then\n            zeros+=1 \n        fi\n        i=$((i-1))\n\
    \    done\n\n    while [[ $j -gt $i ]]; do\n        if [[ ${array[$j]} = \"0\"\
    \ ]]; then\n            zeros+=1 \n        fi\n        j=$((j-1))\n    done\n\n\
    \    if [[ ${#array[@]} -gt 1 ]]; then\n        sorted=($(printf \"%s\\n\" \"\
    ${array[@]}\" | sort -n -k 2| sed -e 's/[^\"]*\"//g'))\n        sorted=($(printf\
    \ \"%s\\n\" \"${sorted[@]}\" | sort -n -k 1| sed -e 's/^\"//g' -e 's/\"$//g'))\n\
    \    else\n        sorted=($(printf \"%s\\n\" \"${array[@]}\" | sort -n -k 1|\
    \ sed -e 's/^\"//g' -e 's/\"$//g'))\n    fi\n\n    echo \"${sorted[@]}\"\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local _a _b _c;\n\n    _a=$1;\n    for _b in $(echo\
    \ \"$1\" | sed 's/^/[/');\n    do\n        _c=$(echo $_a | $sed_sort | sed \"\
    s/\\[${_b}\\]${_c}//g\");\n    done\n\n    echo \"$_c\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=\"$1\"\n  local len=\"${#arr[@]}\"\n\n  #\
    \ Initialize output array with input array size\n  local -i result=\"-${len}\"\
    \n\n  # Sort array elements according to number of ones in their binary representation\n\
    \  local i\n  for i in $(seq 0 \"${len}\"); do\n    local -n temp=\"$((result+i))\"\
    \n    if [[ ${arr[i]} -eq 1 ]]; then\n      temp+=(\"$arr[i]\")\n    fi\n  done\n\
    \n  # Sort array elements according to decimal value\n  for i in $(seq ${len}\
    \ -1 0); do\n    local -n temp=\"$((result+i))\"\n    temp+=(\"$arr[i]\")\n  done\n\
    \n  # Return sorted array\n  printf \"%s\\n\" \"${temp[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgc8l9kws.sh: line 24: local: `-1'': invalid variable name for name
    reference

    /tmp/tmpgc8l9kws.sh: line 25: [[: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmpgc8l9kws.sh: line 24: local: `0'': invalid variable name for name reference

    /tmp/tmpgc8l9kws.sh: line 32: local: `0'': invalid variable name for name reference

    /tmp/tmpgc8l9kws.sh: line 32: local: `-1'': invalid variable name for name reference

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo $(sort_array \"$1\" | sed 's/ /\",\"/g' | sed\
    \ 's/^/\"/' | sed 's/$/\"/' | sort -n)\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=36 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=26 encoding='utf-8'>
  timestamp: 1660056502
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array result\n  array=\"$1\"\n  result=\"\"\n\
    \  for element in $array; do\n    if [[ $element == \"-\" ]]; then\n      continue\n\
    \    elif [[ $element == *[![:digit:]]* ]]; then\n      result=\"${result} ${element}\"\
    \n    else\n      result=\"${result} \\\"${element}\\\"\" \n    fi\n  done\n \
    \ echo \"${result}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=$1\n\n    local sorted\n    local ones\n\
    \n    IFS=' ' read -r -a arr <<<\"$arr\"\n\n    ones=${arr[@]:0:${#arr[@]}}\n\
    \    echo \"${ones}\" | tr ' ' '0' | sort -n | tr ' ' ',' | sed 's/,$//'\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"${1//-/ }\"\n    echo \"${1// /-}\"\n    echo\
    \ \"${1/ / -}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local sorted_array=$(\n  \
    \      echo $array\n        echo \"${array[@]:0}\"\n        echo \"${array[@]:0:1}\"\
    \n        echo \"${array[@]:0:2}\"\n        echo \"${array[@]:0:3}\"\n       \
    \ echo \"${array[@]:0:4}\"\n        echo \"${array[@]:0:5}\"\n        echo \"\
    ${array[@]:0:6}\"\n        echo \"${array[@]:0:7}\"\n        echo \"${array[@]:0:8}\"\
    \n        echo \"${array[@]:0:9}\"\n        echo \"${array[@]:0:10}\"\n      \
    \  echo \"${array[@]:0:11}\"\n        echo \"${array[@]:0:12}\"\n        echo\
    \ \"${array[@]:0:13}\"\n        echo \"${array[@]:0:14}\"\n        echo \"${array[@]:0:15}\"\
    \n        echo \"${array[@]:0:16}\"\n        echo \"${array[@]:0:17}\"\n     \
    \   echo \"${array[@]:0:18}\"\n        echo \"${array[@]:0:19}\"\n        echo\
    \ \"${array[@]:0:20}\"\n        echo \"${array[@]:0:21}\"\n        echo \"${array[@]:0:22}\"\
    \n        echo \"${array[@]:0:23}\"\n        echo \"${array[@]:0:24}\"\n     \
    \   echo \"${array[@]:0:25}\"\n        echo \"${array[@]:0:26}\"\n        echo\
    \ \"${array[@]:0:27}\"\n        echo \"${array[@]:0:28}\"\n        echo \"${array[@]:0:29}\"\
    \n        echo \"${array[@]:0:30}\"\n        echo \"${array[@]:0:31}\"\n     \
    \   echo \"${array[@]:0:32}\"\n        echo \"${array[@]:0:33}\"\n        echo\
    \ \"${array[@]:0:34}\"\n        echo \"${array[@]:0:35}\"\n        echo \"${array[@]:0:36}\"\
    \n        echo \"${array[@]:0:37}\"\n        echo \"${array[@]:0:38}\"\n     \
    \   echo \"${array[@]:0:39}\"\n        echo \"${array[@]:0:40}\"\n        echo\
    \ \"${array[@]:0:41}\"\n        echo \"${array[@]:0:42}\"\n        echo \"${array[@]:0:43}\"\
    \n        echo \"${array[@]:0:44}\"\n        echo \"${array[@]:0:45}\"\n     \
    \   echo \"${array[@]:0:46}\"\n        echo \"${array[@]:0:47}\"\n        echo\
    \ \"${array[@]:0:48}\"\n        echo \"${array[@]:0:\n}\n\ncandidate() {\n   \
    \ sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\"\
    ) = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\"\
    \ ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjaq6ojes.sh: line 83: unexpected EOF while looking for matching
    `"''

    /tmp/tmpjaq6ojes.sh: line 87: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Sort $1 according to number of 1s in their binary\
    \ representation in ascending order.\n  # If there are two or more 1s in an element,\
    \ reverse the order of those elements.\n  # The output of this Kata is in double\
    \ quotes.\n  # The expected time complexity of this Kata is O(nlogn).\n  # The\
    \ memory limit of this Kata is 256 MB.\n  local input=\"$1\"\n  local num_ones=\"\
    \"\n  local arr=()\n  for str in $input; do\n    str=$(echo \"$str\" | awk '{print\
    \ ($1 == \"1\" ? 1 : -1) }')\n    arr+=(\"$str\")\n  done\n  num_ones=\"${arr[*]}\"\
    \n  sort -g <<<\"$num_ones\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=\"$1\"\n    local -a ret\n    local -a arr_tmp\n\
    \    local -i tmp_i\n    local j\n    local len=${#arr[*]}\n    local tmp\n\n\
    \    arr_tmp=($(echo \"${arr[@]}\" | sed 's/ /\" \"/g'))\n    local i\n    for\
    \ (( i = 0; i < len; i++ )); do\n        tmp_i=\"${arr_tmp[i]}\"\n        tmp=${tmp_i}\n\
    \        # replace all non-numeric chars\n        tmp=\"${tmp//[^0-9]}\"\n   \
    \     # check if tmp is non-zero\n        if [[ \"$tmp\" == \"\" ]]; then\n  \
    \          ret[i]=\"\"\n            continue\n        fi\n        # check if tmp\
    \ is negative and has one char\n        if [[ \"$tmp\" == \"-\" ]]; then \n  \
    \          if [[ \"${tmp:(-1)}\" == \"1\" ]]; then\n                ret[i]=\"\
    -\"\n            else\n                ret[i]=\"+\"\n            fi\n        \
    \    continue\n        fi\n        arr_tmp[i]=$(printf \"%b\" \"${tmp}\")\n  \
    \      local tmp\n    done\n\n    echo \"${ret[@]}\"\n}\n\ncandidate() {\n   \
    \ sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\"\
    ) = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\"\
    \ ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0kej2sjz.sh: line 26: 1": syntax error: invalid arithmetic operator
    (error token is """)

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -a arr\n  arr=( $(echo $1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/\
    \ /\" \"/g;s/^/\"/;s/$/\"/g') )\n  printf '%s\\n' \"${arr[@]}\" | tr ' ' '0' |\
    \ sort -nk 2\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"${@:2}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local temp=()\n  for var in \"${@}\"\n  do\n      local\
    \ pos=$( echo $var | wc -l )\n      (( pos == 1 )) || continue\n      local tmp=${var/#*/}\n\
    \      tmp=${tmp/*/}\n      local dec=${tmp%.*}\n      (( dec > 0 )) && temp+=($tmp)\n\
    \  done\n  printf \"'%s'\\n\"  \"${temp[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -n arr=$1 i\n    local -n val\n    local -a\
    \ tmp\n    local -a sorted_vals\n\n    vals=$( echo \"${arr[*]}\" | sed -e 's/^\
    \ *//' -e 's/ *$//' )\n    sorted_vals=$( printf \"%s\\n\" \"${vals[@]}\" | sort\
    \ -n | tr '\\n' ' ' )\n    tmp=()\n    for (( i=0; i < ${#sorted_vals[@]}; i++\
    \ )); do\n        tmp+=( ${sorted_vals[$i]} $i )\n    done\n\n    arr=( \"${sorted_vals[@]}\"\
    \ )\n    for (( i=0; i < ${#arr[@]}; i++ )); do\n        arr[i]=\"${tmp[$i]}\"\
    \n    done\n    printf '%s\\n' \"${arr[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=7 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=3 encoding='utf-8'>
  timestamp: 1660056502
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local IFS=$1\n  local arr=($2)\n  arr=($(IFS=$'\\n'\
    \ sort<<<\"${arr[*]}\"))\n  arr=(${arr[*]})\n  echo \"${arr[*]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=( \"$1\" )\n    local -a s\n    local i=0\n\
    \    local -a sorted=()\n    while [[ $i -lt ${#arr[@]} ]]; do\n        (( s[i++]=\"\
    ${#arr[@]}\" ))\n    done\n    for (( i=0; i<${#s[@]}; i++ )); do\n        sorted[${s[i]}]=\"\
    ${arr[i]}\"\n    done\n    for i in ${!sorted[@]}; do\n        arr[i]=${sorted[$i]}\n\
    \    done\n    printf \"[ \\\"%s\\\" ]\" \"${arr[@]}\"\n}\n\ncandidate() {\n \
    \   sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3\
    \ 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6\
    \ -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"${1}\"\n\n    local -n temp=\"$(mktemp)\"\
    \n\n    local -n count=\"$(mktemp)\"\n\n    local -n dec=\"$(mktemp)\"\n\n   \
    \ local -n key=\"$(mktemp)\"\n\n    local -n array2=\"$(mktemp)\"\n\n    # sort\
    \ into temp\n    while IFS= read -r line; do\n        ((++count[$line]))\n   \
    \ done < <(printf '%s\\n' \"${array}\" | \\\n        awk '{ for (i = 2; i <= NF;\
    \ ++i) print i, $i}' | \\\n        sort -k 2 | \\\n        awk -F, 'BEGIN {prev\
    \ = 0; curr = prev; prev2 = prev; prev3 = prev; prev4 = prev; prev5 = prev;}\n\
    \                 {curr = curr + $2;\n                  if (curr > prev) {printf\
    \ \"%s\", \"${array2}\"; curr2 = curr; curr3 = curr; curr4 = curr; curr5 = curr;};\n\
    \                  if (curr > prev2) {printf \"%s\", \"${array2}\"; curr2 = curr;\
    \ curr3 = curr; curr4 = curr; curr5 = curr;};\n                  if (curr > prev3)\
    \ {printf \"%s\", \"${array2}\"; curr2 = curr; curr3 = curr; curr4 = curr; curr5\
    \ = curr;};\n                  if (curr > prev4) {printf \"%s\", \"${array2}\"\
    ; curr2 = curr; curr3 = curr; curr4 = curr; curr5 = curr;};\n                \
    \  if (curr > prev5) {printf \"%s\", \"${array2}\"; curr2 = curr; curr3 = curr;\
    \ curr4 = curr; curr5 = curr;};\n                  printf \"%s\", \"${array}\"\
    };\n                  prev = $2;\n                  prev2 = prev;\n          \
    \        prev3 = prev2;\n                  prev4 = prev3;\n                  prev5\
    \ = prev4;\n                  next;\n                 }' > \"${temp}\")\n\n  \
    \  # then sort temp\n    while IFS= read -r line; do\n        ((++dec[$line]))\n\
    \    done < <(printf '%s\\n' \"${temp}\" | sort -k 1 | \\\n        awk 'BEGIN\
    \ {dec[prev] = 0;}\n                 {dec[curr]++;}\n                 {prev =\
    \ $1; curr = $1;\n                  next;\n                 }' > \"${key}\")\n\
    \n    # then sort key\n    while IFS= read -r line; do\n        ((++array2[$line]))\n\
    \    done < <(printf '%s\\n' \"${key}\" | sort -k 1 -n | \\\n        awk 'BEGIN\
    \ {dec[prev\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpudvluzjb.sh: line 63: unexpected EOF while looking for matching
    `''''

    /tmp/tmpudvluzjb.sh: line 83: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=$1\n    local result\n    local len=${#input}\n\
    \    for ((i = 0; i <= len; i++)); do\n        if [[ $((${input:i:1} == \"1\"\
    )) = $((${#result})) ]]; then\n            result+=(${input:$i:$((${#result})-1)})\n\
    \        fi\n    done\n    echo $result\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp48ga1unh.sh: line 19: == 1: syntax error: operand expected (error
    token is "== 1")

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # For each element in the array, check if it contains\
    \ one\n  mapfile -t ary<<<\"$1\"\n  sort -t ' ' -n -k 2 <(\n    for elem in \"\
    ${ary[@]}\"\n    do\n      [[ $(echo \"$elem\" | grep -q 1) ]]\n    done\n  )\
    \ <(\n    # Go through every pair of the array and create a string with the element\n\
    \    # and the index\n    for idx in \"${!ary[@]}\"\n    do\n      printf \"%s\
    \ %s\\n\" \"$elem\" \"$idx\"\n    done\n  )\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=(\"${1:-}\")\n    array=($(echo \"${array[@]}\"\
    \ | sed 's/ /\" \" \"/g'))\n    number=${#array[@]}\n    for ((i=0;i<number;i++));\n\
    \    do\n        binary=$(echo ${array[i]} | awk '{print toupper($0)}')\n    \
    \    ones=$(echo ${binary} | awk '{print length($0)}')\n        if (( ${ones}\
    \ > 0 ));\n        then\n            echo \"${array[i]}\"\n        fi\n    done\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local i=0\n  local array_size=${#array[@]}\n\
    \  local array_sorted[${array_size}]\n\n  while ((i<array_size));do\n    array_sorted[$i]=$(echo\
    \ \"${array[$i]}\" | grep -o '[01]\\?[[:digit:]]' | sort -nr -k 2 | head -1)\n\
    \    i=$(($i+1))\n  done\n\n  echo \"${array_sorted[@]}\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array\n  local i\n  local result\n  local one\n\
    \n  array=\"$1\"\n\n  result=$(IFS=\" \"; echo \"$array\" | sed 's/ /\\\" \\\"\
    /g' | sort -n | sed 's/ \\\"//g' | tr '\\n' ' ')\n  array=$(echo \"$result\")\n\
    \n  for ((i = 0; i < ${#array[@]}; i++)); do\n    one=$(echo \"${array[$i]}\"\
    \ | tr '0' '1')\n    if [ \"$one\" = \"1\" ]; then\n      one=\"\\\"$one\\\"\"\
    \n    fi\n    array[$i]=\"$one\"\n  done\n\n  echo \"${array[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -n array=\"$1\"\n    local -a result\n\n   \
    \ array=${array//\" /}\n    array=${array// /}\n    array=${array//-/ }\n\n  \
    \  mapfile -t array < <(printf '%s\\n' \"${array[@]}\")\n    local -a tmp\n  \
    \  local count=0\n    local i=0\n    local tmp\n    while IFS= read -r tmp; do\n\
    \        ((count++))\n    done < <(printf '%s\\n' \"${array[@]}\" | sort -n |\
    \ sed 's/\\([0-9]*\\)1\\([0-9]*\\)/\\2 \\1/')\n    while ((i < count)); do\n \
    \       if ((array[$i] == \"0\")); then\n            ((tmp=array[$((i+1))]))\n\
    \            ((array[++i]=\"1\"))\n            ((array[++i]=\"0\"))\n        \
    \    ((array[++i]=$tmp))\n        fi\n        ((i++))\n    done\n    for ((i=0;\
    \ i<count; i++)); do\n        result+=(${array[$i]})\n    done\n    echo -n \"\
    [\"\n    for ((i=0; i<count; i++)); do\n        echo -n \"${result[$i]}\"\n  \
    \      if (( i < count-1)); then\n            echo -n \",\"\n        fi\n    done\n\
    \    echo -n \"]\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp42zlzb_u.sh: line 65: unexpected EOF while looking for matching
    `"''

    /tmp/tmp42zlzb_u.sh: line 69: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Parse arguments\n  local elements=$1\n  local result=()\n\
    \  local index=0\n\n  # Parse each element and count \"1\"s\n  for element in\
    \ $elements; do\n    while [[ $element =~ ^- ]] && [[ $index -lt 4 ]]; do\n  \
    \    index=$((index+1))\n      element=${element:0:$((${#element}-1))}\n    done\n\
    \    if [[ $index -lt 4 ]]; then\n      element=${element:0:1}\n    fi\n    element=${element:1}\n\
    \    if [[ $element == -* ]]; then\n      element=${element:2}\n    fi\n    element=${element:-$((${#element}-1))}\n\
    \    element=${element:-1}\n    if [[ -z \"$element\" ]]; then\n      element=$(echo\
    \ $element | cut -c1-2)\n      if [[ -z \"$element\" ]]; then\n        element=$(echo\
    \ $element | cut -c1-1)\n      fi\n    fi\n    elements=${elements#$element}\n\
    \    result+=(\\\"$element\\\")\n    index=$((index+1))\n  done\n\n  # Sort by\
    \ descending number of ones\n  local max\n  for element in ${result[@]}; do\n\
    \    while [[ $element =~ ^- ]] && [[ $index -lt 4 ]]; do\n      index=$((index+1))\n\
    \      element=${element:0:$((${#element}-1))}\n    done\n    if [[ $index -lt\
    \ 4 ]]; then\n      element=${element:0:1}\n    fi\n    element=${element:1}\n\
    \    if [[ $element == -* ]]; then\n      element=${element:2}\n    fi\n    element=${element:-$((${#element}-1))}\n\
    \    element=${element:-1}\n    if [[ -z \"$element\" ]]; then\n      element=$(echo\
    \ $element | cut -c1-2)\n      if [[ -z \"$element\" ]]; then\n        element=$(echo\
    \ $element | cut -c1-1)\n      fi\n    fi\n    if [[ \"$element\" -gt \"$max\"\
    \ ]]; then\n      max=$element\n    fi\n  done\n\n  # Sort based on decimal value\n\
    \  max=$(echo $max | cut -c1-3)\n  result=(\\\"$max\\\"$(echo $result | sort -n\
    \ -k))\n\n  # Reverse result\n  local reversed\n  reversed=''\n  local counter\n\
    \  for element in ${result[@]}; do\n    while [[ $element =~ ^- ]] && [[ $counter\
    \ -lt 4 ]]; do\n      counter=$((\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn5bkw1pt.sh: line 83: unexpected EOF while looking for matching
    `)''

    /tmp/tmpn5bkw1pt.sh: line 103: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=\"$1\"\n    mapfile -t array < <(echo \"$array\"\
    \ | sed -e 's/ /\" \"/' -e 's/^/\"/' -e 's/$/\"/' -e 's/ /\",\"/')\n    mapfile\
    \ -t sorted < <(sort <<<\"${array[@]}\")\n    IFS=$'\\n'\n    echo \"${sorted[*]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local sorted_array=$( tr ' ' '\\n' <<< \"$1\" | sort\
    \ -n | tr '\\n' ' ' )\n    eval $(echo \"$sorted_array\")\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp2buyex14.sh: line 16: 1: command not found

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local output\n    output=$(echo\
    \ \"${array}\" | tr \" \" \"\\n\" | sort -r -)\n    echo -n \"${output// /\\\"\
    }\" | tr \" \" \"\\n\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local output=''\n\n  # Count all\
    \ ones\n  local -a counter\n  for value in \"${array[@]}\"; do\n    (( counter[$value]++\
    \ ))\n  done\n\n  # Sort by number of ones\n  for value in \"${!counter[@]}\"\
    ; do\n    array[$value]=${counter[$value]} ${value}\n  done\n\n  # Sort by decimal\
    \ value if values are same\n  local i\n  for ((i = 0; i < ${#counter[@]}; i++));\
    \ do\n    local j\n    for ((j = 1; j < ${#counter[@]}; j++)); do\n      if [\
    \ ${counter[$j]} -gt ${counter[$((j-1))]} ]; then\n        local temp=${array[$i]}\n\
    \        array[$i]=${array[$((j-1))]}\n        array[$((j-1))]=$temp\n      fi\n\
    \    done\n  done\n\n  # Remove all non-positive values\n  local arraylen=${#array[@]}\n\
    \  for ((i = 0; i < arraylen; i++)); do\n    if [[ ${array[$i]} -ge 0 ]]; then\n\
    \      output+=\"\\\"${array[$i]}\\\"\"\n      unset \"array[$i]\"\n    fi\n \
    \ done\n  echo \"$output\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn_obbt12.sh: line 21: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local _sorted=($1)\n  local _decimal=0\n  local _prev=-100\n\
    \  local _pos=0\n  local _flag=0\n  local _i=-1\n\n  for (( _i=$((${#_sorted[@]}\
    \ - 1)); _i >= 0; _i-- )); do\n    local _val=${_sorted[_i]}\n    local _val2=0\n\
    \    if [[ -z ${_prev} ]]; then\n      _prev=\"${_val}\"\n    else\n      _flag=1\n\
    \      if [[ \"${_val}\" -gt \"${_prev}\" ]]; then\n        _sorted[_i]=\"${_prev}\"\
    \n      fi\n      _prev=\"${_val}\"\n    fi\n  done\n\n  _flag=1\n  for (( _i=$((${#_sorted[@]}\
    \ - 1)); _i >= 0; _i-- )); do\n    local _val=${_sorted[_i]}\n    local _val2=0\n\
    \    if [[ -z ${_prev} ]]; then\n      _prev=\"${_val}\"\n    else\n      _flag=1\n\
    \      if [[ \"${_val}\" -gt \"${_prev}\" ]]; then\n        _sorted[_i]=\"${_prev}\"\
    \n      fi\n      _prev=\"${_val}\"\n    fi\n  done\n  printf '%s\\n' \"${_sorted[@]}\"\
    \n\n  local _dec=0\n  for (( _i=$((${#_sorted[@]} - 1)); _i >= 0; _i-- )); do\n\
    \    local _val=${_sorted[_i]}\n    local _val2=0\n    if [[ -z ${_prev} ]]; then\n\
    \      _prev=\"${_val}\"\n    else\n      _flag=1\n      if [[ \"${_val}\" -gt\
    \ \"${_prev}\" ]]; then\n        _sorted[_i]=\"${_prev}\"\n      fi\n      _prev=\"\
    ${_val}\"\n    fi\n  done\n  printf '%s\\n' \"${_sorted[@]}\"\n  printf '%s\\\
    n' \"${_sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local sorted_list=$1\n\n    declare -A counter\n \
    \   declare -A order\n\n    while read -r line; do\n        local value=$(echo\
    \ $line | cut -d ' ' -f 1)\n        local sign=$(echo $line | cut -d ' ' -f 2)\n\
    \        local digit=$(echo $line | cut -d ' ' -f 3)\n        local digit2=$(echo\
    \ $line | cut -d ' ' -f 4)\n\n        counter[$digit]=$(expr $counter[$digit]\
    \ + 1)\n\n        if [[ $sign == - ]]; then\n            order[$digit]=$value\n\
    \        else\n            order[$digit2]=$value\n        fi\n    done <<< \"\
    $sorted_list\"\n\n    for key in $(seq 0 9); do\n        counter[$key]=$((counter[$key]))\n\
    \    done\n\n    declare -A sorted\n    for key in $(seq 0 9); do\n        if\
    \ [[ ${counter[$key]} -gt 1 ]]; then\n            sorted[\"$key\"]=${order[$key]}\n\
    \            counter[$key]=0\n        fi\n    done\n\n    local i=0\n    while\
    \ [[ \"$i\" -lt 10 ]]; do\n        sorted[\"$i\"]=${sorted[\"$i\"]}\n        i=$((i\
    \ + 1))\n    done\n\n    local newlist=''\n    for key in $(seq 0 9); do\n   \
    \     newlist=${newlist}${sorted[\"$key\"]}\n    done\n\n    echo \"$newlist\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=$1\n  local result\n  local num\n  local count\n\
    \n  result=$(for num in $arr; do printf \"%s\" \"${num}\" ; done | sort | uniq)\n\
    \n  for num in $arr; do\n    count=$((num | wc -c))\n    if [ $count -gt 1 ];\
    \ then\n      if [ $num != $result[$count-1] ]; then\n        printf \"%s\" \"\
    ${num}\" > tmp\n        mv tmp ${result[$count-1]}\n        sort_array $result\n\
    \      fi\n    fi\n  done\n\n  printf \"%s\" \"$result\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=33 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=9 encoding='utf-8'>
  timestamp: 1660056502
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n    local i\n    local output\n\
    \    local count\n    local binary\n    local num\n    local dec\n    local prefix\n\
    \    local suffix\n    local temp\n    local outputPrefix\n    local outputSuffix\n\
    \n    # Remove spaces from $input\n    input=\"${input// /$'\\n'}\"\n    # Split\
    \ $input into words\n    IFS=' ' read -r -a array <<< \"$input\"\n    # Sort by\
    \ length of binary representation\n    IFS=' ' read -r -a sortedArray <<< \"${array[@]}\"\
    \ | sort -rn\n    # Sort by number of ones in binary representation\n    IFS='\
    \ ' read -r -a sortedArray <<< \"${array[@]}\" | sort -n\n    # Sort by decimal\
    \ value\n    IFS=' ' read -r -a sortedArray <<< \"${array[@]}\" | sort -nr\n\n\
    \    output=$(IFS=', ' echo \"${sortedArray[@]}\" | tr \" \" \"\\n\" | sort -rn)\n\
    \n    for (( i=0; i<${#output[@]}; i++ )); do\n        if [[ -z \"${output[i]}\"\
    \ ]]; then\n            unset output[$i]\n        fi\n    done\n    IFS=', ' echo\
    \ \"${output[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=$1\n    local output=''\n\n    for number\
    \ in $input\n    do\n        (( ${#number} > 0 )); # Ignore empty strings\n  \
    \      if (( ${#number} > $OPTIND - 1 ))\n        then\n            # Only one\
    \ item left. Let's sort by binary representation\n            local digits=${#number/0/0}\n\
    \            local zeros=${#number/1/0}\n            local ones=${#number/0/0}\n\
    \            local temp=''\n            for (( i=0; i < $digits; i++ ))\n    \
    \        do\n                if [[ $number =~ ^.${digits}$ ]]\n              \
    \  then\n                    temp=${temp}${number}\n                    number=${number/${digits}${digits}${digits}${digits}}\n\
    \                else\n                    break\n                fi\n       \
    \     done\n\n            digits=${#temp/0/0}\n            ones=${#temp/1/0}\n\
    \            zeros=${#temp/0/0}\n\n            if [[ $ones -gt 0 ]]\n        \
    \    then\n                output=\"${output}${temp/${digits}${digits}${digits}${digits}${ones}}${temp/${digits}}${zeros}${temp}\"\
    \n            else\n                output=\"${output}${temp/${digits}${digits}${digits}${digits}}${temp/${zeros}}${zeros}${temp}\"\
    \n            fi\n        else\n            # More than one item left. Let's sort\
    \ by decimal value\n            if (( ${#number} > $OPTIND - 2 ))\n          \
    \  then\n                output=\"${output}${number}${number/0/0}\"\n        \
    \        number=${number/1/1}\n            else\n                output=\"${output}${number}\"\
    \n            fi\n        fi\n    done\n\n    echo \"$output\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpcupb6k1w.sh: line 24: digits=${#number/0/0}: bad substitution

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local list=$1\n  # Parse the list into integers and\
    \ count the bits.\n  local -a num=()\n  local -i bits=0\n  for numElement in $list;\
    \ do\n    num+=( $(eval echo \\${$numElement}) )\n    bits+=$(echo \"$numElement\
    \ | bc -l\" |wc -w)\n  done\n\n  # Sort according to the number of 1s.\n  IFS='\
    \ '\n  IFS=$'\\n' read -a tempList <<<\"$(printf '%s' \"$list\")\"\n  sort -n\
    \ -k 2 <<<\"$(printf '%s' \"${tempList[@]}\")\"\n  IFS=' '\n  IFS=$'\\n' read\
    \ -a numList <<<\"$(printf '%s' \"$list\")\"\n  sort -n -k 2 <<<\"$(printf '%s'\
    \ \"${numList[@]}\")\"\n\n  # Finally, return the sorted array.\n  printf '%s\\\
    n' \"${numList[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    # Convert to binary string.\n    local array=($1)\n\
    \n    # Sort array.\n    local sorted=\"\"\n    for i in \"${array[@]}\"; do\n\
    \        local count=\"$(echo \"$i\" | tr ' ' \\\\n | sort | uniq -c  | \\\n \
    \           cut -f1 -d ' ' | sort -n | \\\n            awk '{print $2}')\"\n\n\
    \        # Sort by number of ones.\n        if [ \"$count\" -gt 1 ]; then\n  \
    \          sorted=\"$sorted $i\"\n        fi\n\n        # Sort by decimal value.\n\
    \        if [ \"$count\" -eq 1 ]; then\n            sorted=\"$sorted $(echo $i\
    \ | sed 's/1/0.\\|1/' | \\\n                tr -d '.' | tr '\\n' ' ')\"\n    \
    \    fi\n    done\n    echo \"${sorted// /, }\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpjcmv4mt0.sh: line 26: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 31: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 26: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 31: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 26: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 31: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 26: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 31: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 26: [: : integer expression expected

    /tmp/tmpjcmv4mt0.sh: line 31: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    read -a array <<<\"$1\"\n    local -n count=\"$1\"\
    \n    local -n arr=\"$1\"\n    local -n len=\"${#arr[@]}\"\n\n    local -n a=\"\
    ()\"\n    local -n last=\"\"\n\n    local -i val\n    local i count\n    local\
    \ j\n\n    for ((i = 0; i < len; i++))\n    do\n        last \"${arr[i]}\"\n \
    \   done\n\n    for ((i = 0; i < len; i++))\n    do\n        count[\"${arr[i]}\"\
    ]=0\n    done\n\n    for ((i = 0; i < len; i++))\n    do\n        val=\"${arr[i]}\"\
    \n        if [[ $val == 0 ]] ; then\n            arr[i - 1]=\"${arr[i]}\"\n  \
    \          continue\n        fi\n\n        count=$(count[\"${arr[i]}\"])\n   \
    \     if [ $count -gt 0 ] ; then\n            arr[i - 1]=\"${arr[i]}\"\n     \
    \       continue\n        fi\n\n        arr[i-1]=\"${last}\"\n    done\n\n   \
    \ echo \"${arr[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpesvy1phq.sh: line 16: local: `1 5 2 3 4'': invalid variable name
    for name reference

    /tmp/tmpesvy1phq.sh: line 17: local: `1 5 2 3 4'': invalid variable name for name
    reference

    /tmp/tmpesvy1phq.sh: line 18: local: `0'': invalid variable name for name reference

    /tmp/tmpesvy1phq.sh: line 20: local: `()'': invalid variable name for name reference

    /tmp/tmpesvy1phq.sh: line 21: local: `'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=$1\n    local i=0\n    local tmp ret\n\
    \    local arraySize=$(echo $array | wc -w)\n\n    for i in $(seq 0 $((arraySize-1)))\n\
    \    do\n        tmp=$(($(echo \"${array:$i:1}\" | grep -c '1') ))\n        if\
    \ [[ -z \"${tmp}\" ]]\n        then\n            tmp=$(echo \"${array:$i:1}\"\
    \ | grep -c '0')\n        fi\n        ((tmp > 0)) && ret+=\"${array:$i} \"\n \
    \   done\n    ret=${ret%?}\n    echo \"${ret}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  shift\n  local output\n  output=$(echo\
    \ \"$array\" | sed -e 's/[^[:digit:]]/\\\n/g' -e 's/^/ /' -e 's/ $//')\n  output=\"\
    ${output//$'\\n'/ }\" # remove trailing spaces\n  output=\"${output// /\\\\ }\"\
    \ # insert space before non-digit characters\n  output=\"${output//$'\"'/} \"\
    \ # insert space after non-digit characters\n  output=\"$(echo \"$output\" | tr\
    \ ' ' '\\n' | sort -n | sed -e 's/ /\\\n'$'\\n\\\\'\"'\\\\'/g' -e 's/\"$//'\"\
    '\\\\'\"$'/')\"\n  echo \"$output\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp076v0l_l.sh: line 24: unexpected EOF while looking for matching
    `''''

    /tmp/tmp076v0l_l.sh: line 45: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local lines=($(cut -d' ' -f1 <<< \"$1\"))\n    local\
    \ sorted=()\n    local i=0 max=0\n    \n    for x in \"${lines[@]}\"; do\n   \
    \     (( ${#x} > max )) && max=${#x}\n    done\n    \n    for (( i=0; i<${#lines[@]};\
    \ i++ )); do\n        local j=0\n        for (( j=0; j<${#lines[@]}; j++ )); do\n\
    \            if [ ${#lines[$j]} -gt $i ]; then\n                break\n      \
    \      fi\n        done\n        \n        local sorted[i]=${lines[$j]}\n    done\n\
    \    \n    for (( i=0; i<${#lines[@]}; i++ )); do\n        local j=0\n       \
    \ for (( j=0; j<${#lines[@]}; j++ )); do\n            if [ ${#lines[$j]} -gt $i\
    \ ]; then\n                break\n            fi\n        done\n        \n   \
    \     local sorted[i]=\"${sorted[i]} ${lines[$j]:0:${#lines[$j]}-1}\"\n    done\n\
    \    \n    for (( i=0; i<${#lines[@]}; i++ )); do\n        local sorted[i]=\"\
    ${sorted[i]} ${lines[$i]}\"\n    done\n    \n    for (( i=0; i<${#lines[@]}; i++\
    \ )); do\n        local sorted[i]=\"\\\"${sorted[i]}\\\"\"\n    done\n    \n \
    \   echo \"${sorted[*]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=${1:-\"1 5 2 3 4\"}\n\n    # To store\
    \ binary representation of integer value\n    local binary_string=\"\"\n    #\
    \ To store decimal representation of integer value\n    local decimal_string=\"\
    \"\n\n    # Loop through all elements of the input array\n    for element in $input;\
    \ do\n        binary_string=\"$binary_string 1\"\n        decimal_string=\"$decimal_string\
    \ $(( 10#$element ))\"\n    done\n\n    # To store decimal representation of binary\
    \ string in order\n    local decimal_string_reversed=\"\"\n    # To store binary\
    \ representation of integer in order\n    local binary_string_reversed=\"\"\n\n\
    \    # Store all numbers between -1 and 1 which can be generated by\n    # flipping\
    \ from 0 to 1 and 1 to 0\n    local flipped_binary_string=\"\"\n    local flipped_decimal_string=\"\
    \"\n\n    # To store sorted order of input array\n    local sorted_elements=\"\
    \"\n\n    # To store sorted order of decimal string\n    local sorted_decimal_string=\"\
    \"\n\n    for element in $binary_string; do\n        local binary_string_reversed=\"\
    $binary_string_reversed 1\"\n        local decimal_string_reversed=\"$decimal_string_reversed\
    \ $(( 10#$binary_string_reversed ))\"\n        local flipped_binary_string=\"\
    $flipped_binary_string $(( 10#$flipped_binary_string ))\"\n        local flipped_decimal_string=\"\
    $flipped_decimal_string $(( 10#$flipped_decimal_string ))\"\n    done\n\n    #\
    \ To store sorted order of binary string\n    local sorted_binary_string=\"\"\n\
    \    # To store sorted order of decimal string in order\n    local sorted_decimal_string_reversed=\"\
    \"\n\n    for element in $flipped_binary_string; do\n        local sorted_binary_string=\"\
    $sorted_binary_string 1\"\n        local sorted_decimal_string_reversed=\"$sorted_decimal_string_reversed\
    \ $(( 10#$sorted_decimal_string_reversed ))\"\n    done\n\n    sorted_elements=\"\
    $sorted_elements ${sorted_binary_string:0:${#sorted_binary_string}-1}\"\n    sorted_decimal_string=\"\
    $sorted_decimal_string ${sorted_decimal_string_reversed:0:${#sorted_decimal_string_reversed}-1}\"\
    \n\n    echo \"$sorted_elements\"\n    echo \"$sorted_decimal_string\"\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpq98_o6qn.sh: line 46: 10# 1 : syntax error in expression (error
    token is "1 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=$1\n    local num_ones=${#array[@]}\n\
    \    # sort the array\n    for ((i = 0; i < num_ones; i++)); do\n        local\
    \ index=$(( $i + 1 ))\n        local val=${array[i]}\n        array[$i]=${array[index]}\
    \ # swap\n    done\n    # re-sort based on decimal value\n    for ((i = 0; i <\
    \ num_ones; i++)); do\n        local val=${array[i]}\n        local num=0\n  \
    \      for ((j = 1; j < num_ones; j++)); do\n            if [ $(( val % 2 )) -eq\
    \ $(( $j % 2 )) ]; then\n                (( num++ ))\n            fi\n       \
    \ done\n        if [ $num -gt 0 ]; then\n            local index=$(( $i ))\n \
    \           local val=${array[i]}\n            local num_arr=(${val//[^0}]}) #\
    \ get string of non-zeros\n            array[$i]=${num_arr[1]}\n            array[$index]=${num_arr[0]}\n\
    \        fi\n    done\n    echo \"${array[*]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=(\"$@\")\n    local -a sorted_arr\n    local\
    \ -a result\n    local i=0\n    local -a bit\n    local -a sorted_bit\n    local\
    \ num_ones=0\n    local num_zeros=0\n    while [ \"$i\" -lt \"${#arr[@]}\" ];\
    \ do\n        local ones=${arr[$i]}\n        (( num_ones+=ones ))\n        ((\
    \ num_zeros+=0-ones ))\n        sorted_arr[i]=\"${ones}${num_ones}${num_zeros}${num_ones+num_zeros}${ones}${num_ones}\"\
    \n        (( i+=1 ))\n    done\n\n    sorted_bit=($(sort -nrk2 <<<\"${sorted_arr[@]}\"\
    ))\n    for (( i = 0; i < \"${#sorted_bit[@]}\"; i++ )); do\n        result[i]=\"\
    ${sorted_bit[i]}${sorted_bit[$(( i + 1 ))]}\"\n    done\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmphuxwnzhb.sh: line 25: ((: 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    /tmp/tmphuxwnzhb.sh: line 26: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array_str=\"$1\"\n    local array_items=()\n\
    \    local array_temp=\"\"\n    local array_temp_items=()\n    local array_binary\n\
    \n    array_items=($(echo \"$array_str\" |\n        awk '{if ($1 != \"-\") {print\
    \ $0}}'\n    ))\n\n    while (( $# > 0 ))\n    do\n        array_temp=$(echo \"\
    $1\" |\n            awk '{if ($1 != \"-\") {print $0}}'\n        )\n\n       \
    \ array_temp_items=($(echo \"$array_temp\" |\n            awk '{if ($1 != \"-\"\
    ) {print $0}}'\n        ))\n\n        array_binary=$(echo \"$array_temp_items\"\
    \ |\n            awk '{\n            binary=\"\"\n            for (i=1; i<=NF;\
    \ i++) {\n                binary += $i\n            }\n            print binary\n\
    \            }'\n        )\n\n        array_temp=\"\"\n        array_temp_items=()\n\
    \n        for (( j=0; j < ${#array_binary}; j++ ))\n        do\n            if\
    \ [[ ${array_binary:j:1} == \"1\" ]]; then\n                array_temp+=${array_temp_items[${#array_temp_items[@]}]}\n\
    \                array_temp_items=()\n            else\n                array_temp_items+=(\"\
    ${array_binary:j:1}\")\n            fi\n        done\n\n        array_str=\"$array_temp\"\
    \n        shift\n    done\n\n    echo \"${array_items[*]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    set -f\n    IFS=' ' read -a array <<< \"$1\"\n   \
    \ local first=1\n    local max=0\n    local j=0\n    local i\n    for ((i=0; i\
    \ < ${#array[@]}; i++ )); do\n        if [ $(( array[i] | wc -l )) -gt $max ];\
    \ then\n            max=$(( array[i] | wc -l ))\n        fi\n    done\n    local\
    \ min\n    for ((i=0; i < ${#array[@]}; i++ )); do\n        if [ $(( array[i]\
    \ | wc -l )) -ge $min ]; then\n            min=$(( array[i] | wc -l ))\n     \
    \   fi\n    done\n    for ((i=0; i < ${#array[@]}; i++ )); do\n        array[$i]=\"\
    ${array[$i]}\"\n        if [ $(( array[i] | wc -l )) -gt $min ]; then\n      \
    \      array[$j]=\"${array[$i]}\"\n            j=$(( j+1 ))\n        fi\n    done\n\
    \    local array[$j]\n    local j=1\n    local i\n    for ((i=0; i < ${#array[@]};\
    \ i++ )); do\n        array[$i]=\"${array[$i]}\"\n        if [ $(( array[i] |\
    \ wc -l )) -gt $max ]; then\n            array[$j]=\"${array[$i]}\"\n        \
    \    j=$(( j+1 ))\n        fi\n    done\n    echo ${array[@]}\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp7i5cygkx.sh: line 28: [: 1: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 28: [: 5: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 28: [: 2: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 28: [: 3: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 28: [: 4: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 34: [: 1: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 34: [: 5: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 34: [: 2: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 34: [: 3: unary operator expected

    /tmp/tmp7i5cygkx.sh: line 34: [: 4: unary operator expected

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  echo \"$1\" | awk '{print tolower($0)}' | sort -nr |\
    \ sed 's/ //g;s/[^-]*-[^-]*$//g' | tr '\\n' '|'\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -n arr=$1\n  local -a res\n\n  printf -v res '%q'\
    \ \"${arr[@]}\" | tr ' ' ' ' | sort -n -k 2 | tr ' ' '\\n'\n  printf '%s\\n' \"\
    ${res[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmplp2uhq39.sh: line 15: local: `1 5 2 3 4'': invalid variable name
    for name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n\tlocal array=$1\n\tlocal array_len=`echo $array | wc\
    \ -l | awk '{print $1}'`\n\n\tlocal max=\"-999999999\"\n\tlocal min=\"999999999\"\
    \n\tlocal res\n\n\tlocal count\n\tlocal tmp\n\tlocal i\n\n\tfor i in `seq 0 $array_len\
    \ - 1`\n\tdo\n\t\ttmp=`echo $array | awk -F\" \" '{print $i}'`\n\t\tcount=`echo\
    \ $tmp | wc -l | awk '{print $1}'`\n\t\t\n\t\tif [[ `echo $tmp | awk '{print $1}'\
    \ | wc -l` == 1 ]]; then\n\t\t\tmax=$tmp\n\t\telse\n\t\t\tif [[ `echo $tmp | awk\
    \ '{print $1}' | wc -l` > `echo $tmp | awk '{print $2}' | wc -l` ]]; then\n\t\t\
    \t\tmax=$tmp\n\t\t\telse\n\t\t\t\tmin=$tmp\n\t\t\tfi\n\t\tfi\n\tdone\n\n\tres=`echo\
    \ $array | awk -F\" \" '{print $min\"-\"$max}'`\n\techo $res\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "seq: extra operand \u20181\u2019\nTry 'seq --help' for more information.\n"
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=\"$1\"\n    local -a sorted\n\n    arr=(\
    \ \"${arr[@]}\" )\n    local -a count\n    count=($(for i in ${arr[@]}; do if\
    \ [[ \"$i\" == \"1\" ]]; then count=( ${count[@]} ; echo -n 1 ) ; else count=(\
    \ ${count[@]} ; echo -n 0 ) ; fi done))\n    count=(${count[@]})\n    local -a\
    \ result\n    result=()\n\n    for i in $(seq ${#arr[@]}); do\n        result+=(\"\
    ${arr[i]}\")\n    done\n    local length\n    length=$(expr ${#result[@]} - 1)\n\
    \n    if [[ -z ${arr[0]} ]] ; then shift ${arr[@]}; return ; fi\n\n    sorted=()\n\
    \    for i in $(seq 1 ${#count[@]}); do\n        local j\n        local k\n  \
    \      local len\n        if [[ \"${count[i]}\" -ge \"${count[i-1]}\" ]] ; then\n\
    \            j=$(( ${i} - 1 ))\n            k=$(( ${count[i]} - 1 ))\n       \
    \ else\n            j=$i\n            k=$(( ${count[i]} - 1 ))\n        fi\n \
    \       len=${#result[@]}\n        if [[ $j -ne $k ]] ; then\n            sorted+=(\"\
    ${result[j]}\" \"${result[k]}\")\n        fi\n    done\n    for (( i = 0; i <\
    \ ${#sorted[@]}; i++ )); do\n        sorted[i]=\"\\\"${sorted[i]}\\\"\"\n    done\n\
    \    echo \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpzwq1yrh9.sh: command substitution: line 21: syntax error near unexpected
    token `;''

    /tmp/tmpzwq1yrh9.sh: command substitution: line 21: `for i in ${arr[@]}; do if
    [[ "$i" == "1" ]]; then count=( ${count[@]} ; echo -n 1 ) ; else count=( ${count[@]}
    ; echo -n 0 ) ; fi done)''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n\tlocal input=$1\n\n\tlocal -a sorted\n\tlocal -a bits\n\
    \tlocal -a numbers\n\tlocal -a len\n\n\tnumbers=()\n\tbits=()\n\tsorted=()\n\n\
    \twhile read -r line; do\n\t\tnumbers+=(\"$line\")\n\tdone <<< \"$input\"\n\n\t\
    len=${#numbers[@]}\n\n\tfor (( i=0; i < len; i++ )); do\n\t\tlet \"bits[$i]=$numbers[$i]\"\
    \n\tdone\n\n\tbits=($(bc <<< \"x${bits[*]} & -x${bits[*]}\" | sed 's/^-/0/'))\n\
    \n\tfor (( i=0; i<len; i++ )); do\n\t\tlet \"bits[$i]=bits[$i] | $bits[$i]\"\n\
    \tdone\n\n\tfor (( i=0; i<len; i++ )); do\n\t\tsorted+=($(echo \"${numbers[$i]}\"\
    \ | bc | sed 's/^0/\"&\"/g' | sed 's/^1/\"0\"/g' | sed 's/^1/\"1\"/g'))\n\tdone\n\
    \n\tsorted=($(sort <<< \"${sorted[*]}\" | sed 's/^0\"$/0\"/g' | sed 's/^1\"$/1\"\
    /g' | sed 's/^1\"$/\"1\"/g' | sed 's/^\"1\"$//g'))\n\n\tprintf '%s\\n' \"${sorted[*]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp6szogjz1.sh: line 33: let: bits[0]=1 5 2 3 4[0]: syntax error in
    expression (error token is "5 2 3 4[0]")

    (standard_in) 1: syntax error

    /tmp/tmp6szogjz1.sh: line 39: let: bits[0]=bits[0] | [0]: syntax error: operand
    expected (error token is "[0]")

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660056497
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -r array=\"$1\"\n    local -r array len=\"${#array}\"\
    \n    local i output first\n    local -a result temp\n    local char\n    local\
    \ -a temp2\n\n    for (( i = 0; i < len; i++ )); do\n        if (( array[i] <\
    \ 0 )); then\n            temp=\"${array[i]}\"\n        else\n            temp=$((\
    \ ${array[i]} >> 1 ))\n        fi\n        char=$(echo \"${array[i]}\" | sed \"\
    s/^\\(.\\)\\(.\\)/\\1\\2/g\")\n        result=()\n        temp2=()\n\n       \
    \ for (( j = 0; j < 8; j++ )); do\n            temp2[j]=$(echo \"${temp}\" | sed\
    \ \"s/.\\(.\\)/\\1/g\")\n            result+=( \"${temp2[j]}\" )\n           \
    \ temp=\n        done\n        temp2+=( \"$char\" )\n        first=\"${result[0]}\"\
    \n        (( array[i] = array[i] / 2 ))\n        temp2=($(printf \"%s\\n\" \"\
    ${result[@]}\" ))\n        for (( j = 1; j < 8; j++ )); do\n            array[i-j]+=\"\
    \ $temp2[j]\"\n        done\n        if [ \"$first\" != \"$char\" ]; then\n  \
    \          array[i++]=$char\n        fi\n    done\n    printf \"%s\\n\" \"${array[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpd2q3x6ic.sh: line 23: ((: 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    /tmp/tmpd2q3x6ic.sh: line 26: 1 5 2 3 4 >> 1 : syntax error in expression (error
    token is "5 2 3 4 >> 1 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local strings=( $1 )\n    local sorted\n    local\
    \ i\n    for (( i = 0 ; i < ${#strings[*]} ; i++ )); do\n        sorted+=($(printf\
    \ \"%-${#sorted[*]}s\" \"${strings[${i}]}\"))\n    done\n    echo $sorted\n}\n\
    \ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local input=${1:-/dev/stdin}\n  local arr=$(echo \"\
    $input\" | tr -cd '[[:digit:]]')\n  local length=$(echo \"$input\" | wc -l)\n\
    \  local sorted=()\n  local index\n  local len\n  local sort\n  local key\n  local\
    \ output\n  local sortIndex\n  for ((index=0; index<$length; index++));do\n  \
    \  if [ $(($index%2)) -eq 0 ];then\n      sorted+=($(echo $arr[index] | sed 's/.//'))\n\
    \    else\n      key=$(echo $arr[index] | sed 's/.//')\n      if [ -z \"$sort\"\
    \ ]; then\n        sort=$(sort -n <<<\"$key\")\n      else\n        sortIndex=$(echo\
    \ $sort | wc -l)\n        if [ $((index-sortIndex)) -gt 0 ];then\n          sort=$(sort\
    \ -n <<<\"$key\"|tail -1)\n        else\n          sort=$(sort -n <<<\"$key\"\
    )\n        fi\n      fi\n      sorted+=($sort)\n    fi\n  done\n  output=$(cat<<EOF\n\
    $sorted\nEOF\n)\n  echo $output\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=\"$1\"\n    local -a num\n    local -a deco\n\
    \    local -a sorted\n    local -a k\n    local -a deco2\n    local -a deco3\n\
    \    local -a deco4\n    local -a deco5\n    local -a deco6\n    local -a deco7\n\
    \    local -a deco8\n    local -a deco9\n    local -a deco10\n\n    # read binary\
    \ representation to an array 'num'\n    while IFS=' ' read -r -n 2 k; do\n   \
    \     num+=(\"$k\")\n    done <<< \"$arr\"\n\n    # sort 'num' array on 'num'\
    \ array\n    sorted=()\n    for k in \"${!num[@]}\"; do\n        num2dec=()\n\
    \        for (( i = 0; i < 16; i++ )); do\n            if (( ${num[k]} & 1 ));\
    \ then\n                deco+=(\"${num2dec}\")\n            else\n           \
    \     deco2+=(\"${num2dec}\")\n            fi\n        done\n        deco+=(\"\
    ${num2dec}\")\n        deco2+=(\"${num2dec}\")\n    done\n\n    # sort 'deco'\
    \ array on 'deco' array\n    k=0\n    for decok in \"${deco[@]}\"; do\n      \
    \  if (( k == 0 )); then\n            deco3+=(\"${decok}\")\n        else\n  \
    \          deco4+=(\"${decok}\")\n        fi\n        (( k++ ))\n    done\n\n\
    \    # sort 'deco2' array on 'deco2' array\n    k=0\n    for decok in \"${deco2[@]}\"\
    ; do\n        if (( k == 0 )); then\n            deco5+=(\"${decok}\")\n     \
    \   else\n            deco6+=(\"${decok}\")\n        fi\n        (( k++ ))\n \
    \   done\n\n    # sort 'deco3' array on 'deco3' array\n    k=0\n    for decok\
    \ in \"${deco3[@]}\"; do\n        if (( k == 0 )); then\n            deco7+=(\"\
    ${decok}\")\n        else\n            deco8+=(\"${decok}\")\n        fi\n   \
    \     (( k++ ))\n    done\n\n    # sort 'deco4' array on 'deco4' array\n    k=0\n\
    \    for \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfm706o8i.sh: line 85: syntax error near unexpected token `newline''

    /tmp/tmpfm706o8i.sh: line 85: `    for ''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"$1\" | tr ' ' '\\n' | sort -nr -k 2 | cut -d\
    \ '\\n' -f 1 | tr '\\n' ' '\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'cut: the delimiter must be a single character

    Try ''cut --help'' for more information.

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  array=$(echo $1 | tr \" \" \"\\n\")\n  result=''\n \
    \ for i in $(seq 0 $((${#array[@]}-1)) )\n  do\n    ones=$(echo $array[${i}] |\
    \ awk '{print length($0)}')\n    if [ -z \"$ones\" ]\n    then\n      continue\n\
    \    fi\n    dec=$(echo $array[${i}] | awk '{print length($1)}')\n    if [ -z\
    \ \"$dec\" ]\n    then\n      continue\n    fi\n    if [ \"$ones\" -gt \"$dec\"\
    \ ]\n    then\n      result=\"$result \\\"$array[${i}]\\\"\"\n    else\n     \
    \ result=\"$result \\\"$array[${i}]\\\" \"\n    fi\n  done\n  result=\"$result${array[$((${#array[@]})-1)]}\"\
    \n  echo \"$result\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpep7u7gqo.sh: command substitution: line 36: syntax error near unexpected
    token `-1''

    /tmp/tmpep7u7gqo.sh: command substitution: line 36: `(${#array[@]})-1''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local i\n\n  for i in $(seq 0\
    \ $#); do\n    local j=$(eval \"echo $((2#$i))\")\n    local numOnes\n    read\
    \ numOnes <<< $(echo \"${array}\"| awk -v n=\"$j\" 'BEGIN{print (n-2)}')\n\n \
    \   if [[ $numOnes -gt 0 ]]; then\n      local tmp\n      read tmp <<< $(echo\
    \ \"${array}\" | awk -v n=\"$numOnes\" 'BEGIN{print (n-2)}')\n      array=$(printf\
    \ \"\\\"%s\\\" %s \" ${array} \"${tmp}\")\n    fi\n  done\n\n  echo \"${array}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    # $1 -> space-separated list\n    local array=$1\n\
    \    local temp\n    local -n result=$2\n    local -n length=$3\n\n    for i in\
    \ $array; do\n        temp=`echo $i|awk '{print strtonum($1)}'`\n        ((array[length]))=${array[length]}-$temp\n\
    \    done\n    local sorted=${#array[*]}\n\n    for i in `seq 1 $sorted`; do\n\
    \        length=$(echo $i|awk '{print strtonum($1)}')\n        ((length))=`echo\
    \ $length-$((length-sorted))`\n        result[length]=${result[$length]}$i\n \
    \   done\n\n    for i in `seq 1 $sorted`; do\n        echo ${result[$i]}\n   \
    \ done\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2\
    \ -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") =\
    \ \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpkz_hjbno.sh: line 23: syntax error near unexpected token `=${array[length]}-$temp''

    /tmp/tmpkz_hjbno.sh: line 23: `        ((array[length]))=${array[length]}-$temp''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local length=\"${#array}\"\
    \n    local sorted=()\n\n    for i in $(seq 1 $length); do\n        local count=0\n\
    \n        case \"${array[$i]}\" in\n            \"1\") count=$(($count + 1)) ;;\n\
    \            \"0\") count=$(($count - 1)) ;;\n            *) ;;\n        esac\n\
    \n        if [[ ${count} -eq 0 ]]; then\n            sorted+=(${array[$i]})\n\
    \        else\n            if [[ ${count} -gt 0 ]]; then\n                sorted+=(${array[$((\
    \ ${i} - 1 ))]})\n            fi\n\n            if [[ ${count} -lt 0 ]]; then\n\
    \                sorted+=(${array[$(( ${i} + 1 ))]})\n            fi\n       \
    \ fi\n    done\n\n    echo \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local temp\n    local -n num_ones=\"\
    ${array}_num_ones\"\n    local -n dec=\"num_ones_dec\"\n    local -n sorted=\"\
    num_ones_sorted\"\n\n    sort -n <<< \"${array}\" | {\n        local -a count\n\
    \        local i\n        local num_ones_sorted\n        local -a sorted_array\n\
    \n        num_ones_sorted=0\n        sorted_array=()\n        while IFS= read\
    \ -r -d '' num_ones; do\n            (( count[$num_ones]++ ))\n        done\n\n\
    \        while IFS= read -r -d '' num_ones; do\n            (( ${num_ones}==1\
    \ || ${num_ones}==0 )) && continue\n            (( count[$num_ones]--, dec[$num_ones]++\
    \ ))\n        done\n\n        for i in \"${!count[@]}\"; do\n            if ((\
    \ ${count[$i]}==1 )); then\n                sorted_array+=(\"${num_ones_sorted}\"\
    )\n            fi\n        done\n\n        IFS= read -r -d '' temp\n        IFS=\
    \ read -r -d '' num_ones_sorted\n        IFS= read -r -d '' sorted_array\n   \
    \     IFS= read -r -d '' dec\n        IFS= read -r -d '' num_ones\n\n        [[\
    \ ${#sorted_array[@]} == 1 ]] || echo \"ERROR: Wrong number of elements\"\n  \
    \  }\n    echo \"${sorted_array[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpyorebapd.sh: line 17: local: `1 5 2 3 4_num_ones'': invalid variable
    name for name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local i\n\n  local sorted\n\n  local array=\"$1\"\n\n\
    \  local -a binaries\n  local -a digits\n  local -a numbers\n  local -a output\n\
    \n  binaries=()\n  digits=()\n  numbers=()\n  output=\"\"\n\n  for i in $(seq\
    \ ${#array[@]})\n  do\n    local string=\"${array[i]}\"\n    local dec\n    local\
    \ bin\n\n    if [ -z \"${string}\" ]; then\n      numbers+=($i)\n      output+=\"\
    $i\"\n      continue\n    fi\n\n    if [[ \"${string}\" == -* ]]; then\n     \
    \ output+=\"$i\"\n      continue\n    fi\n\n    local first\n    first=1\n   \
    \ while [ -z \"${first}\" ]; do\n      local string=\"${string//[^1 ]/}\"\n  \
    \    first=$?\n    done\n\n    if [ \"$first\" -eq 0 ]; then\n      binary=$(echo\
    \ $string | awk '{print toupper($0)}')\n      binaries+=($binary)\n      output+=\"\
    $i\"\n      continue\n    fi\n\n    local dec=$(echo $string | awk '{print strtonum($0)}')\n\
    \    numbers+=($dec)\n    binaries+=($string)\n    digits+=($first)\n  done\n\n\
    \  # If all elements in input are 0 or all elements are negatives, output\n  #\
    \ is empty\n  if [[ ${#array[*]} -eq 0 ]]; then\n    return 0\n  elif [[ ${#array[*]}\
    \ -eq 1 ]]; then\n    sorted=\"$array[0]\"\n  elif [[ ${#array[*]} -gt 1 ]]; then\n\
    \    sorted=$(echo \"${numbers[*]}\" | sort -nr)\n  else\n    sorted=$(echo \"\
    ${numbers[*]}\" | sort -nr -nk1)\n  fi\n\n  printf '%s\\n' \"${sorted[@]}\"\n\
    \  printf '%s\\n' \"${output[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"$1\" | tr ' ' '\\n' | sort -n -k 2 | sed -e\
    \ 's/^ *//' -e 's/ *$//' | tr '\\n' ' '\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    set -a\n    mapfile -t input < <(echo \"$1\")\n  \
    \  unset input\n    local -n sorted_array=sorted_array\n    local -n input=input\n\
    \n    for i in $(seq ${#input[@]})\n    do\n        local j=0\n        local len\n\
    \        len=0\n        while [ $((${input[$i]}+1)) -eq 0 ]\n        do\n    \
    \        ((j++))\n        done\n        local -n num=num\n        num=$((${input[$i]}+1))\n\
    \        while [ $((${input[$i]}-1)) -eq 0 ]\n        do\n            ((j--))\n\
    \        done\n        local -n num=num\n        num=$((${input[$i]}-1))\n   \
    \     sorted_array[$i]=\"${input[$i]}\"\n    done\n\n    eval \"${sorted_array[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpaimsyd28.sh: line 18: local: warning: sorted_array: circular name
    reference

    /tmp/tmpaimsyd28.sh: line 18: warning: sorted_array: circular name reference

    /tmp/tmpaimsyd28.sh: line 19: local: warning: input: circular name reference

    /tmp/tmpaimsyd28.sh: line 19: warning: input: circular name reference

    /tmp/tmpaimsyd28.sh: line 21: warning: input: circular name reference

    /tmp/tmpaimsyd28.sh: line 41: warning: sorted_array: circular name reference

    /tmp/tmpaimsyd28.sh: line 41: warning: sorted_array: circular name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local -a sorted_array\n  \
    \  local -a tmp_array\n    local tmp_num_ones\n    local tmp_index\n    local\
    \ tmp_val\n    local i j\n    tmp_num_ones=()\n    tmp_array=()\n    for ((i =\
    \ 0; i < ${#array[@]}; ++i)); do\n        tmp_val=$(echo \"${array[i]}\" | sed\
    \ 's/ //g')\n        if [[ \"${tmp_val}\" = \"1\" ]]; then\n            tmp_num_ones[$i]=\"\
    $tmp_num_ones[$i]+1\"\n        else\n            tmp_num_ones[$i]=\"$tmp_num_ones[$i]+${tmp_val}\"\
    \n        fi\n        tmp_array[$i]=\"${tmp_val}\"\n    done\n    for ((i = 0;\
    \ i < ${#tmp_num_ones[@]}; ++i)); do\n        tmp_index=0\n        for ((j = 0;\
    \ j < ${#tmp_array[@]}; ++j)); do\n            if [[ \"${tmp_array[$j]}\" == \"\
    ${tmp_num_ones[$i]}\" ]]; then\n                tmp_index=\"$j\"\n           \
    \     break\n            fi\n        done\n        if [[ -z \"${tmp_index}\" ]];\
    \ then\n            echo \"${tmp_array[$i]}\"\n        else\n            tmp_array[$tmp_index]=${tmp_array[$i]}\n\
    \        fi\n    done\n    for ((i = 0; i < ${#tmp_array[@]}; ++i)); do\n    \
    \    sorted_array+=(\"${tmp_array[$i]}\")\n    done\n    echo ${sorted_array[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"${1}\"\n  local count\n  local index\n\
    \  local value\n  local j\n  local max\n  local min\n  local string\n  local temp\n\
    \  local tmp_array\n  local tmp_j\n  local tmp_index\n  local tmp_value\n  local\
    \ tmp_min\n  local tmp_max\n  local tmp_string\n\n  if (( \"${#array}\" < 1));\
    \ then\n    echo \"Empty list\"\n  fi\n  temp=${array% *}\n  tmp_array=( ${temp//\
    \ */ } )\n\n  index=0\n  while (( \"${index}\" < \"${#tmp_array[@]}\" )); do\n\
    \    tmp_j=$(( ${index} + 1 ))\n    value=${tmp_array[$tmp_j]}\n    tmp_max=-1\n\
    \    tmp_min=-1\n    tmp_string=\"\"\n    if [[ ${#value} -eq 1 ]]; then\n   \
    \   if (( \"${value}\" < \"${tmp_max}\" )); then\n        tmp_max=${value}\n \
    \     fi\n      if (( \"${value}\" > \"${tmp_min}\" )); then\n        tmp_min=${value}\n\
    \      fi\n      tmp_string=\"${value}\"\n    else\n      tmp_max=$(( \"${value}\"\
    \ | bc ))\n      tmp_min=$(( \"${value}\" | bc ))\n      tmp_string=$(echo \"\
    ${value}\" | sed \"s/1//\")\n    fi\n    for (( \"${index}\" < \"${#tmp_array[@]}\"\
    \ )); do\n      tmp_j=$(( ${index} + 1 ))\n      tmp_value=${tmp_array[$tmp_j]}\n\
    \      if [[ ${#tmp_value} -eq 1 ]]; then\n        if (( \"${tmp_value}\" < \"\
    ${tmp_max}\" )); then\n          tmp_max=${tmp_value}\n        fi\n        if\
    \ (( \"${tmp_value}\" > \"${tmp_min}\" )); then\n          tmp_min=${tmp_value}\n\
    \        fi\n      else\n        tmp_max=$(( \"${tmp_value}\" | bc ))\n      \
    \  tmp_min=$(( \"${tmp_value}\" | bc ))\n      fi\n      tmp_string=${tmp_string}\"\
    \ ${tmp_value}\"\n    done\n    tmp_array[$tmp_j]=\"${tmp_max}\" # replace max\
    \ with string\n    tmp_array[$tmp_j]=${tmp_min} # replace min with string\n  \
    \  index=$(( ${index} + 1 ))\n  done\n\n  tmp_max=-1\n  tmp_min=-1\n  for (( \"\
    ${index}\" < \"${#tmp_array[@\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp6n8f91ll.sh: line 58: syntax error: arithmetic expression required

    /tmp/tmp6n8f91ll.sh: line 58: syntax error: `(( "${index}" < "${#tmp_array[@]}"
    ))''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n    local temp\n    local output\n\
    \    local flag\n\n    # sort by count\n    IFS=' ' read -r -a array <<< \"$input\"\
    \n    local -i count=0\n    for element in \"${array[@]}\"; do\n        if [ $element\
    \ == 1 ]; then\n            (( count++ ))\n        else\n            if [ $count\
    \ == 0 ]; then\n                output=\"${element}\"\n            else\n    \
    \            output=\"${output} ${element}\"\n            fi\n        fi\n   \
    \ done\n\n    # sort by dec\n    IFS=' ' read -r -a array <<< \"$output\"\n  \
    \  local -i dec=0\n    for element in \"${array[@]}\"; do\n        if [ $element\
    \ == 0 ]; then\n            (( dec++ ))\n        else\n            if [ $dec ==\
    \ 0 ]; then\n                output=\"${element}\"\n            else\n       \
    \         output=\"${output} ${element}\"\n            fi\n        fi\n    done\n\
    \n    echo \"$output\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -a arr\n  local i j count res\n  # Loop over arguments\n\
    \  for arg in \"${@}\"; do\n    # Split arg by whitespace\n    IFS=\"$(expr '\
    \ ' \"$arg\")\" read -r -a arr <<<\"$(eval printf '%s' \"${arg}\")\"\n    # Count\
    \ number of ones in binary representation\n    i=0\n    while [ \"${arr[$i]}\"\
    \ = 1]; do\n      ((i++))\n    done\n    count=\"$(( 2**i ))\"\n    # Compare\
    \ two numbers according to their count in decending order\n    (( j=0 ))\n   \
    \ while [ \"${arr[$j]}\" = 1 ]; do\n      if [ \"$count\" -gt \"$(( 2**j ))\"\
    \ ]; then\n        ((j++))\n      elif [ \"$count\" -eq \"$(( 2**j ))\" ]; then\n\
    \        ((j++))\n        count=\"$(( $count - 1 ))\"\n      fi\n    done\n  \
    \  # Put the result into result\n    res=\"${arr[$j]}${arr[$i]}\"\n    # Remove\
    \ arr[i] and arr[j]\n    arr=(${arr[@]:0:i-1})\n    arr=(${arr[@]:i})\n  done\n\
    \  # Return result\n  echo \"${res}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "expr: syntax error: unexpected argument \u20181 5 2 3 4\u2019\n/tmp/tmpgcz6mxj7.sh:\
    \ line 23: [: missing `]'\n/tmp/tmpgcz6mxj7.sh: line 40: i-1: substring expression\
    \ < 0\n"
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local -a arr\n    arr=(${array//\
    \ *})\n    for (( i = 0; i < ${#arr[@]}; i++ )); do\n        while [[ $((${arr[$i]}-0))\
    \ = \"0\" ]]; do\n            arr[$i]=`expr $i + 1 \\* 2`\n        done\n    done\n\
    \    for (( i = 0; i < ${#arr[@]}; i++ )); do\n        arr[$i]=${arr[$i]//\\\"\
    /}\n    done\n    echo \"${arr[*]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Your implementation here\n}\n\ncandidate() {\n   \
    \ sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\"\
    ) = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\"\
    \ ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmps7qmp0sv.sh: line 16: syntax error near unexpected token `}''

    /tmp/tmps7qmp0sv.sh: line 16: `}''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=( ${1//,/ } )\n  local -A counts\n  for\
    \ element in \"${array[@]}\"; do\n    (( counts[${element:0:1}]++ ))\n  done\n\
    \  local -r output=($(sort -g <<<\"${!counts[@]}\"))\n  printf '%s\\n' \"${output[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local i\n  local s=\n  for i in $(echo $1 | sed 's/\
    \ /\" \"/g') ; do\n    [[ -z \"$s\" ]] || s=\"\\\"$i\\\"\"\n  done\n  eval \"\
    sort -t \\\" \\\" -k $s\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sort: option requires an argument -- ''k''

    Try ''sort --help'' for more information.

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n\n    # Count number of ones\n\
    \    local ones=\"${array,,}\"\n    local numOfOnes=\"${ones,#0}\"\n    (( numOfOnes\
    \ = numOfOnes - 1 ))\n\n    # Sort array based on number of ones\n    local sortedArray=\"\
    ${array,,}\"\n    local sortedArrayLen=\"${#sortedArray}\"\n    for ((i=1; i<${sortedArrayLen};\
    \ i++)); do\n        local cur=\"${sortedArray[$i]}\"\n\n        local bitCount=\"\
    $(printf '%b' ${cur})\" | wc -c\n        (( bitCount = bitCount - 1 ))\n\n   \
    \     local digits=\"${bitCount}\"\n        if (( digits <= numOfOnes )); then\n\
    \            sortedArray[$i]=\"${cur}0\"\n        else\n            sortedArray[$i]=\"\
    ${cur}\"\n        fi\n    done\n\n    # Sort array based on decimal value\n  \
    \  local sortedArrayLen=\"${#sortedArray}\"\n    for ((i=1; i<${sortedArrayLen};\
    \ i++)); do\n        local cur=\"${sortedArray[$i]}\"\n        local digits=\"\
    ${cur}\"\n\n        if (( digits < 0 )); then\n            digits=$(echo \"${digits}\
    \ * 2\" | bc)\n        fi\n        sortedArray[$i]=\"$(echo \"${digits} * $numOfOnes\"\
    \ | bc)\"\n    done\n\n    echo \"${sortedArray[*]}\"\n}\n\ncandidate() {\n  \
    \  sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3\
    \ 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6\
    \ -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmphf_txf_8.sh: line 20: ((: 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    /tmp/tmphf_txf_8.sh: line 32: ((: 1 5 2 3 4: syntax error in expression (error
    token is "5 2 3 4")

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local input=\"$1\"\n  local output=\"\"\n  local count=\"\
    ${input#* }\"\n  local -a unsorted\n  local -a sorted\n\n  IFS=\" \" read -r -a\
    \ unsorted <<<\"$input\"\n  unsorted=(${unsorted[@]/#/ })\n  for item in \"${unsorted[@]}\"\
    ; do\n    case \"${item}\" in\n      \"-\"* ) continue;;\n      \"+\"* ) continue;;\n\
    \      * ) echo \"$item\";;\n    esac\n    local bin=\"${item//[^01]/}\"\n   \
    \ local dec=$(echo \"$bin\" | grep -o '^[0-9]*$' | sort -n | head -1 | tr -d '\\\
    n')\n    sorted=(${sorted[@]/\"$bin\"/\"$dec\"})\n  done\n  output=(${sorted[@]/#/\
    \ })\n  echo \"${output[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=$1\n  local -a temp\n  local -a sorted_array\n\
    \  local current_element\n  local number_of_ones\n  local count\n\n  number_of_ones=$(echo\
    \ \"${array}\" | awk '{print $1}' | sort -n | uniq -c)\n  count=$(echo \"${array}\"\
    \ | awk '{print $1}' | sort -n | uniq -c)\n  number_of_ones=$(echo \"${number_of_ones[@]}\"\
    \ | tr -d ',')\n  count=$(echo \"${count[@]}\" | tr -d ',')\n\n  i=0\n  while\
    \ [ \"$i\" -lt \"$number_of_ones\" ]; do\n    temp=${array[@]:$i+1}\n    current_element=$(echo\
    \ \"${temp}\" | awk '{print $1}')\n\n    # sorting based on number of ones in\
    \ the binary representation\n    if [ $count -gt 0 ] && [ \"$current_element\"\
    \ -eq \"1\" ]; then\n      sorted_array+=(\"$current_element\")\n    elif [ $count\
    \ -eq 0 ] && [ \"$current_element\" -eq \"0\" ]; then\n      sorted_array+=(\"\
    $current_element\")\n    fi\n\n    i=$(($i+1))\n  done\n\n  for i in $(seq 0 $((${#sorted_array[@]}-1)));\
    \ do\n    echo \"${sorted_array[$i]}\"\n  done\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpv2t_ebm3.sh: line 28: [:       1 1: integer expression expected

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -r arr=\"$1\"\n    local -r len=\"$#\"\n   \
    \ local -r output\n    local i\n    local j\n\n    # Remove all spaces\n    arr=\"\
    ${arr// /}\"\n    # Remove leading zeroes\n    arr=\"$(sed 's/^\\([0-9]*\\)$/\\\
    1/g' <<< \"$arr\")\"\n\n    local count\n    local element\n    local temp\n \
    \   local num_ones\n    local dec\n\n    for ((i = 0; i < len; i++)) {\n     \
    \   count=$(echo \"$arr\" | grep \"^${arr[i]}$\" | wc -c)\n        dec=$(echo\
    \ \"$arr\" | grep \"^${arr[i]}$\" | awk '{print int('${arr[i]}')}')\n\n      \
    \  if [ \"$count\" -lt 2 ]; then\n            if [ \"$count\" = \"0\" ]; then\n\
    \                output=\"$arr\"\n                break\n            else\n  \
    \              arr=\"${arr[@]}\"\n            fi\n        else\n            num_ones=$(echo\
    \ \"$arr\" | grep \"^${arr[i]}$\" | awk '{print int('${arr[i]}')}')\n        \
    \    if [ \"$num_ones\" = \"0\" ]; then\n                arr=\"${arr[@]}\"\n \
    \           else\n                if [ \"$num_ones\" -gt \"$dec\" ]; then\n  \
    \                  temp=\"$arr\"\n                    arr=\"$(echo \"$arr\" |\
    \ sed \"s/$arr/$num_ones/g\")\"\n                    arr=\"${arr// /}\"\n    \
    \                output=\"$temp\"\n                    break\n               \
    \ else\n                    arr=\"${arr[@]}\"\n                fi\n          \
    \  fi\n        fi\n    fi\n\n    echo \"$output\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv0cakvsi.sh: line 59: syntax error near unexpected token `fi''

    /tmp/tmpv0cakvsi.sh: line 59: `    fi''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local -a result\n    result=()\n\
    \    for element in ${array[@]}; do\n        result+=$(echo \"$element\" | grep\
    \ -o '^[01]{2,}$' | sort -rn)\n    done\n    IFS=\"' '\" read -ra arr <<< \"${result[*]}\"\
    \n    IFS=\"' '\" read -ra res <<< \"${arr[*]}\"\n    echo \"${res[*]}\"\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=($1)\n\n    for (( i = 0; i < ${#arr[@]};\
    \ i++ )); do\n        if (( ${arr[$i]} == 1 )); then\n            arr[$i]=\"\\\
    \"${arr[$i]}\\\"\"\n        fi\n    done\n\n    echo ${arr[@]}\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=\" \" read -r -a array <<<\"$1\"\n    local\
    \ -n counts=\"\"\n    local -r result=\"\"\n    for number in \"${array[@]}\"\
    ; do\n        counts+=$(echo \"$number\" | grep -q 1 || printf '0' )\n    done\n\
    \    local -n sorted_counts=\"\"\n    local -r sorted_array=\"\"\n    while read\
    \ -r -d '' number; do\n        local count=$(echo \"$number\" | grep -q 1 || printf\
    \ '0' )\n        sorted_counts+=$(printf '%q' \"$count\")\n        sorted_array+=\"\
    $number\"\n    done <<< \"$counts\"\n    echo -n \"$sorted_array\" | sort -n --\
    \ \"${sorted_counts}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp23wqgss7.sh: line 15: local: `-r'': not a valid identifier

    /tmp/tmp23wqgss7.sh: line 15: local: `-a'': not a valid identifier

    /tmp/tmp23wqgss7.sh: line 16: local: `'': not a valid identifier

    /tmp/tmp23wqgss7.sh: line 21: local: `'': not a valid identifier

    sort: cannot read: '''': No such file or directory

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local list=$1\n  # Convert input list to a list of integer\
    \ and sort it by number of ones\n  local intlist=\"\"\n  local -a sorted\n  local\
    \ -a tmp\n  local i\n  for ((i=0; i<${#list}; i++)); do\n    if [[ ${list[i]}\
    \ =~ ^- ]]; then\n      tmp=()\n      for ((j=$((${#intlist}+1)); j>${i}; j--));\
    \ do\n        tmp+=(\"${intlist[$j]}\")\n      done\n      tmp+=(\"${list[i]}\"\
    )\n      intlist+=(\"${tmp[@]}\")\n    else\n      intlist+=(\"${list[i]}\")\n\
    \    fi\n  done\n  sorted=(\"${intlist[@]}\")\n  # Sort by decimal value then\
    \ return result\n  local -n tmp=sorted\n  sort -rn \"${tmp[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=60 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=56 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    sort --field-separator=$1 -k 2 --numeric-sort ${1}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local numbers=$1\n    numbers=$(echo \"$numbers\"\
    \ | sed 's/ /\" 0\"/' | sed 's/ /\" 1\"/' | sort -n)\n    numbers=\"$numbers\"\
    \n    echo \"$numbers\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -a array=\"$1\"\n  local output=($(sort -n -t\
    \ \\; -k1 <<<\"${array[@]}\"))\n  echo \"${output[@]}\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local sorted\n    local str\n    local i\n    local\
    \ n\n    local decimal\n    local dec\n    local res\n    \n    n=$1\n    sorted=(\
    \ )\n    str=$2\n    \n    while [ $n -gt 0 ]; do\n        decimal=$(printf \"\
    %b\" \"$str\" | cut -c -$n- | tr '[:lower:]' '[:upper:]' | sed 's/\\(.\\)/\\1/'\
    \ | sort -u | tr '[:upper:]' '[:lower:]')\n        dec=${decimal//[!0-9]/}\n \
    \       res=$(echo \"$decimal\" | sed \"s/$dec//\")\n        sorted+=( \"$res\"\
    \ )\n        str=$(echo \"$str\" | sed \"s/$decimal/$res/\")\n        n=$(($n\
    \ - 1))\n    done\n    \n    echo \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmps6j54aio.sh: line 27: [: too many arguments

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  IFS=' ' read -r -a arr <<< \"$1\"\n  local -i i\n  local\
    \ -a res\n\n  for i in \"${!arr[@]}\"; do\n    [[ -z \"$arr[i]\" ]] || res[i]=$arr[i]\n\
    \  done\n\n  for (( i=1 ; i <= \"${#res[@]}\" ; i++ )); do\n    local j\n    for\
    \ (( j=1 ; j <= i ; j++ )); do\n      [[ -z \"${res[j]}\" ]] || [[ \"${res[j]:-0}\"\
    \ -gt \"${res[i]}\" ]] &&\n        (( j+=1 ))\n    done\n    res[j]=\"${res[i]}\"\
    \n  done\n\n  echo \"${res[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=43 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=38 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local sorted_array=\"$(echo \"$1\" | tr \" \" \"\\n\"\
    )\"\n  # This line does the magic to sort your array\n  echo \"$sorted_array\"\
    \n  echo \"${sorted_array[@]}\" | sort -n\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"$1\" | xargs -n 1 -d ' ' awk -F'[ ]' '\n  \
    \  {\n        for(i = 1; i <= NF; i++) {\n            bin = itoa($i)\n       \
    \     count = index(bin, \"1\")\n            if (count == length(bin)) \n    \
    \            printf \"%s%s%s\", $i, OFS, count\n            else \n          \
    \      printf \"%s%s%s%s\", $i, OFS, bin, count\n        }\n        print \"\"\
    \n    }\n    ' | sort\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:4: (FILENAME=5 FNR=1) fatal: function `itoa'' not defined

    awk: cmd. line:4: (FILENAME=3 FNR=1) fatal: function `itoa'' not defined

    awk: fatal: cannot open file `4

    '' for reading (No such file or directory)

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=\"$1\" # split array into space-separated\
    \ items\n  local arr_length=${#arr} # get the length of array\n  local arr_max=${#arr[@]}\
    \ # get max length of array\n  # create binary representation\n  local i j\n \
    \ local bin\n  local bin_length=$(expr ${arr_length} + 1)\n  local bin_max=$((${bin_length}\
    \ / 2))\n\n  # create array of zeros\n  local arr_bin=([0]=0; [1]=0);\n  # fill\
    \ array by zeros\n  for ((i = 0; i <= ${bin_max}; i++)); do\n    ((arr_bin[$i]))\n\
    \    ((arr_bin[$i]+=1))\n  done\n  # create array of ones\n  local arr_one=([0]=-1;\
    \ [1]=0)\n  # fill array by ones\n  for ((i = ${arr_length}; i > 0; i--)); do\n\
    \    ((arr_one[$i]))\n    ((arr_one[$i]+=1))\n  done\n  # sort arr_bin with arr\n\
    \  for ((j=0; j < ${arr_length}; j++)); do\n    ((arr_one[arr_bin[j]]))\n    ((arr_one[arr_bin[j]]))\n\
    \    arr_bin[j]=${arr_bin[j]}\n    arr_bin[j]=$((${arr_bin[j]} + ${arr_one[arr_bin[j]]}))\n\
    \    arr_bin[j]=$((${arr_bin[j]} - ${arr_one[arr_bin[j]]}))\n  done\n  # reverse\
    \ arr_bin\n  for i in $(seq 0 $((${#arr_bin[@]}-1))); do\n    arr_bin[i]=${arr_bin[i]}\n\
    \    arr_bin[i]=$((${arr_bin[i]} + ${arr_one[arr_bin[i]]}))\n    arr_bin[i]=$((${arr_bin[i]}\
    \ - ${arr_one[arr_bin[i]]}))\n  done\n  # sort arr_bin with arr\n  for ((j=0;\
    \ j < ${arr_length}; j++)); do\n    ((arr_bin[arr[j]]))\n    arr_bin[arr[j]]=${arr_bin[arr[j]]}\n\
    \    arr_bin[arr[j]]=$((${arr_bin[arr[j]]} + ${arr_one[arr_bin[arr[j]]]}))\n \
    \   arr_bin[arr[j]]=$((${arr_bin[arr[j]]} - ${arr_one[arr_bin[arr[j]]]}))\n  done\n\
    \  # reverse arr_bin\n  for i in $(seq 0 $((${#arr_bin[@]}-1))); do\n    arr_bin[i]=${arr_bin[i]\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp9oxfi96c.sh: line 25: syntax error near unexpected token `;''

    /tmp/tmp9oxfi96c.sh: line 25: `  local arr_bin=([0]=0; [1]=0);''

    /tmp/tmp9oxfi96c.sh: line 27: ((: i <= : syntax error: operand expected (error
    token is "<= ")

    /tmp/tmp9oxfi96c.sh: line 32: syntax error near unexpected token `;''

    /tmp/tmp9oxfi96c.sh: line 32: `  local arr_one=([0]=-1; [1]=0)''

    /tmp/tmp9oxfi96c.sh: line 34: ((: i = : syntax error: operand expected (error
    token is "= ")

    /tmp/tmp9oxfi96c.sh: line 39: ((: j < : syntax error: operand expected (error
    token is "< ")

    /tmp/tmp9oxfi96c.sh: line 53: ((: j < : syntax error: operand expected (error
    token is "< ")

    /tmp/tmp9oxfi96c.sh: line 81: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    arr1=$(echo \"$1\" | sed -e 's/ //g')\n    arr1=$(echo\
    \ \"$arr1\" | sed -e 's/^/-/g' -e 's/$/-/g')\n    arr1=$(echo \"$arr1\" | sed\
    \ -e 's/\\-/+1/g' -e 's/\\-/+1/g' | sort -n | sed -e 's/^/+/g' -e 's/$/-/g')\n\
    \    echo \"${arr1[*]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=(${1:?Variable name 'arr' is not set!})\n\
    \    local IFS=' '\n    arr=($(awk '{for (i=1;i<=NF;i++) a[$i]++} END{\n     \
    \   for (i in a) {\n            j = i;\n            while (j--) {\n          \
    \      if (a[j]>a[j+1]) tmp=a[j];\n                a[j]=a[j+1];\n            \
    \    a[j+1]=tmp;\n            }\n        }\n        for (i in a) print a[i]}'\
    \ <<<\"$arr\"))\n    echo \"${arr[@]}\"\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=$1\n    declare -a result\n    declare -a binary\n\
    \    declare -i counter\n    declare -i len\n    declare -i i\n\n    binary=()\n\
    \    len=${#array[@]}\n\n    for ((i = 0; i < len; i++))\n    do\n        binary[i]=`printf\
    \ '%b' \"${array[i]}\"`\n        counter=`echo \"${binary[i]}\" | tr ' ' '0' |\
    \ wc -c`\n        result+=(\"${binary[i]}\" ${counter})\n    done\n\n    # sort\
    \ -n sorts numbers according to their decimal values, -nr\n    # reverse sorts\
    \ numbers according to their binary values\n    sort -n -r\n\n    for ((i = 0;\
    \ i < len; i++))\n    do\n        binary[i]=`printf '%b' \"${array[i]}\"`\n  \
    \      counter=`echo \"${binary[i]}\" | tr ' ' '0' | wc -c`\n        result+=(\"\
    ${binary[i]}\" ${counter})\n    done\n\n    for i in \"${!result[@]}\"\n    do\n\
    \        echo \"${result[i]}\"\n    done\n\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=51 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=29 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"${1}\"\n    local counts\n    local\
    \ -a res\n\n    counts=( ${array// / } )\n    res=( $( for n in ${!counts[*]};\
    \ do\n                printf '\"%s\" \"%d\"' \"${counts[$n]}\" \"$n\"\n      \
    \      done | sort -nr | sed 's/^\"//;s/\"$//' ) )\n    echo \"${res[@]}\"\n}\n\
    \ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local tmparr\n  IFS=$' \\t\\n'\n  tmparr=( $1 )\n  echo\
    \ \"${tmparr[@]}\" | sort -n -k 2 | sed 's/^\\(-?[0-9]\\+\\)[^\"]*\\(\"\\([^\"\
    ]\\+\\)\"\\).*$/\\3 \\1/g' | sed 's/\"//g'\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local string=\"${1}\"\n    local result=''\n    local\
    \ temp\n    for val in $(echo \"${string}\" | tr \" \" \"\\n\"); do\n        temp=$(echo\
    \ \"${val}\" | awk '{print tolower($0)}')\n        num=$(echo \"${temp}\" | awk\
    \ '{print length($0)}')\n        shift\n        temp=${temp//[01]/'\"0'}\n   \
    \     temp=${temp//[0-1]/'\"1'}\n        result+=\"${temp} ${num}\"\n    done\n\
    \    echo \"${result}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n    local delimiter=\" $( IFS='\
    \ ' echo \"$1\" | sed 's/-[^ -]*$//' | paste -s -d\" \" )\" # remove negative\
    \ sign before last space\n    local unsorted=\"$(IFS=' '; echo \"$input\" | sed\
    \ 's/./ &/' | sed 's/-[^ -]*$//' | paste -s -d\" \")\" # convert all to space\
    \ separated\n    local sorted=\"$(IFS=' '; echo \"$unsorted\" | sort | sed 's/./\
    \ &/' | sed 's/-[^ -]*$//' | paste -s -d\" \")\" # sort all\n    echo \"$sorted\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Part 1: sort numbers in ascending order with same\
    \ number of ones in binary representation\n  local array=\"$1\"\n  local arraySize=\"\
    ${#array}\"\n  local firstArrayIndex=\"0\"\n  local index=\"0\"\n  local binaryRepresentation=\"\
    \"\n  local onesInBinaryRepresentation=\"0\"\n  local onesInArray=\"${array[1]}\"\
    \n  while (( \"${arraySize}\" > \"${firstArrayIndex}\" )); do\n    binaryRepresentation=\"\
    $(printf \"%b\" \"${array[index]}\") \"\n    (( index++ ))\n    (( \"${onesInArray}\"\
    \ < \"${onesInBinaryRepresentation}\" )) &&\n      binaryRepresentation=\"${binaryRepresentation}1\
    \ \"\n    arraySize=\"${#array}\"\n    firstArrayIndex=\"${index}\"\n    onesInArray=\"\
    ${array[1]}\"\n  done\n  echo \"${binaryRepresentation}\"\n  # Part 2: sort numbers\
    \ in ascending order with same number of ones in decimal representation\n  local\
    \ array=\"$1\"\n  local arraySize=\"${#array}\"\n  local firstArrayIndex=\"0\"\
    \n  local index=\"0\"\n  local decimalRepresentation=\"\"\n  local onesInDecimalRepresentation=\"\
    0\"\n  local onesInArray=\"${array[1]}\"\n  while (( \"${arraySize}\" > \"${firstArrayIndex}\"\
    \ )); do\n    decimalRepresentation=\"$(printf \"%f\" \"${array[index]}\") \"\n\
    \    (( index++ ))\n    (( \"${onesInArray}\" < \"${onesInDecimalRepresentation}\"\
    \ )) &&\n      decimalRepresentation=\"${decimalRepresentation}1 \"\n    arraySize=\"\
    ${#array}\"\n    firstArrayIndex=\"${index}\"\n    onesInArray=\"${array[1]}\"\
    \n  done\n  echo \"${decimalRepresentation}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected
    (error token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 26: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 42: printf: 1 5 2 3 4: invalid number

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    /tmp/tmpin2uzgl1.sh: line 44: ((: < 0 : syntax error: operand expected (error
    token is "< 0 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local elements=$1\n    local -i n\n    n=$((${elements}\
    \ / 2))\n    if [ $n -gt ${elements} ]; then\n        echo \"$elements\" | bc\
    \ -l\n    else\n        local -n elements_array\n        elements_array=( \"${elements[@]:0:$n}\"\
    \ )\n        local -i j\n        for (( j = 0; j < $(( $n - 1 )); j++ )); do\n\
    \            local -i index\n            for (( index = 0; index < ${#elements_array[@]};\
    \ index++ )); do\n                local val=${elements_array[$index]}\n      \
    \          elements_array[$index]=${elements_array[$(( $index + 1 ))]}\n     \
    \           elements_array[$(( $index + 1 ))]=${val}\n            done\n     \
    \   done\n        echo \"${elements_array[@]}\"\n    fi\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmphb8ba3n5.sh: line 17: 1 5 2 3 4 / 2: syntax error in expression
    (error token is "5 2 3 4 / 2")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local output\n  local sort\n \
    \ local n\n  local i\n  local count\n  local bin\n  local dec\n  local decimal\n\
    \  local ones\n  local i\n  output=$(echo \"${array}\" | sed 's/ //g' | tr '[:lower:]'\
    \ '[:upper:]')\n  output=\"${output// /-}\"\n  sort=${output#-}\n  n=\"${sort#?}\"\
    \n  sort=${output%-*}\n  n=\"${n?}\"\n  output=$(echo \"$sort\" | sed \"s/$sort//g\"\
    )\n  output=$(echo \"$output\" | sed 's/-//g')\n  sort=\"$(echo \"$output\" |\
    \ sed 's/^0*//g')\"\n  count=\"${sort#?}\"\n  ones=${sort%-*}\n  ones=\"${ones#?}\"\
    \n  count=\"${count#?}\"\n  sort=\"$(echo \"$sort\" | sed \"s/$ones//g\")\"\n\
    \  sort=\"$(echo \"$sort\" | sed \"s/$count//g\")\"\n  count=\"${count#?}\"\n\
    \  sort=\"$(echo \"$sort\" | sed \"s/$n//g\")\"\n  sort=\"$(echo \"$sort\" | sed\
    \ \"s/$count//g\")\"\n  sort=\"$(echo \"$sort\" | sed \"s/-^1//g\")\"\n  sort=\"\
    $(echo \"$sort\" | sed \"s/-0*//g\")\"\n  output=$(echo \"$sort\" | sed \"s/$sort//g\"\
    )\n  output=\"$(echo \"$output\" | sed 's/-^0*//g')\"\n  output=\"$(echo \"$output\"\
    \ | sed 's/-0*//g')\"\n  output=\"$(echo \"$output\" | sed 's/^-//g')\"\n  output=\"\
    $(echo \"$output\" | sed 's/^-//g')\"\n  output=\"$(echo \"$output\" | sed 's/^0*//g')\"\
    \n  output=\"$(echo \"$output\" | sed 's/^0*//g')\"\n  output=\"$(echo \"$output\"\
    \ | sed 's/^1//g')\"\n  output=\"$(echo \"$output\" | sed 's/^1//g')\"\n  output=\"\
    $(echo \"$output\" | sed 's/^0*//g')\"\n  output=\"$(echo \"$output\" | sed 's/^0*//g\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_27d4bxw.sh: line 56: unexpected EOF while looking for matching
    `''''

    /tmp/tmp_27d4bxw.sh: line 76: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=($*)\n  local -n arr=arr\n  local -a res\n\
    \  local -n num=${arr[0]}\n  local -i cnt=1\n  local -i start\n\n  while [[ $cnt\
    \ -lt ${#arr[@]} ]]; do\n    local i=$((cnt))\n    while [[ $i -le ${#arr[@]}\
    \ ]]; do\n      local j=$((i+1))\n      if [[ ${arr[$i]} == \"1\" && ${arr[$j]}\
    \ != \"1\" ]]; then\n        local temp=${arr[$i]}\n        arr[$i]=${arr[$j]}\n\
    \        arr[$j]=$temp\n      elif [[ ${arr[$i]} != \"1\" && ${arr[$j]} == \"\
    1\" ]]; then\n        local temp=${arr[$i]}\n        arr[$i]=${arr[$j]}\n    \
    \    arr[$j]=$temp\n      elif [[ ${arr[$i]} == \"1\" && ${arr[$j]} == \"1\" ]];\
    \ then\n        local temp=${arr[$i]}\n        arr[$i]=${arr[$j]}\n        arr[$j]=$temp\n\
    \      fi\n      i=$((j-1))\n    done\n    cnt=$((cnt+1))\n  done\n\n  local -r\
    \ cnt=${#arr[@]}\n  local -r max_cnt=$(echo $((${#arr[@]}-1)) | bc)\n  local -i\
    \ i\n  local -r num\n  local res\n\n  for ((i=0;i<${max_cnt};i++)) do\n    num=${arr[i]}\n\
    \    if ((${#res[@]} <= 0)); then\n      res+=(\"${num}\")\n    else\n      if\
    \ (( ${#res[@]} > 0 )); then\n        res=${res[@]}\n      fi\n      res+=(\"\
    ${num}\")\n    fi\n  done\n  echo ${res[@]}\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=40 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=11 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input_array=\"$1\"\n    local output_array=()\n\
    \    local num_ones=0\n    local dec\n    local i\n    local bin_array\n    local\
    \ bin_string\n    local bin_char\n\n    for ((i=0;i<${#input_array};i++));do\n\
    \        dec=$(printf '%d' \"${input_array[i]}\")\n        bin_char=$(printf '%b'\
    \ \"${input_array[i]}\")\n        bin_string=$(printf '%s' \"${bin_char}\")\n\n\
    \        # count the number of 1s\n        if (( ${#bin_string} > 0 ));then\n\
    \            num_ones=$(echo \"${bin_string}\" | wc -c)\n        fi\n        output_array+=(\"\
    $dec$num_ones\")\n    done\n\n    # sort based on number of ones\n    local num_ones\n\
    \    for num_ones in \"${output_array[@]}\"; do\n        local dec\n        local\
    \ i\n        for ((i=0;i<${#input_array};i++));do\n            if (( ${input_array[i]}\
    \ > ${num_ones} ));then\n                dec=$(( ${input_array[i]} - ${num_ones}\
    \ ))\n                local bin_char\n                for ((i=0;i<${#bin_string};i++));do\n\
    \                    bin_char=${bin_string:$i:1}\n                    if [[ \"\
    ${bin_char}\" == \"0\" ]]; then\n                        bin_char=$(printf '%b'\
    \ \"0\")\n                        break\n                    fi\n            \
    \    done\n                output_array+=($dec)\n                break\n     \
    \       fi\n        done\n    done\n\n    printf '[\"%s\"]' \"${output_array[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbnqyo5bp.sh: line 25: printf: 1 5 2 3 4: invalid number

    /tmp/tmpbnqyo5bp.sh: line 42: ((: 1 5 2 3 4 > 110 : syntax error in expression
    (error token is "5 2 3 4 > 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 110 : syntax error: operand expected (error
    token is "> 110 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: 1 5 2 3 4 > 010 : syntax error in expression
    (error token is "5 2 3 4 > 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: operand expected (error
    token is "> 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: 1 5 2 3 4 > 010 : syntax error in expression
    (error token is "5 2 3 4 > 010 ")

    /tmp/tmpbnqyo5bp.sh: line 42: ((: > 010 : syntax error: opera'
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local a=\"$1\"\n    local sorted=\"$(IFS=$'\\n';\n\
    \                    echo \"$a\" | sort -k 2n -k 1 -n -t)\"\n    echo \"${sorted%$'\\\
    n'}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2\
    \ -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") =\
    \ \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sort: option requires an argument -- ''t''

    Try ''sort --help'' for more information.

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  declare -a list\n  declare -a array\n  local i\n\n \
    \ list=( $1 )\n  array=( $2 )\n\n  for i in \"${!list[@]}\"; do\n    arr=( ${array[@]/#/${list[i]}/\
    \ } )\n    arr=( ${arr[@]/%/${((${#arr[@]})*${list[i]})/}} )\n    arr=( ${arr[@]/#/\\\
    1/} )  # remove leading quote\n    arr=( ${arr[@]/:/} )  # remove trailing quote\n\
    \    arr=( ${arr[@]/#\\([0-9]\\)/${arr[1]}/} )  # get array value\n    arr=( ${arr[@]/#\\\
    ([0-9]\\)/${arr[1]} }/)  # get array value\n    array=( ${array[@]/#/${arr}/ }\
    \ )\n  done\n\n  echo \"${array[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local var=\"$1\"\n    local num_ones=$(echo $var |\
    \ tr ' ' '1' | wc -w)\n    local num_dec=$(echo $var | tr ' ' '0' | sort -r -n\
    \ | tail -n 1)\n\n    # sort array\n    eval $(echo $var | tr ' ' '0' | sort -n\
    \ | head -n $((num_ones - num_dec)))\n\n    # sort array in descending order\n\
    \    eval $(echo $var | tr ' ' '0' | sort -n -r -n | head -n $((num_ones - num_dec)))\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -n args=$1;\n    local -a arr=(\"${args[@]}\"\
    \ );\n    local -a sort=(\"${args[@]:2}\" );\n    local -i i count=0;\n    local\
    \ sorted=();\n    local temp;\n    for (( i = 0; i < ${#arr[@]}; i++ )); do\n\
    \        if [[ ${arr[i]} == \"1\" ]]; then\n            sorted+=(\"$i\");\n  \
    \      fi\n    done\n    for (( i = 0; i < ${#sorted[@]}; i++ )); do\n       \
    \ temp=( \"${sorted[$i]}\" );\n        if [[ ${arr[i]} == \"1\" ]]; then\n   \
    \         arr[$i]=\"1\";\n        else\n            arr[$i]=\"0\";\n        fi\n\
    \        arr[${temp}]=(\"${arr[i]}\");\n        count=$(( $count + ${arr[$i]}\
    \ ));\n    done\n    while [[ $count -gt 0 ]] do\n        count=$(( $count - 1\
    \ ));\n        sorted+=($count);\n    done\n    local -n array=$1;\n    echo $(IFS=,;\
    \ echo \"${sorted[*]}\")\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n   \
    \ [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmppyrsm71d.sh: line 36: syntax error near unexpected token `do''

    /tmp/tmppyrsm71d.sh: line 36: `    while [[ $count -gt 0 ]] do''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local output\n  declare -i i=0\n\
    \  declare -i num_ones=0\n  declare -i num=0\n\n  for e in $array; do\n    [ -z\
    \ \"$e\" ] || [ \"$e\" = \"-\" ] && continue\n    [ \"$e\" = \"0\" && [ \"$num_ones\"\
    \ -gt 0 ] && output+=\",\\\"$num_ones\\\"\" ] && break\n    [ \"$e\" = \"1\" ]\
    \ && num_ones+=1\n    [ \"$e\" != \"$num_ones\" ] && output+=\",\\\"$e\\\"\"\n\
    \  done\n\n  [ \"$num_ones\" -gt 0 ] && output+=\",\\\"$num_ones\\\"\"\n\n  output=${output#,}\n\
    \  output=${output%%,}\n  echo \"\\\"$output\\\"\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpd8wmyyt_.sh: line 23: [: missing `]''

    /tmp/tmpd8wmyyt_.sh: line 23: [: missing `]''

    /tmp/tmpd8wmyyt_.sh: line 23: [: missing `]''

    /tmp/tmpd8wmyyt_.sh: line 23: [: missing `]''

    /tmp/tmpd8wmyyt_.sh: line 23: [: missing `]''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n\n  echo \"$array\" | tr \" \" \"\
    \\n\" | sort -n | sort -k2nr | tr \"\\n\" \" \"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local input=\"$1\"\n  local output=\"\"\n\n  local -a\
    \ elements\n  local idx\n  local key\n  local sort\n  local value\n\n  elements=(\
    \ $( echo \"$input\" | tr -d '[:space:]' ) )\n  printf -v key  \"%0${#elements[@]}d\"\
    \ # print an unsigned integer as a string\n  printf -v value \"%0${#elements[@]}d\"\
    \ # print an unsigned integer as a string\n\n  sort=0\n\n  for idx in \"${!elements[@]}\"\
    ; do\n    if [ \"$sort\" -eq 0 ]; then\n      printf -v \"$value\" \"%s\" \"$idx\"\
    \n      if [ \"$idx\" -gt 0 ]; then\n        echo \"$key\"\n      fi\n    elif\
    \ [ \"$sort\" -gt 0 ]; then\n      if [ \"$idx\" -gt \"$sort\" ]; then\n     \
    \   echo \"$key\"\n      fi\n    fi\n\n    sort=$(( sort << 1 ))\n  done\n\n \
    \ printf '%s\\n' \"${elements[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpwt7d1o7f.sh: line 32: printf: `0'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local a=\"$1\"\n  local aLen=${#a}\n  local b\n  local\
    \ i\n  local output\n  local val\n  local tmp\n  local str\n  local t\n  local\
    \ ones\n  local dec\n  local tLen\n  local tInt\n  local j\n  local onesInBinary\n\
    \  local decimal\n\n  for ((i=0; i < ${aLen}; i++)); do\n    b=${a:$i:1}\n   \
    \ decimal=$(echo $b | cut -d \" \" -f1)\n    ones=$(echo $b | cut -d \" \" -f2)\n\
    \n    t=$(( ${ones} + 0 ))\n    tLen=${#t}\n    tInt=$(echo \"$t\" | bc)\n   \
    \ onesInBinary=$(echo $t | bc)\n    if [ \"$tInt\" -gt \"$onesInBinary\" ]; then\n\
    \      # sort numbers with more zeros first\n      val=$(echo \"$t\" | bc)\n \
    \     tmp=$val\n      for ((j=0; j < $tLen; j++)); do\n        if [ $j -gt 0 ];\
    \ then\n          val=$(bc <<< \"$val & $t\" | bc)\n        else\n          val=$(bc\
    \ <<< \"$val | $t\" | bc)\n        fi\n      done\n      output=\"$(echo \"$tmp\"\
    \ | bc )\"\n    else\n      val=$(bc <<< \"$val & $onesInBinary\" | bc)\n    \
    \  output=$(bc <<< \"$output | $val\" | bc)\n    fi\n\n    if [ \"$decimal\" -gt\
    \ \"$ones\" ]; then\n      output=$(echo \"$output + $decimal + $ones\" | bc)\n\
    \    else\n      output=$(echo \"$output + $decimal\" | bc)\n    fi\n  done\n\n\
    \  echo \"$output\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    /tmp/tmp5j112i5t.sh: line 58: [: : integer expression expected

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    /tmp/tmp5j112i5t.sh: line 58: [: : integer expression expected

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    /tmp/tmp5j112i5t.sh: line 58: [: : integer expression expected

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    /tmp/tmp5j112i5t.sh: line 58: [: : integer expression expected

    (standard_in) 1: syntax error

    (standard_in) 1: syntax error

    (standard_in) 1: illegal character: |

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr\n    local sorted\n    local count\n   \
    \ local index\n    local index2\n    arr=($1)\n    sorted=()\n    count=0\n  \
    \  index=0\n    index2=0\n    for i in \"${arr[@]}\"; do\n        (( count++ ))\n\
    \        if [[ $i -ge 1 ]]; then\n            sorted+=(\"$i\")\n        fi\n \
    \   done\n    sort -n -t $'\\t' -k 2 <<<\"${sorted[@]}\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\" array\n    local sorted\n    local\
    \ count\n    local digit\n    local j\n    local i\n    local index\n    local\
    \ last\n    local max\n\n    # Convert to array\n    IFS=' ' read -a array <<<\
    \ \"$input\"\n\n    # Sort the array\n    for i in \"${!array[@]}\"; do\n    \
    \    if (( ${array[$i]} > 0 )) ; then\n            last=$i\n        fi\n    done\n\
    \n    # Find first index with number of ones\n    for j in \"${!array[@]}\"; do\n\
    \        count=\"${array[$j]}\"\n        index=$j\n        if (( ${count} > 0\
    \ )) ; then\n            break;\n        fi\n    done\n\n    # Count number of\
    \ ones\n    while (( ${count} > 0 )); do\n        digit=\"${array[$index]}\"\n\
    \        (( ${digit} += 1 ))\n        (( ${index}-- ))\n        (( count-- ))\n\
    \    done\n\n    # Build sorted array\n    sorted=()\n    while (( ${index} >\
    \ 0 )); do\n        if (( ${count} > 0 )) ; then\n            digit=\"${array[$index]}\"\
    \n            (( ${digit} -= 1 ))\n            (( ${index}-- ))\n            ((\
    \ count-- ))\n        fi\n        sorted+=(\"${array[$index]}\")\n    done\n\n\
    \    # Return sorted array\n    echo \"${sorted[@]}\"\n}\n\ncandidate() {\n  \
    \  sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3\
    \ 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6\
    \ -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp62rafbsf.sh: line 47: ((: 1 += 1 : attempted assignment to non-variable
    (error token is "+= 1 ")

    /tmp/tmp62rafbsf.sh: line 48: ((: 0-- : syntax error: operand expected (error
    token is "- ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=\"$1\"\n  local -n arrref=\"${arr}\"\n  local\
    \ -a sorted=()\n  local idx=0\n  local -n len=\"${#arrref}\"\n  local -n last=()\n\
    \  local -n num=()\n  local -n val\n  local -n maxlen=0\n  while (( idx < len\
    \ )) ; do\n    last+=(\"${arrref[idx]}\")\n    (( idx++ ))\n  done\n  for (( idx=0\
    \ ; idx < len ; idx++ )) ; do\n    arrref[idx]=\"$((${arrref[idx]} + ${last[idx]}))\"\
    \n    (( idx++ ))\n  done\n  for (( idx=0 ; idx < len ; idx++ )) ; do\n    ((\
    \ idx++ ))\n    num+=(\"$((${arrref[idx]} >> 1)))\"\n    maxlen=$(( ${#num[@]}\
    \ > maxlen )) && maxlen=${#num[@]}\n  done\n  idx=0\n  while (( idx < maxlen ))\
    \ ; do\n    (( idx++ ))\n    sorted+=(\"${num[idx]}\")\n  done\n  sorted=($(\n\
    \    IFS=$'\\n'\n    echo \"${sorted[*]}\"\n  ))\n  echo \"${sorted[@]}\"\n}\n\
    \ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpc1e5m_sh.sh: line 35: syntax error near unexpected token `&&''

    /tmp/tmpc1e5m_sh.sh: line 35: `    maxlen=$(( ${#num[@]} > maxlen )) && maxlen=${#num[@]}''

    /tmp/tmpc1e5m_sh.sh: line 36: syntax error near unexpected token `done''

    /tmp/tmpc1e5m_sh.sh: line 36: `  done''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local list=$1\n    # Convert string into array using\
    \ spaces\n    list=( $(echo ${list} | tr ' ' ',') )\n    # Count number of ones\
    \ in each element of the array\n    counts=( $(echo ${list} | tr ' ' '1' | tr\
    \ ' ' '0' | wc -c) )\n    # Calculate number of ones based on number of elements\
    \ in the array\n    ones_count=$(expr ${#list[@]} - $(( ${#counts[@]} - 1 )))\n\
    \    # Calculate decimal number for each element in the array\n    decimal_count=$(expr\
    \ ${ones_count} - 1)\n    # Sort based on decimal number first\n    sort -k${decimal_count}\
    \ -n | tr ' ' ','\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: "sort: field number is zero: invalid field specification \u20180\u2019\n"
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local sorted_arr=$1\n  local tmp\n  local sorted\n \
    \ local i\n\n  echo \"$sorted_arr\" | while IFS=$'\\t' read -r i j; do\n    tmp=\"\
    $(echo \"$i\" | sed \"s/.*1\\(.*\\)/'\\1'/\")\"\n    sorted=\"$(echo \"$j\" |\
    \ sed \"s/.*1\\(.*\\)/'\\1'/\")\"\n    if [ \"$tmp\" -gt \"$sorted\" ]; then\n\
    \      printf \"$tmp\\t$sorted\\n\"\n    else\n      printf \"$tmp\\t$i\\n\"\n\
    \    fi\n  done\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmph6pwznot.sh: line 23: [: '' 5 2 3 4'': integer expression expected

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local IFS=\"$1\"\n  local input\n  local output\n  output=$(printf\
    \ \"%s\\n\" \"$1\" | sort -g | sed \"s/ [^ ]*//\" | sed \"s/ /\\\"&\\\"/g\")\n\
    \  printf '%s\\n' \"$output\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  declare -i num=0\n  declare -a arr=(\"$@\")\n  IFS='\
    \ ' read -r -a array <<< \"${arr[*]}\"\n\n  for i in \"${!array[@]}\"; do\n  \
    \  local -a arr_noOnes\n    local -a arr_noOnes_dec\n\n    arr_noOnes=( $(echo\
    \ \"${array[@]}\" | grep -v '^-$') )\n    arr_noOnes_dec=( $(echo \"${arr_noOnes[*]}\"\
    \ | sed 's/^-//g' | sed 's/^-?//' | sed 's/^-0//g' | sed 's/^-0$//' | sed 's/^-1//g'\
    \ | sed 's/^-1$//' | sed 's/^-2//g' | sed 's/^-2$//' | sed 's/^-3//g' | sed 's/^-3$//'\
    \ | sed 's/^-4//g' | sed 's/^-4$//' | sed 's/^-5//g' | sed 's/^-5$//') )\n\n \
    \   num=$((${arr_noOnes_dec[@]}))\n\n    if [ $num -gt 1 ]; then\n      declare\
    \ -a arr_ascDec_dec\n      arr_ascDec_dec=( $(echo \"${arr_noOnes_dec[@]}\" |\
    \ sed 's/^//' | sed 's/^0$//' | sed 's/^1$//' | sed 's/^2$//' | sed 's/^3$//'\
    \ | sed 's/^4$//') )\n      echo \"${arr_ascDec_dec[@]}\"\n      declare -a arr_ascDec\n\
    \      arr_ascDec=( $(echo \"${arr_noOnes_dec[@]}\" | sed 's/^//' | sed 's/^0$//'\
    \ | sed 's/^1$//' | sed 's/^2$//' | sed 's/^3$//' | sed 's/^4$//' | sed 's/^5$//')\
    \ )\n      echo \"${arr_ascDec[@]}\"\n      declare -a arr_ascDec_asc\n      arr_ascDec_asc=(\
    \ $(echo \"${arr_noOnes_dec[@]}\" | sed 's/^//' | sed 's/^0$//' | sed 's/^1$//'\
    \ | sed 's/^2$//' | sed 's/^3$//' | sed 's/^4$//' | sed 's/^5$//' | sed 's/^6\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfmap4vvu.sh: line 36: unexpected EOF while looking for matching
    `''''

    /tmp/tmpfmap4vvu.sh: line 56: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array \n    local tmp \n    array=(${($@)//\
    \ })\n    tmp=\"\"\n    for ((i=1; i<${#array[@]}; i++)); do\n        tmp=$(printf\
    \ \"%b\" \"${array[i]}\")\n        ((tmp=\"${tmp#1}\"))\n        ((tmp=\"${tmp%1}\"\
    ))\n        array[$i]=$(printf \"%d\\\\n\" \"${tmp}\")\n    done\n    echo ${array[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmppfsw4bp2.sh: line 17: ${($@)// }: bad substitution

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=\"$1\"\n    local sorted_arr=()\n\n    #\
    \ Convert input list to array of integers\n    local arr=()\n    for element in\
    \ $*; do\n        arr+=( $(echo $element | tr '[:lower:]' '[:upper:]' | grep -oE\
    \ '[+-]?[0-9]+') )\n    done\n    # Convert array of integers into binary array\n\
    \    for element in \"${arr[@]}\"; do\n        printf \"%s\\n\" \"$(echo \"${element}\"\
    \ | sed 's/^..//' >/dev/null 2>&1)\"\n    done | sort -n\n    # Convert binary\
    \ array to decimal array\n    for element in \"${arr[@]}\"; do\n        echo -n\
    \ $(( $element ))\n    done | sort -n\n    # Sort decimal array into ascending\
    \ order\n    for element in \"${arr[@]}\"; do\n        sorted_arr+=(\"$(( $element\
    \ ))\")\n    done\n    # Convert sorted array into space-separated string\n  \
    \  echo \"${sorted_arr[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=$1\n  local result=\"[\"\n  for (( i = 0;\
    \ i < ${#arr[@]}; i++ )); do\n    local bin=${arr[i]#* }\n    if [[ -z \"$bin\"\
    \ ]]; then\n      continue\n    fi\n    local dec=$(echo \"$bin\" | cut -d' '\
    \ -f1 | cut -d+ -f1)\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo \"$bin\"\
    \ | cut -d' ' -f1 | cut -d- -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n   \
    \   dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d/ -f1)\n    fi\n    if [[ -z \"\
    $dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d+ -f1)\n  \
    \  fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' ' -f1\
    \ | cut -d4- -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo \"\
    $bin\" | cut -d' ' -f1 | cut -d- -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n\
    \      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d/ -f1)\n    fi\n    if [[ -z\
    \ \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d+ -f1)\n\
    \    fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' '\
    \ -f1 | cut -d- -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo\
    \ \"$bin\" | cut -d' ' -f1 | cut -d/ -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n\
    \      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d+ -f1)\n    fi\n    if [[ -z\
    \ \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d4- -f1)\n\
    \    fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' '\
    \ -f1 | cut -d- -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n      dec=$(echo\
    \ \"$bin\" | cut -d' ' -f1 | cut -d/ -f1)\n    fi\n    if [[ -z \"$dec\" ]]; then\n\
    \      dec=$(echo \"$bin\" | cut -d' ' -f1 | cut -d+ -f1)\n    fi\n    if [[ -z\
    \ \"$dec\" ]]; then\n      dec=$(echo \"$bin\" | cut -d' \n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp66nfpw83.sh: line 66: unexpected EOF while looking for matching
    `''''

    /tmp/tmp66nfpw83.sh: line 86: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=$1\n  local -a result\n  local -i cnt\n  local\
    \ -n num=${arr[0]}\n  local -n num=${num//[-]/}\n  local -n arr=(\"${arr[@]//'\
    \ '/ }\")\n  local -n arr=(\"${arr[@]// /}\")\n\n  result=()\n  for (( i = 0;\
    \ i < ${#arr[@]}; i++ )); do\n    cnt=0\n    for (( j = 0; j < ${#arr[@]}; j++\
    \ )); do\n      [[ $(( ${num:$j:1} & ${arr[$j]:$i:1} )) -eq 1 ]] &&\n        ((\
    \ cnt++ ))\n    done\n    num=${num:0:$cnt}\n    [[ ${num} != '' ]] &&\n     \
    \ result+=(\"${num}\")\n  done\n  echo -n \"${result[*]}\"\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpicf8v9z4.sh: line 18: local: `1 5 2 3 4'': invalid variable name
    for name reference

    /tmp/tmpicf8v9z4.sh: line 19: local: `'': not a valid identifier

    /tmp/tmpicf8v9z4.sh: line 20: local: arr: reference variable cannot be an array

    /tmp/tmpicf8v9z4.sh: line 21: local: arr: reference variable cannot be an array

    /tmp/tmpicf8v9z4.sh: line 27: & 1 : syntax error: operand expected (error token
    is "& 1 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -i i j k\n  local -a sorted\n  local -a ones\n\
    \  sorted=()\n  ones=()\n  IFS=$'\\n' read -ra words <<<\"$1\"\n  for ((i=0; i<${#words[@]};\
    \ i++)); do\n    local -a count\n    count=(0)\n    for ((j=0; j<${#words[@]};\
    \ j++)); do\n      ((${words[j]} == ${words[i]}))\n    done\n    ((${#count[@]}\
    \ > 0))\n    local -a sort\n    sort=($((${count[0]}))\n    for ((j=0; j<${#count[@]};\
    \ j++)); do\n      if ((${count[j]} > 1)); then\n        sort+=(-${sort[$((j-1))]})\n\
    \      fi\n    done\n    sort+=(${words[i]})\n    sorted+=(\"${sort[@]}\")\n \
    \   ones+=(${words[i]})\n  done\n  sorted+=(\"$1\")\n  ones+=(\"$1\")\n  echo\
    \ \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpb2dkowt1.sh: line 30: syntax error near unexpected token `(''

    /tmp/tmpb2dkowt1.sh: line 30: `    for ((j=0; j<${#count[@]}; j++)); do''

    /tmp/tmpb2dkowt1.sh: line 31: ((: > 1: syntax error: operand expected (error token
    is "> 1")

    /tmp/tmpb2dkowt1.sh: line 34: syntax error near unexpected token `done''

    /tmp/tmpb2dkowt1.sh: line 34: `    done''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array=\"$1\"\n  local bin=$(printf '%s' \"${array}\"\
    \ | sed -e 's/ /1/g' -e 's/1//g' -e 's/^/0/' -e 's/$/1/')\n  local dec=$(printf\
    \ '%s' \"${array}\" | sed -e 's/^/0/' -e 's/$/1/')\n  local tmp=${array}\n  local\
    \ list=\"$(eval printf '%s' ${tmp} | sort | uniq)\"\n  eval printf '%s' ${bin}\
    \ | sed -e \"s/1/${list}/\"\n  eval printf '%s' ${dec} | sed -e \"s/1/${list}/\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local sorted\n    local number\n\n    sorted=()\n\
    \    IFS=$'\\n'\n    for i in $(seq 1 $((${#1}-1)))\n    do\n        number=\"\
    $(echo \"${1}\" |  awk '{print $i}')\"\n        num=$(echo \"${1}\" |  awk \"\
    {print ${number}/2}\")\n\n        if [[ $num -gt 0 ]]; then\n            sorted+=(\"\
    $number\")\n            sorted+=(\"$num\")\n        fi\n    done\n\n    IFS=$'\
    \ \\t'\n    printf '%s\\n' \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -n array=$1\n    local sorted=()\n    for number\
    \ in $array; do\n        sorted+=(\"\\\"$number\\\"\")\n    done\n    echo ${sorted[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmptjfrh1c8.sh: line 15: local: `1 5 2 3 4'': invalid variable name
    for name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arr=( \"${1:-}\" )\n\n  # split array to individual\
    \ elements\n  local -a arr2=( )\n  for (( i=0;  i < ${#arr[@]};  i++ )); do\n\
    \    arr2+=( \"${arr[i]}\" )\n  done\n\n  # sort elements according to number\
    \ of ones in their binary representation\n  arr2=( $(\n    IFS='[- ]'; echo \"\
    ${arr2[*]}\" | \\\n    sort -grn | \\\n    sed 's/^\\([0-9][0-9]*\\)\"$/\\1/'\
    \ | \\\n    sed 's/\"$/\\1/'\n  ) )\n  # sort elements according to decimal value\n\
    \  arr2=( $(\n    IFS='[- ]'; echo \"${arr2[*]}\" | \\\n    sort -rn\n  ) )\n\n\
    \  # join the array elements with space separator\n  printf '%s\\n' \"${arr2[*]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: 'sort: options ''-gn'' are incompatible

    sed: -e expression #1, char 8: invalid reference \1 on `s'' command''s RHS

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local temp=$1\n    local i count\n    declare -a sorted\n\
    \    IFS=$' \\t\\n' read -r -a array <<< \"$temp\"\n    for i in \"${!array[@]}\"\
    ; do\n        count=$((${array[$i]}+1))\n        sorted[$i]=\"${array[$i]}\"\n\
    \        sorted[$((i-1))]=\"${count}\"\n    done\n    IFS=$' \\t\\n' read -r -a\
    \ sorted\n    for idx in \"${!sorted[@]}\"; do\n        echo \"${sorted[idx]}\"\
    \n    done\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=52 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=47 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local string=$1\n  string=$(IFS=,; echo \"$string\"\
    \ | sed -E -n 's/^([-0-9]*)[ ]*([01])[ ]*([-0-9]*)$/\\2,\\1,\\3/p' | sort -n |\
    \ sed 's/^\\(-?[0-9]*\\)\\(\\([0-9]*\\)\\)\\(,[0-9]*\\)$/\\1\\3/' | tr '\\n' ',')\n\
    \  echo \"$string\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n\tlocal -n arr=$1\n\tlocal -n result=\n\n\tarr=(${(s,:,)arr})\n\
    \tresult=(${(I,${IFS}+\"${arr[@]}\")})\n\n\tlocal -n sorted=$result\n\tlocal -n\
    \ tmp\n\tlocal -i count\n\tlocal -a tmp\n\n\tsorted=(${(I,${IFS}+\"${result[@]}\"\
    )})\n\n\tfor i in \"${!sorted[@]}\"; do\n\t\ttmp=\"${sorted[i]}\"\n\t\tcount=0\n\
    \t\twhile (( ${#tmp} > 0 )); do\n\t\t\t(( tmp[-1] == '0' )); tmp=${tmp[:-1]}\n\
    \t\t\t(( ++count )); tmp=${tmp//0/}\n\t\tdone\n\t\tsorted[i]=\"${count}${tmp}\"\
    \n\tdone\n\techo \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp699rp3fg.sh: line 15: local: `1 5 2 3 4'': invalid variable name
    for name reference

    /tmp/tmp699rp3fg.sh: line 16: local: `'': not a valid identifier

    /tmp/tmp699rp3fg.sh: line 18: ${(s,:,)arr}: bad substitution

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n\tlocal output\n\n\toutput=$(echo \"$1\" | tr -d ' ' |\
    \ cut -d' ' -f2)\n\toutput=($(echo \"$output\" | sort -n | cut -d' ' -f2- | sed\
    \ 's/^0*//'))\n\toutput=($(echo \"$output\" | sort -n | cut -d' ' -f1- | sed 's/^1\\\
    ([0-9]*\\)$/\\1/'))\n\n\techo \"$output\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local input=\"$1\"\n  local -a result\n\n  result=()\n\
    \  # Sort array elements while adding sorted elements to the result array\n  for\
    \ i in $(seq 0 \"${#input[@]}\"); do\n    if [[ \"$input[$i]\" =~ ^[0-9]+$ ]];\
    \ then\n      local num=$(echo \"${input[$i]}\" | awk '{print (1 << $0 + $0-1)\
    \ + $0}')\n      # Add sorted elements to the result array\n      result+=(\"\
    ${input[$i]}\")\n      # Sort the rest of elements in the array\n      sort_array\
    \ \"${input[@]:$((${#input[@]}-1))}\"\n      # Remove the sorted elements from\
    \ the array\n      echo \"${input[@]:0:$i}\" \"${result[@]}\"\n    else\n    \
    \  result+=(\"${input[$i]}\")\n    fi\n  done\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=\"$1\"\n    local result=()\n    local count=0\n\
    \    while read x; do\n        # count number of ones\n        ((count += $(echo\
    \ \"$x\" | tr '\\0' '1')));\n    done <<< \"$arr\"\n    # sort based on number\
    \ of ones\n    if [ \"$count\" -gt 0 ]; then\n        echo \"$arr\" | sort -nr\n\
    \    else\n        echo \"$arr\" | sort\n    fi\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpskj5znvf.sh: line 20: ((: count += 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local sorted\n  sorted=$(\n    eval echo \"$1\" |\n\
    \    sort -rnk2,2 |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo\
    \ '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo\
    \ '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"' |\n    eval echo '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"'\"\
    '\"'\"'\"'\"'\"'\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprj1hozm9.sh: line 30: unexpected EOF while looking for matching
    `''''

    /tmp/tmprj1hozm9.sh: line 50: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n\tlocal -n arr=$1\n\tlocal tmp\n\tlocal j\n\tlocal i\n\
    \tlocal c\n\tlocal ret=()\n\tlocal -a map\n\tlocal -a sorted\n\tmap=()\n\tsorted=()\n\
    \twhile IFS=\" \" read -r j i; do\n\t\tmap[$i]=$j\n\tdone < <(echo $arr | sort\
    \ -n -k 2,2)\n\tfor ((i = 0; i < ${#map[@]}; i++)); do\n\t\ttmp=${map[$i]}\n\t\
    \tc=$(printf \"%s\" \"${tmp}\" | awk '{printf \"%d\\n\", length()}')\n\t\tif [\
    \ $c -eq $(cat <<<\"${tmp}\" | wc -c) ]; then\n\t\t\tsorted+=(\"\\\"${map[$i]}\\\
    \"\")\n\t\telse\n\t\t\tsorted+=(\"${map[$i]}\")\n\t\tfi\n\tdone\n\tlocal -r arr_sorted=$(IFS='\
    \ '; echo \"${sorted[*]}\")\n\techo \"$arr_sorted\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpwe32h9px.sh: line 15: local: `1 5 2 3 4'': invalid variable name
    for name reference

    /tmp/tmpwe32h9px.sh: line 31: [: -eq: unary operator expected

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local tmp=( ${1// / } )\n    local i\n    for i in\
    \ ${!tmp[*]}; do\n        local j\n        local count=0\n        for j in ${tmp[*]};\
    \ do\n            [[ \"$i\" = \"$j\" ]] && count=$(( count + 1 ))\n        done\n\
    \        tmp[$i]=$(( ${#tmp[*]} - $count ))\n    done\n    echo ${tmp[*]}\n}\n\
    \ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local sorted_array\n    local\
    \ num_ones_string\n    local dec\n    local i\n    local j\n\n    # count number\
    \ of ones in array\n    num_ones_string=$(echo \"$array\" | tr \" \" \"+\" | tr\
    \ \" \" \"+\" | tr \" \" \"+\" | tr \" \" \"+\" | tr \" \" \"+\" | tr -s \"+\"\
    )\n    num_ones_array=$(echo \"$num_ones_string\" | tr \" \" \"\\n\")\n    num_ones_array=$(echo\
    \ \"$num_ones_array\" | tr -s \"+\" | wc -l)\n\n    # convert all negative to\
    \ positive\n    if [ $num_ones_string == \"-\" ];\n    then\n        num_ones_string=\"\
    $(($num_ones_string + 1))\"\n    fi\n\n    # sort by number of ones\n    sorted_array=$(echo\
    \ \"$array\" | tr \" \" \"+\" | tr \" \" \"+\" | tr \" \" \"+\" | tr \" \" \"\
    +\" | tr -s \"+\")\n    sorted_array=$(echo \"$sorted_array\" | tr \" \" \"\\\
    n\")\n    sorted_array=$(echo \"$sorted_array\" | tr -s \"+\" | sort -n | tr -s\
    \ \"+\")\n    num_ones_array=$(echo \"$num_ones_array\" | tr \" \" \"\\n\")\n\
    \    num_ones_array=$(echo \"$num_ones_array\" | tr -s \"+\" | sort -n | tr -s\
    \ \"+\")\n    dec=$(echo \"$sorted_array\" | tr -s \"+\" | awk '{ print $1/$2\
    \ }')\n\n    # sort by dec\n    for ((i = 0; i < $num_ones_array; i++)); do\n\
    \        sorted_array=$(echo \"$sorted_array\" | awk \"NR >= $i\" '{ print $1/$2\
    \ }')\n    done\n\n    # return sorted array\n    sorted_array=$(echo \"$sorted_array\"\
    \ | tr -s \"+\" | tr -s \" \")\n    echo $sorted_array\n}\n\ncandidate() {\n \
    \   sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3\
    \ 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6\
    \ -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate\
    \ \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4\
    \ 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12\
    \ 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: division by zero attempted

    awk: fatal: cannot open file `{ print $1/$2 }'' for reading (No such file or directory)

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input_array=\"$1\"\n    local output_array=()\n\
    \    local sorted_array=()\n    local current_val\n    local current_position\n\
    \n    while read -a current_element; do\n        current_position=${current_element[0]}\n\
    \        current_val=${current_element[1]}\n        case \"$current_position\"\
    \ in\n            1)\n                if [ \"$current_val\" = \"1\" ]; then\n\
    \                    sorted_array+=(\"\\\"${current_val}\\\"\")\n            \
    \    else\n                    sorted_array+=(\"\\\"$current_val\\\"\")\n    \
    \            fi\n                ;;\n            *)\n                if [ \"$current_val\"\
    \ -gt \"0\" ]; then\n                    sorted_array+=(\"\\\"$current_val\\\"\
    \")\n                else\n                    sorted_array+=(\"\\\"$current_val\\\
    \")\n                fi\n                ;;\n        esac\n    done\n\n    IFS=$'\\\
    n' output_array=($(sort <<<\"${sorted_array[*]}\"))\n    echo \"${output_array[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpuy89ccls.sh: line 59: unexpected EOF while looking for matching
    `"''

    /tmp/tmpuy89ccls.sh: line 63: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"${1}\"\n    local -a sorted\n    sorted=()\n\
    \    local i\n    i=0\n    while [[ ${array[i]} ]] && [[ ${array[i]} != \" \"\
    \ ]]; do\n        sorted+=( \"${array[i]}\" )\n        (( i++ ))\n    done\n \
    \   sort -n \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sort: cannot read: ''1 5 2 3 4'': No such file or directory

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local result=$(IFS='' xargs -0 \"$1\" | \\\n     \
    \   awk '{ for (i=1; i<NF; i++) { for (j=0; j<length($i); j++) if ($i ~ /^0*(.).*/)\
    \ { ones = ones + substr($i, j, 1); break } } if (ones > 0) { a[ones] = $0; ones=0\
    \ } END { for (i in a) print a[i] } }' | \\\n        sort -n)\n\n    [[ \"$?\"\
    \ -eq 0 ]] || exit 1\n\n    echo \"$result\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=45 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=15 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local result=$(printf \"%s\\n\" $1 | \\\n    sort -n\
    \ | \\\n    awk '{ split($0, a, \"01\"); print a[1] \"-\" a[2]; }' | \\\n    sed\
    \ \"s/-/ /g\" | \\\n    awk '{ for(i = 2; i < NF; ++i) print $i; }')\n  echo $result\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    arr=( $1 )\n    len=${#arr[@]}\n    res=()\n    while\
    \ [[ $len -gt 1 ]]; do\n        ones=0\n        idx=0\n        while [[ $idx -lt\
    \ $len ]]; do\n            (( ${arr[idx]} == 0 )) && { ones++; idx=$(($idx + 1));\
    \ }\n            (( ${arr[idx]} == 1 )) && { idx=$(($idx + 1)); }\n          \
    \  idx=$(($idx + 1))\n        done\n        (( $ones > 0 )) && res+=($(echo $arr[idx]))\n\
    \        arr=( ${arr[@]:0:$idx} )\n        len=$(($len - $idx))\n    done\n  \
    \  res+=( ${arr[@]:0:$len} )\n    res=( \"${res[@]}\" )\n    echo \"${res[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=\"$1\"\n    local input\n    local -a sorted_array\n\
    \    local count\n\n    for input in \"$@\"; do\n        while read -n 1 char;\
    \ do\n            ((count[char]++))\n        done\n        sorted_array+=(\"${input[@]:1}\"\
    )\n    done\n\n    IFS=$'\\n'\n    echo \"${sorted_array[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=67 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=65 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -a arr\n    local i arr\n    local -a sorted\n\
    \    local dec bin\n    arr=($(echo \"$1\" | sed 's/ /\",\"/g'))\n    for ((i=0;\
    \ i<${#arr[@]}; i++)); do\n        bin=$((${arr[i]}-1))\n        dec=$(echo \"\
    obase=2;ibase=10;$bin\" | bc)\n        if (( ${dec} == ${bin} )) ; then\n    \
    \        sorted+=(\"${arr[i]}\")\n        fi\n    done\n    echo ${sorted[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpnq0ytuvu.sh: line 21: 1","5","2","3","4-1: syntax error: invalid
    arithmetic operator (error token is "","5","2","3","4-1")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -i arrayLength=\"$1\"\n  local -i arrayIndex=0\n\
    \  local -i arrayValue=0\n  local -a sortedArray\n\n  sortedArray=()\n\n  while\
    \ [[ $arrayIndex -le $arrayLength ]]; do\n    arrayValue=`echo \"${array[$arrayIndex]}\"\
    \ | awk '{print ($1 == \"1\") ? \"0\" : \"1\"}'`\n    sortedArray+=( $arrayValue\
    \ )\n    (( arrayIndex++ ))\n  done\n\n  echo \"${sortedArray[@]}\"\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpf61fnj1e.sh: line 15: local: 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local xs=\"$1\"\n    local xs\n    local len\n   \
    \ local count\n    local d\n    local a\n    local b\n    local ret\n    local\
    \ i\n    local j\n\n    xs=$(echo \"$xs\" | sed 's/[[:space:]]/ /g' | sort -n)\n\
    \    len=\"${#xs[@]}\"\n\n    count=0\n    d=\"$(for ((i=0; i < len; i++)); do\n\
    \        x=${xs[$i]}\n        ((count+=x))\n    done)\"\n\n    a=\"$(for ((i=0;\
    \ i < len; i++)); do\n        x=${xs[$i]}\n        [[ $((count)-=x)) -eq 0 ]]\
    \ && echo $x\n    done)\"\n\n    b=\"$(for ((i=0; i < len; i++)); do\n       \
    \ x=${xs[$i]}\n        [[ $((count)+=x)) -eq 0 ]] && echo $x\n    done)\"\n\n\
    \    ret=\"$(echo \"$a\" | sed 's/[[:space:]]/ /g' | sort -n)\"\n    [[ -z $ret\
    \ ]] && ret=\"$b\"\n\n    echo \"$ret\"\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp4s_ctjnn.sh: line 35: ((: 1 5 2 3 4: syntax error in expression
    (error token is "5 2 3 4")

    /tmp/tmp4s_ctjnn.sh: command substitution: line 41: syntax error in conditional
    expression: unexpected token `)''

    /tmp/tmp4s_ctjnn.sh: command substitution: line 41: syntax error near `$((count)-=x))''

    /tmp/tmp4s_ctjnn.sh: command substitution: line 41: `        [[ $((count)-=x))
    -eq 0 ]] && echo $x''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n\n    local IFS=' ' #input field\
    \ separator\n    local array=() #array itself\n\n    # for each item in the input\
    \ list, split the item into single integer\n    # and store it into array\n  \
    \  for item in $input; do\n        local temp=() #temp variable for storing single\
    \ integer\n\n        # for each digit in the item, read each digit into temp\n\
    \        # if the digit is one then store it into array\n        # and continue\
    \ to the next item\n        for ((digit=0; digit<${#item}; digit++)); do\n   \
    \         local temp_digit=\"${item:$digit:1}\" #temporary variable for single\
    \ digit\n            if [ \"$temp_digit\" = \"1\" ]; then\n                temp+=(\
    \ $temp_digit )\n                continue 2\n            fi\n        done\n\n\
    \        # if the item is all one digits then store it into array\n        temp+=(\
    \ $item )\n        array+=( \"$temp\" )\n    done\n\n    # sort array according\
    \ to number of ones\n    # sort based on the decimal number\n    # it has to be\
    \ implemented like this\n    # >>> $(sort_array \"1 5 2 3 4\")\n    # ['\"1\"\
    ', '\"2\"', '\"3\"', '\"4\"', '\"5\"']\n    # >>> $(sort_array \"-2 -3 -4 -5 -6\"\
    )\n    # ['\"-6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n    # >>> $(sort_array\
    \ \"1 0 2 3 4\")\n    # ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n    local\
    \ ones_count=$(sort_one_count \"${array[@]}\")\n    local sorted_array=()\n  \
    \  for ((i=0; i<${#ones_count[@]}; i++)); do\n        local item=\n        for\
    \ ((j=0; j<${#ones_count[@]}; j++)); do\n            if [[ ${ones_count[j]} -gt\
    \ ${ones_count[i]} ]]; then\n                item=${ones_count[j]}\n         \
    \       break\n            fi\n        done\n        sorted_array+=( \"$item\"\
    \ )\n    done\n\n    # print sorted array\n    for ((i=0; i<${#sorted_array[*]};\
    \ i++)); do\n        echo \"${sorted_array[i]}\"\n    done\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpxz7hxtza.sh: line 50: sort_one_count: command not found

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  echo \"$1\" | tr \" \" \"\\n\" | sort -n | while read\
    \ line\n  do\n    count=0\n    for n in $line\n    do\n      if [ $n -eq 1 ]\n\
    \      then\n        count=$(($count + 1))\n      fi\n    done\n    if [ $count\
    \ -gt 1 ]\n    then\n      echo \"$line\"\n    fi\n  done\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local a\n    local i=0 j=0\n    local -a sorted\n\
    \    local d=0\n    local s=\"\"\n    local count=0\n\n    while read -a a; do\n\
    \        (( i = i + 1 ))\n        if (( i == 1 )); then\n            # this case\
    \ is for 1 one\n            d=0\n        else\n            # this case is for\
    \ non-ones\n            (( d = d + 1 ))\n        fi\n        s=$s$a\n    done\
    \ <<< \"$1\"\n\n    i=0\n    while (( i < ${#s} )) ; do\n        # count the number\
    \ of ones in the string\n        count=$(grep -c \"1\" <<< \"$s\")\n        if\
    \ (( count > 0 )); then\n            # there are one or more ones in the string\n\
    \            j=0\n            while (( j < ${#s} )) ; do\n                if [[\
    \ \"$s\" == \"${s[@]:j:1}\" ]]; then\n                    break\n            \
    \    fi\n                j=$(( j + 1 ))\n            done\n            (( j =\
    \ j + 1 ))\n            # sort by the number of ones\n            sorted[$(( i\
    \ - 1 ))]=\"${s:$j:1}\"\n            (( j = 0 ))\n        else\n            #\
    \ there are no ones in the string\n            sorted[$i]=\"$s\"\n        fi\n\
    \        (( i = i + 1 ))\n        s=$(grep \"1\" <<< \"$s\")\n    done \n    echo\
    \ \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpz09sy3jg.sh: line 49: sorted[$(( i - 1 ))]: bad array subscript

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    sort -n -g | sed 's/^/\"${1}\" /' > /tmp/sorted.list\n\
    \    mv /tmp/sorted.list $1\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'sort: options ''-gn'' are incompatible

    mv: target ''4'' is not a directory

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local L=$1\n    for (( i=0; i<${#L[*]}; i++ ))\n \
    \   do\n        if [[ ${L[i]} == '1' ]]; then\n            posOnesCount=$(( posOnesCount\
    \ + 1 ))\n        else\n            if (( posOnesCount > 0 ))\n            then\n\
    \                sortByDec=$(( sortByDec * 10 ))\n            fi\n           \
    \ posOnesCount=0\n            sortByDec=$(( sortByDec + ${L[i]} ))\n        fi\n\
    \    done\n    if (( sortByDec > 0 ))\n    then\n        sortByDec=$(( sortByDec/10\
    \ ))\n    fi\n    res=()\n    for (( j=0; j<${#L[*]}; j++ ))\n    do\n       \
    \ if [[ ${L[j]} == '1' ]]; then\n            res+=(\\\"${L[j]}\\\")\n        else\n\
    \            if (( ${posOnesCount} > 0 ))\n            then\n                res+=(\\\
    \"${sortByDec}${L[j]}\\\")\n            fi\n            posOnesCount=0\n     \
    \       sortByDec=$(( sortByDec - ${L[j]} ))\n        fi\n    done\n    echo ${res[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5gv_qrl9.sh: line 26: sortByDec + 1 5 2 3 4 : syntax error in expression
    (error token is "5 2 3 4 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local input_array=\"$1\"\n  local output_array=()\n\
    \  local temp_array=()\n\n  for value in $(echo $input_array | tr \" \" \"\\n\"\
    ); do\n    temp=()\n    digit=0\n\n    while (( $value >= 1 )); do\n      (( value\
    \ >>= 1 ))\n      (( digit++ ))\n    done\n\n    temp+=(\"\\\"$digit\\\"\")\n\
    \  done\n  unset value\n  unset digit\n  unset temp\n\n  temp_array=$(sort --field-separator=\"\
    |\" <<<\"${temp_array[*]}\")\n  for value in $(echo $temp_array | tr \" \" \"\\\
    n\"); do\n    output_array+=(\"$value\")\n  done\n  unset temp_array\n  echo ${output_array[@]}\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  echo \"$1\" | awk '{print substr($1, length($1)/2, 2),\
    \ length($1)/2}'\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Convert the passed string into array of its components\n\
    \  local array=(${1//\" \"/})\n\n  # Add \"0\" to make all components a non-negative\
    \ integers\n  for ((i=0; i<${#array[@]}; i++)); do\n    if [[ \"${array[$i]}\"\
    \ =~ ^-?[0-9]+$ ]]; then\n      array[$i]=\"${array[$i]}0\"\n    elif [[ \"${array[$i]}\"\
    \ =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n      array[$i]=\"${array[$i]}.0\"\n    fi\n\
    \  done\n\n  # Convert the array of non-negative integers into sorted ones\n \
    \ local sorted=()\n  for ((i=0; i<${#array[@]}; i++)); do\n    sorted+=(${array[i]})\n\
    \  done\n\n  # Sort based on number of ones in their binary representation\n \
    \ local count=-1\n  for ((i=0; i<${#sorted[@]}; i++)); do\n    ((count++))\n \
    \   if [[ ${sorted[$i]} == 1 ]]; then\n      sorted[$((count-1))]=${sorted[$((count-1))]}0\n\
    \    fi\n  done\n\n  # Sort based on decimal value\n  local value=0\n  for ((i=0;\
    \ i<${#sorted[@]}; i++)); do\n    ((value+=${sorted[$i]}))\n  done\n  local sorted=()\n\
    \  for ((i=0; i<${#sorted[@]}; i++)); do\n    ((value+=1))\n    sorted+=(${value})\n\
    \  done\n\n  # Return sorted string\n  printf '%s\\n' \"${sorted[@]}\"\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    arr=$1\n    # arr=$(echo ${arr} | tr ' ' '\\n')\n\
    \    arr=$(echo \"${arr}\" | tr -s ' ')\n    local sorted_arr\n    sorted_arr=($(sort\
    \ -n -k 2 <<<\"${arr}\" | tr -d \"\\n\"))\n    echo ${sorted_arr}\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local array=\"$1\"\n    local -n result\n    local\
    \ i\n    local -a arr\n    arr=($array)\n    result=()\n    for ((i=0; i < ${#arr[@]};\
    \ i++)); do\n        local -n val\n        val=$(echo \"${arr[$i]}\" | tr '[0\
    \ 1]' '[2 1]')\n        result+=(\"\\\"${val}\\\"\")\n    done\n    echo \"${result[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpt9dma7xv.sh: line 20: warning: result: removing nameref attribute

    /tmp/tmpt9dma7xv.sh: line 23: `1'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    IFS=\" \" read -r -a array <<< \"$1\"\n    for element\
    \ in \"${array[@]}\"; do\n        (( binary=\"${element:0:1}\" ))\n        ((\
    \ ones=\"${element:1:1}\" ))\n        if [[ \"$ones\" == \"1\" ]]; then\n    \
    \        array=${array[*]}\" \"${array[*]}\"\n        fi\n    done\n    echo \"\
    ${array[*]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp0_lfomo6.sh: line 39: unexpected EOF while looking for matching
    `"''

    /tmp/tmp0_lfomo6.sh: line 43: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    IFS=', ' read -r -a array <<< \"$1\"\n    for idx\
    \ in \"${!array[@]}\"; do\n        ones=$(echo \"${array[$idx]}\" | grep -o '^1$')\n\
    \        dec=$(echo \"${array[$idx]}\" | grep -o '^-?[[:digit:]]+$')\n       \
    \ (( $ones > 0 && $ones < 256 )) && echo \"${array[$idx]}\"\n        (( $dec >\
    \ 0 && $dec < 256 )) && echo \"${array[$idx]}\"\n    done\n}\n\ncandidate() {\n\
    \    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2\
    \ 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2\
    \ -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[\
    \ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\")\
    \ = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp64e2p4fp.sh: line 20: ((: > 0 &&  < 256 : syntax error: operand
    expected (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 19: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 20: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 19: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 20: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 19: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 20: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 19: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    /tmp/tmp64e2p4fp.sh: line 20: ((: > 0 &&  < 256 : syntax error: operand expected
    (error token is "> 0 &&  < 256 ")

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  echo \"$1\" |\n    tr ' ' '\\n' |\n    sort -nr -k 2\
    \ |\n    sed -e 's/^[0-9]*\\(.*\\)$/\\1\"/g' -e 's/^\\([0-9]*\\)$/\\1/g'\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=\" \"\n    local -n arr=$1\n    local result\n\
    \    local item\n    for result in $(seq 0 $((${#arr[@]} -1))); do\n        item=\"\
    ${arr[$result]}\"\n        if ! [ \"$item\" -eq \"${arr[$((result+1)) -1]}\" ];\
    \ then\n            arr[$((result+1))]=\"$item\"\n        fi\n    done\n    echo\
    \ \"${arr[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp6vddmzf8.sh: line 16: local: `1 5 2 3 4'': invalid variable name
    for name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -n result=$1 sorted=()\n    local i j k\n  \
    \  for (( i = 0; i < ${#result}; ++i )); do\n        sorted+=( ${result[i]} )\n\
    \    done\n    local k=0\n    while (( k < ${#sorted[@]}-1 )); do\n        if\
    \ (( ${sorted[k]} == ${sorted[k+1]} )); then\n            (( sorted[k] = ${sorted[k+1]}\
    \ )\n            (( k+=1 ))\n        else\n            for (( j=k+1; j<${#sorted[@]};\
    \ ++j )); do\n                if (( ${sorted[j]} < ${sorted[k]} )); then\n   \
    \                 sorted[k]=${sorted[j]}\n                    (( k = j ))\n  \
    \              fi\n            done\n        fi\n    done\n    for (( i = ( ${#sorted[@]}\
    \ - 2 ); i >= 0; --i )); do\n        sorted[${#sorted[@]}+$i]=${sorted[i]}\n \
    \   done\n    result=( \"${sorted[@]}\" )\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpla9uv32o.sh: line 24: syntax error near unexpected token `(''

    /tmp/tmpla9uv32o.sh: line 24: `            (( k+=1 ))''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local IFS=' '\n  local sorted_array=()\n  local input_array=$1\n\
    \  local num_ones=0\n  local decimal_digits=0\n  local digits_array=()\n  while\
    \ read -r digit; do\n    digits_array+=(\"$digit\")\n    num_ones+=$(echo \"$digit\"\
    \ | grep -c '1')\n    decimal_digits+=$(echo \"$digit\" | grep -c '0') | bc\n\
    \  done <<< \"$input_array\"\n  # sort based on num_ones\n  local num_ones_array=()\n\
    \  while read -r num_one; do\n    num_ones_array+=(\"$num_one\")\n  done <<< \"\
    $num_ones\"\n  local max_num_of_ones=$(echo \"${#num_ones_array[@]}\" | bc -l)\n\
    \  (( \"${max_num_of_ones%.*}\" ))\n  local decimal_digits_array=()\n  while read\
    \ -r decimal_digit; do\n    decimal_digits_array+=(\"$decimal_digit\")\n  done\
    \ <<< \"$decimal_digits\"\n  printf -v sorted_array '%%s' \"${num_ones_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${decimal_digits_array[*]}\"\n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\
    \n  printf -v sorted_array '%%s' \"${sorted_array[*]}\"\n  printf -v sorted_array\
    \ '%%s' \"${sorted_array[*]}\"\n\n}\n\ncandidate() {\n    sort_array \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local list=$1\n    local i\n    local length\n   \
    \ local max\n\n    list=$(echo $list | sed 's/ /\\n/g')\n    list=$(echo $list\
    \ | sed 's/^\\|$//g')\n\n    while read line\n    do\n        # Split into array\
    \ elements\n        IFS=\"|\" read -a array <<< $line\n        length=${#array[@]}\n\
    \n        # Count number of ones in the binary representation\n        max=0\n\
    \        for ((i = 0; i < $length; i++)); do\n            if [ ${array[$i]} =\
    \ \"1\" ]; then\n                let max=$max+1\n            fi\n        done\n\
    \n        # Sort based on number of ones\n        if [ $max -gt 0 ]; then\n  \
    \          for ((i = 0; i < $length; i++)); do\n                if [ ${array[$i]}\
    \ = \"1\" ]; then\n                    local j=i\n                    while [\
    \ $j -le $length -1 -a ${array[$j]} = \"1\" ]; do\n                        let\
    \ j=j+1\n                    done\n                    local temp=${array[$i]}\n\
    \                    array[$i]=${array[$j]}\n                    array[$j]=${temp}\n\
    \                fi\n            done\n        fi\n\n        # Sort based on decimal\
    \ value\n        if [ $max -gt 1 ]; then\n            for ((i = 0; i < $length;\
    \ i++)); do\n                if [ ${array[$i]} = \"1\" ]; then\n             \
    \       local j=i\n                    while [ $j -le $length -1 -a ${array[$j]}\
    \ > 0 ]; do\n                        let j=j+1\n                    done\n   \
    \                 local temp=${array[$i]}\n                    array[$i]=${array[$j]}\n\
    \                    array[$j]=${temp}\n                fi\n            done\n\
    \        fi\n\n        # Convert back to string and print\n        IFS=\"|\" read\
    \ -a array <<< \"${array[@]}\"\n        echo \"${array[@]}\"\n    done\n}\n\n\
    candidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=54 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=18 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  # Your code here\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpgv7q0c_6.sh: line 16: syntax error near unexpected token `}''

    /tmp/tmpgv7q0c_6.sh: line 16: `}''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local line\n    local output\n    local numbers_as_string\n\
    \    local one_as_number\n\n    IFS=$'\\n' line=\"$1\"\n    output=\"$(sort <<<\"\
    $line\")\"\n    numbers_as_string=\"$(tr -d '\\0' <<<\"$line\")\"\n    one_as_number=\"\
    $(echo \"$numbers_as_string\" | awk '{print length($1)}')\"\n\n    local decimal\n\
    \    for decimal in $(echo \"$one_as_number\" | sort -n -k 1 -k 2 | awk '{print\
    \ $1+$2}'); do\n        case \"$decimal\" in\n            1) echo \"$output\"\
    \ | awk -F\"[\"] $decimal\" '{print $2}' ;;\n            2) echo \"$output\" |\
    \ awk -F\"[\"] $decimal\" '{print $1}' ;;\n        esac\n    done\n}\n\ncandidate()\
    \ {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\
    \ 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4\
    \ -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n   \
    \ [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\"\
    ) = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"\
    32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: fatal: invalid regexp: Unmatched [, [^, [:, [., or [=: /[]/

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    arr=$1\n    arr=(${arr// /})\n    for val in ${arr[@]};\
    \ do\n        bits=$(echo \"$val\" | sed -E \"s/^[^1]*([1-9])\\1$/\\1/\")\n  \
    \      dec=$(echo \"$bits\" | sed -E \"s/^[^0]*(0*)(.*)$/\\1/\")\n        bits=$(echo\
    \ \"$dec\" | sed -E \"s/^(.*)\\1(.*)$/\\1/\")\n        echo \"$bits\"\n    done\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    echo \"$1\" | tr ' ' '\\n' | sort -n | tr ' ' '\\\
    n'\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3\
    \ -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"\
    0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    IFS=\" \"\n    mapfile -t array <<< \"$1\"\n    for\
    \ element in \"${array[@]}\"; do\n        # Use Bash builtin parameter expansion\
    \ to find number of ones\n        # in binary representation of current element\n\
    \        ones=\"${(${element:-0}):-0}\"\n        sorted=\"$(echo \"$ones\" | tr\
    \ 1 0)\"\n        sort-values \"$sorted\"\n    done\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp8183kont.sh: line 20: ${(${element:-0}):-0}: bad substitution

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=($1)\n    length=$((${#array[@]}))\n    sorted_array=()\n\
    \    # sort from most significant to the least significant\n    for (( i=length-1;\
    \ i>0; i-- )); do\n        array_index=$(printf \"%02d\" $i)\n        binary_string=$(printf\
    \ \"%.${i}b\" ${array[$i]})\n        ones=$(printf \"%d\" ${binary_string::-1})\n\
    \        if [[ ${ones} -ge 1 ]]; then\n            sorted_array=(\"${sorted_array[@]}\"\
    \ \"$array_index\")\n        fi\n    done\n    echo -n \"\\\"${sorted_array[*]}\\\
    \"\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2\
    \ -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") =\
    \ \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=\"$1\"\n    local len=\"${#arr}\"\n    if\
    \ [ \"${len}\" -eq \"0\" ]; then\n        echo \"$arr\"\n        return\n    fi\n\
    \n    local ones=\n    local dec=\n    local i=0\n    while [ $i -lt \"$len\"\
    \ ]; then\n        local b\n        b=\"${arr:$i:1}\"\n        if [ \"$b\" ==\
    \ \"0\" ]; then\n            ones=\"$ones $b\"\n        else\n            dec=\"\
    $dec $b\"\n        fi\n        i=$(($i+1))\n    done\n\n    local sorted\n   \
    \ if [ \"$ones\" != \"0\" ]; then\n        sorted=$(printf \"\\\"%s\\\" $ones\
    \ |sort\" \"$dec\")\n    else\n        sorted=$(printf \"\\\"%s\\\" |sort\" \"\
    $dec\")\n    fi\n\n    arr=\"$(echo \"$sorted\" | awk '{print $2}')\"\n    echo\
    \ \"$arr\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpkkrwqcsj.sh: line 25: syntax error near unexpected token `then''

    /tmp/tmpkkrwqcsj.sh: line 25: `    while [ $i -lt "$len" ]; then''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local str=\"$1\"\n    local count=\"$(echo \"$str\"\
    \ | awk '{print length($0)}')\"\n    echo \"$str\" | awk -F'[^1]+' '{print $1,\
    \ length($1)}'\n    local sorted=\"$(\n        echo \"$str\" | awk -F'[^1]+' '{\n\
    \            for (i=1; i<=count; i++)\n                if ($i == 1)\n        \
    \            printf $i\n                else\n                    printf \"%i%1i\"\
    , $i, length($i) * $i\n                fi\n            }'\n    )\"\n    local\
    \ decimal=\"$(echo \"$sorted\" | awk '{printf \"%i\", $1}')\"\n    echo \"$sorted\"\
    \n    echo \"$decimal\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    # Your code here\n    local array=\"$1\"\n    echo\
    \ \"${array//[! -z $array ]}\"\n    local -i len=${#array}\n    local i\n    local\
    \ -a array2\n    local result\n    array2=($(echo \"${array}\" | sed 's/ //g'))\n\
    \    for ((i=0;i<${len};i++)); do\n        result=\"$(echo \"${array2[i]}0\" |\
    \ bc)\"\n        array2[i]=\"$(echo \"${array2[i]}1\" | bc)\"\n        array2[$i]=\"\
    $(echo \"${result}${array2[i]}\" | bc)\"\n    done\n    array=\"${array2[@]}\"\
    \n    echo \"${array//[! -z $array ]}\"\n}\n\ncandidate() {\n    sort_array \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3\
    \ 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n   \
    \ [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") =\
    \ \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5\
    \ 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array num_ones\n  local -a indices\n\n  IFS=$'\
    \ \\t\\n'\n  num_ones=($1)\n\n  indices=()\n  for ((i=1; i<${#num_ones[*]}; i++));\
    \ do\n    indices+=(\"${i} ${num_ones[i]}\")\n  done\n\n  unset num_ones\n  printf\
    \ '%s\\n' \"${indices[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n \
    \   [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    array=\"$1\"\n    shift\n\n    count\n    dec\n}\n\
    \ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp4szdyaaw.sh: line 18: count: command not found

    /tmp/tmp4szdyaaw.sh: line 19: dec: command not found

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local arr=(\"${@:2}\")\n    local i j count result\
    \ arr_size\n\n    arr_size=\"${#arr[@]}\"\n    for ((i=0; i < arr_size; i++));\
    \ do\n        count=$(printf '%d' \"${arr[i]}\")\n        result=''\n        for\
    \ ((j=0; j < i; j++)); do\n            if [ \"${count}\" -gt \"0\" ]; then\n \
    \               if [ \"$count\" -gt \"1\" ]; then\n                    result=\"\
    ${result} ${arr[j]}\"\n                    count=$(echo \"${count} - 1\" | bc)\n\
    \                else\n                    result=\"${result} ${arr[j]}\"\n  \
    \                  count=$((${count}-1))\n                fi\n            else\n\
    \                if [ \"$count\" -lt \"0\" ]; then\n                    result=\"\
    ${result} ${arr[j]}\"\n                    count=$(echo \"${count} + 1\" | bc)\n\
    \                else\n                    result=\"${result} ${arr[j]}\"\n  \
    \                  count=$((${count}+1))\n                fi\n            fi\n\
    \        done\n        arr[i]=\"${result}\"\n    done\n    echo \"${arr[@]}\"\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local array sorted\n  local count\n\n  array=$(echo\
    \ $1 | tr \" \" \",\")\n  sorted=()\n  count=0\n  for element in ${array[@]};\
    \ do\n    if [[ $element == *\"-\"* ]]; then\n      sorted+=(\"$element\")\n \
    \     count=$((count + 1))\n    else\n      sorted+=(\"\\\"$element\\\")\"\n \
    \   fi\n  done\n  if (( count > 1 )); then\n    sorted+=(\"\\\"$((count - 1))\\\
    \"\")\n  fi\n  echo \"${sorted[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp15_0swtr.sh: line 29: syntax error near unexpected token `(''

    /tmp/tmp15_0swtr.sh: line 29: `  if (( count > 1 )); then''

    /tmp/tmp15_0swtr.sh: line 31: syntax error near unexpected token `fi''

    /tmp/tmp15_0swtr.sh: line 31: `  fi''

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    IFS= read -r line\n    array=()\n    for element in\
    \ $line; do\n        binary=\"${element:0:${#element}-1}\"\n        decimal=\"\
    ${element:${#binary}-1}\"\n        array+=($((${#binary}+${decimal})))\n    done\n\
    \    IFS=' '\n    sort -nr -k ${array[@]}\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=70 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=68 encoding='utf-8'>
  timestamp: 1660056503
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local IFS=$1; shift\n    local -n list=$1; shift\n\
    \    local sorted=$(for item in $list; do echo $((${item//0/0} & ${item//1/1}\
    \ || ${item})); done)\n    local sorted=($(sort <<<$sorted))\n    local -n num=$1;\
    \ shift\n    local -n str=$1; shift\n    IFS=$IFS\n    local -n length=${#str}\n\
    \    local -n pos=0\n    for (( i=1; i<${#sorted[@]}; i++ )); do\n        local\
    \ item=${sorted[$i]}\n        local count=${num[$item]}\n        local index=$((pos+count-1))\n\
    \        while (( index>0 )) && (( num[$sorted[index]] == 0 )) && [[ -n $sorted[index-1]\
    \ ]]; do\n            index=${sorted[index-1]}\n        done\n        if (( index\
    \ == 0 )); then\n            sorted[$i]=$str\n        else\n            sorted[$i]=\"\
    ${str#*$sorted[index]}\"\n            sorted[$i]=\"$sorted[$i]$sorted[$((pos+count))]\"\
    \n        fi\n        pos=$((pos+count))\n    done\n    echo \"${sorted[@]}\"\n\
    }\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") =\
    \ \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n\
    \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3\
    \ 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\"\
    ) = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp8v26iing.sh: line 16: local: `'': not a valid identifier

    /tmp/tmp8v26iing.sh: line 19: local: `'': not a valid identifier

    /tmp/tmp8v26iing.sh: line 20: local: `'': not a valid identifier

    /tmp/tmp8v26iing.sh: line 22: local: `0'': invalid variable name for name reference

    /tmp/tmp8v26iing.sh: line 23: local: `0'': invalid variable name for name reference

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local input=\"$1\"\n    local output=''\n    local\
    \ -a binary\n    local -a decimal\n    local -a sorted_ones\n    local -a sorted_decimal\n\
    \    local -a sorted_sorted_ones\n\n    echo \"$input\" | while read -r line;\
    \ do\n        binary=( ${line//[^01]/ } )\n        decimal=(${binary[@]:1})\n\n\
    \        # If number of ones in current line in descending order\n        if ((\
    \ ${#binary[@]} > 0 )); then\n            sorted_decimal+=( $(printf \"%04d \"\
    \ \"${decimal[@]}\") )\n        else\n            sorted_decimal+=( $(printf \"\
    %2d \" \"${decimal[@]}\") )\n        fi\n    done\n    IFS=' ' read -r -a sorted_ones\
    \ < <( printf '%s\\n' \"${sorted_decimal[@]}\" | sort -n -k 1 -k 2 -k 3 )\n\n\
    \    # If the number of ones in descending order matches the number of ones\n\
    \    # in the ascending order, sort based on decimal values\n    if (( ${#binary[@]}\
    \ > 0 )); then\n        sorted_sorted_ones=( $(printf \"%s\" \"${sorted_ones[@]}\"\
    \ ) )\n    else\n        sorted_sorted_ones=( $(printf \"%s\" \"${sorted_ones[@]}\"\
    \ ) )\n    fi\n    IFS=' ' read -r -a sorted_sorted_ones < <( printf '%s\\n' \"\
    ${sorted_sorted_ones[@]}\" | sort -n -k 1 -k 2 -k 3 )\n\n    # If the number of\
    \ ones in descending order is less than the number\n    # of ones in the ascending\
    \ order, sort based on decimal values\n    if [[ \"${#sorted_sorted_ones[@]}\"\
    \ -gt \"${#sorted_ones[@]}\" ]]; then\n        sorted_sorted_ones=( $(printf \"\
    %s\" \"${sorted_sorted_ones[@]}\" ) )\n    else\n        sorted_sorted_ones=(\
    \ $(printf \"%s\" \"${sorted_sorted_ones[@]}\" ) )\n    fi\n    IFS=' ' read -r\
    \ -a sorted_sorted_ones < <( printf '%s\\n' \"${sorted_sorted_ones[@]}\" | sort\
    \ -n -k 1 -k 2 -k 3 )\n\n    # Output the sorted array\n    echo \"${sorted_sorted_ones[@]}\"\
    \n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
    \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1\
    \ 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77\
    \ 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6\
    \ 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local arg=\"$1\"\n  local -a arr\n  local i\n  local\
    \ n\n  local -a res\n  local tmp\n  local j\n  local -a val\n  local v\n  local\
    \ k\n  local resstr\n  resstr=\"'\"\n  # Split argument on spaces, store them\
    \ in array arr\n  arr=($(IFS=$'\\n'; echo \"${arg}\" | sed 's/^ *//;s/ *$//'))\n\
    \  # Count the number of ones in each element of arr\n  i=0\n  for v in \"${arr[@]}\"\
    ; do\n    (( i++ ))\n  done\n  # Reverse sort the elements with most ones first\n\
    \  for v in \"${arr[@]}\"; do\n    if (( n=$(( $i - $i | bc )) )) ; then\n   \
    \   (( k=$(( $n - $i )) ))\n      for (( j=$(( $i-1 )); j>=0; j-- )); do\n   \
    \     tmp=(\"${resstr}\"${v})\n        (( v=$(( v-n )) ))\n        (( k--))\n\
    \        res=(\"${res}\"${tmp})\n      done\n      (( i-- ))\n    else\n     \
    \ tmp=(\"${resstr}\"${v})\n      (( k=$(( $i - $i | bc )) ))\n      for (( j=$((\
    \ $i-1 )); j>=0; j-- )); do\n        tmp=(\"${resstr}\"${v})\n        (( v=$((\
    \ v-k )) ))\n        (( k--))\n        res=(\"${res}\"${tmp})\n      done\n  \
    \  fi\n  done\n  echo \"${res[@]}\"\n}\n\ncandidate() {\n    sort_array \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\"\
    \ ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 2
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    IFS=' ' read -r -a array <<< \"$1\"\n    local length=\"\
    ${#array[@]}\"\n    local index\n    local count\n    local string\n\n    for\
    \ index in $(seq 0 $((length - 1)))\n    do\n        count=$(echo \"${array[index]}\"\
    \ | tr '[:lower:]' '[:upper:]' | sed -e 's/^[[:digit:]]*://')\n        if [[ \"\
    $count\" == \"1\" ]]\n        then\n            string=\"$string'\\\"'\\\"${array[index]}\"\
    \n        elif [[ \"$count\" == \"0\" ]]\n        then\n            string=\"\
    $string'\\\"'\\\"${array[index]}\"\n        else\n            string=\"$string'\\\
    \"'\\\"${array[index]}\"'\\\"'\\\"${array[index]}\"\n        fi\n    done\n  \
    \  eval \"$string\"\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate\
    \ \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\"\
    ) = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"\
    2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate\
    \ \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\"\
    ) = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpnfixzp0b.sh: line 50: unexpected EOF while looking for matching
    `"''

    /tmp/tmpnfixzp0b.sh: line 54: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    local -a arr=(\"${@}\")\n    local -i len=${#arr[@]}\n\
    \    local i j\n    local tmp tmp2\n    local output\n    tmp=$(echo \"${arr[*]}\"\
    \ | awk '{printf \"%d%s\", $1, $1}')\n    tmp2=$(echo \"${arr[*]}\" | awk '{printf\
    \ \"%d%s\", $1, $1}' | sort -n)\n    echo \"${arr[*]}\"\n    for i in $(seq 0\
    \ $((len-1)))\n    do\n        if [[ $tmp2 = $tmp ]] ; then\n            tmp=$(echo\
    \ \"${arr[i]}\" | awk '{printf \"%d%s\", $1, $1}')\n        else\n           \
    \ tmp=$(echo \"${arr[i]}\" | awk '{printf \"%d%s\", $1, $1}' | sort -n) &>/dev/null\n\
    \        fi\n        if [[ $tmp != $tmp2 ]] ; then\n            output+=(\"${arr[i]}\"\
    )\n        fi\n    done\n    echo \"${output[@]}\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: 1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n  local -i num_ones i num\n  echo \"${1//[!-0-9]}\" |\
    \ sed 's/^\\([0-9]*\\)/\"&\"/'\n}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n\
    \    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate\
    \ \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
    \ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n  \
    \  [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") =\
    \ \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660056498
- exit_code: -1
  program: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative\
    \ integers according to\n# number of ones in their binary representation in ascending\
    \ order.\n# For similar number of ones, sort based on decimal value.\n# It must\
    \ be implemented like this:\n# >>> $(sort_array \"1 5 2 3 4\")\n# ['\"1\"', '\"\
    2\"', '\"3\"', '\"4\"', '\"5\"']\n# >>> $(sort_array \"-2 -3 -4 -5 -6\")\n# ['\"\
    -6\"', '\"-5\"', '\"-4\"', '\"-3\"', '\"-2\"']\n# >>> $(sort_array \"1 0 2 3 4\"\
    )\n# ['\"0\"', '\"1\"', '\"2\"', '\"3\"', '\"4\"']\n#\n# $1 is a space-separated\
    \ list\nsort_array() {\n    arr=$1\n    sort -n -k 1 -t / -k 4 > /tmp/tmp\n  \
    \  while read -r line; do\n        arr+=\"\\\"\"$line\"\\\"\"\n    done < <(echo\
    \ \"$arr\")\n    rm /tmp/tmp\n    echo \"$arr\"\n}\n\ncandidate() {\n    sort_array\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1 5 2 3 4\") = \"1 2\
    \ 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4 -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n\
    \    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2 4 3\" ]]\n    [[ $(candidate \"\"\
    ) = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5\
    \ 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12 32 5\") = \"32 3 5 6 12 44\" ]]\n\
    \    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n    [[ $(candidate\
    \ \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=22 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=34 encoding='utf-8'>
  timestamp: 1660056503
