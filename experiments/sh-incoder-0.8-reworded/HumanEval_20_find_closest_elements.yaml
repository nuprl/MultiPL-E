name: HumanEval_20_find_closest_elements
language: sh
prompt: "#!/bin/bash\n# From a supplied list of numbers (of length at least two) select\
  \ and return two that are the closest to each\n# other and return them in order\
  \ (smaller number, larger number).\n# >>> $(find_closest_elements \"1.0 2.0 3.0\
  \ 4.0 5.0 2.2\")\n# ['\"2.0\"', '\"2.2\"']\n# >>> $(find_closest_elements \"1.0\
  \ 2.0 3.0 4.0 5.0 2.0\")\n# ['\"2.0\"', '\"2.0\"']\n#\n# $1 is a space-separated\
  \ list\nfind_closest_elements() {\n"
tests: "}\n\ncandidate() {\n    find_closest_elements \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1.0 2.0 3.9 4.0 5.0 2.2\") = \"3.9 4.0\" ]]\n    [[ $(candidate\
  \ \"1.0 2.0 5.9 4.0 5.0\") = \"5.0 5.9\" ]]\n    [[ $(candidate \"1.0 2.0 3.0 4.0\
  \ 5.0 2.2\") = \"2.0 2.2\" ]]\n    [[ $(candidate \"1.0 2.0 3.0 4.0 5.0 2.0\") =\
  \ \"2.0 2.0\" ]]\n    [[ $(candidate \"1.1 2.2 3.1 4.1 5.1\") = \"2.2 3.1\" ]]\n\
  }\n\nrun_test"
completions: ["\tlocal i\n\tlocal result\n\n\tfor i; do\n\t\tif [ \"$i\" == \"$1\"\
    \ ]; then continue; fi\n\t\tif [ $(($i - $1)) -lt 0 ]; then continue; fi\n\t\t\
    if [ $(($i - $1)) -gt 0 ]; then break; fi\n\t\tresult=( \"$i\" \"$2\" )\n\tdone\n\
    \n\techo \"${result[*]}\"", "\tlocal input_array=\"$1\"\n\n\tlocal min\n\tlocal\
    \ max\n\tlocal tmp\n\tlocal output\n\n\tmin=${input_array[0]}\n\tmax=${input_array[0]}\n\
    \tfor (( i=1; i<${#input_array[@]}; i++ )); do\n\t\tif [[ ${input_array[i]} -gt\
    \ ${max} ]]; then\n\t\t\tmax=${input_array[i]}\n\t\tfi\n\t\tif [[ ${input_array[i]}\
    \ -lt ${min} ]]; then\n\t\t\tmin=${input_array[i]}\n\t\tfi\n\tdone\n\n\toutput=$(echo\
    \ \"${input_array[@]}\" | sort -V | sed -n \"/${min}/,/${max}/p\")\n\toutput=${output//'\"\
    '/}\n\toutput=${output//\"'\"}\n\toutput=${output//,/}\n\n\techo \"${output}\"",
  "  local elems=$1\n  shift\n  local num=$1\n  shift\n\n  local closest=\"$(minmax2\
    \ \"$num\" \"$elems\")\"\n  local closest2=\"$(minmax2 \"$closest\" \"$elems\"\
    )\"\n  local closest3=\"$(minmax3 \"$closest\" \"$elems\")\"\n  local closest4=\"\
    $(minmax4 \"$closest\" \"$elems\")\"\n  local closest5=\"$(minmax5 \"$closest\"\
    \ \"$elems\")\"\n  local closest6=\"$(minmax6 \"$closest\" \"$elems\")\"\n  local\
    \ closest7=\"$(minmax7 \"$closest\" \"$elems\")\"\n\n  echo \"$closest\"\n  echo\
    \ \"$closest2\"\n  echo \"$closest3\"\n  echo \"$closest4\"\n  echo \"$closest5\"\
    \n  echo \"$closest6\"\n  echo \"$closest7\"", "\tlocal a b;\n\tlocal elements=(\
    \ $(echo \"$1\" | tr '[:upper:]' '[:lower:]' | sed 's/ /\",\"/g') );\n\tlocal\
    \ numbers=( $(echo \"$1\" | tr '[:upper:]' '[:lower:]' | sed 's/ /\",\"/g') );\n\
    \tlocal i=0;\n\tfor (( i=0; i<${#numbers[@]}; i++ )); do\n\t\tb=\"${numbers[$i]}\"\
    \n\t\tif [[ \" ${elements[@]} \" =~ \" $b \" ]] &&\n\t\t   [[ \" ${numbers[@]}\
    \ \" != *\" $b \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]}\
    \ \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\
    \t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[\
    \ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]}\
    \ \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\"\
    \ ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]}\
    \ \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\
    \t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[\
    \ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]}\
    \ \" != *\" ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\"\
    \ ${numbers[$(($i-1))]} \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" != *\" ${numbers[$(($i-1))]}\
    \ \" ]] &&\n\t\t   [[ \" ${numbers[@]} \" ", "    local line=$( sed -n -e 's/^[\
    \ \\t]*//p' <<< \"$1\" )\n    local elements=$( echo \"$line\" | tr \" \" \"\\\
    n\" | sort -g | uniq )\n    local closest=$( echo \"$elements\" | awk -v min=$1\
    \ -v max=$1 '\n        $2 < min { min = $2 }\n        $2 > max { max = $2 }\n\
    \        { print \">\" $2 \"<\" }\n    ')\n    echo $(sed -n -e 's/^[ \\t]*//p'\
    \ <<< \"$closest\")", "    local numbers=$1\n    local closest=\n    local closestIndex=\n\
    \    local last=\n    for (( i=1; i<${#numbers}; i++ )); do\n        if [[ ${numbers[i]}\
    \ -gt ${last} ]]; then\n            closest=${numbers[i]}\n            closestIndex=${i}\n\
    \        fi\n        last=${numbers[i]}\n    done\n    local sortedNumbers=\n\
    \    for (( i=1; i<${#numbers}; i++ )); do\n        if [[ ${numbers[i]} -gt ${closest}\
    \ ]]; then\n            sortedNumbers=\"${sortedNumbers} ${numbers[i]}\"\n   \
    \     fi\n    done\n    echo \"${sortedNumbers}\"", "    local list=\"$1\"\n \
    \   local i1\n    local i2=\n    for i1 in $list; do\n        for i2 in $list;\
    \ do\n            case \"$i1 $i2 \" in\n                \" $i1 $i2 \" ) continue\
    \ ;;\n                \"$i1 $i2 \") i1=$i2 ;;\n            esac\n        done\n\
    \        break\n    done\n    echo \"$i1 $i2\"", "  numbers=\"$1\" # split input\n\
    \  if [ \"${#numbers}\" -lt 2 ] ; then\n    echo >&2 \"Usage: $(basename \"$0\"\
    ) [NUMBERS]\"\n    return 1\n  fi\n  local min=\"$2\"\n  local max=\"$3\"\n  local\
    \ index=0\n  local closest\n  while [ \"${index}\" -lt \"${#numbers}\" ] ; do\n\
    \    closest=\"$(echo \"${numbers[$index]}\" | awk '{print $2}')\"\n    other=\"\
    $(echo \"${numbers[$((index-1))]}\" | awk '{print $2}')\"\n    local diff=\"$((\
    \ $(echo \"${other}\" | awk '{print $1}') - $(echo \"${closest}\" | awk '{print\
    \ $1}') ))\"\n    if [ ${diff} -le 0 ] ; then\n      echo \"${closest}\"\n   \
    \ elif [ ${diff} -ge 0 ] ; then\n      echo \"${min}\"\n      echo \"${max}\"\n\
    \      return 0\n    fi\n    index=$((index+1))\n  done", "\tlocal input_list=$1\n\
    \t# Make sure we are using bash, sort, cut, and xargs\n\tlocal OPTS=\"-n 1 -P\
    \ -d\"\n\t# Make sure the list has at least two elements\n\t[[ ${#input_list}\
    \ -gt 1 ]] || return 1\n\n\tlocal output_list=\"$(echo \"$input_list\" | sort\
    \ $OPTS | cut -d'\"' -f 2-)\"\n\t[[ ${#output_list} -gt 1 ]] || return 1\n\tlocal\
    \ output_element=\"$(echo \"$output_list\" | sort $OPTS | head -1)\"\n\n\t# Only\
    \ return the first two elements in the list, because the next step\n\t# should\
    \ take care of removing them from the list.\n\techo \"$output_element\"", "  local\
    \ list=\"$1\"\n  local max_distance=${2:-1.0}\n  local min_distance=${2:-1.0}\n\
    \  local selected_elements=()\n  local elements=($list)\n  local element\n  local\
    \ distance\n  local index\n\n  # The for loop below iterates over the list of\
    \ numbers. Each number gets processed on every iteration. \n  # The current selected\
    \ element gets stored into selected_elements.\n  # If the current distance (difference)\
    \ from the current selected element is greater than max_distance, we \n  # update\
    \ max_distance. If the current distance is less than min_distance, we update min_distance.\
    \ \n  # Then, we select the element with that index and add it to selected_elements.\n\
    \  for index in ${!elements[@]}; do\n    element=${elements[$index]}\n    distance=$((${element}\
    \ - ${selected_elements[0]}))\n    if [[ \"$distance\" -gt \"$max_distance\" ]];\
    \ then\n      max_distance=$distance\n    fi\n    if [[ \"$distance\" -lt \"$min_distance\"\
    \ ]]; then\n      min_distance=$distance\n    fi\n    selected_elements+=(\"$element\"\
    )\n  done\n  echo \"${selected_elements[@]}\"", "  local LAST_ELEMENT=-1\n  local\
    \ LAST_ELEMENT_INDEX=-1\n  local MAX_DISTANCE=100\n  local ARRAY\n  local LIST\n\
    \  local NUMS\n  local N\n\n  read -a LIST <<< \"$1\"\n  local ARRAY=($(IFS=,;\
    \ echo \"${LIST[*]}\" | sort -n))\n  for (( i=0; i<${#ARRAY[@]}; i++ )); do\n\
    \    if [ \"$i\" -ne \"$LAST_ELEMENT_INDEX\" ] || [ \"$ARRAY[$LAST_ELEMENT_INDEX]\"\
    \ -gt \"$ARRAY[$i]\" ]; then\n      LAST_ELEMENT=\"$ARRAY[$i]\"\n      LAST_ELEMENT_INDEX=\"\
    $i\"\n    fi\n  done\n  if [ \"$LAST_ELEMENT_INDEX\" -eq \"$LAST_ELEMENT\" ];\
    \ then\n    echo \"$LAST_ELEMENT\"\n  else\n    NUMS=($(IFS=,; echo \"${LIST[*]}\"\
    \ | sort -n | head -n 2 | tail -n 1))\n    echo \"${NUMS[*]}\"\n  fi", "    local\
    \ elements=$1 prev=${elements[0]} \n    for element in \"${elements[@]:1}\" ;\
    \ do\n        local diff=$(( ${element} - $prev ))\n        if [ $diff -le 0 ];\
    \ then\n            prev=${element}\n        elif [ $diff -ge 0 ]; then\n    \
    \        prev=$element\n        fi\n    done\n    echo \"$prev $element\"", " \
    \   local elements=( $1 )\n    local closest\n    local dist\n\n    # find the\
    \ smallest distance\n    closest=( ${elements[@]} )\n    dist=${closest[0]}\n\
    \    for element in \"${elements[@]:1}\"\n    do\n        closest=( ${closest[@]}\
    \ $element )\n        dist=${closest[${#closest[@]} -1]}\n    done\n\n    # return\
    \ the smallest distance\n    printf '%s\\n' \"${closest[@]:0:2}\"", "  local numbers=$1\n\
    \  local index=0\n  local closest=3\n  local number\n  local new_number\n  local\
    \ smallest\n  local largest\n  local out\n  numbers=$(echo $numbers | sed 's/\
    \ /\" \"/')\n  numbers=$(echo $numbers | sed 's/ /\" \"/')\n  numbers=$(echo $numbers\
    \ | sed 's/ /\" \"/')\n  numbers=$(echo $numbers | sed 's/ /\" \"/')\n  while\
    \ IFS='' read -r number || [[ -n \"$number\" ]]; do\n    smallest=$(echo \"$number\"\
    \ | cut -d\".\" -f1)\n    largest=$(echo \"$number\" | cut -d\".\" -f2)\n    if\
    \ [[ $smallest -ne $largest ]]; then\n      smallest=${smallest:-0}\n      largest=${largest:-0}\n\
    \      if [[ $smallest -le $largest ]]; then\n        smallest=${smallest:-0}\n\
    \        largest=${largest:-0}\n      fi\n      smallest=$(( smallest < closest\
    \ ? smallest : closest ))\n      largest=$(( largest > closest ? largest : closest\
    \ ))\n      new_number=\"$(echo \"$number\" | sed \"s/$smallest/$largest/\")\"\
    \n      new_number=\"$(echo \"$new_number\" | sed 's/ /\" \"/')\"\n      echo\
    \ \"${new_number}\"\n    fi\n  done <<< \"$numbers\"", "  local elems=$1\n\n \
    \ # Convert to an array with elements surrounded by quotes\n  local elems_str=\"\
    $(echo \"${elems}\" | tr '\\n' ' ')\"\n\n  # Get all the numbers and convert to\
    \ floats\n  local elems_floats=\"$(echo \"${elems_str}\" | awk '{ gsub(/\\./,\"\
    \",$1); print $1 }')\"\n\n  # Calculate the differences between the two numbers\
    \ and find the two smallest values\n  local smallest_diff=\"$(printf \"%0.2f\"\
    \ $((${elems_floats[1]} - ${elems_floats[0]})))\"\n  local other_smallest_diff=\"\
    $(printf \"%0.2f\" $((${elems_floats[1]} - ${elems_floats[2]})))\"\n\n  # Find\
    \ the closest numbers by adding one to the smallest difference between the two\
    \ numbers\n  local smallest_closest=\"$(printf \"%0.2f\" $((${elems_floats[1]}\
    \ + ${smallest_diff})))\"\n  local other_smallest_closest=\"$(printf \"%0.2f\"\
    \ $((${elems_floats[1]} + ${other_smallest_diff})))\"\n\n  # Return them in order\n\
    \  local elems_str=\"${elems_floats[0]} ${elems_floats[1]} ${elems_floats[2]}\"\
    \n  local elems_str_closest=\"${elems_floats[0]} ${smallest_closest} ${other_smallest_closest}\"\
    \n  local elems_str_closest_order=\"${elems_floats[1]} ${smallest_closest} ${other_smallest_closest}\"\
    \n\n  # Return both results, the original and the closest in order\n  echo \"\
    ${elems_str}\"\n  echo \"${elems_str_closest_order}\"\n  echo \"${elems_str_closest}\"\
    \n", "    local element a\n\n    IFS=' ' read -r -a array <<< \"$1\"\n\n    local\
    \ smallest_distance second\n    for element in \"${array[@]}\"; do\n        a=$((\
    \ smallest_distance + $element ))\n        if [[ \"$smallest_distance\" == \"\
    $a\" ]]; then\n            smallest_distance=$a\n            second=\"$element\"\
    \n        fi\n    done\n\n    echo \"$smallest_distance\" \"$second\"", "  # Parse\
    \ input \n  local lines=(\"$@\")\n  local list=${lines[0]}\n\n  # If no list is\
    \ provided, default to all elements\n  if [ \"$#\" -eq 0 ]; then\n    list=$(seq\
    \ 0 \"$((${#list[@]} - 1))\")\n  fi\n\n  # If any element doesn't contain a space,\
    \ it's a number, but we want it to be\n  # a quoted string -- turn it into a quoted\
    \ string\n  for ((i=1;i<${#list[@]};i++)); do\n    list[i]=$(echo \"${list[i]}\"\
    \ | sed 's/^ *//g')\n  done\n\n  # If the list contains two numbers, they are\
    \ the same -- no need to do anything\n  # (this can happen when the list is generated\
    \ from seq 0, i.e. when the list\n  # contains only one element)\n  if [[ ${#list[@]}\
    \ -eq 2 ]]; then\n    local first=${list[0]}\n    local second=${list[1]}\n  \
    \  echo \"$first\"\n    echo \"$second\"\n    return 0\n  fi\n\n  # Sort the list\
    \ and return the two closest numbers in the list\n  list=$(sort -n -k 1 <<< \"\
    ${list[@]}\")\n  local first=${list[0]}\n  local second=${list[1]}\n\n  echo \"\
    $first\"\n  echo \"$second\"\n  return 0", "\tlocal numbers=$1\n\tlocal result\n\
    \tlocal index1\n\tlocal index2\n\tlocal closest1\n\tlocal closest2\n\t\n\tresult=()\n\
    \tfor index1 in \"${!numbers[@]}\"; do\n\t\tclosest1=${numbers[index1]}\n\t\t\
    closest2=${numbers[index1]}\n\t\tindex2=$((index1 + 1))\n\t\twhile [ \"${index2}\"\
    \ -lt \"${#numbers[@]}\" ]; do\n\t\t\tif [ \"$(echo \"${numbers[index1]} - ${numbers[index2]}\"\
    \ | bc)\" -lt \"$closest1\" ]; then\n\t\t\t\tclosest1=$(( closest1 + ${numbers[index1]}\
    \ - ${numbers[index2]} ))\n\t\t\t\tindex2=$(( index2 + 1))\n\t\t\telse\n\t\t\t\
    \tclosest2=$(( closest2 + ${numbers[index2]} - ${numbers[index1]} ))\n\t\t\t\t\
    index1=$(( index1 + 1 ))\n\t\t\tfi\n\t\tdone\n\t\tresult=(\"${result[@]}\" \"\
    ${numbers[index1]}\" \"${closest1}\" \"${closest2}\")\n\tdone\n\techo \"${result[@]}\"",
  "    local input=\"$1\"\n    local output\n\n    IFS=' ' read -ra array <<< \"$input\"\
    \n    local smallest_array\n    local smallest\n    local closest_index\n    local\
    \ smallest_distance\n    local closest_number\n    local closest_array_entry\n\
    \    local closest_index\n    local closest_distance\n\n    for index in \"${!array[@]}\"\
    ; do\n        smallest_distance=999999999\n        smallest_array=()\n       \
    \ smallest_array[0]=array[index]\n        smallest_array[1]=${array[smallest_array[0]]}\n\
    \        closest_array_entry=$smallest_array[1]\n\n        for (( index--; index>=0;\
    \ )); do\n            smallest_distance=${smallest_distance}\n            smallest_array[1]=${array[$index]}\n\
    \            smallest_distance=${smallest_distance}\n            ((smallest_distance\
    \ < smallest_distance )) && smallest_distance=${smallest_distance}\n         \
    \   closest_distance=${smallest_distance}\n            smallest_distance=${smallest_distance}\n\
    \n            if [[ ${array[$index]} -gt ${closest_array_entry} ]]; then\n   \
    \             closest_array_entry=${array[$index]}\n                closest_index=${index}\n\
    \                closest_distance=${smallest_distance}\n            fi\n     \
    \   done\n        output+=(\"${closest_array_entry}\")\n    done\n    echo \"\
    ${output[@]}\"", "    local a\n    local b\n    local c\n    local d\n\n    #\
    \ Parse the input\n    IFS=' ' read a b c d <<< \"$1\"\n\n    # Work out the list\
    \ of differences between the two inputs,\n    # using the first as the source\
    \ for our first difference\n    d=\"$(bc-a --from=a \"$c\")\"\n\n    # And do\
    \ the same for the second input\n    c=\"$(a-b --from=b \"$b\")\"\n\n    # Sort\
    \ the two output lists (in reverse order).\n    sort -r -n <<<\"$d\" <<<\"$c\"",
  "\tlocal -n list=$1\n\tlocal min=$2\n\tlocal max=$3\n\tlocal -a elements=()\n\t\
    local elem tmp\n\n\tfor (( i=1; i<= ${#list[@]} ; i++)); do\n\t\tif (( i == 1\
    \ )); then\n\t\t\telem=${list[$i]}\n\t\t\tbreak\n\t\tfi\n\t\tif (( elem > list[$i]\
    \ )); then\n\t\t\telem=${list[$i]}\n\t\telse\n\t\t\telem=${list[$((i - 1))]}\n\
    \t\tfi\n\tdone\n\n\tif (( min == \"min\" )) && (( max == \"max\" )) ; then\n\t\
    \tprintf \"%s\\n\" \"${list[@]}\"\n\telse\n\t\tlocal j=0\n\t\tfor (( i=${#list[@]}-1\
    \ ; i>= 1; i--)); do\n\t\t\tif (( i == 1 )); then\n\t\t\t\telem=${list[$i]}\n\t\
    \t\t\tbreak\n\t\t\tfi\n\t\t\ttmp=${list[$((j+1)+1)]}\n\t\t\tif (( elem > tmp ));\
    \ then\n\t\t\t\telem=${list[$i]}\n\t\t\telse\n\t\t\t\telem=${list[$((j+1))]}\n\
    \t\t\tfi\n\t\t\tj=$((j+1))\n\t\tdone\n\t\tprintf \"\\\"%s\\\"\\n\" \"${list[@]}\"\
    \n\tfi", "    local numbers=$(echo \"$1\" | tr '\\n' ' '); shift\n    local smallest;\
    \ local largest;\n    for number in $numbers; do\n        smallest=\"$(echo \"\
    $number\" | awk '{print $1 < $smallest? $1 : $smallest}')\"\n        largest=\"\
    $(echo \"$number\" | awk '{print $1 > $largest? $1 : $largest}')\"\n    done\n\
    \    echo \"$smallest $largest\"", "    local elements=$1\n    local current_element=$(echo\
    \ $elements | awk '{print $2}')\n    local sorted_elements=$(echo $elements |\
    \ sort -r)\n\n    local closest_index=$(echo $sorted_elements | awk '{print $1}'\
    \ | awk -F. '{print $1}' | head -1)\n    local closer=$sorted_elements[$closest_index]\n\
    \    local lower_element=$(echo $closer | awk '{print $1}')\n    local higher_element=$(echo\
    \ $closer | awk '{print $2}')\n\n    local next_element=$(echo $elements | awk\
    \ '{print $2}' | head -2)\n\n    local final_list=$( echo $current_element $next_element\
    \ | tr -d '\"' )\n    local final=`echo $final_list | awk '{print $1}'`\n    echo\
    \ $final", "    local list_nums=\"$1\"\n    local min_index=\"$2\"\n    local\
    \ min_value=\"$3\"\n\n    local cur_index=\"$min_index\"\n    local cur_value=\"\
    $min_value\"\n    local cur_index2=\"$min_index\"\n\n    local value_tmp=\"${list_nums##*\
    \ }\"\n    local value_tmp2=\"${list_nums##* }\"\n    local index=\"${list_nums##*\
    \ }\"\n\n    while [[ ${list_nums} == *\"  \"* ]] ; do\n        list_nums=\"${list_nums%\
    \  *}\"\n        list_nums=\"${list_nums##* }\"\n    done\n\n    if [[ -z \"${list_nums}\"\
    \ ]] ; then\n        echo \"No numbers to compare. Exiting.\"\n        return\
    \ 1\n    fi\n\n    if [[ ${cur_value} > ${cur_value2} ]] ; then\n        cur_value2=\"\
    ${cur_value}\"\n        cur_index2=\"${cur_index}\"\n    fi\n\n    while [[ ${list_nums}\
    \ == *\"  \"* ]] ; do\n        list_nums=\"${list_nums%  *}\"\n        list_nums=\"\
    ${list_nums##* }\"\n    done\n\n    local result=\"\"\n\n    while [[ ${cur_index}\
    \ != ${cur_index2} ]] ; do\n        local value_tmp=\"${list_nums##* }\"\n   \
    \     local value_tmp2=\"${list_nums##* }\"\n        local index=\"${list_nums##*\
    \ }\"\n\n        local diff=\"${value_tmp} - ${cur_value}\"\n        local diff2=\"\
    ${value_tmp2} - ${cur_value2}\"\n\n        if [[ ${diff} -lt ${diff2} ]] ; then\n\
    \            cur_value2=\"${value_tmp}\"\n            cur_index2=\"${index}\"\n\
    \        elif [[ ${diff2} -lt ${diff} ]] ; then\n            cur_value=\"${value_tmp2}\"\
    \n            cur_index=\"${index}\"\n        fi\n    done\n\n    echo \"${result}\"",
  "  # Redirect output to a file if we're going to debug this\n  [ -n \"$DEBUG\" ]\
    \ && exec >&2\n\n  # Make sure our numbers are actually valid floats\n  local\
    \ num_string\n  while read num_string; do\n    [ -z \"$num_string\" ] && break\n\
    \    local num=$(echo \"$num_string\" | awk '{print $1}')\n    local elements=\"\
    $2\"\n\n    case \"$num\" in\n      *) printf \"Bad number: '%s'\\n\" \"$num_string\"\
    \ >&2; exit 1 ;;\n    esac\n\n    if ! [[ $elements =~ ^[0-9]+$ ]]; then\n   \
    \   printf \"Bad elements: %s\\n\" \"$elements\" >&2; exit 1\n    fi\n\n    local\
    \ min_elements=$elements\n    local max_elements=$elements\n  done\n\n  # Make\
    \ sure there's at least two elements to compare\n  if [ ! -z \"$min_elements\"\
    \ ]; then\n    printf \"Minimum elements not specified: %s\\n\" \"$min_elements\"\
    \ >&2; exit 1\n  fi\n\n  # Make sure we actually have two elements\n  if [ ! -z\
    \ \"$2\" ]; then\n    printf \"Expected exactly two elements; got: %s\\n\" \"\
    $2\" >&2; exit 1\n  fi\n\n  # Check that we have at least two elements\n  if [\
    \ \"$1\" == \"-\" ]; then\n    printf \"Need at least two elements\\n\" >&2; exit\
    \ 1\n  fi\n\n  # If there's only one element, we're done\n  if [ \"$min_elements\"\
    \ == \"$2\" ]; then\n    return 0\n  fi\n\n  # Now we know we have two elements\n\
    \  # Check them for validity\n  # NOTE: Bash doesn't have integer arithmetic!\n\
    \  local actual_min=$(( $min_elements - 1 ))\n  local actual_max=$(( $max_elements\
    \ + 1 ))\n\n  # Make sure we have the right number of elements specified\n  if\
    \ [ \"$actual_min\" -eq \"0\" -o \"$actual_max\" -eq \"$1\" ]; then\n    printf\
    \ \"Invalid min or max specified: %s\\n\" \"$min_elements\" >&2; exit 1\n  fi\n\
    \n  # Make sure that the min and max elements are valid numbers\n  for number\
    \ in $(seq 1 \"$actual_min\"); do\n    if [ \"$number\" != \"$(echo \"$number\"\
    \ | awk '{print $1}')\" ]; then\n      printf \"Invalid min value: %d\\n\" \"\
    $number\" >&2; exit 1\n    fi\n  done\n  for number in $(seq 1 \"$actual_max\"\
    ); do\n    if [ \"$number\" != \"$(echo \"$number\" | awk '{print $1}')\" ]; then\n\
    \      printf \"Invalid max value: %d\\n\" \"$number\" >&2; exit 1\n    fi\n \
    \ done\n\n  # ", "\tlet \"len=${#1}\"\n\twhile [ \"${len}\" -gt \"2\" ]; do\n\t\
    \tlet \"min=${1%* }\"\n\t\tlet \"index=0\"\n\t\tlet \"result=-1\"\n\t\twhile [\
    \ \"${len}\" -gt \"2\" ]; do\n\t\t\tlet \"index+=1\"\n\t\t\tlet \"smaller=${1%*\
    \ }\"\n\t\t\tlet \"bigger=${2%* }\"\n\t\t\tlet \"d=${smaller}-${bigger}\"\n\t\t\
    \tif [ \"$(printf \"%.0f\" ${d})\" -gt \"$(printf \"%.0f\" ${min})\" ]; then\n\
    \t\t\t\tlet \"min=${smaller}\"\n\t\t\t\tlet \"result=${index}\"\n\t\t\tfi\n\t\t\
    \tlet \"1=$((index-1))\"\n\t\t\tlet \"2=${len}\"\n\t\tdone\n\t\tif [ \"${result}\"\
    \ -eq \"-1\" ]; then\n\t\t\tlet \"result=${len}\"\n\t\tfi\n\t\tlet \"1=$((result-1))\"\
    \n\t\tlet \"2=${len}\"\n\tdone\n\tif [ \"${len}\" -eq \"2\" ]; then\n\t\techo\
    \ \"${1}\"\n\t\techo \"${2}\"\n\telse\n\t\techo \"${1}\"\n\tfi", "  local elements=$1\n\
    \  local closest\n  local min\n  local max\n  local index\n  local element\n\n\
    \  min=$elements\n  max=$elements\n\n  # Find the largest number\n  index=0\n\
    \  while [ \"$min\" -gt \"$max\" ]; do\n    element=${elements[$index]};\n   \
    \ closest=$element;\n    index=$(( index + 1 ))\n    min=$(( min + element ))\n\
    \    max=$(( max - element ))\n  done\n\n  # Find the smallest number\n  index=0\n\
    \  while [ \"$min\" -lt \"$max\" ]; do\n    element=${elements[$index]};\n   \
    \ closest=$element;\n    index=$(( index + 1 ))\n    min=$(( min - element ))\n\
    \    max=$(( max - element ))\n  done\n\n  # Return both numbers in order\n  echo\
    \ \"$min $max\"", "    local elements currentElement\n    local -a candidates\
    \ min max\n    local -a allCandidates closestCandidate distance\n\n    elements=(\
    \ \"$@\" )\n    currentElement=${elements[0]}\n    min=10000000000000000000000\n\
    \    max=10000000000000000000000\n    for element in \"${elements[@]:1}\"; do\n\
    \        # Compute current distance from minimum to current element\n        distance=$((\
    \ $(echo \"$currentElement - $element\" | bc -l) )); echo \"$currentElement -\
    \ $element distance: $distance\"\n        if [ $distance -lt $min ]; then\n  \
    \          min=$distance\n            closestCandidate=$(echo \"$element\" | bc)\n\
    \        fi\n        # Compute current distance from maximum to current element\n\
    \        distance=$(( $(echo \"$currentElement - $element\" | bc -l) )); echo\
    \ \"$currentElement - $element distance: $distance\"\n        if [ $distance -gt\
    \ $max ]; then\n            max=$distance\n            closestCandidate=$(echo\
    \ \"$element\" | bc)\n        fi\n        candidates+=( \"$closestCandidate\"\
    \ )\n        currentElement=$element\n    done\n\n    allCandidates=( \"$candidates\"\
    \ )\n    allCandidates=( \"${allCandidates[@]:1}\" )\n    allCandidates=( \"${allCandidates[@]:1}\"\
    \ )\n    allCandidates=( \"${allCandidates[@]:1}\" )\n    allCandidates=( \"${allCandidates[@]:1}\"\
    \ )\n    allCandidates=( \"${allCandidates[@]:1}\" )\n    allCandidates=( \"${allCandidates[@]:1}\"\
    \ )\n    allCandidates=( \"${allCandidates[@]:1}\" )\n\n    # Compute current\
    \ distance from minimum to current element\n    distance=$(( $(echo \"$currentElement\
    \ - $element\" | bc -l) )); echo \"$currentElement - $element distance: $distance\"\
    \n    if [ $distance -lt $min ]; then\n        min=$distance\n        closestCandidate=$(echo\
    \ \"$element\" | bc)\n    fi\n    # Compute current distance from maximum to current\
    \ element\n    distance=$(( $(echo \"$currentElement - $element\" | bc -l) ));\
    \ echo \"$currentElement - $element distance: $distance\"\n    if [ $distance\
    \ -gt $max ]; then\n        max=$distance\n        closestCandidate=$(echo \"\
    $element\" | bc)\n    fi\n\n    echo \"${allCandidate", "  local list=\"$1\"\n\
    \  local sorted=\"$(echo \"$list\" | tr '\\n' ' ')\"\n  local smaller=\"$2\"\n\
    \  local bigger=\"$3\"\n  local index=0\n  local distance\n  local value\n\n \
    \ while [ $index != $( echo \"$list\" | sed -n \"$index\" | cut -d ' ' -f 1) ];\
    \ do\n    value=$(echo \"$list\" | sed -n \"$index\" | cut -d ' ' -f \"$index\"\
    )\n    distance=\"$( echo \"$list\" | awk \"{print $1 - $value}\" )\"\n    [ $distance\
    \ -lt \"$smaller\" ] && smaller=\"$distance\"\n    [ $distance -gt \"$bigger\"\
    \ ] && bigger=\"$distance\"\n    index=$( ((index+1)&1)<<1 )\n  done\n\n  echo\
    \ \"$sorted\" | sed -n \"$index\"", "    local elements=$1\n    local elements_count=${#elements}\n\
    \    if [ $elements_count -lt 2 ]\n    then\n        echo \"ERROR: $1 must be\
    \ of size at least two\"\n        exit 1\n    fi\n\n    local elements_sorted=(\
    \ $( echo $elements | tr \"\\n\" \" \" ) )\n    local elements_sorted=($( echo\
    \ \"${elements_sorted[@]}\" | sort ))\n\n    local previous_element=${elements_sorted[0]}\n\
    \    local second_element=${elements_sorted[1]}\n    local third_element=${elements_sorted[2]}\n\
    \n    local closest_elements=()\n    local smallest_distance=-1\n\n    local first_closest=true\n\
    \    local second_closest=true\n\n    for element in \"${elements_sorted[@]:1}\"\
    \n    do\n        local distance=$(( $( echo \"$element - $previous_element\"\
    \ | bc -l ) ))\n        if [ \"$first_closest\" == \"true\" ]\n        then\n\
    \            smallest_distance=$distance\n            first_closest=false\n  \
    \      elif [ \"$second_closest\" == \"true\" ]\n        then\n            smallest_distance=$distance\n\
    \            second_closest=false\n        elif [ \"$smallest_distance\" == \"\
    -1\" ]\n        then\n            smallest_distance=$distance\n            closest_elements=(\
    \ \"${closest_elements[@]}\" \"$element\" )\n        elif [ \"$smallest_distance\"\
    \ -gt \"$distance\" ]\n        then\n            smallest_distance=$distance\n\
    \            closest_elements=( \"${closest_elements[@]}\" \"$element\" )\n  \
    \      fi\n\n        previous_element=$element\n    done\n\n    echo \"${closest_elements[@]}\"",
  "    local elements=( $1 )\n    local elements_set=()\n    local min1=\"$(echo \"\
    ${elements[@]}\" | sort --numeric-sort --key=2 --reverse --key=1)\"\n    local\
    \ min2=\"$(echo \"${elements[@]}\" | sort --numeric-sort --key=2 --reverse --key=1)\"\
    \n    local max1=\"$(echo \"${elements[@]}\" | sort --numeric-sort --key=2 --reverse\
    \ --key=1)\"\n    local max2=\"$(echo \"${elements[@]}\" | sort --numeric-sort\
    \ --key=2 --reverse --key=1)\"\n    local count=0\n    local tmp1=\"\"\n    local\
    \ tmp2=\"\"\n    local tmp3=\"\"\n    local tmp4=\"\"\n    local tmp5=\"\"\n \
    \   while [ $count -lt $((${#elements[@]}-1) ) ]; do\n        tmp1=\"${min1}\"\
    \n        tmp2=\"${max1}\"\n        if [ \"$min1\" != \"$max1\" ]; then\n    \
    \        tmp3=\"${min2}\"\n            tmp4=\"${max2}\"\n        else\n      \
    \      tmp3=\"${min1}\"\n            tmp4=\"${max2}\"\n        fi\n        tmp_element=\"\
    $(echo \"${tmp1}\" | cut -d '\"' -f 2 | cut -d ' ' -f 2)\"\n        tmp_element2=\"\
    $(echo \"${tmp2}\" | cut -d '\"' -f 2 | cut -d ' ' -f 2)\"\n        tmp_element3=\"\
    $(echo \"${tmp3}\" | cut -d '\"' -f 2 | cut -d ' ' -f 2)\"\n        tmp_element4=\"\
    $(echo \"${tmp4}\" | cut -d '\"' -f 2 | cut -d ' ' -f 2)\"\n        tmp5=\"${elements[$count]}\"\
    \n        if [ \"${tmp_element2}\" -eq \"${tmp_element}\" ]; then\n          \
    \  elements_set=( \"$tmp5\")\n            if [ \"$min1\" != \"$max1\" ]; then\n\
    \                min2=\"${tmp5}\"\n                max2=\"${tmp5}\"\n        \
    \    else\n                min1=\"${tmp5}\"\n                max1=\"${tmp5}\"\n\
    \            fi\n        elif [ \"${tmp_element3}\" -eq \"${tmp_element}\" ];\
    \ then\n            elements_set=( \"$tmp5\")\n            if [ \"$min1\" != \"\
    $max1\" ]; then\n                min2=\"${tmp5}\"\n                max2=\"${tmp5}\"\
    \n            else\n                min1=\"${tmp5}\"\n                max1=\"\
    ${tmp5}\"\n            fi\n        elif [ \"${", "    local numbers=$1\n    local\
    \ index1=0\n    local index2=0\n    local smallest=${numbers[0]}\n    local largest=${numbers[0]}\n\
    \    local output=\"\"\n    # Walk through all numbers and find one that is closest\n\
    \    while ((index1 < ${#numbers[@]}) && (index2 < ${#numbers[@]})); do\n    \
    \    let \"index1=index1+1\" # Increment for the next number\n        let \"index2=index2+1\"\
    \ # Increment for the next number\n        if [[ ${numbers[index1]} < ${smallest}\
    \ ]]; then\n            let \"smallest=${numbers[index1]}\"\n        elif [[ ${numbers[index1]}\
    \ > ${largest} ]]; then\n            let \"largest=${numbers[index1]}\"\n    \
    \    fi\n    done\n    # Return two results as strings\n    echo \"${smallest}\"\
    \n    echo \"${largest}\"", "    local numbers=\"$1\"\n    local closest_numbers=\"\
    $2\"\n    local smallest_num=\"${numbers[0]}\"\n    local largest_num=\"${numbers[-1]}\"\
    \n    local smallest_diff=\"$(( ${smallest_num} - ${closest_numbers[0]} ))\"\n\
    \    local largest_diff=\"$(( ${largest_num} - ${closest_numbers[-1]} ))\"\n \
    \   for (( i=1; i<${#numbers[@]}; i++ )); do\n        if [[ ${numbers[i]} -ge\
    \ ${smallest_num} && ${numbers[i]} -lt ${largest_num} ]]; then\n            if\
    \ [[ ${smallest_diff} -eq 0 ]]; then\n                smallest_diff=\"${numbers[i]}\
    \ - ${closest_numbers[0]}\"\n                smallest_num=\"${numbers[i]}\"\n\
    \            else\n                if (( ${smallest_diff} < ${numbers[i]} - ${closest_numbers[0]}\
    \ )) ; then\n                    smallest_diff=\"${numbers[i]} - ${closest_numbers[0]}\"\
    \n                    smallest_num=\"${numbers[i]}\"\n                fi\n   \
    \         fi\n        fi\n        if [[ ${numbers[i]} -le ${largest_num} && ${numbers[i]}\
    \ -gt ${smallest_num} ]]; then\n            if [[ ${largest_diff} -eq 0 ]]; then\n\
    \                largest_diff=\"${numbers[i]} - ${closest_numbers[-1]}\"\n   \
    \             largest_num=\"${numbers[i]}\"\n            else\n              \
    \  if (( ${largest_diff} > ${numbers[i]} - ${closest_numbers[-1]} )) ; then\n\
    \                    largest_diff=\"${numbers[i]} - ${closest_numbers[-1]}\"\n\
    \                    largest_num=\"${numbers[i]}\"\n                fi\n     \
    \       fi\n        fi\n    done\n    echo \"${closest_numbers[@]}\"", "    #\
    \ Parse input string into array and remove spaces from elements\n    IFS=' ' read\
    \ -r -a elements <<< \"$1\"\n    elements=(${elements[@]#*=})\n    # Now we make\
    \ a list of all possible values\n    declare -a array\n    for i in \"${elements[@]}\"\
    ; do\n        array+=(\"$i\")\n    done\n    # Now find the minimum/maximum values\
    \ from that list\n    local minmax=$(awk 'BEGIN{min=max=$1}{if($2>max){max=$2;min=$1}}\
    \ END{print max,min}' <<< \"${array[@]}\")\n    # Now select the values\n    local\
    \ -a result\n    for i in \"${elements[@]}\"; do\n        if [[ ${minmax} == \"\
    $i,$i\" ]]; then\n            result+=(\"$i\")\n        fi\n    done\n    echo\
    \ ${result[@]}", "    local elements=\"$1\"\n    shift\n\n    for element in \"\
    ${elements[@]}\"; do\n        [ \"$element\" -gt \"0\" ] && [ \"$element\" -lt\
    \ \"$max\" ] && max=\"$element\"\n    done\n\n    for element in \"${elements[@]}\"\
    ; do\n        [ \"$element\" -gt \"$max\" ] && echo \"\\\"$element\\\"\" || (echo\
    \ \"\\\"$element\\\"\"; echo \"\\\"$max\\\"\")\n    done", "    local numbers=\"\
    ${1}\"\n    local mindiff=0\n    local mindiffnum\n    local mindiffnumsplit\n\
    \    local mindiffnumstring\n    local minnum=\"\\\"${2}\"\n    local maxnum=\"\
    \\\"${3}\"\n    local i\n    local num\n    local mindiffnumstring1\n    local\
    \ mindiffnumstring2\n\n    mindiffnumsplit=( $( echo \"${mindiffnum}\" | sed 's/[^\
    \ ]*//g' | sed 's/ //g' ) )\n\n    for ((i=1; i<=${#mindiffnumsplit[@]}; i++));\
    \ do\n        num=${mindiffnumsplit[$i]}\n        num=${num//\\\"}\n        mindiffnumstring1=${num%\\\
    .}\n        mindiffnumstring2=${num#\\.}\n\n        mindiffnum=$(echo \"$mindiffnumstring2\
    \ - $mindiffnumstring1\" | bc)\n        if [ $mindiffnum -gt 0 ]; then\n     \
    \       break\n        fi\n    done\n\n    local mindiffnumsplit1\n    mindiffnumsplit1=(\
    \ $( echo \"${mindiffnum}\" | sed 's/[^ ]*//g' | sed 's/ //g' ) )\n\n    for ((i=1;\
    \ i<=${#mindiffnumsplit1[@]}; i++)); do\n        num=${mindiffnumsplit1[$i]}\n\
    \        num=${num//\\\"}\n        mindiffnumstring1=${num%\\.}\n        mindiffnumstring2=${num#\\\
    .}\n\n        mindiffnum=$(echo \"$mindiffnumstring2 - $mindiffnumstring1\" |\
    \ bc)\n        if [ $mindiffnum -gt 0 ]; then\n            break\n        fi\n\
    \    done\n\n    local mindiffnumsplit2\n    mindiffnumsplit2=( $( echo \"${mindiffnum}\"\
    \ | sed 's/[^ ]*//g' | sed 's/ //g' ) )\n\n    for ((i=1; i<=${#mindiffnumsplit2[@]};\
    \ i++)); do\n        num=${mindiffnumsplit2[$i]}\n        num=${num//\\\"}\n \
    \       mindiffnumstring1=${num%\\.}\n        mindiffnumstring2=${num#\\.}\n\n\
    \        mindiffnum=$(echo \"$mindiffnumstring2 - $mindiffnumstring1\" | bc)\n\
    \        if [ $mindiffnum -gt 0 ]; then\n            break\n        fi\n    done\n\
    \n    local mindiffnumsplit3\n    mindiffnumsplit3=( $( echo \"${mindiffnum}\"\
    \ | sed ", "    set -- $(( $# - 1 ))\n    local elements=$1\n    local smallest=-1\n\
    \    local largest=-1\n\n    while [ $# -gt 0 ]; do\n        local next=`expr\
    \ $1 + 1`\n        local element=`echo $elements | cut -d ' ' -f $next`\n    \
    \    local this_smallest=`echo $smallest | cut -d ' ' -f $next`\n        local\
    \ this_largest=`echo $largest | cut -d ' ' -f $next`\n\n        smallest=`expr\
    \ $this_smallest \\< $element \\< $this_largest`\n        largest=`expr $this_smallest\
    \ \\< $element \\< $this_largest`\n\n        elements=`expr \"$elements\" : \"\
    $element \" \" - 1\"`\n    done\n    echo $elements", "    local numbers=\"$1\"\
    \n    local element\n    local index\n    local number\n    local max\n    local\
    \ min\n\n    # Make sure the list of numbers is at least two items long\n    if\
    \ [ -z \"$numbers\" ]; then\n        echo \"No numbers provided\"\n        return\
    \ 1\n    fi\n\n    # Convert the list of numbers to an array, splitting on spaces.\n\
    \    IFS=' ' read -r -a numbers <<< \"$numbers\"\n\n    # Find the smallest and\
    \ largest numbers\n    min=${numbers[0]}\n    max=${numbers[0]}\n    for element\
    \ in \"${numbers[@]:1}\"; do\n        if [ $element -gt $max ]; then\n       \
    \     max=$element\n        elif [ $element -lt $min ]; then\n            min=$element\n\
    \        fi\n    done\n\n    # Calculate the closest two numbers\n    for element\
    \ in \"${numbers[@]:1}\"; do\n        if [ $element -lt $min ] || [ $element -gt\
    \ $max ]; then\n            continue\n        elif [ $element -lt $min ]; then\n\
    \            echo \"$min $element\"\n            break\n        elif [ $element\
    \ -gt $max ]; then\n            echo \"$element $max\"\n            break\n  \
    \      fi\n    done", "    local numbers=$*\n    local closest_first\n    local\
    \ closest_second\n    local tmp\n\n    for (( i=0; i<${#numbers}; i++ )); do\n\
    \        tmp=${numbers[i]}\n\n        # find closest number to first element\n\
    \        closest_first=$(expr \"$tmp\" \"$numbers[0]\")\n        closest_second=$(expr\
    \ \"$tmp\" \"$numbers[1]\")\n\n        if [ \"$closest_first\" -eq \"$closest_second\"\
    \ ]; then\n            # first and second elements are the same\n            continue\n\
    \        fi\n\n        # found two that are close to each other\n        break\n\
    \    done\n\n    # return them in order\n    echo \"$closest_first,$closest_second\"",
  "    local elements\n    local closest_elements\n    local closest_index\n    local\
    \ closest_value\n    local index\n\n    elements=$(echo \"$1\" | sed 's/ /\" \"\
    /g' | awk '{print $1, $2}')\n\n    for index in $( seq 1 $(( $#elements+1 )) )\n\
    \    do\n        closest_value=$(echo \"$elements\" | awk \"{print $index}\" \
    \ | sort -rn | head -1)\n        closest_index=$(echo \"$elements\" | awk \"{print\
    \ \\$index}\" | sort -rn | head -1)\n        case \"$closest_value\" in\n    \
    \        $( echo \"$elements\" | awk \"{print \\$index}\" | sort -rn | head -1\
    \ ))\n                    echo \"$closest_index\"\n                    ;;\n  \
    \          esac\n    done", "  local elements=\"$1\"\n  local closest=\"\"\n \
    \ local closest2=\"\"\n  local smallest=\"$2\"\n  local largest=\"$3\"\n\n  if\
    \ [ -z \"$elements\" ]; then return 1; fi\n\n  local count=0\n  local element\n\
    \  while read -r element; do\n    count=$(( count + 1 ))\n    if [ $count -eq\
    \ 2 ]; then\n      if [ \"$smallest\" == \"$element\" ]; then smallest=\"\"; largest=\"\
    $element\"; fi\n    elif [ \"$element\" == \"$smallest\" ]; then smallest=\"\"\
    ; largest=\"$element\"; fi\n  done <<< \"$elements\"\n\n  local smallest_count=0\n\
    \  local smallest_element\n  local largest_count=0\n  local largest_element\n\
    \  while read -r element; do\n    smallest_count=$(( smallest_count + 1 ))\n \
    \   smallest_element=\"$smallest\"\n    smallest_count=$(( smallest_count + 1\
    \ ))\n    largest_count=$(( largest_count + 1 ))\n    largest_element=\"$largest\"\
    \n  done <<< \"$elements\"\n\n  local i\n  for (( i=1; i<$smallest_count; i++\
    \ )); do\n    local e\n    if [ \"$smallest_count\" -lt \"$i\" ]; then\n     \
    \ e=$smallest_element\n      smallest_count=$(( smallest_count + 1 ))\n      smallest_element=\"\
    $e\"\n    elif [ \"$smallest_count\" -eq \"$i\" ]; then\n      if [ \"$smallest_element\"\
    \ == \"$element\" ]; then smallest_element=\"\"; smallest_count=$(( smallest_count\
    \ + 1 )); done\n      else smallest_element=\"\"; smallest_count=$(( smallest_count\
    \ + 1 )); fi\n    fi\n  done\n\n  for (( i=$smallest_count+1; i<$largest_count;\
    \ i++ )); do\n    local e\n    if [ \"$largest_count\" -lt \"$i\" ]; then\n  \
    \    e=$largest_element\n      largest_count=$(( largest_count + 1 ))\n      largest_element=\"\
    $e\"\n    elif [ \"$largest_count\" -eq \"$i\" ]; then\n      if [ \"$largest_element\"\
    \ == \"$element\" ]; then smallest_element=\"\"; smallest_count=$(( smallest_count\
    \ + 1 )); done\n      else smallest_element=\"\"; smallest_count=$(( smallest_count\
    \ + 1 )); fi\n    fi\n  done\n\n  if [ \"$smallest_", "  local elements=$(echo\
    \ \"$1\" | tr -s \" \")\n  local closest=$(find_closest)\n  local closest_element=$(echo\
    \ $closest | cut -d' ' -f1)\n  local closest_element_other=$(echo $closest | cut\
    \ -d' ' -f2)\n  echo \"$elements $closest $closest_element $closest_element_other\"",
  "  declare -a numbers=()\n  IFS=$'\\n' read -d '' -a numbers <<< \"$1\"\n\n  for\
    \ (( i=0; i<${#numbers[@]}-1; i++ ))\n  do\n    element=${numbers[i]}\n    if\
    \ [[ ${numbers[i]} -gt ${numbers[i+1]} ]]\n    then\n      number1=${numbers[i+1]}\n\
    \      number2=${numbers[i]}\n    elif [[ ${numbers[i]} -lt ${numbers[i+1]} ]]\n\
    \    then\n      number1=${numbers[i]}\n      number2=${numbers[i+1]}\n    fi\n\
    \  done\n\n  echo \"\\\"${number1}\\\" \\\"${number2}\\\"\"", "    local numbers=\"\
    $1\"\n    shift\n    local smallest=0\n    local smallest_index=0\n    local second=\n\
    \n    while (( \"${#numbers[@]}\" > 0 )); do\n        local current_element=\"\
    ${numbers[0]}\"\n        local index=0\n        while (( \"${index}\" < \"${#numbers[@]}\"\
    \ )); do\n            local current_number=\"${numbers[index]}\"\n           \
    \ if (( ${current_element} > \"${current_number}\" )); then\n                smallest=\"\
    ${current_number}\"\n                smallest_index=\"${index}\"\n           \
    \ else\n                second=\"${current_number}\"\n            fi\n       \
    \     (( ++index ))\n        done\n        numbers=( \"${numbers[@]:${smallest_index}:${#numbers[@]}}\"\
    \ )\n    done\n\n    echo \"${second}\"", "    local inputs=$( echo \"$1\" | tr\
    \ \"\\n\" \" \" )\n    local closest=-1\n    local current=-1\n    local closestdiff=-1\n\
    \    local diff=0\n    local closeststring=\"\"\n    local currentstring=\"\"\n\
    \    local i j\n\n    while IFS= read -r line; do\n        for ((i=0; i<${#inputs[@]};\
    \ i++)) {\n            if [ \"$line\" == \"${inputs[$i]}\" ]; then\n         \
    \       current=$i\n                break\n            fi\n        done\n    \
    \    if [ $current -ne -1 ]; then\n            for ((j=0; j<${#inputs[@]}; j++))\
    \ {\n                diff =$(($line-${inputs[$j]}))\n                if [ $j ==\
    \ 0 ] || [ $diff -lt $closestdiff ]; then\n                    closestdiff=$diff\n\
    \                    closeststring=\"${inputs[$j]}\";\n                    closest=$j;\n\
    \                fi\n            done\n        fi\n    done < <(sort -n -k 2 \"\
    ${inputs[@]}\")\n\n    if [ $closest -ne -1 ]; then\n        for ((j=$((closest+2));\
    \ j<${#inputs[@]}; j++)) {\n            diff =$(($line-${inputs[$j]}))\n     \
    \       if [ $j == 0 ] || [ $diff -lt $closestdiff ]; then\n                closestdiff=$diff\n\
    \                closeststring=\"${inputs[$j]}\";\n            fi\n        done\n\
    \    fi\n\n    echo \"${inputs[$closest]}\"", "\tlocal numbers=$1\n\tlocal min1=$(echo\
    \ $numbers | cut -d\" \" -f1)\n\tlocal max1=$(echo $numbers | cut -d\" \" -f1)\n\
    \tlocal min2=$(echo $numbers | cut -d\" \" -f2)\n\tlocal max2=$(echo $numbers\
    \ | cut -d\" \" -f2)\n\tlocal i=$(echo $min1 $max1 | sort -n | head -1)\n\tlocal\
    \ j=$(echo $min2 $max2 | sort -n | head -1)\n\techo $i $j\n\twhile [ \"$i\" !=\
    \ \"$j\" ]\n\tdo\n\t\tlocal jm=$(echo $j | cut -d\" \" -f1)\n\t\tlocal im=$(echo\
    \ $i | cut -d\" \" -f1)\n\t\tlocal jp=$(echo $j | cut -d\" \" -f2)\n\t\tlocal\
    \ ip=$(echo $i | cut -d\" \" -f2)\n\t\tif [ \"$jm\" == \"$im\" -o \"$jp\" == \"\
    $ip\" ]; then\n\t\t\tlocal jm=$(echo $j | cut -d\" \" -f2)\n\t\t\tlocal im=$(echo\
    \ $i | cut -d\" \" -f2)\n\t\t\tj=$(echo $j | cut -d\" \" -f1)\n\t\t\ti=$(echo\
    \ $i | cut -d\" \" -f1)\n\t\t\tj=$(echo $j | cut -d\" \" -f2)\n\t\t\ti=$(echo\
    \ $i | cut -d\" \" -f2)\n\t\telse\n\t\t\tif [ \"$jm\" -lt \"$im\" -o \"$jp\" -lt\
    \ \"$ip\" ]; then\n\t\t\t\tlocal jm=$(echo $j | cut -d\" \" -f2)\n\t\t\t\tlocal\
    \ im=$(echo $i | cut -d\" \" -f2)\n\t\t\t\tj=$(echo $j | cut -d\" \" -f1)\n\t\t\
    \t\ti=$(echo $i | cut -d\" \" -f1)\n\t\t\t\tj=$(echo $j | cut -d\" \" -f2)\n\t\
    \t\t\ti=$(echo $i | cut -d\" \" -f2)\n\t\t\telif [ \"$jm\" -gt \"$im\" -o \"$jp\"\
    \ -gt \"$ip\" ]; then\n\t\t\t\tlocal jm=$(echo $j | cut -d\" \" -f1)\n\t\t\t\t\
    local im=$(echo $i | cut -d\" \" -f1)\n\t\t\t\tj=$(echo $j | cut -d\" \" -f2)\n\
    \t\t\t\ti=$(echo $i | cut -d\" \" -f2)\n\t\t\t\tj=$(echo $j | cut -d\" \" -f1)\n\
    \t\t\t\ti=$(echo $i | cut -d\" \" -f1)\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"$i\
    \ $j\"", "    local L=$1\n    local TMP VAL\n    local N=$( echo $L | wc -l )\n\
    \    local INDEX\n    local ELEMENT\n    local RESULTS\n    local RESULT\n   \
    \ local NEXT\n    local NEXT_INDEX\n    local NEXT_ELEMENT\n\n    RESULTS=( )\n\
    \n    while [ $n -ge 2 ]\n    do\n        NEXT=\n        INDEX=$( echo $L | sed\
    \ \"s/^\\([0-9]*\\)\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/\\1\\/\\2\\/\\3/\" )\n    \
    \    VAL=$( echo $L | sed \"s/^\\([0-9]*\\)\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/\\\
    1\\/\\2\\/\\3/\" )\n\n        while [ $n -ge 1 ]\n        do\n            NEXT_INDEX=$(\
    \ echo $L | sed \"s/^\\([0-9]*\\)\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/\\1\\/\\2\\/\\\
    3/\" )\n            NEXT_ELEMENT=$( echo $L | sed \"s/^\\([0-9]*\\)\\.\\([0-9]*\\\
    )\\.\\([0-9]*\\)$/$1.\\2.\\$3/\" )\n\n            NEXT=${NEXT_INDEX}\n       \
    \     if [ \"$NEXT\" == \"$INDEX\" ]\n            then\n                RESULT=$(\
    \ echo \"$INDEX\" | sed \"s/\\([0-9]*\\)\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/$1.\\\
    2.\\$3/\" )\n                RESULTS+=(\"$RESULT\")\n                break\n \
    \           fi\n            INDEX=${NEXT_INDEX}\n            if [ \"$INDEX\" ==\
    \ \"$NEXT\" ]\n            then\n                RESULT=$( echo \"$INDEX\" | sed\
    \ \"s/\\([0-9]*\\)\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/$1.\\2.\\$3/\" )\n         \
    \       RESULTS+=(\"$RESULT\")\n                break\n            fi\n      \
    \      NEXT=${NEXT_INDEX}\n        done\n        L=$( echo $L | sed \"s/^\\([0-9]*\\\
    )\\.\\([0-9]*\\)\\.\\([0-9]*\\)$/\\1\\/\\2\\/\\3/\" )\n        n=$(( n - 1 ))\n\
    \    done\n    echo \"${RESULTS[@]}\"", "    local list_to_search=\"$1\"\n   \
    \ local numbers=\"$2\"\n    local closest=$3\n\n    if [ -z \"$list_to_search\"\
    \ ]; then\n        echo \"ERROR: The argument 'list_to_search' was not specified.\"\
    \n        exit 1\n    fi\n    \n    # Split into space-separated list\n    local\
    \ list_elements=( $list_to_search )\n    \n    for element in \"${list_elements[@]}\"\
    ; do\n        local number=${element/$/ }\n        local number_to_search=${numbers/$/\
    \ }\n        if [ \"$number_to_search\" -lt \"$number\" ]; then\n            local\
    \ number_to_search=\"$number $number_to_search\"\n        else\n            local\
    \ number_to_search=\"$number_to_search $number\"\n        fi\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }\n        local number_to_search=${number_to_search/$/\
    \ }\n        local number_to_search=${number_to_search/$/ }", "  local elements\n\
    \  local elements_count=`echo $1 | wc -w`\n  if [ $elements_count -lt 2 ]; then\n\
    \    echo \"Usage: $(basename $0) <elements>\"\n    return 1\n  fi\n  local elements_array=(\
    \ `echo $1 | tr ' ' ','` )\n  local elements_count=${#elements_array[@]}\n  if\
    \ [ $elements_count -gt 2 ]; then\n    echo \"Usage: $(basename $0) <elements>\"\
    \n    return 1\n  fi\n\n  elements=\"\"\n  for (( i=1 ; i <= $elements_count ;\
    \ i++ )); do\n    local element\n    element=`echo $elements_array[$i] | sed -e\
    \ 's/\"\"//g'`\n    if [ -z \"$elements\" ]; then\n      elements=\"$element\"\
    \n    else\n      elements=\"$elements $element\"\n    fi\n  done\n  echo `echo\
    \ $elements | tr ' ' ','`", "    local list=\"$1\"\n    local i j\n    local ret\n\
    \    for (( i=0; i<${#list[@]}-1; i++ )); do\n        local this=\"${list[i]}\"\
    \n        local other=\"${list[i+1]}\"\n        if [ ${#this} = 0 ] ; then\n \
    \           continue\n        fi\n        local diff=\"${this}-${other}\"\n  \
    \      if [ \"${diff}\" = 0 ] ; then\n            continue\n        fi\n     \
    \   local mindiff=\"${diff}\"\n        for (( j=i+1; j<${#list[@]}; j++ )); do\n\
    \            local other2=\"${list[j]}\"\n            local diff2=\"${this}-${other2}\"\
    \n            if [ \"${diff2}\" -lt \"${mindiff}\" ] ; then\n                mindiff=\"\
    ${diff2}\"\n            fi\n        done\n        ret=\"${list[i]}\"\n       \
    \ echo \"${ret}\"\n        (( i+=1 ))\n    done", "    local arr=$1\n    local\
    \ first=$2\n    local second=$3\n    local max1=0\n    local min1=$((${#arr} -\
    \ 1))\n    local max2=0\n    local min2=$((${#arr} - 1))\n    while [ $min1 -le\
    \ $min2 ]; do\n        local val1=${arr[$min1]}\n        local val2=${arr[$min2]}\n\
    \        if [[ $((val1-$val2)) -lt 0 ]]; then\n            ((min1++))\n      \
    \  else\n            if [[ $((val2-$val1)) -lt 0 ]]; then\n                ((min2--))\n\
    \            else\n                if [[ $((val1-$val2)) -gt 0 ]]; then\n    \
    \                if [[ $max1 -eq $min2 ]]; then\n                        max2=$((${#arr}\
    \ - 1))\n                        max1=$((${#arr} - 1))\n                    else\n\
    \                        ((max2++))\n                        max1=$((${#arr} -\
    \ 1))\n                    fi\n                else\n                    if [[\
    \ $max2 -eq $min1 ]]; then\n                        max1=$((${#arr} - 1))\n  \
    \                      max2=$((${#arr} - 1))\n                    else\n     \
    \                   ((max1--))\n                        max2=$((${#arr} - 1))\n\
    \                    fi\n                fi\n            fi\n        fi\n    done\n\
    \    if [[ $max1 -le $min2 ]]; then\n        local val1=${arr[$min1]}\n      \
    \  local val2=${arr[$min2]}\n        local arr2=$((val1$val2))\n        if [[\
    \ $max1 -eq $min2 ]]; then\n            local arr2=${arr2}$((${#arr} - 1))\n \
    \       fi\n        echo $arr2\n        echo $first$arr2\n    else\n        local\
    \ val1=${arr[$max1]}\n        local val2=${arr[$min2]}\n        local arr2=$((val2$val1))\n\
    \        if [[ $max2 -eq $min1 ]]; then\n            local arr2=${arr2}$((${#arr}\
    \ - 1))\n        fi\n        echo $first$arr2\n        echo $arr2\n        echo\
    \ $second$arr2\n    fi", "    local line=$(echo \"$1\" | sed 's/ /\\n/g')\n  \
    \  local numbers=$(echo \"$line\" | tr ' ' '\\n' | sort -n)\n    local smallest=$(echo\
    \ \"$line\" | awk -F' ' '{print $1}' | sort -n)\n    local smallest_index=0\n\
    \    local smallest_diff=0\n    local smallest_min=\"\"\n    local smallest_max=\"\
    \"\n\n    # Loop through all the remaining numbers\n    for (( i=1; i<${#numbers[*]};\
    \ i++ )); do\n        local x=$(echo \"$numbers[$i]\" | tr -d '\\n' | awk -F'[.\
    \ ]' '{print $1}')\n        local y=$(echo \"$numbers[$i]\" | tr -d '\\n' | awk\
    \ -F'[. ]' '{print $2}')\n        local diff=$(($x-$y))\n        if [ \"$diff\"\
    \ -gt \"$smallest_diff\" ]; then\n            smallest_diff=$diff\n          \
    \  smallest_index=$i\n            smallest_min=$x\n            smallest_max=$y\n\
    \        fi\n    done\n\n    echo \"$numbers[$smallest_index]\\t$smallest_min\\\
    t$smallest_max\"", "    local numbers=\"$1\"\n    local smallest=\n    local biggest=\n\
    \    local number=\"0.0\"\n\n    while read -r number; do\n        [ \"$number\"\
    \ = \"$smallest\" ] && break\n        [ \"$number\" = \"$biggest\" ] && break\n\
    \        [ \"$number\" -gt \"$smallest\" ] && smaller=\"$number\"\n        [ \"\
    $number\" -lt \"$biggest\" ] && bigger=\"$number\"\n    done <<< \"$numbers\"\n\
    \n    echo -n \"$smaller\\t$bigger\" | tr ' ' '\\t'", "    local elements\n  \
    \  local min_element\n    local max_element\n    elements=( \"$1\" )\n    min_element=${elements[0]}\n\
    \    max_element=${elements[${#elements[@]} - 1]}\n    if [ $# -eq 1 ]\n    then\n\
    \        for element in \"${elements[@]}\"\n        do\n            [ \"$element\"\
    \ -lt \"$min_element\" ] && min_element=\"$element\"\n            [ \"$element\"\
    \ -gt \"$max_element\" ] && max_element=\"$element\"\n        done\n        echo\
    \ \"$min_element $max_element\"\n    else\n        for element in \"${elements[@]}\"\
    \n        do\n            [ \"$element\" -lt \"$min_element\" ] && min_element=\"\
    $element\"\n            [ \"$element\" -gt \"$max_element\" ] && max_element=\"\
    $element\"\n        done\n        echo \"$min_element $max_element\"\n    fi",
  "\tlocal x=\"$1\" | awk '{for(i=2; i<=NF; i++) print $i}' | sort -n\n\tlocal x=\"\
    $1\" | awk '{for(i=2; i<=NF; i++) print $i}' | sort -n\n\tlocal x=$x$1\n\tlocal\
    \ x=$(echo $x | sed 's/ //g')\n\tlocal x=\"'$x'\"\n\tlocal x=\"$x $x\"\n\techo\
    \ $x", "    local string=\"$1\"\n    local elements=( ${string//(/ } )\n    local\
    \ numbers=( ${string//[[:space:]]/} )\n    # return results in a space-separated\
    \ format (not as space-separated list).\n    local results=( $(sort -nu -k1,1\
    \ -k2,2n -k3,3n -k4,4n -k5,5n -k6,6n \"${elements[@]}\") )\n    echo \"${results[*]}\"",
  "  local list=\"$1\"\n  shift\n  local smaller\n  local bigger\n  local element\
    \ number\n  local result=()\n  local i\n  for element in $list; do\n    if [[\
    \ $element == *\".\"* ]]; then\n      element=${element%.*}\n    fi\n    number=\"\
    ${element}\"\n    for (( i = 0; i < 100; i++ )); do\n      smaller=$(echo \"$number\"\
    \ | awk \"{print $1 - $1}\")\n      bigger=$(echo \"$number\" | awk \"{print $1\
    \ + $1}\")\n      if [[ $smaller -gt $bigger ]]; then\n        result+=(\"$smaller\"\
    )\n        number=$bigger\n      else\n        result+=(\"$bigger\")\n       \
    \ number=$smaller\n      fi\n    done\n  done\n  echo $(printf '%s\\n' \"${result[@]}\"\
    )", "    local list_to_check=$1\n    local numbers=$(echo \"$list_to_check\" |\
    \ sed -e 's/ /\" \" ')\n    local smallest=$(echo \"$list_to_check\" | awk -F\
    \ '[\" \"]' '{ print $1 }')\n    local largest=$(echo \"$list_to_check\" | awk\
    \ -F '[\" \"]' '{ print $2 }')\n    local returned_numbers=\"$smallest\"\n   \
    \ for number in $numbers\n    do\n        local current=$number\n        local\
    \ test=$current\n        while [ $current -gt $smallest ]\n        do\n      \
    \      current=$( echo \"$test\" | awk '{ print $1 }' <<< \"$current + 1 \" )\n\
    \            test=$(echo \"$current\" | awk '{ print $1 }')\n        done\n  \
    \      returned_numbers=\"$returned_numbers $test\"\n    done\n    echo \"$returned_numbers\"",
  "    local i j\n    local list\n\n    list=$1\n    shift\n    for ((i=1; i<${#list};\
    \ i++)); do\n        for ((j=1; j<i; j++)); do\n            [[ ${list[i]} -gt\
    \ ${list[j]} ]] && echo \"$list[$i]\" >> $2 && break || echo \"$list[j]\" >> $2\n\
    \        done\n    done", "    local elements=$1\n    local current_element\n\
    \    local current_min_diff\n    local closest_element\n    local closest_min\n\
    \    local elements\n    local min_index\n    local result\n    local temp\n \
    \   local tmp\n    local tmp1\n    local tmp2\n    local tmp3\n    local tmp4\n\
    \    local tmp5\n    local tmp6\n    local tmp7\n    local tmp8\n    local tmp9\n\
    \n    elements=$(echo $elements | tr '[:space:]' '\\n' | sort -n | sed -e 's/[[:space:]]//g')\n\
    \    for element in $elements; do\n        echo \"$element\"\n        closest_element=$(echo\
    \ $element | awk 'BEGIN {min=1000000; i=1} $1<min {min=$1} $1==min {print $1}\
    \ END {print min}')\n        closest_min=$(echo $element | awk 'BEGIN {min=1000000;\
    \ i=1} $1<min {min=$1} $1==min {print $1} END {print min}')\n        current_element=$(echo\
    \ $element | awk 'BEGIN {min=1000000; i=1} $1==min {print $1} END {print min}')\n\
    \        current_min_diff=$(echo $element | awk 'BEGIN {min=1000000; i=1} $1==min\
    \ {print $1} END {print min}')\n        echo $closest_element\n        echo $current_element\n\
    \        echo $current_min_diff\n        echo $element\n        echo $current_element\n\
    \        echo $elements\n        echo $closest_element\n        echo $closest_min\n\
    \        echo $min_index\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        echo $min\n        echo $min\n\
    \        echo $min\n        echo $min\n        ", "\tlocal elements=\"$1\"\n\t\
    # We remove trailing newlines to make things easier to read.\n\techo \"${elements##*[![:space:]]}\"\
    \n\techo \"${elements##*[[:space:]]}\"\n\techo \"${elements##*[![:space:]][[:space:]]}\"\
    \n\techo \"${elements##*[![:space:]]][![:space:]]}\"", "  # The input list is\
    \ space-separated, split into a list of numbers and remove the double quotes\n\
    \  local elements=$(echo $1 | sed 's/\"//g')\n  local number_list=\"$( echo \"\
    $elements\" | tr -s ' ' | cut -d' ' -f 1)\"\n  local returned_elements=()\n  local\
    \ previous_number=\"$(echo \"$number_list\" | cut -d' ' -f 1)\"\n  local next_number=\"\
    $(echo \"$number_list\" | cut -d' ' -f 2)\"\n  local numbers_length=\"$(echo \"\
    $number_list\" | wc -l | tr -d ' ')\"\n  local current_number=\"1.0\"\n  local\
    \ index=0\n  local max_index=numbers_length\n\n  # Now loop through until we find\
    \ the correct number of elements\n  while [ $index -lt $max_index ]; do\n    current_number=\"\
    ${current_number}.0\"\n    index=$(( $index + 1 ))\n    local next_element=\"\
    $( echo \"$elements\" | sed -n \"${index}p\")\"\n    local distance=$(echo \"\
    $next_element-$previous_number\" | bc)\n    local returned_element=\"$( echo \"\
    $elements\" | sed -n \"${index}p\")\"\n    if [ $distance -le 0 ]; then\n    \
    \  returned_elements=\"$returned_elements$returned_element \"\n    elif [ $distance\
    \ -le 1 ]; then\n      returned_elements=\"$returned_element$returned_elements\
    \ \"\n    else\n      returned_elements=\"$returned_elements$returned_element\"\
    \n    fi\n    previous_number=\"$next_number\"\n    next_number=\"$( echo \"$elements\"\
    \ | sed -n \"${index}p\")\"\n  done\n  returned_elements=\"$returned_elements$(\
    \ echo \"$elements\" | sed -n \"${numbers_length}p\")\"\n  echo $returned_elements",
  "  local input_array=\"$1\"\n  local output_array\n  local min\n  local max\n\n\
    \  if [[ $# -gt 2 ]]; then\n    echo \"Usage: $(basename $0) <list> <number>\"\
    \n    exit 1\n  fi\n\n  if [[ ${#input_array} -le 2 ]]; then\n    echo \"Usage:\
    \ $(basename $0) <list> <number>\"\n    echo \"<list> is a space-separated list\
    \ with at least two elements\"\n    echo \"<number> is a non-negative number\"\
    \n    exit 1\n  fi\n\n  min=$( echo $input_array | awk '{print $1}' | sort -n\
    \ | head -1 )\n  max=$( echo $input_array | awk '{print $1}' | sort -n | tail\
    \ -1 )\n\n  while read input; do\n    local curr_min=$( echo $input | awk '{print\
    \ $1}' | sort -n | head -1 )\n    local curr_max=$( echo $input | awk '{print\
    \ $1}' | sort -n | tail -1 )\n    local output_line\n    local diff\n    local\
    \ curr_diff\n    local curr_diff2\n\n    # Make sure min/max are in the array\n\
    \    if [[ ${#input_array[@]} -eq 1 ]]; then\n      echo \"<list> is a single\
    \ element\"\n      exit 1\n    fi\n\n    if [[ ${#curr_min} -le 0 ]]; then\n \
    \     echo \"<list> is empty\"\n      exit 1\n    fi\n\n    if [[ ${#curr_max}\
    \ -le 0 ]]; then\n      echo \"<list> is empty\"\n      exit 1\n    fi\n\n   \
    \ # Compare the two elements to see which is closest\n    curr_diff=$(echo \"\
    scale=4; ${curr_min} - ${min}\" | bc -l)\n    curr_diff2=$(echo \"scale=4; ${min}\
    \ - ${curr_min}\" | bc -l)\n\n    if [[ ${curr_diff} -gt 0 ]]; then\n      if\
    \ [[ ${curr_diff} -gt ${curr_diff2} ]]; then\n        diff=${curr_diff}\n    \
    \    output_line=\"${min}\"\n      else\n        diff=${curr_diff2}\n        output_line=\"\
    ${curr_min}\"\n      fi\n    else\n      if [[ ${curr_diff2} -gt ${curr_diff}\
    \ ]]; then\n        diff=${curr_diff2}\n        output_line=\"${curr_min}\"\n\
    \      else\n        diff=${curr_diff}\n        output_line=\"${min}\"\n     \
    \ fi\n    fi\n\n    output_array+=(\"$output_line\")\n\n    # Find the next element\
    \ that is closest\n    min=$(( $max + 1 ))\n    max=$((", "    local array=\"\
    $1\"\n    local index=0\n    while [ $index -le ${#array[@]} ]; do\n        local\
    \ candidate=$(( index+1 ))\n        if [ $candidate -gt ${#array[@]} ]; then\n\
    \            candidate=${#array[@]}\n        fi\n        local difference=${array[$candidate]}\n\
    \        local closest=${array[$candidate]}\n        for (( i=$(( candidate-1\
    \ )); i<$(( candidate )); i++ )); do\n            local newdifference=${array[$i]}\n\
    \            local newclosest=${array[$i]}\n            if [ \"${difference}\"\
    \ == \"${newdifference}\" ]; then\n                if [ \"${closest}\" == \"${newclosest}\"\
    \ ]; then\n                    closest=$(( $candidate ))\n                else\n\
    \                    closest=$(( candidate-1 ))\n                    break\n \
    \               fi\n            fi\n        done\n        echo \"\\\"${array[$closest]}\\\
    \"\"\n        (( index++ ))\n    done", "    IFS=$'\\n' read -a list <<< \"$1\"\
    \n\n    for i in \"${list[@]}\"; do\n        IFS=$' ' read -a arr <<< \"$i\"\n\
    \        sort -n -k 2 <<< \"$i\"\n        if [ \"$(( ${#arr[@]} - 1 ))\" -gt 0\
    \ ]; then\n            echo \"${list[@]:${arr[0]}-${arr[1]}}\"\n        else\n\
    \            echo \"$i\"\n        fi\n    done", "  local elements=$1\n  local\
    \ closest=\n  local i=\n  local closest=$(echo $elements | tr \" \" \"\\n\" |\
    \ sort -n | head -1)\n  local j=$(( $RANDOM % ( $(( $#elements )-1 ) )) )\n  if\
    \ [ -z $closest ]; then\n    echo \"ERROR: Could not find a suitable number\"\n\
    \    return 1\n  fi\n  while [ $i -le $(( $#elements )) ]; do\n    if [[ $(( $((\
    \ $i + 1 )) - $j )) -lt 0 ]]; then\n      j=$(( $RANDOM % ( $(( $#elements )-1\
    \ ) )) )\n    fi\n    if [[ $(( $(( $i + 1 )) - $j )) -gt $(( $#elements )) ]];\
    \ then\n      j=$(( $RANDOM % ( $(( $#elements )-1 ) )) )\n    fi\n    if [[ $(echo\
    \ \"${elements[*]}\" | cut -d\" \" -f$(( i + 1 ))) -le $(echo \"${elements[*]}\"\
    \ | cut -d\" \" -f$(( j + 1 ))) ]]; then\n      closest=$(( $i + 1 ))\n    fi\n\
    \    i=$(( $i + 1 ))\n  done\n  echo \"${elements[*]} | ${closest}\"", "    #\
    \ Split on whitespace\n    numbers=($(echo $1 | tr \" \" \" \"))\n\n    # No numbers\
    \ given\n    if [ -z \"$numbers\" ]; then\n        echo \"No numbers given, returning\
    \ empty array\"\n        return \"\"\n    fi\n\n    # Sort the numbers\n    IFS='\
    \ ' read -r -a sorted <<<\"$numbers\"\n    IFS=' ' read -r -a closest <<<\"$(sort\
    \ -n <<<\"${sorted[@]:2:$#-2}\" | sort -n -k)\"\n    IFS=' ' read -r -a sorted_reverse\
    \ <<<\"$sorted[@]\" # Reverse\n    IFS=' ' read -r -a closest_reverse <<<\"$(sort\
    \ -n <<<\"${sorted_reverse[@]:2:$#-2}\" | sort -n -r -k)\"\n\n    # Return them\n\
    \    echo \"${closest[@]}\"", "    numbers=$1 # must be supplied as a space-separated\
    \ string\n    local elements=(`echo $numbers |tr '\"' ' ' `)\n    local smallest\n\
    \    local closest\n    local index\n\n    # get the smallest element\n    smallest=$(echo\
    \ $elements | sort -n | tail -n 1)\n    # get the index of the smallest element\n\
    \    index=$(echo $elements | awk -v smallest=$smallest '$1 ~ smallest {print\
    \ NR-1}')\n    # get the smallest element in the previous index\n    closest=$(echo\
    \ $elements | awk -v smallest=$smallest '$1 ~ smallest {print NR-index}')\n\n\
    \    echo $closest $smallest", "    # Convert to array\n    mapfile -t nums <\
    \ <(echo \"$1\" | sed 's/ /\\n/g' | sort -n -k 1,1 -k 2,2 -k 3,3 -k 4,4)\n   \
    \ # Select two numbers and sort them\n    # Assumes the first number is smaller\n\
    \    echo $(echo \"${nums[@]:2:${#nums[@]}-2}\" | sort -n -k 1,1 -k 2,2)", " \
    \   local elements=\"${1}\"\n\n    local closest_elements=\"\"\n\n    local min_index=0\n\
    \    local max_index=0\n\n    local min_distance=10000\n    local max_distance=-1\n\
    \n    for element in $elements; do\n        local element_distance=$(echo \"$element\"\
    \ | cut -d. -f1)\n        local element_distance_in_float=$((element_distance))\n\
    \        local element_distance_in_int=$((element_distance_in_float))\n      \
    \  local element_float=$((element_distance_in_float/1000000000.0))\n        local\
    \ element_int=$((element_distance_in_int/1000000000.0))\n        local element_int2=$((element_distance_in_int/1000000000))\n\
    \        local element_int3=$((element_distance_in_int/10000000))\n        local\
    \ element_int4=$((element_distance_in_int/1000000))\n        local element_int5=$((element_distance_in_int/100000))\n\
    \        local element_int6=$((element_distance_in_int/10000))\n        local\
    \ element_int7=$((element_distance_in_int/1000))\n        local element_int8=$((element_distance_in_int/100))\n\
    \n        local min=$((element_int))\n        local max=$((element_int))\n   \
    \     local min_distance_in_float=10000\n        local max_distance_in_float=-1\n\
    \n        if [ -z \"$min\" -o -z \"$max\" ]; then\n            echo \"ERROR: Problem\
    \ parsing array $elements\" >&2\n            exit 1\n        fi\n\n        if\
    \ [ \"$min\" -lt \"$max\" ]; then\n            if [ \"$min\" -lt \"$min_distance\"\
    \ ]; then\n                min_distance=$min\n                closest_elements=\"\
    $element\"\n            fi\n            if [ \"$max\" -gt \"$max_distance\" ];\
    \ then\n                max_distance=$max\n                closest_elements=\"\
    $element\"\n            fi\n        else\n            if [ \"$max\" -lt \"$min_distance\"\
    \ ]; then\n                min_distance=$max\n                closest_elements=\"\
    $element\"\n            fi\n            if [ \"$min\" -gt \"$max_distance\" ];\
    \ then\n                max_distance=$min\n                closest_elements=\"\
    $element\"\n            fi\n        fi\n\n        local min_int=$((min))\n   \
    \     local max_int=$((max))\n\n        if [ \"$min_int\" -lt \"$max_int\" ];\
    \ then\n            if [ \"$min_int\" -lt \"$min_distance_in_float\" ]; then\n\
    \                min_distance_in_float=$min_int\n                closest_elements=\"\
    $element\"\n            fi\n            if [ \"$max_int\" -gt \"$max_distance_in_float\"\
    \ ]; then\n                max_distance_in_float=$max_int\n                closest_elements=\"\
    $element\"", "\tlocal elements=$1\n\n\tlocal min_idx=0\n\tlocal min_diff=99999\n\
    \n\tlocal num_elements=$(echo \"$elements\" | wc -l)\n\t\n\tlocal idx=1\n\t\n\t\
    for element in $elements; do\n\t\tdiff=$(echo \"$element - $elements\" | bc)\n\
    \n\t\tif [ \"$diff\" -lt \"$min_diff\" ]; then\n\t\t\tmin_diff=$diff\n\t\t\tmin_idx=$idx\n\
    \t\tfi\n\n\t\t((idx+=1))\n\tdone\n\n\techo \"\\\"$elements[$min_idx]\\\"\"", " \
    \   local i\n    local numbers\n    local closest\n    numbers=$( echo \"$1\"\
    \ | tr -s ' ' , )\n    closest=\n    for i in $( seq 1 \"$#\" ); do\n        local\
    \ number\n        number=$( echo \"$numbers\" | awk -F' ' -v n=$i '$n >= $1 &&\
    \ $n <= $2 { print $n; exit }'  2>/dev/null )\n        if [ \"$number\" != \"\"\
    \ ]; then\n            closest=\"$closest $number\"\n            echo \"$closest\"\
    \n            numbers=$( echo \"$numbers\" | sed \"s/$number //g\" )\n       \
    \ fi\n    done\n    echo \"$closest\"", "    # Check if the number of arguments\
    \ is at least 2\n    local i nearest_min nearest_max\n    local elements x\n \
    \   local num_args tmp\n    num_args=$(#$1); shift\n    if [[ -z $1 ]]; then\n\
    \        echo \"Usage: $(basename $0) [list of] numbers\"\n        exit 1\n  \
    \  fi\n\n    # Initialize $elements to all elements except the first element\n\
    \    elements=$1\n\n    # Initialize $nearest_min to minimum number in $1\n  \
    \  nearest_min=$1\n\n    # Initialize $nearest_max to maximum number in $1\n \
    \   nearest_max=$1\n\n    # Move $1 to the end of $elements and $tmp to all but\
    \ the first element of $1\n    for x in \"$1\"; do elements=\"$elements $x\";\
    \ tmp=\"$tmp $x\"; done\n\n    # Go through all numbers in $elements\n    for\
    \ ((i = 1; i <= num_args; i++)); do\n        # Evaluate $tmp (the first $i elements)\
    \ to a float\n        tmp=$(eval \"echo $tmp\")\n\n        # Find $nearest_min\
    \ and $nearest_max\n        (( nearest_min = $i ))\n        (( nearest_max = $i\
    \ ))\n\n        # Evaluate $elements to an array of floats\n        elements=$(eval\
    \ \"echo $elements\")\n\n        local j\n\n        for (( j = 1; j <= num_args;\
    \ j++ )); do\n            # Skip if $tmp is smaller than $elements[j] or larger\
    \ than $elements[$j]\n            if [[ (( $tmp < $elements[$j] )) || (( $tmp\
    \ > $elements[j] ))]]; then\n                nearest_min=$j\n                nearest_max=$i\n\
    \                break\n            fi\n        done\n\n        (( nearest_min\
    \ = $nearest_min - 1 ))\n        (( nearest_max = $nearest_max + 1 ))\n    done\n\
    \n    # Return both nearest numbers and sort the result so the smallest number\
    \ comes first\n    echo $nearest_min $nearest_max\n    sort -n -k $nearest_min\
    \ -k $nearest_max <<< \"$tmp\"", "    local elements mins maxes\n    local i j\
    \ dist mind\n    local elements_string\n    local i1=1 j1=1 i2=1 j2=1 mind=1 mind_string\n\
    \n    # Strip leading and trailing quotes\n    elements=$(tr -d '\\n' < $1 tr\
    \ '\"' ' ')\n\n    # Convert to integer if possible\n    if [[ ${#elements} -gt\
    \ 2 ]]; then\n        elements_string=$(printf '%s\\n' \"${elements}\")\n    else\n\
    \        elements_string=${elements}\n    fi\n\n    # Sort elements\n    IFS='\
    \ ' read -a elements <<< \"${elements_string}\"\n    IFS=' ' read -a mins <<<\
    \ \"$2\"\n    IFS=' ' read -a maxes <<< \"$3\"\n    IFS=' ' read -a mins <<< \"\
    $4\"\n\n    # Find min and max for one value\n    i=0\n    mind=1\n    for j in\
    \ \"${elements[@]}\"; do\n        dist=$(echo \"${mins[$i]} - ${j}\"|bc)\n   \
    \     (( i < ${#mins[@]} )) || continue\n\n        if (( dist > 0 )); then\n \
    \           mind_string=${mins[$i]}\n            mind=$i\n        fi\n\n     \
    \   (( i++ ))\n    done\n\n    if [[ ${mind} -gt ${#mins[@]} ]]; then\n      \
    \  mind=0\n    fi\n\n    # Find min and max for two values\n    i=0\n    mind=1\n\
    \    for j in \"${elements[@]}\"; do\n        dist=$(echo \"${mins[$i]} - ${j}\"\
    |bc)\n        (( i < ${#mins[@]} )) || continue\n\n        if (( dist > 0 ));\
    \ then\n            mind_string=${mins[$i]}\n            mind=$i\n        fi\n\
    \n        (( i++ ))\n    done\n\n    if [[ ${mind} -gt ${#mins[@]} ]]; then\n\
    \        mind=0\n    fi\n\n    # Return result\n    echo \"${maxes[$mind]}\"\n\
    \    echo \"${mins[$mind]}\"", "\tlocal elements=($1)\n\tlocal min_value=${elements[0]}\n\
    \tlocal max_value=${elements[${#elements[@]}-1]}\n\n\tlocal i=1\n\twhile ((i <\
    \ ${#elements[@]}-1)); do\n\t\tlocal cur_value=${elements[i]}\n\t\tlocal next_value=${elements[i+1]}\n\
    \t\tif [[ ${cur_value} -le ${min_value} ]]; then\n\t\t\tmin_value=${cur_value}\n\
    \t\telif [[ ${cur_value} -ge ${max_value} ]]; then\n\t\t\tmax_value=${cur_value}\n\
    \t\tfi\n\n\t\t((i++))\n\tdone\n\n\techo \"\\\"${min_value}\\\"\"", "    local\
    \ a b d\n    IFS=' ' read -a a < <(echo \"$1\")\n    IFS=' ' read -a b < <(echo\
    \ \"$2\")\n    for ((i=0; i<${#a[@]}; i++))\n    do\n        echo \"${b[$i]}\"\
    \n        d=\"${a[$i]}\"\n        echo \"${a[$((j=$i+1))]}\"\n        if [ \"\
    $d\" == \"$a[$j]\" ]; then\n            echo \"$d\"\n            break\n     \
    \   elif [ \"$d\" == \"$b[$j]\" ]; then\n            echo \"$d\"\n           \
    \ break\n        fi\n    done", "    # $1: list of numbers to compare\n    local\
    \ elements\n    local closest_element\n    local closest_elements_index\n    local\
    \ current_element\n\n    elements=\"$1\"\n    closest_elements_index=0\n    closest_element=\"\
    $(echo \"${elements}\" | awk '{ print $1 }' | sort -n | head -1)\"\n\n    while\
    \ [[ $closest_element != \"$1\" ]] && [ \"$closest_element\" != \"$2\" ]; do\n\
    \        closest_elements_index=$((closest_elements_index+1))\n        current_element=\"\
    $(echo \"${elements}\" | awk \"{print \\\"$closest_element\\\"}\")\"\n       \
    \ closest_element=\"$(echo \"${elements}\" | awk \"{print \\\".\\\"}\" | sed -n\
    \ \"${closest_elements_index}p\" | head -1)\"\n    done\n\n    echo '\"' \"${closest_element}\"\
    '\"", "    local list_string result\n    list_string=\"$1\"\n    while [ \"${list_string}\"\
    \ ]; do\n        result=$(echo \"${list_string}\" | cut -d \" \" -f $(($(echo\
    \ \"${list_string}\" | wc -w) - 2)));\n        result=$(echo \"${list_string}\"\
    \ | sed -e 's/'$result'//');\n        list_string=\"${result} ${list_string#*\
    \ }\"\n    done\n    echo \"${result}\"", "\tlocal arg1=\"$1\"\n\tlocal -a array=()\n\
    \tlocal -a mins=()\n\tlocal -a maxs=()\n\n\t# Break out input into array elements\n\
    \tIFS=\" \"; for element in $arg1; do array+=(\"$element\"); done\n\n\t# Sort\
    \ array\n\tlocal -a sorted=()\n\tfor element in ${array[@]}; do sorted+=(\"$element\"\
    ); done\n\tsorted=( \"${sorted[@]:1:${#sorted[@]}}\" )\n\n\t# Sort numbers in\
    \ array - O(n*log(n))\n\tfor element in ${sorted[@]}; do\n\t\tlocal -a nums=()\n\
    \t\tfor number in ${array[@]}; do\n\t\t\tif [[ $element -gt $number ]]; then\n\
    \t\t\t\tnums+=(\"$number\")\n\t\t\telif [[ $element -lt $number ]]; then\n\t\t\
    \t\tnums+=(\"$number\")\n\t\t\tfi\n\t\tdone\n\t\tmins+=(${nums[0]})\n\t\tmaxs+=(${nums[1]})\n\
    \tdone\n\n\t# Return sorted array\n\tlocal -a sorted_array=()\n\tlocal -a sorted_mins=()\n\
    \tlocal -a sorted_maxs=()\n\tfor index in ${!mins[@]}; do\n\t\tsorted_array+=(\"\
    $mins[$index]\")\n\t\tsorted_mins+=(${mins[$index]})\n\t\tsorted_maxs+=(${maxs[$index]})\n\
    \tdone\n\n\techo \"${sorted_array[@]}\"\n\techo \"${sorted_mins[@]}\"\n\techo\
    \ \"${sorted_maxs[@]}\"\n\n\treturn 0", "\tlocal arg=$1\n\tlocal -a nums=( $(\
    \ echo $arg ) ); # parse the input into an array of numbers\n\tlocal -a index=(${#nums[@]}\
    \ - 1 )\n\tlocal -a result=()\n\tlocal -i i\n\tlocal num1\n\tlocal num2\n\tlocal\
    \ diff\n\n\tresult=(${nums[@]:index[$(( $index == 0 ))]}); # store the original\
    \ first value\n\ti=1\n\twhile [ $i -lt $index ]; do\n\t\tnum1=\"${nums[$i]}\"\n\
    \t\ti=$(( $i + 1 ))\n\t\tif (( index == $i )); then\n\t\t\ti=1\n\t\t\tresult=(${nums[@]:index[$((\
    \ $index == 0 ))]}); # store the original first value\n\t\tfi\n\n\t\tif (( i -lt\
    \ $index )); then\n\t\t\tnum2=\"${nums[$i]}\"\n\t\t\tdiff=$(( $num1 - $num2 ))\n\
    \t\t\tresult=( \"${result[@]}\" \"$num2\" \"$diff\" )\n\t\tfi\n\tdone\n\techo\
    \ \"${result[@]}\"", "    local elements=$1\n    local min=$(echo $elements |\
    \ awk '{print $1}')\n    local max=$(echo $elements | awk '{print $1}')\n    while\
    \ [ $min -le $max ]; do\n        local m=$(($min+1))\n        local n=$(($max-1))\n\
    \        if [ $(echo $elements | awk '{print $1}' | grep -q $m) ]; then\n    \
    \        if [ $(echo $elements | awk '{print $1}' | grep -q $n) ]; then\n    \
    \            min=$m\n            elif [ $(echo $elements | awk '{print $1}' |\
    \ grep -q $n) ]; then\n                max=$n\n            else\n            \
    \    echo $((min))\n                echo $((max))\n            fi\n        fi\n\
    \    done\n    echo $((min))\n    echo $((max))", "    local -n _find_closest_elements=find_closest_elements\n\
    \n    local elements=$1\n    shift\n    local smaller\n    local bigger\n    local\
    \ smaller_val\n    local bigger_val\n    local smaller_pos\n    local bigger_pos\n\
    \n    for (( i=${#elements} ; i-- > 0; )); do\n        smaller=$(echo \"${elements[i]}\"\
    \ | awk '{print $1}')\n        bigger=$(echo \"${elements[i]}\" | awk '{print\
    \ $1}')\n        smaller_val=$(echo \"${elements[i]}\" | awk '{print $2}')\n \
    \       bigger_val=$(echo \"${elements[i]}\" | awk '{print $2}')\n        smaller_pos=$(echo\
    \ \"${elements[i]}\" | awk '{print index($1, smaller)}')\n        bigger_pos=$(echo\
    \ \"${elements[i]}\" | awk '{print index($1, bigger)}')\n        if (( ${#smaller_pos}\
    \ > 0 )); then\n            if (( ${#bigger_pos} > 0 )); then\n              \
    \  echo \"${smaller} ${smaller_val}\"\n                echo \"${bigger} ${bigger_val}\"\
    \n                break\n            else\n                echo \"${smaller} ${smaller_val}\"\
    \n                break\n            fi\n        elif (( ${#smaller_pos} == 0\
    \ )); then\n            echo \"${bigger} ${bigger_val}\"\n            break\n\
    \        fi\n    done", "    local numbers=\"$1\"\n    local result=()\n    local\
    \ num\n    local num2\n    local num3\n    for num in $numbers; do\n        num2=$(echo\
    \ $num | sed -e 's/^\\./\\.0/')\n        num3=$(echo $num | sed -e 's/^\\./\\\
    ./')\n        if (( num2 < num3 )); then\n            result+=( \"\\\"$num2\\\"\
    \" )\n        elif (( num3 < num2 )); then\n            result+=( \"\\\"$num3\\\
    \"\" )\n        fi\n    done\n    echo \"${result[@]}\"", "    declare -i index=0\n\
    \    local arr=(\"$1\")\n    local values=()\n\n    for val in \"${arr[@]}\";\
    \ do\n        # Convert input string \"1.0 2.0 3.0 4.0 5.0 2.0\" to\n        #\
    \ an array: values=(1.0 2.0 3.0 4.0 5.0 2.0).\n        values=(\"${values[@]}\"\
    \ \"$val\")\n    done\n\n    for (( index=1 ; index<${#values[@]} ; index++ ));\
    \ do\n        # Use bc to find the closest two values to the current value in\n\
    \        # values.\n        bc -l <<< \"scale=2; sqrt(((${values[index-1]} - ${values[index]})\
    \ ^ 2 + (${values[index+1]} - ${values[index]}) ^ 2))\"\n    done", "  local IFS=$'\\\
    n'\n  local elements=\"$1\"\n  local output=\"$2\"\n  # The first element must\
    \ be in the list\n  if [[ ${elements%%$elements} != $elements ]]; then\n    echo\
    \ \"ERROR: first element ($elements) not included in supplied list\"\n    exit\
    \ 1\n  fi\n  # The output must be defined\n  if [[ -z \"$output\" ]]; then\n \
    \   echo \"ERROR: second element must be defined\"\n    exit 1\n  fi\n  # The\
    \ first element must be the smallest of the two\n  local first=$(echo \"$elements\"\
    \ | cut -d' ' -f1)\n  local second=$(echo \"$elements\" | cut -d' ' -f2)\n  local\
    \ smallest_difference=$(echo \"$elements\" | cut -d' ' -f1)\n  local new_elements=\"\
    $output\"\n  while read -r line; do\n    # Ignore blank lines\n    if [[ \"$line\"\
    \ != \"\" ]]; then\n      local difference=$(echo \"$line\" | cut -d' ' -f1 -\
    \ | bc -l)\n      if [[ \"$smallest_difference\" == \"$smallest_difference\" ]];\
    \ then\n        # Select the element with the smallest difference\n        smallest_difference=$difference\n\
    \        new_elements=\"$line\"\n      elif [[ \"$difference\" -lt \"$smallest_difference\"\
    \ ]]; then\n        # Keep the smaller number\n        new_elements=\"$line\"\n\
    \      else\n        # Keep the larger number\n        new_elements=\"$line\"\n\
    \      fi\n    fi\n  done < <(echo \"$elements\" | sed 's/ /\",\"/g')\n  printf\
    \ \"%s\\n\" \"${new_elements//$first/$second}\"", "\tlocal numbers=$1\n\tlocal\
    \ smallest=$(echo $numbers | tr -s ' ' | cut -d ' ' -f 1)\n\tlocal largest=$(echo\
    \ $numbers | tr -s ' ' | cut -d ' ' -f 2)\n\tlocal nums=$(echo $numbers |  tr\
    \ -s ' ')\n\tlocal results=()\n\tfor number in $nums; do\n\t\tlocal diff=$(( $number\
    \ - $smallest ))\n\t\tif [[ $diff -lt 0 ]]; then\n\t\t\tdiff=$(( $smallest - $number\
    \ ))\n\t\tfi\n\t\tresults=( \"${results[@]}\" \"$number\" \"${smallest}\" \"${diff}\"\
    \ )\n\tdone\n\techo \"${results[@]}\"", "  local elements=$1\n\n  local closest\n\
    \  local closest_index\n\n  local elements_array=($elements)\n  local array=($elements)\n\
    \n  for index in \"${!array[@]}\"; do\n    closest=\"${array[$index]}\"\n    closest_index=$index\n\
    \    for index2 in \"${!array[@]}\"; do\n      if [ \"$index2\" -gt \"$closest_index\"\
    \ ]; then\n        closest=\"${array[$index2]}\"\n        closest_index=$index2\n\
    \      fi\n    done\n    array=(\"${array[@]:0:$closest_index}\" \"${array[@]:$closest_index+1:$#}\"\
    )\n    array=(\"${array[@]:0:$closest_index}\" \"${closest}\")\n  done\n  echo\
    \ ${array[@]}", "  local list_to_check=$1\n  local list_to_sort=$(echo $list_to_check\
    \ | sed 's/ /\" \"/')\n  local smallest_num=$(echo $list_to_check | sed 's/ /\"\
    \ \"/' | sort -n | sed 's/\"//g' | head -1)\n  local largest_num=$(echo $list_to_check\
    \ | sed 's/ /\" \"/' | sort -n | sed 's/\"//g' | tail -1)\n  local numbers=$(echo\
    \ $list_to_check | sed 's/ /\" \"/' | sort -n | sed 's/\"//g')\n  local next_smallest_num=$(echo\
    \ $list_to_check | sed 's/ /\" \"/' | sort -n | sed 's/\"//g' | awk '{print $2}')\n\
    \  local next_largest_num=$(echo $list_to_check | sed 's/ /\" \"/' | sort -n |\
    \ sed 's/\"//g' | awk '{print $2}')\n  for i in $(seq $(($#numbers-1)) )\n  do\n\
    \    if [ ${numbers[$i]} -gt ${smallest_num} ]\n    then\n      smallest_num=$numbers[$i]\n\
    \    fi\n    if [ ${numbers[$i]} -lt ${largest_num} ]\n    then\n      largest_num=$numbers[$i]\n\
    \    fi\n  done\n  echo $smallest_num $largest_num", "  # Split $1 on spaces into\
    \ a list by splitting on whitespace.\n  # The first element is the minimum, the\
    \ second is the maximum.\n  local min max\n  IFS=$' \\t' read -ra min <<< \"$1\"\
    \n  IFS=$' \\t' read -ra max <<< \"$2\"\n  # The list $min and $max are in the\
    \ correct order.\n  # We use awk to print only lines with $1 between the values\
    \ of $min and $max\n  # (the closest values).\n  local i\n  for (( i = 0; i <\
    \ ${#min[@]}; i++ )); do\n    if [[ ${min[$i]} -gt ${max[$i]} ]]; then\n     \
    \ printf \"\\\"%s\\\"\" ${min[$i]}\n    elif [[ ${max[$i]} -gt ${min[$i]} ]];\
    \ then\n      printf \"\\\"%s\\\"\" ${max[$i]}\n    else\n      printf \"\\\"\
    %s\\\"\" ${min[$i]}\n    fi\n  done\n  echo \"$min[@]\" \"$max[@]\"", "  local\
    \ input=\"$1\"\n  # Split each argument on whitespace and put it into an array.\n\
    \  IFS=$' ' read -r -a array <<< \"$input\"\n  # Find closest pair of values\n\
    \  local closest=\n  local min_index=\n  local max_index=\n  local input_length=\n\
    \  local min_diff=\n  local i=\n  local j=\n  # Loop through each value once,\
    \ find min/max value and compare\n  for ((i=0; i<\"${#array[@]}\"; i++)); do\n\
    \    local current_diff=\n    if ((input_length+=1)); then\n      # If the current\
    \ value is bigger add it to the array for later\n      if [ \"${array[$i]}\" -gt\
    \ \"${array[$input_length]}\" ]; then\n        array+=(\"${array[$i]}\")\n   \
    \     input_length+=1\n      else\n        array[$i]=\n      fi\n    fi\n    for\
    \ ((j=$i; j<\"${#array[@]}\"; j++)); do\n      if ((input_length+=1)); then\n\
    \        local diff\n        diff=\"$(echo \"${array[$i]}\" - \"${array[$j]}\"\
    |bc)\"\n        if ((diff < 0)); then\n          array+=(\"${array[$j]}\")\n \
    \         input_length+=1\n        else\n          current_diff+=$diff\n     \
    \   fi\n      else\n        current_diff=0\n      fi\n      # Compare with previous\
    \ and set closest\n      if ((current_diff < min_diff)); then\n        closest=\"\
    $i\"\n        min_index=\"$j\"\n        min_diff=$current_diff\n      elif ((current_diff\
    \ > max_diff)); then\n        closest=\"$j\"\n        max_index=\"$i\"\n     \
    \   max_diff=$current_diff\n      fi\n    done\n  done\n  # Pull values from array\n\
    \  echo \"${array[${closest}]}\"\n  echo \"${array[${max_index}]}\"", "    # $1:\
    \ space-separated list of floating point numbers\n    # $2: minimum difference\
    \ between any two numbers (default 0.02)\n    # $3: minimum difference between\
    \ any two numbers (default 0.0001)\n    local arr=$(echo $1 | tr ' ' \"\\n\")\n\
    \    local mdev=$3\n    local mindiff=$2\n    local mindiffdev=$mindiff\n    local\
    \ tmp\n    local val\n    local i\n    local j\n    local val2\n    local diffdev\n\
    \    local mindiff2\n    local mindiffdev2\n\n    while read -r line ; do\n  \
    \      arr+=($(echo \"$line\" | tr ' ' \"\\n\"))\n    done < <(printf \"$arr\"\
    )\n\n    for ((i=0; i<${#arr[@]}; i++)); do\n        val=${arr[i]}\n        for\
    \ ((j=i+1; j<${#arr[@]}; j++)); do\n            val2=${arr[j]}\n            diffdev=$(echo\
    \ \"scale=5; $val - $val2\" | bc)\n            if [[ \"$diffdev\" -gt \"$mindiffdev\"\
    \ ]]; then\n                mindiffdev=\"$diffdev\"\n                mindiff=$i\n\
    \                mindiff2=$j\n            fi\n            if [[ \"$diffdev\" -eq\
    \ \"$mindiffdev\" ]]; then\n                mindiff2=$j\n                mindiffdev2=$mindiffdev\n\
    \            fi\n        done\n    done\n\n    echo \"${arr[$mindiff2]}\"", "\t\
    local elems=$(sed -E 's/(.*[^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^\
    \ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*([^ ])[ ]*", "\tlocal\
    \ elements=$1\n\tlocal closest_numbers=()\n\tlocal index=0\n\tlocal prev_number=\"\
    \"\n\tlocal prev_element=\"\"\n\tlocal elements_index=0\n\tlocal elements_length=$((\
    \ ${#elements} ))\n\tfor (( index=0; index < ${elements_length}; index++ )); do\n\
    \t\tlocal number=$( echo \"${elements}\" | cut -d ' ' -f $index )\n\t\tif [ $((\
    \ ${index} % 2 )) -ne 0 ]; then\n\t\t\tclosest_numbers=\"${closest_numbers} \\\
    \"$number\\\"\"\n\t\tfi\n\tdone\n\techo \"${closest_numbers}\"", "    local l=$1\n\
    \    local nums\n    local maxval\n    local minval\n    local num\n\n    if [[\
    \ -z \"$l\" ]]; then\n        return 2\n    fi\n\n    nums=( $l )\n    maxval=${nums[0]}\n\
    \    minval=${nums[0]}\n\n    for num in \"${nums[@]:1}\"; do\n        if [ \"\
    $maxval\" -gt \"$num\" ]; then\n            maxval=$num\n        fi\n        if\
    \ [ \"$minval\" -lt \"$num\" ]; then\n            minval=$num\n        fi\n  \
    \  done\n\n    echo \"${nums[@]:1:2}\"", "    set -e  # ensure script will fail\
    \ and exit if any command fails\n    set -v  # ensure script will output any command\
    \ that fails\n    IFS=', ' read -a list <<< \"$1\"\n    local smallest_diff smallest_element\
    \ smallest_idx \n    local biggest_diff biggest_element biggest_idx\n    for i\
    \ in \"${!list[@]}\"; do\n        diff=$( echo \"( ${list[$i]} - $2 )\" | bc -l\
    \ )\n        if [ \"$diff\" -lt \"$smallest_diff\" ]; then\n            smallest_diff=\"\
    $diff\"\n            smallest_element=\"$2\"\n            smallest_idx=\"$i\"\n\
    \        fi\n        if [ \"$diff\" -gt \"$biggest_diff\" ]; then\n          \
    \  biggest_diff=\"$diff\"\n            biggest_element=\"$2\"\n            biggest_idx=\"\
    $i\"\n        fi\n    done\n    echo \"${list[$smallest_idx]}\"\n    echo \"${list[$biggest_idx]}\"",
  "    local l=( $1 );\n    local n=$(( ${#l[@]} - 1 ));\n    local x1 x2;\n    local\
    \ d;\n\n    # sort by absolute difference\n    for ((i=0; i < $n; i++))\n    do\n\
    \        d=$(( ${l[$i]} - ${l[$(($n-1)+i)]} ));\n        l[$i]=`echo \"$d\" |\
    \ bc`; \n    done\n    n=$(( ${#l[@]} - 1 ));\n    l=( ${l[@]} );\n    for ((i=0;\
    \ i<$n; i++))\n    do\n        x1=$l[i];\n        x2=$l[((i+1)%$n)];\n       \
    \ if [[ \"$x1\" > \"$x2\" ]]\n        then\n            l[((i%$n)+1)]=${l[i]};\n\
    \            l[i]=${l[((i+1)%$n)]};\n            l[((i%$n)+1)]=$x1;\n        \
    \    l[i]=$x2;\n        fi\n    done\n    echo ${l[@]};", "    local elements\n\
    \    IFS=$'\\n' elements=($1)\n    elements=${elements[0]}\n    local i\n    local\
    \ closest\n    local current\n    local number\n    local result\n    for i in\
    \ \"${elements[@]}\"; do\n        current=$(echo \"$i\" | cut -d \" \" -f 1)\n\
    \        closest=$(echo \"$i\" | cut -d \" \" -f 2)\n        if [ -z \"$current\"\
    \ ]; then\n            current=$(echo \"$closest\" | cut -d \" \" -f 1)\n    \
    \        closest=$(echo \"$closest\" | cut -d \" \" -f 2)\n        fi\n      \
    \  result=$(echo \"$current $closest\" | sort)\n        if [ \"$result\" == \"\
    $i\" ]; then\n            current=$(echo \"$closest\" | cut -d \" \" -f 1)\n \
    \           closest=$(echo \"$closest\" | cut -d \" \" -f 2)\n            continue\n\
    \        fi\n        local max\n        local min\n        if [ \"$i\" == \"$result\"\
    \ ]; then\n            echo \"$i\"\n            exit\n        fi\n        local\
    \ num\n        num=$(echo \"$i\" | cut -d \" \" -f 1)\n        num=$(echo \"$num\"\
    \ | tr -d '[:space:]')\n        num=$(echo \"$num\" | tr '[:upper:]' '[:lower:]')\n\
    \        max=$(echo \"$i\" | cut -d \" \" -f 2)\n        min=$(echo \"$i\" | cut\
    \ -d \" \" -f 3)\n        if [ \"$min\" == \"$max\" ]; then\n            echo\
    \ \"$i\"\n            exit\n        fi\n        if [ \"$num\" == \"$max\" ]; then\n\
    \            echo \"$i\"\n            exit\n        fi\n        if [ \"$num\"\
    \ == \"$min\" ]; then\n            echo \"$i\"\n            exit\n        fi\n\
    \        local num\n        num=$(echo \"$max\" | cut -d \" \" -f 1)\n       \
    \ num=$(echo \"$num\" | tr -d '[:space:]')\n        num=$(echo \"$num\" | tr '[:upper:]'\
    \ '[:lower:]')\n        if [ \"$num\" == \"$min\" ]; then\n            echo \"\
    $i\"\n            exit\n        fi\n        if [ \"$num\" == \"$max\" ]; then\n\
    \            echo \"$i\"\n            exit\n        fi\n        num=$(echo \"\
    $max\" | cut -d \" \" -f 2)\n        num=$(echo \"$num\" | tr -d '[:space:]')\n\
    \        num=$(echo \"$num\" | tr '[:upper:]' '[:lower:]')\n        if [ \"$num\"\
    \ == \"$min\" ]; then\n            echo \"$i\"\n            exit\n        fi\n\
    \        if [ \"$num\" == \"", "    local elements=$1\n    local distance\n  \
    \  local min\n    local max\n    local min_index\n    local max_index\n    local\
    \ min_index\n    local max_index\n\n    # Parse elements into an array\n    IFS='\
    \ ' read -a elements <<< \"${elements}\"\n\n    # Find the smallest and largest\
    \ elements\n    min=\"${elements[0]}\"\n    max=\"${elements[0]}\"\n    for i\
    \ in \"${elements[@]:1}\"; do\n        distance=\"$(( ( $(echo \"${i} - ${min}\"\
    |bc -l) ^ 2 ) / 2))\"\n        (( min_index = $( echo \"${i} - ${min}\"|bc -l\
    \ ) < $min_index )) || min_index=$i\n        (( max_index = $( echo \"${i} - ${min}\"\
    |bc -l ) > $max_index )) || max_index=$i\n        min=\"$(( ${min} > ${i} )) ||\
    \ min=${i}\"\n        max=\"$(( ${max} < ${i} )) || max=${i}\"\n    done\n\n \
    \   # Sort and return the min and max\n    sort -n -k 1,1 -k 2,2n -k 3,3n -k 4,4n\
    \ -k 5,5n <<< \"${min},${max}\"", "    local input=\"$1\"\n    local min_value\
    \ max_value\n    local output_arr\n    local arr\n    local i\n    local j\n \
    \   local output\n    local tmp\n\n    # Find the minimum and maximum value\n\
    \    arr=( $input )\n    min_value=${arr[0]}\n    max_value=${arr[-1]}\n\n   \
    \ # Store the elements of the array in an array to compare with others\n    output_arr=($arr)\n\
    \n    # Store the minimum value in the first element and the maximum value in\
    \ the last element\n    arr=( ${output_arr[@]} ); min_value=${arr[0]}; max_value=${arr[-1]}\n\
    \n    for (( i = 0; i < ${#arr[@]}; i++ )); do\n        arr[i]=${arr[i]//\\\"\
    /}\n        arr[i]=${arr[i]//,/}\n        arr[i]=${arr[i]//,/}\n        arr[i]=${arr[i]//,/}\n\
    \    done\n\n    # Start looping from first element\n    for (( i = 1; i < ${#arr[@]};\
    \ i++ )); do\n        if [[ $min_value < ${arr[i]} ]]; then\n            min_value=${arr[i]}\n\
    \        fi\n\n        if [[ $max_value > ${arr[i]} ]]; then\n            max_value=${arr[i]}\n\
    \        fi\n    done\n\n    # Loop until we reach the first element or the difference\
    \ between the maximum and minimum elements is less\n    # than an acceptable threshold\n\
    \    while [ ${i} -lt ${#arr[@]} ]; do\n        tmp=$min_value\n\n        for\
    \ (( j=0; j < ${#arr[@]}; j++ )); do\n            if [[ $tmp -eq ${arr[j]} ]];\
    \ then\n                tmp=${arr[j]}\n            fi\n        done\n\n      \
    \  if [[ ${tmp} != $min_value ]]; then\n            output_arr[i-1]=\"$min_value\"\
    \n        fi\n\n        if [[ ${tmp} != $max_value ]]; then\n            output_arr[i]=\"\
    $max_value\"\n        fi\n\n        (( i+=1 ))\n\n        if [[ ${i} -eq ${#arr[@]}\
    \ ]]; then\n            break\n        fi\n\n        for (( j=1; j < ${#arr[@]};\
    \ j++ )); do\n            arr[j-1]=${arr[j-1]//\\\"/}\n            arr[j-1]=${arr[j-1]//,/}\n\
    \            arr[j-1]=${arr[j-1]//,/}\n            arr[j-1]=${arr[j-1]//,/}\n\
    \        done\n\n        min_value=${arr[0]}\n        max_value=${arr[-1]}\n\n\
    \        # Start looping from first element\n", "  local elements=${1}\n  local\
    \ values=${2:-$elements}\n  local value\n  local i\n  local j\n  local closest\n\
    \  local prev\n  local next\n  local result\n\n  for ((i=0; i < ${#elements} &&\
    \ i < 2; i++)); do\n    value=${values[i]}\n    prev=${values[i - 1]}\n    next=${values[i\
    \ + 1]}\n    prev=${prev//\\\"/}\n    next=${next//\\\"/}\n    closest=${prev}\n\
    \    for ((j=0; j < ${#prev}; j++)); do\n      if  [ ${#prev} -gt ${#next} ];\
    \ then\n        closest=${prev}\n        break\n      elif [ ${#next} -gt ${#prev}\
    \ ]; then\n        closest=${next}\n        break\n      fi\n    done\n\n    [\
    \ ${#closest} -eq ${#value} ] && result+=${closest}\n  done\n\n  result=( $(printf\
    \ '\"%s\"\\n' \"${result[@]}\") )\n  echo ${result[@]}", "\tlocal array=\"$1\"\
    \n\tlocal elements\n\tlocal index\n\tlocal lower\n\tlocal upper\n\telements=()\n\
    \tlower=0\n\tupper=`expr ${#array} - 1`\n\twhile [ \"$lower\" -le \"$upper\" ];\
    \ do\n\t\tindex=`expr $lower + $(( $upper - $lower - 1 ))`\n\t\tlower=`expr $lower\
    \ + 1`\n\t\tupper=`expr $upper - 1`\n\t\tif [ \"$lower\" -le \"$index\" ]; then\n\
    \t\t\tlower=$index\n\t\tfi\n\t\tif [ \"$upper\" -ge \"$index\" ]; then\n\t\t\t\
    upper=$index\n\t\tfi\n\t\telements[$index]=\"${array[$index]}\"\n\tdone\n\techo\
    \ \"$elements\"", "    local input=$1\n\n    # Trim spaces off input\n    input=${input//\
    \ /}\n\n    # Split input on white space\n    local elements=$( echo $input |\
    \ sed -e \"s/ /\\n/g\" )\n\n    # Select two elements and sort them (smallest\
    \ first)\n    local output=\"\"\n    local smallest=${elements[0]}\n    local\
    \ largest=${elements[1]}\n    local lowest_index=0 # Index for smallest element\n\
    \    local highest_index=0 # Index for largest element\n    for element in ${elements[@]};\
    \ do\n        if [[ $element -gt $smallest ]]; then\n            smallest=$element\n\
    \            lowest_index=$(($lowest_index+1))\n        elif [[ $element -lt $smallest\
    \ ]]; then\n            largest=$element\n            highest_index=$(($highest_index+1))\n\
    \        fi\n    done\n\n    # Sort the output in ascending order\n    for ((\
    \ i=0; i<$lowest_index; i++ )); do\n        output+=\" $smallest\"\n    done\n\
    \    for (( j=$lowest_index; j<$highest_index; j++ )); do\n        output+=\"\
    \ $elements[j]\"\n    done\n    for (( k=$highest_index; k<$lowest_index; k++\
    \ )); do\n        output+=\" $largest\"\n    done\n\n    echo \"$output\"", " \
    \ # $1 is space-separated list\n  # $2 is the value to use to compare\n  # $3\
    \ is the value to return as smallest\n  # $4 is the value to return as largest\n\
    \  # $5 is the value to return as first\n  # $6 is the value to return as last\n\
    \n  # First find smallest and largest\n  smallest=${1[0]}\n  largest=${1[1]}\n\
    \  count=0\n\n  # Loop through numbers and find closest\n  for number in ${1[@]};\
    \ do\n    local current=$number\n    local closest_number\n    local closest_dist=$((\
    \ $number - $2 ))\n\n    if [ \"$smallest\" == \"$2\" ]; then\n      closest_number=$2\n\
    \      closest_dist=$(( $closest_dist ))\n    elif [ \"$smallest\" == \"$3\" ];\
    \ then\n      closest_number=$3\n      closest_dist=$(( $closest_dist ))\n   \
    \ elif [ \"$smallest\" == \"$4\" ]; then\n      closest_number=$4\n      closest_dist=$((\
    \ $closest_dist ))\n    elif [ \"$smallest\" == \"$5\" ]; then\n      closest_number=$5\n\
    \      closest_dist=$(( $closest_dist ))\n    elif [ \"$smallest\" == \"$6\" ];\
    \ then\n      closest_number=$6\n      closest_dist=$(( $closest_dist ))\n   \
    \ else\n      closest_number=$current\n      closest_dist=$(( $closest_dist ))\n\
    \    fi\n\n    smallest=$number\n    count=$(( count + 1 ))\n\n    # Compare against\
    \ smallest and replace if closest\n    if [ \"$closest_dist\" == \"0\" ]; then\n\
    \      # Replace smallest with the current smallest\n      smallest=$current\n\
    \    elif [ \"$closest_dist\" == \"1\" ]; then\n      # Replace smallest with\
    \ current largest and current smallest\n      smallest=$current\n      largest=$current\n\
    \    elif [ \"$closest_dist\" == \"-1\" ]; then\n      # Replace smallest with\
    \ current smallest and current largest and current smallest\n      smallest=$current\n\
    \      largest=$current\n      smallest=$current\n      largest=$current\n   \
    \ elif [ \"$closest_dist\" == \"-2\" ]; then\n      # Replace smallest with current\
    \ smallest and current largest and current smallest\n      smallest=$current\n\
    \      largest=$current\n      smallest=$current\n      largest=$current\n   \
    \ elif [ \"$closest_dist\" == \"1\" -a \"$closest_dist\" == \"-1\" ]; then\n \
    \     # Replace smallest and largest with current smallest\n      smallest=$current\n\
    \      largest=$current\n    elif [ \"$closest_dist\" == \"1\" -a \"$closest_dist\"\
    \ == \"-2\" ]; then\n      # Replace smallest and largest with current largest ",
  "    # Read input values\n    input=$1\n    IFS=' ' read -r -a elements <<< \"$input\"\
    \n    IFS='.' read -r -a values <<< \"$1\"\n    length=\"${#values[@]}\"\n   \
    \ if [ \"$length\" -ne 2 ] ; then\n        echo \"Error: expecting 2 elements\"\
    \n        exit 1\n    fi\n    \n    # Find smallest and largest values\n    min=$((\
    \ ${values[0]} ))\n    max=$(( ${values[1]} ))\n    for (( i=1 ; i<$length ; i++\
    \ )) ; do\n        value=$(( ${values[$i]} ))\n        if [[ $value -lt $min ]]\
    \ ; then\n            min=$value\n        elif [[ $value -gt $max ]] ; then\n\
    \            max=$value\n        fi\n    done\n    \n    # Return values in order\n\
    \    arr=()\n    for (( i=1 ; i<$length ; i++ )) ; do\n        if [[ $i -ne 1\
    \ ]] ; then\n            arr+=($(( ${values[$i]} )))\n        else\n         \
    \   arr+=($min)\n        fi\n    done\n    arr+=( $(( ${values[$length-1]} )))\n\
    \    \n    printf '%s\\n' \"${arr[@]}\"", "    local a=\"${1// /}\" # replace\
    \ spaces with commas\n    local b=( $a ) # split the string into an array\n  \
    \  local c\n    for (( i=0; i < ${#b[@]} ; i++ )); do\n        local d=\"${b[$i]}\"\
    \n        local e\n        for (( j=0; j < ${#b[@]} ; j++ )); do\n           \
    \ if [[ \"$j\" -eq \"$i\" ]]; then\n                continue\n            fi\n\
    \            if [ \"$d\" -eq \"$b[$j]\" ]; then\n                e=\"$b[$j]\"\n\
    \                break\n            fi\n        done\n        local f\n      \
    \  for (( j=0; j < ${#b[@]} ; j++ )); do\n            if [[ \"$j\" -eq \"$i\"\
    \ ]]; then\n                continue\n            fi\n            if [ \"$d\"\
    \ -eq \"$b[$j]\" ]; then\n                f=\"$b[$j]\"\n                break\n\
    \            fi\n        done\n        b[${#b[@]}-1]=\"$e\"\n        b[${#b[@]}-1]=\"\
    $f\"\n    done\n    local g\n    for (( i=0; i < ${#b[@]} ; i++ )); do\n     \
    \   local h\n        for (( j=0; j < ${#b[@]} ; j++ )); do\n            if [[\
    \ \"$j\" -eq \"$i\" ]]; then\n                continue\n            fi\n     \
    \       if [ \"$b[${#b[@]}]\" -gt \"$b[$j]\" ]; then\n                h=\"$b[$j]\"\
    \n                break\n            fi\n        done\n        b[${#b[@]}-1]=\"\
    $h\"\n    done\n    for (( i=0; i < ${#b[@]} ; i++ )); do\n        local i\n \
    \       for (( j=0; j < ${#b[@]} ; j++ )); do\n            if [[ \"$j\" -eq \"\
    $i\" ]]; then\n                continue\n            fi\n            if [ \"$b[${#b[@]}]\"\
    \ -gt \"$b[$j]\" ]; then\n                i=$b[$j]\n                break\n  \
    \          fi\n        done\n        b[${#b[@]}-1]=\"$i\"\n    done\n    echo\
    \ \"${b[@]}\"", "  # Use awk to remove extra quotes\n  echo \"$1\" | awk '{for\
    \ (i=1; i<=NF; i++) {gsub(/\"/, \"\", a[i]); a[i]=(length(a[i]) > length($i))\
    \ ? a[i]: $i}}'", "    local list=$(echo \"$1\" | tr \" \" \"\\n\")\n    local\
    \ smallest_value=$(echo \"$1\" | cut -d' ' -f1)\n    local other_value=$(echo\
    \ \"$1\" | cut -d' ' -f2)\n    local i=$(echo \"$list\" | grep -v \"^$smallest_value$\"\
    \ | wc -l)\n    if [ $i -eq 0 ] ; then echo \"$smallest_value\"; return 1; fi\n\
    \    if [ $i -gt 0 ] ; then echo \"$smallest_value\" ; return 1; fi\n    local\
    \ j=$(echo \"$list\" | grep \"$smallest_value\" | wc -l)\n    if [ $j -eq 0 ]\
    \ ; then echo \"$other_value\"; return 1; fi\n    if [ $j -gt 0 ] ; then echo\
    \ \"$other_value\" ; return 1; fi\n    local k=$(( i - 1 ))\n    if [ $(echo \"\
    $list\" | grep \"$list\" | sort | uniq | wc -l) -gt 2 ] ; then\n        echo \"\
    $list\" | sed -n \"$kp,$(( i + 1 ))p\"\n    else\n        echo \"$list\" | sed\
    \ -n \"$kp,$i\"\n    fi", "  local elements=$1\n  local min_value=${elements[1]}\n\
    \  local max_value=${elements[2]}\n  local min_element\n  local max_element\n\
    \  local element_count\n  local index\n\n  for index in \"${!elements[@]}\"; do\n\
    \    local value=${elements[index]};\n    local value_diff=$((value - min_value));\n\
    \    local value_diff_diff=$((value_diff - max_value));\n\n    if [[ -z \"${value_diff}\"\
    \ ]]; then\n      if [[ -z \"${value_diff_diff}\" ]]; then\n        echo \"${elements[index]}\"\
    \n      else\n        echo ${min_element}\n        return\n      fi\n    fi\n\
    \    local elements_diff=$((index - max_index));\n    local elements_diff_diff=$((elements_diff\
    \ - max_element));\n\n    if [[ -z \"${elements_diff}\" ]]; then\n      min_value=${value}\n\
    \      min_element=${elements[index]}\n      max_value=${value}\n      max_element=${elements[index]}\n\
    \    elif [[ -z \"${elements_diff_diff}\" ]]; then\n      max_value=${value}\n\
    \      max_element=${elements[index]}\n    elif [[ -z \"${value_diff_diff}\" ]];\
    \ then\n      min_value=${value}\n      min_element=${elements[index]}\n     \
    \ max_value=${value}\n      max_element=${elements[index]}\n    elif [[ -n \"\
    ${value_diff}\" ]] && [[ -n \"${elements_diff}\" ]]; then\n      local min_diff=$((value_diff\
    \ - elements_diff));\n      if [[ ${min_diff} -gt 0 ]]; then\n        echo \"\
    ${elements[index]}\"\n      fi\n    fi\n  done\n  echo \"${min_element}\"", "\t\
    local input_str=$1\n\tlocal elements=$( echo $input_str |  sed -e 's/^[ \\t]*//'\
    \ -e 's/[ \\t]*$//' )\n\tlocal distance\n\tlocal element\n\tlocal closest_element\n\
    \tlocal output_str=\"\"\n\n\twhile read line\n\tdo\n\t\tdistance=\"$( echo \"\
    scale=2; $element - $line\" | bc )\"\n\t\tif [[ $distance -lt 0 ]]; then\n\t\t\
    \tdistance=\"$( echo \"scale=2; $line - $element\" | bc )\"\n\t\tfi\n\t\t\n\t\t\
    if [[ $distance -gt 0 ]]; then\n\t\t\tclosest_element=\"$( echo \"$line\" | bc\
    \ )\"\n\t\t\toutput_str=\"$output_str '\\\"'$line'\\\"'\"\n\t\tfi\n\tdone <<<\
    \ \"$elements\"\n\techo \"$output_str\"", "    IFS=$'\\n' read -r -a array <<<\
    \ \"$1\"\n    local closest=$2\n\n    local min\n    local i\n    local len\n\
    \    for (( i=0; i < ${#array[@]} - 1; i++ )); do\n        len=\"${#array[$i]}\"\
    \n        if (( len > min )); then\n            min=$len\n            closest=\"\
    ${array[$i]}\"\n        fi\n    done\n\n    echo \"${closest}\"", "    local elements=(\
    \ \"$@\" )\n    local smallest_element=\"${elements[0]}\"\n    local largest_element=\"\
    ${elements[0]}\"\n\n    for (( i=1; i<${#elements[@]} ; i++)); do\n        local\
    \ temp=\"${elements[i]}\"\n\n        if [[ ${smallest_element} -gt ${temp} ]];\
    \ then\n            smallest_element=\"${temp}\"\n        fi\n        if [[ ${largest_element}\
    \ -lt ${temp} ]]; then\n            largest_element=\"${temp}\"\n        fi\n\
    \    done\n    echo \"${smallest_element} ${largest_element}\"", "\tlocal elements=$1\n\
    \tlocal numElements=$(echo $elements | wc -w)\n\tlocal min=$2\n\tlocal max=$3\n\
    \tlocal closest1=\"\"\n\tlocal closest2=\"\"\n\n\t# If there is only one element,\
    \ return that.\n\tif [[ $numElements -eq 1 ]] ; then\n\t\techo $elements\n\t\t\
    return 0\n\tfi\n\n\t# For each element find the minimum and the maximum.\n\tlocal\
    \ i=0\n\tlocal temp1=$min\n\tlocal temp2=$max\n\twhile [ $i -lt $numElements ]\n\
    \tdo\n\t\ttemp1=$(echo $temp1 | sed -e \"s/\\(.\\)/\\$1./\") #add decimal point\
    \ to each element\n\t\ttemp2=$(echo $temp2 | sed -e \"s/\\(.\\)/\\$1./\") #add\
    \ decimal point to each element\n\t\ti=$((i + 1))\n\tdone\n\n\t# For each element\
    \ find the closest element and store it in closest array\n\tlocal j=0\n\twhile\
    \ [ $j -lt $numElements ]\n\tdo\n\t\tlocal min1=$(echo $temp1 | sed -e \"s/\\\
    (.\\)/\\$1./\") #add decimal point to each element\n\t\tlocal max1=$(echo $temp2\
    \ | sed -e \"s/\\(.\\)/\\$1./\") #add decimal point to each element\n\t\tlocal\
    \ diff1=$(echo $max1 - $min1)\n\t\tlocal min2=$(echo $temp1 | sed -e \"s/\\(.\\\
    )/\\$1./\") #add decimal point to each element\n\t\tlocal max2=$(echo $temp2 |\
    \ sed -e \"s/\\(.\\)/\\$1./\") #add decimal point to each element\n\t\tlocal diff2=$(echo\
    \ $min2 - $max2)\n\t\tlocal diff=$(echo $diff1 | $diff2)\n\t\tlocal closestElement=$(echo\
    \ $elements | sed -e \"s/$min1/$min2/g\") #replace min with max\n\t\techo $closestElement\n\
    \t\tclosestArray[$j]=$closestElement\n\t\tclosestArray[$j+1]=$closestElement\n\
    \t\tj=$((j + 2))\n\tdone\n\n\techo $closestArray\n\treturn 0", "    local input=\"\
    $1\"\n    shift\n    local inputs=($@)\n    local smallest_value\n    local smallest_index\n\
    \    local largest\n    local largest_index\n    local element\n    for index\
    \ in ${#inputs[@]};\n    do\n        smallest_value=${inputs[index]}\n       \
    \ smallest_index=\"${index}\"\n        largest=${inputs[0]}\n        largest_index=0\n\
    \        for element in \"${inputs[@]}\"\n        do\n            local value=\"\
    $(echo \"${element}\" | awk -F '\"' '{ print $2 }')\"\n            local index=\"\
    $(echo \"${element}\" | awk -F '\"' '{ print $1 }')\"\n            local diff=\"\
    $(( ${value} - ${largest} ))\"\n            if [ ${diff} -le 0 ]; then\n     \
    \           largest=\"${value}\"\n                largest_index=\"${index}\"\n\
    \            else\n                if [ ${diff} -gt 0 ]; then\n              \
    \      smallest=\"${value}\"\n                    smallest_index=\"${index}\"\n\
    \                fi\n            fi\n        done\n        echo -n \"${smallest_value}\"\
    \ \"${smallest_index}\"\n        echo -n \" \" \"${largest}\" \"${largest_index}\"\
    \n    done", "    local numbers=\"$1\"\n    local index=1\n    local smallest=\"\
    $(echo \"$numbers\" | awk '{print $1}')\"\n    local largest=\"$(echo \"$numbers\"\
    \ | awk '{print $1}')\"\n\n    # Handle case where numbers contain spaces.\n \
    \   while [ \"$(echo \"$numbers\" | awk '{print $1}')\" != \"\" ]; do\n      \
    \  smallest=\"$(echo \"$smallest\" | awk '{print $1}')\"\n        largest=\"$(echo\
    \ \"$largest\" | awk '{print $1}')\"\n        numbers=\"$(echo \"$numbers\" |\
    \ awk '{print $2}')\"\n        index=$(($index+1))\n    done\n\n    # Handle case\
    \ where there is only one number in the list.\n    numbers=\"$numbers\"\n    if\
    \ [ \"$numbers\" == \"1\" ]; then\n        smallest=\"1\"\n        largest=\"\
    1\"\n        index=0\n        return\n    fi\n\n    local number\n    while [\
    \ \"$index\" -lt \"$((index+1))\" ];\n    do\n        number=\"$(echo \"$numbers\"\
    \ | awk -v index=\"$index\" '{print $index}')\"\n        local diff=\"$(( $number\
    \ - $smallest ))\"\n        smallest=\"$(echo \"$smallest\" | awk '{print $1}'\
    \ | awk -v diff=\"$diff\" '{print $1}')\"\n        largest=\"$(echo \"$largest\"\
    \ | awk '{print $1}' | awk -v diff=\"$diff\" '{print $1}')\"\n        numbers=\"\
    $(echo \"$numbers\" | awk '{print $2}')\"\n        index=$(($index+1))\n    done\n\
    \n    echo \"$smallest $largest\"", "  IFS=\" \"\n  echo \"$1\" | sort -n | uniq\
    \ -d | cut -d ' ' -f 2-", "    IFS=$' '\n    set -- $1 2<$2 |\n    head -n1 |\n\
    \    cut -d ' ' -f2 |\n    sort --key=2 |\n    tail -n1", "  local numbers=\"\
    $1\"\n  local result\n  if [[ ${#numbers} -le 2 ]]; then\n    echo \"No numbers\
    \ supplied\"\n    return 1\n  fi\n  local array=( ${numbers//,/ } )\n  local close=\"\
    0 0\"\n  local i\n  for ((i=0; i < ${#array[@]}; i++)); do\n    local number=\"\
    ${array[i]}\"\n    local closest=\"$(echo $number | awk '{print sqrt ($1 - $2)}')\"\
    \n    if [[ $closest -lt $close ]]; then\n      close=\"$closest\"\n      result=\"\
    ${number}\"\n    fi\n  done\n  echo \"$result\"", "  local list_numbers=\"${1#*[!0-9.]}\"\
    \n  local numbers=( $list_numbers )\n  local smaller_number largest_number current_number\n\
    \  local smallest_distance\n  local distance\n  local element\n  for (( i = 0;\
    \ i < ${#numbers[*]}; i++ )); do\n    current_number=${numbers[$i]}\n    smallest_distance=99999\n\
    \    for (( j = (i + 1); j < ${#numbers[*]}; j++ )); do\n      distance=$( echo\
    \ \"$current_number ${numbers[j]}\" | bc -l )\n      if (( distance < smallest_distance\
    \ )); then\n        smallest_distance=$distance\n        element=${numbers[$j]}\n\
    \        smallest_number=$current_number\n      fi\n    done\n    element=\"${element%.*}\"\
    \n    largest_number=${smallest_number}\n    if (( i < (${#numbers[*]} - 1)));\
    \ then\n      largest_number=${numbers[$((i + 1))]}\n    fi\n    numbers[$i]=$smallest_number\n\
    \    numbers[$(( i + 1))]=$largest_number\n  done\n  printf '%s\\n' \"${numbers[@]}\"",
  "    local array=( \"${@}\" )\n    local len=${#array[@]}\n    local min1=0\n  \
    \  local min2=0\n    local element1\n    local element2\n    # Sort array and\
    \ pick the first and second closest elements\n    for (( i=1; i<=len; i++ ));\
    \ do\n        element1=\"${array[i]}\"\n        if [[ $min1 -lt $i ]]; then\n\
    \            min1=$i\n            element2=\"$element1\"\n        fi\n       \
    \ if [[ $min2 -lt $i ]]; then\n            min2=$i\n            element2=\"$element1\"\
    \n        fi\n    done\n    echo '\"$(printf \"%s\" \"$element2\")\"'", "    local\
    \ elements=$1\n    local elements_array=( $elements )\n\n    local smallest_index=0\n\
    \    local smallest_number=${elements_array[$smallest_index]}\n    local second_smallest_index=-1\n\
    \    local second_smallest_number=${elements_array[$second_smallest_index]}\n\n\
    \    while [ ${#elements_array[@]} -gt 1 ] ; do\n        local current_index=$((\
    \ ${#elements_array[@]} - 1 ))\n        local current_number=${elements_array[$current_index]}\n\
    \n        local difference=$(( ${current_number} - ${second_smallest_number} ))\n\
    \        if [ \"${difference}\" -le 0 ] ; then\n            second_smallest_number=${current_number}\n\
    \            second_smallest_index=$current_index\n        elif [ \"${difference}\"\
    \ -ge 0 ] ; then\n            smallest_number=${current_number}\n            smallest_index=$current_index\n\
    \        fi\n    done\n\n    if [ ${smallest_index} -eq 0 ] ; then\n        smallest_number=${elements_array[1]}\n\
    \        smallest_index=1\n    fi\n    if [ ${second_smallest_index} -eq 0 ] ;\
    \ then\n        second_smallest_number=${elements_array[1]}\n        second_smallest_index=1\n\
    \    fi\n\n    echo ${elements_array[$smallest_index]} ${elements_array[$second_smallest_index]}",
  "    local input_list\n    local elements_to_return\n    local closest_element\n\
    \    local tmp\n    local input_list_length\n    local input_list_element\n  \
    \  local input_list_element_length\n    local input_list_element_element_length\n\
    \    local input_list_element_element_element_length\n    local output_element\n\
    \    local output_element_length\n    local output_element_element_length\n  \
    \  local output_element_element_element_element_length\n\n    input_list=$1\n\
    \    input_list_length=${#input_list}\n    elements_to_return=()\n\n    for ((\
    \ i = 0; i < input_list_length; i++ )); do\n        closest_element=$(echo ${input_list}\
    \ | tr -d '\\n' | sort -n | head -n 1)\n        input_list_element=$(echo ${input_list}\
    \ | tr -d '\\n' | sort -n | tail -n 1)\n\n        input_list_element_length=${#input_list_element}\n\
    \        input_list_element_element_length=${#input_list_element[@]}\n       \
    \ input_list_element_element_element_length=${#input_list_element[@][@]}\n\n \
    \       output_element=$(echo ${input_list_element} | tr -d '\\n')\n\n       \
    \ if [ $input_list_element_element_element_element_length -eq 0 ]; then\n    \
    \        if [ $input_list_element_element_element_length -gt 0 ]; then\n     \
    \           output_element=$(echo ${input_list_element} | tr -d '\\n' | sort -n\
    \ | tail -n 1)\n                input_list_element=$(echo ${input_list_element}\
    \ | tr -d '\\n' | sort -n | head -n 1)\n                input_list_element_element_length=${#input_list_element}\n\
    \                input_list_element_element_element_length=${#input_list_element[@]}\n\
    \                input_list_element_element_element_element_length=${#input_list_element[@][@]}\n\
    \            fi\n        fi\n\n        output_element_length=${#output_element}\n\
    \        output_element_element_length=${#output_element[@]}\n        output_element_element_element_length=${#output_element[@][@]}\n\
    \n        if [ $output_element_element_element_element_length -gt 0 ]; then\n\
    \            if [ $output_element_element_element_length -gt 0 ]; then\n     \
    \           if [ $output_element_element_length -gt 0 ]; then\n              \
    \      tmp=$(echo ${output_element} | sort -n | tail -n 1)\n                 \
    \   output_element=$(echo ${output_element} | sort -n | head -n 1)\n         \
    \           output_element_length=${#output_element}\n                    output_element_element_element_length=${#output_element[@]}\n\
    \                    output_element_element_element_element_length=${#output_element[@][@]}\n\
    \                fi\n\n                if [[ $closest_element == \"${output_element}\"\
    \ ]]; then\n                    elements_to_return+=(${input_", "    local list\n\
    \    list=(\"${@}\")\n    # sort the list\n    local sorted_list=($(IFS=' ' echo\
    \ \"${list[*]}\"))\n    sorted_list=($(sort -rV \"${sorted_list[@]}\"))\n    #\
    \ remove the first element from the list\n    sorted_list=(${sorted_list[@]:1})\n\
    \    # get the two closest elements\n    local closest=$sorted_list[@]\n    local\
    \ farthest=$sorted_list[@]\n    local smallest_element=${closest[0]}\n    local\
    \ largest_element=${farthest[0]}\n    # now loop through them and keep the smallest\
    \ one and the largest one\n    for element in \"${sorted_list[@]:1}\"; do\n  \
    \      if [[ ${smallest_element} -gt ${element} ]]; then\n            smallest_element=${element}\n\
    \        fi\n        if [[ ${largest_element} -lt ${element} ]]; then\n      \
    \      largest_element=${element}\n        fi\n    done\n    echo \"${smallest_element}\
    \ ${largest_element}\"", "    local elements=\"$1\"\n    local elements=\"$elements\"\
    \ | tr \" \" \";\"\n    local output=\"$(find_closest_element \"$elements\" \"\
    $elements\")\"\n    echo -e \"$output\"", "  local arg\n  local arg_index\n  local\
    \ min_diff\n  local min_arg\n  local sorted_array\n  local sorted_array_index\n\
    \  local sorted_array_value\n  local tmp_array\n  local tmp_array_index\n  local\
    \ tmp_array_value\n  local tmp_arg\n  local tmp_arg_index\n  local tmp_arg_value\n\
    \  local tmp_min_diff\n  \n  tmp_array=( $1 )\n  tmp_arg_value=$( echo \"${tmp_array[@]}\"\
    \ | tr \" \" \"\\n\" )\n  sorted_array_values=( $(sort -n \"${tmp_arg_value}\"\
    \ ) )\n  \n  tmp_min_diff=1000\n  for sorted_array_index in \"${!sorted_array_values[@]}\"\
    ; do\n    sorted_array_value=${sorted_array_values[sorted_array_index]}\n    tmp_arg=$(\
    \ echo \"${sorted_array_value}\" | cut -d ' ' -f 1 )\n    tmp_arg_index=$( echo\
    \ \"${tmp_array[@]}\" | tr \" \" \"\\n\" | grep -n \"${tmp_arg}\" | cut -d ':'\
    \ -f 1 )\n    tmp_arg_value=$( echo \"${tmp_array[@]}\" | tr \" \" \"\\n\" | grep\
    \ -n \"${tmp_arg}\" | cut -d ':' -f 2 )\n    \n    min_diff=0\n    for tmp_array_index\
    \ in \"${!tmp_array_values[@]}\"; do\n      tmp_array_value=${tmp_array_values[tmp_array_index]}\n\
    \      tmp_arg_value=$( echo \"${tmp_array_value}\" | cut -d ' ' -f 1 )\n    \
    \  tmp_arg_index=$( echo \"${tmp_array[@]}\" | tr \" \" \"\\n\" | grep -n \"${tmp_arg_value}\"\
    \ | cut -d ':' -f 1 )\n      tmp_arg_value=$( echo \"${tmp_array[@]}\" | tr \"\
    \ \" \"\\n\" | grep -n \"${tmp_arg_value}\" | cut -d ':' -f 2 )\n      \n    \
    \  diff=$( echo \"${tmp_arg_value} - ${sorted_array_value}\" | bc )\n      if\
    \ (( min_diff == 0 || ( diff < min_diff ) )) ; then\n        min_diff=$( echo\
    \ \"${tmp_arg_value} - ${sorted_array_value}\" | bc )\n        min_arg=\"${tmp_arg}\"\
    \n      fi\n    done\n    \n    if [[ $min_diff -le 0 ]]; then\n      sorted_array+=(\
    \ \"${sorted_array_value}\" )\n    fi\n  done\n  \n  echo ${sorted_array[*]}",
  "    local elements=${1:-\"2.0 3.0 4.0 5.0 2.2\"}\n    local elements_array=($elements)\n\
    \    local smallest=$(echo ${elements_array[0]} | sed 's/ //g')\n    local largest=$(echo\
    \ ${elements_array[${#elements_array[@]}-1]} | sed 's/ //g')\n    for element\
    \ in \"${elements_array[@]}\"; do\n        local element_array=($(echo $element\
    \ | sed 's/ //g'))\n        if [[ ${smallest} -gt ${element_array[0]} ]]; then\n\
    \            smallest=$element\n        elif [[ ${largest} -lt ${element_array[0]}\
    \ ]]; then\n            largest=$element\n        fi\n    done\n    echo \"$smallest\
    \ $largest\"", "    local numbers=$1\n    local closest_elements=()\n    local\
    \ current_closest_element\n    for number in $numbers; do\n        current_closest_element=$(echo\
    \ \"$number\" | cut -d' ' -f1)\n        local closest_element=$(find_closest_element\
    \ \"$number\" \"$current_closest_element\")\n        closest_elements+=(\"$closest_element\"\
    )\n    done\n    echo \"${closest_elements[*]}\"", "    local numbers=\"$1\"\n\
    \    local closest=\"$2\"\n    local count=0\n    local output\n    local outputArray\n\
    \n    # Go through each of the arguments and find the smallest and largest ones\n\
    \    for number in $numbers; do\n        if [[ $((number+count)) < \"$closest\"\
    \ ]]; then\n            closest=\"$((number+count))\"\n            output=\"$number\"\
    \n        elif [[ $((number+count)) > \"$closest\" ]]; then\n            closest=\"\
    $((number+count))\"\n            output=\"$number\"\n        fi\n        count=$((count+1))\n\
    \    done\n\n    # Put the result in the output\n    outputArray=( $output )\n\
    \    echo \"${outputArray[@]}\"", "    local list=$1\n    local small=${list#*\
    \ }\n    local big=${list% *}\n    local small_big=$(echo \"${small} ${big}\"\
    \ | sort -n -k 1,1)\n    local smallest=$(echo \"${small_big}\" | cut -d \" \"\
    \ -f 1)\n    local largest=$(echo \"${small_big}\" | cut -d \" \" -f 2)\n    echo\
    \ $smallest\n    echo $largest", "\tlocal elements=$1\n\tshift\n\tlocal index=0\n\
    \tlocal diff=99999999\n\tlocal element\n\tlocal temp\n\tlocal output\n\n\tfor\
    \ element in ${elements//,/ }\n\tdo\n\t\ttemp=$(echo $element | cut -d\"-\" -f2)\n\
    \t\ttemp=$((temp+$index))\n\n\t\tif [ $temp -le $diff ]\n\t\tthen\n\t\t\tdiff=$temp\n\
    \t\t\toutput=\"$element\"\n\t\tfi\n\tdone\n\n\techo $output", "    local array=\"\
    ${1}\"\n    local index=0\n    local value\n    local min=\"1000000000\"\n   \
    \ local min_index=0\n    local max=\"-1000000000\"\n    local max_index=0\n  \
    \  local element\n    local element2\n    local elements\n    while [[ $((index+1))\
    \ -lt ${#array[@]} ]]; do\n        value=\"$( echo \"${array[$index]}\" | tr -d\
    \ '[[:space:]]' )\" || return\n        element=\"$( echo \"${array[$index]}\"\
    \ | tr '[[:space:]]' '_' )\" || return\n        element2=\"$( echo \"${array[$index+1]}\"\
    \ | tr -d '[[:space:]]' )\" || return\n        elements=$( echo \"${array[@]}\"\
    \ )\n        local smallest_distance=\"$( echo \"${elements##* ${element2}}\"\
    \ | cut -d ' ' -f 2 | sort -n | tail -n 1 )\" || return\n        local smallest_distance_index=\"\
    $( echo \"${elements##* ${element2}}\" | cut -d ' ' -f 2 | sort -n | head -n 1\
    \ )\" || return\n        local largest_distance=\"$( echo \"${elements##* ${element}}\"\
    \ | cut -d ' ' -f 2 | sort -n | head -n 1 )\" || return\n        local largest_distance_index=\"\
    $( echo \"${elements##* ${element}}\" | cut -d ' ' -f 2 | sort -n | tail -n 1\
    \ )\" || return\n        local dist=\"$( echo \"${smallest_distance} - ${largest_distance}\"\
    \ )\" || return\n        local dist2=\"$( echo \"${smallest_distance} - ${value}\"\
    \ )\" || return\n        local dist3=\"$( echo \"${largest_distance} - ${value}\"\
    \ )\" || return\n        local dist4=\"$( echo \"${value} - ${largest_distance}\"\
    \ )\" || return\n        local dist5=\"$( echo \"${value} - ${smallest_distance}\"\
    \ )\" || return\n        local dist6=\"$( echo \"${smallest_distance_index} -\
    \ ${largest_distance_index}\" )\" || return\n        local dist7=\"$( echo \"\
    ${smallest_distance_index} - ${value}\" )\" || return\n        local dist8=\"\
    $( echo \"${largest_distance_index} - ${value}\" )\" || return\n        local\
    \ dist9=\"$( echo \"${value} - ${largest_distance_index}\" )\" || return\n   \
    \     local dist10=\"$( echo \"${value} - ${smallest_distance_index}\" )\" ||\
    \ return\n        if [[ ${smallest_", "  local numbers=$1\n  local smallest_number\n\
    \  local biggest_number\n  local output\n\n  if [ $# -eq 1 ]\n  then\n    smallest_number=$2\n\
    \    biggest_number=$3\n  else\n    smallest_number=$1\n    biggest_number=$2\n\
    \  fi\n\n  local number_string\n  local number\n  local smallest_string\n  local\
    \ biggest_string\n  local diff\n  local i\n  local smallest_index\n  local biggest_index\n\
    \  local difference\n  local number_index\n  local min\n  local max\n\n  for number\
    \ in $numbers\n  do\n    number_string=$(printf '%s' \"$number\" | sed 's/[[:space:]]//g')\n\
    \    number_index=\"${number_string%%.*}\"\n    number=\"${number_string##*$number_index}\"\
    \n\n    smallest_string=$(printf '%s' \"$smallest_number\" | sed 's/[[:space:]]//g')\n\
    \    smallest_index=\"${smallest_string%%.*}\"\n    smallest_number=\"${smallest_string##*$smallest_index}\"\
    \n\n    biggest_string=$(printf '%s' \"$biggest_number\" | sed 's/[[:space:]]//g')\n\
    \    biggest_index=\"${biggest_string%%.*}\"\n    biggest_number=\"${biggest_string##*$biggest_index}\"\
    \n\n    difference=$(( $(echo \"scale=6; $number - $smallest_number\" | bc -l)\
    \ / $(echo \"scale=6; $smallest_number - $biggest_number\" | bc -l) ))\n    if\
    \ [ $difference -le 0 ]\n    then\n      min=$smallest_number\n      max=$biggest_number\n\
    \    elif [ $difference -gt 0 ]\n    then\n      min=$biggest_number\n      max=$smallest_number\n\
    \    else\n      min=$(echo \"scale=6; $smallest_number\" | bc -l)\n      max=$(echo\
    \ \"scale=6; $biggest_number\" | bc -l)\n    fi\n    \n    if [ \"$number\" ==\
    \ \"$min\" ]\n    then\n      smallest_index=$(echo \"scale=6; $smallest_number\"\
    \ | bc -l)\n      smallest_number=$(echo \"scale=6; $smallest_number - $biggest_number\"\
    \ | bc -l)\n      smallest_number=\"${smallest_number%%.*}\"\n      smallest_number=\"\
    ${smallest_number##*$smallest_index}\"\n      smallest_number=\"\\\"$smallest_number",
  "  echo \"$(echo \"$1\" | sed 's/[ \\t]/ /g')\" | grep -Eo \"[0-9]+\\.?[0-9]*\"\
    \ | sort -n | head -2 | tail -1 | sed \"s/\\\"//g\"", "    # Take the list of\
    \ elements and split it into a list of numbers and a list of strings.\n    IFS=$'\\\
    n' read -r -a elements <<< \"$1\"\n\n    # Sort the list of numbers, taking the\
    \ smallest number first\n    sorted=($(\n        IFS=' '\n        for element\
    \ in \"${elements[@]}\"; do\n            echo \"$element\"\n        done\n   \
    \     sort -n | head -1\n    ))\n\n    # Take one element from the sorted list\
    \ and see if that element exists elsewhere in the list\n    for element in \"\
    ${sorted[@]}\"; do\n        if ! grep -w \"$element\" <<< \"$1\"; then\n     \
    \       # Didn't find the element, print it and remove it from the sorted list\n\
    \            echo \"$element\"\n            echo \"$element\"\n            echo\
    \ \"$1\"\n            sorted=(\"${sorted[@]:1:${#sorted[@]}}\")\n            break\n\
    \        fi\n    done\n\n    # Return the list of elements that we want, in order\n\
    \    echo \"${sorted[@]}\"", "  local elements=\"${1//[\\ \\t]}\";\n  # Sort elements\
    \ and pick two numbers from each group.\n  sorted_elements=\"${elements//[\\ \\\
    t][ \\t][ \\t]}\"\n  local sorted=$(echo \"$sorted_elements\" | tr ' ' '\\n' |\
    \ sort -n | sed 's/^[ \\t]*//g')\n  local small=\"${sorted[0]}\"\n  local big=\"\
    ${sorted[-1]}\"\n  local small_index=$(( ${#sorted_elements} - 1))\n  local big_index=$(echo\
    \ \"$sorted_elements\" | grep -n $big | cut -d':' -f1)\n  while [ \"$small_index\"\
    \ -ge \"$big_index\" ]; do\n    small_index=$(( ${small_index} - 1 ))\n    big_index=$((\
    \ ${big_index} - 1 ))\n  done\n  echo '\"' \"$small\" '\" (\"' \"$big\" '\")'",
  "    local elements=$1\n\n    # Convert from string to floating point numbers\n\
    \    IFS=' ' read -a elements <<< \"${elements}\"\n\n    # Sort and find closest\n\
    \    local smallest=$(( ${elements[0]} ))\n    local largest=$(( ${elements[${#elements[@]}-1]}\
    \ ))\n    for i in $(seq 1 ${#elements[@]})\n    do\n        local this=$(( ${elements[i]}\
    \ ))\n        if (( ${this} < ${smallest} )); then\n            smallest=${this}\n\
    \        elif (( ${this} > ${largest} )); then\n            largest=${this}\n\
    \        fi\n    done\n    echo -n \"\\\"${smallest}\\\"\"\n    for i in $(seq\
    \ 1 ${#elements[@]}); do\n        local this=$(( ${elements[i]} ))\n        if\
    \ (( ${this} < ${smallest} )); then\n            smallest=${this}\n        fi\n\
    \    done\n    echo \"\\\"${largest}\\\"\"", "  local numbers=$*\n  local sorted_numbers=$(echo\
    \ \"$numbers\" | sed -e 's/ /\",\"/g' | sort -n)\n  local smallest_number=$(echo\
    \ \"$numbers\" | sed -e 's/ /\",\"/g' | sort -n | sed -n -e 's/^\"\\(.*\\)\"/\\\
    1/p' | head -1)\n  local biggest_number=$(echo \"$numbers\" | sed -e 's/ /\",\"\
    /g' | sort -n | sed -n -e 's/^\"\\(.*\\)\"/\\1/p' | tail -1)\n  echo \"$smallest_number\"\
    , \"$biggest_number\"", "  declare -a numbers\n  declare -a closest\n  numbers=(\
    \ \"$@\" )\n  closest=( \"$numbers[0]\" )\n  local i diff tmp\n  declare -a tmp\n\
    \  for ((i=0;i<${#numbers[@]};++i)); do\n    diff=-1\n    for ((j=0;j<${#closest[@]};++j));\
    \ do\n      diff=`expr $diff \\* $( echo \"$closest[$j] - ${numbers[$i]}\" | bc\
    \ )`\n    done\n    diff=`expr $diff \\* $i`\n    if [ $diff -lt 0 ]; then\n \
    \     tmp=( \"${closest[@]:$j+1:}\" )\n      closest=( \"${numbers[@]:0:$j+1}\"\
    \ \"${tmp[@]}\" )\n    elif [ $diff -gt 0 ]; then\n      tmp=( \"${closest[@]:$j+1:}\"\
    \ )\n      closest=( \"${tmp[@]:0:$j+1}\" \"${numbers[@]:$i-1:$j+1}\" )\n    fi\n\
    \  done\n  echo \"${closest[@]}\"", "  local array=($@)\n  local small=$1\n  local\
    \ big=${array[-1]}\n  local small_index=0\n  local big_index=0\n  local closest=\n\
    \  while [ \"$small_index\" -lt \"$#\" ] && [ \"$big_index\" -lt \"$#\" ];do\n\
    \    local element=${array[$small_index]}\n    local element2=${array[$big_index]}\n\
    \    (( (( $element > $element2 )) )) || return $small_index $big_index\n    ((\
    \ (( $element < $element2 )) )) || return $small_index $big_index\n    local closest=$element\n\
    \    (( small_index++ )) || break\n    local closest2=$element2\n    (( big_index++\
    \ )) || break\n  done\n  echo $closest\n  echo $closest2", "  local list_of_interest\n\
    \  list_of_interest=$1\n  echo $list_of_interest | sed -e \"s/ /' '/g\" | sort\
    \ --field-separator=\\' \\' \\\n    | awk 'BEGIN{ min_dist_found=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
  "    local arg=\"$1\"\n    if [[ \"$arg\" =~ ^-?[0-9]+\\.?[0-9]+$ && ${#arg} -gt\
    \ 2 ]]; then\n        local min1=\"${arg%.*}\"\n        local min2=\"${arg#*.}\"\
    \n        local elems=( \"$@\" )\n        local min=$( printf \"%0.2f\" \"$min1\"\
    \ \"$min2\" )\n        local min_index=0\n        local min_idx=${#elems[@]}\n\
    \        for ((i=$((${#elems[@]} - 1)); i>=0; i--)); do\n            local diff=$(echo\
    \ \"$min\" - \"${elems[i]%.*}\" | bc)\n            local diff_diff=$(echo \"$diff\"\
    \ - \"${min}\" | bc)\n            if [[ -z ${elems[i]} ]]; then\n            \
    \    elems=( \"${elems[@]:0:i}\" )\n                i=$((i - 1))\n           \
    \ fi\n            if [[ $diff_diff -eq 0 ]]; then\n                min_index=$i\n\
    \                break\n            fi\n        done\n        if [[ -z \"$min_index\"\
    \ ]]; then\n            return \"\"\n        fi\n        local max=\"${elems[min_index]%.*}\"\
    \n        local max_idx=${#elems[@]}\n        for ((i=0; i<$min_idx; i++)); do\n\
    \            local diff=$(echo \"${min} - ${elems[i]}\" | bc)\n            local\
    \ diff_diff=$(echo \"$diff\" - \"$min\" | bc)\n            if [[ $diff_diff -eq\
    \ 0 ]]; then\n                min_idx=$i\n                break\n            fi\n\
    \        done\n        local result=()\n        for ((i=$((min_index - 1)); i>=0;\
    \ i--)); do\n            result+=( \"${elems[i]}\" )\n        done\n        if\
    \ [[ $((min_idx - 1)) -ne $min_index ]]; then\n            ((min_idx++))\n   \
    \         result+=( \"${elems[min_idx]}\" )\n        fi\n        if [[ $((max_idx\
    \ - 1)) -ne $min_index ]]; then\n            result+=( \"${elems[min_idx]}\" )\n\
    \        fi\n        echo -n \"${result[*]}\"\n    else\n        echo \"invalid\
    \ input\"\n    fi", "    local list=$1\n    local -a smallest_elements\n    local\
    \ -a larger_elements\n    local -a element_names\n    local -a element\n    local\
    \ smallest_diff\n    local larger_diff\n    local found\n\n    smallest_elements=()\n\
    \    larger_elements=()\n    element_names=()\n\n    # Split $list into separate\
    \ numbers (if any) \n    while read element; do\n        element_names+=( $(echo\
    \ $element | sed 's/ //g') )\n    done < <(echo $list | tr ' ' '\\n' | sed 's/\
    \ //g' | sort -n)\n\n    # If we have less than two elements, return an empty\
    \ array\n    if [ ${#element_names[@]} -le 1 ]; then return 0; fi\n\n    # Sort\
    \ each element by converting to a floating point number\n    local -a elements\n\
    \    elements=( $(echo $element_names | tr ' ' '\\n' | sed 's/ //g' | xargs -n2\
    \ echo) | sort -n | sed 's/^\\s*//g')\n\n    # Iterate through each pair of elements\
    \ and check which of them is closest to each other \n    for (( i=0; i<${#elements[@]}-1;\
    \ i++ )); do\n        smallest_diff=$(echo $elements[$i] | sed 's/ //g' | xargs\
    \ -n2 echo)\n        larger_diff=$(echo $elements[$((i+1))] | sed 's/ //g' | xargs\
    \ -n2 echo)\n\n        if [ \"$smallest_diff\" -gt \"$larger_diff\" ]; then\n\
    \            smallest_diff=$larger_diff\n            larger_diff=$smallest_diff\n\
    \        fi\n\n        if [ \"$smallest_diff\" -lt \"$larger_diff\" ]; then\n\
    \            smallest_diff=$larger_diff\n            larger_diff=$smallest_diff\n\
    \        fi\n\n        smallest_elements[$i]=$smallest_diff\n        larger_elements[$i]=$larger_diff\n\
    \    done\n\n    # Check if $list's order is reversed. If it is, reverse both\
    \ arrays.\n    if [ \"$smallest_elements\" != \"${smallest_elements[@]}\" ] &&\
    \ [ \"$larger_elements\" != \"${larger_elements[@]}\" ]; then \n        smallest_elements=(${smallest_elements[@]}\
    \ ${smallest_elements[@]})\n        larger_elements=(${larger_elements[@]} ${larger_elements[@]})\n\
    \    fi\n\n    # Return elements that satisfy the criteria\n    found=\n    for ",
  "  local list=\"$1\"\n  shift\n  local sorted=( $(echo \"$list\" | tr \" \" \" \"\
    \ |\n                   sed -E \"s/^([0-9]+\\.[0-9]+).*/\\1/\"\n             \
    \      | sort -n ) ) \n  local close=( ${sorted[*]/%/ } ) # remove duplicates\
    \ (if any) and leave the first element\n  local closest=( ${close[*]/%/ } )\n\
    \  local returned_result=()\n  local i=0 j=0\n  while [ $i -lt $#${close[*]} ];\
    \ do\n    (( distance=\"$( echo \"${close[*][$i]} - ${close[*][$j]}\" | bc )\"\
    \ ))\n    if (( distance < 0 )) ; then\n      returned_result+=( \"${closest[$i]}\"\
    \ )\n      (( i++ ))\n      (( j++ ))\n    elif (( distance > 0 )); then\n   \
    \   returned_result+=( \"${closest[$j]}\" )\n      (( j++ ))\n    else\n     \
    \ (( i++ ))\n      (( j++ ))\n    fi\n  done\n  returned_result+=( \"${closest[$i]}\"\
    \ )\n  returned_result+=( \"${closest[$j]}\" )\n  echo \"${returned_result[*]}\"",
  "    local i1=0\n    local i2=${#1}\n    local i3\n    local i4\n    local i5\n\
    \    local i6\n    local i7\n    local k8\n    local k8\n\n    local j1\n    local\
    \ j2\n    local j3\n    local j4\n    local j5\n    local j6\n    local j7\n\n\
    \    local k9\n    local k10\n    local k11\n    local k12\n    local k13\n  \
    \  local k14\n    local k15\n    local k16\n\n    local l1\n    local l2\n   \
    \ local l3\n    local l4\n    local l5\n    local l6\n    local l7\n\n    local\
    \ m1 m1\n\n    local n1 n2\n\n    local o1 o2 o3\n    local o4 o5 o6\n\n    local\
    \ p1\n    local p2\n    local p3\n    local p4\n    local p5\n    local p6\n\n\
    \    local q1 q2 q3\n    local q4 q5 q6\n\n    local r1\n    local r2\n    local\
    \ r3\n    local r4\n    local r5\n    local r6\n\n    local s1 s2\n\n    local\
    \ t1\n    local t2\n    local t3\n    local t4\n    local t5\n    local t6\n\n\
    \    local u1 u2 u3\n    local u4 u5 u6\n\n    local v1\n    local v2\n    local\
    \ v3\n    local v4\n    local v5\n    local v6\n\n    local w1 w2 w3 w4 w5 w6\n\
    \    local w7 w8 w9 w10 w11 w12 w13 w14 w15 w16\n    local w17 w18 w19 w20 w21\
    \ w22 w23 w24 w25 w26\n    local w27 w28 w29 w30 w31 w32 w33 w34 w35 w36\n   \
    \ local w37 w38 w39 w40 w41 w42 w43 w44 w45 w46\n    local w47 w48 w49 w50 w51\
    \ w52 w53 w54 w55 w56\n    local w57 w58 w59 w60 w61 w62 w63 w64 w65 w66\n    ",
  "    local elements\n    local i imax\n    elements=($1)\n    imax=${#elements[@]}\n\
    \    local closest\n    local diff\n    local diffmax\n    local diffmin\n   \
    \ local closest1\n    local closest2\n    for ((i=0;i<imax;i++));\n    do\n  \
    \      closest=$(echo \"${elements[i]}\" | bc | awk '{print $1 - $2}')\n     \
    \   if [[ ${elements[i]} == ${closest} ]]; then\n            closest1=\"\\\"${elements[i]}\\\
    \"\"\n        else\n            if [[ ${elements[i+1]} == ${closest} ]]; then\n\
    \                closest2=\"\\\"${elements[i+1]}\\\"\"\n            else\n   \
    \             diff=$(echo \"${closest} - ${elements[i]}\" | bc | awk '{print $1}')\n\
    \                if [[ ${diff} -le -3 ]]; then\n                    closest1=\"\
    \\\"${elements[i]}\\\"\"\n                    closest2=\"\\\"${elements[i+1]}\\\
    \"\"\n                elif [[ ${diff} -ge -3 ]]; then\n                    diffmax=$((diff\
    \ + 3))\n                    diffmin=$((diff - 3))\n                    if [[\
    \ ${elements[i]} -gt ${closest} ]]; then\n                        closest1=\"\\\
    \"${closest}\\\"\"\n                        closest2=\"\\\"${elements[i]}\\\"\"\
    \n                    else\n                        closest1=\"\\\"${elements[i+1]}\\\
    \"\"\n                        closest2=\"\\\"${closest}\\\"\"\n              \
    \      fi\n                elif [[ ${diff} -lt -3 ]]; then\n                 \
    \   closest1=\"\\\"${elements[i]}\\\"\"\n                    closest2=\"\\\"${elements[i-1]}\\\
    \"\"\n                fi\n            fi\n        fi\n    done\n    echo \"${closest1}\"\
    \ \"${closest2}\"", "  local -n arr=$1\n  local num\n  local -a result\n\n  IFS=$'\\\
    n' read -d '' -a array <<< \"$1\"\n\n  for ((i=0; i<${#array[@]}; i++)) ; do\n\
    \    num=${array[i]}\n    result=()\n    for ((j=0; j<${#array[@]}; j++)) ; do\n\
    \      [[ \"${array[j]}\" -gt \"$num\" ]] && result+=(\"${array[j]}\") || result+=(\"\
    ${array[j]}\" && break)\n    done\n    (( ${#result[@]} )) && printf '%s\\n' \"\
    ${result[@]}\" || printf '%s\\n' \"${array[@]}\"\n  done", "\tlocal a=$1\n\tlocal\
    \ b=$2\n\tlocal diff\n\tlocal c\n\tlocal i\n\tlocal j\n\tlocal closest\n\tlocal\
    \ closestval\n\tlocal closet\n\tlocal closestj\n\tfor ((i = 0; i <= ${#a}; i++));\
    \ do\n\t\tc=$a[i]\n\t\tfor ((j = 0; j <= ${#b}; j++)); do\n\t\t\tb=$b[j]\n\t\t\
    \tdiff=$((${b} - ${c}))\n\t\t\tif (${diff} -lt 0); then\n\t\t\t\tdiff=$((-${diff}))\n\
    \t\t\telif (${diff} -gt 0); then\n\t\t\t\tdiff=$((${diff}))\n\t\t\tfi\n\t\t\t\
    if ((${diff} > ${closestval})); then\n\t\t\t\tclosest=${a[i]}\n\t\t\t\tclosestj=${j}\n\
    \t\t\t\tclosestval=${diff}\n\t\t\tfi\n\t\tdone\n\tdone\n\techo $closest\n\techo\
    \ $closestj\n\techo $closestval", "    # Extract numbers\n    local numbers=\"\
    $1\"\n    # Extract elements\n    local elements=\"$2\"\n    # Loop to extract\
    \ closest pair of numbers\n    for element in $elements; do\n        local lowest_distance=\"\
    $(($element + 1))\"\n        local lowest_number=\"$(($numbers))\"\n        local\
    \ second_lowest_distance=\"$(($element - 1))\"\n        local second_lowest_number=\"\
    $(($numbers))\"\n        # Loop through remaining elements to find distance to\
    \ current element\n        for (( index = 1; index <= $numbers; index++ )); do\n\
    \            # Take first number in the pair\n            local second_number=\"\
    $(($element))\"\n            # Calculate distance\n            local distance=\"\
    $(($(( ($second_number - $second_lowest_number) * 2 )) +\n                $((\
    \ ($second_number - $lowest_number) * 2 )) +\n                $(( ($lowest_number\
    \ - $lowest_number) * 2 )) +\n                $(( ($lowest_number - $second_lowest_number)\
    \ * 2 ))))\"\n            # Store result if the distance is less than current\
    \ lowest_distance\n            if [[ ${distance} < \"$lowest_distance\" ]]; then\n\
    \                lowest_distance=\"$distance\"\n                lowest_number=\"\
    $second_number\"\n            fi\n            # Store result if the distance is\
    \ less than current second_lowest_distance\n            if [[ ${distance} < \"\
    $second_lowest_distance\" ]]; then\n                second_lowest_distance=\"\
    $distance\"\n                second_lowest_number=\"$second_number\"\n       \
    \     fi\n        done\n        # Store result if both distances are less than\
    \ the previous lowest_distance\n        if [[ $(( $lowest_distance < $second_lowest_distance\
    \ )) ]]; then\n            echo \"\\\"$lowest_number\\\" \\\"$lowest_distance\\\
    \"; \\\"$second_lowest_number\\\" \\\"$second_lowest_distance\\\"\"\n        else\n\
    \            echo \"\\\"$lowest_number\\\" \\\"$lowest_distance\\\"\"\n      \
    \  fi\n    done", "  local l\n  local n\n\n  while read l || [[ -n \"$l\" ]];\
    \ do\n    echo $l\n    echo $(grep -n -- \"$l\" \"$1\"|awk -F ':' '{print $1}'|sort\
    \ -n | head -2)\n  done", "    local input=\"$1\"\n    local IFS=' '\n\n    local\
    \ elements=($input)\n    local min=${elements[0]}\n    local max=${elements[0]}\n\
    \n    local smallest_index=-1\n    local largest_index=-1\n\n    for ((i=1; i<\"\
    ${#elements[@]}\"; i=i+2)); do\n        local element=${elements[$i]}\n      \
    \  local next=${elements[$((i + 1))]}\n\n        if [ \"$element\" -gt \"$max\"\
    \ ]; then\n            largest=\"${element}\"\n            largest_index=$i\n\
    \        elif [ \"$element\" -lt \"$min\" ]; then\n            smallest=\"${element}\"\
    \n            smallest_index=$i\n        fi\n    done\n\n    local smallest_element=\"\
    ${elements[$smallest_index]}\"\n    local largest_element=\"${elements[$largest_index]}\"\
    \n\n    echo \"$smallest_element $largest_element\"", "    local x\n    local\
    \ smallest\n    local smallest_element\n    local other\n    local other_element\n\
    \    local other_smallest\n\n    x=\"$1\"\n    smallest=$( echo $x | awk '{print\
    \ $1}' | sort -nr | head -n 1)\n    smallest_element=$( echo $x | awk '{print\
    \ $1}' | sort -nr | head -n 1)\n    other=$( echo $x | awk '{print $2}' | sort\
    \ -nr | head -n 1)\n    other_element=$( echo $x | awk '{print $2}' | sort -nr\
    \ | head -n 1)\n\n    while [ \"$other\" != \"\" ]; do\n        if [ $other -le\
    \ $smallest ]; then\n            smallest=$other\n            smallest_element=$other_element\n\
    \        else\n            other=$( echo $x | awk '{print $2}' | sort -nr | head\
    \ -n 1)\n            other_element=$( echo $x | awk '{print $2}' | sort -nr |\
    \ head -n 1)\n        fi\n    done\n    echo \"$smallest_element $smallest\"",
  "    local elements=\"$1\"\n\n    local closest_elements\n    # Find the closest\
    \ elements from the given list, this assumes no repeats in list\n    closest_elements=$(\n\
    \        awk '{\n            smallest=$1;\n            smallest_index=$1;\n  \
    \          second_smallest=$1;\n            for (element; element=\\$2; ) {\n\
    \                if (\\$2 < smallest) {\n                    smallest=\\$2;\n\
    \                    second_smallest=element;\n                } else if (\\$2\
    \ == smallest) {\n                    if (\\$2 < second_smallest) {\n        \
    \                second_smallest=element;\n                    }\n           \
    \     } else {\n                    smallest_index=element;\n                }\n\
    \                element=\\$2;\n            }\n            smallest_index=$(echo\
    \ $smallest_index| sed -e 's/ //g' -e 's/\"//g');\n        }'\n        \"$elements\"\
    \n    )\n    # Now get the second element and make it into a list\n    closest_elements=$(echo\
    \ \"$closest_elements\" | sed -e 's/\"//g')\n    echo \"$closest_elements\"",
  "    IFS=$' \\t\\n'\n    local sorted=\"${1}\"\n    local array=()\n    for element\
    \ in $sorted; do\n        array+=(\"$element\")\n    done\n\n    local close=${array[0]}\n\
    \    local far=${array[0]}\n    local closest\n    for element in ${array[@]:1};\
    \ do\n        if [ \"$element\" == \"$close\" ]; then\n            closest=$close\n\
    \        elif [ \"$element\" == \"$far\" ]; then\n            closest=$far\n \
    \       else\n            local diff=$(echo \"$element - $close\" | bc)\n    \
    \        if [ $diff -le 0 ]; then\n                closest=$close\n          \
    \  else\n                closest=$far\n            fi\n        fi\n        close=$element\n\
    \        far=$closest\n    done\n\n    echo \"$closest\"", "    local elements=(\
    \ $1 )\n    local smallest=( $2 )\n    local largest=( $2 )\n    for (( i = 3;\
    \ i <= ${#elements[@]}; i++ )); do\n        local element=${elements[${#elements[@]}-1-i]}\n\
    \        if (( ${smallest[${#smallest[@]}]} > ${element} )) ; then\n         \
    \   smallest[${#smallest[@]}-1]=${element}\n        fi\n        if (( ${largest[${#largest[@]}]}\
    \ < ${element} )) ; then\n            largest[${#largest[@]}-1]=${element}\n \
    \       fi\n    done\n    local string=''\n    for (( i = 0; i < ${#smallest[@]};\
    \ i++ )); do\n        local element=${smallest[i]}\n        local element=${elements[${#elements[@]}-1-i]}\n\
    \        local element=\\$\\{\\{element\\}\\}\n        local element=\\$element\n\
    \        if (( i )) ; then\n            string+=\" \"\n        fi\n        string+=\"\
    ${element}\"\n    done\n    echo ${string[@]}", "    local elements=\"${1}\"\n\
    \    local index1=0\n    local index2=1\n    local elements_array=(${elements//[\"\
    \ \"]})\n    while [ $index1 -lt ${#elements_array[@]} ]; do\n        local element1=${elements_array[$index1]}\n\
    \        local element2=${elements_array[$index2]}\n        if [ \"${element1}\"\
    \ == \"${element2}\" ]; then \n            index1=${index1+1}\n            index2=${index2+1}\n\
    \            continue\n        fi\n        local diff=${element1##* }\n      \
    \  if (( \"${diff}\" == \"${element2}\" )) ; then\n            element2=${element1}\n\
    \        fi\n        if (( \"${diff}\" < \"${element2}\" )) ; then\n         \
    \   element2=\"${element1}\"\n        fi\n        local diff1=\"${element2##*\
    \ }\"\n        if (( \"${diff1}\" == \"${element1}\" )) ; then\n            element2=\"\
    ${element1}\"\n        fi\n        if (( \"${diff1}\" < \"${element1}\" )) ; then\n\
    \            element1=\"${element2}\"\n        fi\n        elements_array[$index1]=${element2}\n\
    \        elements_array[$index2]=${element1}\n        index1=$((index1+1))\n \
    \       index2=$((index2+1))\n    done\n    echo \"${elements_array[@]}\"", " \
    \ local numbers=$(echo \"$1\" | tr \" \" \" \")\n  local smallest=$(echo \"$numbers\"\
    \ | sort -n | head -1)\n  local largest=$(echo \"$numbers\" | sort -n | tail -1)\n\
    \  echo \"$smallest $largest\"", "    local array n mx mn d\n    array=$1\n  \
    \  local i j k\n    read a b c d <<< \"$2\"\n\n    n=\"${#array[@]}\"\n    if\
    \ [ $n -eq 0 ]; then\n        echo \"$array is empty\"\n        return 1\n   \
    \ elif [ -z \"$a\" ]; then\n        echo \"missing first argument ($a)\"\n   \
    \     return 1\n    elif [ -z \"$b\" ]; then\n        echo \"missing second argument\
    \ ($b)\"\n        return 1\n    elif [ -z \"$c\" ]; then\n        echo \"missing\
    \ third argument ($c)\"\n        return 1\n    elif [ -z \"$d\" ]; then\n    \
    \    echo \"missing fourth argument ($d)\"\n        return 1\n    fi\n\n    for\
    \ (( j=0; j<n; j=j+2 )); do\n        a=\"$array[$j]\"\n        b=\"$array[$j+1]\"\
    \n\n        # sort numbers by magnitude\n        if [ \"$(echo \"$b > $a\" | bc)\"\
    \ -ne 0 ]; then\n            mx=\"$b\"\n            mn=\"$a\"\n        else\n\
    \            mx=\"$a\"\n            mn=\"$b\"\n        fi\n\n        # determine\
    \ which number is closest\n        if [ \"$(echo \"$mn - $mx > $n - $j\" | bc)\"\
    \ -eq 0 ]; then\n            echo \"$mn - $mx < $n - $j\"\n        elif [ \"$(echo\
    \ \"$mn - $mx < $n - $j\" | bc)\" -eq 1 ]; then\n            echo \"$mn - $mx\"\
    \n        elif [ \"$(echo \"$mn - $mx > $n - $j\" | bc)\" -eq 2 ]; then\n    \
    \        echo \"$mn - $mn\"\n        else\n            echo \"$mn - $mx is out\
    \ of bounds\"\n        fi\n\n        # swap numbers in the array\n        if [\
    \ \"$(echo \"$i -eq 0 $j < $n\" | bc)\" -eq 0 ]; then\n            i=$(( i + 1\
    \ ))\n            array[$i]=$mn\n            array[$j+1]=$mx\n        elif [ \"\
    $(echo \"$i -eq 0 $j < $n\" | bc)\" -eq 1 ]; then\n            i=$(( j - 1 ))\n\
    \            array[$i]=$mn\n            array[$j+1]=$mx\n        elif [ \"$(echo\
    \ \"$i -eq 0 $j < $n\" | bc)\" -eq 2 ]; then\n            i=$(( n - 1 ))\n   \
    \         array[$i]=$mn\n            array[$j+1]=$mx\n        elif [ \"$(echo\
    \ \"$i -eq", "    local x\n    local ret=()\n    for x in $@; do\n        local\
    \ d=$( echo \"$x\"|sed \"s/.$/x\")\n        if [ -z \"$d\" ]; then d=$(echo \"\
    $x\"|awk '{print $1}'); fi\n        if [ \"$d\" -lt \"$ret\" ]; then\n       \
    \     ret=\"$d\"\n        else\n            ret=\"$x\"\n        fi\n    done\n\
    \    echo \"$ret\"", "    local numbers=$(echo \"$1\" | tr '[:space:]' ' ')\n\
    \    local min\n    local max\n    local out\n    local numbers\n    local min\n\
    \    local max\n    local out\n    min=$(awk -F\\. 'BEGIN { min=100000000000000\
    \ } ; { if ($1 < min) { min=$1; max=$1; } } END { print min \" \" max }' <<< \"\
    $numbers\")\n    max=$(awk -F\\. 'BEGIN { min=100000000000000 } ; { if ($1 > max)\
    \ { max=$1; min=$1; } } END { print min \" \" max }' <<< \"$numbers\")\n    out=\"\
    $(echo \"$numbers\" | tr '[:space:]' '\\n' | awk -F\\. 'BEGIN { min=100000000000000\
    \ } ; { if ($1 < min) { min=$1; max=$1; } } END { print min \" \" max }' | sed\
    \ 's/ /, /g')\"\n    echo \"$out\"", "  local elements=\"$1\"\n  shift\n  local\
    \ smallest=\"$1\"\n  shift\n  local biggest=\"$1\"\n  shift\n  echo \"$smallest,\
    \ $biggest\" | sort -rn | head -n 2", "  local i\n  local sorted\n  local last\n\
    \  local output\n\n  # sort the list so that it is in ascending order\n  sorted=$1\n\
    \  for i in $sorted; do\n    sorted=\"${sorted} ${i}\"\n  done\n\n  # split the\
    \ list into two\n  last=${sorted:(-1)}\n  output=$(set -- ${sorted} | sed \"s/\
    \ ${last} //\")\n  output=$(set -- ${sorted} | sed \"s/ ${last} //\" | head -1)\n\
    \n  # return both the closest two and the remaining in order\n  echo \"$output\"\
    \n  echo \"$last\"", "\tlocal lst_of_numbers=$1\n\tlocal closest=\n\tlocal smallest=\n\
    \tlocal largest=\n\tlocal numbers=($lst_of_numbers)\n\n\twhile [ ${#numbers} -gt\
    \ 1 ] ; do\n\t\tsmallest=${numbers[0]}\n\t\tlargest=${numbers[-1]}\n\t\tlocal\
    \ smallest_elements=()\n\t\tlocal largest_elements=()\n\t\tlocal min_distance=\n\
    \t\tlocal max_distance=\n\t\tlocal i\n\t\tfor i in \"${!numbers[@]}\"; do\n\t\t\
    \tlocal current=${numbers[i]}\n\t\t\tlocal smallest_element=\n\t\t\tlocal largest_element=\n\
    \t\t\tlocal distance=\n\t\t\tsmallest_element+=($smallest)\n\t\t\tlargest_element+=($largest)\n\
    \t\t\tdistance+=$(( $(echo \"$current - $smallest\" | bc -l) ))\n\t\t\tsmallest_element+=($current)\n\
    \t\t\tlargest_element+=($current)\n\t\t\tdistance+=$(( $(echo \"$current - $largest\"\
    \ | bc -l) ))\n\t\t\tmin_distance=$(( $distance < $min_distance ? $distance :\
    \ $min_distance ))\n\t\t\tmax_distance=$(( $distance > $max_distance ? $distance\
    \ : $max_distance ))\n\t\tdone\n\n\t\tif [ ${#smallest_elements[@]} -gt 1 ]; then\n\
    \t\t\tsmallest=${smallest_elements[${#smallest_elements[@]}-1]}\n\t\tfi\n\n\t\t\
    if [ ${#largest_elements[@]} -gt 1 ]; then\n\t\t\tlargest=${largest_elements[${#largest_elements[@]}-1]}\n\
    \t\tfi\n\n\t\tnumbers=(${smallest_elements[@]} ${numbers[@]} ${largest_elements[@]})\n\
    \tdone\n\n\tprintf '%s\\n' \"$closest\"", "    local array number\n    read -a\
    \ array <<<\"$1\"\n    local first=${array[0]}\n    local last=${array[-1]}\n\
    \    local i result\n    for ((i=0;i<${#array[@]};i++)); do\n        local number=${array[i]}\n\
    \        local diff=${number}-${first}\n        if [ $diff -lt 0 ]; then diff=-$diff;\
    \ fi\n        if [ $diff -gt 0 ]; then diff=$((diff-last)); fi\n        result=$((diff/last))\n\
    \        result=$((result+i))\n        echo -n \"${array[result]} \"\n    done",
  "    local l=$1 \n    local tmp tmp2 tmp3 i j k \n    tmp=\"${l}\"\n    while [[\
    \ $tmp =~ ([0-9]*\\.?[0-9]+) ]]; do \n        tmp2=\"${BASH_REMATCH[1]}\"\n  \
    \      tmp3=\"${tmp2}\"\n        for (( i = 0; i < ${#tmp}; i++ )); do\n     \
    \       (( j = (i + 1) % ${#tmp} )); \n            k=\"${tmp:$i:1}\"\n       \
    \     if [[ $tmp == $k ]] ; then\n                break 2\n            fi\n  \
    \          if [[ $tmp == $tmp2 ]] ; then\n                if [[ $tmp2 < $tmp3\
    \ ]] ; then\n                    tmp3=$tmp2\n                else\n          \
    \          tmp3=$k\n                fi\n            fi\n        done\n       \
    \ echo \"\\\"$tmp3\\\"\"\n    done", "    set -- $1 \n    local num1=$1\n    local\
    \ num2=$2\n    local num1x=$(( ${#num1} - 1 ))\n    local num2x=$(( ${#num2} -\
    \ 1 ))\n    local difference=`expr $num1 \\- $num2`\n    if [[ ${difference} -lt\
    \ 0 ]]; then\n        echo \"${num2} is closer to ${num1} than ${num1}\"\n   \
    \ elif [[ ${difference} -gt 0 ]]; then\n        echo \"${num2} is closer to ${num1}\
    \ than ${num2}\"\n    else\n        local min1=${num1:0:$num1x}\n        local\
    \ min2=${num2:0:$num2x}\n        local max1=${num1:$num1x:$(( ${#num1} - num1x\
    \ ))}\n        local max2=${num2:$num2x:$(( ${#num2} - num2x ))}\n        local\
    \ min=${min1}\n        local max=${max1}\n        local mindiff=`expr $num1 \\\
    - $min1`\n        local maxdiff=`expr $num1 \\- $max1`\n        local maxdiffx=$((\
    \ ${#maxdiff} - 1 ))\n        local mindiffx=$(( ${#mindiff} - 1 ))\n        local\
    \ i=$(( num1x - num2x ))\n        local j=$(( num2x - num1x ))\n        (( i <\
    \ j )) && { local k=$i; i=$j; j=$k; }\n        while [[ $i -ge 0 ]] && [[ $j -ge\
    \ 0 ]] && [[ ${difference:$i:$j} -gt 0 ]]; do\n            (( i -= 1 )); j -=\
    \ 1\n            (( j -= 1 ))\n        done\n        if [[ $i -ge 0 ]] && [[ $j\
    \ -ge 0 ]]; then\n            local k1=${min1:$i:$j}\n            local k2=${min2:$i:$j}\n\
    \            local k3=${max1:$i:$j}\n            local k4=${max2:$i:$j}\n    \
    \        (( i < j )) && { local k5=$i; i=$j; j=$k; }\n            (( k2 < k4 ))\
    \ && { local k6=$k2; k2=$k4; k4=$k5; k5=$k6", "    local array=\"$1\"\n    local\
    \ nums=\"\"\n    for element in $array; do\n        nums+=\" -e ${element}\"\n\
    \    done\n    local smallest=$(echo \"${array[@]}\" | sort -n -k1 -r)\n    local\
    \ largest=$(echo \"${array[@]}\" | sort -n -k2 -r)\n    local smallest_num=${smallest##*\
    \ }\n    local largest_num=${largest##* }\n    local sorted_num=$(echo \"${array[@]}\"\
    \ | sort -n -k1 -r)\n    local result=()\n    local i=0 j=1\n    local smallest_diff=${smallest_num}-${smallest_num}\n\
    \    local largest_diff=${largest_num}-${largest_num}\n    local diff=${smallest_diff}\
    \ # init diff to smallest diff\n    local smallest_result=$smallest_num\n    local\
    \ largest_result=$largest_num\n    for element in $sorted_num; do\n        if\
    \ [ $i == $j ]; then\n            result+=(\"$smallest_result\")\n           \
    \ break\n        fi\n        if [ $diff -gt ${smallest_diff} ] ; then\n      \
    \      result+=(\"$smallest_result\")\n            smallest_diff=$diff\n     \
    \       smallest_result=$smallest_num\n        fi\n        if [ $diff -lt ${largest_diff}\
    \ ] ; then\n            result+=(\"$largest_result\")\n            largest_diff=$diff\n\
    \            largest_result=$largest_num\n        fi\n        smallest_diff=$((\
    \ $smallest_diff - $diff ))\n        largest_diff=$(( $largest_diff + $diff ))\n\
    \        diff=$(( $diff + 1 ))\n        (( j++ ))\n    done\n    echo \"${result[@]}\"",
  "    local xs x\n    xs=$(echo $1 |sed 's/ /\",\"/g')\n    x=\"${xs:0:1}\"\n   \
    \ x=\"$( echo \"$xs\" | awk '{print $1;}' | sort -g | head -2 )\"\n    echo \"\
    $x\"\n    echo \"$x\"", "    local elements=\"$1\"\n    shift\n    local closest\
    \ nearest_element other\n    for nearest_element in $elements; do\n        other=\n\
    \        for element in $elements; do\n            if [ \"$nearest_element\" -gt\
    \ \"$element\" ]; then\n                other=\"$element\"\n                break\n\
    \            fi\n        done\n        if [ \"$other\" != \"\" ]; then\n     \
    \       echo \"$nearest_element $other\"\n        fi\n    done", "  IFS=$'\\n'\
    \ read -r -a args <<< \"$1\"\n  local index=0\n  local smallest=-1\n  local largest=-1\n\
    \  local smallestElement\n  local largestElement\n  local element\n  while [ $index\
    \ -lt $((${#args[@]}-1) ) ]; do\n    element=${args[$index]}\n    if [ $(( $smallest\
    \ < $element )) -eq 0 ]; then\n      smallest=$element\n      smallestElement=$smallest\n\
    \    elif [ $(( $largest < $element )) -eq 0 ]; then\n      largest=$element\n\
    \      largestElement=$largest\n    fi\n    let index=$index+1\n  done\n  echo\
    \ $smallestElement $largestElement", "    local list_=\"$1\"\n    if [[ ! \"${list_}\"\
    \ =~ \\ ]] ; then\n        echo \"${list_}\" 1>&2\n        return 1\n    fi\n\n\
    \    echo \"${list_}\" 1>&2\n    local -a elements\n    local -a sorted\n    local\
    \ -a closest_elements\n    local -a tmp\n    local i j\n    local elem elem2 min_elem\n\
    \    local min_elem min_elem2\n\n    # sort the list\n    IFS=' ' read -ra elements\
    \ <<< \"${list_}\"\n    sorted=( ${elements[@]} )\n    IFS=' ' read -ra sorted\
    \ <<< \"${sorted[*]}\"\n\n    # get the minimum and maximum values\n    min_elem=${sorted[0]}\n\
    \    min_elem2=${sorted[1]}\n    for (( i = 0 ; i < ${#sorted[@]} ; i++ )) ; do\n\
    \        elem=${sorted[$i]}\n        elem2=${sorted[((i+1)%${#sorted[@]})]}\n\
    \        if [[ \"$elem\" -gt \"$min_elem\" ]] ; then\n            min_elem=$elem\n\
    \        fi\n        if [[ \"$elem2\" -gt \"$min_elem2\" ]] ; then\n         \
    \   min_elem2=$elem2\n        fi\n    done\n\n    # loop through sorted elements\n\
    \    for (( i = 0 ; i < ${#sorted[@]} ; i++ )) ; do\n        elem=${sorted[$i]}\n\
    \        elem2=${sorted[((i+1)%${#sorted[@]})]}\n        if [[ \"$elem\" -gt \"\
    $min_elem\" ]] ; then\n            closest_elements=(${closest_elements[@]} \"\
    ${elem}\")\n        elif [[ \"$elem2\" -gt \"$min_elem2\" ]] ; then\n        \
    \    closest_elements=(${closest_elements[@]} \"${elem2}\")\n        fi\n    done\n\
    \n    # remove duplicates\n    local j=0\n    for (( i = 0 ; i < ${#closest_elements[@]}\
    \ ; i++ )) ; do\n        if [[ \"${closest_elements[i]}\" == \"${closest_elements[$((j+1))]}\"\
    \ ]] ; then\n            (( j++ ))\n        else\n            closest_elements=(\
    \ \"${closest_elements[@]:$((j+1))}\" )\n            j=0\n        fi\n    done\n\
    \n    # remove empty elements\n    while true; do\n        local j=0\n       \
    \ for (( i = 0 ; i < ${#closest_elements[@]} ; i++ )) ; do\n            if [[\
    \ ! \"${closest_elements[i]}\" =~ ^[0-9]+\\.[0-9]+$ ]] ; then\n              \
    \  (( j++ ", "    set -- $1\n    local min_idx=0\n    local max_idx=0\n    local\
    \ results=()\n\n    for idx in $(seq 1 $#); do\n        if [[ $idx -eq 1 ]]; then\n\
    \            [[ -z \"${arr[$((idx-1))]}\" && ${arr[$idx]} == \"${arr[$idx]}\"\
    \ ]] \\\n                || results[$min_idx++]=\"${arr[$((idx-1))]}\"\n     \
    \   else\n            [[ -z \"${arr[$idx]}\" && ${arr[$idx]} > \"${arr[$idx]}\"\
    \ ]] \\\n                || results[$max_idx++]=\"${arr[$idx]}\";\n        fi\n\
    \    done\n\n    echo \"${results[@]}\"", "  local items=$(echo \"$1\" | tr '\
    \ ' '\\n')\n  local smallest_item=$(echo \"$items\" | sort -n | head -1)\n  local\
    \ largest_item=$(echo \"$items\" | sort -n | tail -1)\n  printf '%s\\n' \"$smallest_item\"\
    \ \"${largest_item}\"", "    local numlist=$(echo $1 | tr '\"' ' ')\n    local\
    \ small=$(( ${#numlist[@]} - 1 ))\n    local large=0\n\n    for (( i=0; i < small;\
    \ i++ )); do\n        if (( $(echo \"${numlist[@]} < ${numlist[$i]}\" | bc) ));\
    \ then\n            small=$i\n        fi\n    done\n\n    for (( i=0; i < small;\
    \ i++ )); do\n        if (( $(echo \"${numlist[@]} > ${numlist[$i]}\" | bc) ));\
    \ then\n            large=$i\n        fi\n    done\n\n    if [ $small -eq $large\
    \ ]; then\n        echo \"${numlist[$small]}\"\n    else\n        echo \"${numlist[$small]}\
    \ ${numlist[$large]}\"\n    fi", "    local elements=$(printf \"%q\" \"$1\")\n\
    \    local min_distance=$2\n    local min_index=0\n    local max_index=0\n   \
    \ local min_value\n    local max_value\n    for ((i=0; i<${#elements[@]}; i++));\
    \ do\n        min_value=$(echo \"${elements[$i]}\" | awk -F'.' '{ print $1 < \"\
    $2\" ? $1 : $2 }')\n        max_value=$(echo \"${elements[$i]}\" | awk -F'.' '{\
    \ print $1 < \"$2\" ? $2 : $1 }')\n        if [[ $min_value -gt $max_value ]];\
    \ then\n            min_index=$i\n            min_value=${elements[$min_index]}\n\
    \        else\n            max_index=$i\n            max_value=${elements[$max_index]}\n\
    \        fi\n    done\n    echo \"${elements[$min_index]}\" \"${elements[$max_index]}\"",
  "    local lst_of_numbers=\"$1\"\n    local first_number second_number\n    local\
    \ lst_of_numbers_arr=($lst_of_numbers)\n    local len=${#lst_of_numbers_arr[@]}\n\
    \    local smallest_diff largest_diff\n    local i\n    local j\n    for i in\
    \ $(seq 0 $((len-2))); do\n        first_number=${lst_of_numbers_arr[i]}\n   \
    \     second_number=${lst_of_numbers_arr[i+1]}\n        smallest_diff=$(( $second_number\
    \ - $first_number ))\n        largest_diff=$(( $first_number - $second_number\
    \ ))\n        if [ $smallest_diff -eq $largest_diff ]; then\n            smallest_diff=$(echo\
    \ \"$smallest_diff\" | bc)\n            largest_diff=$(echo \"$largest_diff\"\
    \ | bc)\n            if [ $smallest_diff -gt $largest_diff ]; then\n         \
    \       echo \"$first_number\"\n                echo \"$second_number\"\n    \
    \            echo \"\"\n            fi\n        fi\n    done", "    local list=\"\
    ${1}\"\n\n    local -a elements\n    IFS=$'\\n' read -d '' -ra elements <<< \"\
    $list\"\n\n    local -a candidates\n    candidates=()\n    for element in \"${elements[@]}\"\
    ; do\n        candidates=(\"${candidates[@]}\" \"$element\")\n    done\n\n   \
    \ local -a results\n    results=()\n    local smallest=\"$(( ${candidates[0]}\
    \ - 1 ))\"\n    local largest=\"$(( ${candidates[0]} + 1 ))\"\n    for candidate\
    \ in \"${candidates[@]:1}\"; do\n        local -a candidates\n        candidates=()\n\
    \        for element in \"${elements[@]}\"; do\n            if [ \"$smallest\"\
    \ -lt \"$element\" ] \\\n            && [ \"$candidate\" -lt \"$element\" ] \\\
    \n            && [ \"$largest\" -gt \"$element\" ] \\\n            && [ \"$candidate\"\
    \ -gt \"$element\" ]; then\n                candidates=(\"${candidates[@]}\" \"\
    $element\")\n            fi\n        done\n        results=(\"${results[@]}\"\
    \ \"$candidate\")\n        smallest=\"$(( ${candidates[0]} - 1 ))\"\n        largest=\"\
    $(( ${candidates[0]} + 1 ))\"\n    done\n\n    echo \"${results[@]}\"", "\tlocal\
    \ list=\"$1\"\n\n\t[[ $# -lt 2 ]] && return 1\n\n\t# Build a list of the two closest\
    \ elements\n\tlocal pairs=()\n\tlocal min1=\"$2\"\n\tlocal min2=\"$2\"\n\tlocal\
    \ n=\"$#\"\n\tlocal i=1\n\n\twhile [[ $i -ne $n ]]; do\n\t\tlocal diff=\"$(echo\
    \ \"$min1 - $min2\" | bc)\"\n\t\tlocal min1=\"$2\"\n\t\tlocal min2=\"$2\"\n\t\t\
    if [[ $diff -le 0 ]]; then\n\t\t\tmin1=\"$1\"\n\t\t\tmin2=\"$2\"\n\t\telse\n\t\
    \t\tmin1=\"$2\"\n\t\t\tmin2=\"$1\"\n\t\tfi\n\t\tpairs+=\" $min1 $min2\"\n\t\t\
    ((i++))\n\tdone\n\n\techo \"${pairs[@]}\"", "    # Split the supplied argument\
    \ into two parts, the first part is the \"smallest\" element\n    # and the second\
    \ part is the \"largest\" element. The supplied argument is assumed to have at\n\
    \    # least two elements.  If no two elements satisfy this condition the function\
    \ will return the\n    # arguments unchanged.\n    #\n    local smallest=\"$1\"\
    \n    local largest=\"$2\"\n\n    # Split the supplied argument into two parts,\
    \ the first part is the \"smallest\" element\n    # and the second part is the\
    \ \"largest\" element. The supplied argument is assumed to have at\n    # least\
    \ two elements.  If no two elements satisfy this condition the function will return\
    \ the\n    # arguments unchanged.\n    #\n    if [[ \"$smallest\" == *\" \"$*\
    \ ]]; then\n        smallest=$( echo $smallest | sed 's/ //g' )\n        largest=$(\
    \ echo $largest | sed 's/ //g' )\n    fi\n\n    # If the smallest element is not\
    \ numeric, the function will return the arguments unchanged.\n    if [ -z \"$smallest\"\
    \ ] || [ -z \"$largest\" ]; then\n        echo \"No elements were supplied\"\n\
    \        return\n    fi\n\n    # Remove leading and trailing quotes from the smallest\
    \ and largest elements\n    smallest=$( echo $smallest | sed 's/\"//g' )\n   \
    \ largest=$( echo $largest | sed 's/\"//g' )\n\n    local smallest_index=\n  \
    \  local largest_index=\n    local smallest_value\n    local largest_value\n\n\
    \    # Iterate through the smallest and largest elements, finding the index of\
    \ the current element\n    # and then printing the values of both elements that\
    \ correspond to those indices\n    for element in $( echo $smallest $largest);\
    \ do\n        element=$( echo $element | sed 's/ //g' )\n        element=$( echo\
    \ $element | sed 's/^\"//g' )\n        element=$( echo $element | sed 's/\"$//g'\
    \ )\n\n        smallest_index=$( echo $element | awk 'BEGIN { FS=\"[\\.\\[\\]]+\"\
    \ } { print index($1, \"'$element'\") }')\n        largest_index=$( echo $element\
    \ | awk 'BEGIN { FS=\"[\\.\\[\\]]+\" } { print index($1, \"'$element'\") }' )\n\
    \        if [ -z \"$smallest_index\" ]; then\n            smallest_value=\"\"\n\
    \        else\n            smallest_value=$( echo $smallest | awk 'BEGIN { FS=\"\
    [\\.\\[\\]]+\" } { print $smallest_index+1 }')\n        fi\n        if [ -z \"\
    $largest_index\" ]; then\n            lar", "    local a=\"$1\";\n    local b=\"\
    $2\";\n\n    # Convert all strings to doubles\n    while read -r i; do\n     \
    \   a+=\" \"`echo $i | sed -e 's/^0\\(.\\)/\\1/'`;\n    done <<< \"$a\";\n\n \
    \   while read -r i; do\n        b+=\" \"`echo $i | sed -e 's/^0\\(.\\)/\\1/'`;\n\
    \    done <<< \"$b\";\n\n    # Loop through b and find its closest\n    for i\
    \ in `echo $b | sed 's/ /,/g'`; do\n        local j=0;\n        local difference=${a:-$i};\
    \ # initialize difference as negative of a\n        while [ $j -le $((${#b}-1))\
    \ ]; do\n            if (( ${difference} < ${a:-$b[$j]} )); then\n           \
    \     difference=${a:-$b[$j]};\n            else\n                break;\n   \
    \         fi\n        done\n        if (( $j == $((${#b}-1)) )) ; then\n     \
    \       echo \"$i $i\"\n        else\n            echo \"$i $b[$j]\"\n       \
    \ fi\n    done", "  local arg=\"$1\"\n  local -a elements=(\"$arg\")\n  local\
    \ smallest=0\n  local largest=0\n  local element\n\n  while ((${#elements[@]}>0));\
    \ do\n    local index=0\n    local value\n\n    while ((index<${#elements[@]}));\
    \ do\n      value=\"${elements[$index]}\"\n      (( index+1 )) || break\n    \
    \  element=\"$(echo \"$value\" | tr -d '\\\"')\"\n      (( index+1 )) || break\n\
    \      elements+=(\"$element\")\n    done\n    (( index+1 )) || break\n\n    if\
    \ [[ $((${#elements[@]}+1)) -gt $((${#elements[@]})) ]]; then\n      (( index+1\
    \ )) || break\n      elements+=(\"${elements[$index]}\")\n    fi\n\n    smallest=${elements[0]}\n\
    \    largest=${elements[0]}\n    for (( i=1; i<${#elements[@]}; i++ )); do\n \
    \     if [[ ${elements[$i]} -gt $smallest ]]; then\n        smallest=${elements[$i]}\n\
    \      fi\n      if [[ ${elements[$i]} -lt $largest ]]; then\n        largest=${elements[$i]}\n\
    \      fi\n    done\n\n    elements=(\"${elements[@]:0:1}\" \"${elements[@]:$((${#elements[@]}\
    \ - 1))}\")\n  done\n\n  echo \"$smallest\"\n  echo \"$largest\"", "    # Parse\
    \ arguments\n    IFS=$'\\n' read -a list <<< \"$1\"\n\n    # Sort the list by\
    \ magnitude\n    list=$(echo \"${list[*]}\" | sort -r)\n\n    # Extract the two\
    \ closest numbers\n    smallest=${list[0]}\n    largest=${list[0]}\n\n    for\
    \ number in \"${list[@]:1}\"\n    do\n        if [ \"$number\" -lt \"$smallest\"\
    \ ]\n        then\n            smallest=$number\n        elif [ \"$number\" -gt\
    \ \"$largest\" ]\n        then\n            largest=$number\n        fi\n    done\n\
    \n    # Return them in order\n    echo \"$smallest $largest\"", "    local numbers=$1\n\
    \    local temp\n\n    local xdiff\n    local x\n    local y\n    local z\n  \
    \  local w\n\n    temp=${numbers[1]}\n    shift\n    for x in $numbers\n    do\n\
    \        # Calculate delta x\n        xdiff=$(( ${x} - temp ))\n\n        # Compare\
    \ x with each of numbers in turn\n        for y in $numbers\n        do\n    \
    \        # Calculate delta y\n            ydiff=$(( ${y} - temp ))\n\n       \
    \     # If y is the smallest, keep it\n            if [ $ydiff -lt $xdiff ]\n\
    \            then\n                # If x is the smallest, keep it\n         \
    \       if [ $xdiff -lt $ydiff ]\n                then\n                    temp=$x\n\
    \                else\n                    temp=$y\n                fi\n     \
    \       fi\n        done\n\n        # Save the smallest difference\n        z=$temp\n\
    \    done\n\n    echo \"$x\" \"\\\"${z}\\\"\"", "    # Parse the supplied list.\n\
    \    # Make sure it contains at least two elements.\n    local elements=$@\n \
    \   local element=$1 index1 index2\n    if [ $# -eq 1 ]\n    then\n        local\
    \ elements=$@\n    elif [ $# -eq 2 ]\n    then\n        local elements=$(echo\
    \ \"$@\" | tr \" \" \"\\n\")\n    fi\n    local elementsLength=${#elements[@]}\n\
    \    if [ $elementsLength -eq 0 ]\n    then\n        echo \"$@\"\n        return\n\
    \    fi\n    if [ $elementsLength -gt 1 ]\n    then\n        # Loop through each\
    \ element and compare it to all other elements.\n        # Store the smallest\
    \ value in index1 and the biggest value in index2.\n        for (( index1 = 0;\
    \ index1 < elementsLength; index1++ ))\n        do\n            for (( index2\
    \ = index1+1; index2 < elementsLength; index2++ ))\n            do\n         \
    \       # Convert the element to floating point for comparison\n             \
    \   # and make sure that it actually is numeric.\n                local element=${elements[index1]}\n\
    \                if [ $element == \"\" ]\n                then\n             \
    \       local element=\"0\"\n                else\n                    element=$(echo\
    \ \"$element\" | tr -d '\\n')\n                fi\n                element=${elements[index2]}\n\
    \                if [ $element == \"\" ]\n                then\n             \
    \       local element=\"0\"\n                else\n                    element=$(echo\
    \ \"$element\" | tr -d '\\n')\n                fi\n                element=$(echo\
    \ \"$element\" | tr -d '\\n')\n                if [ $element == \"\" ]\n     \
    \           then\n                    local element=\"0\"\n                else\n\
    \                    element=$(echo \"$element\" | tr -d '\\n')\n            \
    \    fi\n                local element1=$(echo \"$element\" | tr -d '\\n')\n \
    \               local element2=$(echo \"$element\" | tr -d '\\n')\n          \
    \      # Check if element 1 is bigger than element 2\n                # if so,\
    \ set index1 = index2 and break the inner loop.\n                if [ $element1\
    \ > $element2 ]\n                then\n                    index1=index2\n   \
    \                 break\n                fi\n                # Check if element\
    \ 2 is bigger than element 1\n                # if so, set index2 = index1 and\
    \ break the inner loop.\n                if [ $element1 < $element2 ]\n      \
    \          then\n                    index2=index1\n                    break\n\
    \                fi\n            done\n        done\n    fi\n    # Return the\
    \ element pairs ordered from smallest to biggest in index1 and index2.\n    echo\
    \ \"$elements[index1] $elements[index2]\"", "    IFS=\" \" read -r -a numbers\
    \ <<< \"$1\"\n    local num_1 num_2\n    for (( i=0; i < ${#numbers[@]}; i++ ));\
    \ do\n      num_1=$(( numbers[$(( i + 1 ))] - numbers[$i] ))\n      num_2=$((\
    \ numbers[$i] - numbers[$(( i + 1 ))] ))\n      if [ \"$num_1\" -gt \"$num_2\"\
    \ ]; then\n        numbers[$i]=$num_1\n        numbers[$(( i + 1 ))]=num_2\n \
    \     else\n        numbers[$i]=$num_2\n        numbers[$(( i + 1 ))]=num_1\n\
    \      fi\n    done\n    IFS=\" \"\n    echo \"${numbers[*]}\"", "  local in_list\n\
    \  local smallest_in_list\n  local smallest_in_list_idx\n  local smallest_in_list\n\
    \  local smallest_in_list_idx\n  local i\n  local in_list_idx=0\n  in_list=\"\
    ${1}\"\n  if [[ ! ${#in_list} -eq 2 ]]; then\n    echo \"Not enough arguments\"\
    \n    exit 1\n  fi\n  echo \"${in_list}\"\n  for ((i=0; i < ${#in_list}; i++));\
    \ do\n    local elem\n    elem=\"${in_list[i]}\"\n    if [[ ${elem} -eq \"${smallest_in_list}\"\
    \ ]]; then\n      in_list_idx=\"${i}\"\n    fi\n    if [[ ${smallest_in_list}\
    \ -eq \"\" ]]; then\n      smallest_in_list=\"${elem}\"\n      smallest_in_list_idx=\"\
    ${i}\"\n    fi\n    if [[ ${elem} -gt ${smallest_in_list} ]]; then\n      smallest_in_list=\"\
    ${elem}\"\n      smallest_in_list_idx=\"${i}\"\n    fi\n  done\n  echo \"${smallest_in_list}:${smallest_in_list_idx}\"",
  "  echo $(expr $(echo \"$1\" | tr \" \" \"\\n\" | sort -n | uniq | sed \"s/ //g\"\
    \ | sed \"s/^/\\\"/\") \\\n      | sed \"s/^/[/\" | sed \"s/$/]/\" \\\n      |\
    \ sed \"s/ /\",\"/g\")", "    local a b c d e f g h i j k l m n o p q r s t u\
    \ v w x y z\n    local array=\"$1\"\n    if ! echo ${array} | grep -E '^[0-9]+\\\
    .[0-9]+$'; then\n      echo \"Usage: '${FUNCNAME[0]} list-of-numbers'\" >&2\n\
    \      return 0\n    fi\n    for a in ${array[@]:0:2}; do\n        for b in ${array[@]:2:2};\
    \ do\n            for c in ${array[@]:4:2}; do\n                for d in ${array[@]:6:2};\
    \ do\n                    for e in ${array[@]:8:2}; do\n                     \
    \   for f in ${array[@]:10:2}; do\n                            for g in ${array[@]:12:2};\
    \ do\n                                for h in ${array[@]:14:2}; do\n        \
    \                            for i in ${array[@]:16:2}; do\n                 \
    \                       for j in ${array[@]:18:2}; do\n                      \
    \                      for k in ${array[@]:20:2}; do\n                       \
    \                         for l in ${array[@]:22:2}; do\n                    \
    \                                for m in ${array[@]:24:2}; do\n             \
    \                                           for n in ${array[@]:26:2}; do\n  \
    \                                                          for o in ${array[@]:28:2};\
    \ do\n                                                                for p in\
    \ ${array[@]:30:2}; do\n                                                     \
    \               for q in ${array[@]:32:2}; do\n                              \
    \                                          for r in ${array[@]:34:2}; do\n   \
    \                                                                         for\
    \ s in ${array[@]:36:2}; do\n                                                \
    \                                for t in ${array[@]:38:2}; do\n             \
    \                                                                       for u\
    \ in ${array[@]:40:2}; do\n                                                  \
    \                                      for v in ${array[@]:42:2}; do\n       \
    \                                                                            \
    \         for w in ${array[@]:44:2}; do\n                                    \
    \                                                            for x in ${array[@]:46:2};\
    \ do\n                                                                       \
    \                             for y in ${array[@]:48:2}; do\n                \
    \                                                                            \
    \            for z in ${array[@]:50:2}; do\n                                 \
    \                                                                           if\
    \ [[ ${a} -gt ${b} ]] && [[ ${a} -gt ${c} ]] && [[ ${a} -gt ${d} ]] && [[ ${a}\
    \ -gt ${e} ]] && [[ ${a} -gt ${f} ]] && [[ ${a} -gt ${g} ]] && [[ ${a} -gt ${h}\
    \ ]] && [[ ${a} -gt ${i} ]] && [[ ${a} -gt ${j} ]] && [", "  IFS=' ' read -ra\
    \ array <<< \"$1\"\n  local min\n  local max\n\n  if (( \"${#array[@]}\" < 2 ));\
    \ then\n    echo -e \"Error: list must be of length at least two\\n\" >&2\n  \
    \  exit 1\n  fi\n\n  local i\n  min=\"${array[0]}\"\n  max=\"${array[-1]}\"\n\
    \  for i in \"${!array[@]}\"; do\n    local diff\n    diff=\"${array[i]} - $min\"\
    \n    if [ \"$diff\" -gt \"$(( $max - $min ))\" ]; then\n      min=\"${array[i]}\"\
    \n      max=\"${array[i]}\"\n    elif [ \"$diff\" -lt \"$(( $min - $max ))\" ];\
    \ then\n      min=\"${array[i]}\"\n      max=\"${array[i]}\"\n    else\n     \
    \ if (( \"${i}\" < \"${i-1}\" )); then\n        min=\"${array[i]}\"\n        max=\"\
    ${array[i]}\"\n      fi\n    fi\n  done\n\n  echo \"$min $max\"", "    local lst_str=$1\n\
    \    local lst_array=(${lst_str//[\" \"]/ })\n    local first_element=${lst_array[0]}\n\
    \    local second_element=${lst_array[1]}\n    local return_array=()\n\n    for\
    \ element in \"${lst_array[@]:2}\" ; do\n        if [ $element -gt $first_element\
    \ ]; then\n            second_element=$element\n        elif [ $element -lt $first_element\
    \ ]; then\n            first_element=$element\n        fi\n    done\n\n    return_array[0]=\"\
    '$first_element'\"\n    return_array[1]=\"'$second_element'\"\n    echo \"${return_array[@]}\"",
  "  local elements\n  local element\n  local min_element\n  local max_element\n \
    \ local min_value\n  local max_value\n  elements=($1)\n  shift\n  while [ $# -gt\
    \ 0 ]; do\n    element=$(echo \"$1\" | sed 's/[[:blank:]]//g')\n    min_element=$(echo\
    \ \"$elements\" | awk \"{if($1 < $min_element) {print $1}}\")\n    max_element=$(echo\
    \ \"$elements\" | awk \"{if($1 > $max_element) {print $1}}\")\n    shift\n  done\n\
    \  min_value=$(echo \"$min_element\" | awk \"{print $1}\")\n  max_value=$(echo\
    \ \"$max_element\" | awk \"{print $1}\")\n  echo \"$min_value $max_value\"", " \
    \   declare -i i\n\n    for i in \"${!1}\"; do\n        local j=$(( i - 1 ))\n\
    \        local a=$( echo \"${!1}\" | tr $i $j )\n\n        if [[ \"${!1}\" > \"\
    ${!a}\" ]]; then\n            local b=$( echo \"${!1}\" | tr $i $j )\n       \
    \     echo \"${!b}\"\n        elif [[ \"${!1}\" < \"${!a}\" ]]; then\n       \
    \     local b=$( echo \"${!1}\" | tr $i $j )\n            echo \"${!b}\"\n   \
    \     fi\n    done", "  local IFS=$1\n  local ARRAY=\"$2\"\n  local CLOSEST=$(cat\
    \ <<EOF\n  declare -a closest=()\n  for i in ${ARRAY[@]}; do\n    for j in ${ARRAY[@]};\
    \ do\n      ((distance=${i##* - }${j##* - }))\n      if [[ ${distance} -le ${i##*\
    \ - } ]]; then closest+=($j); fi\n      if [[ ${distance} -le ${j##* - } ]]; then\
    \ closest+=($i); fi\n    done\n  done\n  echo \"${closest[@]}\"\nEOF\n)", "\t\
    local -n a=$1\n\tlocal -n closest\n\tlocal -n cur curmax\n\tlocal -n diff\n\n\t\
    closest=()\n\tcur=$(awk '{print $1}' <<< \"${a[@]:1}\")\n\tcurmax=a[1]\n\tdiff=10\n\
    \tfor (( i = 1; i < ${#a[@]}; i++ )); do\n\t\tdiff=$((${a[$i]} - ${cur}))\n\t\t\
    if [[ ${diff} -le 0 ]]; then\n\t\t\tclosest+=(${a[$i]})\n\t\t\tcur=${a[$i]}\n\t\
    \telse\n\t\t\tif [[ ${diff} -gt $diff ]]; then\n\t\t\t\tdiff=$((${diff} - ${diff}\
    \ + ${curmax} - ${cur}))\n\t\t\tfi\n\t\t\tclosest+=(${cur})\n\t\t\tcur=${a[$i]}\n\
    \t\t\tcurmax=${a[$i]}\n\t\tfi\n\tdone\n\tclosest+=(${a[$i]})", "    local elements=$1\n\
    \    local element\n    local distance\n    local result\n    local index\n  \
    \  local smallest_value\n    local index2\n    local value1\n    local value2\n\
    \    local i\n    local i1\n    local i2\n    local j\n    local j1\n    local\
    \ j2\n    local min_index\n    local max_index\n    local min\n    local max\n\
    \    local imax\n    local imin\n    local temp\n\n    # find the smallest value\n\
    \    smallest_value=$(echo \"$elements\" | awk '{for(i=1;i<=NF;i++)if($i<=$i)\
    \ print $i}')\n    # find all values bigger than smallest value\n    index1=0\n\
    \    index2=1\n    while [[ ${index1}==0 ]]; do\n        index1=$(echo \"$elements\"\
    \ | awk -v index1=$index1 -F' ' '{ for(i=1;i<=NF;i++)if($i<='\"${smallest_value}\"\
    ') print index1} {exit}' </dev/null)\n        index2=0\n        while [[ ${index2}==0\
    \ ]]; do\n            index2=$(echo \"$elements\" | awk -v index2=$index2 -F'\
    \ ' '{ for(i=1;i<=NF;i++)if($i>='\"${smallest_value}\"') print index2} {exit}'\
    \ </dev/null)\n        done\n    done\n    smallest_values=$(echo \"$elements\"\
    \ | awk -v smallest_value=$smallest_value -F' ' '{ for(i=1;i<=NF;i++)if($i==smallest_value)\
    \ print $i}')\n    # find all values smaller than smallest value\n    index1=0\n\
    \    index2=1\n    while [[ ${index1}==0 ]]; do\n        index1=$(echo \"$elements\"\
    \ | awk -v index1=$index1 -F' ' '{ for(i=1;i<=NF;i++)if($i>='\"${smallest_value}\"\
    ') print index1} {exit}' </dev/null)\n        index2=0\n        while [[ ${index2}==0\
    \ ]]; do\n            index2=$(echo \"$elements\" | awk -v index2=$index2 -F'\
    \ ' '{ for(i=1;i<=NF;i++)if($i<='\"${smallest_value}\"') print index2} {exit}'\
    \ </dev/null)\n        done\n    done\n    biggest_values=$(echo \"$elements\"\
    \ | awk -v smallest_value=$smallest_value -F' ' '", "  local -a a=$1\n  local\
    \ diff num\n  local min\n  local max\n  local i\n  local j\n  local output\n\n\
    \  for ((i=0; i < ${#a[@]}; i++)); do\n    # find the smallest and the biggest\
    \ number from the list, put that into the output array\n    min=a[0]\n    max=${a[0]}\n\
    \    for ((j=0; j < ${#a[@]}; j++)); do\n      diff=`echo \"${a[j]} - ${a[i]}\"\
    \ | bc -l`\n      if [[ $diff -lt $min ]]; then\n        min=${a[j]}\n      fi\n\
    \      if [[ $diff -gt $max ]]; then\n        max=${a[j]}\n      fi\n    done\n\
    \    output+=($(echo \"${a[j]} - ${a[i]}\" | bc -l))\n  done\n  echo ${output[@]}",
  "    local numbers=\"${1}\"\n    local min_diff=0\n    local elem1\n    local elem2\n\
    \n    # First try to find the smallest difference between two consecutive numbers\
    \ (if any)\n    local elem1=\"$(get_smallest_diff \"${numbers}\")\"\n\n    # If\
    \ that didn't work, try again with the biggest difference between consecutive\
    \ numbers\n    if [[ -z \"${elem1}\" ]]; then\n        local elem2=\"$(get_biggest_diff\
    \ \"${numbers}\")\"\n    else\n        local min_diff=\"${elem1}\"\n        local\
    \ elem2=\"${elem2}\"\n    fi\n\n    # Return the result if both are valid\n  \
    \  if [[ -n \"${elem1}\" ]] && [[ -n \"${elem2}\" ]]; then\n        echo \"'${elem1}'\
    \ '${elem2}'\"\n    else\n        echo \"'${elem1}'\" if [[ -z \"${elem2}\" ]]\
    \ && [[ -n \"${elem1}\" ]]\n    fi", "    local numbers=$1\n    local i closest\n\
    \    local numbers\n    local number\n    local closest_str\n    local closest_number\n\
    \    local closest_index\n    local index\n    local str\n    local number\n\n\
    \    numbers=( $numbers )\n    number=${numbers[0]}\n    index=0\n    for (( i\
    \ = 0; i < ${#numbers[@]}; i++ )); do\n        if [[ $index -eq 0 ]]; then\n \
    \           closest_str=$numbers[i]\n            closest_number=${numbers[$i]}\n\
    \            closest_index=i\n            continue\n        fi\n        if ((\
    \ ${numbers[$index]} - ${numbers[$i]} > 0 )); then\n            closest_str=$numbers[i]\n\
    \            closest_number=${numbers[$i]}\n            closest_index=i\n    \
    \    else\n            closest_str=$numbers[$index]\n            closest_number=${numbers[$index]}\n\
    \            closest_index=index\n        fi\n    done\n    for (( i = 0; i <\
    \ ${#numbers[@]}; i++ )); do\n        number=${numbers[i]}\n        if [[ ${numbers[$i]}\
    \ -eq ${closest_number} ]]; then\n            if (( ${closest_index} != ${i} ));\
    \ then\n                closest_str=${numbers[$i]}\n                closest_number=${numbers[$closest_index]}\n\
    \                closest_index=${i}\n            fi\n        fi\n    done\n  \
    \  echo \"$closest_str $closest_number\"", "    local list=\"$1\"\n    if [[ $#\
    \ -lt 2 ]]\n    then\n        echo \"Usage: $(basename $0) number1 number2 ...\"\
    \n        exit 1\n    fi\n\n    local min\n    local max\n    local result\n\n\
    \    local i\n    local j\n    local m\n    local n\n\n    for ((i = 1; i < $#;\
    \ i++)); do\n        result=()\n        n=$i\n\n        for ((j = 1; j < $#; j++));\
    \ do\n            m=$(echo \"$list\" | awk \"{print \\$$n}\" | awk -F '.' '{print\
    \ $1 - $$j}')\n            if [[ $m -ge 0 ]]\n            then\n             \
    \   result=(\"${result[@]}\" \"$list\" | awk -F '.' '{print $1 + $$j}')\n    \
    \        fi\n            n=$(($n + 1))\n        done\n\n        if [[ ${#result[@]}\
    \ -eq 0 ]]\n        then\n            continue\n        fi\n\n        min=${result[0]}\n\
    \        max=${result[1]}\n\n        for ((j = 1; j < $#; j++)); do\n        \
    \    m=$(echo \"$list\" | awk \"{print \\$$n}\" | awk -F '.' '{print $1 - $$j}')\n\
    \            if [[ $m -ge 0 ]]\n            then\n                max=${result[1]}\n\
    \            fi\n            n=$(($n + 1))\n        done\n\n        if [[ $min\
    \ -gt $max ]]\n        then\n            min=$min\n        else\n            min=$max\n\
    \        fi\n    done\n\n    echo ${result[@]}", "  local elements=\"${1}\"\n\
    \  [[ \"$elements\" =~ \\- ]]\n  local sep=\"${1#-}\"\n  local closest=()\n  local\
    \ smallest=()\n  local largest=()\n  local nums=()\n\n  for element in ${elements//'\
    \ '/ }; do\n    nums+=(\"$element\")\n  done\n\n  for num in \"${nums[@]}\"; do\n\
    \    local distance=()\n    local minidx=-1\n    local maxidx=-1\n    for ((i=1;i<${#nums[@]};i++));\
    \ do\n      distance+=(\"${nums[i]}\" $(( \"${nums[i]}\" > num ? 1 : -1 )))\n\
    \    done\n\n    local min=\"${distance[@]}\"\n    local minidx=\"${#min[@]}\"\
    \n    local minidx2=-1\n\n    local max=\"${distance[@]}\"\n    local maxidx=\"\
    ${#max[@]}\"\n    local maxidx2=-1\n\n    if [ \"${#nums[@]}\" -gt \"${#min[@]}\"\
    \ ]; then\n      min=\"${nums[@]}\"\n      minidx=\"${#nums[@]}\"\n    fi\n\n\
    \    if [ \"${#nums[@]}\" -gt \"${#max[@]}\" ]; then\n      max=\"${nums[@]}\"\
    \n      maxidx=\"${#nums[@]}\"\n    fi\n\n    if [ \"${#nums[@]}\" -gt \"${#min[@]}\"\
    \ ] || [ \"${#nums[@]}\" -gt \"${#max[@]}\" ]; then\n      echo \"$num cannot\
    \ be used to find the closest elements\"\n      exit 99\n    fi\n\n    if [ \"\
    ${#closest[@]}\" -eq 0 ]; then\n      closest=(\"$min\")\n      smallest=(\"$min\"\
    )\n      largest=(\"$max\")\n      continue;\n    fi\n\n    for ((i=1;i<${#closest[@]};i++));\
    \ do\n      distance+=(\"${closest[$i]}\" $(( \"${closest[$i]}\" > num ? 1 : -1\
    \ )))\n    done\n\n    if [ \"${#distance[@]}\" -eq 0 ]; then\n      closest=(\"\
    $min\")\n      smallest=(\"$min\")\n      largest=(\"$max\")\n      continue;\n\
    \    fi\n\n    local closest=\"${closest[@]}\"\n    local smallest=\"${smallest[@]}\"\
    \n    local largest=\"${largest[@]}\"\n    local distance=\"${distance[@]}\"\n\
    \    local minidx", "  local nums=\"$1\" || return\n  nums=\"${nums// / }\"\n\
    \  local -n elements=$( echo \"${nums}\" | tr \" \" \"\\n\" )\n  local min=$(\
    \ echo \"${elements[0]}\" | cut -d \" \" -f1 )\n  local max=$( echo \"${elements[0]}\"\
    \ | cut -d \" \" -f2 )\n  local min_max=\"$min $max\"\n  for elem in \"${elements[@]:1}\"\
    ; do\n    if [[ $min_max -le \"$elem\" ]]; then\n      min=$elem\n    fi\n   \
    \ if [[ $elem -le $max ]]; then\n      max=$elem\n    fi\n  done\n  echo \"$min\
    \ $max\"", "  local elements=$1\n\n  # Split elements into an array\n  local elements_array=($elements)\n\
    \n  # Return two closest elements (smallest first), and return them in order\n\
    \  local smallest_element=${elements_array[0]}\n  local largest_element=${elements_array[0]}\n\
    \  local smallest_element_found=0\n  local largest_element_found=0\n  for element\
    \ in \"${elements_array[@]:1}\"\n  do\n    ((smallest_element_found+=1))\n   \
    \ if (( $smallest_element_found == 2 ))\n    then\n      smallest_element=${element}\n\
    \      smallest_element_found=1\n    fi\n    ((largest_element_found+=1))\n  \
    \  if (( $largest_element_found == 2 ))\n    then\n      largest_element=${element}\n\
    \      largest_element_found=1\n    fi\n  done\n\n  # Return the elements\n  echo\
    \ \"${smallest_element} ${largest_element}\""]
stop_tokens:
- "\n}"
