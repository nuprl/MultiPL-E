name: HumanEval_99_closest_integer
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a value (string) representing\
  \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
  # from two integers, round it away from zero.\n# Examples\n# >>> $(closest_integer\
  \ \"10\")\n# \"10\"\n# >>> $(closest_integer \"15.3\")\n# \"15\"\n# Note:\n# Rounding\
  \ away from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\n#\n# $1 is a string\nclosest_integer() {\n"
tests: "}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
  \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\"\
  \ ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
completions: ["    local NUM=$1\n    local ROUND\n    ROUND=1 # Set ROUND to be a\
    \ positive number to round\n    local MIN\n    MIN=0 # Set MIN to 0\n    local\
    \ MAX\n    MAX=1000000000000000 # Set MAX to 1000000000000000\n    local CLOSEST_RESULT\n\
    \    CLOSEST_RESULT=$1 # Set CLOSEST_RESULT to the number we started with\n  \
    \  while [[ $ROUND -le 100 ]] || [[ $ROUND -ge 99 ]] ; do\n        local RESULT\n\
    \        RESULT=$(($ROUND+$MIN+$MAX)) # Add MIN to ROUND and MAX to ROUND\n  \
    \      if [[ $RESULT -gt $CLOSEST_RESULT ]]; then\n            CLOSEST_RESULT=$RESULT\n\
    \        fi\n        local TEST\n        TEST=$(echo $RESULT)\n        if [[ $TEST\
    \ -ge $1 ]]; then\n            MAX=$RESULT\n        else\n            MIN=$RESULT\n\
    \        fi\n        ROUND=$(($ROUND+1))\n    done\n    echo \"$CLOSEST_RESULT\"",
  "    local a=\"${1#-}\"\n    local b=\"${1%-}\"\n    local c=\"${2#-}\"\n    local\
    \ d=\"${2%-}\"\n\n    if [[ \"$a\" == \"$d\" ]];\n    then\n        echo -n \"\
    0\"\n    else\n        echo \"$(expr \"$a\" : \"$b\")\"\n    fi", "  local NUM=$1\n\
    \  local RESULT=0\n\n  # Get difference between NUM and RESULT to ensure integer\
    \ rounding\n  NUM=\"${NUM%.*}\"\n  RESULT=\"${RESULT%.*}\"\n\n  local NUMNUMNUM\n\
    \  if [ $RESULT -gt 0 ]; then\n    NUMNUMNUM=\"-$NUM\"\n  else\n    NUMNUMNUM=\"\
    $NUM\"\n  fi\n\n  # Sum all possible differences between the two numbers\n  local\
    \ SUM=0\n  for ((i=0;i<5;i++)); do\n    local DIFF=\"$i\"\n    if (( i > 0 ));then\n\
    \      DIFF=\"$((DIFF+1))\"\n    fi\n    ((SUM+=${DIFF}${NUMNUMNUM}${DIFF}))\n\
    \  done\n\n  # Get absolute difference\n  RESULT=\"${RESULT%+$SUM}\"\n\n  echo\
    \ \"$RESULT\"", "  local val=$1\n  local diff1=0\n  local diff2=0\n  local diff\n\
    \  local num1=\"${val%.*}\"\n  local num2=\"${val##*.}\"\n  # Handle special case\
    \ for equidistant numbers.\n  if [ \"${val}\" == \"0\" ]; then\n    return 0;\n\
    \  fi\n  # Find the difference between the two numbers as float\n  diff=\"$(echo\
    \ \"${num2}-${num1}\" | bc)\"\n  # Handle special case for equality.\n  if [ \"\
    ${diff}\" == \"0\" ]; then\n    return 0\n  fi\n  # Handle special case for equidistant\
    \ numbers, where the difference\n  # is positive.\n  if [ \"${diff}\" == \"+inf\"\
    \ ]; then\n    return 0\n  fi\n  # Handle special case for equidistant numbers,\
    \ where the difference\n  # is negative.\n  if [ \"${diff}\" == \"-inf\" ]; then\n\
    \    return 0\n  fi\n  # The difference between the two numbers is positive, so\
    \ return the\n  # greater integer.\n  if [ \"${diff}\" > 0 ]; then\n    echo \"\
    ${num1}\"\n  else\n    echo \"${num2}\"\n  fi", "\tlocal a=\"${1}.0\"\n\tlocal\
    \ b=\"-${1}.0\"\n\tlocal diff tmp\n\n\t# a is closest to b if they are equal and\
    \ differ by less than 1\n\tdiff=`echo \"${b} - ${a}\"|bc -l`\n\tif [ ${diff} ==\
    \ \"${1}\" ] && [ ${diff} != \"1\" ]; then\n\t\tdiff=`echo \"${a} - ${b}\"|bc\
    \ -l`\n\t\tif [ ${diff} == \"${1}\" ]; then\n\t\t\tdiff=\"1\"\n\t\telse\n\t\t\t\
    diff=\"-1\"\n\t\tfi\n\tfi\n\n\t# if the difference is still zero, return the original\
    \ number\n\tif [ \"${diff}\" == \"0\" ]; then\n\t\techo $1\n\telse\n\t\ttmp=\"\
    ${b}\"\n\t\techo \"${tmp}${diff}\"\n\tfi", "  awk -F. '{print $1}' <<< \"$1\"",
  "  local val=\"$1\"\n  local min\n  local max\n  local middle\n  local output\n\n\
    \  if [[ \"$val\" == *\".\"* ]]; then\n    # Remove any decimal places\n    num=$(echo\
    \ \"$val\" | sed -e 's/\\..*$//')\n    # If the number is all digits, just return\
    \ the number\n    if [[ \"$num\" == *[^[:digit:]]* ]]; then\n      return \"$val\"\
    \n    fi\n    middle=$(( (num / 2) | 0 ))\n    max=$(expr \"$middle\" + 1)\n \
    \   min=$(expr \"$middle\" - 1)\n  else\n    num=$(echo \"$val\" | sed -e 's/^\\\
    ..*//')\n    middle=$(( (num / 2) | 0 ))\n    max=$(expr \"$middle\" + 1)\n  \
    \  min=$(expr \"$middle\" - 1)\n  fi\n\n  output=$(\n    if [ \"$max\" -gt \"\
    $min\" ];\n    then\n      expr \"$max\" - \"$min\"\n    else\n      expr \"$max\"\
    \ - \"$num\"\n    fi\n  )\n  echo \"$output\"", "    local value=\"$1\"\n    local\
    \ num=$((10#$1))\n    local closest=$(( 10#$((num % 10)) ))\n\n    while [[ $closest\
    \ -eq 0 ]]\n    do\n        num=${num/10}\n        closest=$(( 10#$((num % 10))\
    \ ))\n    done\n    echo \"$value\"", "  local string=\"${1}\"\n  local integer\n\
    \  integer=$((string+0))\n  while [[ ${integer} -le ${string} ]]; do\n    integer=$((integer+1))\n\
    \  done\n  echo $integer", "    local NUMBER=\"$1\"\n    local TOLERANCE=10\n\
    \    local MIN_INTEGER=1\n    local MAX_INTEGER=100\n    local MAX_ABS=\"$(expr\
    \ ${MAX_INTEGER} - ${MIN_INTEGER})\"\n    local NUMBER_FORMAT=\"%d\"\n\n    #\
    \ Convert the input to an integer.\n    local N=\"${NUMBER}\"\n    local S=\"\
    ${N%%,*}\"\n    local P=\"${N#*,}\"\n    local TOTAL_DIGITS=\"$(expr ${P} / ${TOLERANCE})\"\
    \n    local TRUNCATE_DIGITS=\"$(expr ${S} / ${TOLERANCE})\"\n    local INT_DIGIT_ONE=\"\
    $(expr ${S} - ${TRUNCATE_DIGITS} )\"\n    local INT_DIGIT_ZERO=\"$(expr ${S} -\
    \ ${TRUNCATE_DIGITS} + ${TOTAL_DIGITS} )\"\n    local INT_DIGIT=\"$(expr ${S}\
    \ + ${TOTAL_DIGITS} + ${TOLERANCE} )\"\n\n    if [[ \"$S\" -gt \"0\" ]]; then\n\
    \        if (( ${S} == ${TRUNCATE_DIGITS} ))\n        then\n            INT_DIGIT=\"\
    -${INT_DIGIT_ZERO}\"\n        else\n            INT_DIGIT=\"-${INT_DIGIT_ONE}\"\
    \n        fi\n    fi\n    if [[ \"${INT_DIGIT}\" -gt \"${MAX_ABS}\" ]]; then\n\
    \        INT_DIGIT=\"$(expr ${INT_DIGIT} - ${MAX_ABS})\"\n    fi\n    if [[ \"\
    ${INT_DIGIT}\" -lt \"${MIN_INTEGER}\" ]]; then\n        INT_DIGIT=\"$(expr ${INT_DIGIT}\
    \ + ${MIN_INTEGER})\"\n    fi\n    if [[ \"${INT_DIGIT}\" -gt \"${MAX_INTEGER}\"\
    \ ]]; then\n        INT_DIGIT=\"$(expr ${INT_DIGIT} - ${MAX_INTEGER})\"\n    fi\n\
    \    echo ${INT_DIGIT}", "    local num=$1\n    # echo \"num is: $num\"\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    #\
    \ echo \"$num\" | sed 's/^-\\?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\\
    ?\\([1-9]\\)/-1&/'\n    # echo \"$num\" | sed 's/^-\\?\\([1-9]", "    local val=\"\
    ${1}\"\n    local min=0\n    local max=$((${val}-10000))\n    local res=$(echo\
    \ \"${val} * $((${max} - min)) / 10000\" | bc)\n    echo ${res}", "    local x=$1\
    \ #local variable\n    echo \"$x\" # debug\n    # Trim leading and trailing whitespace\n\
    \    x=${x#\"${x%%.*}\"}\n    x=${x%%\"${x#*.}\"}\n    # Get the sign of the number\n\
    \    x=${x#-}\n    x=${x%%-}\n    # Figure out the integer value of the number\n\
    \    x=${x%%%.*}\n    x=${x##*/}\n    local int_val=$((10#${x}))\n    # If the\
    \ number is not equidistant from two integers, round it away\n    # from zero\n\
    \    if [[ ${x} -eq ${int_val} ]]; then\n        int_val=$((int_val+1))\n    fi\n\
    \    echo \"${int_val}\"", "    local str=\"$1\"\n    local i1=\"$2\"\n    local\
    \ i2=\"$3\"\n    local diff\n    local i\n    diff=\"$((i1-i2))\"\n    if [ $diff\
    \ -gt 0 ]; then\n        i=$((i1+1))\n    elif [ $diff -lt 0 ]; then\n       \
    \ i=$((i2-1))\n    else\n        i=$i1\n    fi\n    echo \"$i\"", "  local x=\"\
    $1\"\n  local prefix=\"-${x}\"\n  local suffix=\"+${x}\"\n  local closest=1000000000\n\
    \  local closest_num=$(closest_float \"$1\") || exit 1\n  local diff\n  diff ()\
    \ {\n    local x=\"$1\"\n    local y=\"$2\"\n    test \"$y\" = \"$x\" && return\
    \ 0\n    test \"$y\" = \"$prefix\" && return 1\n    test \"$y\" = \"$suffix\"\
    \ && return -1\n    return 1\n  }\n  while diff \"$closest_num\" \"$x\" ; do\n\
    \    closest_num=$(closest_float \"$closest_num\")\n  done\n  diff \"$closest_num\"\
    \ \"$x\" &> /dev/null\n  diff \"$closest_num\" \"$prefix\" &> /dev/null\n  diff\
    \ \"$closest_num\" \"$suffix\" &> /dev/null\n  return $(($closest_num + $diff\
    \ - 1))", "  # Input validation\n  if [[ \"$1\" == \"-?\" || \"$1\" == \"--help\"\
    \ || \"$1\" == \"-h\" || \"$1\" == \"--version\" || \"$1\" == \"-v\" ]]; then\n\
    \    echo \"$($FUNCNAME $0 [OPTION]... VALUE)...\"\n    echo \"  Options:\"\n\
    \    echo\n    echo \"    -h, --help         Print this help message and exit\"\
    \n    echo \"    -v, --version      Print version information and exit\"\n   \
    \ echo \"    -?, --help         Print this help message and exit\"\n    exit 0\n\
    \  fi\n  local STRING=\"$1\"\n  local MIN\n  local MAX\n  local DIVISOR\n  local\
    \ NUMBER\n  local NEXT OLD DIVISOR\n  # Parse and validate input\n  # Make sure\
    \ we have a valid integer string as a first argument\n  case \"${STRING}\" in\n\
    \    -*)\n      echo \"$FUNCNAME: error: invalid argument '$STRING' -- not a number\"\
    \ >&2\n      exit 1\n    ;;\n    *[!0-9]*)\n      echo \"$FUNCNAME: error: invalid\
    \ argument '$STRING' -- not a number\" >&2\n      exit 1\n    ;;\n    *)\n   \
    \   # Convert to integer\n      NUMBER=\"${STRING}\"\n      ;;\n  esac\n  MIN=\"\
    0\"\n  MAX=\"9\"\n  # Parse the number\n  while [[ \"$NUMBER\" =~ (^|)([!0-9]+)($|)\
    \ ]]; do\n    # Get the divisor\n    OLD=\"${BASH_REMATCH[2]}\"\n    DIVISOR=\"\
    ${BASH_REMATCH[3]}\"\n    # Make sure the divisor is valid and greater than zero\n\
    \    if [[ ${DIVISOR} =~ ^[!0-9]+$ ]]; then\n      if [[ \"${MIN}\" == \"0\" ]];\
    \ then\n        MIN=\"${DIVISOR}\"\n      else\n        MAX=\"${DIVISOR}\"\n \
    \     fi\n    fi\n    # Make sure the number is greater than zero\n    if [[ \"\
    ${NUMBER}\" =~ ^[0-9]+$ ]]; then\n      # Make sure the number is less than the\
    \ maximum\n      if [[ \"$NUMBER\" -gt \"$MAX\" ]]; then\n        echo \"$FUNCNAME:\
    \ error: argument '$1' out of range: maximum is '$MAX'\" >&2\n        exit 1\n\
    \      fi\n      # Make sure the number is less than the minimum\n      if [[\
    \ \"$NUMBER\" -lt \"$MIN\" ]]; then\n        echo \"$FUNCNAME: error: argument\
    \ '$1' out of range: minimum is '$MIN'\" >&2\n        exit 1\n      fi\n     \
    \ # Make sure the number is equidistant from ", "  local value\n  value=\"$1\"\
    \n  local number=\"$1\"\n  if (( $# != 1 )); then\n      echo \"Usage: $(basename\
    \ $0) [-n number] [-f format]\"\n      return 1\n  fi\n  local minval=\"$1\"\n\
    \  local minvalstr=\"$minval\"\n  minvalstr=\"${minvalstr%.*}\"\n  local maxval=\"\
    $1\"\n  local maxvalstr=\"$maxval\"\n  maxvalstr=\"${maxvalstr%.*}\"\n  local\
    \ n=\"$1\"\n  local nstr=\"$n\"\n  nstr=\"${nstr%.*}\"\n  if [ \"$maxval\" ==\
    \ \"-inf\" ] || [ \"$minval\" == \"inf\" ]; then\n      echo \"You passed an infinite\
    \ number\"\n      return 1\n  fi\n  local mindiff=\"1e18\"\n  local maxdiff=\"\
    -1e18\"\n  local mindiffstr=\"-1e18\"\n  local maxdiffstr=\"1e18\"\n  if [ \"\
    $minval\" != \"$maxval\" ]; then\n      mindiff=$(( ($minval - $maxval) ))\n \
    \     maxdiff=$(( ($maxval - $minval) ))\n      mindiffstr=$(( ($mindiff) ))\n\
    \      maxdiffstr=$(( ($maxdiff) ))\n      if [ \"$mindiff\" == 0 ]; then\n  \
    \        maxdiffstr=\"-1\"\n      fi\n  fi\n  if [ \"$mindiff\" -gt \"$maxdiff\"\
    \ ]; then\n      echo \"${minvalstr}.${mindiffstr} and ${maxvalstr}.${maxdiffstr}\
    \ are equidistant\"\n      return 1\n  fi\n  if [ \"$mindiffstr\" == \"-1\" ];\
    \ then\n      mindiffstr=\"0\"\n  fi\n  if [ \"$maxdiffstr\" == \"-1\" ]; then\n\
    \      maxdiffstr=\"0\"\n  fi\n  local minint=\"$minvalstr\"\n  local maxint=\"\
    $maxvalstr\"\n  local mindiffint=\"$mindiffstr\"\n  local maxdiffint=\"$maxdiffstr\"\
    \n  if [ \"$minval\" != \"$maxval\" ]; then\n      minint=$(( ($minval - $maxval)\
    \ ))\n      maxint=$(( ($maxval - $minval) ))\n      mindiffint=$(( ($mindiff\
    \ + $mindiffstr) ))\n      maxdiffint=$(( ($maxdiff - $maxdiffstr) ))\n      if\
    \ [ \"$mindiffint\" == ", "\t# This code makes a few assumptions:\n\t# - All numbers\
    \ are positive\n\t# - All numbers are equidistant from two integers\n\t# - All\
    \ numbers are non-negative\n\t# - All numbers are non-zero and non-decimal\n\t\
    # - All numbers are of same number of digits\n\t# - No leading zeros are allowed\n\
    \t# - No leading zeros or negative signs are allowed\n\t# - All numbers have same\
    \ number of digits\n\t# - No leading zeros are allowed\n\t# - No leading zeros\
    \ or negative signs are allowed\n\t# - All numbers have same number of digits\n\
    \t# - All numbers consist of same number of digits\n\t# - The function must return\
    \ an int\n\t\n\t# Convert the string to a number\n\tread -p \"$1\" number_to_test\
    \ <<< \"$1\"\n\tnumber_to_test=$((number_to_test))\n\t\n\t# This array will hold\
    \ the digits of a given number\n\tdig_array=()\n\t\n\t# First we take each digit\
    \ of the given number\n\t# Note: To get the last digit we subtract 1 from the\
    \ length\n\tfor i in $(seq 1 $((${#number_to_test} - 1)))\n\tdo\n\t\t# Add the\
    \ digit to the array\n\t\tdig_array[$i]=$((${number_to_test%%%.*}${number_to_test#*%.}))\n\
    \t\t# Remove the digit from the number\n\t\tnumber_to_test=$((${number_to_test#*${dig_array[$i]}}))\n\
    \tdone\n\t\n\t# Take the difference of the number and the sum of the array\n\t\
    # then round up to the nearest integer\n\tdig_difference=$((${number_to_test}-${dig_array[@]}))\n\
    \tdig_sum=$((${#dig_array[@]}+1))\n\t\n\t#if $dig_sum > $number_to_test\n\t#then\n\
    \t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\t\n\t\n\t#if [ $dig_sum -gt $number_to_test\
    \ ]\n\t#then\n\t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\t\n\t\n\t#if [ $dig_sum\
    \ -gt $number_to_test ]\n\t#then\n\t#\tdig_sum=$((number_to_test + 1))\n\t#fi\n\
    \t\n\t#echo \"$dig_sum\"\n\t\n\tif [ \"$dig_sum\" -gt \"$number_to_test\" ]; then\n\
    \t\tdig_sum=$((number_to_test + 1))\n\tfi\n\t\n\t\n\t\n\t#if [ -z \"$dig_sum\"\
    \ -o ", "    local number=$1\n    local digits=${number//./ }\n    if [ \"$number\"\
    \ == \"$digits\" ]; then\n        echo $1\n        return\n    fi\n\n    # Check\
    \ if number is equidistant from two integers\n    local a=$(( 10#$digits - 5 ))\n\
    \    local b=$(( 10#$digits + 5 ))\n    # Check if given number is equidistant\
    \ from two integers\n    local c=$(( 10#$number - 5 ))\n    local d=$(( 10#$number\
    \ + 5 ))\n    # Check if $a is closer to $b than $c and $d\n    if (( $a > $b\
    \ )); then\n        local tmp=$a\n        a=$b\n        b=$tmp\n    fi\n    if\
    \ (( $c > $d )); then\n        local tmp=$c\n        c=$d\n        d=$tmp\n  \
    \  fi\n    # $a is closer to $b or $c than $d\n    if [ $a -gt $b ] || [ $c -gt\
    \ $d ]; then\n        echo $a\n        return\n    fi\n    # $b is closer to $c\
    \ than $d\n    if [ $b -gt $c ] || [ $d -gt $a ]; then\n        echo $b\n    \
    \    return\n    fi\n    # $c is closer to $d than $a\n    if [ $c -gt $d ] ||\
    \ [ $d -gt $a ]; then\n        echo $c\n        return\n    fi\n    # Given number\
    \ is equidistant from two integers\n    echo $d", "\tlocal value=$1\n\tlocal closest\n\
    \tlocal num1=$(awk -F. '{ print $1 }' <<< $value)\n\tlocal num2=$(awk -F. '{ print\
    \ $2 }' <<< $value)\n\tlocal diff=$(( num1 - num2 ))\n\n\tif [ \"$diff\" = \"\
    $((num1 * -1))\" ]; then\n\t\tclosest=$(( num1 + 1 ))\n\telse\n\t\tclosest=$((\
    \ num1 - 1 ))\n\tfi\n\n\techo \"$closest\"", "  local number=$1\n  local min=$((\
    \ $(( $number | gawk '{ print $1 }') - 1 ))\n  local max=$(( $(( $number | gawk\
    \ '{ print $1 }') + 1 )))\n  local closest\n\n  local current=$(( $number ))\n\
    \  local closest2=$(( $(( $number | gawk '{ print $1 }') + 1 )))\n  local closest3=$((\
    \ $(( $number | gawk '{ print $1 }') - 1 )))\n  local diff\n\n  for (( i = 0;\
    \ i < $max; i++ )); do\n    diff=$(( $current - $closest2 ))\n    if (( $diff\
    \ < 0 )); then\n      closest2=$(( $closest2 + 1 ))\n    else\n      closest2=$((\
    \ $closest2 - 1 ))\n    fi\n    diff=$(( $current - $closest3 ))\n    if (( $diff\
    \ < 0 )); then\n      closest3=$(( $closest3 - 1 ))\n    else\n      closest3=$((\
    \ $closest3 + 1 ))\n    fi\n    diff=$(( $current - $closest ))\n    if (( $diff\
    \ < 0 )); then\n      closest=$(( $closest - 1 ))\n    else\n      closest=$((\
    \ $closest + 1 ))\n    fi\n  done\n  echo $(( $closest2 | gawk '{ print $1 }'\
    \ ))", "    local number=$1\n    local numbers=$(echo \"$number\" | tr \",\" \"\
    \ \")\n    local min=$(( ${numbers//,/ - } ))\n    local max=$(( ${numbers//,/\
    \ - } ))\n    if [[ $max -ge $min ]]; then\n        local max=$(( ${max} + 1 ))\n\
    \        local min=$(( ${min} - 1 ))\n    fi\n    echo $(echo \"${number}\" |\
    \ awk -F. -v max=$max -v min=$min 'BEGIN { print \"'\"$min\"'\" } $1 == $2 { print\
    \ $3 } END { print \"'\"$max\"'\" }')", "        local -r input=\"${1}\"\n   \
    \     if [[ -z \"$input\" ]] || [[ \"$input\" = *\"-\"* ]] ; then\n          \
    \      echo \"$1\" >&2\n                return 1\n        fi\n        local digits=$(echo\
    \ \"$input\" | sed -e 's/^\\(.\\).*$/\\1/')\n        local last=${digits:(-1)}\n\
    \        local diff\n        local lastdiff\n        local cur\n        local\
    \ num\n        local ret\n        for (( cur = 0; cur <= 9; cur++ )); do\n   \
    \             num=${digits:$((cur))}\n                if (( \"$num\" < \"$last\"\
    \ )) ; then\n                        last=$num\n                        diff=$((\
    \ last - last % 10 ))\n                        lastdiff=$(( last - last % 10 ))\n\
    \                else\n                        diff=$(( 10 - last % 10 ))\n  \
    \                      lastdiff=$(( 10 - last % 10 ))\n                      \
    \  last=$num\n                fi\n                if (( \"$diff\" = \"0\" )) ;\
    \ then\n                        if (( \"$lastdiff\" != \"0\" )) ; then\n     \
    \                           diff=$(( lastdiff % 10 ))\n                      \
    \  fi\n                        ret=$(( 10 + last + diff ))\n                 \
    \       echo \"$ret\"\n                        break\n                fi\n   \
    \     done", "  local val=\"$1\"\n  (( $# > 0 )); # ensure arguments are given\
    \ to this function\n  local prev=\"$(closest_integer $2)\"\n  local diff=${#val}\n\
    \  local maxdiff\n  local cur\n  local nums\n\n  if [ -z \"$prev\" ]; then\n \
    \   prev=0\n  fi\n\n  case \"$val\" in\n    [0-9.]*)\n      nums=\"$(echo $val\
    \ |sed 's/\\./\\\\\\./g')\"\n      break\n  esac\n  prev=${prev%.*}\n  if [[ \"\
    $diff\" -gt \"$maxdiff\" ]]; then\n    maxdiff=$diff\n  fi\n  (( diff-- ))\n \
    \ for (( cur=1; cur<=${#nums}; cur++ )); do\n    diff =$(echo \"$prev*($((cur-1)/${#nums}))\"\
    \ |bc)\n    if [ \"$diff\" -gt \"$maxdiff\" ]; then\n      maxdiff=$diff\n   \
    \ fi\n    (( prev=\"$cur\" ))\n  done\n  (( maxdiff-- ))\n  if [[ \"$maxdiff\"\
    \ -eq 0 ]]; then\n    echo \"0\"\n  else\n    echo \"$prev\"\n  fi", "  local\
    \ num=\"${1}\"\n  [[ \"${num}\" =~ ^[+-]?[0-9]+$ ]] || return 0\n  local -n num=${num}\n\
    \  local num2=$(( (${num} / 2) + 0.5 ))\n  local num3=$(( (${num2} / 2) + 0.5\
    \ ))\n  [[ ${num} -eq ${num2} ]] || return 0\n  [[ ${num} -eq ${num3} ]] || return\
    \ 0\n  echo \"${num}\"", "  val=$(echo $1 | awk '{print $1}')\n  prevval=$(echo\
    \ $1 | awk '{print $2}')\n\n  integer=$(echo \"$val\" | cut -d \".\" -f 1)\n \
    \ diff=$(echo \"$prevval - $integer\" | bc)\n  if [[ $diff -eq 0 ]]; then\n  \
    \  echo $integer\n  else\n    echo $(($integer + $diff))\n  fi", "    local number=\"\
    $1\"\n    local difference=\n\n    # See if the number is already an integer.\n\
    \    if [[ \"$number\" =~ ^-?[0-9]+$ ]]; then\n        echo \"$number\"\n    \
    \    return\n    fi\n\n    # See if the number is close to zero, and if so, return\
    \ 0.\n    if [ \"$number\" == \"0\" ]; then\n        echo \"0\"\n        return\n\
    \    fi\n\n    # Get the difference between the current number and the next \n\
    \    # number in the sequence.\n    if [ \"$number\" == \"$next\" ];then\n   \
    \     difference=0\n    else\n        difference=\"$(( number - next ))\"\n  \
    \  fi\n\n    # Round the difference away from zero, if it exists.\n    if [ \"\
    $difference\" -lt \"0.5\" ]; then\n        difference=\"0$difference\"\n    fi\n\
    \n    # Convert the difference to an integer.\n    difference=\"$(echo -e \"${difference}\"\
    \ | bc)\"\n\n    # See if the difference is equidistant from two numbers. \n \
    \   if [ \"$difference\" -gt \"0\" ]; then\n        # Yes, return the number that\
    \ is closer to zero.\n        echo \"$next\"\n        return\n    fi\n\n    #\
    \ No, so return the number that is furthest from zero.\n    echo \"$number\"",
  "  # We accept any numeric string\n  local string=$1\n  # Convert to an array that\
    \ we can modify\n  local arr=(${string//,/ })\n  # Initialize the minimum difference\n\
    \  local mindiff=${arr[1]}\n  # Initialize the current difference\n  local diff=${arr[1]}\n\
    \  # Initialize the minimum difference\n  local mindiff=${arr[1]}\n  # Now loop\
    \ over the array\n  for index in ${!arr[@]}; do\n    # Update our current difference\n\
    \    diff=$((${arr[$index]} - ${arr[index]}))\n    # See if we should update\n\
    \    if [[ \"${diff}\" -lt \"${mindiff}\" ]]; then\n      # Update the minimum\
    \ difference\n      mindiff=${diff}\n      # Update the minimum difference index\n\
    \      mindiffindex=\"${index}\"\n    fi\n  done\n  # If we found a min difference\n\
    \  if [[ \"${mindiff}\" -eq 0 ]]; then\n    # Return current value\n    echo \"\
    ${arr[@]}\"\n  else\n    # Return closest value\n    echo \"${arr[@]:0:${mindiffindex}}\"\
    \n  fi", "  local value=$1\n\n  (( ${value//[^0-9]/} < 0 )) || return 0\n  # Remove\
    \ everything but digits (no decimal point) and add one to\n  # avoid negative\
    \ numbers\n  local n=$((${value//[^0-9]/}+1))\n  (( ${n} < $1 )) && return 0\n\
    \  (( ${n} > $1 )) && return 0\n  (( ${n} == $1 )) && return 0\n  (( ${n} == ${value//[0-9]/}\
    \ )) && return 0\n\n  local factors=$(echo \"$1/10\" | bc)\n  (( ${factors} >\
    \ ${value//[0-9]/} )) && return 0\n  (( ${factors} < ${value//[0-9]/} )) && return\
    \ 1\n  (( ${factors} == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo\
    \ \"$1/100\" | bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors}\
    \ < ${value//[0-9]/} )) && return 1\n  (( ${factors} == ${value//[0-9]/} )) &&\
    \ return 0\n\n  local factors=$(echo \"$1/1000\" | bc)\n  (( ${factors} > ${value//[0-9]/}\
    \ )) && return 0\n  (( ${factors} < ${value//[0-9]/} )) && return 1\n  (( ${factors}\
    \ == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo \"$1/10000\" |\
    \ bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors} < ${value//[0-9]/}\
    \ )) && return 1\n  (( ${factors} == ${value//[0-9]/} )) && return 0\n\n  local\
    \ factors=$(echo \"$1/100000\" | bc)\n  (( ${factors} > ${value//[0-9]/} )) &&\
    \ return 0\n  (( ${factors} < ${value//[0-9]/} )) && return 1\n  (( ${factors}\
    \ == ${value//[0-9]/} )) && return 0\n\n  local factors=$(echo \"$1/1000000\"\
    \ | bc)\n  (( ${factors} > ${value//[0-9]/} )) && return 0\n  (( ${factors} <\
    \ ${value//[0-9]/} )) && return 1\n  (( ${factors} == ${value//[0-9]/", "  local\
    \ integer=$1\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer\
    \ / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer /\
    \ 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10\
    \ ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n\
    \  integer +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer\
    \ +=$(( 10#$integer / 10 ))\n  integer +=$(( 10#$integer / 10 ))\n  integer +=$((\
    \ 10#$integer / 10 ))", "  local _number=\"$1\"\n  local _equidistant=\"false\"\
    \n  local _last=\"\"\n  local _dist=\"\"\n  local _out=\"\"\n\n  [[ \"$_number\"\
    \ =~ ^-?[0-9][0-9]*\\.[0-9]+$ ]] || _equidistant=\"true\"\n  local _number=\"\
    ${_number%.*}\"\n  [[ \"$_number\" =~ ^-?[0-9][0-9]*\\.[0-9]+$ ]] || _equidistant=\"\
    true\"\n  local _number=\"${_number%.*}\"\n\n  [[ \"$_number\" =~ ^-?[0-9]+$ ]]\
    \ || _equidistant=\"true\"\n  local _number=\"${_number%.*}\"\n  [[ \"$_number\"\
    \ =~ ^-?[0-9]+$ ]] || _equidistant=\"true\"\n\n  # Check to see if there is a\
    \ number greater than the given value\n  if [[ -n \"$_number\" && \"$_number\"\
    \ -gt 0 ]]; then\n    _last=\"$_number\"\n    if [[ $_equidistant == \"true\"\
    \ ]]; then\n      _dist=\"1\"\n    else\n      _dist=\"0\"\n    fi\n  fi\n\n \
    \ # Check to see if there is a number less than the given value\n  if [[ -n \"\
    $_number\" && \"$_number\" -lt 0 ]]; then\n    _last=\"$_number\"\n    if [[ $_equidistant\
    \ == \"true\" ]]; then\n      _dist=\"1\"\n    else\n      _dist=\"0\"\n    fi\n\
    \  fi\n\n  # Check to see if there is a number equal to the given value\n  if\
    \ [[ -n \"$_number\" && \"$_number\" == \"$(_number)\" ]]; then\n    _last=\"\
    $_number\"\n    if [[ $_equidistant == \"true\" ]]; then\n      _dist=\"1\"\n\
    \    else\n      _dist=\"0\"\n    fi\n  fi\n\n  # Check to see if there is a number\
    \ greater than or equal to the given value\n  if [[ -n \"$_number\" && \"$_number\"\
    \ -ge \"$(_number)\" ]]; then\n    _last=\"$_number\"\n    if [[ $_equidistant\
    \ == \"true\" ]]; then\n      _dist=\"1\"\n    else\n      _dist=\"0\"\n    fi\n\
    \  fi\n\n  # Check to see if there is a number less than or equal to the given\
    \ value\n  if [[ -n \"$_number\" && \"$_number\" -le \"$(_number)\" ]]; then\n\
    \    _last=\"$_number\"\n    if [[ $_equidistant == \"true\" ]]; then\n      _dist=\"\
    1\"\n    else\n      _dist=\"0\"\n    fi\n  fi\n\n  # Check to see if there is\
    \ a number equal to or greater than the ", "  local string=${1}\n\n  # The variable\
    \ $string will now contain one or more numbers that\n  # are equidistant from\
    \ each other.\n  local numbers=$(echo ${string} | sed 's/[^0-9.]//g')\n  # The\
    \ variable numbers now contains only numbers that are\n  # equidistant from each\
    \ other.\n\n  # The variable $numbers now contains only numbers.\n  # If there\
    \ are no numbers in $numbers, the variable will contain a\n  # single number that\
    \ is the sum of all digits in $string. For\n  # example, if $numbers is \"14.5\"\
    \ then $numbers contains 14 as a\n  # number because 14.5 is equidistant from\
    \ 14 as well as 15.\n  if [[ ${numbers} =~ [0-9] ]]; then\n    local number=${numbers}\n\
    \  else\n    local number=0\n    local sum=0\n    for n in ${numbers}; do\n  \
    \    ((sum+=n))\n    done\n    local number=$(echo ${sum})\n  fi\n\n  local closest=$(echo\
    \ $string | sed \"s/${number}//g\")\n\n  local rounded_closest=$(( closest + $((\
    \ $(( closest % 1 )) - 1 )) ))\n\n  echo $rounded_closest", "  local number=$1\n\
    \  local min\n  local max\n  local number1\n  local number2\n  local returnnumber\n\
    \  local diff\n  local difference\n\n  # Strip any leading zeros from number\n\
    \  number=${number%.*}\n\n  # If the number is empty\n  if [ ${#number} -eq 0\
    \ ]; then\n    return 0\n  fi\n\n  # Get max and min\n  max=${number}\n  min=${number}\n\
    \n  # Set min/max to zero\n  min=0\n  max=0\n\n  # Get min and max from number\n\
    \  for number in ${number//.}; do\n    ((min+=number))\n    ((max-=number))\n\
    \  done\n\n  # If min == max then return number\n  if ((min == max)); then\n \
    \   return 0\n  fi\n\n  # Get the first number\n  number1=${number}\n\n  # Get\
    \ the second number\n  number2=${number}\n\n  # Get difference between them\n\
    \  diff=$((number2-number1))\n\n  # If diff is bigger than 0, add one\n  if ((\
    \ diff > 0 )); then\n    diff=$((diff + 1))\n  fi\n\n  # Return difference with\
    \ closest integer\n  returnnumber=$((min + diff))\n\n  # Return number with closest\
    \ integer\n  echo \"$returnnumber\"", "    local string=${1}\n    local integer=${string}\n\
    \    if [[ \"${integer}\" =~ ^-?[0-9]+$ ]]; then\n        integer=\"${integer}.0\"\
    \n    fi\n    local digits=$(echo \"${integer}\" | sed -e 's/^\\(-?[0-9]+\\)$/.\\\
    1/')\n    local remainder=${integer%%${digits}}\n    local quotient=$(echo \"\
    ${integer}/${digits}\")\n    local quotient2=0\n    while [[ \"${quotient}\" -gt\
    \ \"${quotient2}\" ]]; do\n        quotient2=$(( ${quotient} + 2 ))\n    done\n\
    \    if [[ $quotient != ${quotient2} ]]; then\n        quotient=\"${quotient2}\"\
    \n    fi\n    echo ${quotient}", "  # The first argument should be a string\n\
    \  local STRING=$1\n  local NUMBERS=(${STRING//[^0-9\\.]/})\n\n  # Remove non-numeric\
    \ characters\n  local STRING_FULL=$(echo \"${STRING}\" | tr -cd '[:digit:]')\n\
    \  local NUMBER_START=${STRING_FULL#${STRING_FULL%%[^0-9]}*}\n  local NUMBER_END=${STRING_FULL%${STRING_FULL%%[^0-9]}*}\n\
    \  local NUMBERS_START=(${NUMBER_START//[^0-9\\.]/})\n  local NUMBERS_END=(${NUMBER_END//[^0-9\\\
    .]/})\n\n  # Convert start and end numbers to integers\n  local NUMBER_START=$((${NUMBER_START}+0))\n\
    \  local NUMBER_END=$((${NUMBER_END}+0))\n\n  # Get the difference between the\
    \ start and end numbers\n  local DIFF_START=$((${NUMBER_START}-${NUMBERS_START}))\n\
    \  local DIFF_END=$((${NUMBER_END}-${NUMBERS_END}))\n\n  # Return the difference\
    \ if it is smaller than the difference\n  # between the two closest integers,\
    \ and return the closest integer\n  # otherwise.\n  if [[ ${DIFF_START} -le ${DIFF_END}\
    \ ]]; then\n    echo ${NUMBER_START}\n  else\n    echo ${NUMBER_END}\n  fi", " \
    \   local string=\"$1\"\n    local min=\"$(echo \"${string}\" | cut -d \".\" -f1)\"\
    \n    local max=\"$(echo \"${string}\" | cut -d \".\" -f2)\"\n    local num\n\
    \    if [ \"${min}\" == \"${max}\" ] ; then\n        num=\"${min}\"\n    else\n\
    \        if [ \"${min}\" -le \"${max}\" ] ; then\n            num=\"$min\"\n \
    \       else\n            local difference\n            difference=\"$(( $(echo\
    \ \"${min} - ${max}\" | bc -l) / 2 ))\"\n            num=\"$(( ${max} - ${difference}\
    \ + ${min} ))\"\n        fi\n    fi\n    echo $num", "  # Parse the argument\n\
    \  local number=$1\n  # Get the current timestamp\n  local timestamp=$(date +%s)\n\
    \  # Split the number at the period\n  local first=${number%.*}\n  local second=${number#*.}\n\
    \  # Get the integer part of the first number\n  local integer=${first##*.}\n\
    \  # Get an integer comparison for the first number\n  local comp=(( ${first}\
    \ == ${first}+0 ))\n  # If the first number has a period\n  if [[ \"$integer\"\
    \ == \"0\" ]]; then\n    # Return it as-is if the second number is also 0\n  \
    \  if [[ \"$second\" == \"0\" ]]; then\n      echo $first\n    else\n      # Get\
    \ the difference between the two numbers\n      local diff=$(( ${second} - ${first}\
    \ ))\n      # If the second number is positive and the first is negative,\n  \
    \    # return the first number as the difference\n      if (( comp )) && [[ $diff\
    \ -gt 0 ]]; then\n        echo $first\n      else\n        # Otherwise, return\
    \ the first number and the second number\n        echo $first\n        echo $second\n\
    \      fi\n    fi\n  # If the first number does not have a period\n  else\n  \
    \  # Get the difference between the two numbers\n    local diff=$(( ${second}\
    \ - ${first} ))\n    # If the second number is negative, and the first is positive,\n\
    \    # return the second number as the difference\n    if (( comp )) && [[ $diff\
    \ -gt 0 ]]; then\n      echo $second\n    # If the second number is positive and\
    \ the first is negative,\n    # return the first number as the difference\n  \
    \  elif (( comp )) && [[ $diff -lt 0 ]]; then\n      echo $first\n    # Otherwise,\
    \ return the first number and the second number\n    else\n      echo $first\n\
    \      echo $second\n    fi\n  fi", "  local value\n  local round\n\n  # Get the\
    \ value passed in as the first argument, split it at any points\n  # of whitespace\
    \ and strip it of leading and trailing whitespace.\n  value=\"$1\" | tr -s ' '\
    \ | awk '{print $1}'\n\n  # Convert value to an integer\n  value=$(( \"$value\"\
    \ ))\n\n  # See if the value is equidistant from two integers\n  round=$(closest_integer\
    \ \"$value\")\n  if [ -z \"$round\" ]; then\n    echo \"$value\"\n  else\n   \
    \ echo -n \"$value\"\n  fi", "  local n=\"$1\"\n  local i=\"$(( ${n} + 1 ))\"\n\
    \  while (( ${i} > 0 )); do\n    if (( ${n} > ${i} )); then\n      n=\"${i}\"\n\
    \    fi\n    (( i-- ))\n  done\n  echo \"$n\"", "  local num=\"${1}\"\n  local\
    \ num2=\"$1\"\n  local zero=\"$((num - num2))\"\n  local distance=\"$((num2 -\
    \ num))\"\n  local rounding_distance=\"$((distance - 1))\"\n  local closest_int=\"\
    $((zero + rounding_distance))\"\n  if [[ \"$closest_int\" == \"$zero\" ]]\n  then\n\
    \    echo $closest_int\n  else\n    echo $closest_int\n  fi", "    local value=$1\n\
    \    local integer\n    local sign=1\n    local difference\n    local maxdiff\n\
    \    local roundto\n    # If the number is less than zero, set it to zero and\
    \ increment the\n    # sign.\n    if [[ $value -lt 0 ]]; then\n        sign=0\n\
    \        value=$(( 0 - value ))\n    fi\n    # Iterate over the integer values,\
    \ round them and compare them.\n    for integer in $(seq 1 $(( 10#$value )) );\
    \ do\n        # Round the value to the closest integer.\n        value=$(( 10#$value\
    \ + $sign*((10#$integer-1) % 10) ))\n        # Calculate the difference between\
    \ the given number and the\n        # rounded number.\n        difference=$((\
    \ 10#$value - $integer ))\n        # If the difference is greater than or equal\
    \ to zero and the\n        # current number is also less than the rounded number,\
    \ the number\n        # should be returned.\n        if [[ $difference -ge 0 ]]\
    \ && [[ $value -lt $integer ]]; then\n            break\n        fi\n        #\
    \ If there are still more numbers to check, then the number should\n        #\
    \ be returned if the difference is greater than or equal to\n        # maxdiff,\
    \ since that means that the difference between this and\n        # the previous\
    \ number is greater than zero.\n        if [[ $difference -gt $maxdiff ]]; then\n\
    \            maxdiff=$difference\n            roundto=$integer\n        fi\n \
    \   done\n    # Return the rounded number.\n    echo \"$value\"", "  local number=\"\
    ${1}\"\n  local distance\n\n  # Make sure that number is numeric\n  if ! [[ $number\
    \ =~ ^-?[0-9]+$ ]]; then\n    echo \"Invalid input. String must be numeric.\"\
    \ >&2\n    exit 1\n  fi\n\n  # Calculate distance between the two numbers\n  if\
    \ [ \"$number\" == \"0\" ]; then\n    distance=\"1\"\n  elif [ \"$number\" ==\
    \ \"1\" ]; then\n    distance=\"0\"\n  else\n    distance=$(echo \"$number\" |\
    \ bc)\n  fi\n\n  # If distance is negative, round away from zero.\n  # If distance\
    \ is zero, rounding away from zero is meaningless\n  if [ \"$distance\" == \"\
    -$distance\" ]; then\n    echo \"0\"\n  elif [ \"$distance\" == \"$distance\"\
    \ ]; then\n    echo \"$number\"\n  else\n    echo \"$(( $number + $distance ))\"\
    \n  fi", "  local number=\"$1\"\n  local first=$(echo \"$number\" | awk '{print\
    \ $1}')\n  local second=$(echo \"$number\" | awk '{print $2}')\n  local diff=$((\
    \ ($second-$first) + abs($second-$first) ))\n  echo $(( diff < 0 ? $first : $second\
    \ ))", "\tlocal number=$1\n\t# Make sure we're dealing with a number, not a string\n\
    \t[[ $number =~ ^[0-9]+$ ]] || return 1\n\tlocal original=$number\n\t# Make sure\
    \ the original is non-negative\n\t[[ $number =~ ^-[0-9]+$ ]] || return 1\n\t#\
    \ Make sure we're dealing with integers\n\t[[ $number =~ ^[0-9]+\\.[0-9]+$ ]]\
    \ || return 1\n\t# Make sure the original is positive (a floating-point number\
    \ may be\n\t# considered positive)\n\t[[ $number =~ ^[0-9]+\\.[0-9]+$ ]] || return\
    \ 1\n\tlocal difference\n\tlocal round\n\tlocal rounded_number\n\tlocal rounded_difference\n\
    \tlocal rounded_round\n\n\tdifference=$(($number - $original))\n\t# This check\
    \ is probably useless since we already checked that the\n\t# original is non-negative,\
    \ but it does ensure that the difference is\n\t# not negative.\n\t[[ $difference\
    \ =~ ^-[0-9]+$ ]] || return 1\n\t# Round away from zero by adding 0.5\n\tdifference=$(($difference\
    \ + 0.5))\n\t# Round the difference down to an integer\n\tround=$((${difference%%.*}))\n\
    \t# Round the original down to an integer\n\trounded_number=$(($original - $round))\n\
    \n\t# If the difference was 0, return the original number\n\tif [[ ${difference}\
    \ == 0 ]]; then\n\t\treturn 0\n\telse\n\t\t# If the difference was negative, return\
    \ the original number\n\t\tif [[ ${difference} < 0 ]]; then\n\t\t\treturn 0\n\t\
    \t# If the difference was positive, round to integer and return\n\t\telse\n\t\t\
    \treturn $rounded_number\n\t\tfi\n\tfi", "  # Make sure the input is indeed a\
    \ string\n  typeset -i number=\"$1\"\n  # Make sure the first character is a number\n\
    \  [[ \"$number\" =~ ^[0-9]+$ ]]\n  # Remove all non numeric characters\n  number=\"\
    ${number//[^0-9]/}\"\n  # If there are no digits in the string, return it\n  [[\
    \ ${#number} -eq 0 ]]\n  # If there is one digit, return it\n  [[ ${#number} -eq\
    \ 1 ]]\n  # If the number is positive, add 1 to it\n  # If the number is negative,\
    \ subtract 1 from it\n  case \"${number}\" in\n    \"1\" | \"+1\")\n      number=$(($number\
    \ + 1))\n      ;;\n    \"-1\" | \"-1\")\n      number=$(($number - 1))\n     \
    \ ;;\n    *)\n      number=$(($number - 1))\n      ;;\n  esac\n  # Make sure the\
    \ number is greater than 0\n  [[ -z $number ]] && number=\"0\"\n  # Return the\
    \ result\n  echo \"$number\"", "    local STRING=\"$1\"\n    local NUM=\"${STRING%%[!0-9]*}\"\
    \n    local MOD=\"${NUM%%[^!0-9]*}\"\n    if [[ -z \"$MOD\" ]]; then\n       \
    \ local MOD=\"$NUM\"\n    fi\n    local MODNUM=\"$(echo -e \"${MOD}\" | tr -cd\
    \ '[:digit:]')\"\n    local MODMODNUM=\"$(echo -e \"${MODNUM}\" | tr -cd '[:digit:]')\"\
    \n    local MODMODMODNUM=\"$(echo -e \"${MODMODNUM}\" | tr -cd '[:digit:]')\"\n\
    \    local RESULT=\"$(echo -e \"${NUM}\" | tr -cd '[:digit:]')\"\n    if [[ \"\
    $RESULT\" -ge \"$MODMODNUM\" ]]; then\n        local NEWRESULT=\"$RESULT\"\n \
    \   else\n        if [[ \"$RESULT\" -ge \"$MODNUM\" ]]; then\n            local\
    \ NEWRESULT=\"$MODMODNUM\"\n        else\n            if [[ \"$RESULT\" -ge \"\
    $MODMODNUM\" ]]; then\n                local NEWRESULT=\"$MODMODMODNUM\"\n   \
    \         else\n                if [[ \"$RESULT\" -ge \"$MODNUM\" ]]; then\n \
    \                   local NEWRESULT=\"$MODMODNUM\"\n                else\n   \
    \                 local NEWRESULT=\"$MODMODMODNUM\"\n                fi\n    \
    \        fi\n        fi\n    fi\n    echo \"$NEWRESULT\"", "  local string=${1}\n\
    \n  # If there are no integers, return empty string\n  if [ -z \"$string\" ];\
    \ then\n    return \"\"\n  fi\n\n  # Split string by decimal point\n  local integers=$(echo\
    \ $string | sed 's/[^0-9\\.]//g')\n\n  # If there is only one integer, return\
    \ it\n  if [ ! -z \"$integers\" ]; then\n    return $integers\n  fi\n\n  # If\
    \ there are two or more integers, get closest to 0\n  if [ $((${#integers} % 2))\
    \ -eq 0 ]; then\n    local result=0\n    local base=${#integers}\n    local digits=${#integers}\n\
    \    local digit\n    local difference\n\n    # Find two closest integer to each\
    \ other\n    for (( digit=0; digit < digits-1; digit++ )); do\n      if [ $((${integers%.}${digit}))\
    \ = $((${integers%.}${digit+1})) ]; then\n        local tmp=$((${integers%.}${digit+1}))\n\
    \        local distance=$(closest_integer \"0.$tmp\")\n\n        if [ -z \"$distance\"\
    \ ]; then\n          distance=$(closest_integer \"0.$tmp\")\n        fi\n\n  \
    \      difference=$(( ${digit}-distance ))\n        break\n      fi\n    done\n\
    \n    # If difference is negative, result is lower\n    if [ -n \"$difference\"\
    \ ]; then\n      result=$(( $difference*${base}+$base+${digits-1}))\n    else\n\
    \      result=$(( $digits+1 ))\n    fi\n    return $result\n  fi\n\n  # If there\
    \ is only two integers, return it\n  if [ $((${#integers} % 2)) -eq 0 ]; then\n\
    \    return $((${integers} % 2))\n  fi\n\n  # If there are three or more integers,\
    \ return nearest to zero\n  if [ $((${#integers} % 3)) -eq 0 ]; then\n    local\
    \ result=0\n    local base=${#integers}\n    local digits=${#integers}\n    local\
    \ digit\n    local difference\n    local tmp1\n    local tmp2\n\n    # Find two\
    \ closest integers to each other\n    for (( digit=0; digit < digits-1; digit++\
    \ )); do\n      tmp1=$((${integers%.}${digit}))\n      tmp2=$((${integers%.}${digit+1}))\n\
    \      if [ $((${integers%.}${digit})) = $((${integers%.}${digit+1})) ]; then\n\
    \        difference=$(( $digit-$((${digit", "    local value=$1\n    local sign=\n\
    \    # Find the sign of the number\n    if [ $value == \"-\" ];then\n        sign=\n\
    \    else\n        sign=\n    fi\n\n    local number=\"$(echo \"${value}\" | bc)\"\
    \n    local closest\n    local closestCount\n    local nextNumber\n    local nextNumberCount\n\
    \n    if [ \"${number}\" == \"0\" ];then\n        closest=\"0\"\n    elif [ \"\
    ${number}\" == \"1\" ];then\n        closest=\"1\"\n    elif [ \"${number}\" ==\
    \ \"9\" ];then\n        closest=\"9\"\n    else\n        closest=\"$(echo \"${sign}${number}\"\
    \ | bc | cut -d '.' -f 1)\"\n    fi\n\n    local i=2\n    local closestCount=0\n\
    \    while [ \"${closest}\" == \"${i}\" ];do\n        local nextNumber=\"$(echo\
    \ \"${sign}${i}\" | bc)\"\n        local nextNumberCount=0\n        if [ \"${nextNumber}\"\
    \ == \"0\" ];then\n            nextNumberCount=0\n        elif [ \"${nextNumber}\"\
    \ == \"1\" ];then\n            nextNumberCount=1\n        elif [ \"${nextNumber}\"\
    \ == \"9\" ];then\n            nextNumberCount=9\n        else\n            nextNumberCount=$(echo\
    \ \"${nextNumber}\" | bc | cut -d '.' -f 1)\n        fi\n\n        if [ \"$nextNumberCount\"\
    \ -gt \"$closestCount\" ];then\n            closest=\"$nextNumber\"\n        \
    \    closestCount=$nextNumberCount\n        fi\n\n        i=$((i+1))\n    done\n\
    \n    echo \"${closest}\"", "  local STRING=$1\n\n  # Strip trailing period\n\
    \  local STRIPPED=${STRING%.}\n  local N=${STRIPPED##*\\.}\n  if (( $N == 0 ));\
    \ then\n    N=$(( $STRING == 0 ? 10 : 10 ))\n  fi\n\n  # Strip leading zeroes\n\
    \  local ZEROED=$(echo $STRIPPED | sed -e 's/^0\\([0-9]*\\)/\\1/')\n  local INT_TO_TEST=$((\
    \ $ZEROED ))\n\n  # This for loop checks every other integer before returning\
    \ the\n  # integer that is closest to the provided one. For example\n  # closest_integer(\"\
    14.5\") returns 14 and closest_integer(\"-14.5\")\n  # returns -14\n  for (( NI\
    \ = 1; NI <= 10; NI++ )); do\n    local INT=$(( $INT_TO_TEST + $NI ))\n    # If\
    \ the integer is equidistant from two integers, return the \n    # one that is\
    \ farthest from zero.\n    if (( $INT < 0 )); then\n      if (( $NI == 0 )); then\n\
    \        INT=$N\n      fi\n    else\n      if (( $NI > 0 )); then\n        INT=$N\n\
    \        break\n      fi\n    fi\n  done\n\n  # Convert to string\n  echo $INT",
  "  local IFS='.' read -r -a array <<<\"$1\"\n  local cutoff=\"$2\"\n  local diff\
    \ max\n  diff=\"${array[0]}${array[1]}\"\n  max=\"${array[1]}\"\n  for i in \"\
    ${array[@]:2}\"; do\n    (( diff += i ))\n    if (( diff > cutoff )); then\n \
    \     diff=$(( diff - cutoff ))\n      max=\"$i\"\n    fi\n  done\n  echo \"$max\"",
  "    local number=\"$1\"\n    local result=\"$1\"\n    local last=\"$1\"\n    local\
    \ diff\n    while [ $last = \"$1\" ]; do\n        diff=\"$(echo \"$number - $result\"\
    \ | bc)\"\n        if [[ $diff -lt 0 ]]; then\n            result=\"$result\"\n\
    \        elif [[ $diff -gt 0 ]]; then\n            result=\"$result\"\n      \
    \      ((result++))\n        fi\n        last=\"$result\"\n        ((result++))\n\
    \    done\n    echo \"$result\"", "  local NUM=\"$1\"\n  local MIN=\"$2\"\n  local\
    \ MAX=\"$3\"\n  local CLOSEST=\"$(echo \"${NUM}\" | awk -F. -v min=\"${MIN}\"\
    \ -v max=\"${MAX}\" 'BEGIN { \n    # Find difference between the numbers\n   \
    \ dif = ( max - min )\n    # Handle \"equal\" numbers\n    if ( dif == 0 ) return\
    \ max\n    # Find the nearest integer\n    for( i = 1; i <= diff; i++ ) if ( dif\
    \ / i == i ) { \n      n = ( dif / i ) * i\n      break\n    } \n    # Handle\
    \ \"farthest\" numbers\n    if ( i == diff ) return -max\n    # Find the closest\
    \ integer\n    for( i = diff; i <= 1; i-- ) if ( dif / i == i ) {\n      n = (\
    \ dif / i ) * i\n      break\n    }\n  }')\"\n  echo \"${CLOSEST}\"", "    local\
    \ STRING=$1\n    if [[ \"$STRING\" =~ ^[0-9]*$ ]]; then\n        local NUM=$((\
    \ $(echo \"$STRING\" | cut -d \".\" -f1) ))\n        local NUM2=$(( $(echo \"\
    $STRING\" | cut -d \".\" -f2) ))\n        local DIFF=$(( ${NUM}-${NUM2} ))\n \
    \       if (( ${DIFF} < 0 )); then\n            NUM2=$(( ${NUM} + ( ${DIFF} %\
    \ ${NUM2} )))\n        fi\n        echo $(( ${NUM2} + ${DIFF} / ${NUM} ))\n  \
    \  else\n        echo \"Error: input was not a number\"\n    fi", "  local string=$1\n\
    \  # Remove the leading sign, if any\n  local int_string=${string:${#string}-1}\n\
    \  # Check if there is any number at all before the decimal point\n  if [[ ${string:0:1}\
    \ = - ]]; then\n    echo \"ERROR: Number with leading '-' is not an integer.\"\
    \n    exit 1\n  fi\n  local last_char=${string:(-1)}\n  if [[ ${last_char} = .\
    \ ]]; then\n    echo \"ERROR: Number with trailing '.' is not an integer.\"\n\
    \    exit 1\n  fi\n  # Check there are no digits before the decimal point\n  if\
    \ [[ ${string:0:1} = - ]]; then\n    echo \"ERROR: Number with leading '-' is\
    \ not an integer.\"\n    exit 1\n  fi\n  # Check if there is any number at all\
    \ after the decimal point\n  if [[ ${string:(-1)} = . ]]; then\n    echo \"ERROR:\
    \ Number with trailing '.' is not an integer.\"\n    exit 1\n  fi\n  # Remove\
    \ the decimal point\n  local new_string=${string:0:-1}\n  # Convert it to a decimal\n\
    \  local int=\"${new_string}\"\n  local dec=\"${string:(-1)}\"\n  # If the number\
    \ is too large (greater than 9223372036854775807), then no integer\n  # is guaranteed\
    \ to exist, so return 0\n  if (( int > 9223372036854775807 )); then\n    local\
    \ ret=0\n  elif (( int < -9223372036854775808 )); then\n    local ret=0\n  else\n\
    \    local dec=${int}\n    local ret=$(echo $dec | bc)\n    if (( $ret == 0 ));\n\
    \    then\n      echo \"ERROR: Number '${new_string}' is not an integer and cannot\
    \ be converted to an integer.\"\n      exit 1\n    fi\n  fi\n  echo \"${ret}\"",
  "    local NUMBER=$1\n    local FARTHER=3\n    local NEXT=15\n    local MODULO=0\n\
    \    local RESULT=\"$NUMBER\"\n\n    while [ \"$NUMBER\" -gt \"$RESULT\" ] &&\
    \ [ \"$NUMBER\" -ne \"$NEXT\" ]; then\n        MODULO=$((NUMBER % $RESULT))\n\
    \        RESULT=$((NUMBER - MODULO))\n        NEXT=$((NEXT + MODULO))\n\n    \
    \    if [ \"$RESULT\" -eq \"$FARTHER\" ]; then\n            RESULT=\"$NUMBER\"\
    \n        fi\n        if [ \"$NUMBER\" -eq \"$FARTHER\" ]; then\n            RESULT=\"\
    $NEXT\"\n        fi\n    fi\n    echo \"$RESULT\"", "  local n=$1\n  local maxdiff=10\n\
    \  # check if n is an integer\n  local intcheck\n  if [[ $n =~ ^-?[0-9]+$ ]];\
    \ then\n    # check if the number is an integer, and less than 2^31-1\n    if\
    \ [[ $n =~ ^-?[0-9]+$ ]] && [[ $n -lt 2^31-1 ]]; then\n      # check if the number\
    \ is negative\n      local isneg\n      isneg=$(echo $n | awk '{exit ( $0 ~ /^\\\
    -/ )}')\n      if [[ $isneg ]]; then\n        n=$(($n - $maxdiff))\n      else\n\
    \        n=$(($n + $maxdiff))\n      fi\n      intcheck=1\n    else\n      echo\
    \ \"ERROR: Expected a positive number, but got $n\"\n      return 1\n    fi\n\
    \  else\n    echo \"ERROR: Expected a positive number, but got $n\"\n    return\
    \ 1\n  fi\n  local prevint=-1\n  local prevdiff=-1\n  local numdiff=-1\n  local\
    \ num=0\n  local numstr\n  while true; do\n    num=$(expr $n \\* 10 + 1)\n   \
    \ numstr=$(printf \"%04d\" $num)\n    if [ \"$numstr\" == \"$n\" ]; then\n   \
    \   break\n    fi\n    # check if the number is an integer, and less than 2^31-1\n\
    \    if [[ $numstr =~ ^-?[0-9]+$ ]] && [[ $numstr -lt 2^31-1 ]]; then\n      #\
    \ check if the number is negative\n      local isneg\n      isneg=$(echo $numstr\
    \ | awk '{exit ( $0 ~ /^\\-/ )}')\n      if [[ $isneg ]]; then\n        numstr=$(($numstr\
    \ - $maxdiff))\n      else\n        numstr=$(($numstr + $maxdiff))\n      fi\n\
    \      intcheck=1\n    else\n      echo \"ERROR: Expected a positive number, but\
    \ got $numstr\"\n      return 1\n    fi\n    if [ \"$prevint\" == \"$num\" ];\
    \ then\n      numdiff=$((numdiff + 1))\n    else\n      if [ \"$prevint\" == \"\
    $numdiff\" ]; then\n        prevdiff=$((prevdiff + 1))\n      else\n        prevdiff=1\n\
    \      fi\n      numdiff=1\n      numstr=$(printf \"%04d\" $num)\n      prevint=$num\n\
    \    fi\n    if [ $numdiff -gt $maxdiff ]; then\n      maxdiff=$numdiff\n    fi\n\
    \  done\n  echo $numstr", "        local value=\"${1}\"\n        local val=${value}\n\
    \        local diff=0\n        # Strip leading zeros, if any\n        value=${value#0}\n\
    \        value=${value%%.*}\n        val=${val#0}\n        val=${val%%.*}\n\n\
    \        while [ -n \"$value\" ]\n        do\n                val2=$(( val + diff\
    \ ))\n                val3=$(( val + diff ))\n                val4=$(( val + diff\
    \ ))\n\n                # Avoid negative values\n                if [ -n \"$val2\"\
    \ ] && [ \"$val2\" -gt \"$val\" ]\n                then\n                    \
    \    diff=$(( $val2 - val ))\n                        val=$val2\n            \
    \    elif [ -n \"$val3\" ] && [ \"$val3\" -gt \"$val\" ]\n                then\n\
    \                        diff=$(( $val3 - val ))\n                        val=$val3\n\
    \                elif [ -n \"$val4\" ] && [ \"$val4\" -gt \"$val\" ]\n       \
    \         then\n                        diff=$(( $val4 - val ))\n            \
    \            val=$val4\n                else\n                        diff=0\n\
    \                fi\n        done\n        echo \"$val\"", "  local str=$1\n \
    \ local num=$(echo $str |awk '{print $1; exit}')\n  local digits=$((10#${str%%%.*}))\n\
    \  local digits_count=$(echo $digits |wc -w)\n  local digits_sum=$(($digits *\
    \ $digits_count))\n  local digits_diff=$(($digits - $digits_sum))\n  local closest_integer=$(($((10#$digits_sum/$digits_count)*$digits_count))\
    \ \\\n                             -1 \\\n                             -$digits_diff)\n\
    \  if (( $closest_integer < 0 ))\n  then\n    closest_integer=$((10#$closest_integer))\n\
    \  fi\n  echo $closest_integer", "    local NUM=$1\n    local FIRST_INTEGER=0\n\
    \    local SECOND_INTEGER=0\n    local MID_VALUE=0\n\n    if [[ -z \"$NUM\" ]];\
    \ then\n        echo >&2 \"Usage: $(basename \"$0\") [number]\"\n        return\
    \ 1\n    fi\n\n    # Convert to decimal\n    local DEC=`echo \"$NUM\" | bc -l`\n\
    \    # Check for negative\n    if [[ \"$NUM\" < 0 ]]; then\n        DEC=$((-$DEC))\n\
    \    fi\n\n    local FIRST_INTEGER=0\n    local SECOND_INTEGER=0\n\n    # Loop\
    \ until we find a better match\n    while [[ \"$FIRST_INTEGER\" -lt \"$DEC\" ]]\
    \ || [[ \"$SECOND_INTEGER\" -lt \"$DEC\" ]]; do\n        FIRST_INTEGER=$(( $FIRST_INTEGER\
    \ + 1 ))\n        SECOND_INTEGER=$(( $SECOND_INTEGER + 1 ))\n\n        MID_VALUE=$((\
    \ $NUM - $DEC ))\n    fi\n\n    # Round the result away from zero\n    if [[ \"\
    $MID_VALUE\" -eq 0 ]]; then\n        local NEG_DEC=$(( 1 -$DEC ))\n        NEG_DEC=$((\
    \ $NEG_DEC + 1 ))\n        local NEG_NUM=$(( -$MID_VALUE ))\n\n        FIRST_INTEGER=$((\
    \ 0 ))\n        SECOND_INTEGER=$(( 1 ))\n\n        while [[ \"$FIRST_INTEGER\"\
    \ -lt \"$NEG_DEC\" ]] || [[ \"$SECOND_INTEGER\" -lt \"$NEG_DEC\" ]]; do\n    \
    \        FIRST_INTEGER=$(( $FIRST_INTEGER + 1 ))\n            SECOND_INTEGER=$((\
    \ $SECOND_INTEGER + 1 ))\n        done\n    fi\n\n    echo $(( $FIRST_INTEGER\
    \ ))", "  [[ \"$1\" =~ ^-?[0-9]+$ ]] || return 1\n  local d=0\n  local e=0\n \
    \ local x=$1\n  local y=1\n  while (( x > y )); do\n    x=y\n    y=d\n    d=$((d\
    \ + 1))\n    e=$((e + 1))\n  done\n  local final=$(( x - y))\n  [[ $d -gt $e ]]\
    \ && return $(( final - abs( final - x )))\n  return $(( final - abs( final -\
    \ y )))", "    local x=$1;\n    local max=$((${#x} + 1));\n    for ((i=1; i<=max;\
    \ i++)); do\n        [[ ${#x} -eq ${i} ]] && break;\n        local d=$(expr $x\
    \ - $i);\n        [[ ${d} -le 0 ]] && break;\n        local diff=$(expr $i + 1);\n\
    \        [[ ${#diff} -eq ${i} ]] && diff=0;\n        local d=$(expr $d - $diff);\n\
    \        local i=$(expr $i - 1);\n        [[ -z ${i} ]] && break;\n    done;\n\
    \    echo $i;", "    if [ ! -z \"$1\" ]; then\n        local x=\"$1\"\n      \
    \  # Check if the number is equidistant\n        local y\n        if [ \"$1\"\
    \ == \"$x\" ]; then\n            # If the number is equidistant, return it\n \
    \           return 0\n        else\n            # Get the two numbers and find\
    \ the closest integer\n            x=$($x | cut -d\\. -f1)\n            y=$($x\
    \ | cut -d\\. -f2)\n            if [ \"$y\" == \"$x\" ]; then\n              \
    \  # If the two numbers are equidistant, round them away from zero\n         \
    \       x=$($x | cut -d\\. -f1)\n                x=${x:-0}\n            fi\n \
    \       fi\n        # Return the number\n        return $x\n    fi", "  local\
    \ number=$1\n  if [ -z \"$number\" ]\n  then\n    return 0\n  fi\n  local closest_num=$((\
    \ $number + $number / 2 ))\n  local closest_integer=$(( $closest_num % $number\
    \ ))\n  local decimal=$(( $closest_num / $number ))\n  if [ -z $decimal ]\n  then\n\
    \    echo \"$closest_integer\"\n  else\n    echo \"$closest_integer $decimal\"\
    \n  fi", "  local number=$1\n\n  # make sure it is numeric\n  [[ \"$number\" =~\
    \ ^[0-9]+$ ]] || return 1\n\n  # make sure it isn't too small or too big\n  local\
    \ lowerBound=10\n  local upperBound=10e200\n\n  # get the lower and upper bounds\n\
    \  while [[ \"$number\" -lt \"$lowerBound\" || \"$number\" -gt \"$upperBound\"\
    \ ]]; do\n    (( lowerBound = $lowerBound + 1 ))\n    (( upperBound = $upperBound\
    \ - 1 ))\n  done\n\n  # now return the closest integer\n  local closestInt=\n\
    \  while [[ \"$number\" -eq \"$closestInt\" ]]; do\n    (( closestInt = ( $closestInt\
    \ + 1 )))\n  done\n\n  echo \"$closestInt\"", "  local number=$1\n  (( $# > 1\
    \ )) && echo \"Too many arguments\"\n  (( $# < 1 )) && echo \"Too few arguments\"\
    \n  local i=0 closest=$number prev_closest=$number\n  local closest2=$number prev_closest2=$number\n\
    \  (( $# == 1 )) && echo \"Too few arguments\"\n  local -n result=$( closest_integer\
    \ $2 )\n  result=$result\n  (( $result == 0 )) && return $result\n  while [ $i\
    \ -lt 10 ]; do\n    closest=$(($closest+$(($closest-$prev_closest))))\n    prev_closest=$closest\n\
    \    closest2=$(($closest2+$(($closest2-$prev_closest2))))\n    prev_closest2=$closest2\n\
    \    i=$((i+1))\n  done\n  (( $closest < $closest2 )) && return $closest\n  ((\
    \ $closest > $closest2 )) && return $closest2", "  local NUM=\"$1\"\n  local CLOSEST\n\
    \  CLOSEST=$NUM\n  local NUM2\n  NUM2=$(echo \"$NUM + 1\" | bc)\n  if [ \"$NUM\"\
    \ = \"$NUM2\" ]; then\n    CLOSEST=$NUM\n  else\n    local NUM3\n    NUM3=$(echo\
    \ \"$NUM - 1\" | bc)\n    if [ \"$NUM\" = \"$NUM3\" ]; then\n      CLOSEST=$NUM\n\
    \    fi\n  fi\n  echo \"$CLOSEST\"", "  # Convert $1 to a float\n  num=$(echo\
    \ \"$1\" | tr '[:upper:]' '[:lower:]')\n  num=$(echo \"$num\" | sed -e 's/^\\\
    ([0-9]*\\).*$/0\\1/')\n  num=$(echo \"$num\" | sed -e 's/^0*//')\n  num=$(echo\
    \ \"$num\" | sed -e 's/^\\([-+]*\\)\\([0-9]*\\).*/\\2\\1/')\n  num=$(echo \"$num\"\
    \ | sed -e 's/^0*//')\n  num=$(echo \"$num\" | sed -e 's/^-\\([0-9]*\\)\\([0-9]*\\\
    ).*/\\2\\1/')\n  num=$(echo \"$num\" | sed -e 's/^-*//')\n  num=$(echo \"$num\"\
    \ | sed -e 's/^-*//')\n\n  # Convert the number to a base 10 number\n  num=$(echo\
    \ \"$num\" | sed -e 's/^\\([0-9]*\\)\\([-+]*\\)\\([0-9]*\\)\\([-+]*\\)\\([0-9]*\\\
    ).*$/\\2\\/\\1\\/\\3/')\n\n  # Round the number up or down\n  num=$(echo \"$num\"\
    \ | sed -e 's/^\\([-+]*\\)\\([0-9]*\\)$/\\1\\/\\1/')\n  num=$(echo \"$num\" |\
    \ sed -e 's/^\\([0-9]*\\)$/\\1/')\n\n  # Convert the number to a base 10 number\n\
    \  num=$(echo \"$num\" | sed -e 's/^\\([-+]*\\)\\([0-9]*\\)\\([-+]*\\)\\([0-9]*\\\
    )$/\\1\\/\\3/')\n\n  # Return the number\n  echo \"$num\"", "  if [ -z \"$1\"\
    \ ]; then\n    echo\n  fi\n  local number=$1\n  local min=$(($((${number%.*}-0))));\n\
    \  local max=$(($((${number%.*}-0))));\n  if [ $number -gt $min ]; then\n    echo\
    \ \"$number\"\n  else\n    echo \"$max\"\n  fi", "  local number=\"$1\"\n  # Check\
    \ if number is either \"0\" or is empty\n  [[ \"$number\" =~ ^(0|)$ ]] || return\
    \ 1\n  # Check if the given number is a float\n  [[ \"$number\" =~ ^(-)?([0-9]*\\\
    .[0-9]+)$ ]] || return 1\n  # Split string into integer and decimal part\n  local\
    \ integer_part=$1\n  local decimal_part=$2\n  # Check if decimal part is empty\n\
    \  [[ \"$decimal_part\" =~ ^(-)$ ]] || return 1\n  # Check if the integer part\
    \ is negative\n  [[ \"$integer_part\" =~ ^(-)$ ]] || integer_part=$1\n  # Check\
    \ if decimal part is negative\n  [[ \"$decimal_part\" =~ ^(-)$ ]] || decimal_part=$2\n\
    \  # Check if decimal part is zero\n  [[ \"$decimal_part\" =~ ^(0)$ ]] || return\
    \ 1\n  # Split integer and decimal part\n  local integer=$1\n  local decimal=$2\n\
    \  # Check if decimal part is a float\n  [[ \"$decimal\" =~ ^(-)?([0-9]*\\.[0-9]+)$\
    \ ]] || return 1\n  # Check if the integer part is negative\n  [[ \"$integer\"\
    \ =~ ^(-)$ ]] || integer=$1\n  # Check if decimal part is negative\n  [[ \"$decimal\"\
    \ =~ ^(-)$ ]] || decimal=$2\n  # Check if the decimal part is zero\n  [[ \"$decimal\"\
    \ =~ ^(0)$ ]] || return 1\n  # Check if decimal part is an integer\n  [[ \"$decimal\"\
    \ =~ ^(-)?([0-9]+)$ ]] || return 1\n  # Find closest integer if decimal part is\
    \ integer\n  local closest\n  if [[ $decimal -eq \"$integer\" ]]; then\n    closest=$integer\n\
    \  else\n    closest=$(( $decimal < $integer ? $integer : $decimal ))\n  fi\n\
    \  echo $closest", "  local STRING=$1\n  local NUMBER=0\n  local MIN_VALUE=1000000000\
    \ # Minimum possible number\n  local MAX_VALUE=0 # Maximum possible number\n \
    \ local EXIT_CODE=0 # Standard exit code\n  local DIFF\n  local NEXT\n  local\
    \ NEXT_MAX\n  local NEXT_MIN\n  local PREV\n  local PREV_MAX\n  local PREV_MIN\n\
    \  # Parse the string\n  NEXT_MAX=0\n  NEXT_MIN=0\n  PREV_MAX=0\n  PREV_MIN=0\n\
    \  for NEXT in $STRING; do\n    case \"$NEXT\" in\n      \"-\")\n        DIFF=$((\
    \ $(( MAX_VALUE - $NEXT )) ))\n      ;;\n      \"+\")\n        DIFF=$(( $(( $NEXT\
    \ + MIN_VALUE )) ))\n      ;;\n      \".\")\n        DIFF=0\n      ;;\n      *)\n\
    \        DIFF=$(( $( (( $NEXT + MIN_VALUE )) < $(( MAX_VALUE - MIN_VALUE )) )\
    \ ))\n      ;;\n    esac\n    if [ $DIFF -gt 0 ] ; then\n      break\n    elif\
    \ [ $DIFF -le 0 ] ; then\n      DIFF=$(( $DIFF + 1 ))\n    fi\n    case \"$DIFF\"\
    \ in\n      0)\n        DIFF=1\n        ;;\n      1)\n        DIFF=2\n       \
    \ ;;\n      2)\n        DIFF=3\n        ;;\n      3)\n        DIFF=4\n       \
    \ ;;\n      4)\n        DIFF=5\n        ;;\n      5)\n        DIFF=6\n       \
    \ ;;\n      6)\n        DIFF=7\n        ;;\n      7)\n        DIFF=8\n       \
    \ ;;\n      8)\n        DIFF=9\n        ;;\n      9)\n        DIFF=10\n      \
    \  ;;\n      *)\n        DIFF=$(( $DIFF + 1 ))\n        ;;\n    esac\n    case\
    \ \"$DIFF\" in\n      0)\n        DIFF=1\n        ;;\n      1)\n        DIFF=2\n\
    \        ;;\n      2)\n        DIFF=3\n        ;;\n      3)\n        DIFF=4\n\
    \        ;;\n      4)\n        DIFF=5\n        ;;\n      5)\n        DIFF=6\n\
    \        ;;\n      6)\n        DIFF=7\n        ;;\n      7)\n        DIFF=8\n\
    \        ;;\n      8)\n        DIFF=9\n        ;;\n      9)\n        DIFF=10\n\
    \        ;;\n    e", "  if [ $# -ne 1 ]; then\n    echo \"Usage: $(basename $0)\
    \ number\"\n    echo \"The number must be a string\"\n    exit 1\n  fi\n\n  local\
    \ string=\"$1\"\n  local num=\"-1\"\n\n  if [[ ${string} =~ ^[+-]?([0-9]+|[0-9]*\\\
    .[0-9]+)$ ]]; then\n    local num=\"$1\"\n  elif [[ ${string} =~ ^[0-9]+\\.[0-9]+$\
    \ ]]; then\n    local num=\"${string%.*}\"\n  else\n    echo \"${string} is not\
    \ a number\"\n    exit 1\n  fi\n\n  local max=\"$(( 10 * ${num} ))\"\n\n  if [[\
    \ ${num} -eq 1 ]]; then\n    echo \"0\"\n  elif [[ ${num} -gt ${max} ]]; then\n\
    \    echo \"${max}\"\n  elif [[ ${num} -lt 0 ]]; then\n    echo \"0\"\n  else\n\
    \    local mod=\"${num%%/*}\"\n\n    while [[ ${mod} -gt 0 ]]; do\n      if [[\
    \ ${mod} -le ${max} ]]; then\n        echo \"${mod}\"\n        break\n      fi\n\
    \      mod=\"${mod%/*}\"\n    done\n  fi", "  local number=\"$1\"\n  # Check that\
    \ the string is a number\n  [[ \"$number\" =~ ^[0-9]+$ ]] || return 1\n  # Check\
    \ that it isn't too big or too small\n  [[ \"$number\" -le \"0\" ]] && return\
    \ 1 || [[ \"$number\" -gt \"0\" ]] && return 1\n  # Check that the number is equidistant\
    \ from zero\n  local base=\"$((${number%%.*} + 1))\"\n  local base2=\"$((${base%%.*}\
    \ + 1))\"\n  (( $base2 > $base )) && return 1\n  (( $number < 0 )) && return 1\n\
    \  (( $number > 0 )) && return $base", "    local input_number=$1\n    local closest_integer=$(grep\
    \ -Po \"[0-9]+\\.?[0-9]*$\" <<< \"$input_number\" | sort -n | tail -n 1)\n   \
    \ echo \"$closest_integer\"", "  # We use the fact that the difference between\
    \ $1 and $2 is at most one\n  # million\n  (( \"$1\" - \"$2\" ))", "  local val=$1\n\
    \  local val=${val%.*}\n  local factor=1\n  if [[ $val = \"0\" ]]; then\n    echo\
    \ \"0\"\n    return\n  fi\n  while (( val > 0 )) ; do\n    (( val = val / factor\
    \ ))\n    (( factor *= 10 ))\n  done\n  (( val == 0 ))\n  echo $val", "  local\
    \ str=$1\n  local a=\"${str%.*}\"\n  local b=\"${str##*.}\"\n  local c=\"${str%.*}\"\
    \n  local d=\"${str##*.}\"\n  local e=\"${str##*.}\"\n  local f=\"${str##*.}\"\
    \n  local g=\"${str##*.}\"\n  local h=\"${str##*.}\"\n  local i=\"${str##*.}\"\
    \n\n  local j=\"${a}${b}${c}${d}${e}${f}${g}${h}${i}\"\n  local k=\"$j\"\n  local\
    \ l=$(( ${j} > ${k} ? ${j} : ${k} ))\n  echo \"$l\"", "  local number=$1\n  #\
    \ Parse number into its integer part.\n  local integer=\"${number%%.*}\"\n  #\
    \ Parse number into its decimal part.\n  local decimal_part=\"${number#$integer}\"\
    \n  # Round the decimal part away from zero.\n  local rounded_decimal_part=$(echo\
    \ \"${decimal_part}\" | bc -c)\n  # Add it back on to the integer part.\n  local\
    \ rounding_result=\"$integer$rounded_decimal_part\"\n  # Convert the rounded decimal\
    \ part back to a string.\n  echo \"${rounding_result}\"", "    local string=\"\
    $1\"\n    local max=0\n    local min=1\n    local difference\n    local closest_integer\n\
    \    local temp\n\n    if [[ $string =~ ^-?[0-9]+(.[0-9]+)?$ ]]; then\n      \
    \  # number starts with -?\n        temp=$(echo \"${string}\" | sed -e 's/^\\\
    (-?[0-9]\\+\\)\\(\\.\\)\\([0-9]*\\)/\\1/g')\n        # Remove \"-\" from beginning\n\
    \        case \"${temp}\" in\n            (-*)\n                temp=\"${temp:1}\"\
    \n                ;;\n            (*)\n                # Keep \"-\"\n        \
    \        ;;\n        esac\n    else\n        case \"$string\" in\n           \
    \ (*)\n                echo \"$string\"\n                ;;\n        esac\n  \
    \      return\n    fi\n\n    while true; do\n        if [[ $string -eq \"$min\"\
    \ || $string -eq \"$max\" ]]; then\n            echo \"$string\"\n           \
    \ break\n        fi\n        if [[ $string -eq \"$max\" ]]; then\n           \
    \ if (( max - min == 1 )); then\n                echo \"$max\"\n             \
    \   break\n            fi\n            (( max++ ))\n            (( min-- ))\n\
    \            difference=$(echo \"$max\" \"$min\" | bc)\n        fi\n        if\
    \ [[ $string -eq \"$min\" ]]; then\n            if (( min - max == 1 )); then\n\
    \                echo \"$min\"\n                break\n            fi\n      \
    \      (( min++ ))\n            (( max-- ))\n            difference=$(echo \"\
    $max\" \"$min\" | bc)\n        fi\n        difference=$(echo \"$difference\" |\
    \ awk '{print $1}')\n        if (( $difference < 1 )); then\n            closest_integer=\"\
    $max\"\n            break\n        fi\n        if (( $difference > 1 )); then\n\
    \            closest_integer=\"$min\"\n            break\n        fi\n    done\n\
    \    echo $closest_integer", "  [[ -z \"$1\" ]] && echo \"No number given to closest_integer\"\
    \ && return 1\n  \n  # Convert input to a number to make sure we're working with\
    \ a number\n  [[ -z \"$1\" ]] && return 1\n  local input_number=\"$(echo \"$1\"\
    \ | sed -e 's/\\./\\\\./g' -e 's/,/\\\\./g')\"\n  \n  # Make sure the number is\
    \ at least two digits long\n  [[ -z \"$input_number\" || (${#input_number} < 2\
    \ )&& \"$input_number\" != \"-0\" && \"$input_number\" != \"-000\" && \"$input_number\"\
    \ != \"-.\" ]]\n    && echo \"$1 is not a positive integer\" >&2\n    && return\
    \ 1\n  \n  # Check if the input is a valid number\n  [[ \"$input_number\" =~ ^-?[0-9]+$\
    \ ]]\n    && echo \"$1 is not a valid number\" >&2\n    && return 1\n  \n  # If\
    \ the input number is equal to zero then return zero\n  if [[ \"$input_number\"\
    \ == \"0\" ]]; then\n    echo 0\n    return\n  fi\n  \n  # If the input number\
    \ is equal to one, return one\n  if [[ \"$input_number\" == \"1\" ]]; then\n \
    \   echo 1\n    return\n  fi\n  \n  # Create a variable with the input number\
    \ as a string\n  local input_number_as_string=\"$input_number\"\n  \n  # Make\
    \ sure the input number is three or more characters long\n  if [[ \"$input_number_as_string\"\
    \ == \"0000\" ]] || [[ \"$input_number_as_string\" == \"-0\" ]] || [[ \"$input_number_as_string\"\
    \ == \"-000\" ]]; then\n    local input_number_as_string_without_leading=\"0${input_number_as_string}\"\
    \n    local input_number_as_string_without_trailing=\"${input_number_as_string_without_leading%.*}\"\
    \n    local input_number_as_string_without_trailing_leading_zero=\"${input_number_as_string_without_trailing}0\"\
    \n    \n    if [[ \"$input_number_as_string\" == \"$input_number_as_string_without_trailing_leading_zero\"\
    \ ]]; then\n      echo 0\n      return\n    fi\n  fi\n  \n  # Rearrange the integer\
    \ part to make comparisons easier\n  local input_number_as_string_rearranged=\"\
    0$input_number_as_string\"\n  \n  # Get all the integer parts of the input number\
    \ as strings\n  local input_number_as_string_rearranged_with_leading_zeros=$(echo\
    \ \"$input_number_as_string_rearranged\" | sed -e 's/^0*\\([0-9][0-9]*\\).*/\\\
    1/')\n  local input_number_as_string_rearranged_with_no_leading_zeros=", "   \
    \ local number=$1\n    local integer_array=()\n    local max_value\n    local\
    \ max_idx\n    local diff\n\n    if ! [[ \"$number\" =~ ^[0-9]+$ ]]; then\n  \
    \      echo \"$1 is not a valid number\" >&2\n        return 1\n    fi\n\n   \
    \ # Convert the string to a list of integers\n    integer_array=($number)\n\n\
    \    # If the first number is an integer, return it\n    if [[ \"$integer_array\"\
    \ =~ ^[0-9]+$ ]]; then\n        echo \"$integer_array\"\n        return 0\n  \
    \  fi\n\n    # Sort our list of numbers in reverse order\n    integer_array=(\"\
    ${integer_array[@]}\" )\n    integer_array=(\"${integer_array[@]}\" )\n    integer_array=(\"\
    ${integer_array[@]}\" )\n    integer_array=(\"${integer_array[@]}\" )\n    integer_array=(\"\
    ${integer_array[@]}\" )\n    integer_array=(\"${integer_array[@]}\" )\n\n    #\
    \ Find the maximum value of the array\n    max_value=${integer_array[@]:0:1}\n\
    \    max_idx=0\n\n    for (( i=0; i<${#integer_array[@]}; i++ )); do\n       \
    \ if [ \"${integer_array[$i]}\" -gt \"$max_value\" ]; then\n            max_value=${integer_array[$i]}\n\
    \            max_idx=$i\n        fi\n    done\n\n    # If the number is equidistant\
    \ from two integers, round it\n    # away from zero.\n    if [[ ${integer_array[$max_idx]}\
    \ -eq ${integer_array[$max_idx-1]} ]]; then\n        max_idx=$(( max_idx + 1 ))\n\
    \    fi\n\n    # Convert the new list of integers back to a string\n    integer_array=()\n\
    \    for (( i=0; i <= $max_idx; i++ )); do\n        integer_array=( \"${integer_array[@]}\"\
    \ $(( ${integer_array[$i]}-1 )) )\n    done\n\n    integer_array=( \"${integer_array[@]}\"\
    \ )\n\n    # Return the string\n    echo \"${integer_array[0]}\"", "  local string=$1\n\
    \  local numbers=(\"$string\")\n  local round\n  local closest\n\n  round=$(echo\
    \ \"${numbers[@]}\" | awk '{print $1}' | sed 's/-//g' | cut -d- -f1)\n  for number\
    \ in \"${numbers[@]}\"; do\n    local diff=$(( ${number} + round ))\n    if [[\
    \ \"$diff\" -gt \"$closest\" ]]; then\n      closest=$diff\n    fi\n  done\n \
    \ echo $closest", "    local VAL=$1\n    local NEIGHBORS=\"2 4 6 8 10 12\"\n \
    \   local NEIGHBOR=\"$NEIGHBORS\"\n    local NEIGHBOR_INDEX=0\n    local NEIGHBOR_POS=1\n\
    \    while [ \"$NEIGHBOR\" != \"$VAL\" ] ; do\n        local NEIGHBOR_POS=$((NEIGHBOR_POS+1))\n\
    \        if [ \"$NEIGHBOR_POS\" -lt \"$#NEIGHBORS\" ] ; then\n            NEIGHBOR=\"\
    $NEIGHBORS\"\n        else\n            NEIGHBOR=\"$NEIGHBORS[$NEIGHBOR_POS]\"\
    \n        fi\n        NEIGHBOR_INDEX=$((NEIGHBOR_INDEX+1))\n        if [ \"$NEIGHBOR_INDEX\"\
    \ -eq \"$((NEIGHBORPOS-1))\" ] ; then\n            NEIGHBOR_POS=1\n        fi\n\
    \    done\n    echo \"$NEIGHBOR\"", "  local val=\"$1\"\n  local diff=\"$2\"\n\
    \  local int=\"$3\"\n  if [[ $diff = \"+\" || $diff = \"-\" ]]; then\n    local\
    \ shift=-1\n  elif [[ $diff = \"+\" ]]; then\n    shift=1\n    shift\n  else\n\
    \    shift\n  fi\n  # echo \"$val\"\n  # echo \"$int\"\n  # echo \"$diff\"\n \
    \ val=$(($val + $shift))\n  (( diff > 0 )) && val=$(($val + $int)) || val=$(($val\
    \ - $int))\n  # echo \"$val\"\n  val=\"$(($val / 1))\"\n  # echo \"$val\"\n  echo\
    \ \"$val\"", "    local NUM=\"${1#-}\"\n    local ZERO=\"${NUM}\"\n    local DENOMINATOR\n\
    \    local DENOMINATOR_REMAINDER\n    local NEWNUM\n\n    if [ \"${NUM}\" -eq\
    \ \"${ZERO}\" ]; then\n        return 0\n    fi\n\n    # Break up the number into\
    \ its individual digits\n    local NUMBER=\"${NUM}\"\n    local DIGITS=\"\"\n\
    \    while [ \"${NUMBER}\" -ge 0 ]; do\n        DIGITS=\"${DIGITS}${NUMBER%?}\"\
    \n        NUMBER=\"${NUMBER//?}\"\n    done\n\n    # Remove any leading zeros\n\
    \    while [ \"${DIGITS}\" == \"0\" ]; do\n        DIGITS=\"${DIGITS#-}\"\n  \
    \  done\n\n    # Break up the number into its individual digits\n    local DIGITS=\"\
    ${DIGITS}\"\n    local FIRST_DIGIT=\"${DIGITS}\"\n\n    if [ \"${DIGITS}\" -gt\
    \ 0 ]; then\n        local FIRST_DIGIT=\"${DIGITS}\"\n        local SECOND_DIGIT=\"\
    ${DIGITS#-}\"\n        if [ \"${FIRST_DIGIT}\" -gt \"${SECOND_DIGIT}\" ]; then\n\
    \            local SECOND_DIGIT=\"${SECOND_DIGIT}\"\n            FIRST_DIGIT=\"\
    ${FIRST_DIGIT}\"\n        fi\n    else\n        SECOND_DIGIT=\"0\"\n    fi\n\n\
    \    if [ \"${FIRST_DIGIT}\" -gt \"${SECOND_DIGIT}\" ]; then\n        FIRST_DIGIT=\"\
    ${FIRST_DIGIT}\"\n        SECOND_DIGIT=\"${SECOND_DIGIT}\"\n    else\n       \
    \ SECOND_DIGIT=\"${SECOND_DIGIT}0\"\n    fi\n\n    # Calculate the difference\
    \ between the first and second digits\n    local DIFF=\"${FIRST_DIGIT}-${SECOND_DIGIT}\"\
    \n    local DIFF_REMAINDER=\"${DIFF}\"\n    while [ \"${DIFF}\" -gt 0 ]; do\n\
    \        DIFF_REMAINDER=\"${DIFF_REMAINDER}${DIFF}\"\n        DIFF=\"${DIFF//?}\"\
    \n    done\n\n    # Now we have the difference between the two numbers and also\
    \ the remainder,\n    # so calculate the closest integer to that number\n    if\
    \ [ \"${DIFF}\" -eq \"0\" ]; then\n        NEWNUM=\"0\"\n    else\n        local\
    \ NEWNUM=\"${FIRST_DIGIT}${DIFF_REMAINDER}\"\n    fi\n\n    # Turn it into a positive\
    \ number if the original number was negative\n    if [ \"${ZERO}\" -lt \"${NEWNUM}\"\
    \ ]; then\n        NEWNUM=\"${NEWNUM}+\"\n    fi\n\n    return \"$NEWNUM\"", " \
    \ awk 'BEGIN {\n    # Convert all numbers to decimals\n    for(i=1; i<=NF; i++)\
    \ $i=$i/10\n  }\n  { \n    # Sort them by absolute value\n    for (i=1; i<=NF;\
    \ i++) {\n      if ($i == \"-\" || $i == \"+\") \n        next\n      else if\
    \ ($i < $(i-1)) {\n        swap=$i\n        next\n      }\n      else if ($i ==\
    \ $(i-1)) \n        break\n    }\n    # Swap the first number in the array with\
    \ the last number\n    $i = swap\n  }\n  END {\n    # Convert the array back to\
    \ a string\n    for (i=1; i<=NF; i++) $i = sprintf(\"%d\", $i)\n    printf \"\
    %s\" \"$1\"\n  }'", "    local number=$1\n    local integer\n    integer=$(( (\
    \ (number % 1) * ( 1 + number % 1 ) ) / 2 ))\n    if [ \"$number\" -eq \"$integer\"\
    \ ] ; then\n        # integer equals $number, so return it\n        echo $integer\n\
    \    else\n        # integer doesn't equal $number, but it's closer to zero,\n\
    \        # so return it\n        echo $integer\n    fi", "  number=$1\n  echo\
    \ \"$number\" | awk -F'.' '{print $1}' | sort | uniq -c | awk '{if ($1 > 1) print\
    \ $1}'", "  if (( $1 == \"NaN\" )) ; then\n    echo \"NaN\"\n  else\n    if [[\
    \ \"$1\" == *\"-\"* ]] ; then\n      echo \"$((${1//-/}%+1))\"\n    else\n   \
    \   echo \"$((${1//./}%+1))\"\n    fi\n  fi", "    echo $(echo $1 |sed -e 's/^-//g'\
    \ -e 's/^\\+//' -e 's/\\([0-9]*\\)[^0-9]*\\([0-9]*\\)/\\1\\2/')", "    local num=\"\
    ${1}\"\n    if [[ $num =~ ^[0-9]+$ ]]; then\n        local digits=\"${num//[!0-9.]}\"\
    \n        local number=\"${digits:0:1}\"\n        local decimal=\"${digits:1}\"\
    \n        local nearest_integer=\"${number}.${decimal}\"\n        if [[ $nearest_integer\
    \ =~ ^-[0-9]+$ ]]; then\n            nearest_integer=\"${nearest_integer//-/0}\"\
    \n        fi\n        local nearest_integer=\"${nearest_integer//+/ }\"\n    \
    \    local nearest_integer=\"${nearest_integer//\\./}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//+/\
    \ }\"\n        local nearest_integer=\"${nearest_integer//\\./}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"\
    ${nearest_integer//[0-9]/}\"\n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\
    \n        local nearest_integer=\"${nearest_integer//[0-9]/}\"\n        local\
    \ nearest_integer=\"${nearest_integer//[0-9]/}\"", "  local number=$1\n  local\
    \ smallest\n  local largest\n  local number2\n  local number3\n  local smallest_diff\n\
    \  local largest_diff\n  smallest=`echo $number | awk '{ print $1 }'`\n  largest=`echo\
    \ $number | awk '{ print $2 }'`\n  smallest_diff=`echo $smallest - $number | awk\
    \ '{ print $1 }'`\n  largest_diff=`echo $largest - $number | awk '{ print $1 }'`\n\
    \  if [ $smallest_diff -ne 0 ]; then\n    number2=`echo $number | awk -v smallest_diff=$smallest_diff\
    \ \\\n        '{ print $1 }'`\n    number3=`echo $number | awk -v largest_diff=$largest_diff\
    \ \\\n        '{ print $1 }'`\n    if [ $smallest_diff -eq 0 ]; then\n      return\
    \ $number2\n    else\n      return $number3\n    fi\n  elif [ $largest_diff -ne\
    \ 0 ]; then\n    number2=`echo $number | awk -v largest_diff=$largest_diff \\\n\
    \        '{ print $1 }'`\n    number3=`echo $number | awk -v smallest_diff=$smallest_diff\
    \ \\\n        '{ print $1 }'`\n    if [ $largest_diff -eq 0 ]; then\n      return\
    \ $number2\n    else\n      return $number3\n    fi\n  else\n    number2=`echo\
    \ $number | awk '{ print $1 }'`\n    number3=`echo $number | awk '{ print $2 }'`\n\
    \    if [ $number2 -eq $number ]; then\n      return $number3\n    elif [ $number3\
    \ -eq $number ]; then\n      return $number2\n    else\n      return 0\n    fi\n\
    \  fi", "    local val=\"$1\"\n    local min=\"$2\"\n    local max=\"$3\"\n  \
    \  local diff\n    local closest\n    local prev\n    local num\n    local str\n\
    \    local ret\n    # Convert the value to an integer.\n    num=\"$(echo \"$val\"\
    \ | sed 's/[\\.\\-\\+]//g')\"\n    if [ $num -ge $max ] && [ $num -le $min ];\
    \ then\n        # Number is in range.\n        return $num\n    elif [ $num -gt\
    \ $max ]; then\n        # Number is greater than the max value.\n        diff=$((\
    \ $max - $num))\n        prev=$(( $min - $diff ))\n        # Check if closest\
    \ number is less than the given value.\n        if [ \"$diff\" -gt 0 ] && [ \"\
    $num\" -gt \"$prev\" ] && [ \"$num\" -le \"$min\" ]; then\n            return\
    \ $min\n        elif [ \"$diff\" -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"\
    $num\" -ge \"$max\" ]; then\n            return $max\n        elif [ \"$num\"\
    \ -eq \"$prev\" ]; then\n            # Check if difference is zero before returning.\n\
    \            if [ \"$diff\" = 0 ]; then\n                return $min\n       \
    \     elif [ \"$diff\" != 0 ]; then\n                # Return closest number.\n\
    \                return $num\n            fi\n        fi\n    elif [ $num -le\
    \ $min ]; then\n        # Number is less than the min value.\n        diff=$((\
    \ $num - $min))\n        prev=$(( $max - $diff ))\n        # Check if closest\
    \ number is greater than the given value.\n        if [ \"$diff\" -gt 0 ] && [\
    \ \"$num\" -gt \"$prev\" ] && [ \"$num\" -le \"$max\" ]; then\n            return\
    \ $max\n        elif [ \"$diff\" -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"\
    $num\" -ge \"$min\" ]; then\n            return $min\n        elif [ \"$num\"\
    \ -eq \"$prev\" ]; then\n            # Check if difference is zero before returning.\n\
    \            if [ \"$diff\" = 0 ]; then\n                return $max\n       \
    \     elif [ \"$diff\" != 0 ]; then\n                # Return closest number.\n\
    \                return $num\n            fi\n        fi\n    elif [ \"$num\"\
    \ -eq \"$min\" ]; then\n        # Number is equal to min.\n        diff=$(( $min\
    \ - $num ))\n        prev=$(( $max - $diff ))\n        # Check if closest number\
    \ is greater than the given value.\n        if [ \"$diff\" -gt 0 ] && [ \"$num\"\
    \ -gt \"$prev\" ] && [ \"$num\" -le \"$max\" ]; then\n            return $max\n\
    \        elif [ \"$diff\" -lt 0 ] && [ \"$num\" -gt \"$prev\" ] && [ \"$num\" ",
  "  # The $1 is our value that we are looking for\n  # The $2 represents the largest\
    \ number\n  # The $3 represents the smallest number\n\n  # First we convert the\
    \ value to float\n  FLOAT_VALUE=$(echo \"$1\" | sed 's/\\./\\\\./g')\n  FLOAT_VALUE=$(echo\
    \ \"$FLOAT_VALUE\" | sed 's/ //g')\n\n  # Now we try to get the closest integer\n\
    \  CLOSEST_INTEGER=$(echo \"$FLOAT_VALUE\" | bc)\n  CLOSEST_INTEGER=$(echo \"\
    $CLOSEST_INTEGER\" | sed 's/^0/-')\n\n  # Now we convert the string to an int\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^-/0')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n\
    \  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo\
    \ \"$CLOSEST_INTEGER\" | sed 's/^0*//')\n  CLOSEST_INTEGER=$(echo \"$CLOSEST_INTEGER\"\
    \ | sed 's/^", "    local val=\"$1\"\n    local int_val=${val//[^0-9]}\n    local\
    \ num_val=${int_val//\\.}\n\n    # Return closest integer to the input number\n\
    \    if [ -z \"$num_val\" ]; then\n        echo \"Invalid Input\"\n    elif [\
    \ \"$int_val\" -eq \"$val\" ]; then\n        # Value is equidistant from two integers\n\
    \        int_val=\"$num_val\"\n    fi\n\n    echo \"$int_val\"", "  local NUM=$1\n\
    \  local RESULT\n  if [[ $NUM =~ ^[0-9]+$ ]]; then\n    RESULT=$(echo \"$NUM\"\
    \ | sed -e 's/^\\([0-9][0-9]*\\)\\+[0-9]*$/\\1/')\n    if [[ $RESULT =~ ^-?[0-9]+$\
    \ ]]; then\n      RESULT=$(echo \"$RESULT * -1\" | bc)\n    fi\n  else\n    RESULT=$(echo\
    \ \"$NUM\" | bc)\n  fi\n  echo $RESULT", "    local input=$1\n    # Convert input\
    \ to an integer since bash doesn't have floats.\n    input=${input//[^0-9]/}\n\
    \    local max\n    local closest\n    local diff\n\n    # If the input is empty,\
    \ return \"0\".\n    [[ ! -z \"$input\" ]] || return 0\n\n    # If the input contains\
    \ a single digit, return the integer.\n    # Otherwise return the \"max\" variable\
    \ as input.\n    [[ ${input%%[^0-9]} == [0-9] || ${input%%[^0-9]} == [0-9][0-9]\
    \ ]] || max=$input\n    closest=$max\n\n    # Get the difference between the closest\
    \ and the input number.\n    # The diff variable is set to zero if it is the same\
    \ as the input.\n    diff=$(echo \"$input\" - \"$closest\" | bc -l)\n    [[ !\
    \ -z \"$diff\" ]] || diff=0\n\n    # If the difference is negative, subtract 1\
    \ from the closest variable\n    # and add 1 to the input variable.\n    if [\
    \ \"$diff\" -lt 0 ]\n    then\n        closest=$(echo \"$closest\" - 1)\n    \
    \    input=$(echo \"$input\" + 1)\n    fi\n\n    # If the difference is zero,\
    \ return the same variable.\n    # Otherwise, return the closest variable as the\
    \ input.\n    [ \"$diff\" -eq 0 ] || return $closest", "  local val=$1\n  # Remove\
    \ leading and trailing whitespace\n  val=`echo $val | tr -d ' \\t'`\n  # Handle\
    \ negative numbers\n  if [ \"$val\" == \"-$val\" ]; then\n    val=\"-0$val\"\n\
    \  fi\n  # Handle decimal numbers\n  if [ \"$val\" == \"$val\" ] || [ \"$val\"\
    \ == \"$val.0\" ]; then\n    val=\"$val.0\"\n  fi\n  # Convert string to integer\
    \ with base 10\n  val=\"${val#\"$prefix\"}\"\n  val=\"${val%\"$postfix\"}\"\n\
    \  if [ $val -gt $max ]; then\n    val=$max\n  fi\n  if [ $val -lt $min ]; then\n\
    \    val=$min\n  fi\n  echo -n \"$val\"", "  local int_string=$1\n  local int_num=\"\
    $(echo -e \"${int_string}\" | sed 's/^ *//g' | tr -d '\"')\"\n  local int_num2=\"\
    $(echo -e \"${int_num}\" | sed 's/^ *//g' | tr -d '\"')\"\n  local int_dif=\"\
    $(expr ${int_num} - ${int_num2})\"\n  local int_result=\"$((${int_dif}/2))\"\n\
    \  echo \"${int_result}\"", "  # Convert the argument to a floating point value\n\
    \  input=$1\n  value=$(echo \"$input\"|tr -dc '0-9')\n  value=$(echo \"$value\"\
    |bc)\n  base=${input%%.*}\n  if [[ \"$input\" =~ ^-?[0-9]$ ]]; then\n    if [[\
    \ \"$input\" =~ -?[1-9][0-9]*$ ]]; then\n      input=$(echo \"$base+$input\"|bc)\n\
    \    fi\n  fi\n  input=$(echo \"$input\"|bc)\n  if [ \"$input\" -gt \"$value\"\
    \ ]; then\n    value=$input\n  fi\n  output=$(( value + 1 ))\n  echo $output",
  "  local x=\"$1\"\n  local prev=\"$1\"\n  local next=\"$1\"\n\n  if [[ \"$x\" ==\
    \ \"0\" ]]; then\n    echo \"0\"\n  elif [[ -z \"$prev\" ]]; then\n    echo \"\
    $x\"\n  else\n    while true; do\n      prev=\"$prev\"\n      if [[ $prev -gt\
    \ \"$next\" ]]; then\n        next=\"$x\"\n        break\n      fi\n      if [[\
    \ \"$prev\" -eq \"$x\" ]]; then\n        echo \"$x\"\n        break\n      fi\n\
    \    done\n  fi", "    local string=$1\n    local diff\n    local closest_diff\n\
    \    local closest_integer\n    local diff\n    local integer\n    local num\n\
    \    integer=$(($(( $(( 10#$string + 1 ) - 10#$string ) / 10 )) ))\n    if [[\
    \ $integer -eq 0 ]]; then\n        return 0\n    fi\n    num=$(( $string % 10\
    \ ))\n    diff=$(($(( 10#$string - $(( 10#$num )) - 1 )) ))\n    closest_diff=$(($((\
    \ 10#$closest_integer - $closest_integer / 10 )) ))\n    closest_integer=$(( $closest_integer\
    \ + 1 ))\n    while [ $closest_diff -le 0 ]; do\n        (($diff < 0)) && return\
    \ $(( 10#$closest_integer ))\n        (($diff == 0)) && return $(( 10#$closest_integer\
    \ ))\n        (($diff > 0)) && return $(( 10#$closest_integer + 1 ))\n       \
    \ (($diff == 1)) && return $(( 10#$closest_integer + 1 ))\n        (($diff > 1))\
    \ && return $(( 10#$closest_integer + 1 ))\n        (($diff == 2)) && return $((\
    \ 10#$closest_integer + 1 ))\n        (($diff > 2)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff == 3)) && return $(( 10#$closest_integer + 1 ))\n  \
    \      (($diff > 3)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ == 4)) && return $(( 10#$closest_integer + 1 ))\n        (($diff > 4)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff == 5)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff > 5)) && return $(( 10#$closest_integer + 1 ))\n   \
    \     (($diff == 6)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ > 6)) && return $(( 10#$closest_integer + 1 ))\n        (($diff == 7)) && return\
    \ $(( 10#$closest_integer + 1 ))\n        (($diff > 7)) && return $(( 10#$closest_integer\
    \ + 1 ))\n        (($diff == 8)) && return $(( 10#$closest_integer + 1 ))\n  \
    \      (($diff > 8)) && return $(( 10#$closest_integer + 1 ))\n        (($diff\
    \ == 9)) && return $(( 10#$closest_integer + 1 ))\n        ", "    local string=\"\
    $1\"\n    if [[ \"${string}\" =~ ^[0-9]+$ ]]; then\n        local integer=\"${string}\"\
    \n    else\n        echo \"Input is not a number: '$string'\"\n        return\
    \ 1\n    fi\n    local result\n    local num1=\"${integer}\"\n    local num2=\"\
    $(( ($(expr \"$integer\" - \"${integer}\") * (-1)) | bc -l))\"\n    result=\"\
    $(( ($(expr \"$integer\" - \"${integer}\") * (-1)) | bc -l))\"\n    if [[ \"${integer}\"\
    \ == *\".\"* ]]; then\n        integer=\"${integer%%.*}\"\n        num1=\"${integer}\"\
    \n    fi\n    if [[ \"${num1}\" < \"${num2}\" ]]; then\n        result=\"$num1\"\
    \n    elif [[ \"${num1}\" > \"${num2}\" ]]; then\n        result=\"$num2\"\n \
    \   fi\n    echo \"$result\"", "    local string=${1}\n    local number=${string}\n\
    \    # if the number is already an integer, just return it\n    [[ \"$string\"\
    \ =~ ^[0-9]+$ ]] && echo \"$string\" || return 1\n    # make sure it's a positive\
    \ number\n    [[ \"$string\" =~ ^[+-]([0-9]+)?$ ]] || return 1\n    # if the number\
    \ is positive, check if it's closer to zero than to either of the\n    # numbers\
    \ involved, if it is, the one closer to zero should return\n    if [[ ${number}\
    \ -lt 0 ]]; then\n        # first check whether it's closer to zero\n        local\
    \ number1=${number}\n        local number2=${number}\n        if [[ ${number}\
    \ -lt $number1 ]]; then\n            number1=$number\n        else\n         \
    \   number2=$number\n        fi\n        if [[ ${number1} -lt 0 && ${number2}\
    \ -lt 0 ]]; then\n            number=${number1}\n        elif [[ ${number1} -lt\
    \ 0 && ${number2} -gt 0 ]]; then\n            number=${number2}\n        fi\n\
    \    fi\n    echo \"$number\"", "  declare -i n=\"$1\" count=0\n  # Make sure\
    \ the number is numeric\n  [ \"$n\" = \"${n%%.*}\" ] || return 1\n  n=${n%.*}\n\
    \  if [ $n -eq 0 ]; then\n    return $n\n  fi\n  local base=0\n  # Loop through\
    \ all possible bases until we find a one that doesn't have an\n  # exact match\n\
    \  for base in {10..16}; do\n    if [ \"${#n}\" -eq \"${#base}\" ]; then\n   \
    \   continue\n    fi\n    # Make sure the base has at least two characters\n \
    \   if [ \"${#base}\" -le 2 ]; then\n      return 1\n    fi\n    local i\n   \
    \ # Loop through the string until we find the first character that doesn't\n \
    \   # match the base\n    for (( i=0; i<${#base}; i++ )); do\n      if [ \"${n:$i:1}\"\
    \ != \"${base:i:1}\" ]; then\n        count=$(expr ${n} - $i)\n        break\n\
    \      fi\n    done\n    if [ $count -eq 0 ]; then\n      break\n    fi\n  done\n\
    \  local closest\n  # Loop through all possible bases until we find one that has\
    \ exact\n  # match\n  for base in {10..16}; do\n    if [ \"${#n}\" -eq \"${#base}\"\
    \ ]; then\n      continue\n    fi\n    # Make sure the base has at least two characters\n\
    \    if [ \"${#base}\" -le 2 ]; then\n      return 1\n    fi\n    local i\n  \
    \  # Loop through the string until we find the first character that does\n   \
    \ # match the base\n    for (( i=0; i<${#base}; i++ )); do\n      if [ \"${n:$i:1}\"\
    \ = \"${base:i:1}\" ]; then\n        closest=$(expr ${n} - $i)\n        break\n\
    \      fi\n    done\n    if [ $closest -eq 0 ]; then\n      break\n    fi\n  done\n\
    \  # The closest integer is the greatest integer between the base and the number\n\
    \  # that hasn't been parsed\n  local closest\n  for base in {10..16}; do\n  \
    \  if [ \"${#n}\" -eq \"${#base}\" ]; then\n      continue\n    fi\n    local\
    \ i\n    local j\n    local closest\n    for (( i=0; i<${#base}; i++ )); do\n\
    \      if [ \"${n:$i:1}\" = \"${base:i:1}\" ]; then\n        closest=$(expr ${n}\
    \ - $i)\n        break\n      fi\n    done\n    for (( j=0; j<${#n}; j++ )); do\n",
  "    local string=\"$1\"\n\n    local -a integers\n    integers=( $string )\n\n\
    \    local integer\n    integer=${integers[$(( ${#integers[@]} - 1 ))]}\n    integer=\"\
    ${integer%.*}\"\n\n    if [[ ${integer} -eq $string ]]; then\n      integer=$((\
    \ ${integer} + 1 ))\n    else\n      integer=$(( ${integer} ))\n    fi\n\n   \
    \ echo \"$integer\"", "    local number=$1\n    local integers=$($(printf \"%s\
    \ $2 $3 $4\" $number $2 $3 $4)|grep -Eo \"[0-9]+\")\n    local minmax=$($(printf\
    \ \"%s $2 $3 $4\" $number $2 $3 $4)|grep -Eo \"[0-9.]+\")\n    local min=$(($(echo\
    \ \"$minmax ${integers[*]}\"|awk '{print $1*($2-$3)+$4}')))\n    local max=$(($(echo\
    \ \"$minmax ${integers[*]}\"|awk '{print $1*($2-$3)-$4}')))\n    echo \"$((${number%%.*}-$min+$max))\"",
  "  local string=${1}\n  local integer closest\n  local number diff\n  local negative\
    \ negative_index\n  local positive_index\n\n  negative_index=0\n  positive_index=0\n\
    \  negative=false\n  positive=false\n  diff=0\n  # Loop through the string, incrementing\
    \ negative_index if needed\n  for number in \"${string//,/ }\"; do\n    (( negative_index++\
    \ ))\n    if [[ \"${number}\" = -* ]]; then\n      negative=true\n    fi\n   \
    \ (( positive_index++ ))\n    if [[ \"${number}\" = -* ]]; then\n      negative=true\n\
    \    fi\n    (( diff += ${number} ))\n  done\n\n  # Return closest integer based\
    \ on positive_index and negative_index\n  # If the difference between the two\
    \ is negative, return -negative_index\n  # If the difference between the two is\
    \ positive, return positive_index\n  # Otherwise return diff itself\n  if [[ \"\
    ${diff}\" = -* ]]; then\n    if [[ \"${negative}\" == true ]]; then\n      ((\
    \ negative_index -= 1 ))\n    else\n      (( positive_index -= 1 ))\n    fi\n\
    \  fi\n  if [[ \"${diff}\" = * ]]; then\n    if [[ \"${negative}\" == true ]];\
    \ then\n      (( negative_index -= 1 ))\n    else\n      (( positive_index -=\
    \ 1 ))\n    fi\n  fi\n  closest=${string%${string//,/ }}\n  closest=${closest//-/}\n\
    \  closest=${closest//+/}\n  if [[ \"${diff}\" > 0 ]]; then\n    closest=\"${closest}+\"\
    \n  fi\n  if [[ \"${diff}\" < 0 ]]; then\n    closest=\"${closest}-\"\n  fi\n\
    \  return \"${closest}\"", "  declare number=$1\n  declare integer\n\n  integer=$(echo\
    \ \"$number\" | sed 's/\\./\\+/')\n  integer=$(echo \"$number\" | sed 's/-/-+/')\n\
    \  integer=$(echo \"$number\" | sed 's/+/-+/')\n  integer=$(echo \"$number\" |\
    \ sed 's/^[+-]/0\\+/')\n  integer=$(echo \"$number\" | sed 's/[+-]$//')\n  integer=$(echo\
    \ \"$number\" | sed 's/^\\+\\+/0\\+/')\n  integer=$(echo \"$number\" | sed 's/\\\
    +$//')\n\n  echo \"$integer\"", "    local input=$1\n    if [[ \"$input\" =~ ^[0-9]+\\\
    .[0-9]+$ ]]; then\n        local digits=${#input}\n        if [ \"$digits\" -gt\
    \ 3 ]; then\n            local sign=$(( 10#$digits - 2 ))\n            local decimal=${input%%.*}\n\
    \            local integer=$(printf \"%0*d\" \"$sign\" \"$decimal\")\n       \
    \     local nearest_integer=$(( 10#$integer + $sign ))\n            # Make sure\
    \ that the integer is really an integer (and not a\n            # fraction)\n\
    \            if (( \"$nearest_integer\" < $integer )); then\n                nearest_integer=$((\
    \ $nearest_integer + 1 ))\n            fi\n            echo $nearest_integer\n\
    \        else\n            echo $input\n        fi\n    else\n        echo 1\n\
    \    fi", "    local i\n    local diff\n    local farthest_integer\n    local\
    \ diff_index\n    local integer_part\n    local decimals\n    local decimals_index\n\
    \    local decimals_part\n    local decimals_part_index\n\n    integer_part=\"\
    ${1}\"\n    decimals=\"${integer_part:(-$((${#integer_part}-1))):1}\"\n    decimals_part=\"\
    ${decimals:1}\"\n\n    # Calculate difference between original and integer part\n\
    \    diff=\"$(( ${#integer_part} - ${#decimals_part} ))\"\n    if [ -n \"${diff}\"\
    \ ]; then\n        echo \"${integer_part}.0\"\n        return\n    fi\n\n    diff_index=\"\
    $(echo \"${integer_part}\" | tr -cd '0123456789')\"\n    decimals_part_index=\"\
    $(echo \"${decimals_part}\" | tr -cd '0123456789')\"\n\n    # If the difference\
    \ is equidistant, round away from zero.\n    if [ \"${diff_index}\" -eq \"${decimals_part_index}\"\
    \ ]; then\n        (( diff -- = 0 ))\n    fi\n    if [ \"${diff_index}\" -lt \"\
    ${decimals_part_index}\" ]; then\n        farthest_integer=\"${integer_part}\"\
    \n    else\n        farthest_integer=\"${decimals_part}\"\n    fi\n    echo \"\
    ${farthest_integer}\"", "  local value=\"$1\"\n  if ! test -d .; then\n    echo\
    \ 0\n  else\n    local digits=$(echo \"${value}\" | sed 's/[^0-9]*//g')\n    local\
    \ first=\"${digits}\"\n    local second=\"${digits}.0\"\n    local sign=\"${digits}\"\
    \n    local firstLength=${#first}\n    local secondLength=${#second}\n    local\
    \ signLength=${#sign}\n    local distance=${firstLength}\n\n    if [ \"$firstLength\"\
    \ -gt \"$secondLength\" ]; then\n      first=\"${first%.*}\"\n      second=\"\
    ${second%.*}\"\n      sign=\"${sign%.*}\"\n      firstLength=${#first}\n     \
    \ secondLength=${#second}\n      signLength=${#sign}\n      distance=${firstLength}\n\
    \    fi\n\n    if [ \"$secondLength\" -gt \"$firstLength\" ]; then\n      first=\"\
    ${first%.*}\"\n      second=\"${second%.*}\"\n      sign=\"${sign%.*}\"\n    \
    \  firstLength=${#first}\n      secondLength=${#second}\n      signLength=${#sign}\n\
    \      distance=${secondLength}\n    fi\n\n    if [ \"$firstLength\" -gt \"$signLength\"\
    \ ]; then\n      first=\"${first%.*}\"\n      sign=\"${sign%.*}\"\n      firstLength=${#first}\n\
    \      signLength=${#sign}\n      distance=${firstLength}\n    fi\n\n    if [\
    \ \"$signLength\" -gt \"$firstLength\" ]; then\n      first=\"${first%.*}\"\n\
    \      sign=\"${sign%.*}\"\n      firstLength=${#first}\n      signLength=${#sign}\n\
    \      distance=${signLength}\n    fi\n\n    local closest\n    if [ \"$distance\"\
    \ -gt \"$2\" ]; then\n      closest=\"$first$((signLength-distance))$sign\"\n\
    \    elif [ \"$distance\" -lt \"$2\" ]; then\n      closest=\"$second$((distance-signLength))$sign\"\
    \n    else\n      closest=\"$value\"\n    fi\n    echo ${closest}\n  fi", "  local\
    \ number=$1\n  local min\n  local max\n  local distance\n  local closest\n\n \
    \ min=${number%%.*}\n  max=${number#*.}\n\n  if (( min < 0 )) ; then\n    # If\
    \ the number begins with a minus, remove it\n    min=${number#*-}\n    max=${number%%-*}\n\
    \  fi\n\n  if (( max > 0 )) ; then\n    # If the number begins with a plus, remove\
    \ it\n    max=${number#+*}\n    min=${number%%+*}\n  fi\n\n  if (( ${#min} > ${#max}\
    \ )) ; then\n    # If the two numbers have different lengths, fail\n    distance=${#min}\n\
    \  else\n    distance=${#max}\n  fi\n\n  if (( distance > 1 )) ; then\n    # If\
    \ the two numbers are equidistant, round away from zero\n    closest=$(( ${number}+${min}/10\
    \ ))\n  else\n    # If the two numbers are equidistant, round towards the integer\n\
    \    closest=$(( ${number}+${min} ))\n  fi\n\n  echo \"$closest\"", "  local integer=$1\n\
    \  local diff\n  diff =$(echo \"$integer\" | bc)\n  local diffInt\n  diffInt=$((\
    \ diff*10 ))\n  local diffDbl\n  diffDbl=$(( diff*10 ))\n  if [ \"$diffInt\" -ge\
    \ \"10\" ]; then\n      diffInt=$(( diffInt-1 ))\n      diffDbl=$(( diffDbl+1\
    \ ))\n  fi\n  if [ \"$diffDbl\" -ge \"10\" ]; then\n      diffDbl=$(( diffDbl-1\
    \ ))\n      diffInt=$(( diffInt+1 ))\n  fi\n  if [ \"$diffInt\" -ge \"1\" ]; then\n\
    \      diffInt=0\n      diffDbl=0\n  fi\n  if [ \"$diffDbl\" -ge \"1\" ]; then\n\
    \      diffDbl=0\n      diffInt=0\n  fi\n  echo $(( diffInt+diffDbl ))", "  local\
    \ x $2\n  x=\"$1\"\n  y=\"$x\"\n  echo \"$(( ( ( ( ( ( $x | cut -c -3 ) - $y |\
    \ cut -c -2 ) ) \\\n            - $y | cut -c -1 ) - $y | cut -c -1 ) + 1 ))\"",
  "    local input=\"$1\"\n    if [[ \"${input}\" = \"--help\" ]]; then\n        echo\
    \ \"This script returns the closest integer to an integer input. \\\nIf the number\
    \ input is a float, a decimal point is added before rounding.\"\n        exit\
    \ 0\n    fi\n\n    if [[ \"$input\" =~ ^[0-9]+(\\.[0-9]+)?$ ]]; then\n       \
    \ local input_int=\"${BASH_REMATCH[0]}\"\n        local input_decimal=\"${BASH_REMATCH[1]}\"\
    \n        if [[ $(( ${#input_decimal} )) -gt 0 ]]; then\n            local input_int_dec=\"\
    ${input_int}.${input_decimal}\"\n            local input_int_dec2=\"${input_int_dec}\"\
    \n        else\n            local input_int_dec=\"${input_int}\"\n           \
    \ local input_int_dec2=\"${input_int_dec}\"\n        fi\n        # Check if input\
    \ integer is equidistant from two integers\n        if [[ ${#input_int_dec} -gt\
    \ ${#input_int_dec2} ]]; then\n            if [[ $(( ${#input_decimal} )) -gt\
    \ 0 ]]; then\n                local input_int_dec2_dec=\"${input_int_dec2}.${input_decimal}\"\
    \n                local input_int_dec2_dec2=\"${input_int_dec2_dec}\"\n      \
    \      else\n                local input_int_dec2_dec=\"${input_int_dec2}\"\n\
    \                local input_int_dec2_dec2=\"${input_int_dec2_dec}\"\n       \
    \     fi\n            local output_int=${#input_int_dec2}\n            local output_decimal=\"\
    ${input_int_dec2_dec2}${output_int}\"\n        else\n            local output_int=${#input_int_dec}\n\
    \            local output_decimal=\"${input_int_dec}${output_int}\"\n        fi\n\
    \        echo \"$output_decimal\"\n    else\n        echo \"Error: Input must\
    \ be a number\"\n    fi", "  local value\n  local base\n  local distance\n  local\
    \ closest\n  local quotient\n  local remainder\n  local rounded\n  local result\n\
    \  local digit\n  local quotientString\n  local remainderString\n\n  value=$1\n\
    \  base=$(echo \"${value}\" | sed -e \"s/[^0-9.]//g\")\n  if [ -z \"${base}\"\
    \ ]; then base=1; fi\n  distance=$(echo \"${value}\" | sed -e \"s/^.\\([0-9]*\\\
    )$/\\1/\")\n  if [ -z \"${distance}\" ]; then distance=0; fi\n  closest=$(echo\
    \ \"${distance}\" | bc)\n  if [ \"${closest}\" -lt 1 ]; then closest=1; fi\n\n\
    \  quotient=$(echo \"${closest} / ${base}\" | bc)\n  quotientString=$(echo \"\
    ${quotient}\" | sed -e \"s/^.\\([0-9]*\\)$/\\1/\")\n  remainder=$(echo \"${quotient}\
    \ - ${quotientString}\" | bc)\n  remainderString=$(echo \"${remainder}\" | sed\
    \ -e \"s/^.\\([0-9]*\\)$/\\1/\")\n  if [ \"${quotient}\" -gt \"${quotientString}\"\
    \ ]; then rounded=\"1\"; else\n    rounded=\"0\"\n  fi\n  if [ \"${remainder}\"\
    \ -gt \"${remainderString}\" ]; then rounded=\"1\"; else\n    rounded=\"0\"\n\
    \  fi\n  if [ \"${rounded}\" -eq \"0\" ]; then rounded=\"1\"; fi\n\n  if [ \"\
    ${rounded}\" -eq \"1\" ]; then\n    result=$(echo \"${value}\" | sed -e \"s/^.\\\
    ([0-9]*\\)$/\\1/\")\n  else\n    result=\"${value}\"\n  fi\n  echo ${result}",
  "  local STRING=$1\n  # Remove all non-digit characters\n  STRING=${STRING/[!0-9]/}\n\
    \  # If no digits exist in the string, return it.\n  if [ ${#STRING} -eq 0 ];\
    \ then\n    return 0\n  fi\n  # If there is more than one digit, then sort them\
    \ and take the first\n  # one.\n  if [[ ${#STRING} -eq 1 ]]; then\n    local NUMBER=$1\n\
    \    if [[ $NUMBER =~ ^[+-]?[0-9]+$ ]]; then\n      # Number starts with at least\
    \ one digit\n      local DIGIT=$(echo $NUMBER | sed -e 's/^\\([0-9]\\+\\).*$/\\\
    1/')\n      # Test if digit exists in the string\n      local INDEX=${STRING:${#DIGIT}}\n\
    \      local DIGIT=${STRING:${INDEX:1}}\n      if [[ ${#DIGIT} -gt 0 ]]; then\n\
    \        echo $DIGIT\n      else\n        echo 0\n      fi\n    else\n      echo\
    \ 0\n    fi\n  else\n    if [ $STRING -le 0 ] || [ $STRING -ge 9 ]; then\n   \
    \   echo $STRING\n    else\n      echo 0\n    fi\n  fi", "  # Get the value\n\
    \  val=$1\n\n  # Convert it to an integer if needed\n  val=${val//[^0-9]}\n  val=${val//.}\n\
    \  val=${val//+}\n\n  # If it looks like a number, use it\n  [[ \"${val}\" =~\
    \ ^[0-9]+$ ]] || return $val\n\n  # If the value is negative, subtract it\n  [[\
    \ $val -gt 0 ]] && val=$((val - 1))\n\n  # Scan from greatest to least and return\
    \ the closest\n  # integer to that value\n  val=$((val+1))\n  while (( val > 0\
    \ )); do\n    (( val = val / 10 ))\n  done\n  while (( val < 0 )); do\n    ((\
    \ val = val * 10 ))\n  done\n  echo \"$val\"", "    local number=$1\n    local\
    \ closest=`expr ${number} \\* 10`\n    local remainder\n    local delta\n\n  \
    \  while true; do\n        remainder=`expr $number % $closest`\n        delta=`expr\
    \ $remainder \\- $closest`\n        if [ $delta -le 0 ]; then\n            closest=$remainder\n\
    \            break\n        elif [ $delta -ge 0 ]; then\n            closest=$remainder\n\
    \        fi\n        number=$(( $number / 10 ))\n    done\n\n    return $closest",
  "  local VALUE=$1\n  local TOLERANCE\n  local TOLERANCE_INT\n  local NORM_NUM\n\
    \  local CLOSEST\n  TOLERANCE=$(echo \"0.$(( 10#$TOLERANCE ))\" | bc)\n  TOLERANCE_INT=$(echo\
    \ \"$TOLERANCE * $(( 10#1 ))\" | bc)\n  NORM_NUM=$(echo \"$VALUE * $(( 10#1 ))\"\
    \ | bc)\n  CLOSEST=$(( $(echo \"($NORM_NUM + $TOLERANCE_INT + $TOLERANCE_INT)\"\
    \ | bc) ))\n  (( $(echo \"$VALUE * $(( 10#1 )) < $CLOSEST\" | bc) )) && echo $CLOSEST",
  "  local number=$1\n  local number_string=$(echo \"${number}\" | tr -dc '0-9')\n\
    \  local first_number_string=$(echo \"${number_string}\" | head -n 1)\n  local\
    \ second_number_string=$(echo \"${number_string}\" | tail -n 1)\n\n  if [[ ${first_number_string}\
    \ -ne ${second_number_string} ]]; then\n    local diff=$(( (\"${number}\" - \"\
    ${first_number_string}\") \\\n              / (\"${second_number_string}\" - \"\
    ${first_number_string}\") + 1 ))\n    local closest=$(( \"${diff}\" > 0 ? \"${first_number_string}\"\
    \ : \"${second_number_string}\" ))\n    echo \"${closest}\"\n  else\n    echo\
    \ ${number}\n  fi", "  # Check if the first argument is a number\n  [[ -z $1 ]]\
    \ && echo \"$0: missing argument\" && exit 1\n  [[ ! -z \"$1\" ]] && local number=$1\n\
    \n  # Check if first argument is a float or not\n  [[ \"$number\" =~ ^[0-9]+\\\
    .[0-9]+$ ]] || echo \"$0: argument is not a number: $number\" && exit 1\n\n  #\
    \ Check if the given number is a float\n  if [[ $number =~ ^[0-9]+\\.[0-9]+$ ]];\
    \ then\n    local int_part=$(echo \"$number\" | awk '{print $1}')\n    local dec_part=$(echo\
    \ \"$number\" | awk '{print $2}')\n\n    # If first digit is non-zero, the number\
    \ is negative\n    if [[ \"$int_part\" -ne \"0\" ]]; then\n      int_part=-$int_part\n\
    \      dec_part=-$dec_part\n    fi\n\n    local closest\n    closest=$(echo \"\
    $int_part*$dec_part\" | bc)\n    # Round it away from zero\n    closest=$(bc <<<\
    \ \"scale=0;$closest;$dec_part\")\n    echo \"$closest\"\n  fi", "  local val=$1\n\
    \  val=\"$(printf '%s\\n' \"$val\" | tr -d '[\\.,]' | tr '[:upper:]' '[:lower:]')\"\
    \n  local min=$((10#$val))\n  local max=$((10#$val))\n  local step=$((10#$max))\n\
    \  local round=0\n  while [[ $min -le $val ]]; do\n    ((min+=$step))\n    round=$((min%10))\n\
    \  done\n  local rounds=0\n  while [[ $min -le $max ]]; do\n    ((min+=$step))\n\
    \    round=$((min%10))\n    ((rounds++))\n  done\n  ((min--))\n  if (( rounds\
    \ == 0 )); then\n    min=$min\n  else\n    ((min++))\n  fi\n  ((max--))\n  if\
    \ (( rounds == 0 )); then\n    max=$max\n  else\n    ((max--))\n  fi\n  echo $((\
    \ min + $round ))", "  local x y\n\n  x=$1\n  y=$(echo $x | cut -d \".\" -f 1)\n\
    \  (( x==y )) && echo \"$x\"\n  (( y<x )) && echo $x\n  (( x<y )) && echo $y",
  "  local -n NUMBER=$1\n  local -n MAX=`echo $NUMBER | cut -d. -f1`\n  local -n MIN=`echo\
    \ $NUMBER | cut -d. -f2`\n  local -n MOD=`echo $MAX - $MIN`\n  local -n RES=`echo\
    \ $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n TEMP=`echo $RES % $MOD`\n\
    \  local -n DIFF=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n\
    \ MOD=`echo $TEMP % $MOD`\n  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo\
    \ $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n\
    \  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local\
    \ -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo\
    \ $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER\
    \ | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo $TEMP % $MOD`\n \
    \ local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN\
    \ {print $1*$2-$3}'`\n  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo\
    \ $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n\
    \  local -n DIFF=`echo $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local\
    \ -n TEMP=`echo $NUMBER | awk -F. 'BEGIN {print $1*$2-$3}'`\n  local -n DIFF=`echo\
    \ $TEMP % $MOD`\n  local -n FAR=`echo $DIFF % $MOD`\n  local -n TEMP=`echo $NUMBER\
    \ | awk -F. 'BEGIN {", "  local x\n  x=\"${1}\"\n  local closest\n  local closestdiff\n\
    \  local mindiff\n  local mindiffdiff\n  local int\n  local num\n  local numdiff\n\
    \  num=\"${x}\"\n  numdiff=\"0\"\n  numdiffdiff=\"0\"\n  while [ \"${num}\" !=\
    \ \"0\" ]; do\n    int=\"${num}\"\n    int=\"${int%.*}\"\n    if [ \"${int}\"\
    \ = \"0\" ]; then break; fi\n    closest=\"${int}\"\n    closestdiff=\"0\"\n \
    \   mindiff=\"${closest}\"\n    mindiffdiff=\"0\"\n    while [ \"${closest}\"\
    \ != \"0\" ]; do\n      num=\"${num}.${closest}\"\n      numdiff=\"${numdiff}.${closestdiff}\"\
    \n      numdiffdiff=\"${numdiffdiff}.${mindiffdiff}\"\n      closest=\"${closest%%.*}\"\
    \n      closestdiff=\"${closestdiff%%.*}\"\n      mindiff=\"${mindiff}.${closest}\"\
    \n      mindiffdiff=\"${mindiffdiff}.${closestdiff}\"\n    done\n    local result\n\
    \    if [ \"${mindiff}\" -lt \"${x}\" ]; then break; fi\n    num=${mindiff}\n\
    \    numdiff=${mindiffdiff}\n  done\n  echo \"${x}\"", "    local number=$1\n\
    \    local closest\n    # Round number away from zero\n    number=${number%.*}\n\
    \    closest=$(( ${number} - ${number%%.*} ))\n    # Handle special cases\n  \
    \  if [[ \"$number\" == \"0\" ]]; then\n        closest=0\n    elif [[ \"$number\"\
    \ == \"-0\" ]]; then\n        closest=-0\n    elif [[ \"$number\" == \"-0\" ]];\
    \ then\n        closest=--0\n    fi\n    echo $closest", "  local number=\"$1\"\
    \n  local integer=\"$2\"\n  local direction=\"$3\"\n  if [ \"$direction\" == \"\
    up\" ]; then\n    # If the value is greater than the integer then return integer.\n\
    \    if [ \"$number\" -gt \"$integer\" ]; then\n      echo \"$integer\"\n    fi\n\
    \  fi\n  if [ \"$direction\" == \"down\" ]; then\n    # If the value is less than\
    \ the integer then return integer.\n    if [ \"$number\" -lt \"$integer\" ]; then\n\
    \      echo \"$integer\"\n    fi\n  fi", "  local num=\"$1\"\n  shift\n  local\
    \ min=\"$1\"\n  shift\n  local max=\"$1\"\n  shift\n  local diff\n\n  # make sure\
    \ given numbers are all integers\n  if [[ $num =~ ^[0-9]+$ ]]; then\n    local\
    \ diff\n    local min\n    local max\n    diff=$(echo \"$num - $min\" | bc -l)\n\
    \    if [[ $diff -gt 0 ]]; then\n      min=$(( min + 1 ))\n      diff=$(echo \"\
    $num - $min\" | bc -l)\n    fi\n    if [[ $diff -lt 0 ]]; then\n      max=$((\
    \ max + 1 ))\n      diff=$(echo \"$max - $num\" | bc -l)\n    fi\n    if [[ $diff\
    \ -eq 0 ]]; then\n      echo \"$min\"\n    else\n      echo \"$max\"\n    fi\n\
    \  else\n    echo \"$num\"\n  fi", "    local num=$1\n    local prev=$((num-1))\n\
    \    local next=$((num+1))\n    if [ \"$prev\" == \"$num\" -o \"$next\" == \"\
    $num\" ]; then\n        echo \"$num\"\n        return 0\n    fi\n    if [ \"$prev\"\
    \ == \"$next\" ]; then\n        echo \"$num\"\n        return 0\n    fi\n\n  \
    \  if [ \"$prev\" == \"0\" -o \"$num\" == \"0\" ]; then\n        echo \"0\"\n\
    \        return 0\n    fi\n\n    local temp=$((num+1))\n    local temp2=$((num-1))\n\
    \    local temp3=$((num-1))\n    local temp4=$((num+1))\n    local temp5=$((num+1))\n\
    \    local temp6=$((num+1))\n    local temp7=$((num+1))\n    local temp8=$((num+1))\n\
    \    local temp9=$((num+1))\n    local temp10=$((num+1))\n    local temp11=$((num+1))\n\
    \    local temp12=$((num+1))\n    local temp13=$((num+1))\n    local temp14=$((num+1))\n\
    \    local temp15=$((num+1))\n\n    while true; do\n        if [ \"$prev\" ==\
    \ \"$temp\" ]; then\n            echo \"$temp\"\n            return 0\n      \
    \  fi\n\n        if [ \"$next\" == \"$temp\" ]; then\n            echo \"$temp\"\
    \n            return 0\n        fi\n\n        if [ \"$prev\" == \"$temp3\" ];\
    \ then\n            echo \"$temp3\"\n            return 0\n        fi\n\n    \
    \    if [ \"$next\" == \"$temp3\" ]; then\n            echo \"$temp3\"\n     \
    \       return 0\n        fi\n\n        if [ \"$prev\" == \"$temp7\" ]; then\n\
    \            echo \"$temp7\"\n            return 0\n        fi\n\n        if [\
    \ \"$next\" == \"$temp7\" ]; then\n            echo \"$temp7\"\n            return\
    \ 0\n        fi\n\n        if [ \"$prev\" == \"$temp9\" ]; then\n            echo\
    \ \"$temp9\"\n            return 0\n        fi\n\n        if [ \"$next\" == \"\
    $temp9\" ]; then\n            echo \"$temp9\"\n            return 0\n        fi\n\
    \n        if [ \"$prev\" == \"$temp11\" ]; then\n            echo \"$temp11\"\n\
    \            return 0\n        fi\n\n        if [ \"$next\" == \"$temp11\" ];\
    \ then\n            echo \"$temp11\"\n            return 0\n        fi\n\n   \
    \     if [ \"$prev\" == \"$temp13\" ]; then\n            echo \"$temp13\"\n  \
    \          return 0\n        fi\n\n        if [ \"$next\" == \"$temp13\" ]; then\n\
    \            echo \"$temp13\"\n            return 0\n        fi\n\n        if\
    \ [ \"$prev\" == \"$temp15\" ]; then\n            ", "    local string=\"$1\"\n\
    \    if [[ $string == +([[:digit:]]) ]]; then\n        echo \"$string\"\n    \
    \    return\n    fi\n    local -n string=\"$1\"\n    local -n number=\"${string#-}\"\
    \n    local -n number=\"${number%+}\"\n    local -n number=\"${number#+}\"\n \
    \   local -n number=\"${number%%.*}\"\n    local -n number=\"${number%.*}\"\n\
    \    echo \"$number\"", "\tlocal string=\"$1\"\n\tlocal prev_integer\n\tlocal\
    \ number\n\tlocal next_integer\n\tprev_integer=\"$(echo \"$string\" | sed 's/^\
    \ *//')\"\n\tnumber=\"$(echo \"$string\" | sed 's/ *$//')\"\n\tnext_integer=\"\
    $(echo \"$number\" | sed 's/^ *//')\"\n\tif [[ \"$prev_integer\" -gt \"$next_integer\"\
    \ ]]; then\n\t\techo $prev_integer\n\telse\n\t\techo $next_integer\n\tfi", " \
    \   local VALUE=$1\n    local MIN=$2\n    local MAX=$3\n    local RESULT\n   \
    \ local FARTHER\n    local ABOVE\n    local ABOVE2\n    local BELOW\n    local\
    \ BELOW2\n    local CLOSEST\n    local CLOSEST2\n    local ABOVEDIFF\n    local\
    \ BELOWDIFF\n    local CLOSESTDIFF\n    local ABOVEDIFF2\n    local BELOWDIFF2\n\
    \    local CLOSESTDIFF2\n    local NUM\n    local MAXDIFF\n    local MAXDIFF2\n\
    \    local MAXDIFF3\n    local MAXDIFF4\n    local NUM2\n    NUM=${VALUE}\n  \
    \  MAXDIFF=${MAX}\n    MAXDIFF2=${MAX}\n    MAXDIFF3=${MAX}\n    MAXDIFF4=${MAX}\n\
    \    NUM2=${VALUE}\n    ABOVE=$(( ${NUM} + ${MIN} ))\n    BELOW=$(( ${NUM} - ${MIN}\
    \ ))\n    CLOSEST=$(( ${NUM} - ${MAX} ))\n    ABOVE2=$(expr ${ABOVE} + 1)\n  \
    \  BELOW2=$(expr ${BELOW} + 1)\n    CLOSEST2=$(expr ${CLOSEST} + 1)\n    ABOVEDIFF=$((\
    \ ${ABOVE} - ${ABOVE2} ))\n    ABOVEDIFF2=$(( ${ABOVE} - ${ABOVE2} ))\n    BELOWDIFF=$((\
    \ ${BELOW} - ${BELOW2} ))\n    BELOWDIFF2=$(( ${BELOW} - ${BELOW2} ))\n    CLOSESTDIFF=$((\
    \ ${CLOSEST} - ${CLOSEST2} ))\n    CLOSESTDIFF2=$(( ${CLOSEST} - ${CLOSEST2} ))\n\
    \    if [ ${ABOVE} -lt ${MIN} ]; then\n        RESULT=${ABOVE}\n    else\n   \
    \     if [ ${ABOVE} -eq ${MAX} ]; then\n            RESULT=${ABOVE2}\n       \
    \ else\n            if [ ${BELOW} -lt ${MIN} ]; then\n                RESULT=${BELOW}\n\
    \            else\n                if [ ${BELOW} -eq ${MAX} ]; then\n        \
    \            RESULT=${BELOW2}\n                else\n                    if [\
    \ ${CLOSEST} -lt ${MIN} ]; then\n                        RESULT=${CLOSEST}\n \
    \                   else\n                        if [ ${CLOSEST} -eq", "  local\
    \ x\n  local y diff rounded_x\n  x=$1\n  y=$2\n  diff=$(echo \"scale=8; $x-$y\"\
    \ | bc)\n  rounded_x=$(( ($x + $y) / 2 ))\n  echo $rounded_x if [[ $rounded_x\
    \ -eq $x ]] || [[ $rounded_x -eq $y ]]; then\n    return 0\n  else\n    echo $rounded_x\n\
    \  fi", "  local x=\"$1\"\n  local -n y=$2\n  local -n i=0\n  local -n min_diff\n\
    \  local -n d\n\n  y=${y%:*}\n\n  while true; do\n    ((i++))\n    ((d=x*i+y))\n\
    \    diff=$(( d - y%d ))\n    [[ -n \"$min_diff\" ]] && [[ \"$diff\" -lt \"$min_diff\"\
    \ ]] || min_diff=$diff\n    [[ $diff -eq 0 ]] && break\n    ((y+=d%:))\n  done\n\
    \n  echo \"$x\"\n  [[ -n \"$min_diff\" ]] && echo \"$min_diff\"", "  # Split $1\
    \ into individual components and convert them into\n  # integers.\n  local -a\
    \ components\n  IFS='.' read -r -a components <<<\"$1\"\n  local -a components_sorted\n\
    \  IFS='.' read -r -a components_sorted <<<\"${components[@]}\" \\\n    | sort\
    \ -n -k 1 --random-sort\n  local -a numbers\n  local -a numbers_sorted\n  local\
    \ -a closest_integers\n  local -a closest_integers_sorted\n  local -a rounding_factor\n\
    \  local -a rounded_values\n  local -a rounded_values_sorted\n  local -a rounded_integers\n\
    \  local -a rounded_integers_sorted\n  for component in \"${components[@]}\";\
    \ do\n    local -a components\n    if [ -z \"$component\" ]; then\n      # Handle\
    \ a zero input by returning the original input.\n      closest_integers_sorted+=(\"\
    $1\")\n      rounded_values_sorted+=(\"$1\")\n      rounded_integers_sorted+=(\"\
    $1\")\n      continue\n    fi\n    local -a components_sorted\n    IFS='.' read\
    \ -r -a components_sorted <<<\"${components[@]}\" \\\n      | sort -n -k 1 --random-sort\n\
    \    local -a components\n    local -a numbers_sorted\n    local -a closest_integers_sorted\n\
    \    local -a rounding_factor\n    local -a rounded_values\n    local -a rounded_values_sorted\n\
    \    local -a rounded_integers\n    local -a rounded_integers_sorted\n    # If\
    \ the component has a number in it\n    if [ -n \"${components_sorted[0]}\" ];\
    \ then\n      # Take the lowest of the two numbers and round it towards zero.\n\
    \      local number=\"${components_sorted[0]}\"\n      local rounded_number=\"\
    ${number}.0\"\n      local rounded_number=\"${rounded_number//\\.[0-9]*$/.}\"\n\
    \      # Take the absolute value of that number.\n      number=\"${number:-0}\"\
    \n      rounded_number=\"${rounded_number:-0}\"\n      # If that number is equidistant\
    \ from two integers, round it away\n      # from zero.\n      if (( number < rounded_number\
    \ )); then\n        rounded_number=\"$(( $number + $rounded_number + 1 ))\"\n\
    \      fi\n      # Add that number to the numbers array.\n      numbers_sorted+=(\"\
    $number\")\n      # ", "  local input=$1\n  local output=$(input)\n  local remainder\n\
    \  local closest_integer=0\n  local closest_double=0\n  while [[ -n $output ]];\
    \ do\n    remainder=$(( $output % 1 ))\n    closest_integer=$(( $closest_integer\
    \ + 1 ))\n    closest_double=$(( $closest_double + ( $output / $remainder ) ))\n\
    \    output=$( (( $output / 1 )) - 1 )\n  done\n  echo \"$closest_integer\"",
  "  local num=$1\n  local integers\n  local min\n  local max\n  integers=$(echo $num\
    \ | sed \"s/^\\([0-9]*\\)\\.\\([0-9]*\\)/\\1 \\2/\")\n  min=$(echo \"$integers\"\
    \ | cut -d \" \" -f1)\n  max=$(echo \"$integers\" | cut -d \" \" -f2)\n  if [\
    \ -z \"$max\" ]; then\n    echo \"$min\"\n  else\n    if [ \"$min\" -le \"$max\"\
    \ ]; then\n      echo $(echo \"$min + 1\" | bc)\n    else\n      echo $(echo \"\
    $min - 1\" | bc)\n    fi\n  fi", "    local number=$1\n    local number=${number%.*}\n\
    \    local diff=$(expr $(echo \"($number - $2) / $1\" | bc -l))\n    local closest=\n\
    \    local sign=\n    if [ $diff -lt 0 ]; then\n      closest=$(( $number + $diff\
    \ ))\n      sign=-\n    elif [ $diff -gt 0 ]; then\n      closest=$(( $number\
    \ - $diff ))\n      sign=\n    else\n      closest=$number\n      sign=\n    fi\n\
    \    echo $(( $closest * $sign ))\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ", "   \
    \ local num=\"$1\"\n    local min=\"$2\"\n    local max=\"$3\"\n    local diff\n\
    \    local diff_reset\n    local diff_reset_val\n    local closest_integer\n \
    \   local closest_integer_val\n    local closest_integers\n    local closest_integer_vals\n\
    \n    diff=`echo \"$max-$min\" | bc`\n    if [ \"$diff\" -eq 0 ]\n    then\n \
    \       closest_integer=\"$min\"\n    elif [ \"$diff\" -gt 0 ]\n    then\n   \
    \     closest_integer=`echo \"$min+$diff/2\" | bc`\n    else\n        closest_integer=`echo\
    \ \"$max-$diff/2\" | bc`\n    fi\n    closest_integers=\"$closest_integer $closest_integer\
    \ $closest_integer $closest_integer\"\n    closest_integer_vals=$( echo \"$closest_integers\"\
    \ | tr ' ' '\\n' | sort -rn | tr '\\n' ' ')\n    closest_integer_val=$( echo \"\
    $closest_integer_vals\" | head -1 | tr -d '\\n')\n    closest_integer_vals=$(\
    \ echo \"$closest_integer_vals\" | tail -1 | tr -d '\\n')\n    diff_reset=$( echo\
    \ \"$diff/2\" | bc)\n    diff_reset_val=$( echo \"$diff_reset\" | tr -d '\\n'\
    \ | tr ' ' '\\n' | sort -rn | tr '\\n' ' ')\n    if [ \"$diff_reset_val\" -gt\
    \ 0 ]\n    then\n        closest_integers=$( echo \"$closest_integer_vals\" |\
    \ sed -ie \"s/$closest_integer_val $closest_integer_val $closest_integer_val $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_vals/\" )\n   \
    \ fi\n    closest_integer_vals=$( echo \"$closest_integers\" | tr ' ' '\\n' |\
    \ sort -rn | tr '\\n' ' ')\n    closest_integer_val=$( echo \"$closest_integer_vals\"\
    \ | head -1 | tr -d '\\n')\n    closest_integer_vals=$( echo \"$closest_integer_vals\"\
    \ | tail -1 | tr -d '\\n')\n    if [ \"$diff_reset_val\" -gt 0 ]\n    then\n \
    \       closest_integers=$( echo \"$closest_integer_vals\" | sed -ie \"s/$closest_integer_val\
    \ $closest_integer_val $closest_integer_val $closest_integer_val/$closest_integer_vals\
    \ $closest_integer_vals $closest_integer_vals $closest_integer_val/$", "  if [[\
    \ $1 =~ ^[+-]?[0-9]+\\.?[0-9]*$ ]]; then\n    local first=\"$1\"\n    # Make sure\
    \ that the first argument looks like a number\n    if ! [[ $first =~ ^[+-]?[0-9]+\\\
    .?[0-9]*$ ]]; then\n      echo \"$1 does not look like an integer\" >&2\n    \
    \  return 1\n    fi\n    # Make sure that the second argument looks like a number\n\
    \    if ! [[ $2 =~ ^[+-]?[0-9]+\\.?[0-9]*$ ]]; then\n      echo \"$2 does not\
    \ look like an integer\" >&2\n      return 1\n    fi\n    # Round away from zero\
    \ and make sure that its a number\n    # Round away from zero means you get closer\
    \ to the closest integer.\n    # For example: closest_integer(\"14.5\", \"14.4\"\
    ) should return 15\n    # closest_integer(\"-14.5\", \"14.4\") should return -15\n\
    \    if [[ $((first+second)) -gt 0 ]]; then\n      if [[ $((first+second)) -lt\
    \ $((first+first)) ]]; then\n        local closest=$((first+second))\n      elif\
    \ [[ $((first+second)) -lt 0 ]]; then\n        local closest=$((first+second))\n\
    \      else\n        local closest=$((first+second))\n      fi\n      if [[ $((first+second))\
    \ -eq $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   fi\n      local closest=$((closest))\n    else\n      if [[ $((first+second))\
    \ -lt $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   elif [[ $((first+second)) -lt 0 ]]; then\n        local closest=$((first+second))\n\
    \      else\n        local closest=$((first+second))\n      fi\n      if [[ $((first+second))\
    \ -eq $((first+first)) ]]; then\n        local closest=$((first+second))\n   \
    \   fi\n      local closest=$((closest))\n    fi\n    echo $closest\n  else\n\
    \    echo \"$1 does not look like an integer\" >&2\n    return 1\n  fi", "   \
    \ echo \"$1\" | awk -v x=$1 -v n=3 -v d=$(($n - 1)) '{\n\tprint $1 < 0 ? $x -\
    \ $d : $x + $d;\n    }'", "    local IFS=.\n    # split $1 into integer and fraction\
    \ parts\n    local n=$(echo $1 | cut -d . -f 1-2)\n    local f\n    local parts=()\n\
    \    # loop through all parts of $n\n    for part in $n; do\n        # split $part\
    \ into an integer part and fraction part\n        local int_part=$(echo $part\
    \ | cut -d . -f 1)\n        local frac_part=$(echo $part | cut -d . -f 2- | sed\
    \ 's/^0*//')\n        # round frac_part up based on the integer\n        frac_part=$(bc\
    \ <<< \"$frac_part + $int_part\")\n        # push the rounded up fraction part\
    \ into the array\n        parts+=(\"$frac_part\")\n    done\n    # round $parts\
    \ up to the nearest integer\n    parts=$(echo $parts | tr \" \" \"\\n\" | sort\
    \ -n | tail -1)\n    # concatenate integer and fractional parts back together\
    \ and return\n    echo \"${parts[0]}.$parts\"", "    local value_string=$1\n \
    \   local sign=$(echo $value_string | awk '{print $1}')\n    local value=$(echo\
    \ $value_string | awk '{print $2}')\n    local diff\n    local rounding_diff\n\
    \n    # If the given number was already an integer, return it\n    if [[ ${value}\
    \ == ${value} ]]; then\n        echo \"$value_string\"\n        return 0;\n  \
    \  fi\n\n    # If the given number is negative, round it to the\n    # closest\
    \ integer below zero.\n    if [[ $sign == \"-\" ]]; then\n        value=$(echo\
    \ $value | bc -l)\n        rounding_diff=$(echo $((value + 0.5)) | bc -l)\n  \
    \      diff=$(echo $((rounding_diff - value)) | bc -l)\n    fi\n\n    # Convert\
    \ the given string to an integer.\n    value=$(echo $value | bc -l)\n\n    # If\
    \ the given value is less than 0, return it as-is\n    if [[ $diff -lt 0 ]]; then\n\
    \        echo \"$value_string\"\n        return 0;\n    fi\n\n    # If the given\
    \ value is larger than $value, return it\n    if [[ $diff -gt $value ]]; then\n\
    \        echo \"$value_string\"\n        return 0;\n    fi\n\n    # If we got\
    \ here, the given value is not equidistant from\n    # two integers, so return\
    \ the integer closest to zero.\n    diff=$(echo $((diff + 0.5)) | bc -l)\n   \
    \ rounding_diff=$(echo $((diff - value)) | bc -l)\n    diff=$(echo $((rounding_diff\
    \ - value)) | bc -l)\n\n    echo \"$value_string\"", "  local number=$1\n  [[\
    \ \"$number\" =~ ^-?[0-9]+$ ]] || return 1\n  local closest\n  local closestNumber\n\
    \  local minDiff\n  local numString\n\n  minDiff=1\n  numString=$number\n  while\
    \ [[ \"$numString\" =~ ^-?[0-9]+$ ]]; do\n    closestNumber=$(( $numString|$(echo\
    \ \"$numString - $closest\"|bc -l) ))\n    closest=$closestNumber\n    minDiff=$((\
    \ $minDiff|$(echo \"$numString - $closest\"|bc -l) ))\n    numString=$(echo \"\
    $closestNumber + 1\"|bc -l )\n  done\n\n  echo \"$closest\"", "  local number=$1\n\
    \  if [[ $# -eq 1 ]]; then\n    echo \"$1\"\n  else\n    # Remove all non-digits\
    \ to avoid floating point problems\n    local number2=\"${number//[^0-9.]/}\"\n\
    \    echo \"$(expr $(echo \"$number2 - $number\" | bc -l) / $(echo \"$number2\
    \ - $number\" | bc -l))\"\n  fi", "  local string=\"$1\"\n  local number=\"$2\"\
    \n  local closest\n  local diff\n  local closestdiff\n  local prevdiff\n\n  #\
    \ Convert input string to numeric value\n  read -r number < <(echo \"$string\"\
    \ | tr '.' ' ')\n  prevdiff=-1\n  closestdiff=-1\n  closest=$number\n\n  # Iterate\
    \ over numbers\n  for number in $(seq 1 $((${#number} - 1))); do\n    diff=$((${number}\
    \ - number))\n\n    if [[ $diff -eq 0 || diff -eq $((${#number} - 1)) ]]; then\n\
    \      # If diff is zero, then we've found the closest number\n      # so exit\
    \ the loop\n      echo \"$number\"\n      return\n    fi\n\n    if [[ $diff -gt\
    \ $prevdiff ]]; then\n      prevdiff=$diff\n      closestdiff=$diff\n      closest=$number\n\
    \    fi\n  done", "  local val=\"$1\"\n  if [ -z \"$val\" ]; then\n    echo \"\
    ERROR: Argument $1 is not set.\" 1>&2\n    return 1\n  fi\n  local -a integers=(\
    \ )\n  local integer\n  integer=\"$(echo \"$val\" |\n      awk 'BEGIN {\n    \
    \      FS = \":\"\n          for (i = 1; i <= NF; i++) {\n              nums[i]\
    \ = $1\n              printf \"%s\\t\", nums[i]\n          }\n      }\n      function\
    \ distance(a, b) {\n          sum = 0\n          for (i = 1; i <= NF; i++) {\n\
    \              sum += $i * $i\n          }\n          sq = sum * sum\n       \
    \   return sq * (a - b) * (a - b) / (sqrt sq)\n      }\n      function closest()\
    \ {\n          for (index = 1; index <= NF; index++) {\n              dist = distance(index-1,\
    \ index)\n              if (dist > distance(a,b)) {\n                  a = index\n\
    \              }\n          }\n      }\n      closest(5)\n      closest(6)\n \
    \     closest(7)\n      closest(8)\n      closest(9)\n      closest(10)\n    \
    \  closest(11)\n      closest(12)\n      closest(13)\n      closest(14)\n    \
    \  closest(15)\n      closest(16)\n      closest(17)\n      closest(18)\n    \
    \  closest(19)\n      closest(20)\n      closest(21)\n      closest(22)\n    \
    \  closest(23)\n      closest(24)\n      closest(25)\n      closest(26)\n    \
    \  closest(27)\n      closest(28)\n      closest(29)\n      closest(30)\n    \
    \  closest(31)\n      closest(32)\n      closest(33)\n      closest(34)\n    \
    \  closest(35)\n      closest(36)\n      closest(37)\n      closest(38)\n    \
    \  closest(39)\n      closest(40)\n      closest(41)\n      closest(42)\n    \
    \  closest(43)\n      closest(44)\n      closest(45)\n      closest(46)\n    \
    \  closest(47)\n      closest(48)\n      closest(49)\n      closest(50)\n    \
    \  closest(51)\n      closest(52)\n      closest(53)\n      closest(54)\n    \
    \  closest(55)\n      closest(56)\n      closest(57)\n      closest(58)\n    \
    \  closest(59)\n      closest(60)\n      closest(61)\n      closest(62)\n    \
    \  closest(63)\n      close", "    local val=$1\n    local minval=0\n    local\
    \ maxval=${#val}\n    local lastval=${#val}\n    local rounding=0\n    while [\
    \ $lastval -gt $minval ]; do\n        lastval=$((lastval-1))\n    done\n    while\
    \ [ $lastval -gt $maxval ]; do\n        lastval=$((lastval+1))\n    done\n   \
    \ local roundval=$((lastval+rounding))\n    if [ $val -eq $roundval ]; then\n\
    \        echo $roundval\n        return\n    fi\n    while [ $minval -le $maxval\
    \ ]; do\n        local midval=$((minval+maxval)/2)\n        local diff=$((midval-val))\n\
    \        if [ $diff -eq 0 ]; then\n            echo $roundval\n            echo\
    \ $roundval\n            return\n        elif [ $diff -eq $((minval-roundval))\
    \ ]; then\n            minval=$((midval))\n        elif [ $diff -eq $((maxval-roundval))\
    \ ]; then\n            maxval=$((midval))\n        fi\n    done", "  local -a\
    \ arr=( $1 )\n  local closest\n  for n in \"${arr[@]}\"; do\n    (( closest+=n\
    \ ))\n  done\n  closest=$(echo \"$closest\" | bc)\n  [[ $closest -eq 0 ]] && closest=$((\
    \ 10#1 ))\n  (( $closest > $2 )) && closest=$(( $closest - 1 ))\n  echo \"$closest\"",
  "  if [ \"$#\" -eq 1 ]\n  then\n    number=$1\n  else\n    echo \"Need one argument.\"\
    \n    exit 1\n  fi\n\n  case \"$number\" in\n    (-?[0-9]+)([.][0-9]+)?([eE][-+]?[0-9]+)?)\n\
    \      echo \"$number\"\n      ;;\n    *)\n      echo \"$number\" | sed -e 's/^\
    \ *//' -e 's/ *$//'\n      ;;\n  esac", "    local number=\"$1\"\n    local num=\"\
    ${number%.*}\"\n    local num=\"${num#*-}\"\n    local num=\"${num%.0}\"\n   \
    \ local num=\"${num%.}\"\n    local num=\"${num#.}\"\n    local num=\"${num#,}\"\
    \n    local num=\"${num%,}\"\n    local num=\"${num#+}\"\n    local num=\"${num%+}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\
    \n    local num=\"${num%-}\"\n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\
    \n    local num=\"${num#-}\"\n    local num=\"${num%-}\"\n    local num", "  local\
    \ string=$1\n  local numstring=\"${string%.*}\"\n  local num=\"${numstring#*.}\"\
    \n  local closest=\"${string#$num}\"\n  local int\n  if [ -z \"$closest\" ]\n\
    \  then\n    closest=\"${closest}\"\n  fi\n  local num2\n  num2=$(echo $closest\
    \ | sed -e \"s/^0//\" -e \"s/^-//\")\n  local diff\n  diff=$(echo \"${closest}\
    \ - ${num2}\"| bc)\n  local diffabs\n  diffabs=$(echo \"${diff}\" | bc | xargs\
    \ | head -1)\n  if [ -z \"$diffabs\" ]\n  then\n    int=\"${closest}\"\n  else\n\
    \    int=\"${closest}+${diffabs}\"\n  fi\n  echo \"$int\"", "  local number=$1\n\
    \  local integer_result=0\n  local previous_result=0\n  local diff\n\n  while\
    \ [[ $integer_result -eq 0 ]]; do\n    integer_result=$(( $(( $number / 10 ))\
    \ % 10 ))\n    previous_result=$(( $(( $number / 10 )) % 10 ))\n    diff=$(( $number\
    \ - $previous_result ))\n    number=$(( $number - diff ))\n  done\n  echo \"$integer_result\"",
  "  local value\n  local -n x=\"$1\"\n  x=${x//./}\n  local -n y=\"$1\"\n  y=${y//./}\n\
    \  local -n z=\"$1\"\n  z=${z//./}\n  if [ \"$x\" -eq \"$y\" ]\n  then\n    if\
    \ [ \"$x\" -eq \"$z\" ]\n    then\n      echo \"$x\"\n    else\n      local -n\
    \ f=\"$x\"\n      f=$(( ${f} - 1 ))\n      echo \"$f\"\n    fi\n  else\n    if\
    \ [ \"$x\" -eq \"$z\" ]\n    then\n      local -n g=\"$y\"\n      g=$(( ${g} -\
    \ 1 ))\n      echo \"$g\"\n    else\n      local -n h=\"$z\"\n      h=$(( ${h}\
    \ - 1 ))\n      echo \"$h\"\n    fi\n  fi", "  local number=$1\n  local digits=$((\
    \ 10#$number ))\n  local factor=10\n  local quotient\n  local distance\n  local\
    \ result\n  local difference\n  local closest\n\n  local previous\n  local current\n\
    \  local previousDistance\n  local currentDistance\n\n  local min\n  local max\n\
    \  local maxDistance\n\n  local range\n  local maxDistance\n  local minDistance\n\
    \  local maxDifference\n  local minDifference\n\n  local digitCount\n\n  while\
    \ (( digits >= 10 )); do\n    digitCount=$(( 10#$digits ))\n    digits=( ( 10#$digits\
    \ ) - 1 )\n    factor=$(muldiv $factor 10)\n\n    if [ $digits == 0 ]; then\n\
    \      break\n    fi\n  done\n\n  # Check if the number is actually an integer\n\
    \  if [ $digits -lt 10 ]; then\n    echo \"Error: Number must be an integer.\"\
    \ > /dev/stderr\n    return 1\n  fi\n\n  # Round away from zero if equidistant\
    \ to two other integers\n  if [ -z \"$min\" ] || [ -z \"$max\" ]; then\n    previous=$(muldiv\
    \ $number $factor)\n    previous=( ( 10#$previous ) - 1 )\n    previous=$(( 10#$previous\
    \ ))\n\n    if [ \"$previous\" = \"$number\" ]; then\n      echo \"$number\" >\
    \ /dev/stderr\n      return $number\n    fi\n\n    while [ \"$previous\" -gt \"\
    $min\" ] && [ \"$previous\" -lt \"$max\" ]; then\n      previous=$(muldiv $previous\
    \ $factor)\n      previous=( ( 10#$previous ) - 1 )\n      previous=$(( 10#$previous\
    \ ))\n    done\n\n    if [ \"$previous\" == \"$min\" ]; then\n      min=$number\n\
    \    elif [ \"$previous\" == \"$max\" ]; then\n      max=$number\n    fi\n  fi\n\
    \n  if [ \"$min\" = \"$max\" ]; then\n    echo \"$number\" > /dev/stderr\n   \
    \ return $number\n  fi\n\n  range=$(( 10#$max - $min ))\n  maxDistance=$(( 10#$range/2\
    \ ))\n\n  while [ \"$min\" -lt \"$max\" ] && [ \"$min\" -lt \"$maxDistance\" ];\
    \ then\n    current=$(muldiv $number $factor)\n    currentDistance=$(( 10#$current/2\
    \ ))\n\n    if [ \"$min\" = \"$current\" ]; then\n      echo \"$number\" > /dev/stderr\n\
    \      return $number\n    fi\n\n    if [ \"$minDistance\" -eq \"$currentDistance\"\
    \ ]; then\n      min=$number\n    fi\n\n    if [ \"$maxDistance\" -eq \"$currentDistance\"\
    \ ]; then", "    local number=$1\n    local output=$(\n        # Round number\
    \ down\n        if [[ ${number} -lt 1 ]]; then\n            ${number}\n      \
    \  fi\n        # Divide by 2 until number is odd\n        while [[ \"${number}%2\"\
    \ == \"1\" ]]; do\n            number=$((${number}/2))\n        done\n       \
    \ # Divide by 2 until number is even\n        while [[ \"${number}%2\" != \"0\"\
    \ ]]; do\n            number=$((${number}/2))\n        done\n        # Return\
    \ result (rounded away from zero)\n        ${number#0}\n    )\n    echo \"$output\"",
  "  local number=$1\n  if [[ \"${number}\" =~ ^-?[0-9]+$ ]]; then\n    if [[ \"$number\"\
    \ -gt \"$number1\" ]] || [[ \"$number\" -lt \"$number2\" ]]; then\n      number1=$number\n\
    \    else\n      number2=$number\n    fi\n  else\n    echo \"${number} is not\
    \ a number\"\n    return 1\n  fi\n  local closest_integer=$(( number1 + number2\
    \ ))\n  echo $closest_integer", "  local v=$1\n  local i=`echo $v | awk -F. '{print\
    \ $1}'`\n  local j=`echo $v | awk -F. '{print $2}'`\n  local k=`echo $v | awk\
    \ -F. '{print $3}'`\n  if [ \"$i\" == \"$j\" ]; then\n    if [ \"$i\" == \"$k\"\
    \ ]; then\n      i=$(( $i + 1 ))\n    else\n      i=$(( $i - 1 ))\n    fi\n  else\n\
    \    if [ \"$j\" == \"$k\" ]; then\n      j=$(( $j + 1 ))\n    else\n      j=$((\
    \ $j - 1 ))\n    fi\n  fi\n  echo $i", "\tlocal NUMBER=$1\n\tlocal CLOSEST_VALUE=$2\n\
    \tlocal NUMBER_FLOAT=$(( ${NUMBER} / 10 ))\n\tlocal NUMBER_INT=$(( ${NUMBER} %\
    \ 10 ))\n\n\tlocal CLOSEST_INTEGER=$(( ${CLOSEST_VALUE} - ${NUMBER_FLOAT} ))\n\
    \n\tlocal CLOSEST_INTEGER_STRING=$(( ${CLOSEST_INTEGER} + ${NUMBER_INT} ))\n\t\
    local CLOSEST_INTEGER_STRING=\"$( printf \"%03d\" ${CLOSEST_INTEGER_STRING} )\"\
    \n\n\techo \"${CLOSEST_INTEGER_STRING}\"", "    local number=\"${1}\"\n    local\
    \ diff\n\n    local min1=\"${1}\"\n    local min2=\"${min1}\"\n    local max1=\"\
    ${number}\"\n    local max2=\"${number}\"\n    local difference1=\"${1}\"\n  \
    \  local difference2=\"${1}\"\n\n    # Calculate the difference between the numbers\n\
    \    while [[ \"${min1}\" > \"${max1}\" ]]; do\n        ((difference1++))\n  \
    \      ((min1--))\n    done\n    while [[ \"${min2}\" > \"${max2}\" ]]; do\n \
    \       ((difference2--))\n        ((max2++))\n    done\n\n    # Calculate the\
    \ difference between the two\n    difference1=\"$((difference1 - difference2))\"\
    \n    if [[ -z \"${difference1}\" ]]; then\n        return 1\n    fi\n\n    #\
    \ Get the closest integer\n    diff=\"$((min1 + difference1))\"\n\n    case \"\
    ${diff}\" in\n        0)\n            echo \"${number}\"\n        ;;\n       \
    \ -0)\n            echo \"${min1}\"\n        ;;\n        *)\n            echo\
    \ \"${min1}\"\n        ;;\n    esac", "  local IFS=.\n  echo \"${1%%-*}\"\n  local\
    \ num=\"${1#*-}\"\n  local num2=${1#*.}\n  local numdiff=$(( num - num2 ))\n \
    \ if [ -z \"$num2\" ]; then\n    echo \"0\"\n  fi\n  local numstr=$(( numdiff\
    \ + num2 ))\n  local numstr2=$(printf \"%.0f\" $numstr)\n  echo \"$numstr2\"",
  "  local number=$1\n  local diff\n  local diff1\n  local diff2\n\n  echo \"${number}|$(echo\
    \ \"${number}\" | awk -F. '{print $1}')\"\n  echo \"${number}|$(echo \"${number}\"\
    \ | awk -F. '{print $1}')\"\n  diff=$((10#${number}|$(echo \"${number}\" | awk\
    \ -F. '{print $1}')))\n  diff1=$((${number}|$(echo \"${number}\" | awk -F. '{print\
    \ $1}')))\n  diff2=$((10#${number}|$(echo \"${number}\" | awk -F. '{print $1}')))\n\
    \  echo \"${diff}|${diff1}|${diff2}\"\n\n  # If diff < 0, then we're in the negative\
    \ direction so we need to add\n  # 10 to diff. Otherwise, we're in the positive\
    \ direction, so it's the\n  # opposite.\n  if (( diff < 0 )); then\n    ((diff\
    \ += 10))\n  else\n    ((diff -= 10))\n  fi\n\n  echo \"${diff}|${diff1}|${diff2}\"",
  "  local string=\"$1\"\n  local diff\n  local min\n\n  # convert input string to\
    \ float\n  local float_val=\"$string\"\n  float_val=\"$((float_val / 10))\"\n\n\
    \  # if first integer is greater than second integer\n  if [[ $string -gt $((\
    \ $string + .5 )) ]]; then\n    # return second integer\n    echo $string\n  \
    \  return\n  fi\n\n  # if first integer is less than second integer\n  if [[ $string\
    \ -lt $(( $string - .5 )) ]]; then\n    # return second integer\n    echo $string\n\
    \    return\n  fi\n\n  # if values are equidistant from two integers\n  # determine\
    \ which one is closer\n  if [ $(( $string - $float_val )) -le $(( $float_val -\
    \ $string )) ]; then\n    # return first integer\n    echo $string\n    return\n\
    \  fi\n\n  # if values are equidistant from two integers\n  # determine which\
    \ one is closer\n  if [ $(( $string - $float_val )) -ge $(( $float_val - $string\
    \ )) ]; then\n    # return second integer\n    echo $string\n    return\n  fi\n\
    \n  # if values are equidistant from two integers\n  # determine which one is\
    \ closer\n  if [ $string -eq $float_val ]; then\n    echo $string\n    return\n\
    \  fi", "    local num=$1\n    local min\n    local max\n    min=$((${num}-1))\n\
    \    max=$((${num}+1))\n    # find min and max if they're integers\n    # otherwise\
    \ find min and max if they're floats\n    if [[ $((${min#0}%1)) == 1 && $((${max#0}%1))\
    \ == 1 ]]; then\n        local tmp_min=$((${min#0}))\n        local tmp_max=$((${max#0}))\n\
    \        local tmp_num\n        tmp_num=$(expr ${tmp_max} - ${tmp_min} + 1)\n\
    \        local tmp_ans\n        tmp_ans=$(expr ${num} - ${tmp_min})\n        #\
    \ find the closest number\n        local min_diff\n        local min_idx\n   \
    \     min_diff=$((${tmp_num} - ${num}))\n        min_idx=$((${tmp_ans} - ${num}))\n\
    \        if [[ ${min_diff} -eq 0 ]]; then\n            echo ${tmp_num}\n     \
    \   elif [[ ${min_diff} -gt 0 ]]; then\n            echo ${num}\n        elif\
    \ [[ ${min_diff} -lt 0 ]]; then\n            echo ${tmp_ans}\n        fi\n   \
    \ elif [[ $((${min#%.*}%1)) == 0 && $((${max#%.*}%1)) == 0 ]]; then\n        local\
    \ tmp_num\n        tmp_num=$(expr ${max} - ${min} + 1)\n        local tmp_ans\n\
    \        tmp_ans=$(expr ${num} - ${min})\n        # find the closest number\n\
    \        local min_diff\n        local min_idx\n        min_diff=$((${tmp_num}\
    \ - ${num}))\n        min_idx=$((${tmp_ans} - ${num}))\n        if [[ ${min_diff}\
    \ -eq 0 ]]; then\n            echo ${tmp_num}\n        elif [[ ${min_diff} -gt\
    \ 0 ]]; then\n            echo ${num}\n        elif [[ ${min_diff} -lt 0 ]]; then\n\
    \            echo ${tmp_ans}\n        fi\n    elif [[ $((${min#%.*}%1)) == 0 &&\
    \ $((${max#%.*}%1)) != 0 ]]; then\n        local tmp_num\n        tmp_num=$(expr\
    \ ${max} - ${min} + 1)\n        local tmp_ans\n        tmp_ans=$(expr ${num} -\
    \ ${min})\n        # find the closest number\n        local min_diff\n       \
    \ local min_idx\n        min_diff=$((${tmp_num} - ${num}))\n        min_idx=$((${tmp_ans}\
    \ - ${num}))\n        if [[ ${min_diff} -", "  local NUM=\"$1\"\n  local NUM2=\"\
    ${NUM}.0\"\n  NUM2=($NUM2)\n  local DIVISOR\n  local RESULT\n  local MIN\n  local\
    \ MAX\n  local REM\n  REM=$(( (${#NUM2[@]}-1) / 2 ))\n  while true; do\n    DIVISOR=$((\
    \ ${NUM2[$REM]} - ${NUM2[$((REM-1))]} ))\n    RESULT=$(( ${NUM} / $DIVISOR ))\n\
    \    if [ \"$RESULT\" = \"$NUM\" ]; then\n      MIN=$REM\n      MAX=$(( ${#NUM2[@]}\
    \ - 1 ))\n    elif [ \"$RESULT\" -gt \"$NUM\" ]; then\n      MIN=$(( ${#NUM2[@]}\
    \ - 1 ))\n      MAX=$REM\n    else\n      MIN=$(( ${#NUM2[@]} - 1 ))\n      MAX=$REM\n\
    \    fi\n    break\n  done\n  if [ \"$MIN\" = \"$MAX\" ]; then\n    echo \"$NUM\"\
    \n  else\n    echo \"${NUM}${NUM2[$MIN]}\"\n  fi", "  local number=$1\n  local\
    \ numbers=$( echo \"$number\" | sed 's/-?[0-9]\\([0-9.]*\\)/\\1/' )\n  local closest=$(\n\
    \    case \"$number\" in\n      # If the input is less than two, return it.\n\
    \      \"$number\"|\"\")\n      echo \"$number\"\n      ;;\n      \"$numbers\"\
    |\"\")\n      echo \"$number\"\n      ;;\n      *)\n      local dist\n      local\
    \ min\n      # Find the closest number that's not greater than the number\n  \
    \    # we're looking for.\n      min=$( echo \"$numbers\" | sed 's/^[^-]*-\\(.*\\\
    )/\\1/' )\n      dist=`echo \"$number-$min\" | bc`\n      echo \"$min\"\n    \
    \  ;;\n    esac\n  )", "  local num=\"${1}\"\n  (( num_sign=${num%%-*}; num=${num##*-}\
    \ ))\n  # Make sure that $num ends in decimal point\n  if [ \"$num_sign\" = \"\
    -\" ]; then\n    num=$(( 10#$num + 1 ))\n  else\n    num=$(( 10#$num - 1 ))\n\
    \  fi\n  # Test to see if $num is equidistant from two integers\n  # Note: if\
    \ two integers have a difference of less than 0.0001 then\n  # they are equidistant\n\
    \  local diff\n  if (( diff )); then\n    if (( diff < 0.0001 )); then\n     \
    \ echo \"$num\"\n    else\n      echo \"0\"\n    fi\n  else\n    echo $num\n \
    \ fi", "    echo -n \"$1\"\n    local -n num=$1\n    local -n prev=\"$num\"\n\
    \    local -n max\n    local -n dist\n    local -n pos\n    local -n closest\n\
    \n    num=$(echo \"$num\" | sed 's/\\./ /' | bc)\n    max=$(($num))\n    prev=0\n\
    \n    while [ \"$max\" -gt \"$prev\" ]; do\n        ((dist=$((max-prev)))) # calculate\
    \ the distance between `max` and `prev`\n        pos=$(( prev + dist/2 )) # calculate\
    \ the position of `max` within `prev`\n        closest=\"$pos\"\n        if [\
    \ \"$dist\" -eq \"$max\" ]\n        then\n            closest=$(( prev + dist\
    \ ))\n        fi\n        prev=$pos\n        max=$(( $max -1 ))\n    done\n  \
    \  echo \"$closest\"", "  local x=\"$1\"\n  if [[ $x =~ (^-?[0-9]+(\\.[0-9]+)?$|^[0-9]+(\\\
    .[0-9]+)?$) ]]; then\n    local num=\"$(echo \"$x\" | sed 's/^-?//;s/^\\.//')\"\
    \n    local max=\"$(echo \"$x\" | sed 's/^-?//;s/^\\.//')\"\n    while (( \"$num\"\
    \ > \"$max\" )) ; do\n      max=$(( max + 1 ))\n    done\n    while (( \"$num\"\
    \ < \"$max\" )) ; do\n      max=$(( max - 1 ))\n    done\n    echo \"$max\"\n\
    \  fi", "  local input=\"$1\"\n  local integer=\"\"\n  local closest=\"\"\n  local\
    \ distance=\"\"\n\n  if [ -z \"$input\" ] || [ \"${#input}\" -gt 2 ]; then\n \
    \   echo \"$0: Event argument missing or invalid or empty\" >&2\n    exit 1\n\
    \  fi\n\n  input=\"$input\"\n  integer=\"${input%%.*}\"\n\n  # Remove \".\" if\
    \ present (no fractional part)\n  if [ -z \"$integer\" ]; then\n    integer=\"\
    $input\"\n  fi\n\n  # Remove \"-\" if present (no negative sign allowed)\n  if\
    \ [ -z \"$integer\" ]; then\n    integer=\"$input\"\n  fi\n\n  # Remove leading\
    \ zeroes\n  if [ -z \"$integer\" ]; then\n    integer=\"$input\"\n  fi\n\n  #\
    \ Remove trailing zeroes\n  if [ -z \"$integer\" ]; then\n    integer=\"$input\"\
    \n  fi\n\n  # Get length of integer part\n  length=$(echo \"$integer\" | wc -w)\n\
    \n  # Remove \".\" if present\n  if [ -z \"$integer\" ]; then\n    integer=\"\
    $input\"\n  fi\n\n  case \"$integer\" in\n    -*)\n      echo \"$0: Invalid decimal\
    \ input \\\"$integer\\\"\" >&2\n      exit 1\n    ;;\n    *)\n      integer \"\
    $length\"\n    ;;\n  esac", "  local VALUE=\"$1\"\n\n  if [ \"$VALUE\" == \"\"\
    \ ]; then\n    VALUE=\"0\"\n  fi\n\n  local DIVISOR=\n  local CLOSEST_VALUE=\"\
    $VALUE\"\n  local CLOSEST_DIVISOR=0\n  local CLOSEST_DIVISOR_PRECISION=0\n  local\
    \ CLOSEST_DIVISOR_REMAINDER=0\n  local CLOSEST_DIVISOR_OFFSET=-1\n\n  for DIVISOR\
    \ in $(seq \"$VALUE\" 1 0 1); do\n    local DIVISOR_PRECISION=$(( 10#$DIVISOR\
    \ ))\n    local DIVISOR_REMAINDER=$(( 10#$DIVISOR % 10#$VALUE ))\n    local DIVISOR_OFFSET=$((\
    \ 10#$DIVISOR % 10#$VALUE ))\n\n    if [ \"$DIVISOR_PRECISION\" -gt \"$CLOSEST_DIVISOR_PRECISION\"\
    \ ]; then\n      CLOSEST_DIVISOR_PRECISION=\"$DIVISOR_PRECISION\"\n      CLOSEST_DIVISOR_REMAINDER=\"\
    $DIVISOR_REMAINDER\"\n      CLOSEST_DIVISOR_OFFSET=\"$DIVISOR_OFFSET\"\n     \
    \ CLOSEST_DIVISOR=\"$DIVISOR\"\n    fi\n\n    if [ \"$CLOSEST_DIVISOR\" -gt \"\
    $CLOSEST_VALUE\" ]; then\n      CLOSEST_VALUE=\"$CLOSEST_DIVISOR\"\n    fi\n\n\
    \    if [ \"$CLOSEST_DIVISOR_OFFSET\" -ge \"0\" ]; then\n      break\n    fi\n\
    \  done\n\n  echo \"$CLOSEST_DIVISOR\"", "  local string=\"$1\"\n  local integer=\"\
    ${string}\"\n  local number=\"1\"\n  local factor=\"$2\"\n\n  while [[ \"$integer\"\
    \ -gt \"$number\" ]]; do\n    number=$(( $number * $factor ))\n  done\n  echo\
    \ \"$number\"", "  if [[ \"$1\" = \"-.*\" ]]; then\n    echo \"$(( $(echo \"$1\"\
    \ | tr '.' '+' | bc -l) / $2 ))\"\n  else\n    echo \"$(( ( $1 < $2 ) ? $1 : $2\
    \ ))\"\n  fi", "\tlocal number=$1\n\tlocal base\n\tlocal closest_number\n\tlocal\
    \ closest_base\n\tlocal difference\n\tlocal round_to\n\n\t# If the number is already\
    \ an integer, just return the number.\n\tif [[ \"$number\" =~ ^[0-9]+$ ]]; then\n\
    \t\techo \"$number\"\n\t\treturn\n\tfi\n\n\t# If the number is negative, multiply\
    \ by -1 before rounding\n\t# away from zero. For example, -11.5 rounds to -12.5,\
    \ and the\n\t# function should return -12.5 in this case.\n\tif [[ \"$number\"\
    \ =~ ^-[0-9]+$ ]]; then\n\t\techo \"$(( ${number//-} ))\"\n\t\treturn\n\tfi\n\n\
    \t# If there are no decimals, just return the number. For example,\n\t# \"100\"\
    \ should return 100 and \"10\" should return 10.\n\tif [[ \"$number\" =~ ^[0-9]+\\\
    .[0-9]+$ ]]; then\n\t\techo \"$number\"\n\t\treturn\n\tfi\n\n\t# If the last character\
    \ of the number is \".\", remove it.\n\tif [[ \"$number\" =~ ^[0-9]+\\.$ ]]; then\n\
    \t\techo \"$number\"\n\t\treturn\n\tfi\n\n\t# If the last character of the number\
    \ is a \"e\", remove it.\n\tif [[ \"$number\" =~ ^[0-9]+[eE]$ ]]; then\n\t\techo\
    \ \"$number\"\n\t\treturn\n\tfi\n\n\t# If the last character of the number is\
    \ a \"+\", remove it.\n\tif [[ \"$number\" =~ ^[0-9]+\\+$ ]]; then\n\t\techo \"\
    $number\"\n\t\treturn\n\tfi\n\n\t# Split the number into its base and number parts,\
    \ ignoring any\n\t# leading zeros.\n\tlocal number_parts=${number//+/ }\n\tlocal\
    \ base_parts=\"$(echo \"$number_parts\" | cut -d. -f1-3)\"\n\n\t# If the base\
    \ is 0, then just return the number as is.\n\tif [[ \"$base_parts\" =~ (^|0)$\
    \ ]]; then\n\t\techo \"$number_parts\"\n\t\treturn\n\tfi\n\n\t# If the base is\
    \ a negative number, then multiply by -1 before rounding\n\t# away from zero.\
    \ For example, -12.5 rounds to -13.\n\tif [[ \"$base_parts\" =~ ^-[0-9]+$ ]];\
    \ then\n\t\techo \"$(( ${base_parts//-} ))\"\n\t\treturn\n\tfi\n\n\t# If the base\
    \ is 0, return it as the number itself if it's equidistant from\n\t# two integers.\
    \ If it isn't, return it as the closest integer from zero.\n\tif [[ \"$base_parts\"\
    \ =~ (^|0)$ ]]; then\n\t\tif [[ $(echo \"$number_parts\" | ", "  # Set a default\
    \ for $2, which we will assume is a value\n  # that can't be parsed by an integer\n\
    \  local STRING=\"invalid\"\n  local VALUE=\"$1\"\n  if ! [[ ${VALUE:0:1} = +\
    \ ]]; then\n    STRING=\"no integer\"\n  fi\n  # If value is an integer, use it\n\
    \  if [[ $STRING != \"no integer\" && $VALUE =~ ^[+-]?\\d+$ ]]; then\n    VALUE=\"\
    ${VALUE}\"\n  fi\n  # Loop until we get an acceptable value\n  while [[ \"${VALUE}\"\
    \ != ${STRING} ]]; do\n    # If it's negative, make it positive\n    if [[ $VALUE\
    \ =~ ^-$ ]]; then\n      VALUE=\"${VALUE}${VALUE}\"\n    fi\n    # Try again to\
    \ parse it as an integer\n    VALUE=$(echo ${VALUE} | awk -F. '{print $1*$2+$3*$4+$5*$6+$7}')\n\
    \    if [[ $VALUE =~ ^[+-]?\\d+$ ]]; then\n      break\n    fi\n  done\n  echo\
    \ \"${VALUE}\"", "\tlocal input=$1\n\t# Make sure the input is a string.\n\t[\
    \ -z \"$input\" ] && return 1\n\t# Set up return value.\n\tlocal output=0\n\t\
    # If there are less than two characters, return 0\n\t[ \"${#input}\" -le 2 ] &&\
    \ return 0\n\t# If the first character is a number, return that\n\t[[ $input =~\
    \ ^[0-9]+$ ]] && output=\"$input\" || return 0\n\t# If the first character is\
    \ a letter, return it\n\t[[ $input =~ ^[a-z]+$ ]] && output=\"$input\" || return\
    \ 0\n\t# If the first character is a special char, return it\n\t[[ $input =~ ^[!,%,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^,&,*,@,(,),-,.,/,~,^",
  "  local number=$1\n  local prev=$(( number - 1 ))\n  local diff=$(echo \"${number}-${prev}\"\
    \ | bc)\n  local diff1=$(echo \"${prev}-${number}\" | bc)\n  local diff2=$(echo\
    \ \"${number}-${prev}\" | bc)\n  local diff3=$(echo \"${prev}-${prev}\" | bc)\n\
    \  echo \"${number}\"\n  if (( \"${diff}\" < \"${diff1}\" && \"${diff}\" < \"\
    ${diff2}\" && \"${diff}\" < \"${diff3}\" )) ; then\n    echo \"${prev}\"\n  else\n\
    \    echo \"${number}\"\n  fi", "\tlocal str=$1\n\tlocal num=$(( str - $str %\
    \ 2 ))\n\t(( num > 0 )) && echo \"$str\"\n\t(( num < 0 )) && echo \"$(closest_integer\
    \ \"$(-num)\")\"", "  local val=$1\n  local integer\n  local round\n  integer=$(echo\
    \ $val |tr \".\" \" \")\n  round=$(echo $integer |awk '{ print $1 }')\n  if [\
    \ \"$integer\" == \"$round\" ]\n  then\n    echo 0\n  else\n    local diff=$((\
    \ $integer - $round ))\n    if [ \"$diff\" -eq \"0\" ]\n    then\n      echo $integer\n\
    \    else\n      echo $(( $integer - diff ))\n    fi\n  fi", "  local val=$1\n\
    \  # First check if val is already an integer.\n  if [[ $val =~ ^[0-9]+$ ]]; then\n\
    \    echo \"$val\"\n  fi\n  # If val is an empty string, return an empty string\n\
    \  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  # If val is an empty string,\
    \ return an empty string\n  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  #\
    \ Now check for a decimal number.\n  if [[ $val =~ ^[0-9]+\\.[0-9]+$ ]]; then\n\
    \    echo \"$val\"\n  fi\n  # If val is not an integer, return an empty string\n\
    \  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  # Now check for a decimal number.\n\
    \  if [[ $val =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    echo \"$val\"\n  fi\n  # Now\
    \ check for a hexadecimal number.\n  if [[ $val =~ ^0x[A-Fa-f0-9]+\\.[0-9]+$ ]];\
    \ then\n    echo \"$val\"\n  fi\n  # If val is not an integer, return an empty\
    \ string\n  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  # Now check for a\
    \ octal number.\n  if [[ $val =~ ^0[0-7]+\\.[0-9]+$ ]]; then\n    echo \"$val\"\
    \n  fi\n  # If val is not an integer, return an empty string\n  if [ -z \"$val\"\
    \ ]; then\n    return 0\n  fi\n  # Now check for a binary/octal/hex number\n \
    \ if [[ $val =~ ^[01]+\\.[0-9]+$ ]]; then\n    echo \"$val\"\n  fi\n  # If val\
    \ is not an integer, return an empty string\n  if [ -z \"$val\" ]; then\n    return\
    \ 0\n  fi\n  # Now check for a binary number\n  if [[ $val =~ ^[01]+$ ]]; then\n\
    \    echo \"$val\"\n  fi\n  # If val is not an integer, return an empty string\n\
    \  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  # Now check for a decimal number.\n\
    \  if [[ $val =~ ^[0-9]+$ ]]; then\n    echo \"$val\"\n  fi\n  # If val is not\
    \ an integer, return an empty string\n  if [ -z \"$val\" ]; then\n    return 0\n\
    \  fi\n  # Now check for a hexadecimal number.\n  if [[ $val =~ ^0x[A-Fa-f0-9]+$\
    \ ]]; then\n    echo \"$val\"\n  fi\n  # If val is not an integer, return an empty\
    \ string\n  if [ -z \"$val\" ]; then\n    return 0\n  fi\n  # Now check for a\
    \ octal number.\n  if [[ $val =~ ^", "  local STRING=\"$1\"\n  local EXPECTED_RESULT=\"\
    $2\"\n  local EXPECTED_RESULT2=\"$3\"\n\n  # Strip any sign\n  local NUMBER=\"\
    ${STRING%%+([0-9])}\"\n\n  # Strip any decimal part\n  NUMBER=\"${NUMBER%.*}\"\
    \n\n  # Strip any trailing zeros\n  NUMBER=\"${NUMBER##*.}\"\n\n  local OPTARGS=(\"\
    $@\")\n  local RESULT\n  RESULT=0\n\n  # If the string is an integer, simply return\
    \ it\n  case \"$NUMBER\" in\n    \"$EXPECTED_RESULT\") return \"$NUMBER\";;\n\
    \    *) ;;\n  esac\n\n  local EXPECTED_LEN\n  EXPECTED_LEN=\"${#EXPECTED_RESULT}\"\
    \n\n  local NUM_DIFF\n  NUM_DIFF=0\n  local NUM_SKIP\n  NUM_SKIP=1\n  local NUM\n\
    \  NUM=\"$NUMBER\"\n  while [[ \"$NUM\" =~ \"[0-9]\" ]]; do\n    NUM_DIFF=$((\
    \ ${NUM_DIFF} + 1 ))\n    NUM=\"${NUM#?}\"\n  done\n  NUM=\"${NUM%%[^0-9]}\"\n\
    \  local NUM_LENGTH\n  NUM_LENGTH=\"${#NUM}\"\n\n  if (( NUM_LENGTH < EXPECTED_LEN\
    \ )); then\n    NUM_SKIP=$(( NUM_LENGTH - EXPECTED_LEN ))\n    NUM=\"${NUM}$EXPECTED_RESULT2\"\
    \n  fi\n\n  local NUM_SKIP_COUNT\n  NUM_SKIP_COUNT=\"$(expr $NUM_SKIP + 1)\"\n\
    \  local NUM_SKIP_NUM\n  NUM_SKIP_NUM=\"$(expr $NUM_SKIP_COUNT \\* $NUM_DIFF)\"\
    \n\n  if (( $NUM_SKIP_COUNT < $NUM_SKIP_NUM )); then\n    NUM_SKIP=$NUM_SKIP_COUNT\n\
    \  fi\n\n  # If not equidistant, find the closest value by dividing the number\
    \ by 10^EXPECTED_LEN\n  while (( \"$NUM\" != \"$EXPECTED_RESULT\" )); do\n   \
    \ (( RESULT = ( $RESULT + ( $NUMBER / 10 ) ) ))\n    (( EXPECTED_RESULT = ( $EXPECTED_RESULT\
    \ / 10 ) ))\n    (( NUM = ${NUM%%[^0-9]} ))\n    (( NUM_LENGTH = ${#NUM} ))\n\
    \    if (( NUM_LENGTH < EXPECTED_LEN )); then\n      (( NUM_SKIP ))\n      NUM=\"\
    ${NUM", "  local value\n  value=${1}\n\n  # Make sure we round down\n  if [ \"\
    $value\" == \"\" ]; then\n    echo \"Value is empty\"\n    return 0\n  fi\n\n\
    \  # Scan the string to find the first integer and check if that is the closest\n\
    \  # to zero. If yes, then return that integer.\n  local int\n  local found\n\
    \  while (( \"$value\" > 0 )) ; do\n    int=$(( ${value%%.*} + 1 ))\n    found=false\n\
    \    for (( ; int > 0; int-=1 )); do\n      [[ \"$int\" -eq \"$value\" ]] && found=true\n\
    \    done\n    if [ \"$found\" == true ]; then\n      break\n    fi\n    value=${value#*.}\n\
    \  done\n\n  # Return the first value that we found\n  echo $int", "  local number=$1\n\
    \  local decimal=$(( $(echo \"$number\" | bc | awk '{print $3}') - $(echo \"$number\"\
    \ | bc | awk '{print $2}') ))\n  if [ $decimal -gt 0 ]\n  then\n    decimal=$((\
    \ $decimal - $(( $decimal % 1 )) ))\n  fi\n  if [ $decimal -lt 0 ]\n  then\n \
    \   decimal=$(( $decimal + $(( $decimal % 1 )) ))\n  fi\n  echo \"$number\"",
  "    local val=\"${1}\"\n    local d\n    local closest\n    local next\n    local\
    \ prev\n    local diff\n    local int_val\n    local diff\n    local min\n   \
    \ local max\n    local m\n    local ans\n\n    # first check whether val is a\
    \ number\n    if [[ ! \"$val\" =~ ^[0-9]+\\.?[0-9]*$ ]]; then\n        echo \"\
    Usage: $(basename \"$0\") <number>\"\n        exit 1\n    fi\n    int_val=$((\
    \ 10#$val ))\n\n    if [[ \"$int_val\" < 2 ]]; then\n        echo \"ERROR: $(basename\
    \ \"$0\") should take at least one integer argument\"\n        exit 1\n    fi\n\
    \n    # check that val is a valid number\n    if [[ ! \"$val\" =~ ^[0-9]*\\.?[0-9]+$\
    \ ]]; then\n        echo \"ERROR: $(basename \"$0\") should take at least one\
    \ float argument\"\n        exit 1\n    fi\n    m=$(( 10#$val ))\n\n    if [[\
    \ \"$m\" == 1 ]]; then\n        echo \"ERROR: $(basename \"$0\") should take at\
    \ least one non-zero argument\"\n        exit 1\n    fi\n\n    # get the closest\
    \ integer (round towards zero)\n    d=$(( 10#$int_val ))\n    closest=$(( $d +\
    \ 1 ))\n\n    prev=$(( $int_val - $d ))\n    next=$(( $int_val + $d ))\n\n   \
    \ # see which number has the smallest difference\n    min=$(( $int_val - $closest\
    \ ))\n    max=$(( $int_val + $closest ))\n\n    if [ \"$min\" -ne \"$max\" ];\
    \ then\n        # if the closest integer is equidistant from two integers,\n \
    \       # round it to the smaller one\n        if [ \"$min\" -eq \"$int_val\"\
    \ ]; then\n            closest=$min\n        else\n            closest=$max\n\
    \        fi\n    fi\n\n    if [ \"$closest\" -ne \"$int_val\" ]; then\n      \
    \  # if the closest integer is not equidistant from two integers,\n        # round\
    \ it to the smaller one\n        if [ \"$int_val\" -eq \"$closest\" ]; then\n\
    \            closest=$int_val\n        else\n            closest=$closest\n  \
    \      fi\n    fi\n\n    # check whether closest is smaller than the number\n\
    \    if [ \"$closest\" -lt \"$m\" ]; then\n        echo \"ERROR: $(basename \"\
    $0\") should take at least one integer argument\"\n        exit 1\n    fi\n\n\
    \    if [ \"$m\" -lt \"$closest\" ]; then\n        echo \"ERROR: $(basename \"\
    $0\") should take at least one float argument\"\n        exit 1\n    fi\n\n  \
    \  # check for equidistant integers\n", "\tlocal number=\"$1\"\n\n\t# Convert\
    \ non-integers to float\n\tlocal number_as_float=\"$number\"\n\tcase \"$number\"\
    \ in\n\t\t*[!0-9]*) return 1;;\n\tesac\n\tlocal integer=\"$(\"$number_as_float\"\
    )\"\n\tlocal decimal=\"$(\"$number_as_float\" | sed 's/^.*\\.//')\"\n\n\t# The\
    \ decimal part of the float must be between 0 and 15\n\tif [ \"$decimal\" -lt\
    \ 0 ] || [ \"$decimal\" -gt 15 ]\n\tthen\n\t\treturn 1;\n\tfi\n\n\tlocal rounded_integer=\"\
    $(\"$integer\" | sed -e 's/^0*\\(\\.\\?\\)\\?0*$/1\\1/')\"\n\tlocal rounded_decimal=\"\
    $(\"$decimal\" | sed -e 's/^0*\\(\\.\\?\\)\\?0*$/1\\1/')\"\n\tlocal closest_integer=\"\
    $(\"$rounded_integer\" | sed -e 's/\\./\\,\\./' | sed -e 's/^0*\\(\\.\\?\\)\\\
    ?0*$/1\\1/')\"\n\tlocal closest_decimal=\"$(\"$rounded_decimal\" | sed -e 's/\\\
    ./\\,\\./' | sed -e 's/^0*\\(\\.\\?\\)\\?0*$/1\\1/')\"\n\n\t# Check if decimal\
    \ is closer\n\tif [ \"$closest_decimal\" = \"$decimal\" ]\n\tthen\n\t\treturn\
    \ \"$closest_integer\"\n\tfi\n\n\t# Check if integer is closer\n\tif [ \"$closest_integer\"\
    \ -lt \"$number\" ]\n\tthen\n\t\treturn \"$closest_decimal\"\n\tfi\n\n\t# Check\
    \ if integer is closer\n\tif [ \"$closest_integer\" -gt \"$number\" ]\n\tthen\n\
    \t\treturn \"$closest_integer\"\n\tfi", "  local string=${1}\n  local number=$(echo\
    \ $string | sed -e 's/,//g')\n  local closest=$(echo $number | sed -e 's/\\./,/g'\
    \ -e 's/,//g' -e 's/^0//' -e 's/^-//' -e 's/^-//')\n  local negative=$(echo $number\
    \ | sed -e 's/^\\./,/g' -e 's/,//g' -e 's/^0//' -e 's/^-//' -e 's/^-//')\n  local\
    \ positive=$(echo $number | sed -e 's/^\\./,/g' -e 's/,//g' -e 's/^-//' -e 's/^-//'\
    \ -e 's/^0//')\n  local closestint=$(echo $number | sed -e 's/^\\./,/g' -e 's/,//g'\
    \ -e 's/^-//' -e 's/^-//' -e 's/^0//')\n  local closestintstr=$(echo $closestint\
    \ | sed -e 's/^0//')\n\n  # if the number is negative\n  if [[ \"$negative\" ==\
    \ \"$number\" ]]; then\n    # if the number is equidistant from two positive numbers,\
    \ round\n    # it to the closest positive\n    if [[ \"$positive\" == \"$closest\"\
    \ ]]; then\n      closest=$positive\n      closestint=$positive\n      closestintstr=$positive\n\
    \    else\n      closestint=$positive\n      closestintstr=$positive\n    fi\n\
    \  else\n    # if the number is equidistant from two negative numbers, round\n\
    \    # it to the closest negative\n    if [[ \"$negative\" == \"$closest\" ]];\
    \ then\n      closest=$negative\n      closestint=$negative\n      closestintstr=$negative\n\
    \    else\n      closestint=$negative\n      closestintstr=$negative\n    fi\n\
    \  fi\n\n  echo \"$closest\"\n  echo \"$closestint\"\n  echo \"$closestintstr\"",
  "  val=$(echo $1 | sed 's/ /-/g')\n  val1=$(echo $val | sed 's/-/ /g')\n  val2=$(echo\
    \ $val | sed 's/ /+/g')\n  val3=$(echo $val | sed 's/+/ /g')\n  val4=$(echo $val\
    \ | sed 's/-/-/g')\n  val5=$(echo $val | sed 's/+/\\+/g')\n  val6=$(echo $val\
    \ | sed 's/ /\\+/g')\n  val7=$(echo $val | sed 's/\\+/-/g')\n\n  int_1=$(echo\
    \ \"$val\" | sed 's/^\\(.\\)$/\\1/')\n  int_2=$(echo \"$val\" | sed 's/^\\(.\\\
    )$/-\\1/')\n  int_3=$(echo \"$val\" | sed 's/^\\(.\\)$/\\+\\1/')\n  int_4=$(echo\
    \ \"$val\" | sed 's/^\\(.\\)$/-\\+/')\n  int_5=$(echo \"$val\" | sed 's/^\\(.\\\
    )$/\\+\\-\\+/')\n  int_6=$(echo \"$val\" | sed 's/^\\(.\\)$/\\+/+/')\n  int_7=$(echo\
    \ \"$val\" | sed 's/^\\(.\\)$/-\\+/')\n\n  int_1_1=$(echo \"$val\" | sed 's/^.//')\n\
    \  int_2_1=$(echo \"$val\" | sed 's/^\\(.\\)$/-\\1/')\n  int_3_1=$(echo \"$val\"\
    \ | sed 's/^\\(.\\)$/\\+\\1/')\n  int_4_1=$(echo \"$val\" | sed 's/^\\(.\\)$/-\\\
    +/')\n  int_5_1=$(echo \"$val\" | sed 's/^\\(.\\)$/\\+\\-\\+/')\n  int_6_1=$(echo\
    \ \"$val\" | sed 's/^\\(.\\)$/\\+/+/')\n  int_7_1=$(echo \"$val\" | sed 's/^\\\
    (.\\)$/-\\+/')\n\n  int_1_2=$(echo \"$val\" | sed 's/^.//')\n  int_2_2=$(echo\
    \ \"$val\" | sed 's/^-\\(.\\)$/-\\1/')\n  int_3_2=$(echo \"$val\" | sed 's/^\\\
    +\\(.\\)$/+\\1/')\n  int_4_2=$(echo \"$val\" | sed 's/^\\-\\(.\\)$/-\\+/')\n",
  "    local number=$1\n    # Make sure that we're working with a number.\n    local\
    \ is_num\n    is_num=$( expr \"$number\" : '^[0-9]+([.][0-9]+)?$' )\n    if [[\
    \ -z $is_num ]]; then\n        echo \"Invalid number format: '$number'\"\n   \
    \     return 1\n    fi\n    # Make sure that we're dealing with a positive number.\n\
    \    local is_pos\n    is_pos=$( expr \"$number\" : '^[0-9]+$' )\n    if [[ -z\
    \ $is_pos ]]; then\n        echo \"Invalid positive number format: '$number'\"\
    \n        return 1\n    fi\n    # Make sure that the number we're working with\
    \ is less than 100.\n    local is_less\n    is_less=$( expr \"$number\" : '^[0-9]+([.][0-9]+)?$'\
    \ )\n    if [[ -z $is_less ]]; then\n        echo \"Invalid number less than 100:\
    \ '$number'\"\n        return 1\n    fi\n    local num\n    local diff\n    local\
    \ abs\n    local newnum\n    local maxnum\n    if [ \"$is_num\" = \"true\" ];\
    \ then\n        num=${number%.*}\n    else\n        echo \"Invalid number format:\
    \ '$number'\"\n        return 1\n    fi\n    if [ \"$is_pos\" = \"true\" ]; then\n\
    \        num=${num}\n    else\n        echo \"Invalid positive number format:\
    \ '$number'\"\n        return 1\n    fi\n    maxnum=100\n    if [ \"$is_less\"\
    \ = \"true\" ]; then\n        maxnum=100\n        num=$(expr ${num} - 1)\n   \
    \ fi\n    diff=$(( ${num} - ${maxnum} ))\n    abs=$( expr \"$diff\" : \"^[0-9]+$\"\
    \ )\n    if [[ -z $abs ]]; then\n        echo \"Invalid number less than 100:\
    \ '$number'\"\n        return 1\n    fi\n    if [[ -z $diff ]]; then\n       \
    \ return 0\n    fi\n    if [ $abs -lt $diff ]; then\n        newnum=$(expr ${num}\
    \ + $diff)\n        if [ \"$is_num\" = \"true\" ]; then\n            echo \"$newnum\"\
    \n        else\n            echo $newnum\n        fi\n    else\n        newnum=$(expr\
    \ ${num} - $diff)\n        if [ \"$is_num\" = \"true\" ]; then\n            echo\
    \ \"$newnum\"\n        else\n            echo $newnum\n        fi\n    fi", " \
    \   local v=$1\n    local i\n    local n\n    local prev\n    local max\n    local\
    \ min\n    local diff\n    local closest\n    local diff\n\n    # Make sure the\
    \ value is a string\n    echo \"$1\" | xargs cat\n    if [ \"$1\" == \"-nan\"\
    \ ]\n    then\n        return 1\n    fi\n\n    if [ -z \"$v\" ]\n    then\n  \
    \      return 1\n    fi\n    if [ \"$v\" = \"null\" ]\n    then\n        return\
    \ 1\n    fi\n    if [ \"$v\" = \"false\" ]\n    then\n        return 1\n    fi\n\
    \    if [ \"$v\" = \"true\" ]\n    then\n        return 1\n    fi\n\n    # Parse\
    \ the string to extract an integer from the first non-whitespace\n    # character\n\
    \    i=\"${v#*[^[:space:]]}\"\n    if [ \"$i\" == \"\" ]\n    then\n        return\
    \ 1\n    fi\n\n    # Make sure the number does not contain anything other than\
    \ digits\n    if ! echo \"$i\" | grep -Eq \"^[0-9]+$\" > /dev/null\n    then\n\
    \        return 1\n    fi\n\n    # If the number is negative and the negative\
    \ sign is present, strip it\n    if [ \"${v%[![:space:]]}\" = \"-\" ]\n    then\n\
    \        v=\"${v#*-}\"\n    fi\n\n    # Strip whitespace from the string\n   \
    \ v=\"${v%%[![:space:]]*}\"\n    v=\"${v##*[![:space:]]}\"\n\n    # If the number\
    \ is zero, return it\n    if [ \"$v\" = \"0\" ]\n    then\n        echo \"0\"\n\
    \        return 0\n    fi\n\n    # Make sure the number is at least 1 digit\n\
    \    if [ \"${v:0:1}\" != \"-\" ]\n    then\n        v=\"0$v\"\n    fi\n\n   \
    \ # Get the number as a string\n    n=\"$v\"\n\n    # If the number is positive,\
    \ strip off the positive sign\n    if [ \"${v:0:1}\" != \"+\" ]\n    then\n  \
    \      v=\"$v\"\n    fi\n\n    # Get the number as a string\n    n=\"$v\"\n\n\
    \    # Get the maximum number from the string\n    max=$(echo \"$n\" | awk '{print\
    \ $NF}' | sed 's/^-\\([0-9][0-9]*\\)$/\\1/')\n\n    # Get the minimum number from\
    \ the string\n    min=$(echo \"$n\" | awk '{print $NF}' | sed 's/^-\\([0-9][0-9]*\\\
    )$/\\1/')\n\n    # Get the difference between the two\n    diff=$(echo \"$max\"\
    \ - \"$min\")\n\n    # If the difference is zero, return it\n    if [ \"$diff\"\
    \ == 0 ]\n    then\n        echo \"0\"\n        return 0\n    fi\n\n    # If the\
    \ number is equidistant, round ", "  echo \"$1\" | awk -v OFS='' 'BEGIN{\n   \
    \    while(diff<1){\n           diff=1;\n           last=$1;\n           for(i=1;i<length($1);i++){\n\
    \             diff=diff*10+($(i)-$(i-1))\n           }\n           if(diff==1\
    \ && $1!=$1){\n             diff=diff*10\n           }\n           else if(diff<1){\n\
    \             diff=diff*10\n           }\n           if(diff>10){\n          \
    \   diff=diff/10;\n             last=$1;\n           }\n       }\n       return\
    \ last;\n  }'", "    local STRING=$1\n    local CLOSEST_TO_SEEN=\n\n    # Iterate\
    \ over the given string, adding each character to a \"seen\"\n    # array. If\
    \ the character is not in the array, add it.\n    for CHAR in $STRING; do\n  \
    \      if ! [[ ${CLOSEST_TO_SEEN[$CHAR]} ]]; then \n            CLOSEST_TO_SEEN[$CHAR]=1\n\
    \        else\n            # Increment the value of the element in the seen array\n\
    \            ((CLOSEST_TO_SEEN[$CHAR]+=1))\n        fi\n    done\n\n    # Iterate\
    \ over the seen array, finding which element has the largest\n    # value and\
    \ returning it (note that zero is not a possible value).\n    for KEY in ${!CLOSEST_TO_SEEN[@]};\
    \ do\n        if [[ ${CLOSEST_TO_SEEN[$KEY]} -eq ${#CLOSEST_TO_SEEN[@]} ]]; then\n\
    \            echo \"${KEY}\"\n        fi\n    done", "    local NUMBER=\"$1\"\n\
    \    local NUMBER_MAX=\"$2\"\n    local NUMBER_MIN=\"$3\"\n\n    local TOLERANCE=\"\
    $4\"\n    local CLOSEST_INTEGER=\"$5\"\n\n    local NUMBER_FLOAT=\"$6\"\n    local\
    \ NUMBER_STRING=\"$7\"\n\n    local INTEGER=\"$8\"\n    local NUMBER_SPACE=\"\
    $9\"\n\n    local INTEGER_POINT=\"$10\"\n    local NUMBER_POINT=\"$11\"\n\n  \
    \  local INTEGER_FRACTION=\"$12\"\n    local NUMBER_FRACTION=\"$13\"\n\n    local\
    \ INTEGER_EXPONENT=\"$14\"\n    local NUMBER_EXPONENT=\"$15\"\n\n    local INTEGER_EXPONENTS=\"\
    $16\"\n    local NUMBER_EXPONENTS=\"$17\"\n\n    local INTEGER_EXPONENT_AND_NUMBER=\"\
    $18\"\n    local NUMBER_EXPONENT_AND_NUMBER=\"$19\"\n\n    local INTEGER_EXPONENT_AND_NUMBERS=\"\
    $20\"\n    local NUMBER_EXPONENT_AND_NUMBERS=\"$21\"\n\n    local EXPONENT_AND_NUMBER=\"\
    $22\"\n    local EXPONENT_AND_NUMBERS=\"$23\"\n\n    local EXPONENT_AND_NUMBERS_AND_INTEGER=\"\
    $24\"\n    local EXPONENT_AND_NUMBERS_AND_INTEGER=\"$25\"\n\n    local EXPONENT_AND_NUMBERS_AND_CLOSURE=\"\
    $26\"\n    local EXPONENT_AND_NUMBERS_AND_CLOSURE=\"$27\"\n\n    if [[ $NUMBER_MIN\
    \ -eq 0 ]]; then\n        NUMBER_MIN=-$(( $NUMBER_MAX + 1 ))\n    fi\n    if [[\
    \ $NUMBER_MAX -eq 0 ]]; then\n        NUMBER_MAX=$(( $NUMBER_MIN - 1 ))\n    fi\n\
    \n    if [[ $NUMBER_MIN -eq $NUMBER_MAX ]]; then\n        return 0\n    fi\n\n\
    \    if [[ $NUMBER -ne \"0\" ]]; then\n        if [[ $NUMBER_MIN -gt $NUMBER ]];\
    \ then\n            if [[ $NUMBER_MIN -le $NUMBER ]]; then\n                return\
    \ $CLOSEST_INTEGER\n            else\n                return $INTEGER\n      \
    \      fi\n        elif [[ $NUMBER -ge $NUMBER_MAX ]]; then\n            if [[\
    \ $NUMBER_MAX -le $NUMBER ]]; then\n                return $CLOSEST_INTEGER\n\
    \            else\n                return $INTEGER\n            fi\n        else\n\
    \            return 0\n        fi\n    fi\n\n    if [[ $NUMBER_MIN -eq 0 ]]; then\n\
    \        INTEGER=\"$NUMBER\"\n        INTEGER_POINT=\"$NUMBER_POINT\"\n      \
    \  INTEGER_FRACTION=\"$NUMBER_FRACTION\"\n        INTEGER_EXPONENT=\"$NUMBER_EXPONENT\"\
    \n        INTEGER_EXP", "  local number=$1\n  # Check if number is numeric\n \
    \ [[ \"$number\" =~ ^-?[0-9]+([.][0-9]+)?$ ]] || return 1\n  # Check if number\
    \ is equidistant from two numbers\n  local diff\n  [[ \"$number\" =~ ^-?[0-9]+([.][0-9]+)$\
    \ ]] || return 1\n  diff=${number#$1}\n  local diff2\n  [[ \"$number\" =~ ^-?[0-9]+([.][0-9]+)$\
    \ ]] || return 1\n  diff2=${number#$1}\n  [[ \"$diff2\" == \"$diff\" ]] || return\
    \ 1\n  # Check if number is close to zero\n  if [ \"$number\" -le 0 ] ; then return\
    \ 0; fi\n  local d\n  if [ \"$diff\" -le \"10\" ] ; then d=2\n  elif [ \"$diff\"\
    \ -lt \"-10\" ] ; then d=1\n  else return 1 ; fi\n  local i\n  local j\n  if [\
    \ \"$diff2\" -le \"10\" ] ; then i=2\n  elif [ \"$diff2\" -lt \"-10\" ] ; then\
    \ i=1\n  else return 1 ; fi\n  local n\n  local p\n  if [ \"$diff2\" -le \"$diff\"\
    \ ] ; then n=2\n  elif [ \"$diff2\" -lt \"$diff\" ] ; then n=1\n  else return\
    \ 1 ; fi\n  if [ \"$d\" -eq \"2\" ] ; then p=$((i + j + 1))\n  elif [ \"$d\" -eq\
    \ \"1\" ] ; then p=$((i * j))\n  else return 1 ; fi\n  [[ \"$diff\" -le \"$p\"\
    \ ]] || return 1\n  local q\n  if [ \"$diff2\" -le \"$diff\" ] ; then q=2\n  elif\
    \ [ \"$diff2\" -lt \"$diff\" ] ; then q=1\n  else return 1 ; fi\n  if [ \"$q\"\
    \ -eq \"2\" ] ; then return $((n - 1))\n  elif [ \"$q\" -eq \"1\" ] ; then return\
    \ $((n * j - i))\n  else return 1 ; fi", "  local x=\"${1}\"\n  if [[ -z \"$x\"\
    \ ]]; then\n    exit 1\n  fi\n  if [[ \"$x\" =~ ^-?[0-9]*\\.?[0-9]*$ ]]; then\n\
    \    local xi=$(echo \"$x\" | cut -d. -f1)\n    local xj=$(echo \"$x\" | cut -d.\
    \ -f2)\n    local diff=$(( xj - xi ))\n    if [[ \"$diff\" -gt 0 ]]; then\n  \
    \    x=\"$xi\"\n    else\n      x=\"$xj\"\n    fi\n  fi\n  echo \"$x\"", '    echo
    $((${1%%.*}+${1#*.}+${1%%.*}))', "    local input=\"$1\"\n    local integer=\"\
    $2\"\n\n    if [[ $integer -eq 0 ]]; then\n        echo \"0\"\n        return\
    \ 0\n    fi\n    local x=\"$integer\"\n    local y=\"$integer\"\n\n    while ((\
    \ x > y )); do\n        (( y -= 1 ))\n    done\n\n    # echo \"$integer - $y\"\
    \ # uncomment this line to print the difference\n    echo $(( x - y ))", "   \
    \ local IFS=`./get_decimal_separator $1`\n    local number=$1\n    local i=2\n\
    \    while [ $i -le $2 ]; do\n        local c=$(( $number - $number % $i ))\n\
    \        if [ $c -eq 0 ]; then\n            # Certain situations where $number\
    \ == 0 are handled below.\n            return $number\n        fi\n        i=$((\
    \ $i + 1 ))\n        if [ $i -eq 10 ]; then\n            # In most cases, we are\
    \ only required to worry about integer\n            # numbers that end with 0,\
    \ such as \"010\", \"100\", etc.\n            return $number\n        fi\n   \
    \ done\n\n    # At this point, $number is not guaranteed to be an integer.\n \
    \   # It could be an integer, or it could have been a floating-point number\n\
    \    # that has a decimal component, or a string, or it could be \"0\".\n    #\
    \ We can handle all of these, but the following cases cover\n    # a couple of\
    \ other common cases as well.\n    if [ $number -eq 0 ]; then\n        # Handle\
    \ cases such as \"$number\" being the string \"0\", or \"$number\"\n        #\
    \ being \"0\".\n        return 0\n    elif [ $number -eq \"0\" ]; then\n     \
    \   # Handle case such as \"$number\" being the string \"0\".\n        return\
    \ 0\n    elif [ $number == -0 ]; then\n        # Handle case such as \"$number\"\
    \ being \"-0\".\n        return 0\n    else\n        # Handle cases where $number\
    \ is neither \"0\", nor \"-0\".\n        # This is because for integers, $number\
    \ is only ever going to be\n        # something like \"10\", so it is safe to\
    \ just return the value $number.\n        local IFS=`./get_decimal_separator $number`\n\
    \        echo $number\n    }", "    local string=${1}\n    local number\n    local\
    \ closest\n    local sign\n    local i\n    local last\n\n    # First we try to\
    \ read it as a floating point number\n    number=\"${string%%.*}\"\n    # if the\
    \ string contains a decimal point, we try to read it as a number\n    if [[ ${string#*.}\
    \ != *. ]]; then\n        number=\"$(eval echo \"${string}\")\"\n    fi\n    #\
    \ we check the string only if it contains any character\n    if [[ -z \"$string\"\
    \ ]]; then\n        return\n    fi\n\n    # Then we try to convert it to a number\n\
    \    if ! [[ $string =~ ^-?[0-9]+$ ]]; then\n        return\n    fi\n\n    sign=${string:0:1}\n\
    \    string=${string:1}\n\n    if [[ ${sign} == \"-\" ]]; then\n        string=$((\
    \ ${string} + 1 ))\n    fi\n\n    # If the number is bigger than 2147483647 we\
    \ use the standard math\n    # command to round it down using floor.\n    if [[\
    \ ${number} -gt 2147483647 ]]; then\n        closest=$(( ${number} - 1 ))\n  \
    \  else\n        closest=$(( ${number} + 1 ))\n    fi\n\n    # if the closest\
    \ was zero, we set it to the biggest integer and the\n    # sign to negative so\
    \ that we never return zero\n    if [[ ${closest} == 0 ]]; then\n        closest=$((\
    \ ${number} + 1 ))\n        sign=\"-\"\n    fi\n\n    # if the closest is bigger\
    \ than the original (negative) number,\n    # we add one to the closest so that\
    \ it becomes the new negative\n    # number\n    if [[ ${closest} -gt ${number}\
    \ ]]; then\n        closest=$(( ${number} + 1 ))\n        sign=\"-\"\n    fi\n\
    \n    last=\"${string}\"\n    # we loop on every number until we find the closest\
    \ one\n    for (( i = closest; i >= 0; i-- )); do\n        if [[ ${last} -gt ${number}\
    \ ]]; then\n            closest=$(( ${number} + 1 ))\n            sign=\"-\"\n\
    \        fi\n        number=$(( ${number} + 1 ))\n        last=\"${number}\"\n\
    \    done\n    # and we check the sign if we have any\n    if [[ ${sign} == \"\
    -\" ]]; then\n        closest=$(( ${closest} - 1 ))\n    fi\n    # we return the\
    \ integer closest to the given number\n    echo ${closest}", "    local v=\"$1\"\
    \n    local c\n\n    case \"$v\" in\n        *[!0-9]*)\n            echo \"$v\"\
    \n            return 0;;\n        *)\n            c=${v##*[!0-9]}\n          \
    \  case \"$c\" in\n                0)\n                    echo \"0\"\n      \
    \              return 0;;\n                *)\n                    echo \"$c\"\
    \n                    return $c;;\n            esac\n    esac"]
stop_tokens:
- "\n}"
