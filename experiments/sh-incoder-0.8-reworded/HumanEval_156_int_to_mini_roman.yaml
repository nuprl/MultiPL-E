name: HumanEval_156_int_to_mini_roman
language: sh
prompt: "#!/bin/bash\n# Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n\
  # Examples:\n# >>> $(int_to_mini_roman \"19\")\n# \"xix\"\n# >>> $(int_to_mini_roman\
  \ \"152\")\n# \"clii\"\n# >>> $(int_to_mini_roman \"426\")\n# \"cdxxvi\"\n#\n# $1\
  \ is an integer\nint_to_mini_roman() {\n"
tests: "}\n\ncandidate() {\n    int_to_mini_roman \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"19\") = \"xix\" ]]\n    [[ $(candidate \"152\") = \"clii\"\
  \ ]]\n    [[ $(candidate \"251\") = \"ccli\" ]]\n    [[ $(candidate \"426\") = \"\
  cdxxvi\" ]]\n    [[ $(candidate \"500\") = \"d\" ]]\n    [[ $(candidate \"1\") =\
  \ \"i\" ]]\n    [[ $(candidate \"4\") = \"iv\" ]]\n    [[ $(candidate \"43\") =\
  \ \"xliii\" ]]\n    [[ $(candidate \"90\") = \"xc\" ]]\n    [[ $(candidate \"94\"\
  ) = \"xciv\" ]]\n    [[ $(candidate \"532\") = \"dxxxii\" ]]\n    [[ $(candidate\
  \ \"900\") = \"cm\" ]]\n    [[ $(candidate \"994\") = \"cmxciv\" ]]\n    [[ $(candidate\
  \ \"1000\") = \"m\" ]]\n}\n\nrun_test"
completions: ["  local num=\"$1\"\n  case $num in\n    1|11|21|31|41|51|61|71) echo\
    \ \"xix\";;\n    2|12|22|32|42|52|62|72) echo \"xiv\";;\n    3|13|23|33|43|53|63|73)\
    \ echo \"ix\";;\n    4|14|24|34|44|54|64|74) echo \"vi\";;\n    5|15|25|35|45|55|65|75)\
    \ echo \"vii\";;\n    6|16|26|36|46|56|66|76) echo \"ixi\";;\n    7|17|27|37|47|57|67|77)\
    \ echo \"xci\";;\n    8|18|28|38|48|58|68|78) echo \"cc\";;\n    9|19|29|39|49|59|69|79)\
    \ echo \"ccc\";;\n    10|20|30|40|50|60|70|80) echo \"cccci\";;\n    *)\n    \
    \    echo \"$num\";;\n  esac", "    if [[ $1 -lt 1 || $1 > 1000 ]]; then echo\
    \ \"Invalid integer: $1\"; return 1; fi\n    local num=$1\n    local roman=\"\
    $(roman_number_to_roman_word $(num))\"\n    echo -n $roman", "  local input=${1}\n\
    \  local output=\"\"\n  local i\n\n  for (( i=1; i <= ${#input}; i++ )); do\n\
    \    if [[ ${input:$i:1} = 1 ]]; then\n      output+=\"x\"\n    elif [[ ${input:$i:1}\
    \ = 5 ]]; then\n      output+=\"i\"\n    elif [[ ${input:$i:1} = 10 ]]; then\n\
    \      output+=\"l\"\n    elif [[ ${input:$i:1} = 20 ]]; then\n      output+=\"\
    c\"\n    elif [[ ${input:$i:1} = 30 ]]; then\n      output+=\"d\"\n    elif [[\
    \ ${input:$i:1} = 50 ]]; then\n      output+=\"m\"\n    elif [[ ${input:$i:1}\
    \ = 100 ]]; then\n      output+=\"f\"\n    elif [[ ${input:$i:1} = 500 ]]; then\n\
    \      output+=\"v\"\n    elif [[ ${input:$i:1} = 1000 ]]; then\n      output+=\"\
    x\"\n    else\n      output+=\"${input:$i}\"\n    fi\n  done\n  echo \"$output\"",
  "    # Convert integer to string\n    declare -i num=$1\n    declare -i roman=0\n\
    \n    # Check if num is between 1 and 1000\n    if [ $num -ge 1 ] && [ $num -le\
    \ 1000 ]; then\n        # Loop through string\n        while [ $num -le 1000 ];\
    \ do\n            # Increment number of characters by one\n            roman=$((roman\
    \ + 1))\n            num=$(expr $num / 10)\n        done\n\n        # Loop through\
    \ string again, adding last character to string\n        while [ $roman -gt 0\
    \ ]; do\n            # Loop through string\n            while [ $num -ge 1000\
    \ ]; do\n                # Increment number of characters by one\n           \
    \     roman=$((roman - 1))\n                num=$(expr $num / 10)\n          \
    \  done\n\n            # Return roman string\n            printf \"%s\" $roman\n\
    \            roman=0\n            num=$(expr $num / 10)\n        done\n    else\n\
    \        echo \"Invalid number. Must be between 1 and 1000. Exiting.\"\n     \
    \   exit 1\n    fi", "  local number=\"$1\"\n  local roman=''\n  # Convert to\
    \ decimal, from right-to-left starting from LSB.\n  while (( number >= 10 ));\
    \ do\n    (( number %= 10 ))\n    roman+=$(( $(( 10 * number )) - 1 ))\n  done\n\
    \  # Convert to lowercase.\n  roman+=$(( 10 * number ))\n  roman+=\"${roman:0:1}\"\
    \n  echo ${roman:1}", "  if (( $# < 1 )); then\n    echo \"Usage: $(basename $0)\
    \ <num>\"\n    exit 1\n  fi\n  local num=\"$1\"\n  local romannum\n  local i j\n\
    \n  romannum=\"\"\n  while (( \"$num\" > 0 )); do\n    local n=$(($num % 100))\n\
    \    romannum=\"$roman${n}\"\n    (( $num -= $n ))\n    (( $num > 0 ))\n    ((\
    \ $num % 10 ))\n    (( $num > 9 ))\n  done\n\n  romannum=\"${romannum:0:1}\"\n\
    \  (( \"$num\" > 0 ))\n  return \"$romannum\"", "  local num=\"$1\"\n  local len\n\
    \  local min\n  local max\n  local m\n  local n\n  local roman\n  local i\n  roman=\"\
    \"\n  min=$(echo \"$num/1000\" | bc)\n  max=$(echo \"$num/100\" | bc)\n  len=$((\
    \ $(echo \"$max-$min+1\" | bc) ))\n  roman=\"$(echo \"$min\" | bc)\"\n  while\
    \ [ $len -gt 0 ]; do\n    m=$(echo \"$roman+$len/100*10\" | bc)\n    m=$(( $(echo\
    \ \"$m+1\" | bc) ))\n    n=$(echo \"$roman+$m*10\" | bc)\n    roman=\"$n\"\n \
    \   len=$(( $(echo \"$len-$m+1\" | bc) ))\n  done\n  echo \"$roman\"", "  local\
    \ num=\"$1\"\n  local numstr=\"$num\"\n  local roman=\"0\"\n  while [ \"$num\"\
    \ -gt 0 ]; do\n    local digit=\"$(( num % 10 ))\"\n    local remainder=\"$((\
    \ num % 100 ))\"\n    roman=\"$roman$(( digit < 4 ? ${digit} : \"c\"))\"\n   \
    \ num=$(expr $remainder - $digit)\n  done\n  echo \"$roman\"", "\t# Convert $1\
    \ to decimal\n\tint_str=$1\n\tint_num=$(echo $int_str | awk '{print $1}')\n\t\
    # Roman numerals start at 1, not 0\n\tint_num=$(expr $int_num - 1)\n\tint_str=`echo\
    \ $int_str | awk '{print tolower(substr($0, 1, 1))}'`\n\t# Determine how long\
    \ $int_str is going to be\n\tint_str_length=$(echo $int_str | wc -c)\n\t# Determine\
    \ if $int_str is going to take up more than 3 characters\n\t# and if so, add a\
    \ zero character at the end to make up for it\n\tif [[ $int_str_length -gt 3 ]];\
    \ then\n\t\tint_str=$int_str\"0\"\n\tfi\n\t# Get the initial letter\n\tint_str_first=$(echo\
    \ $int_str | awk '{print $1}')\n\t# Determine if the integer is even, odd, or\
    \ neither\n\t# An even integer will always begin with an \"i\" instead of an \"\
    x\"\n\tint_is_even=$(( $int_num % 2 ))\n\t# Determine if $int_str is even or odd\n\
    \tif [[ $int_is_even -eq 1 ]]; then\n\t\tint_str_even=$(echo $int_str | awk '{print\
    \ $1}')\n\telse\n\t\tint_str_odd=$(echo $int_str | awk '{print $1}')\n\tfi\n\t\
    # Determine if the integer is higher or lower\n\tint_is_higher_or_lower=$(( $int_num\
    \ > $int_num ))\n\t# Determine which roman numeral to use\n\tint_to_roman_roman=0\n\
    \tint_to_roman_decimal=0\n\tint_to_roman_thousands=0\n\tint_to_roman_thousands_decimal=0\n\
    \tif [[ $int_is_even -eq 1 ]]; then\n\t\tif [[ $int_is_higher_or_lower -eq 1 ]];\
    \ then\n\t\t\tint_to_roman_roman=\"i\"\n\t\t\tint_to_roman_thousands=\"x\"\n\t\
    \telse\n\t\t\tint_to_roman_roman=\"i\"\n\t\tfi\n\t\tint_to_roman_decimal=$int_num\n\
    \t\tif [[ $int_str_length -ge 4 ]]; then\n\t\t\tint_to_roman_thousands_decimal=$(($int_to_roman_decimal/1000))\n\
    \t\tfi\n\t\tint_to_roman_thousands=$int_to_roman_thousands_decimal\n\t\tint_to_roman_thousands=$(echo\
    \ $int_to_roman_thousands | sed -e 's/.$//')\n\telse\n\t\tif [[ $int_", "  local\
    \ num=\"$1\"\n  local a\n\n  # Handle some special cases early\n  case \"$num\"\
    \ in\n    # 1\n    \"$num\")\n      echo \"$num\"\n      ;;\n\n    # 2\n    \"\
    $num$num\")\n      echo \"$num$num\"\n      ;;\n\n    # 3\n    \"$num$num$num\"\
    )\n      echo \"$num$num$num\"\n      ;;\n\n    # 4\n    \"$num$num$num$num\"\
    )\n      echo \"$num$num$num$num\"\n      ;;\n\n    # 5\n    \"$num$num$num$num$num\"\
    )\n      echo \"$num$num$num$num$num\"\n      ;;\n\n    # 6\n    \"$num$num$num$num$num$num\"\
    )\n      echo \"$num$num$num$num$num$num\"\n      ;;\n\n    # 7\n    \"$num$num$num$num$num$num$num\"\
    )\n      echo \"$num$num$num$num$num$num$num\"\n      ;;\n\n    # 8\n    \"$num$num$num$num$num$num$num$num\"\
    )\n      echo \"$num$num$num$num$num$num$num$num\"\n      ;;\n\n    # 9\n    \"\
    $num$num$num$num$num$num$num$num$num\")\n      echo \"$num$num$num$num$num$num$num$num$num\"\
    \n      ;;\n\n    # 10\n    \"$num$num$num$num$num$num$num$num$num$num\")\n  \
    \    echo \"$num$num$num$num$num$num$num$num$num$num\"\n      ;;\n\n    # 11\n\
    \    \"$num$num$num$num$num$num$num$num$num$num$num\")\n      echo \"$num$num$num$num$num$num$num$num$num$num$num\"\
    \n      ;;\n\n    # 12\n    \"$num$num$num$num$num$num$num$num$num$num$num$num\"\
    )\n      echo \"$num$num$num$num$num$num$num$num$num$num$num$num\"\n      ;;\n\
    \n    # 13\n    \"$num$num$num$num$num$num$num$", "  local -i roman_num=\"$1\"\
    \n  local -i roman_num_in_base_ten=\"$(( roman_num / 10 ))\"\n  local -i remainder=\"\
    $(( roman_num % 10 ))\"\n  local -i roman_num_chars=\"IJKLMNOPQ\"\n  local -i\
    \ roman_num_chars_index_for_base_ten=\"$(( roman_num_in_base_ten + 1 ))\"\n  local\
    \ -i roman_num_chars_index_for_roman=\"$(( roman_num_chars - 1 ))\"\n  local -a\
    \ base_ten_chars=(\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\" \"M\" \"L\" \"X\"\
    \ \"V\")\n  local -a roman_chars=(\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\" \"\
    M\" \"L\" \"X\" \"V\")\n\n  (( roman_chars[roman_num_chars_index_for_roman] ))\n\
    \n  # If there are no more letters to output, reverse the array.\n  if [[ ${#base_ten_chars[*]}\
    \ -le ${#roman_chars[*]} ]]; then\n    base_ten_chars=($(tac \"${base_ten_chars[*]}\"\
    ))\n    roman_chars=($(tac \"${roman_chars[*]}\"))\n  fi\n\n  local output\n \
    \ local output_length\n  local output_char_length\n  local output_char_length_index\n\
    \  local output_char_length_max_index\n  local output_char_length_min_index\n\
    \  local output_char_length_max_length\n  local output_char_length_min_length\n\
    \  local output_char_length_max_length_index\n  local output_char_length_min_length_index\n\
    \  local output_char_length_index\n  local output_char_length_index_min\n  local\
    \ output_char_length_index_max\n\n  # If there are multiple characters, take only\
    \ one.\n  case \"${roman_chars[*]}\" in\n    *)\n      output=\"${roman_chars[roman_num_chars_index_for_roman]}\"\
    \n      ;;\n  esac\n\n  output_length=\"${#output}\"\n  output_char_length=\"\
    ${#output_char_length}\"\n  output_char_length_index=\"${roman_num_chars_index_for_roman}\"\
    \n  output_char_length_min_index=\"${roman_num_chars_index_for_base_ten}\"\n \
    \ output_char_length_max_index=\"${roman_num_chars_index_for_base_ten}${#base_ten_chars[*]}\"\
    \n  output_char_length_min_length=\"${#base_", "    # $1 is an integer\n    if\
    \ [[ ! \"$1\" =~ ^[0-9]+$ ]]; then\n        echo \"int_to_mini_roman: bad argument\
    \ \\\"$1\\\", must be an integer\" >&2\n        return 1\n    fi\n\n    roman=\"\
    ${1}\"\n    while [ \"$roman\" -gt 1000 ]; do\n        roman=$(($roman / 10))\n\
    \    done\n\n    while [ \"$roman\" -lt 1000 ]; do\n        mini=\"${roman}\"\n\
    \        roman=$(($roman / 10))\n        case \"$roman\" in\n            0)\n\
    \                mini=\"x\"\n                ;;\n            1)\n            \
    \    mini=\"c\"\n                ;;\n            2)\n                mini=\"d\"\
    \n                ;;\n            3)\n                mini=\"m\"\n           \
    \     ;;\n            4)\n                mini=\"l\"\n                ;;\n   \
    \         5)\n                mini=\"x\"\n                ;;\n            6)\n\
    \                mini=\"v\"\n                ;;\n            7)\n            \
    \    mini=\"f\"\n                ;;\n            8)\n                mini=\"s\"\
    \n                ;;\n            9)\n                mini=\"p\"\n           \
    \     ;;\n            *)\n                echo \"int_to_mini_roman: bad argument\
    \ \\\"$1\\\", must be an integer <= 1000\" >&2\n                return 1\n   \
    \             ;;\n        esac\n        mini=\"$mini$mini\"\n    done\n\n    echo\
    \ \"$mini\"", "    local num=\"$1\"\n    local roman_num=\"\"\n    case \"$num\"\
    \ in\n        1)  echo \"I\";;\n        2)  echo \"II\";;\n        3)  echo \"\
    III\";;\n        4)  echo \"IV\";;\n        5)  echo \"V\";;\n        6)  echo\
    \ \"VI\";;\n        7)  echo \"VII\";;\n        8)  echo \"VIII\";;\n        9)\
    \  echo \"IX\";;\n        *)  echo \"$num\";;\n    esac", "  if [[ $1 == \"1\"\
    \ ]]; then\n    echo $1\n  else\n    while [[ $1 -gt 0 ]]; do\n      (( $1 % 1000\
    \ < 15 )) && echo $1\n      (( $1 % 1000 < 30 )) && echo $1 + ($1 % 1000) / 100\n\
    \      (( $1 % 1000 < 40 )) && echo $1 + ($1 % 1000) / 10 + ($1 % 100) / 100\n\
    \      (( $1 % 1000 < 50 )) && echo $1 + ($1 % 1000) / 5 + ($1 % 100) / 10 + ($1\
    \ % 10) / 100\n      (( $1 % 1000 < 60 )) && echo $1 + ($1 % 1000) / 10 + ($1\
    \ % 100) / 5 + ($1 % 10) / 10 + ($1 % 5) / 100\n      (( $1 % 1000 < 70 )) &&\
    \ echo $1 + ($1 % 1000) / 5 + ($1 % 100) / 10 + ($1 % 10) / 5 + ($1 % 5) / 10\
    \ + ($1 % 2) / 100\n      (( $1 % 1000 < 80 )) && echo $1 + ($1 % 1000) / 10 +\
    \ ($1 % 100) / 5 + ($1 % 10) / 5 + ($1 % 5) / 10 + ($1 % 2) / 5 + ($1 % 2) / 10\n\
    \      (( $1 % 1000 < 90 )) && echo $1 + ($1 % 1000) / 5 + ($1 % 100) / 10 + ($1\
    \ % 10) / 5 + ($1 % 5) / 10 + ($1 % 2) / 5 + ($1 % 2) / 10\n      (( $1 % 1000\
    \ < 100 )) && echo $1 + ($1 % 1000) / 10 + ($1 % 100) / 5 + ($1 % 10) / 5 + ($1\
    \ % 5) / 10 + ($1 % 2) / 5 + ($1 % 2) / 10\n      (( $1 % 1000 < 105 )) && echo\
    \ $1 + ($1 % 1000) / 5 + ($1 % 100) / 10 + ($1 % 10) / 5 + ($1 % 5) / 10 + ($1\
    \ % 2) / 5 + ($1 % 2) / 10\n      (( $1 % 1000 < 110 )) && echo $1 + ($1 % 1000)\
    \ / 10 + ($1 % 100) / 5 + ($1 % 10) / 5 + ($1 % 5) / 10 + ($1 % 2) / 5 + ($1 %\
    \ 2) / 10\n      (( $1 % 1000 < 115 )) && echo $1 + ($1 % 1000) / 5 + ($1 % 100)\
    \ / 10 + ($1 % 10) / 5 + ($1 % 5) / 10 + ($1 % 2) / 5 + ($1 % 2) / 10\n      ((\
    \ $1 % 1000 < 120 )) && echo $1 + ($1 % 1000) / 10 + ($1 % 100) / 5 + ($1 % 10)\
    \ / 5 + ($1 % 5) / 10 + ($1 % 2) / 5 + ($1 % 2) / 10\n      ((", "    # $1 is\
    \ an integer\n    local num=$1\n    # Romans use I, X, V, L, C, D, M\n    local\
    \ roman_map=(\"I\" \"X\" \"V\" \"L\" \"C\" \"D\" \"M\")\n    # Initialize variables\
    \ we need\n    local i count\n    # Loop through all values in $roman_map\n  \
    \  for (( i = 0; $i < ${#roman_map[@]}; i++ )); do\n        # See if we have a\
    \ value equal to $num\n        if [ $num -eq \"${roman_map[$i]}\" ]; then\n  \
    \          count=$(( ${i} + 1 ))\n            break\n        fi\n    done\n  \
    \  # See if $count was set to something non-zero\n    if [ -n \"${roman_map[$count]}\"\
    \ ]; then\n        # Return the roman numeral of that value\n        echo $(roman_map[$count])\n\
    \    else\n        # If $count was not set to anything non-zero, return the unchanged\n\
    \        # $num in lowercase\n        echo $(echo \"$num\" | tr [:upper:] [:lower:])\n\
    \    fi", "  local x\n  local num=$1\n\n  if [[ ! $num =~ ^[0-9]+$ ]]; then\n\
    \    echo \"Invalid integer passed to int_to_mini_roman: $1\"\n    return 1\n\
    \  fi\n  if [[ $num == 0 ]]; then\n    echo \"Invalid integer passed to int_to_mini_roman:\
    \ $num\"\n    return 1\n  fi\n\n  local roman_num=\"\"\n\n  local i count\n  for\
    \ i in $(seq 1 $num); do\n    count=0\n    while [ $count -le $((i-1)) ] && [\
    \ $((i*10 + $count)) -gt $num ]; do\n      count=$((count+1))\n    done\n    roman_num=$roman_num$((i*10\
    \ + $count))\n  done\n  echo \"$roman_num\"", "  [[ $1 =~ ^[0-9]+$ ]] && echo\
    \ \"$1\" || exit 1\n  local num=$1\n  local roman=\"\"\n  local i=0\n  while [\
    \ \"$i\" -lt \"$num\" ]; do\n    local digit=$((num % 10))\n    roman+=($(roman_char[${digit}]))\n\
    \    num=$((num / 10))\n    ((i=i+1))\n  done\n  echo \"${roman[@]}\"", "  local\
    \ n=\"$1\"\n  local mini_roman=\"\"\n  local nstr=\"$n\"\n  local i=0\n  while\
    \ [ $n -gt 0 ]; do\n    local roman=\"\"\n    local nstr=\"${nstr%?}\"\n    local\
    \ digit=$(( $(nstr) - 1 ))\n    local char=$(( 48 + $digit ))\n    local digit=$((\
    \ $digit > 0 ))\n    if [ $digit -eq 0 ]; then\n      roman=\"x\"\n    elif [\
    \ $digit -eq 1 ]; then\n      roman=\"x\"\n    elif [ $digit -eq 2 ]; then\n \
    \     roman=\"l\"\n    elif [ $digit -eq 3 ]; then\n      roman=\"l\"\n    elif\
    \ [ $digit -eq 4 ]; then\n      roman=\"c\"\n    elif [ $digit -eq 5 ]; then\n\
    \      roman=\"c\"\n    elif [ $digit -eq 6 ]; then\n      roman=\"x\"\n    elif\
    \ [ $digit -eq 7 ]; then\n      roman=\"l\"\n    elif [ $digit -eq 8 ]; then\n\
    \      roman=\"c\"\n    elif [ $digit -eq 9 ]; then\n      roman=\"x\"\n    elif\
    \ [ $digit -eq 10 ]; then\n      roman=\"l\"\n    elif [ $digit -eq 11 ]; then\n\
    \      roman=\"x\"\n    elif [ $digit -eq 12 ]; then\n      roman=\"l\"\n    elif\
    \ [ $digit -eq 13 ]; then\n      roman=\"c\"\n    elif [ $digit -eq 14 ]; then\n\
    \      roman=\"l\"\n    elif [ $digit -eq 15 ]; then\n      roman=\"x\"\n    elif\
    \ [ $digit -eq 16 ]; then\n      roman=\"l\"\n    elif [ $digit -eq 17 ]; then\n\
    \      roman=\"c\"\n    elif [ $digit -eq 18 ]; then\n      roman=\"l\"\n    elif\
    \ [ $digit -eq 19 ]; then\n      roman=\"x\"\n    elif [ $digit -eq 20 ]; then\n\
    \      roman=\"l\"\n    elif [ $digit -eq 21 ]; then\n      roman=\"x\"\n    elif\
    \ [ $digit -eq 22 ]; then\n      roman=\"l\"\n    elif [ $digit -eq 23 ]; then\n\
    \      roman=\"x\"\n    elif [ $digit -eq 24 ]; then\n      roman=\"l\"\n    elif\
    \ [ $digit -eq 25 ]; then\n      roman=\"x\"\n    elif [ $digit -eq 26 ", "  \
    \  local i\n    for ((i = 0; i < ($1); i++)); do\n        if (( $i % 10 == 0 ));\
    \ then\n            printf \"%s\" \"${i//10}\"\n        else\n            echo\
    \ -n \"${i//10}\"\n            roman_num=$(echo \"${i//10}\"|sed 's/i/i/;s/x/x/;s/c/c/;s/o/o/;s/l/l/;s/m/m/;s/k/k/;s/s/s/;s/x/x/g;s/c/c/g;s/o/c/g;s/l/l/g;s/m/m/g;s/k/k/g;s/s/s/g;s/x//g;s/c//g;s/o//g;s/l//g;s/m//g;s/k//g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/m/g;s/k/g;s/s/s//g;s/x/g;s/c/g;s/o/g;s/l/g;s/",
  "  local num=$1\n  local roman=\"\"\n  local roman_part=\"\"\n  local i=0\n  local\
    \ base=1\n\n  while [ \"$num\" -ge 1000 ]; do\n    num=$((num % 1000))\n    roman_part+=\"\
    M\"\n    ((i++))\n  done\n\n  while [ \"$num\" -ge 100 ]; do\n    num=$((num %\
    \ 100))\n    roman_part+=\"C\"\n    ((i++))\n  done\n\n  while [ \"$num\" -ge\
    \ 10 ]; do\n    num=$((num % 10))\n    roman_part+=\"D\"\n    ((i++))\n  done\n\
    \n  while [ \"$num\" -gt 0 ]; do\n    num=$((num % 10))\n    roman_part+=\"C\"\
    \n    ((i++))\n  done\n\n  if [ $roman_part ]\n  then\n    roman=$roman_part$roman\n\
    \  fi\n\n  if [ $i -gt 0 ]\n  then\n    roman=$roman\"x\"\n  fi\n\n  echo \"$roman\"",
  "    local num=$1\n    local mini_roman=\"\"\n    # Check for edge cases.\n    if\
    \ [[ $num == 1 ]]; then\n        mini_roman=\"x\"\n    elif [[ $num == 0 ]]; then\n\
    \        mini_roman=\"z\"\n    else\n        # Loop through the remainder of num\
    \ in descending order\n        # as we iterate through the digits from left to\
    \ right. \n        # Reverse the result of each iteration so that the first\n\
    \        # iteration is the largest number and iterating from the\n        # right\
    \ to left is the smallest possible outcome.\n        for (( i = num; i; i-- ));\
    \ do\n            # Multiply num by its proper divisor\n            local num=$(echo\
    \ $i | rev | cut -d \"/\" -f 2 | rev)\n            # Add the current number to\
    \ the accumulator mini_roman\n            local mini_roman=$(( ${mini_roman}${mini_roman:+}\
    \ ${num%${mini_roman}}))\n        done\n    fi\n    echo ${mini_roman:1}", " \
    \   # Convert number to binary string\n    roman=( $(printf \"%d\\t%d\" $1 $((10#$1)))\
    \ )\n    # Initialize roman\n    roman += (\"x\"\n            # x is unchanged,\
    \ c's are increased by 1 (for 10's), and i's\n            # decreased by 1 (for\
    \ 1's)\n            \"c\"\n            \"i\"\n            \"i\"\n            )\n\
    \    local num=\"${roman[0]}\"\n    # Iterate over remaining array elements\n\
    \    for ((i=1; i<${#roman[@]}; i++)); do\n        case \"${roman[i]}\" in\n \
    \           c) num+=\"x\"\n            ;;\n            i) num-=\"x\"\n       \
    \     ;;\n        x) num+=${roman[i-1]}\n            ;;\n    esac\n    echo \"\
    ${num,,}\"", "    local num=$1\n    if [ $num -gt 1000 || $num -le 1 ]; then\n\
    \        echo \"Invalid input: $num\"\n        return\n    fi\n\n    # https://en.wikipedia.org/wiki/Roman_numeral_system\n\
    \    local roman=\"m\"\n    local prefix=\"k\"\n    if [ $num -le 5 ]; then\n\
    \        roman=\"c\"\n        prefix=\"b\"\n    elif [ $num -le 10 ]; then\n \
    \       roman=\"d\"\n        prefix=\"c\"\n    elif [ $num -le 100 ]; then\n \
    \       roman=\"m\"\n        prefix=\"c\"\n    elif [ $num -le 1000 ]; then\n\
    \        roman=\"m\"\n        prefix=\"f\"\n    fi\n\n    # A \"while\" loop will\
    \ iterate until $num is 0 or negative.\n    while [ $num -gt 0 ]; do\n       \
    \ # Divide the number by 100 and store remainder in $quotient. Round to int\n\
    \        local quotient=$(echo $num / 100 | bc)\n        local remainder=$(($num\
    \ % 100))\n        roman=\"$roman${roman}${prefix}${quotient}\"\n        # Update\
    \ $num to $remainder\n        num=$(echo $remainder | bc)\n    done\n    # Strip\
    \ leading zero\n    roman=\"${roman%k}\"\n    # Remove trailing \"x\"\n    roman=\"\
    ${roman#*x}\"\n    # Remove trailing \"m\"\n    roman=\"${roman%m}\"\n\n    echo\
    \ $roman", "  local num=$1\n  local d=0\n  local r=''\n  local ds=''\n  # The\
    \ number starts with Roman numerals up to 1000\n  # The number starts with II\
    \ numerals up to 900\n  # The number starts with III numerals up to 900\n  # The\
    \ number starts with IV numerals up to 900\n  # The number starts with V numerals\
    \ up to 900\n  # The number starts with VI numerals up to 900\n  # The number\
    \ starts with VII numerals up to 900\n  # The number starts with VIII numerals\
    \ up to 900\n  # The number starts with IX numerals up to 900\n  # The number\
    \ starts with XX numerals up to 900\n  # The number starts with XI numerals up\
    \ to 900\n  # The number starts with XI numerals up to 900\n  # The number starts\
    \ with I numerals up to 900\n  # The number starts with III numerals up to 900\n\
    \  # The number starts with IV numerals up to 900\n  # The number starts with\
    \ V numerals up to 900\n  # The number starts with VI numerals up to 900\n  #\
    \ The number starts with VII numerals up to 900\n  # The number starts with VIII\
    \ numerals up to 900\n  # The number starts with XX numerals up to 900\n  # The\
    \ number starts with XI numerals up to 900\n  # The number starts with I numerals\
    \ up to 900\n  # The number starts with III numerals up to 900\n  # The number\
    \ starts with IV numerals up to 900\n  # The number starts with V numerals up\
    \ to 900\n  # The number starts with VI numerals up to 900\n  # The number starts\
    \ with VII numerals up to 900\n  # The number starts with VIII numerals up to\
    \ 900\n  # The number starts with XX numerals up to 900\n  # The number starts\
    \ with XI numerals up to 900\n  # The number starts with I numerals up to 900\n\
    \  # The number starts with III numerals up to 900\n  # The number starts with\
    \ IV numerals up to 900\n  # The number starts with V numerals up to 900\n  #\
    \ The number starts with VI numerals up to 900\n  # The number starts with VII\
    \ numerals up to 900\n  # The number starts with VIII numerals up to 900\n  #\
    \ The number starts with XX ", "  local num=$1\n  local roman\n  case $num in\n\
    \    1)  roman=\"xix\"\n        ;;\n    10)  roman=\"ex\"\n        ;;\n    11)\
    \  roman=\"dx\"\n        ;;\n    12)  roman=\"cc\"\n        ;;\n    13)  roman=\"\
    ccc\"\n        ;;\n    14)  roman=\"cd\"\n        ;;\n    15)  roman=\"cdd\"\n\
    \        ;;\n    16)  roman=\"cccd\"\n        ;;\n    17)  roman=\"cccc\"\n  \
    \      ;;\n    18)  roman=\"cdddd\"\n        ;;\n    19)  roman=\"cdxxvi\"\n \
    \       ;;\n    20)  roman=\"xixvi\"\n        ;;\n    21)  roman=\"xixvii\"\n\
    \        ;;\n    22)  roman=\"xixix\"\n        ;;\n    23)  roman=\"xixixi\"\n\
    \        ;;\n    24)  roman=\"xixixii\"\n        ;;\n    25)  roman=\"xixixiii\"\
    \n        ;;\n    26)  roman=\"xixixiv\"\n        ;;\n    27)  roman=\"xixixivh\"\
    \n        ;;\n    28)  roman=\"xixixivh\"\n        ;;\n    29)  roman=\"xixixivh\"\
    \n        ;;\n    30)  roman=\"xixixvi\"\n        ;;\n    31)  roman=\"xixixvii\"\
    \n        ;;\n    32)  roman=\"xixixix\"\n        ;;\n    33)  roman=\"xixixxi\"\
    \n        ;;\n    34)  roman=\"xixixxi\"\n        ;;\n    35)  roman=\"xixixxii\"\
    \n        ;;\n    36)  roman=\"xixixxiii\"\n        ;;\n    37)  roman=\"xixixxiv\"\
    \n        ;;\n    38)  roman=\"xixixxi\"\n        ;;\n    39)  roman=\"xixixxi\"\
    \n        ;;\n    40)  roman=\"xixixxii\"\n        ;;\n    41)  roman=\"xixixxiii\"\
    \n        ;;\n    42)  roman=\"xixixxiv\"\n        ;;\n    43)  ro", "  local\
    \ int_arg=$1\n  local int_len=$(echo $int_arg | wc -w)\n  local int_string=$int_arg\n\
    \  local roman_numeral=$(\n    echo $int_string | \\\n    sed -e \"s/^.\\{1,$int_len\\\
    }$/.\\1/\" | \\\n    sed -e \"s/\\(.\\{1\\}\\)./\\1ii/\"\n  )\n  echo \"$roman_numeral\"\
    \ | tr '[:upper:]' '[:lower:]'", "  echo \"$1\"\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n\
    \    local num=$1\n    if [[ $num -lt 1 ]]; then\n      return \"Error - invalid\
    \ input: ${num}\"\n    elif [[ $num -lt 1000 ]]; then\n      return \"Error -\
    \ invalid input: ${num}: not between 1 and 1000\"\n    else\n      local i=0 roman\n\
    \      while [[ $i -lt 10 ]]; then\n        roman=$(printf '%02d' $(( (num % 10)\
    \ * $i )))\n        (( i++ ))\n        if [[ $roman =~ ^[0-9]+$ ]]; then\n   \
    \       echo $roman\n          return\n        fi\n      done\n    fi\n  fi",
  "    # Check to make sure the integer is in the valid range\n    if [ \"$1\" -gt\
    \ 1 -a \"$1\" -lt 1000 ]; then\n        # Convert integer to its roman numeral\
    \ equivalent\n        echo \"$(roman_numeral_to_int \"$1\")\" | xargs -I{} printf\
    \ \"%s\" {} | tr \"\\n\" \" \"\n    else\n        echo \"Invalid input\"\n   \
    \     exit 1\n    fi", "  local int=$1\n  # special cases\n  if [[ $int == 1 ]];\
    \ then\n    echo \"i\"\n  elif [[ $int == 2 ]]; then\n    echo \"ii\"\n  elif\
    \ [[ $int == 3 ]]; then\n    echo \"iii\"\n  elif [[ $int == 4 ]]; then\n    echo\
    \ \"iv\"\n  elif [[ $int == 5 ]]; then\n    echo \"v\"\n  elif [[ $int == 6 ]];\
    \ then\n    echo \"vi\"\n  elif [[ $int == 7 ]]; then\n    echo \"vii\"\n  elif\
    \ [[ $int == 8 ]]; then\n    echo \"viii\"\n  elif [[ $int == 9 ]]; then\n   \
    \ echo \"ix\"\n  elif [[ $int == 10 ]]; then\n    echo \"x\"\n  elif [[ $int ==\
    \ 11 ]]; then\n    echo \"xi\"\n  elif [[ $int == 12 ]]; then\n    echo \"xii\"\
    \n  elif [[ $int == 13 ]]; then\n    echo \"xiv\"\n  elif [[ $int == 14 ]]; then\n\
    \    echo \"xvi\"\n  elif [[ $int == 15 ]]; then\n    echo \"xvii\"\n  elif [[\
    \ $int == 16 ]]; then\n    echo \"xviii\"\n  elif [[ $int == 17 ]]; then\n   \
    \ echo \"xix\"\n  elif [[ $int == 18 ]]; then\n    echo \"xx\"\n  elif [[ $int\
    \ == 19 ]]; then\n    echo \"xxi\"\n  elif [[ $int == 20 ]]; then\n    echo \"\
    xxii\"\n  elif [[ $int == 21 ]]; then\n    echo \"xxiii\"\n  elif [[ $int == 22\
    \ ]]; then\n    echo \"xxiv\"\n  elif [[ $int == 23 ]]; then\n    echo \"xxv\"\
    \n  elif [[ $int == 24 ]]; then\n    echo \"xxvi\"\n  elif [[ $int == 25 ]]; then\n\
    \    echo \"xxvii\"\n  elif [[ $int == 26 ]]; then\n    echo \"xxviii\"\n  elif\
    \ [[ $int == 27 ]]; then\n    echo \"xxix\"\n  elif [[ $int == 28 ]]; then\n \
    \   echo \"xxx\"\n  else\n    # general case\n    local i\n    local i\n    local\
    \ i\n    local i\n    local i\n    local i\n    local i\n    local i\n    local\
    \ i\n    local i\n    local i\n    local i\n    local i\n    local i\n    local\
    \ i\n    local i\n    local i\n    local i\n    local i\n    local i\n    local\
    \ i\n    local i\n    local i\n    local i\n    local i\n    local i\n    local\
    \ i\n    local i\n    local i\n    local i\n    local i\n    local i\n    local\
    \ i\n    local i\n    ", "  local num=\"$1\"\n  local numroman=''\n  local numroman_temp=''\n\
    \  local digit\n  local nroman_prefix=''\n  local nroman_suffix=''\n  local suffix=''\n\
    \  local prefix=''\n  local i\n  local j\n  local num_digits=${#num}\n\n  i=1;\
    \ j=1;\n  while [ $i -le $num_digits ]\n  do\n    digit=\"${num:$i:1}\"\n    case\
    \ \"$digit\" in\n      I) nroman_prefix=\"x\";;\n      V) nroman_prefix=\"l\"\
    ;;\n      X) nroman_prefix=\"c\";;\n      L) nroman_prefix=\"i\";;\n      C) nroman_prefix=\"\
    d\";;\n      D) nroman_prefix=\"m\";;\n      M) nroman_prefix=\"p\";;\n      P)\
    \ nroman_prefix=\"n\";;\n      N) nroman_prefix=\"k\";;\n    esac\n\n    suffix=''\n\
    \    prefix=''\n    case \"$digit\" in\n      a) suffix=\"a\";;\n      b) suffix=\"\
    b\";;\n      c) suffix=\"c\";;\n      d) suffix=\"d\";;\n      e) suffix=\"e\"\
    ;;\n      f) suffix=\"f\";;\n      g) suffix=\"g\";;\n      h) suffix=\"h\";;\n\
    \      i) suffix=\"i\";;\n      j) suffix=\"j\";;\n      k) suffix=\"k\";;\n \
    \     l) suffix=\"l\";;\n      m) suffix=\"m\";;\n      n) suffix=\"n\";;\n  \
    \    o) suffix=\"o\";;\n      p) suffix=\"p\";;\n      q) suffix=\"q\";;\n   \
    \   r) suffix=\"r\";;\n      s) suffix=\"s\";;\n      t) suffix=\"t\";;\n    \
    \  u) suffix=\"u\";;\n      v) suffix=\"v\";;\n      w) suffix=\"w\";;\n     \
    \ x) suffix=\"x\";;\n      y) suffix=\"y\";;\n      z) suffix=\"z\";;\n    esac\n\
    \n    # Append the prefix\n    if [[ $j -le $num_digits ]]\n    then\n      if\
    \ [[ \"$i\" -eq 1 ]]\n      then\n        prefix=$prefix$nroman_prefix\n     \
    \ elif [[ \"$i", "    local roman_number=$1\n    local result=\"\"\n    local\
    \ counter=1\n    while [ $counter -le $roman_number ]; do\n        local roman_digit_as_int=$(($counter\
    \ % 10))\n        local roman_digit_as_char=$(printf \"%c\" $roman_digit_as_int)\n\
    \        local roman_digit_as_string=$(printf \"%o\" $roman_digit_as_int)\n  \
    \      result+=\"$roman_digit_as_char\"\n        counter=$((counter + 1))\n  \
    \  done\n    echo $result", "    local num=\"$1\"\n\n    case \"$num\" in\n  \
    \      0)\n            # 0 is uncommon\n            echo \"0\"\n        ;;\n \
    \       1)\n            # 1 is rare\n            echo \"x\"\n        ;;\n    \
    \    2)\n            # 2 is common\n            echo \"l\"\n        ;;\n     \
    \   3)\n            # 3 is uncommon\n            echo \"cl\"\n        ;;\n   \
    \     4)\n            # 4 is common\n            echo \"xl\"\n        ;;\n   \
    \     5)\n            # 5 is uncommon\n            echo \"lx\"\n        ;;\n \
    \       6)\n            # 6 is common\n            echo \"ix\"\n        ;;\n \
    \       7)\n            # 7 is uncommon\n            echo \"ic\"\n        ;;\n\
    \        8)\n            # 8 is common\n            echo \"ib\"\n        ;;\n\
    \        9)\n            # 9 is uncommon\n            echo \"iu\"\n        ;;\n\
    \        10)\n            # 10 is common\n            echo \"i\"\n        ;;\n\
    \        *)\n            # Everything above 9 is common\n            echo \"xiii\"\
    \n        ;;\n    esac", "  local int_str=\"$1\"\n  local roman_str=\"\"\n\n \
    \ int_str=${int_str:0:1}\n  int_str=${int_str:0:1}\n  int_str=${int_str:0:1}\n\
    \  int_str=${int_str:0:1}\n  int_str=${int_str:0:1}\n\n  for ((i=0;i<int_str.length;i++));\
    \ do\n    roman_str=\"$roman_str ${int_str:i:1}\"\n  done\n\n  echo \"$roman_str\"",
  "  local number=$1\n  local result=\"\"\n  local roman=\"$(mini_to_roman_numeral\
    \ $number)\"\n  while [[ -n \"$roman\" ]]; do\n    local letter=$(echo $roman\
    \ | cut -d \"x\" -f 1)\n    local numeral=$(echo $roman | cut -d \"x\" -f 2)\n\
    \    case \"$letter\" in\n      i|I) numeral=\"$(mini_to_roman_numeral $numeral)\"\
    \ ;;\n      v|V) numeral=\"$(mini_to_roman_numeral $numeral)\" ;;\n      l|L)\
    \ numeral=\"$(mini_to_roman_numeral $numeral)\" ;;\n      c|C) numeral=\"$(mini_to_roman_numeral\
    \ $numeral)\" ;;\n      d|D) numeral=\"$(mini_to_roman_numeral $numeral)\" ;;\n\
    \    esac\n    case \"$numeral\" in\n      0) numeral=\"l\" ;;\n      1) numeral=\"\
    c\" ;;\n      2) numeral=\"x\" ;;\n      3) numeral=\"l\" ;;\n      4) numeral=\"\
    c\" ;;\n      5) numeral=\"x\" ;;\n      6) numeral=\"l\" ;;\n      7) numeral=\"\
    c\" ;;\n      8) numeral=\"x\" ;;\n      9) numeral=\"c\" ;;\n      10) numeral=\"\
    l\" ;;\n      11) numeral=\"c\" ;;\n      12) numeral=\"x\" ;;\n      13) numeral=\"\
    l\" ;;\n      14) numeral=\"c\" ;;\n      15) numeral=\"x\" ;;\n      16) numeral=\"\
    l\" ;;\n      17) numeral=\"c\" ;;\n      18) numeral=\"x\" ;;\n      19) numeral=\"\
    c\" ;;\n      20) numeral=\"l\" ;;\n      21) numeral=\"c\" ;;\n      22) numeral=\"\
    x\" ;;\n      23) numeral=\"l\" ;;\n      24) numeral=\"c\" ;;\n      25) numeral=\"\
    x\" ;;\n      26) numeral=\"l\" ;;\n      27) numeral=\"c\" ;;\n      28) numeral=\"\
    x\" ;;\n      29) numeral=\"c\" ;;\n      30) numeral=\"l\" ;;\n      31) numeral=\"\
    c\" ;;\n", "    local num=\"$1\"\n    local int_to_mini=\"$int_to_mini\"\n   \
    \ local i\n\n    local mini_roman=\"\"\n    while [ $num -lt 1000 ]; do\n    \
    \    int_to_mini=\"$int_to_mini${mini_roman:+}$int_to_mini\"\n        ((num+=1))\n\
    \    done\n\n    local i\n    for i in $(seq 1 $num); do\n        local mini_roman_suffix=\"\
    $int_to_mini${mini_roman:+}$int_to_mini\"\n        mini_roman=\"$mini_roman${mini_roman_suffix:1:1}\"\
    \n    done\n\n    echo $mini_roman", "\tlocal num=\"$1\"\n\tif [ \"$(expr match\
    \ \"$num\" '.*[0-9]')\" = \"0\" ]; then\n\t\techo \"$num\"\n\telse\n\t\twhile\
    \ [ \"$num\" -ge 1000 ]; do\n\t\t\tnum=\"$(( $num / 1000 ))\"\n\t\tdone\n\n\t\t\
    local roman=\"\"\n\t\tlocal i\n\t\tfor i in $(seq 1 $num); do\n\t\t\troman+=\"\
    $(mini_roman $(( $i - 1 )))\"\n\t\tdone\n\n\t\techo \"$roman\"\n\tfi", "\tlocal\
    \ num=${1:--1}\n\tlocal roman=\"\"\n\twhile [ $num -gt 0 ]; do\n\t\troman+=$((\
    \ $num % 10 ))\n\t\tnum=$( ( $num / 10 ))\n\tdone\n\tif [ $num -gt 0 ]; then\n\
    \t\troman+=$(( $num % 10 ))\n\tfi\n\techo \"$roman\" | tr '[:upper:]' '[:lower:]'",
  "    local num=$1\n\n    # Make sure that num is positive (we subtract it from the\
    \ original num here\n    # in case num is negative)\n    if [ $num -gt 1000 ]\n\
    \    then\n\techo \"ERROR: num is greater than 1000.\"\n\treturn 1\n    fi\n\n\
    \    # Make sure that the input number has no more than 4 characters\n    if [\
    \ $((num % 100)) -gt 4 ]\n    then\n\techo \"ERROR: num is greater than 1000.\"\
    \n\treturn 1\n    fi\n\n    # Make sure that the input number is within 1000 by\
    \ comparing it to its mod\n    # by 1000\n    if [ $((num % 1000)) -lt 1 ]\n \
    \   then\n\techo \"ERROR: num is greater than 1000.\"\n\treturn 1\n    fi\n\n\
    \    local roman=\"\"\n    local cnum=$((num % 10))\n    local dnum=$((num / 10\
    \ % 10))\n    local lnum=$((num / 100 % 10))\n    local inum=$((num / 1000 % 10))\n\
    \n    if [ $cnum -eq 0 ]\n    then\n\tif [ $dnum -eq 0 ]\n\tthen\n\t    if [ $lnum\
    \ -eq 0 ]\n\t    then\n\t\tif [ $inum -eq 0 ]\n\t\tthen\n\t\t    roman=x${roman}\n\
    \t\telse\n\t\t    roman=x${roman}i\n\t\tfi\n\t    else\n\t\tif [ $inum -eq 0 ]\n\
    \t\tthen\n\t\t    roman=x${roman}l\n\t\telse\n\t\t    roman=x${roman}l${lnum}\n\
    \t\tfi\n\t    fi\n\telse\n\t    if [ $inum -eq 0 ]\n\t    then\n\t\troman=x${roman}c\n\
    \t    else\n\t\tif [ $inum -eq 1 ]\n\t\tthen\n\t\t    roman=x${roman}cc\n\t\t\
    else\n\t\t    roman=x${roman}cc${cnum}\n\t\tfi\n\t    fi\n\tfi\n    else\n\tif\
    \ [ $dnum -eq 0 ]\n\tthen\n\t    if [ $inum -eq 0 ]\n\t    then\n\t\troman=x${roman}d\n\
    \t    else\n\t\tif [ $inum -eq 1 ]\n\t\tthen\n\t\t    roman=x${roman}dc\n\t\t\
    else\n\t\t    roman=x${roman}dc${cnum}\n\t\tfi\n\t    fi\n\telse\n\t    if [ $inum",
  "  local num=$1\n  local roman\n  local i\n  local roman_num\n  local roman_rev\n\
    \n  if [[ $num -lt 1 ]]; then\n    echo \"num is negative\"\n    return 0\n  elif\
    \ [[ $num -lt 1000 ]]; then\n    echo \"num too small\"\n    return 0\n  else\n\
    \    for roman_num in $(seq 1 ${#roman[@]}); do\n      roman=${roman[${roman_num}]}\n\
    \      if [[ $roman == \"\" ]]; then\n        echo \"roman is empty\"\n      \
    \  return 0\n      fi\n      if [[ $num -eq ${roman_num} ]]; then\n        if\
    \ [[ \"$roman\" == \"i\" ]]; then\n          roman_rev=\"ii\"\n          break\n\
    \        elif [[ \"$roman\" == \"ii\" ]]; then\n          roman_rev=\"iii\"\n\
    \          break\n        elif [[ \"$roman\" == \"iii\" ]]; then\n          roman_rev=\"\
    iv\"\n          break\n        elif [[ \"$roman\" == \"iv\" ]]; then\n       \
    \   roman_rev=\"v\"\n          break\n        elif [[ \"$roman\" == \"v\" ]];\
    \ then\n          roman_rev=\"\"\n          break\n        fi\n      fi\n    done\n\
    \  fi\n\n  roman_nums=()\n  roman_nums+=(\"${roman_rev}\")\n\n  for ((i=1; i <=\
    \ ${#roman_nums[*]}; i=i+2)); do\n    roman_nums+=(\"${roman_nums[*]:i:3}\")\n\
    \  done\n\n  echo \"${roman_nums[*]}\"", "    local var=\"$1\"\n    local roman=$(\
    \ roman_numeral \"$var\" )\n    local mini=$( mini_roman \"$roman\" )\n    echo\
    \ \"$mini\"", "  local num=$1\n  local roman_num\n  local roman_num_tmp\n  local\
    \ roman_num_length\n  local roman_num_prefix\n  roman_num=\"III\"\n  roman_num_tmp=\"\
    ${roman_num}\"\n  roman_num_prefix=\"I\"\n  while (( num > 0 )) ; do\n    roman_num_tmp=\"\
    $(roman_num_prefix $roman_num_tmp)\"\n    (( roman_num_length++))\n    (( num--))\n\
    \    roman_num_prefix=\"V\"\n  done\n  roman_num_tmp=\"$(roman_num_tmp 0)\"\n\
    \  roman_num=\"$(echo $roman_num)\"\n  if (( roman_num_length == 0 )); then\n\
    \    roman_num=\"$(echo $roman_num 0)\"\n  fi\n  roman_num=\"${roman_num}\"\n\
    \  echo \"${roman_num}\"", "  local num=\"$1\"\n  local output\n\n  if [ $num\
    \ -eq 1 ] ; then\n    output=\"I\"\n  elif [ $num -eq 2 ] ; then\n    output=\"\
    II\"\n  elif [ $num -eq 3 ] ; then\n    output=\"III\"\n  elif [ $num -eq 4 ]\
    \ ; then\n    output=\"IV\"\n  elif [ $num -eq 5 ] ; then\n    output=\"V\"\n\
    \  elif [ $num -eq 6 ] ; then\n    output=\"VI\"\n  elif [ $num -eq 7 ] ; then\n\
    \    output=\"VII\"\n  elif [ $num -eq 8 ] ; then\n    output=\"VIII\"\n  elif\
    \ [ $num -eq 9 ] ; then\n    output=\"IX\"\n  elif [ $num -ge 10 ] ; then\n  \
    \  output=\"X\"\n  else\n    echo \"Argument must be between 1 and 1000 inclusive\"\
    \n  fi\n\n  echo \"$output\"", "  echo $(eval echo '\\''$'\\{'$(($1 * 400 + 1))'':'$(($1\
    \ * 100 + 1))'':'$(($1 * 10 + 1))'}'\\'');", "  # We must enforce these restrictions\n\
    \  # 1 <= num <= 1000\n  local num=\"${1#0}\";\n  local result=`echo \"$num\"\
    \ | awk '{print \"$num\",\"0000\",\"vi\"}'`;\n  local num=\"${result%,*}\"\n \
    \ local result=\"${result#*,}\"\n  local count=\"${result%,*}\"\n  local result=\"\
    ${result#*,}\"\n  local count=\"${count#*,}\"\n  local result=\"${result#*,}\"\
    \n  echo \"${result%,*}\"", "    if [ $1 -lt 1 -o $1 -gt 1000 ]\n    then\n  \
    \      echo \"error: invalid input: argument 1 must be between 1 and 1000\"\n\
    \        exit 1\n    fi\n\n    # Initialize result variables\n    roman_number=\"\
    \"\n    mini_roman=\"\"\n\n    # Iterate through roman numbers from highest to\
    \ lowest\n    for (( num=${1}; num>0; num-- ))\n    do\n        # Get char at\
    \ the current position in the roman number\n        char=$(echo ${roman_number}\
    \ | cut -c${num})\n\n        # Append char at the current position to the mini-roman\
    \ string\n        mini_roman+=\"${char}\"\n    done\n\n    # Return mini-roman\
    \ string\n    echo \"${mini_roman}\"", "  local num=$1\n  local string=\"\"\n\
    \  while [ \"$num\" -gt 0 ]; do\n    local digit=$(($num % 10))\n    string=$(($string\
    \ $digit))\n    num=$(expr $num / 10)\n  done\n  echo $(echo $string | tr 'x'\
    \ 'i')", "  if [ $1 -lt 1 ]; then\n    echo \"Error: num is not positive\" 1>&2\n\
    \    exit 1\n  elif [ $1 -gt 1000 ]; then\n    echo \"Error: num is too large\"\
    \ 1>&2\n    exit 1\n  fi\n  local roman numeral\n  numeral=\"$1\"\n  roman=\"\"\
    \n  while [ \"$numeral\" -gt 0 ]; do\n    numeral=`expr $numeral \\% 1000`\n \
    \   roman=\"${roman}${roman_numeral_map[$numeral]}\"\n  done\n  echo \"$roman\"\
    \ | tr A-Z a-z", "    if [ $1 -eq 0 ]; then\n        echo \"X\"\n    elif [ $1\
    \ -le 1 ]; then\n        echo \"x$(($1-1))\"\n    elif [ $1 -gt 1000 ]; then\n\
    \        echo \"$(($1%100/10 + $1%10))$(($1%10)*10)x\"\n    else\n        echo\
    \ \"$(($1%100/10 + $1%10))$(($1%10)*10)\"\n    fi", "    local i=\"$1\"\n    local\
    \ x=\"$2\"\n    local a\n\n    # Romans have \"I\" as first roman, and \"V\" as\
    \ the next-last.\n    if [ \"$i\" -eq 1 ] ; then\n        echo \"I\"\n    elif\
    \ [ \"$i\" -eq 3 ] ; then\n        echo \"XII\"\n    elif [ \"$i\" -ge 4 ] ; then\n\
    \        local b=\"$(( i - 4 ))\"\n        local c=\"$(( i - 4 ))\"\n        local\
    \ d\n        local e\n        local f\n        local g\n        local h\n    \
    \    local i\n\n        # Special case: 4 -> IV\n        if [ \"$i\" -eq 4 ] ;\
    \ then\n            echo \"IV\"\n            return\n        fi\n\n        while\
    \ :\n        do\n            echo \"$c\"\n            a=\"$x\"\n            IFS=\"\
    $(printf \"%d\" \"$b\")\"\n            x=\"$a\"\n            IFS=\"$(printf \"\
    %d\" \"$a\")\"\n            echo \"$x\"\n            b=\"$c\"\n            IFS=\"\
    $(printf \"%d\" \"$b\")\"\n            c=\"$x\"\n            IFS=\"$(printf \"\
    %d\" \"$a\")\"\n            d=\"$x\"\n            IFS=\"$(printf \"%d\" \"$b\"\
    )\"\n            e=\"$x\"\n            IFS=\"$(printf \"%d\" \"$a\")\"\n     \
    \       f=\"$x\"\n            IFS=\"$(printf \"%d\" \"$b\")\"\n            g=\"\
    $x\"\n            IFS=\"$(printf \"%d\" \"$a\")\"\n            h=\"$x\"\n    \
    \        IFS=\"$(printf \"%d\" \"$b\")\"\n            i=\"$x\"\n            IFS=\"\
    $(printf \"%d\" \"$a\")\"\n        done\n\n        echo \"${h}${g}${f}${e}${d}${c}${b}${a}\"\
    \n    else\n        echo \"$i\"\n    fi", "  local num=$1\n\n  # Romans (see http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)\n\
    \  # are given in the order of thousands, hundreds, tens, ones, to their left\n\
    \  # (1000 = one thousand, 100 = one hundred and so on).\n  local romans=( \"\"\
    \ \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"vi\" \"vii\" \"viii\" \"ix\" \"x\" \"xi\"\
    \ \"xii\" \"xiii\" \"xiv\" \"xv\" \"xvi\" \"xvii\" \"xviii\" \"xvx\" \"xix\" \"\
    xx\" \"xxi\" \"xxii\" \"xxiii\" \"xxiv\" \"xxv\" \"xxvi\" \"xxvii\" \"xxviii\"\
    \ \"xxix\" \"xxx\" \"xxxx\" )\n\n  local n=0\n  while [ $num -gt 0 ]; do\n   \
    \ (( num -= romans[$n+1] ))\n    (( n++; n%=4 ))\n  done\n  echo \"${romans[@]:0:$n}\"",
  "  if [ \"$1\" -lt 1 ] || [ \"$1\" -gt 1000 ]; then\n    echo \"error: invalid number\
    \ - $1\"\n    echo \"valid range is between 1 and 1000\"\n  fi\n  local num=\"\
    $1\"\n  local roman_num=\"\"\n  local tmp_num=\"$1\"\n  local tmp_roman_num=\"\
    \"\n\n  while [ \"$num\" -gt 0 ]; do\n    (( num-- ))\n    (( tmp_num-- ))\n \
    \   (( tmp_roman_num++ ))\n  done\n\n  while [ \"$tmp_num\" -gt 0 ]; do\n    roman_num=\"\
    ${roman_num}${tmp_roman_num}\"\n    (( tmp_num-- ))\n    (( tmp_roman_num++ ))\n\
    \  done\n\n  echo \"${roman_num}\"", "\tlocal num=$1\n\tlocal roman=\"\"\n\n\t\
    while [ \"$num\" -gt 0 ]; do\n\t\tlocal last_digit=$(echo $num | awk '{print $NF}')\n\
    \t\tlocal next_digit=$((10#$last_digit))\n\t\troman=\"${roman}${next_digit}\"\n\
    \t\tnum=$(( $num - $next_digit ))\n\tdone\n\n\techo \"${roman%?}\"", "  if ! [[\
    \ $1 =~ ^[0-9]+$ ]]; then\n    echo \"Error: invalid argument [$1]\" 1>&2\n  \
    \  return 1\n  fi\n  if ! [[ $1 -le 1000 ]]; then\n    echo \"Error: num is greater\
    \ than 1000\" 1>&2\n    return 1\n  fi\n  echo \"$(($1%1000)/1000)\" | bc -l",
  "  local num=${1:?Variable 'num' is not set}\n  local roman\n  local mini_roman\n\
    \  if [ $num -gt 1000 -o $num -le 1 ]; then\n    echo \"ERROR: 'num' must be between\
    \ 1 and 999\"\n    return 1\n  fi\n  local i\n  local roman_array=()\n  local\
    \ mini_roman_array=()\n  local i\n  roman_array=( \"C\" \"D\" \"C\" \"D\" \"C\"\
    \ \"D\" \"C\" \"D\" \"C\" \"D\" \"C\" \"D\" \"C\" \"D\" \"C\" \"D\" )\n  mini_roman_array=(\
    \ \"C\" \"c\" \"D\" \"d\" \"C\" \"c\" \"D\" \"c\" \"C\" \"c\" \"D\" \"c\" \"C\"\
    \ \"c\" \"D\" \"d\" )\n  local n\n  for (( i=1; i <= $num; i++ )); do\n    roman=${roman_array[$((i-1))]}\n\
    \    mini_roman=${mini_roman_array[$((i-1))]}\n    n=$((i-1))\n    while [ \"\
    $n\" -le \"$((num-i))\" ]; do\n      roman=${roman}${roman_array[$((n))]}\n  \
    \    mini_roman=${mini_roman}${mini_roman_array[$((n))]}\n      ((n++))\n    done\n\
    \    roman=${roman}${roman_array[$((i-1))]}\n    mini_roman=${mini_roman}${mini_roman_array[$((i-1))]}\n\
    \    mini_roman=${mini_roman}${roman_array[$((i-1))]}\n    mini_roman=${mini_roman}${mini_roman_array[$((i-1))]}\n\
    \    roman_array[$((i-1))]=$roman\n    mini_roman_array[$((i-1))]=$mini_roman\n\
    \  done\n  mini_roman=${mini_roman}${mini_roman_array[$((num-1))]}\n  mini_roman=${mini_roman}${roman_array[$((num-1))]}\n\
    \  mini_roman=${mini_roman}${mini_roman_array[$((num-1))]}\n  mini_roman=${mini_roman}${roman_array[$((num-1))]}\n\
    \  mini_roman=${mini_roman}${mini_roman_array[$((num-1))]}\n  mini_", "  if [[\
    \ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"Error: argument must be an integer.\"\
    \ > /dev/stderr\n    exit 1\n  fi\n  local num=$1\n\n  if [[ ! -z \"$2\" ]]; then\n\
    \    case \"$2\" in\n      roman | *roman)\n        echo \"$num\" | rev | cut\
    \ -d \" \" -f 1 | rev\n        ;;\n      *)\n        echo \"Error: unknown conversion\
    \ style.\" > /dev/stderr\n        exit 1\n        ;;\n    esac\n  else\n    local\
    \ roman=\"\"\n    case \"$num\" in\n      0)\n        roman=\"x\"\n        ;;\n\
    \      1)\n        roman=\"i\"\n        ;;\n      5)\n        roman=\"ivi\"\n\
    \        ;;\n      10)\n        roman=\"vi\"\n        ;;\n      50)\n        roman=\"\
    viii\"\n        ;;\n      100)\n        roman=\"iviii\"\n        ;;\n      1000)\n\
    \        roman=\"viiix\"\n        ;;\n    esac\n    echo \"$roman\"\n  fi", " \
    \ local -i num=\"$1\"\n  local roman=\"\"\n  while [ \"$num\" -gt 0 ]; do\n  \
    \  local remainder\n    remainder=\"$(( num % 10 ))\"\n    roman += \"${roman-}\"\
    \ \"$(( num / 10 ))\"\n    num=${num%10}\n  done\n  echo \"$roman\" | tr '[:upper:]'\
    \ '[:lower:]'", "  local num=$1\n  local roman=\n  local i=\n  while [[ $num -gt\
    \ 0 ]]; do\n    local remainder=$((num % 1000))\n    local tmp=${roman:0:$i}\n\
    \    roman=$((tmp + remainder + 1))\n    ((num=num/1000))\n    ((i++))\n  done\n\
    \  echo \"$roman\"", "  local num=$1\n  local numerals=(\n    \"M\"\n    \"CM\"\
    \n    \"D\"\n    \"CD\"\n    \"C\"\n    \"XC\"\n    \"L\"\n    \"XL\"\n    \"\
    X\"\n    \"IX\"\n    \"V\"\n    \"IV\"\n    \"I\"\n  )\n  local roman=\"0\"\n\n\
    \  while (( num > 0 )) ; do\n    roman =$(echo $numerals | awk -v num=$num -F\
    \ ',' '{print $1*num+$2}')\n    num=$(expr $num - 1)\n  done\n\n  echo $roman",
  "  # $1 is an integer\n  local num=$1\n  if [[ $num -lt 1 || $num -lt 1000 ]]; then\n\
    \    echo \"Usage: '$(basename $0)' <number>\" >&2\n    exit 1\n  fi\n  local\
    \ roman=\"\"\n  for ((i=$num;i>0;i--)); do\n    local remainder=$((i % 10))\n\
    \    roman $remainder \"${roman:+}$remainder\"\n  done\n  echo \"${roman^^}\"",
  "  [[ $1 =~ ^[+-]?[0-9]+$ ]] || return 0\n  local tmp=()\n  local i=$1\n  while\
    \ (( i++ < $1 )); do\n    tmp+=$(printf '%c' $(( $(printf '%b' $(( i )) )) | awk\
    \ '{print tolower($0)}'  ))\n  done\n  printf '%s\\n' \"${tmp[@]}\"", "    local\
    \ num=$1\n    local numeral=\"\"\n    local i=1 j=1 roman_numeral=\n    while\
    \ [ $num -gt 0 ]\n    do\n        numeral=${roman_numeral}\"${num%${i}}${numeral}\"\
    \n        (( i+=1 ))\n        (( num-=${i} ))\n        (( j+=1 ))\n        roman_numeral=\"\
    ${roman_numeral},${i}\"\n    done\n    numeral=${numeral:1}\n    return $numeral",
  "  echo $(echo \"$1\" | sed 's/\\([0-9]\\)\\(.*\\)/\\1\\3/g')", "    local num=$1\
    \ i\n    local roman=\"\"\n\n    # Fill roman digits from right to left\n    while\
    \ (( num > 0 )) ; do\n        (( num -= 10 ))\n        roman += 1\n    done\n\n\
    \    # Fill roman digits from left to right\n    while (( num > 0 )) ; do\n  \
    \      (( roman += $roman_map[$(( $roman - 1 ))]\n        num -= $roman_map[$((\
    \ $roman - 1 ))] ))\n    done\n\n    # Convert to lowercase\n    roman=$(echo\
    \ \"$roman\" | tr [:upper:] [:lower:])\n    echo $roman", "    local num=$1\n\
    \    local roman_num\n    local roman_num_char\n\n    roman_num=$(mini_roman_num_to_ints\
    \ \"$num\")\n\n    roman_num_char=$(echo \"$roman_num\" | awk '{printf \"%s\"\
    , $2}')\n\n    echo \"$roman_num_char\"", "  local NUM=$1\n  echo \"$NUM\" | while\
    \ read -r N; do\n    [[ $N == [0-9] ]] && echo \"$N\" || break\n    echo \"$N\"\
    \ | while read -r M; do\n      [[ $M == [0-9] ]] && echo \"$M\" || break\n   \
    \   echo \"$M\" | while read -r I; do\n        [[ $I == [0-9] ]] && echo \"$I\"\
    \ || break\n        echo \"$I\"\n      done\n    done\n  done", "  if (( $# !=\
    \ 1 )); then\n    echo >&2 \"Usage: $0 int\"\n    exit 1\n  fi\n\n  local num=\"\
    $1\"\n\n  local roman_numeral=\"\"\n\n  case $num in\n    [0-9]* | [1-9][0-9]*\
    \ | [1-9][0-9][0-9]* | [1-9][0-9][0-9][0-9]* | \\\n      [1-9][0-9][0-9][0-9][0-9]*\
    \ | [1-9][0-9][0-9][0-9][0-9][0-9]* | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]* | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]* | \\\n\
    \      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]* | \\\n  \
    \    [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]* | \\\n\
    \      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*\
    \ | \\\n      [1-9][0-9][0-9][0-9", "  if [[ $1 =~ ^[0-9]+$ ]]; then\n    local\
    \ num=${1#0}\n    if [[ $num -lt 1 || $num -gt 1000 ]]; then\n      echo \"invalid\
    \ roman numeral $1\"\n      exit 1\n    fi\n    local roman\n    local nums\n\
    \    # create array of roman numerals from 1 to num\n    nums=$(seq 1 $num)\n\
    \    # for each element in this array, create corresponding mini roman\n    #\
    \ and add it to our final list\n    for x in $nums; do\n      roman=$((x | roman_numeral_to_decimal))\n\
    \      if [[ $roman =~ ^[0-9]+$ ]]; then\n        mini_roman+=$(mini_roman_numeral_to_string\
    \ $roman)\n      fi\n    done\n    echo \"${mini_roman:0:${#mini_roman}-1}\"\n\
    \  fi", "    local num=${1%?}\n    local roman=\"$(echo \"$num\" | \\\n      \
    \         sed -e 's/^\\([0-9]\\)$/\\1\\u/'\\\n               -e 's/^\\([0-9][0-9]\\\
    )$/\\1\\u\\2/'\\\n               -e 's/^\\([0-9][0-9][0-9]\\)$/\\1\\u\\2\\3/'\\\
    \n               -e 's/^\\([0-9][0-9][0-9][0-9]\\)$/\\1\\u\\2\\3\\4/'\\\n    \
    \           -e 's/^\\([0-9][0-9][0-9][0-9][0-9]\\)$/\\1\\u\\2\\3\\4\\5/'\\\n \
    \              -e 's/^\\([0-9][0-9][0-9][0-9][0-9][0-9]\\)$/\\1\\u\\2\\3\\4\\\
    5\\6/')\"\n    echo \"$roman\" | tr '[:upper:]' '[:lower:]'", "  local num=$1\n\
    \  local roman \n  local remainder\n  local temp\n  local l\n  local i\n\n  case\
    \ \"$num\" in\n    1)\n      roman=\"M\"\n      ;;\n    4)\n      roman=\"C\"\n\
    \      ;;\n    9)\n      roman=\"D\"\n      ;;\n    13)\n      roman=\"E\"\n \
    \     ;;\n    16)\n      roman=\"X\"\n      ;;\n    21)\n      roman=\"L\"\n \
    \     ;;\n    26)\n      roman=\"V\"\n      ;;\n    31)\n      roman=\"I\"\n \
    \     ;;\n    100)\n      roman=\"X\"\n      ;;\n    105)\n      roman=\"XC\"\n\
    \      ;;\n    112)\n      roman=\"XL\"\n      ;;\n    115)\n      roman=\"XV\"\
    \n      ;;\n    117)\n      roman=\"XIX\"\n      ;;\n    120)\n      roman=\"\
    XLI\"\n      ;;\n    123)\n      roman=\"XLV\"\n      ;;\n    126)\n      roman=\"\
    XLIX\"\n      ;;\n    130)\n      roman=\"XLVI\"\n      ;;\n    134)\n      roman=\"\
    XLVII\"\n      ;;\n    138)\n      roman=\"XLVIII\"\n      ;;\n    142)\n    \
    \  roman=\"XLVIII\"\n      ;;\n    146)\n      roman=\"XLVIIII\"\n      ;;\n \
    \   150)\n      roman=\"XLVIIIII\"\n      ;;\n    154)\n      roman=\"XLVIIIII\"\
    \n      ;;\n    158)\n      roman=\"XLVIIIIII\"\n      ;;\n    162)\n      roman=\"\
    XLVIIIIIII\"\n      ;;\n    166)\n      roman=\"XLVIIIIIIII\"\n      ;;\n    170)\n\
    \      roman=\"XLVIIIIIIIII\"\n      ;;\n    174)\n      roman=\"XLVIIIIIIIIII\"\
    \n      ;;\n    178)\n      roman=\"XLVIIIIIIIIIII\"\n      ;;\n    182)\n   \
    \   roman=\"XLVIIIIIIIIIIII\"", "  local num=${1:-$PRGNAME}\n  local output=''\n\
    \  case \"$num\" in\n    1)\n      output=\"x\";;\n    4)\n      output=\"c\"\
    ;;\n    6)\n      output=\"l\";;\n    8)\n      output=\"i\";;\n    10)\n    \
    \  output=\"xix\";;\n    20)\n      output=\"xc\";;\n    30)\n      output=\"\
    xcl\";;\n    50)\n      output=\"ixl\";;\n    60)\n      output=\"xl\";;\n   \
    \ 70)\n      output=\"xil\";;\n    80)\n      output=\"xixl\";;\n    90)\n   \
    \   output=\"xixc\";;\n    100)\n      output=\"xic\";;\n    1000)\n      output=\"\
    xicx\";;\n    *)\n      output=\"${num}\"\n  esac\n  echo \"$output\"", "    local\
    \ n=$1\n    local miniroman=\"$2\"\n    local roman=\"\"\n\n    # Handle special\
    \ cases:\n    if [ \"$n\" -eq 1 ]; then miniroman=\"$miniroman$n\"; return; fi\n\
    \    if [ \"$n\" -eq 3 ]; then miniroman=\"$miniroman$n$n\"; return; fi\n    if\
    \ [ \"$n\" -eq 4 ]; then miniroman=\"$miniroman$n$n$n\"; return; fi\n    if [\
    \ \"$n\" -eq 5 ]; then miniroman=\"$miniroman$n$n$n$n\"; return; fi\n    if [\
    \ \"$n\" -eq 6 ]; then miniroman=\"$miniroman$n$n$n$n$n\"; return; fi\n    if\
    \ [ \"$n\" -eq 9 ]; then miniroman=\"$miniroman$n$n$n$n$n$n\"; return; fi\n  \
    \  if [ \"$n\" -eq 10 ]; then miniroman=\"$miniroman$n$n$n$n$n$n$n\"; return;\
    \ fi\n    if [ \"$n\" -eq 35 ]; then miniroman=\"$miniroman$n$n$n$n$n$n$n$n\"\
    ; return; fi\n\n    # Initialize roman to a blank string:\n    roman=\"\"\n\n\
    \    # Convert each digit to its corresponding roman numeral:\n    for ((i=1;\
    \ i<=$(( $n - 1 )); i++)); do\n        local digit=$(( $n % 10 ))\n        roman=$roman$((\
    \ $digit >= 4 ? $digit - 4 : $digit ))\n        miniroman=$miniroman$(( $digit\
    \ >= 4 ? \"IV\" : $digit ))\n        (( n /= 10 ))\n    done\n\n    # Output the\
    \ result: add roman numeral to mini roman numeral:\n    miniroman=\"$miniroman$roman\"",
  "  local roman_number=$1\n  local mini_roman=\"\"\n  local i\n  local j\n  for i\
    \ in $(seq 1 ${#roman_number}); do\n    local digit=${roman_number:$i:1}\n   \
    \ local char=$(echo $digit | tr \"-\" \"M\")\n    local roman_letter=\"${roman_letters[${char}]}\"\
    \n    mini_roman=\"${mini_roman}${roman_letter}\"\n  done\n  echo $mini_roman\
    \ | tr M- m", "  echo $1 | \\\n    awk 'BEGIN{\n      roman2int={ \\\n       \
    \ 'M'\t=> 1,\n        'CM'\t=> 2,\n        'D'\t=> 3,\n        'CD'\t=> 4,\n \
    \       'C'\t=> 5,\n        'XC'\t=> 6,\n        'L'\t=> 7,\n        'XL'\t=>\
    \ 8,\n        'X'\t=> 9,\n        'IX'\t=> 10,\n        'V'\t=> 11,\n        'IV'\t\
    => 12,\n        'I'\t=> 13\n      };\n      int2roman={ \\\n        1\t=> 'M',\n\
    \        2\t=> 'CM',\n        3\t=> 'D',\n        4\t=> 'CD',\n        5\t=> 'C',\n\
    \        6\t=> 'XC',\n        7\t=> 'L',\n        8\t=> 'XL',\n        9\t=> 'X',\n\
    \        10\t=> 'IX',\n        11\t=> 'V',\n        12\t=> 'IV',\n        13\t\
    => 'I'\n      };\n      roman=\"\";\n      int=0;\n      while(roman <= \"M\"\
    \ || roman <= \"IV\") {\n        int+=roman2int[roman];\n        roman=int2roman[int];\n\
    \      }\n      print roman;\n    }'", "    local num=$1\n    # Turn num to the\
    \ smallest integer smaller than it\n    # and to the power of 2 (powers of 2 are\
    \ powers of 10\n    # and are therefore easier to manipulate than decimal numbers)\n\
    \    num=$((num + 1))\n    num=$(echo \"$num\" | bc)\n    # Roman numerals start\
    \ with the letter I and go\n    # upwards, so we start with the largest possible\
    \ number\n    # and subtract one\n    num=$((num-1))\n    # Each subsequent digit\
    \ is the numeral representation\n    # of the number minus the last digit\n  \
    \  local num_str=$((num%10))\n    num=$(echo \"$num / 10\" | bc)\n    for (( i=0;\
    \ i<$num; i++ )); do\n        ((num_str+=$((10#$((num_str+$((10#$((num-i)%10))))))))\n\
    \    done\n    # Return the string with the roman numerals reversed\n    echo\
    \ \"${num_str}\"", "    local num=$1\n    local roman cur\n    local -i index\n\
    \    local num2\n    local -i roman_len\n    local cur2\n    local j\n\n    #\
    \ special case 1\n    if [ \"$num\" -gt 1000 ]; then \n        echo \"$num: invalid\
    \ argument\"\n        return\n    fi\n\n    # special case 2\n    if [ \"$num\"\
    \ -gt 500 ]; then\n        roman=\"0\"\n        for (( index = 0; index < $1;\
    \ index++ )); do\n            roman=\"$roman$((num % 10))\"\n            num=$((num\
    \ / 10))\n        done\n        echo \"$roman\"\n        return\n    fi\n\n  \
    \  # special case 3\n    if [ \"$num\" -lt 1 ]; then\n        echo \"$num: invalid\
    \ argument\"\n        return\n    fi\n\n    roman=\"0\"\n    for (( index = 0;\
    \ index < $1; index++ )); do\n        cur=$((num % 10))\n        num=$((num /\
    \ 10))\n        # special case 4\n        if [ \"$cur\" -gt 5 ]; then\n      \
    \      roman=\"$roman$((cur + 1))\"\n        else\n            roman=\"$roman$cur\"\
    \n        fi\n    done\n    echo $roman", "  # $2 may be an empty string ($1 is\
    \ an integer)\n  local int_num=$1; shift\n  # Check if the input is an integer\n\
    \  if [[ $int_num =~ ^-?[0-9]+$ ]]; then\n    # Convert the integer into binary\n\
    \    local int_bin=$(printf \"%b\" $int_num | sed 's/^0\\+//')\n    # Count leading\
    \ zeros to determine position of leading zeros\n    local lead_zeros=$(echo \"\
    $int_bin\" | grep -o '^0*\\?$')\n    # Convert all zeros into a 'a'\n    local\
    \ lead_zeropos=${#lead_zeros}\n    # Remove the leading zeros from binary\n  \
    \  local lead_zeropos=${lead_zeropos#0}\n    # Find the length of the binary\n\
    \    local bin_len=$(echo \"$int_bin\" | wc -w)\n    # Initialize roman numeral\
    \ to an empty string\n    local roman_num=\"\"\n    # If the length of the binary\
    \ is 1, i.e. \"000000\"\n    if [[ $bin_len == 1 ]]; then\n      # The string\
    \ to be converted is exactly one character, i.e. \"a\"\n      roman_num=\"${int_bin}\"\
    \n      # No need to convert the integer into a string, as it's already a string\n\
    \      exit 0\n    fi\n    # If the binary contains more than 1 leading zeros,\
    \ i.e. \"0000001\"\n    if [[ $lead_zeros > 0 ]]; then\n      # The length of\
    \ the binary is greater than the leading zeros, i.e. \"00000\"\n      if [[ $bin_len\
    \ > $lead_zeros ]]; then\n        # Convert the binary into its actual roman numeral,\
    \ i.e. \"mcm\"\n        local roman_num=$($ROMAN-$int_num | awk '{print $2}')\n\
    \        # Find the position of the first non-roman numeral character\n      \
    \  local first_non_roman_char=$(echo \"$roman_num\" | awk '{print index($0, \"\
    a\")}')\n        # Find the position of the second non-roman numeral character\n\
    \        local second_non_roman_char=$(echo \"$roman_num\" | awk '{print index($0,\
    \ \"i\")}')\n        # Find the position of the third non-roman numeral character\n\
    \        local third_non_roman_char=$(echo \"$roman_num\" | awk '{print index($0,\
    \ \"l\")}')\n        # Find the position of the fourth non-roman numeral character\n\
    \        local fourth_non_roman_char=$(echo \"$roman_num\" | awk '{print index($0,\
    \ \"c\")}')\n        # Find the position of the fifth non-roman numeral character\n\
    \        local fifth_non_roman_char=$(echo \"$roman_num\" | awk '{print index",
  "  local num=$1\n  local roman=\"\"\n  local i=2\n  while [ $i -le $num ]; do\n\
    \    roman+=\"$(roman_numeral_to_mini_roman $i)\"\n    i=$((i+1))\n  done\n  echo\
    \ ${roman,,}", "    local num=$1\n    if [ $num -gt 1000 ] || [ $num -le 1 ];\
    \ then\n        echo \"[ERROR] Invalid number: $num\" >&2\n        return 1\n\
    \    fi\n    local roman=\n    local i\n    local count\n    for (( i = 0; i <\
    \ 3; i++ )); do\n        count=0\n        for (( j = 3; j < i; j++ )); do\n  \
    \          (( count += roman[$j] ))\n        done\n        if [ $num -eq $count\
    \ ]; then\n            roman=`echo $roman | tr -s '[:alpha:]' '[:lower:]'`\n \
    \       fi\n    done\n    echo $roman", "  local number=$1\n  local alphabet=\"\
    IX CLV\"\n  if [[ $number -gt 999 ]]\n  then\n    # Note: $alphabet[0] is \"I\"\
    \ and $alphabet[1] is \"X\"\n    local numbers_in_alphabet=($((number%10))$((number%100/10))$((number%1000/100))\
    \ )\n    # $numbers_in_alphabet[0] is \"I\"\n    # $numbers_in_alphabet[1] is\
    \ \"V\"\n    # $numbers_in_alphabet[2] is \"X\"\n    local roman_numbers=(${alphabet[$((numbers_in_alphabet[1]))]}${numbers_in_alphabet[0]})\n\
    \    # $roman_numbers[0] is \"C\"\n    # $roman_numbers[1] is \"L\"\n    # $roman_numbers[2]\
    \ is \"V\"\n    local roman_numbers_string=$roman_numbers[*]\n    # $roman_numbers_string\
    \ is \"CLV\"\n    local mini_roman_number=$(echo $roman_numbers_string | sed -e\
    \ 's/./\\U&/g')\n    # $mini_roman_number is \"xix\"\n    echo \"$mini_roman_number\"\
    \n  else\n    echo \"$number\"\n  fi", "  local numeral\n  numeral=$1\n  case\
    \ \"$numeral\" in\n    [0-9]*)\n      # No change required\n      ;;\n    [1-9]*)\
    \ # Convert to Roman\n      # Roman\n      numeral=$(echo \"$numeral\" | sed -r\
    \ 's/([0-9])([0-9])/\\1\\2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([0-9])([a-z])/\\\
    1\\L\\2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([a-z])([0-9])/\\1\\\
    L\\2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([0-9])([A-Z])/\\1\\L\\\
    2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([A-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([a-zA-Z])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([a-zA-Z])/\\1\\L\\2/g')\n\
    \      # Lower\n      numeral=$(echo \"$numeral\" | sed -r 's/([0-9])([a-z])/\\\
    1\\L\\2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([a-z])([0-9])/\\1\\\
    L\\2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([0-9])([A-Z])/\\1\\L\\\
    2/g')\n      numeral=$(echo \"$numeral\" | sed -r 's/([A-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([a-zA-Z])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([0-9])/\\1\\L\\2/g')\n\
    \      numeral=$(echo \"$numeral\" | sed -r 's/([a-zA-Z])([a-zA-Z])/\\1\\L\\2/g')\n\
    \      ;;\n    *)\n      printf \"Input must be an integer (between 1 and 999).\
    \ Exiting.\"\n", "  if [ \"$1\" = \"--help\" ]; then\n    echo \"Usage: $0 num\"\
    \n    exit 1\n  fi\n  num=$(echo \"$1\" | awk '{print tolower($0)}')\n  if [ \"\
    $num\" = \"--help\" ]; then\n    echo \"Usage: $0 num\"\n    exit 1\n  fi\n  local\
    \ i roman\n  local roman alphabet\n  alphabet=\"IUP\"\n  for ((i = 0; i < 3; i++));\
    \ do\n    roman=$( printf \"%${i}s\" | tr \" \" \"\\$$i\" )\n    roman=\"${roman//[I]/i}\"\
    \n    roman=\"${roman//[U]/i}\"\n    roman=\"${roman//[P]/i}\"\n    roman=\"${roman//[X]/i}\"\
    \n    roman=\"${roman//[D]/i}\"\n    roman=\"${roman//[M]/i}\"\n    roman=\"${roman//[C]/i}\"\
    \n    roman=\"${roman//[L]/i}\"\n    roman=\"${roman//[V]/i}\"\n    roman=\"${roman//[X]/i}\"\
    \n    roman=\"${roman//[I]/i}\"\n    roman=\"${roman//[V]/i}\"\n    roman=\"${roman//[X]/i}\"\
    \n    roman=\"${roman//[L]/i}\"\n    roman=\"${roman//[C]/i}\"\n    roman=\"${roman//[M]/i}\"\
    \n    roman=\"${roman//[D]/i}\"\n    roman=\"${roman//[P]/i}\"\n    roman=\"${roman//[U]/i}\"\
    \n    roman=\"${roman//[M]/i}\"\n    roman=\"${roman//[C]/i}\"\n    roman=\"${roman//[X]/i}\"\
    \n    roman=\"${roman//[L]/i}\"\n    roman=\"${roman//[V]/i}\"\n    roman=\"${roman//[U]/i}\"\
    \n    roman=\"${roman//[S]/i}\"\n    roman=\"${roman//[X]/i}\"\n    roman=\"${roman//[C]/i}\"\
    \n    roman=\"${roman//[D]/i}\"\n    roman=\"${roman//[M]/i}\"\n    roman=\"${roman//[P]/i}\"\
    \n    ro", "\tlocal num=$1\n\tlocal num_str=$(sed -n -e \"s/^[[:space:]]\\?\\\
    +//p\" <<< $num)\n\tlocal roman # string used to store a roman numeral\n\n\t#\
    \ first handle all the special cases\n\tif [[ \"$num_str\" == \"0\"* ]]; then\n\
    \t\techo $num_str\n\telse\n\t\tnum_str=$(echo $num_str | sed -e \"s/^[[:alpha:]]\\\
    {1\\}\\([[:digit:]]\\+\\)/\\1x\\1/\")\n\t\tif [[ \"$num_str\" == \"1\"* ]]; then\n\
    \t\t\techo $num_str\n\t\telse\n\t\t\tif [[ \"$num_str\" == \"2\"* ]]; then\n\t\
    \t\t\techo $num_str\n\t\t\telif [[ \"$num_str\" == \"3\"* ]]; then\n\t\t\t\techo\
    \ $num_str\n\t\t\telif [[ \"$num_str\" == \"4\"* ]]; then\n\t\t\t\techo $num_str\n\
    \t\t\telif [[ \"$num_str\" == \"5\"* ]]; then\n\t\t\t\techo $num_str\n\t\t\telif\
    \ [[ \"$num_str\" == \"6\"* ]]; then\n\t\t\t\techo $num_str\n\t\t\telif [[ \"\
    $num_str\" == \"7\"* ]]; then\n\t\t\t\techo $num_str\n\t\t\telif [[ \"$num_str\"\
    \ == \"8\"* ]]; then\n\t\t\t\techo $num_str\n\t\t\telif [[ \"$num_str\" == \"\
    9\"* ]]; then\n\t\t\t\techo $num_str\n\t\t\telse\n\t\t\t\techo \"ERROR\"\n\t\t\
    \tfi\n\t\tfi\n\tfi", "  if [ $1 -eq 1 ]\n    then\n      echo \"xix\"\n    elif\
    \ [ $1 -eq 2 ]\n      then\n      echo \"vi\"\n    elif [ $1 -eq 3 ]\n      then\n\
    \      echo \"vii\"\n    elif [ $1 -eq 4 ]\n      then\n      echo \"ix\"\n  \
    \  elif [ $1 -eq 5 ]\n      then\n      echo \"ivi\"\n    elif [ $1 -eq 6 ]\n\
    \      then\n      echo \"vix\"\n    elif [ $1 -eq 7 ]\n      then\n      echo\
    \ \"ix\"\n    elif [ $1 -eq 8 ]\n      then\n      echo \"lvi\"\n    elif [ $1\
    \ -eq 9 ]\n      then\n      echo \"xii\"\n    elif [ $1 -eq 10 ]\n      then\n\
    \      echo \"cii\"\n    elif [ $1 -eq 11 ]\n      then\n      echo \"ii\"\n \
    \   elif [ $1 -eq 12 ]\n      then\n      echo \"iii\"\n    elif [ $1 -eq 13 ]\n\
    \      then\n      echo \"ciii\"\n    elif [ $1 -eq 14 ]\n      then\n      echo\
    \ \"xiii\"\n    elif [ $1 -eq 15 ]\n      then\n      echo \"viii\"\n    elif\
    \ [ $1 -eq 16 ]\n      then\n      echo \"iii\"\n    elif [ $1 -eq 17 ]\n    \
    \  then\n      echo \"lxii\"\n    elif [ $1 -eq 18 ]\n      then\n      echo \"\
    lvii\"\n    elif [ $1 -eq 19 ]\n      then\n      echo \"ixii\"\n    elif [ $1\
    \ -eq 20 ]\n      then\n      echo \"iii\"\n    elif [ $1 -eq 21 ]\n      then\n\
    \      echo \"viii\"\n    elif [ $1 -eq 22 ]\n      then\n      echo \"lxiii\"\
    \n    elif [ $1 -eq 23 ]\n      then\n      echo \"lviii\"\n    elif [ $1 -eq\
    \ 24 ]\n      then\n      echo \"ixiii\"\n    elif [ $1 -eq 25 ]\n      then\n\
    \      echo \"iv\"\n    elif [ $1 -eq 26 ]\n      then\n      echo \"vi\"\n  \
    \  elif [ $1 -eq 27 ]\n      then\n      echo \"lvi\"\n    elif [ $1 -eq 28 ]\n\
    \      then\n      echo \"vii\"\n    elif [ $1 -eq 29 ", "\t# Write your code\
    \ here:\n\tlocal num=${1}\n\tlocal mini_roman=\"\"\n\tlocal mini_roman_length=${#mini_roman}\n\
    \tlocal roman_list=\"MCMXCV\"\n\tlocal roman_length=${#roman_list}\n\tlocal roman_power=${roman_length}\n\
    \tlocal roman_power2=0\n\tlocal roman_power3=0\n\tlocal roman_power4=0\n\tlocal\
    \ roman_power5=0\n\tlocal roman_power6=0\n\tlocal roman_power7=0\n\tlocal roman_power8=0\n\
    \tlocal roman_power9=0\n\tlocal roman_power10=0\n\tlocal roman_power11=0\n\tlocal\
    \ roman_power12=0\n\tlocal roman_power13=0\n\tlocal roman_power14=0\n\tlocal roman_power15=0\n\
    \tlocal roman_power16=0\n\tlocal roman_power17=0\n\tlocal roman_power18=0\n\t\
    local roman_power19=0\n\tlocal roman_power20=0\n\tlocal roman_power21=0\n\tlocal\
    \ roman_power22=0\n\tlocal roman_power23=0\n\tlocal roman_power24=0\n\tlocal roman_power25=0\n\
    \tlocal roman_power26=0\n\tlocal roman_power27=0\n\tlocal roman_power28=0\n\t\
    local roman_power29=0\n\tlocal roman_power30=0\n\tlocal roman_power31=0\n\tlocal\
    \ roman_power32=0\n\tlocal roman_power33=0\n\tlocal roman_power34=0\n\tlocal roman_power35=0\n\
    \tlocal roman_power36=0\n\tlocal roman_power37=0\n\tlocal roman_power38=0\n\t\
    local roman_power39=0\n\tlocal roman_power40=0\n\tlocal roman_power41=0\n\tlocal\
    \ roman_power42=0\n\tlocal roman_power43=0\n\tlocal roman_power44=0\n\tlocal roman_power45=0\n\
    \tlocal roman_power46=0\n\tlocal roman_power47=0\n\tlocal roman_power48=0\n\t\
    local roman_power49=0\n\tlocal roman_power50=0\n\tlocal roman_power51=0\n\tlocal\
    \ roman_power52=0\n\tlocal roman_power53=0\n\tlocal roman_power54=0\n\tlocal roman_power55=0\n\
    \tlocal roman_power56=0\n\tlocal ro", "    local num_str=\"$1\"\n    local num=\"\
    ${num_str}\"\n    local len=\"${#num_str}\"\n    local num_array=()\n\n    # First\
    \ split it into chunks of three characters each\n    while [ $len -gt 0 ]\n  \
    \  do\n        ((len -= 3))\n        num_array+=(\"${num_str:3:3}\")\n    done\n\
    \n    # Second, map it to its corresponding numbers\n    local roman_nums=()\n\
    \    for roman_num in \"${num_array[@]}\"\n    do\n        if [[ \"$roman_num\"\
    \ =~ ^[IVXLCDM]+$ ]]\n        then\n            # $roman is one of the six Roman\
    \ numerals\n            roman_nums+=(\"${roman_num}\")\n        fi\n    done\n\
    \n    # Third, convert to a string\n    local roman=\"\"\n    for roman_num in\
    \ \"${roman_nums[@]}\"\n    do\n        local roman_string=\"$roman${roman_num}\"\
    \n        roman=\"${roman:0:1}${roman_string}\"\n    done\n\n    # Finally, convert\
    \ to lowercase\n    echo \"$roman\"", "\tlocal num=$1\n\tlocal num_str=\"\"\n\t\
    local last_digit\n\tlocal count=1\n\tlocal i\n\tlocal rom\n\n\twhile [ $num ];\
    \ do\n\t\tlast_digit=${num%10}\n\t\trom=$last_digit\n\t\tnum=${num/10}\n\t\t((count++))\n\
    \t\tnum_str=\"${num_str}${rom}\"\n\tdone\n\tnum_str=\"${num_str}${last_digit}\"\
    \n\n\techo \"$num_str\"", "  num=$1\n\n  # Convert to a base 10 number then do\
    \ arithmetic\n  result=$(( (10#$num) - 1 ))\n\n  # Determine if this is an \"\
    I\" or a \"V\"\n  case \"$result\" in\n    10|11|12|13|14|15) echo \"I$result\"\
    \n      ;;\n    9|10|11|12|13|14|15) echo \"V$result\"\n      ;;\n    8|9)\n \
    \     # If the result is between 8 and 99, return \"IV\"\n      if (( $result\
    \ > 8 )) && (( $result < 100 )) {\n        echo \"IV$result\"\n      else\n  \
    \      # Otherwise, if result is between 89 and 97, return \"VI\"\n        if\
    \ (( $result > 89 )) && (( $result < 98 )) {\n          echo \"VI$result\"\n \
    \       else\n          # Otherwise, return \"IX\"\n          echo \"IX$result\"\
    \n        fi\n      fi\n      ;;\n    *)\n      # Anything else is considered\
    \ an \"X\"\n      echo \"X$result\"\n  esac", "  local num=\"$1\"\n\n  local int_to_roman\n\
    \  int_to_roman=$( \\\n  local roman_num=\"$2\"\n\n  # The roman numeral system\
    \ is cyclic. A new numeral is chosen for each\n  # number of the numerals system\
    \ that is greater or equal to the given\n  # number.\n\n  # The roman numeral\
    \ system is cyclic. A new numeral is chosen for each\n  # number of the numerals\
    \ system that is greater or equal to the given\n  # number.\n  # This array holds\
    \ the new numerals system. Index 0 is the number 0\n  # (and the new numerals\
    \ system), 1 is the number 1, and so on.\n  local numeral_system=( $(seq \"${roman_num}\"\
    ) )\n\n  # The new numerals system is cyclic. A new numeral is chosen for each\n\
    \  # number of the numerals system that is greater or equal to the given\n  #\
    \ number.\n  # The new numerals system is shifted one place to the left, so that\
    \ its\n  # first element is the number 0.\n  local numeral_system_shift=1\n\n\
    \  # The new numeral that is added to the numerals system.\n  # This variable\
    \ will hold the new numeral.\n  local numeral=\"\"\n\n  # The new numeral that\
    \ is added to the numerals system.\n  # This variable will hold the new numeral.\n\
    \  local numeral_shift=0\n\n  # The new numerals system that is returned to the\
    \ caller.\n  local numeral_system\n\n  # The new numeral that is added to the\
    \ numerals system.\n  # This variable will hold the new numeral.\n  local numeral=\"\
    \"\n\n  # The new numeral that is added to the numerals system.\n  # This variable\
    \ will hold the new numeral.\n  local numeral_shift=0\n\n  # The new numerals\
    \ system that is returned to the caller.\n  local numeral_system\n\n  while ((\
    \ numeral_shift <= numeral_num )); do\n    (( numeral_shift+=numeral_system_shift\
    \ ))\n\n    numeral=\"${numeral_system[$numeral_shift]}\"\n\n    # Replace any\
    \ roman numerals for the number in the numerals system.\n    # These are already\
    \ roman numerals.\n    numeral=\"$(echo \"$numeral\" | sed -e \"s/\\([0-9A-Z]\\\
    {3\\}\\)/\\1/g\")\"\n\n    (( numeral_shift+=numeral_system_shift ))\n    numeral_system[$numeral_shift]=\"\
    ${numeral}\"\n  done\n\n  numeral_system[0]=\"${numeral_system[0]}\"\n  numeral_",
  "\tlocal num=$1\n\tif (( num < 1 || num > 1000 )); then\n\t\techo 1>&2 \"Invalid\
    \ input\"\n\t\texit 1\n\tfi\n\n\tlocal roman=\"0\"\n\n\twhile (( num > 0 )); do\n\
    \t\tlocal remainder=$(echo $num % 10 | sed -e 's/^0/i/' -e 's/^i//')\n\t\troman\
    \ $remainder\n\t\tnum=$(( $num / 10 ))\n\tdone\n\n\techo $roman", "  declare -i\
    \ num=\"$1\"\n  # Remove leading zeros (if any)\n  echo \"$num\" | sed -E 's/^(0+).*$/\\\
    1/'\n  # Convert roman numerals (and preserve case)\n  echo \"${num%??}\"", " \
    \   local num=$1\n    local min=$((10#$num))\n    local roman_arr=(\"I\" \"II\"\
    \ \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" \"X\" \"XI\" \"XII\" \"\
    XIII\" \"XIV\" \"XV\")\n    for ((i = 0; i < ${#roman_arr[@]}; ++i)); do\n   \
    \     if ((num >= ${min} && num <= ${min+${#roman_arr[i]}}))\n        then\n \
    \           echo $roman_arr[i]\n            return 0\n        fi\n    done", " \
    \ local num=\"$1\"\n  local roman_num=\"\"\n\n  (( num > 0 )); # Make sure input\
    \ number is positive\n  (( num--)); # Subtract the input number from 1 to get\
    \ the last digit.\n  (( num > 0 )); # Make sure input number is positive\n\n \
    \ local last=0 # Flag for first time through the loop.\n  local cur=0 # Flag for\
    \ the current number being processed.\n  local digit\n  local i\n  local roman_char\n\
    \n  for i in {1..9}; do\n    digit=\"${num%$i}\"\n    roman_char=\"${roman_num:+$roman_char}$i$last\"\
    \n    (( num -= digit ))\n    last=${roman_char:0:1}\n    (( cur += i ))\n  done\n\
    \n  if (( num > 0 )) && [[ \"$roman_num\" != \"$roman_char\" ]]; then\n    roman_num=\"\
    $roman_char$last\"\n  else\n    roman_num=\"$roman_num$last\"\n  fi\n\n  echo\
    \ \"$roman_num\" | tr A-Z a-z", "    local num=$1\n    local int_to_mini_roman=\"\
    $2\"\n    local mini_roman_array=( \"III\" \"II\" \"IV\" \"V\" \"VI\" \"VII\"\
    \ \"VIII\" \"IX\" \"X\" \"XI\" \"XII\" \"XIII\" \"XIV\" \"XV\" \"XVI\" \"XVII\"\
    \ \"XVIII\" \"XIX\" \"XX\" \"XXI\" \"XXII\" \"XXIII\" \"XXIV\" \"XXV\" \"XXVI\"\
    \ \"XXVII\" \"XXVIII\" \"XXIX\" \"XXX\" \"XXXXX\" \"XXXX\" \"XXXXI\" \"XXXXII\"\
    \ \"XXXXIII\" \"XXXXIV\" \"XXXXV\" \"XXXXVI\" \"XXXXVII\" \"XXXXVIII\" \"XXXXIX\"\
    \ \"XXXXX\" \"XXXXXI\" \"XXXXXII\" \"XXXXXIII\" \"XXXXXIV\" \"XXXXXV\" \"XXXXXVI\"\
    \ \"XXXXXVII\" \"XXXXXVIII\" \"XXXXXIX\" \"XXXXXX\" \"XXXXXXI\" \"XXXXXXII\" \"\
    XXXXXXIII\" \"XXXXXXIV\" \"XXXXXXV\" \"XXXXXXVI\" \"XXXXXXVII\" \"XXXXXXVIII\"\
    \ \"XXXXXXIX\" \"XXXXXVIII\" \"XXXXXIX\" \"XXXXI\" \"XXXXII\" \"XXXXIII\" \"XXXXIV\"\
    \ \"XXXXV\" \"XXXXVI\" \"XXXXVII\" \"XXXXVIII\" \"XXXXIX\" \"XXIX\" \"XXI\" \"\
    XXII\" \"XXIII\" \"XXIV\" \"XXV\" \"XXVI\" \"XXVII\" \"XXVIII\" \"XXIX\" \"XXX\"\
    \ \"XXXXX\" \"XXXX\" \"XXXXI\" \"XXXXII\" \"XXXXIII\" \"XXXXIV\" \"XXXXV\" \"\
    XXXXVI\" \"XXXXVII\" \"XXXXVIII\" \"XXXXIX\" \"XXIX\" \"XXI\" \"XXII\" \"XXIII\"\
    \ \"XXIV\" \"XXV\" \"XXVI\" \"XXVII\" \"XXVIII\" \"XXIX\" \"XXX\" \"XXXXX\" \"\
    XXXX\" \"XXXXI\" \"XXXXII\" \"XXXXIII\" \"XXXXIV\" \"XXXXV\" \"XXXXVI\" \"XXXXVII\"\
    \ \"XXXXVIII\" \"XXXXIX\" \"XXIX\" \"XXI\" \"XXII\" \"XXIII\" \"XXIV\" \"XXV\"\
    \ \"XXVI\" \"XXVII\" \"XXVIII\" \"XXIX\" \"XXX\" \"XXXXX\" \"XXXX\" \"XXXXI\"\
    \ \"XXXXII\" \"XXXXIII\" \"XXXXIV\" \"XXXXV\" \"XXXXVI\" \"XXXXVII\" \"XXXXVIII\"\
    \ \"XXXXIX\" \"XXIX\" \"XXI\" \"XXII", "    local num=\"$1\"\n    local roman=\"\
    \"\n    if [ \"$num\" -lt 1 ]; then\n        printf \"Usage:\\n\\trman \\\"num\\\
    \"\\n\" 1>&2\n        return 1\n    elif [ \"$num\" -lt 1000 ]; then\n       \
    \ printf \"Usage:\\n\\trman \\\"num\\\"\\n\" 1>&2\n        return 1\n    fi\n\
    \    while [ $num -gt 0 ]; do\n        ((num%=10))\n        roman+=$((($num%1)+0x1))\n\
    \    done\n    roman+=$((10#$num))\n    roman=\"${roman//-}\"\n    roman=\"${roman//}`\"\
    \n    roman=\"${roman//}`\"\n    echo \"${roman,,}\"\n    return 0", "    int_num=$1\n\
    \n    # Convert the integer to a string in reverse order\n    int_reversed=$(echo\
    \ \"$int_num\" | rev | cut -d \" \" -f1 | rev)\n\n    # Find the position of the\
    \ first consonant and count them up\n    int_count=0\n    for char in $(echo \"\
    $int_reversed\"); do\n        int_count=$((int_count+1))\n        if [[ \"$char\"\
    \ = \"C\" ]]; then\n            break\n        fi\n    done\n\n    # Create the\
    \ final roman numeral string\n    int_final_roman=\"\"\n    int_length=$(echo\
    \ \"$int_count\" | bc)\n    for (( i=1; i<$int_length; i++ )); do\n        int_final_roman+=\"\
    $(echo \"$int_reversed\" | head -$i | tail -1 | cut -d \" \" -f1)\"\n    done\n\
    \n    # Convert the final roman numeral string to lowercase and return\n    int_final_roman=$(echo\
    \ \"$int_final_roman\" | tr '[:upper:]' '[:lower:]')\n    echo \"$int_final_roman\"",
  "  local num=\"$1\"\n  local roman=\n  local i=0\n  while (( i <= 3 )); do\n   \
    \ local mult=1\n    (( i % 2 )) && mult=3\n    roman=\"$(printf \"%c%c%s%c\" \"\
    $roman \" \"$(\n    case \"$num\" in\n      0)\n        echo \"\"\n        ;;\n\
    \      *)\n        echo -n \"$mult\"\n        ;;\n    esac\n    )\" \"$(\n   \
    \   case \"$num\" in\n        1)\n          echo \"\"\n          ;;\n        *)\n\
    \          echo -n \"m$mult\"\n          ;;\n      esac\n    )\" \"$roman \")\"\
    \n    (( i++ ))\n  done\n  echo \"${roman,,}\"", "\tlocal num_roman_str=\"$1\"\
    \n\tlocal num_str=\"${num_roman_str%%+*}\"\n\tlocal num_decimal=\"${num_roman_str##*+}\"\
    \n\tlocal roman_roman_num=\"\"\n\n\t# This algorithm is based on the following\
    \ post:\n\t# http://stackoverflow.com/questions/9290057/roman-to-integer-algorithm\n\
    \twhile [ $num_decimal -gt 0 ]\n\tdo\n\t\tnum_rom=$(echo \"$num_decimal/$M\" |bc)\n\
    \t\troman_roman_num=\"$rom${roman_roman_num}\"\n\t\tnum_decimal=$(echo \"$num_decimal-$M*$num_rom\"\
    \ |bc)\n\tdone\n\n\techo \"${roman_roman_num%?}\"", "  local num=\"$1\"\n  if\
    \ [[ $num -gt $1 || $num -le 0 ]]; then\n    echo >&2 \"Error; $num must be between\
    \ 0 and 999.\"\n    exit 1\n  fi\n  local nroman=0\n  local nstr=''\n  local ntmp=''\n\
    \  local i\n  local c\n  local u\n  local m\n  local n\n  local o\n  local p\n\
    \  local q\n  local r\n  local s\n  local t\n  local u\n\n  m=$((num % 10))\n\
    \  num=$(expr ${num} / 10)\n\n  for i in {1..$m}; do\n    u=$((num % 1000))\n\
    \    num=$(expr ${num} / 1000)\n    nroman=$((${nroman} + $u))\n    nstr=\"${nstr}${ntmp}\"\
    \n    ntmp=''\n  done\n\n  nstr=\"${nstr}${ntmp}\"\n  ntmp=''\n  o=$((num % 10))\n\
    \  num=$(expr ${num} / 10)\n\n  for i in {1..$o}; do\n    u=$((num % 100))\n \
    \   num=$(expr ${num} / 100)\n    nroman=$((${nroman} + $u))\n    nstr=\"${nstr}${ntmp}\"\
    \n    ntmp=''\n  done\n\n  nstr=\"${nstr}${ntmp}\"\n  ntmp=''\n  q=$((num % 10))\n\
    \  num=$(expr ${num} / 10)\n\n  for i in {1..$q}; do\n    u=$((num % 10))\n  \
    \  nroman=$((${nroman} + $u))\n    nstr=\"${nstr}${ntmp}\"\n    ntmp=''\n  done\n\
    \n  nstr=\"${nstr}${ntmp}\"\n  r=$((num % 10))\n  num=$(expr ${num} / 10)\n\n\
    \  for i in {1..$r}; do\n    u=$((num % 10))\n    nroman=$((${nroman} + $u))\n\
    \    nstr=\"${nstr}${ntmp}\"\n    ntmp=''\n  done\n\n  nstr=\"${nstr}${ntmp}\"\
    \n  s=$((num % 10))\n  num=$(expr ${num} / 10)\n\n  for i in {1..$s}; do\n   \
    \ u=$((num % 10))\n    nroman=$((${nroman} + $u", "  [[ $1 == \"\" ]] && echo\
    \ \"Please provide an integer greater than 0.\" && exit 1\n  [[ ! -z $1 ]] &&\
    \ [[ $1 -ge 1 ]] && [[ $1 -le 1000 ]] && shift\n  [[ ! -z $1 ]] && [[ $1 -ge 1\
    \ ]] && [[ $1 -le 1000 ]] &&\n    echo $1 | while IFS= read -r n; do\n      rom=${n:0:1}\n\
    \      echo -n \"${rom:0:1}${rom:1}\"\n    done", "  local n=$1\n  local num=\"\
    \"\n  # Initialize a variable which we'll use to keep track of what number we're\
    \ on and\n  # what letter we're on.\n  local numeral\n  local i=0\n  # Initialize\
    \ a variable which we'll use to keep track of the first number we encounter\n\
    \  # and the first letter we encounter.\n  local first_num=\"$(printf \"%d\" $n)\"\
    \n  local first_let=\"$(printf \"A\")\"\n  # Loop through each numeral and check\
    \ if it's a digit\n  # (we ignore anything else).\n  for numeral in $(printf \"\
    %d\" $n); do\n    (( i++))\n    # If this numeral is not a digit, then this is\
    \ the first time we've seen this numeral\n    # and we reset our variables.\n\
    \    [[ $numeral = *[0-9] ]] && first_num=\"$(printf \"%d\" $n)\" && first_let=\"\
    $(printf \"A\")\"\n    # If this numeral is a digit, then we check if the first\
    \ number we've seen is larger\n    # than the number we're on and if so, we set\
    \ that as our new first number.\n    [[ $numeral = *[0-9] ]] && (( i < $first_num\
    \ )) && first_num=\"$numeral\" && first_let=\"$(printf \"A\")\"\n  done\n  # Now\
    \ that we've seen all the numbers in the numeral, we can check which one was larger\n\
    \  # and concatenate it to the rest of our string.\n  if (( $i > $first_num ));\
    \ then\n    numeral=\"$first_let\"\n  else\n    numeral=$(printf \"%02d\" $((\
    \ $n - $first_num )))\n  fi\n  (( i < $n )) && numeral=\"${numeral}${numeral%%[AB]}\"\
    \ || numeral=\"${numeral}${numeral%%[BC]}\" || numeral=\"${numeral}${numeral%%[BD]}\"\
    \ || numeral=\"${numeral}${numeral%%[C]}\" || numeral=\"${numeral}${numeral%%[D]}\"\
    \ || numeral=\"${numeral}${numeral%%[E]}\" || numeral=\"${numeral}${numeral%%[F]}\"\
    \ || numeral=\"${numeral}${numeral%%[G]}\" || numeral=\"${numeral}${numeral%%[H]}\"\
    \ || numeral=\"${numeral}${numeral%%[I]}\" || numeral=\"${numeral}${numeral%%[J]}\"\
    \ || numeral=\"${numeral}${numeral%%[K]}\" || numeral=\"${numeral}${numeral%%",
  "  [[ $1 != [0-9][0-9] ]] || exit 1;\n  local num=$1;\n  local first\n  local last\n\
    \  local digit\n  local miniroman\n  first=1;\n  last=9;\n  miniroman=$1;\n  while\
    \ [[ $num ]]; do\n    digit=${num%$last}\n    last=$((last-digit))\n    miniroman=\"\
    ${miniroman}$((digit > 0 ? \"I\" : \"v\"))$((digit > 9 ? \"X\" : \"x\"))\"\n \
    \   num=$((num / $last))\n  done\n  [[ $first != $num ]] || exit 1;\n  printf\
    \ \"$miniroman\"", "\troman_number=${1}\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number:0:1}))\n\
    \troman_number=$((${roman_number}-1))\n\troman_number=$((${roman_number}+470))\n\
    \troman_number=$((${roman_number}+1))\n\troman_number=$((${roman_number", "  local\
    \ num=$1\n\n  if (( num < 1 || num > 1000 )); then\n    return 1\n  fi\n\n  #\
    \ Initialize variables\n  numeral=\"a\"\n  numeral_length=0\n  remainder=0\n\n\
    \  # Iterate over numeral characters\n  for (( char=0; char<${#numeral}; char++\
    \ )); do\n    # Get the remainder\n    remainder=$(( $num % 10 ))\n\n    # Update\
    \ numeral string\n    numeral=\"${numeral}$(( $remainder * ${roman_numeral_char_lengths[$char]}))\"\
    \n\n    # Update numeral length\n    numeral_length=$(( $numeral_length + $roman_numeral_char_lengths[$char]\
    \ ))\n\n    # Decrease the number by this remainder\n    num=$( (( $num / 10 ))\
    \ - $remainder )\n  done\n\n  # Return the new numeral string\n  echo ${numeral:0:$numeral_length}",
  "\tlocal num=\"$1\"\n\tlocal count=\"3\"\n\tlocal ret=\"\"\n\tlocal i=0\n\twhile\
    \ ((i <= num) && (i <= 1000)); do\n\t\tlocal ii=${num/#/}\n\t\tret=\"${ret}${i}${ii=}$count\"\
    \n\t\t((count = ${ii%}))\n\t\t((num = $ii / $count))\n\t\t((i = i + 1))\n\tdone\n\
    \tret=\"${ret}${i}x\"\n\techo \"${ret%${#ret}}\"", "  declare -i num=$1\n\n  local\
    \ roman_array=(\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\")\n  local mini_roman=\"\
    \"\n\n  for (( index=0; index<${#roman_array[@]}; index++ )); do\n    # If the\
    \ last character of the current roman_array has the highest value\n    # in the\
    \ current roman array, set that last character to be the first\n    # character\
    \ of the mini_roman array.\n    local last_char=${roman_array[index]}\n    if\
    \ (( index == 0 )); then\n      mini_roman=\"${roman_array[index]}\"\n    elif\
    \ [[ ${roman_array[index]} -gt ${roman_array[index-1]} ]]; then\n      last_char=${roman_array[index-1]}\n\
    \      mini_roman=\"${mini_roman}${last_char}\"\n    else\n      # If the first\
    \ character of the current roman_array is less than the\n      # last character\
    \ of the previous roman_array, append the last\n      # character of the current\
    \ roman_array to the mini_roman array.\n      if [[ ${roman_array[index]} -lt\
    \ ${roman_array[index-1]} ]]; then\n        mini_roman=\"${mini_roman}${roman_array[index]}\"\
    \n      fi\n    fi\n  done\n\n  echo ${mini_roman}", "  # Split $1 into its digits.\n\
    \  local digits=$(echo \"$1\" | tr \" \" \"0\")\n  local roman_numeral=\"\"\n\n\
    \  # Iterate through each digit in $digits.\n  for digit in $digits\n  do\n  \
    \  # Multiply each digit by its corresponding roman-numeral value.\n    local\
    \ multiplied_digit=$((($digit*$ROMAN_NUMERAL)))\n\n    # Accumulate each digit,\
    \ starting with the highest value.\n    roman_numeral+=($((multiplied_digit+$MAX_ROMAN_NUMERAL)))\n\
    \  done\n\n  # Replace spaces with an underscore.\n  echo \"${roman_numeral//[![:space:]]/_}\"",
  "    local num=$1\n    local temp=$(echo $((num%100)) | sed \"s/$temp/${roman_num_map[$((num%100))]}/\"\
    )\n    local ret=$(echo $num | sed \"s/$temp/$mini_roman_map[$((num%100))]/\"\
    )\n    echo $ret", "  if [ -z \"$1\" ]\n  then\n    echo \"Usage: $(basename $0)\
    \ integer\"\n    return 1\n  fi\n  \n  int_to_mini_roman_aux=\"$1\"\n  int_to_mini_roman_aux=$(echo\
    \ $int_to_mini_roman_aux | sed 's/^0*//' | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo\
    \ $int_to_mini_roman_aux | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux\
    \ | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed\
    \ 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^\
    \ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^ *//')\n\
    \  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo\
    \ $int_to_mini_roman_aux | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux\
    \ | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed\
    \ 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^\
    \ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^ *//')\n\
    \  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo\
    \ $int_to_mini_roman_aux | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux\
    \ | sed 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_roman_aux | sed\
    \ 's/^ *//')\n  int_to_mini_roman_aux=$(echo $int_to_mini_", "  local num=\"$1\"\
    \n  case \"$num\" in\n    1)\n      echo \"I\";;\n    4)\n      echo \"IV\";;\n\
    \    5)\n      echo \"V\";;\n    10)\n      echo \"IX\";;\n    20)\n      echo\
    \ \"X\";;\n    30)\n      echo \"XX\";;\n    100)\n      echo \"XL\";;\n    1000)\n\
    \      echo \"L\";;\n    *)\n      echo \"Error - invalid int given\"\n      exit\
    \ 1\n  esac", "  # Initialize result\n  RESULT=$1\n  # Check if result is numeric\n\
    \  [[ -z \"$RESULT\" ]] && return 1\n  # Initialize numerals and characters\n\
    \  NUMERALS=\"M D C X V I L X\"\n  CHARACTERS=\"M C D I X L V X C\"\n  MINI_ROMAN=0\n\
    \  # Iterate over numerals and characters\n  for i in $NUMERALS; do\n    # Iterate\
    \ over all characters in the numeral\n    for c in $CHARACTERS; do\n      # Check\
    \ if current char and numeral char are equal\n      [[ \"$RESULT\" == \"$i$c\"\
    \ ]] || continue\n      # Iterate over all chars in the numeral and add them to\
    \ the running sum\n      MINI_ROMAN=$((MINI_ROMAN+$i))\n    done\n  done\n  #\
    \ Return result\n  echo \"$MINI_ROMAN\"", "\techo $(printf \"%${1}sM\" $(seq 1\
    \ 1000 | LC_ALL=C sort -nu))", '    echo ${1//+([0-9])/}', "    # Validate input\n\
    \    if ! [[ $1 =~ ^[0-9]{1,3}$ ]]; then\n        echo \"error: invalid input\
    \ $1\"\n        return 1\n    fi\n\n    int_to_roman \"$1\"", "    local roman_num=\"\
    $1\"\n\n    local roman_numeral=\"\"\n    local letter=\"${roman_num:0:1}\"\n\n\
    \    local roman_numerals=(\n        \"c\"\n        \"xc\"\n        \"l\"\n  \
    \      \"xl\"\n        \"xc\"\n        \"cd\"\n        \"dc\"\n        \"i\"\n\
    \        \"ii\"\n        \"iii\"\n        \"iv\"\n        \"v\"\n        \"vi\"\
    \n        \"vii\"\n        \"viii\"\n        \"ix\"\n        \"x\"\n        \"\
    xx\"\n        \"c\"\n        \"d\"\n        \"e\"\n        \"f\"\n        \"g\"\
    \n        \"h\"\n        \"k\"\n        \"l\"\n        \"m\"\n        \"n\"\n\
    \        \"o\"\n        \"p\"\n        \"q\"\n        \"r\"\n        \"s\"\n \
    \       \"t\"\n        \"u\"\n        \"v\"\n        \"w\"\n        \"x\"\n  \
    \      \"y\"\n        \"z\"\n        \"aa\"\n        \"ab\"\n        \"ac\"\n\
    \        \"ad\"\n        \"ae\"\n        \"af\"\n        \"ag\"\n        \"ah\"\
    \n        \"ai\"\n        \"aj\"\n        \"ak\"\n        \"al\"\n        \"am\"\
    \n        \"an\"\n        \"ao\"\n        \"ap\"\n        \"aq\"\n        \"ar\"\
    \n        \"as\"\n        \"at\"\n        \"au\"\n        \"av\"\n        \"aw\"\
    \n        \"ax\"\n        \"ay\"\n        \"az\"\n        \"ba\"\n        \"bb\"\
    \n        \"bc\"\n        \"bd\"\n        \"be\"\n        \"bf\"\n        \"bg\"\
    \n        \"bh\"\n        \"bi\"\n        \"bj\"\n        \"bk\"\n        \"bl\"\
    \n        \"bm\"\n        \"bn\"\n        \"bo\"\n        \"bp\"\n        \"bq\"\
    \n        \"br\"\n        \"bs\"\n        \"bt\"\n        \"bu\"\n        \"bv\"\
    \n        \"bw\"\n        \"bx\"\n        \"by\"\n        \"bz\"\n        \"ca\"\
    \n        \"cb\"\n        \"cc\"\n        \"cd\"\n        \"ce\"\n        \"cf\"\
    \n        \"cg\"\n        \"ch\"\n        \"ci\"\n        \"cj\"\n        \"ck\"\
    \n        \"cl\"\n        \"cm\"\n        \"cn\"\n        \"co\"\n        \"cp\"\
    \n        \"cq\"\n        \"cr\"\n        \"cs\"\n        \"ct\"\n        \"cu\"\
    \n        \"cv\"\n        \"cw\"\n        \"cx\"\n        \"cy\"\n        \"cz\"\
    \n        \"da\"\n", "  # Get the integer part\n  local num=$1\n  num=${num: -1}\n\
    \  # Romanize the integer part and get its roman\n  local roman\n  roman=$(printf\
    \ \"%%${num}s\" | romanize)\n  # If it contains only \"I\" or \"V\", just return\
    \ the integer part\n  roman=${roman:0:1}\n  # If it contains only \"X\", add \"\
    XL\", else add \"L\"\n  # This also works for 1000 and more\n  if [[ \"${roman:0:1}\"\
    \ == \"X\" ]]; then\n    roman=\"${roman:0:1}XL${roman:2}\"\n  else\n    roman=\"\
    ${roman:0:1}L${roman:2}\"\n  fi\n  # Return it in lowercase\n  echo $(echo $roman\
    \ | tr '[:upper:]' '[:lower:]')", "    if [[ \"$1\" -gt 1 ]]; then\n        echo\
    \ \"ERROR: argument 1 must be <= 1000.\" >&2\n        exit 1\n    fi\n\n    #\
    \ Romans have a \"zero\" at the beginning of the numeral system. This\n    # makes\
    \ sure that it has a minus sign if it's negative.\n    local num=\"$1\"\n    if\
    \ [[ \"$num\" == *\"-\"* ]]; then\n        num=\"$( echo \"$num\" | sed \"s/-//g\"\
    \ )\" # Remove leading '-'\n    fi\n\n    local numeral_str=\"$( echo \"$num\"\
    \ | sed 's/\\(.\\)/\\1 \\1/' )\"\n    # Convert the numeral from string to integer\n\
    \    local numeral=\"$( echo \"$numeral_str\" | tr -cd 0-9 )\" # Remove all non-digits\n\
    \    if [[ \"$numeral\" != \"\" ]]; then\n        # Convert the numeral from integer\
    \ to roman\n        local numeral_to_roman=\"$( echo \"$numeral\" | roman-numerals-to-roman-numbers\
    \ )\"\n        numeral_to_roman=\"$( echo \"$numeral_to_roman\" | sed \"s/^$numeral_str//\"\
    \ )\"\n\n        # Return a concatenation of the roman numerals\n        echo\
    \ \"$numeral_to_roman\"\n    else\n        echo \"ERROR: no roman numeral for\
    \ value $num\" >&2\n        exit 1\n    fi", "  local num=$1\n  local digits=\"\
    \"\n  local roman=\"\"\n\n  while (( num > 0 )) ; do\n    (( num /= 1000 ))\n\
    \    (( digits = digits + \"M\" ))\n  done\n\n  (( num %= 1000 ))\n  (( digits\
    \ = digits + \"CM\" ))\n  while (( num > 0 )) ; do\n    (( num /= 10 ))\n    ((\
    \ digits = digits + \"D\" ))\n  done\n\n  (( num %= 10 ))\n  (( digits = digits\
    \ + \"CD\" ))\n  while (( num > 0 )) ; do\n    (( num /= 5 ))\n    (( digits =\
    \ digits + \"C\" ))\n  done\n\n  (( num %= 5 ))\n  (( digits = digits + \"XC\"\
    \ ))\n  while (( num > 0 )) ; do\n    (( num /= 4 ))\n    (( digits = digits +\
    \ \"L\" ))\n  done\n\n  (( num %= 4 ))\n  (( digits = digits + \"XL\" ))\n  while\
    \ (( num > 0 )) ; do\n    (( num /= 3 ))\n    (( digits = digits + \"X\" ))\n\
    \  done\n\n  (( num %= 3 ))\n  (( digits = digits + \"IX\" ))\n  while (( num\
    \ > 0 )) ; do\n    (( num /= 2 ))\n    (( digits = digits + \"V\" ))\n  done\n\
    \n  (( num %= 2 ))\n  (( digits = digits + \"IV\" ))\n  (( roman = roman + digits\
    \ ))\n\n  (( num %= 10 ))\n  (( digits = digits + \"V\" ))\n  (( roman = roman\
    \ + digits ))\n\n  (( num %= 10 ))\n  (( digits = digits + \"I\" ))\n  (( roman\
    \ = roman + digits ))\n\n  (( num %= 10 ))\n  (( digits = digits + \"X\" ))\n\
    \  (( roman = roman + digits ))\n\n  (( num %= 10 ))\n  (( digits = digits + \"\
    L\" ))\n  (( roman = roman + digits ))\n\n  (( num %= 10 ))\n  (( digits = digits\
    \ + \"C\" ))\n  (( roman = roman + digits ))\n\n  (( num %= 10 ))\n  (( digits\
    \ = digits + \"D\" ))\n  (( roman = rom", "  # $1 is a positive integer\n  int_to_roman\
    \ () {\n    # $1 is an integer\n    roman_number=\"\"\n    int_to_roman $1\n \
    \   while [ -z \"$roman_number\" ]; do\n      roman_number=${roman_number:0:1}\n\
    \      int_to_roman $1\n    done\n    echo \"$roman_number\"\n  }\n  int_to_roman\
    \ \"$1\"", "  # $1 is always positive\n  local num=\"$1\"\n  if (( num == 1 ));\
    \ then\n    echo \"x\"\n  elif (( num == 2 )); then\n    echo \"ix\"\n  elif ((\
    \ num == 0 )); then\n    echo \"0\"\n  elif (( num > 0 && num < 1000 )); then\n\
    \    # $num is a positive integer\n    local str=\"\"\n    for (( i=1; i <= num;\
    \ i++ )); do\n      # $i is less than 1000, so we increment $i\n      str=\"$str$i\"\
    \n    done\n    echo \"$str\"\n  else\n    echo \"Invalid input $1\"\n  fi", " \
    \ local num=$1\n  local mini_roman\n  mini_roman=\"x\"\n  if [ $num -le 1 ]; then\n\
    \    return 1\n  elif [ $num -ge 1000 ]; then\n    return $1\n  else\n    while\
    \ [ $num -gt 0 ]; do\n      if [ $num -gt 10 ]; then\n        mini_roman=\"$mini_roman\
    \ c\"\n      else\n        mini_roman=\"$mini_roman x\"\n      fi\n      (( num\
    \ -= 10 ))\n    done\n    return $mini_roman\n  fi", "\tlocal num=${1#0}\n\t#\
    \ Convert it to roman numeral\n\tlocal roman=\n\tlocal count=1\n\twhile (( ${#num}\
    \ > 0 )); do\n\t\tlocal digit=${num%10}\n\t\troman=${roman:+}$roman.$(( ${digit}\
    \ * $count ))\n\t\tnum=${num//${digit}/}\n\t\t(( count++ ))\n\tdone\n\n\t# If\
    \ there are any remaining digits, then add \"x\" to the end.\n\t(( count > 0 ))\
    \ && roman=${roman:+}$roman.$(( ${count} * 10 ))\n\n\t# If the last digit is greater\
    \ than 5, then add \"i\" to the end instead\n\t# of \"x\"\n\tif [[ ${#roman} -gt\
    \ 4 ]]; then\n\t\troman=${roman:+}$roman.$(( ${roman%?} * 10 ))\n\tfi\n\n\techo\
    \ \"$roman\"", "  if [[ \"$1\" -lt 1 || \"$1\" -gt 1000 ]]; then\n    echo \"\
    Usage: $(basename $0) <num>\"\n    return 1\n  fi\n  local NUM=$1\n\n  if [[ \"\
    $NUM\" == 0 ]]; then\n    echo \"Error: '$NUM' is an invalid roman (too high).\"\
    \n    return 1\n  fi\n  # Make sure number is in valid range\n  if [[ \"$NUM\"\
    \ -lt 1 || \"$NUM\" -gt 1000 ]]; then\n    echo \"Error: Invalid roman: $NUM\"\
    \n    return 1\n  fi\n\n  # Only allow 3 characters, starting with M\n  local\
    \ ROMAN=\"\"\n  local M=1\n  while [[ \"$NUM\" -gt $M ]]; do\n    local R=$(echo\
    \ \"$M * 1000\" | bc)\n    ROMAN=\"$(echo \"$R - $NUM*100\" | bc)${ROMAN}\"\n\
    \    M=$R\n  done\n\n  # Add leading zeroes\n  ROMAN=\"$(echo \"$ROMAN\" | sed\
    \ -e \"s/^0*//\")\"\n  echo \"$ROMAN\"", "    local num=$1\n    local roman=\"\
    \"\n    local roman_dict=\"iux\"\n    local roman_cnt=3\n    local roman_num=\"\
    \"\n    local roman_char=\"\"\n\n    if [[ \"$num\" < 1 ]]; then\n        return\
    \ \"Error $0: parameter must be positive\"\n    elif [[ \"$num\" -ge 1000 ]];\
    \ then\n        return \"Error $0: parameter must be <= 1000\"\n    elif [[ \"\
    $num\" -le 1000000 ]]; then\n        local int=$((num / 1000))\n        local\
    \ int2=`echo $int | bc`\n        local int3=`echo $int2 | bc`\n        local int4=`echo\
    \ $int3 | bc`\n        local int5=`echo $int4 | bc`\n        local int6=`echo\
    \ $int5 | bc`\n        local int7=`echo $int6 | bc`\n        local int8=`echo\
    \ $int7 | bc`\n        local num1=`echo $int8 | bc`\n        roman_num=$(echo\
    \ $num1 | awk '{print $1}')\n        roman=$(echo $roman_num | awk '{print substr($0,\
    \ length($0) - 1, 1)}')\n        roman=$roman_dict$roman\n    elif [[ \"$num\"\
    \ -le 1000000000 ]]; then\n        local int=$((num / 1000000))\n        local\
    \ int2=`echo $int | bc`\n        local int3=`echo $int2 | bc`\n        local int4=`echo\
    \ $int3 | bc`\n        local int5=`echo $int4 | bc`\n        local int6=`echo\
    \ $int5 | bc`\n        local int7=`echo $int6 | bc`\n        local int8=`echo\
    \ $int7 | bc`\n        local int9=`echo $int8 | bc`\n        local int10=`echo\
    \ $int9 | bc`\n        local int11=`echo $int10 | bc`\n        local int12=`echo\
    \ $int11 | bc`\n        local int13=`echo $int12 | bc`\n        local int14=`echo\
    \ $int13 | bc`\n        local int15=`echo $int14 | bc`\n        local int16=`echo\
    \ $int15 | bc`\n        local int17=`echo $int16 | bc`\n        local int18=`echo\
    \ $int17 | bc`\n        local int19=`echo $int18 | bc`\n        local int20=",
  "    local num=${1:-}\n    local roman=\"\"\n\n    local a=0\n    local b=0\n  \
    \  local c=0\n    local d=0\n    local e=0\n    local f=0\n    local g=0\n   \
    \ local h=0\n    local i=0\n    local j=0\n    local k=0\n    local l=0\n    local\
    \ m=0\n    local n=0\n    local o=0\n    local p=0\n    local q=0\n    local r=0\n\
    \    local s=0\n    local t=0\n    local u=0\n    local v=0\n    local w=0\n \
    \   local x=0\n    local y=0\n    local z=0\n    local roman_dict=\"x\"\n\n  \
    \  while [[ $num -gt 0 ]]; do\n        num=$(expr $num - 1)\n        # grab characters\
    \ from input string\n        (( num > 0 ))\n        (( num < 10 ))\n        ((\
    \ num > 0 ))\n        (( num >= 10 ))\n        (( num < 100 ))\n        (( num\
    \ >= 100 ))\n        (( num < 1000 ))\n        (( num >= 1000 ))\n        (( num\
    \ == 0 ))\n        # grab the character corresponding to the decimal digit\n \
    \       roman=\"${roman:+$roman$roman_dict}\"\n        # increment the corresponding\
    \ counter in the dictionary\n        (( roman_dict += $(expr $roman_dict + 1)\
    \ ))\n    done\n\n    # grab characters from the input string\n    roman=\"${roman:+$roman$roman_dict}\"\
    \n    roman=\"${roman:+$roman$roman_dict}\"\n    roman=\"${roman:+$roman$roman_dict}\"\
    \n\n    # convert counters to roman numerals\n    (( roman_dict = \"XIXLXXXVI\"\
    ))\n    roman=\"$(echo \"$roman\" | sed 's/[XIXLXXXVI]/X/' | sed 's/\\(.\\)\\\
    (.\\)/\\1\\L\\2/' | sed 's/^/L/' | sed 's/$/I/')\"\n    roman=\"$(echo \"$roman\"\
    \ | sed 's/[XIXLXXXVI]/I/')\"\n    roman=\"$(echo \"$roman\" | sed 's/\\(.\\)\\\
    (.\\)/\\1\\L\\2/' | sed 's/^/L/' | sed 's/$/I/')\"\n    ", "  echo \"$1\" | awk\
    \ -F '/' '{print $1%10, $1%100; $1%=10; $1%=100}' ", "  local input=$1\n  # If\
    \ it's < 0 or > 1000, return an error\n  if [ \"$input\" -lt 1 -o \"$input\" -gt\
    \ 1000 ]; then\n    echo \"Error: num ($input) not within range (1 <= num <= 1000)\"\
    \n    return 1\n  fi\n\n  # Create the initial string\n  local output=\"$input\"\
    \n\n  # Iterate through all the remaining digits\n  while [ \"$input\" -gt 0 ];\
    \ do\n    # If the remainder when divided by 5 is 1, add \"vi\"\n    if [ \"$output\"\
    \ -eq 0 ]; then\n      if [ \"$input\" -gt 9 ]; then\n        output=$(echo \"\
    $input/10\" | bc)\n        ((output += 5))\n      else\n        output=$(echo\
    \ \"$input/10\" | bc)\n      fi\n    else\n      if [ \"$input\" -gt 9 ]; then\n\
    \        output=$(echo \"$input/10\" | bc)\n        ((output += 5))\n      else\n\
    \        output=$(echo \"$input/10\" | bc)\n      fi\n    fi\n  done\n\n  # If\
    \ the input was > 1000, then append an \"x\"\n  if [ \"$output\" -gt 1000 ]; then\n\
    \    output=$(echo \"$output/10\" | bc)\n    output=\"x$output\"\n  fi\n\n  #\
    \ Return the lower case string\n  echo \"$output\"", "    # Validate input\n \
    \   if [[ $1 -lt 1 || $1 > 1000 ]]; then return 1; fi\n    # Initialize variables\n\
    \    number=$1\n    roman=\"\"\n    \n    # Iterate from 1 to num\n    for ((i=1;\
    \ i<=number; i++)); do\n        # Iterate from 1 to i\n        for ((j=1; j<=i;\
    \ j++)); do\n            # Obtain current value of number\n            value=$((number-j))\n\
    \            # Obtain current value of i\n            i=$i\n            # Obtain\
    \ current value of roman\n            roman=$(roman$(roman))${roman+value}\n \
    \       done\n    done\n    # Lower case\n    roman=$(echo \"$roman\" | sed -e\
    \ \"s/^[a-z]*//\" -e \"s/[0-9]*//\")\n    # Return output\n    echo \"$roman\"",
  "  local num=$1\n  [[ -z \"$num\" ]] || [[ \"$num\" -lt 1 || \"$num\" -gt 1000 ]]\
    \ || return 1\n  local roman\n  local i\n  local len\n  local roman_out\n  local\
    \ roman_out_lower\n  local roman_out_upper\n  local roman_out_length\n  roman=\"\
    \"\n  roman_out_length=${#roman}\n  for ((i = 1; i <= $num; i++)); do\n    roman+=$((10#$i))\n\
    \  done\n  roman_out=$(echo \"$roman\" | tr ' ' '~')\n  roman_out_lower=$(echo\
    \ \"$roman_out\" | tr '~' '-')\n  roman_out_upper=$(echo \"$roman_out\" | tr '-'\
    \ '~')\n  roman_out_length=${#roman_out_lower}\n  for ((i = 1; i <= roman_out_length;\
    \ i++)); do\n    roman_out+=\" \"\n  done\n  echo \"$roman_out_lower\"", "   \
    \ # convert decimal to roman numeral\n    local dec=$1\n    local roman=\"\"\n\
    \    for (( c=0 ; c<9 ; c++ )); do\n        local char=\"${dec%??????}\"\n   \
    \     if [[ \"$char\" =~ $ascii_roman_numeral_regex ]]; then\n            local\
    \ digit=$(echo $char | sed \"s/\\?$char/\\?0/\")\n            (( dec=dec/$digit\
    \ ))\n            roman=$roman$char\n        else\n            echo \"$char\"\n\
    \            exit 1;\n        fi\n    done\n    echo $roman", "  if [ \"$1\" -gt\
    \ \"1\" ] || [ \"$1\" -lt \"1000\" ]; then\n    return 1\n  fi\n  i=\"$1\"\n \
    \ rom=\"$(roman_to_int \"$i\")\"\n  res=\"$(mini_roman_to_mini_roman \"$i\")\"\
    \n  if [ \"$res\" == \"1\" ]; then\n    res=\"$(mini_roman_to_mini_roman \"$i\"\
    )\"\n  fi\n  if [ \"$rom\" != \"0\" ]; then\n    res=\"$res${res:1}\"\n  fi\n\
    \  printf \"%s\" \"$res\"", "  local numeral=\"$1\"\n  local lower=\"$2\"\n  local\
    \ num\n\n  (( lower-- ))\n  num=$(printf \"%.0s\" \"$numeral\" | sed 's/^\\(.\\\
    )\\(.\\)\\(.\\)\\(.\\)\\(.\\).*/\\1 \\2 \\3 \\4 \\5 \\6')\n  while [[ \"$num\"\
    \ =~ ^(.)(.)(.)(.)(.)(.)$ ]]; do\n    (( num=\"${BASH_REMATCH[5]}\" ))\n  done\n\
    \  echo \"$lower$num\"", "  # $1 is an integer\n  local -r num=$1\n\n  if [[ ${num}\
    \ -le 1 || ${num} -gt 1000 ]]; then\n    echo \"Invalid input: ${num}\"\n    return\
    \ 1\n  fi\n\n  local roman=\"\"\n\n  if [[ ${num} -eq 1 ]]; then\n    roman=\"\
    x\"\n  elif [[ ${num} -eq 2 ]]; then\n    roman=\"xc\"\n  elif [[ ${num} -eq 3\
    \ ]]; then\n    roman=\"cc\"\n  elif [[ ${num} -eq 4 ]]; then\n    roman=\"ccc\"\
    \n  elif [[ ${num} -eq 5 ]]; then\n    roman=\"cd\"\n  elif [[ ${num} -eq 6 ]];\
    \ then\n    roman=\"cccd\"\n  elif [[ ${num} -eq 7 ]]; then\n    roman=\"cdxx\"\
    \n  elif [[ ${num} -eq 8 ]]; then\n    roman=\"cccxx\"\n  elif [[ ${num} -eq 9\
    \ ]]; then\n    roman=\"cddd\"\n  elif [[ ${num} -eq 10 ]]; then\n    roman=\"\
    cdddd\"\n  elif [[ ${num} -eq 11 ]]; then\n    roman=\"cccc\"\n  elif [[ ${num}\
    \ -eq 12 ]]; then\n    roman=\"ccccl\"\n  elif [[ ${num} -eq 13 ]]; then\n   \
    \ roman=\"cccdl\"\n  elif [[ ${num} -eq 14 ]]; then\n    roman=\"cdxxl\"\n  elif\
    \ [[ ${num} -eq 15 ]]; then\n    roman=\"cxxxx\"\n  elif [[ ${num} -eq 16 ]];\
    \ then\n    roman=\"ccccll\"\n  elif [[ ${num} -eq 17 ]]; then\n    roman=\"cccdll\"\
    \n  elif [[ ${num} -eq 18 ]]; then\n    roman=\"cdxxll\"\n  elif [[ ${num} -eq\
    \ 19 ]]; then\n    roman=\"cxxxxl\"\n  elif [[ ${num} -eq 20 ]]; then\n    roman=\"\
    cccccll\"\n  elif [[ ${num} -eq 21 ]]; then\n    roman=\"cccdlll\"\n  elif [[\
    \ ${num} -eq 22 ]]; then\n    roman=\"cdxxlll\"\n  elif [[ ${num} -eq 23 ]]; then\n",
  "    local num=${1#*[0-9]}\n    # Convert integer to base 10\n    local num_base10=${num}\n\
    \    local num_roman=\"0\"\n    local i\n    for ((i=1; i<=6; i++)); do\n    \
    \    local roman_num=${num_base10}\n        local roman_num_len=$(echo \"${roman_num}\"\
    \ | wc -c)\n        local roman_num_base=$(echo \"${roman_num}\" | sed \"s/.*/$((${roman_num_len}\
    \ * 10 + 1))/\")\n        roman_num=$(echo \"$roman_num_base$roman_num\" | sed\
    \ \"s/.$//\")\n        num_roman+=\"${roman_num}\"\n        num_base10=\"${roman_num_base}\"\
    \n    done\n\n    # Return mini-roman string\n    echo \"${num_roman,,}\"", " \
    \ if [[ $1 =~ ^[0-9]+$ ]]; then\n    local -i i\n    local -a map\n\n    local\
    \ -a roman\n    local -a romanrev\n\n    map=( $(roman_to_mini_roman \"$2\") )\n\
    \    romanrev=( $(roman_to_mini_roman \"$1\") )\n\n    for (( i=0; i < ${#romanrev[@]};\
    \ i++ )); do\n      local roman_rev=\"${romanrev[$i]}\"\n\n      if [[ \"${roman_rev}\"\
    \ -eq \"${map[$i]}\" ]]; then\n        roman=(\"${roman[@]}\")\n        roman=(\"\
    ${roman[@]/#/${map[$i]}}\")\n        break\n      fi\n    done\n\n    # reverse\
    \ the roman numeral into its decimal equivalent if needed\n    if [[ \"${roman[0]}\"\
    \ -eq \"${map[0]}\" ]]; then\n      romanrev=($(set +o; set -u; \"${roman[@]}\"\
    \ | tr a-z A-Z))\n    fi\n\n    # print to stdout and return the roman numeral\n\
    \    printf \"%s\" \"${romanrev[@]}\"\n  else\n    echo \"error: invalid input\"\
    \n  fi", "  # Convert string parameter to an integer\n  local num=\"$1\"\n\n \
    \ # Initialize an empty string as a roman numeral\n  local roman=\"\"\n\n  # Convert\
    \ the integer into its decimal representation\n  local decimal=\"$((10#$num))\"\
    \n\n  # Initialize a for loop variable\n  local i=0\n\n  # Repeat the following\
    \ steps until the decimal representation reaches zero\n  # (this is why it's important\
    \ to increment i after each iteration)\n  while [ $decimal -ge 1 ]; do\n    #\
    \ Convert the decimal representation back to a roman numeral equivalent\n    roman=\"\
    ${roman}${decimal}${i}\"\n\n    # Add the next consecutive value of i to the decimal\
    \ variable\n    ((decimal+=i))\n\n    # Increment the loop variable by one\n \
    \   ((i++))\n  done\n\n  # Return the roman numeral equivalent in lowercase\n\
    \  echo \"${roman,,}\"", "  local num=$1\n  local result=\"\"\n  local i\n\n \
    \ for ((i=1; i <= 1000; i++))\n  do\n    if ((num % i == 0))\n    then\n     \
    \ result+=$i\n    else\n      result+=\"x\"\n    fi\n  done\n  printf \"%s\" \"\
    $result\" | sed -E 's/^0+([a-z])/l\\1/'", "\tlocal input=${1:-$1}\n\tlocal i=0\n\
    \tlocal output=\"\"\n\tlocal maxlen=0\n\t# find longest number\n\twhile [ $i -lt\
    \ $input ]\n\tdo\n\t\tlocal x=$(echo \"$input\" | cut -d- -f$i)\n\t\tmaxlen=$((\
    \ ${#x} > maxlen ))\n\t\toutput=$output$x\n\t\ti=$(( i + 1 ))\n\tdone\n\tif [\
    \ $maxlen -gt 2 ]; then\n\t\techo \"$output\"\n\telse\n\t\techo \"$output\"\n\t\
    fi", "    if [ $# -ne 1 ] ; then\n        echo \"ERROR: Not enough arguments supplied.\"\
    \ >&2\n        return 1\n    fi\n    local num=$1\n    if [ $num -le 1 -o $num\
    \ -gt 1000 ] ; then\n        echo \"ERROR: argument 1 must be in range 1-1000.\"\
    \ >&2\n        return 1\n    fi\n    local roman=\"\"\n    local i=$((num-1))\n\
    \    while [ $i -ne 0 ] ; do\n        local remainder=$((num % 10))\n        roman=\"\
    $(printf \"%c\" \"$roman\" | tr \"a\" \"\" $((remainder - 1)))\"\n        num=$(expr\
    \ ${num} - $remainder)\n        i=$((num-1))\n    done\n    printf \"$roman\"\
    \ | tr \"a\" \"\"", "\techo \"$1\" | sed \"s/^\\([0-9]\\{1,\\}\\)$/\\L\\1/\"",
  "  if [ \"$1\" -le \"1\" ] || [ \"$1\" -gt \"1000\" ]; then\n    echo \"Bad parameter:\
    \ $1\"\n  fi\n  local num=\"$1\"\n  local numeral\n\n  numeral=\"$(\n    printf\
    \ \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(.\\)/\\1\\2\\3/'\n  )\" \"$(\n\
    \    printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(..\\)/\\1\\3\\2/'\n\
    \  )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(.\\)/\\\
    1\\2\\3/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\\
    )\\(..\\)/\\1\\3\\2/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\\
    (.\\)\\(.*\\)\\(.\\)/\\1\\2\\3/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n   \
    \ sed 's/^\\(.\\)\\(.*\\)\\(..\\)/\\1\\3\\2/'\n  )\" \"$(\n    printf \"%${#num}s\"\
    \ |\n    sed 's/^\\(.\\)\\(.*\\)\\(.\\)/\\1\\2\\3/'\n  )\" \"$(\n    printf \"\
    %${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(..\\)/\\1\\3\\2/'\n  )\" \"$(\n \
    \   printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(.\\)/\\1\\2\\3/'\n \
    \ )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\)\\(..\\)/\\\
    1\\3\\2/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\(.\\)\\(.*\\\
    )\\(.\\)/\\1\\2\\3/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n    sed 's/^\\(.\\\
    )\\(.*\\)\\(..\\)/\\1\\3\\2/'\n  )\" \"$(\n    printf \"%${#num}s\" |\n    sed\
    \ 's/^\\(.\\)\\(.*\\)\\(.\\)/\\1\\2\\3/'\n  )\" \"$(\n    printf \"%${#num}s\"\
    \ |", "    local num=$1\n    local roman_num=''\n    local first_digit\n    local\
    \ second_digit\n    local third_digit\n    local last_digit\n    local roman\n\
    \    local roman_letter\n\n    if [[ $num -ne 1 && $num -ne 3 && $num -ne 5 &&\
    \ $num -ne 7 && $num -ne 9 && $num -ne 11 ]]; then\n        echo\n        echo\
    \ \"ERROR: Invalid number: $1\"\n        echo\n        echo \"Valid numbers: 1\
    \ .. 100\"\n        echo\n        echo \"Usage:\"\n        echo\n        echo\
    \ \"  $(basename $0) <integer>\"\n        echo\n        exit 1\n    fi\n    case\
    \ \"$num\" in\n        1)\n            first_digit='x'\n            second_digit='i'\n\
    \            third_digit='v'\n            last_digit='x'\n            roman=\"\
    $1x$3i$5$7\"\n            ;;\n        2)\n            first_digit='x'\n      \
    \      second_digit='i'\n            third_digit='v'\n            last_digit='x'\n\
    \            roman=\"$1x$3i$5$7\"\n            ;;\n        3)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='l'\n            last_digit='x'\n\
    \            roman=\"$1x$3li$5$7\"\n            ;;\n        4)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='lx'\n            last_digit='x'\n\
    \            roman=\"$1x$3llx$5$7\"\n            ;;\n        5)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='x'\n            last_digit='v'\n\
    \            roman=\"$1x$3li$5$7\"\n            ;;\n        6)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='x'\n            last_digit='x'\n\
    \            roman=\"$1x$3lx$5$7\"\n            ;;\n        7)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='x'\n            last_digit='i'\n\
    \            roman=\"$1x$3li$5$7\"\n            ;;\n        8)\n            first_digit='c'\n\
    \            second_digit='l'\n            third_digit='x'\n            last_digit='i'\n\
    \            roman=\"$1x$3lx$5$7\"", "  echo \"$1\" | awk '\n  function base2roman(i)\
    \ {\n    roman[]={}\n    roman[0]=\"i\"\n    roman[1]=\"ii\"\n    roman[2]=\"\
    iii\"\n    roman[3]=\"iv\"\n    roman[4]=\"v\"\n    roman[5]=\"vi\"\n    roman[6]=\"\
    vii\"\n    roman[7]=\"viii\"\n    roman[8]=\"ix\"\n    roman[9]=\"x\"\n    roman[10]=\"\
    xi\"\n    roman[11]=\"xii\"\n    roman[12]=\"xiv\"\n    roman[13]=\"xvi\"\n  \
    \  roman[14]=\"xv\"\n    roman[15]=\"xvii\"\n    roman[16]=\"xviii\"\n    roman[17]=\"\
    xix\"\n    roman[18]=\"xx\"\n    roman[19]=\"xixi\"\n    roman[20]=\"xixii\"\n\
    \    roman[21]=\"xixiii\"\n    roman[22]=\"xixiv\"\n    roman[23]=\"xixv\"\n \
    \   roman[24]=\"xixvi\"\n    roman[25]=\"xixv\"\n    roman[26]=\"xixvii\"\n  \
    \  roman[27]=\"xixviii\"\n    roman[28]=\"xixix\"\n    roman[29]=\"xixx\"\n  \
    \  roman[30]=\"xixxi\"\n    roman[31]=\"xixxii\"\n    roman[32]=\"xixxiii\"\n\
    \    roman[33]=\"xixxiv\"\n    roman[34]=\"xixxv\"\n    roman[35]=\"xixxv\"\n\
    \    roman[36]=\"xixxvi\"\n    roman[37]=\"xixxvi\"\n    roman[38]=\"xixxvii\"\
    \n    roman[39]=\"xixxviii\"\n    roman[40]=\"xixix\"\n    roman[41]=\"xixix\"\
    \n    roman[42]=\"xixixi\"\n    roman[43]=\"xixixii", "    local num=$1\n    local\
    \ dnum\n    local d\n    local i\n    local roman\n\n    num=${num:--1}\n\n  \
    \  if [ $num -eq 0 ]; then\n        echo \"0\"\n    elif [ $num -eq 1 ]; then\n\
    \        echo \"I\"\n    elif [ $num -eq 2 ]; then\n        echo \"II\"\n    elif\
    \ [ $num -eq 3 ]; then\n        echo \"III\"\n    elif [ $num -eq 4 ]; then\n\
    \        echo \"IV\"\n    elif [ $num -eq 5 ]; then\n        echo \"V\"\n    elif\
    \ [ $num -eq 6 ]; then\n        echo \"VI\"\n    elif [ $num -eq 7 ]; then\n \
    \       echo \"VII\"\n    elif [ $num -eq 8 ]; then\n        echo \"VIII\"\n \
    \   elif [ $num -eq 9 ]; then\n        echo \"IX\"\n    elif [ $num -eq 10 ];\
    \ then\n        echo \"X\"\n    elif [ $num -eq 11 ]; then\n        echo \"XI\"\
    \n    elif [ $num -eq 12 ]; then\n        echo \"XII\"\n    elif [ $num -eq 13\
    \ ]; then\n        echo \"XIII\"\n    elif [ $num -eq 14 ]; then\n        echo\
    \ \"XIV\"\n    elif [ $num -eq 15 ]; then\n        echo \"XV\"\n    elif [ $num\
    \ -eq 16 ]; then\n        echo \"XVI\"\n    elif [ $num -eq 17 ]; then\n     \
    \   echo \"XVII\"\n    elif [ $num -eq 18 ]; then\n        echo \"XVIII\"\n  \
    \  elif [ $num -eq 19 ]; then\n        echo \"XIX\"\n    elif [ $num -eq 20 ];\
    \ then\n        echo \"XX\"\n    elif [ $num -eq 21 ]; then\n        echo \"XXI\"\
    \n    elif [ $num -eq 22 ]; then\n        echo \"XXII\"\n    elif [ $num -eq 23\
    \ ]; then\n        echo \"XXIII\"\n    elif [ $num -eq 24 ]; then\n        echo\
    \ \"XXIV\"\n    elif [ $num -eq 25 ]; then\n        echo \"XXV\"\n    elif [ $num\
    \ -eq 26 ]; then\n        echo \"XXVI\"\n    elif [ $num -eq 27 ]; then\n    \
    \    echo \"XXVII\"\n    elif [ $num -eq 28 ]; then\n        echo \"XXVIII\"\n\
    \    elif [ $num -eq 29 ]; then\n        echo \"XXIX\"\n    elif [ $num -eq 30\
    \ ]; then\n        echo \"XXX\"\n    elif [ $num -eq 31 ]; then\n        echo\
    \ \"XXXI\"\n    elif ", "  local num=$1\n  local mini_roman=\"0\"\n  while [ $num\
    \ -gt 0 ]; do\n    (( num -= 10 ))\n    mini_roman=\"$mini_roman x\"\n  done\n\
    \  echo ${mini_roman::-1}", "    local num=\"$1\"\n    local i\n    local roman\n\
    \    local ret\n    local count\n    local n\n\n    # Round to nearest multiple\
    \ of 3\n    if [ ! \"${num}\" -gt 1000 ] ; then\n        num=$(( num / 300 ))\n\
    \    fi\n\n    if [ ! \"${num}\" -gt 0 ] ; then\n        return 0\n    fi\n\n\
    \    # Convert base to lowercase\n    num=$( echo \"$num\" | tr '[:upper:]' '[:lower:]'\
    \ )\n\n    roman=\"\"\n    for (( i = 1; i <= num; i++ )) ; do\n        count=$(\
    \ echo \"$i\" | bc )\n        roman+=\"$(roman_num \"${count}\")\"\n    done\n\
    \    ret=\"${roman::-1}\"\n    echo ${ret:0:1}", "    local number=$1\n    if\
    \ [ ${#number} -lt 1 ]; then\n        echo \"Error: num must be integer and greater\
    \ than 0\"\n        exit 1\n    elif [ ${#number} -gt 1000 ]; then\n        echo\
    \ \"Error: num must be integer and less than 1000\"\n        exit 1\n    fi\n\
    \    local roman=\"\"\n    local digit=0\n    local i\n    local j\n    # Handle\
    \ special cases\n    if [ ${number} -eq 0 ]; then roman=\"0\"; return ${roman}\n\
    \    elif [ ${number} -eq 1 ]; then roman=\"i\"; return ${roman}\n    elif [ ${number}\
    \ -eq 4 ]; then roman=\"iv\"; return ${roman}\n    elif [ ${number} -eq 5 ]; then\
    \ roman=\"ivi\"; return ${roman}\n    elif [ ${number} -eq 9 ]; then roman=\"\
    ix\"; return ${roman}\n    elif [ ${number} -eq 10 ]; then roman=\"xix\"; return\
    \ ${roman}\n    elif [ ${number} -eq 20 ]; then roman=\"vix\"; return ${roman}\n\
    \    elif [ ${number} -eq 30 ]; then roman=\"ixvi\"; return ${roman}\n    elif\
    \ [ ${number} -eq 50 ]; then roman=\"lv\"; return ${roman}\n    elif [ ${number}\
    \ -eq 60 ]; then roman=\"lvi\"; return ${roman}\n    elif [ ${number} -eq 70 ];\
    \ then roman=\"lvx\"; return ${roman}\n    elif [ ${number} -eq 80 ]; then roman=\"\
    lxvi\"; return ${roman}\n    elif [ ${number} -eq 90 ]; then roman=\"xlv\"; return\
    \ ${roman}\n    elif [ ${number} -eq 100 ]; then roman=\"xlix\"; return ${roman}\n\
    \    # Handle normal cases\n    for (( i = 1; i <= number; i++ )); do\n      \
    \  digit=$(echo $number | awk '{printf \"%.2s\\n\", $i}')\n        if [ -z ${roman+digit}\
    \ ]; then\n            roman=\"${roman}x\"\n        elif [ -z ${roman+digit} ];\
    \ then\n            roman=\"${roman}${roman}\"\n        fi\n    done\n    roman=\"\
    ${roman}i\"\n    echo \"${roman}\"", "  if [ $# -eq 0 ] ; then\n    echo \"Usage:\
    \ $(basename $0) integer\"\n  fi\n  roman_numerals=\"i ii iii iv v vi vii viii\
    \ ix x xi xii\"\n  int_to_mini_roman_helper", "  # Convert the integer to an array\
    \ of characters\n  str=$1\n  str=${str//-/}\n  str=${str//\\+/}\n  str=${str//}\n\
    \  str=${str//+/}\n\n  # If the string length is less than or equal to 3\n  if\
    \ [[ $str -lt 3 ]]; then\n    echo \"ERROR! Integer must be positive and less\
    \ than 1000!\"\n    exit 1\n  fi\n\n  # Initialize an empty array for the resulting\
    \ roman numeral\n  roman =\n\n  # Loop through the characters in the string and\
    \ determine what type of character\n  # it is\n  for (( i = 0; i < ${#str}; i++\
    \ )); do\n    char=${str:$i:1}\n\n    # If the character is between '0' and '9',\
    \ then it is a numeral\n    if (( ${char:0:1} <= 9 && ${char:1:1} <= 9 )); then\n\
    \      # If the character is a numeral then the roman numeral is just the character\n\
    \      roman+=$char\n      # Otherwise, it is a letter\n    else\n      # If the\
    \ character is between 'A' and 'Z', then it is a roman numeral\n      if (( ${char:0:1}\
    \ <= Z && ${char:1:1} <= Z )); then\n        roman+=${char:0:1}i\n      else\n\
    \        roman+=${char:0:1}e\n      fi\n    fi\n  done\n\n  # Return this value\n\
    \  echo $roman", '    echo "$1" | sed -r "s/^([0-9]+)$/\U\1/g"', "    local num=$1\n\
    \    local output=\"\"\n\n    local MINUS_ONE=\"\\u{2d}\\u00b2\"\n    local ZERO_ONE=\"\
    \\u{30}\\u00b0\"\n    local ONE_ONE=\"\\u{31}\\u00b1\"\n    local TWO_ONE=\"\\\
    u{32}\\u00b2\"\n    local THREE_ONE=\"\\u{33}\\u00b3\"\n    local FOUR_ONE=\"\\\
    u{34}\\u00b4\"\n    local FIVE_ONE=\"\\u{35}\\u00b5\"\n    local SIX_ONE=\"\\\
    u{36}\\u00b6\"\n    local SEVEN_ONE=\"\\u{37}\\u00b7\"\n    local EIGHT_ONE=\"\
    \\u{38}\\u00b8\"\n    local NINE_ONE=\"\\u{39}\\u00b9\"\n    local TEN_ONE=\"\\\
    u{3a}\\u00ba\"\n    local ELEVEN_ONE=\"\\u{3b}\\u00bb\"\n    local TWELVE_ONE=\"\
    \\u{3c}\\u00bc\"\n    local THIRTEEN_ONE=\"\\u{3d}\\u00bd\"\n    local FOURTEEN_ONE=\"\
    \\u{3e}\\u00be\"\n    local FIFTEEN_ONE=\"\\u{3f}\\u00bf\"\n    local SIXTEEN_ONE=\"\
    \\u{40}\\u00c0\"\n    local SEVENTEEN_ONE=\"\\u{41}\\u00c1\"\n    local EIGHTEEN_ONE=\"\
    \\u{42}\\u00c2\"\n    local NINETEEN_ONE=\"\\u{43}\\u00c3\"\n    local TWENTY_ONE=\"\
    \\u{44}\\u00c4\"\n    local THIRTY_ONE=\"\\u{45}\\u00c5\"\n    local FOURTY_ONE=\"\
    \\u{46}\\u00c6\"\n    local FORTY_ONE=\"\\u{47}\\u00c7\"\n    local SIXTY_ONE=\"\
    \\u{48}\\u00c8\"\n    local SEVENTY_ONE=\"\\u{49}\\u00c9\"\n    local EIGHTY_ONE=\"\
    \\u{4a}\\u00ca\"\n    local NINETY_ONE=\"\\u{4b}\\u00cb\"\n    local ONE_HUNDRED=\"\
    \\u{100}\\u00b1\"\n    local TWO_HUNDRED=\"\\u{101}\\u00b2\"\n    local THREE_HUNDRED=\"\
    \\u{102}\\u00b3\"\n    local FOUR_HUNDRED=\"\\u{103}\\u00b4\"\n    local FI",
  "  [[ ${1} == 1 ]] || [[ ${1} -le 1000 ]] || return\n  local num=$1\n  case \"${num}\"\
    \ in\n  1)\n    echo \"x\"\n    ;;\n  2)\n    echo \"c\"\n    ;;\n  3)\n    echo\
    \ \"b\"\n    ;;\n  4)\n    echo \"u\"\n    ;;\n  5)\n    echo \"d\"\n    ;;\n\
    \  6)\n    echo \"x\"\n    ;;\n  7)\n    echo \"g\"\n    ;;\n  8)\n    echo \"\
    p\"\n    ;;\n  9)\n    echo \"f\"\n    ;;\n  10)\n    echo \"p\"\n    ;;\n  11)\n\
    \    echo \"x\"\n    ;;\n  12)\n    echo \"c\"\n    ;;\n  13)\n    echo \"b\"\n\
    \    ;;\n  14)\n    echo \"u\"\n    ;;\n  15)\n    echo \"d\"\n    ;;\n  16)\n\
    \    echo \"f\"\n    ;;\n  17)\n    echo \"p\"\n    ;;\n  18)\n    echo \"x\"\n\
    \    ;;\n  19)\n    echo \"c\"\n    ;;\n  20)\n    echo \"b\"\n    ;;\n  21)\n\
    \    echo \"u\"\n    ;;\n  22)\n    echo \"d\"\n    ;;\n  23)\n    echo \"f\"\n\
    \    ;;\n  24)\n    echo \"p\"\n    ;;\n  25)\n    echo \"x\"\n    ;;\n  26)\n\
    \    echo \"c\"\n    ;;\n  27)\n    echo \"b\"\n    ;;\n  28)\n    echo \"u\"\n\
    \    ;;\n  29)\n    echo \"d\"\n    ;;\n  30)\n    echo \"f\"\n    ;;\n  31)\n\
    \    echo \"p\"\n    ;;\n  32)\n    echo \"x\"\n    ;;\n  33)\n    echo \"c\"\n\
    \    ;;\n  34)\n    echo \"b\"\n    ;;\n  35)\n    echo \"u\"\n    ;;\n  36)\n\
    \    echo \"d\"\n    ;;\n  37)\n    echo \"f\"\n    ;;\n  38)\n    echo \"p\"\n\
    \    ;;\n  39)\n    echo \"x\"\n    ;;\n  40)\n    echo \"c\"\n    ;;\n  41)\n\
    \    echo \"b\"\n    ;;\n  42)\n    echo \"u\"\n    ;;\n  43)\n    echo \"d\"\n\
    \    ;;\n  44)\n    echo \"f\"\n    ;;\n  45)\n    echo \"p\"\n    ;;\n  46)\n\
    \    echo \"x\"\n    ;;\n  47)\n    echo \"c\"\n    ;;\n  48)\n    echo \"b\"\n\
    \    ;;\n  49)\n    echo \"u\"", "  local num=$1\n  local roman mini\n  local\
    \ i ix vi xi vii xvi xvii xvvi xixi vixi xixii vixii xixiii vixiii xixiv\n  local\
    \ v vi vx vii vvi vvii vviii vixi vixii vixix vixivi vixiii vixivii vixivii\n\
    \  local vix vixi vixii vixii\n\n  if (( ${num} < 1 || ${num} > 1000 )); then\n\
    \    echo \"Error with number $num. Number must be in range 1-1000.\"\n  else\n\
    \    roman=\"0\"\n    mini=\"0\"\n    # Convert to base 10 first\n    num=$(echo\
    \ \"$num\" | sed 's/^\\([0-9]*\\)/\\1/')\n    while (( ${#num} > 0 )); do\n  \
    \    i=$(( $num % 10 ))\n      roman=\"${roman}${i:1}\"\n      num=$(expr $num\
    \ / 10)\n    done\n    # Now convert back to base-10\n    num=$(echo \"$roman\"\
    \ | sed 's/^\\([0-9]*\\)\\([0-9]*\\)/\\2/')\n    # Now convert back to base-1000\n\
    \    num=$(echo \"$roman\" | sed 's/^\\([0-9]*\\)\\([0-9]*\\)\\([0-9]*\\)/\\3\
    \ /')\n    i=$(( $num % 1000 ))\n    vi=$(( $i / 10 ))\n    vx=$(( $i % 10 ))\n\
    \    vii=$(( $i / 100 ))\n    vx=$(( $vx + $vi ))\n    viii=$(( $i / 1000 ))\n\
    \    vvi=$(( $i % 1000 ))\n    vvii=$(( $vvi + $viii ))\n    vviii=$(( $vvi +\
    \ $viii ))\n    vvi=x$vvi\n    vvii=x$vvii\n    vx=x$vx\n    vi=x$vi\n    vii=x$vii\n\
    \    xi=x$xi\n    vii=x$vii\n    xvi=x$xvi\n    xvii=x$xvii\n    xvi=x$xvi\n \
    \   xixi=x$xixi\n    viii=x$viii\n    xi=x$xi\n    xii=x$xi\n    x", "  local\
    \ NUM\n  NUM=$1\n  case ${NUM} in\n    1)\n      echo \"I\";;\n    2)\n      echo\
    \ \"IV\";;\n    3)\n      echo \"III\";;\n    4)\n      echo \"II\";;\n    5)\n\
    \      echo \"V\";;\n    6)\n      echo \"VI\";;\n    7)\n      echo \"VII\";;\n\
    \    8)\n      echo \"VIII\";;\n    9)\n      echo \"IX\";;\n    10)\n      echo\
    \ \"X\";;\n    11)\n      echo \"XI\";;\n    12)\n      echo \"XII\";;\n    13)\n\
    \      echo \"XIII\";;\n    14)\n      echo \"XIV\";;\n    15)\n      echo \"\
    XV\";;\n    16)\n      echo \"XVI\";;\n    17)\n      echo \"XVII\";;\n    18)\n\
    \      echo \"XVIII\";;\n    19)\n      echo \"XIX\";;\n    20)\n      echo \"\
    XX\";;\n    21)\n      echo \"XXI\";;\n    22)\n      echo \"XXII\";;\n    23)\n\
    \      echo \"XXIII\";;\n    24)\n      echo \"XXIV\";;\n    25)\n      echo \"\
    XXV\";;\n    26)\n      echo \"XXVI\";;\n    27)\n      echo \"XXVII\";;\n   \
    \ 28)\n      echo \"XXVIII\";;\n    29)\n      echo \"XXIX\";;\n    30)\n    \
    \  echo \"XXX\";;\n    31)\n      echo \"XXXI\";;\n    32)\n      echo \"XXXII\"\
    ;;\n    33)\n      echo \"XXXIII\";;\n    34)\n      echo \"XXXIV\";;\n    35)\n\
    \      echo \"XXXV\";;\n    36)\n      echo \"XXXVI\";;\n    37)\n      echo \"\
    XXXVII\";;\n    38)\n      echo \"XXXVIII\";;\n    39)\n      echo \"XXXIX\";;\n\
    \    40)\n      echo \"XL\";;\n    41)\n      echo \"XLI\";;\n    42)\n      echo\
    \ \"XLII\";;\n    43)\n      echo \"XLIII\";;\n    44)\n      echo \"XLIV\";;\n\
    \    45)\n      echo \"XLIVI\";;\n    46)\n      echo \"XLIVII\";;\n    47)\n\
    \      echo \"", "  local num=$1\n  local i=$(( ${#num} - 1 ))\n  local iconv\n\
    \  local roman\n  while (( i > 0 )); do\n    roman=`printf \"%${i}s\" \"MCMXCML\"\
    `\n    iconv=`iconv -f utf-8 -t utf-8 --from-code=\\`printf \"%d\" ${i}\\`-\\\
    `printf \"%d\" ${i}\\`\\` \\\n      | sed -e 's/M//g' -e 's/C//g' -e 's/M//g'\
    \ -e 's/C//g' -e 's/X//g' -e 's/C//g' \\\n      -e 's/M//g' -e 's/X//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/X//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e 's/C//g'\
    \ -e 's/X//g' -e 's/C//g' -e 's/C//g' \\\n      -e 's/X//g' -e 's/C//g' -e ",
  "  echo \"$1\" | awk '{print substr($0,index($0,\"M\"),1);}'", "    local roman_num=$1\n\
    \    local roman_chars=$(roman_num_to_roman_chars $roman_num)\n    roman_chars=$(echo\
    \ \"${roman_chars}\" | tr -d '\\r')\n    roman_chars=$(echo \"${roman_chars}\"\
    \ | tr '[:upper:]' '[:lower:]')\n    echo \"${roman_chars}\"", "  # If $1 is 0,\
    \ return $2\n  # If $1 is negative, return \"-\"\n  # If $1 is 1, return \"x\"\
    \n  if [[ $1 -eq 0 ]]; then\n    echo -n $2\n  elif [[ $1 -lt 0 ]]; then\n   \
    \ echo \"-\"\n  else\n    # Convert $1 to an array, and sort it to make it easier\
    \ to iterate\n    int_arr=($(echo $1 | sort -n))\n    # Iterate through the array\n\
    \    for i in \"${int_arr[@]}\"; do\n      # If $i divides evenly, then return\
    \ $i followed by \"x\"\n      if [[ ${i} -eq 0 ]]; then\n        echo -n $i $2\n\
    \      # If $i divides evenly, and $i divides exactly halfway, then return $i\
    \ followed by \"ix\"\n      elif [[ ${i} -eq 1 && ${i} -gt 1 ]]; then\n      \
    \  echo -n $i $2 $2\n      # If $i divides unevenly, then return $i followed by\
    \ \"i\"\n      elif [[ ${i} -lt 1 || ${i} -gt $((${#int_arr[@]})) ]]; then\n \
    \       echo -n $i $2\n      fi\n    done\n  fi", "\tlocal i\n\n\t# Ensure that\
    \ the input is an integer\n\ti=$1 #force\n\n\t# Handle single-digit integer inputs\
    \ first\n\tif [ $i -eq 1 ] ; then\n\t\techo \"x\"\n\t\treturn 0\n\tfi\n\n\tlocal\
    \ num\n\tlocal r1\n\tlocal r2\n\tlocal r3\n\tlocal r4\n\tlocal i1\n\tlocal i2\n\
    \tlocal i3\n\tlocal i4\n\tlocal n\n\tlocal m\n\tlocal r\n\n\t# Initialize variables\n\
    \tnum=0\n\ti1=0\n\ti2=0\n\ti3=0\n\ti4=0\n\tr1=0\n\tr2=0\n\tr3=0\n\tr4=0\n\tn=0\n\
    \tm=0\n\twhile [ $i -gt 0 ]\n\tdo\n\t\tnum=$(( $num + $i ))\n\t\ti=$(( $i - 1\
    \ ))\n\n\t\t# Handle single-digit integer inputs\n\t\tif [ $i -eq 1 ] ; then\n\
    \t\t\ti=$(( $i + 1 ))\n\t\t\tr1=$r1$r1\n\t\t\tr2=$r2$r2\n\t\t\tr3=$r3$r3\n\t\t\
    \tr4=$r4$r4\n\t\t\tcontinue\n\t\tfi\n\n\t\t# Handle multiple-digit integer inputs\n\
    \t\tif [ $num -eq 0 ] ; then\n\t\t\ti=$(( $i + 1 ))\n\t\t\tr1=$r1$r1\n\t\t\tr2=$r2$r2\n\
    \t\t\tr3=$r3$r3\n\t\t\tr4=$r4$r4\n\t\t\tcontinue\n\t\tfi\n\n\t\tm=$(( $m - 1 ))\n\
    \t\ti=$(( $i - 1 ))\n\t\ti1=$i1$i1\n\t\ti2=$i2$i2\n\t\ti3=$i3$i3\n\t\ti4=$i4$i4\n\
    \n\t\tif [ $m -eq 0 ] ; then\n\t\t\t# Handle first multiple-digit integer\n\t\t\
    \tr=$(( $r + 1 ))\n\t\t\tr1=$r1$r1\n\t\t\tr2=$r2$r2\n\t\t\tr3=$r3$r3\n\t\t\tr4=$r4$r4\n\
    \t\telse\n\t\t\t# Handle following multiple-digit integers\n\t\t\tr=$(( $r + 10\
    \ ))\n\t\t\tr1=$r1$r1\n\t\t\tr2=$r2$r2\n\t\t\tr3=$r3$r3\n\t\t\tr4=$r4$r4\n\t\t\
    fi\n\n", "  local number=$1\n  local roman_numeral=\n  local previous_roman=\n\
    \  local previous_numeral=\n  local numeral\n  local i\n  \n  while [ \"$roman_numeral\"\
    \ == \"$previous_roman\" ] || [ \"$roman_numeral\" == \"$previous_numeral\" ];\
    \ do\n    numeral=$(int_to_roman_numeral $number | cut -d 'x' -f 1)\n    roman_numeral=$(int_to_roman_numeral\
    \ $number | cut -d 'x' -f 2)\n    previous_numeral=$numeral\n    previous_roman=$roman_numeral\n\
    \  done\n  \n  (( $number > 0 )) && numeral=\"I$numeral\"\n  (( $number > 0 ))\
    \ && roman_numeral=\"$numeral$roman_numeral\"\n  (( $number > 1 )) && numeral=\"\
    X$numeral\"\n  (( $number > 1 )) && roman_numeral=\"$numeral$roman_numeral\"\n\
    \  (( $number > 2 )) && numeral=\"C$numeral\"\n  (( $number > 2 )) && roman_numeral=\"\
    $numeral$roman_numeral\"\n  (( $number > 3 )) && numeral=\"L$numeral\"\n  (( $number\
    \ > 3 )) && roman_numeral=\"$numeral$roman_numeral\"\n  (( $number > 4 )) && numeral=\"\
    D$numeral\"\n  (( $number > 4 )) && roman_numeral=\"$numeral$roman_numeral\"\n\
    \  (( $number > 5 )) && numeral=\"M$numeral\"\n  (( $number > 5 )) && roman_numeral=\"\
    $numeral$roman_numeral\"\n  (( $number > 6 )) && numeral=\"V$numeral\"\n  (( $number\
    \ > 6 )) && roman_numeral=\"$numeral$roman_numeral\"\n  (( $number > 7 )) && numeral=\"\
    I$numeral\"\n  (( $number > 7 )) && roman_numeral=\"$numeral$roman_numeral\"\n\
    \  (( $number > 8 )) && numeral=\"X$numeral\"\n  (( $number > 8 )) && roman_numeral=\"\
    $numeral$roman_numeral\"\n  (( $number > 9 )) && numeral=\"C$numeral\"\n  (( $number\
    \ > 9 )) && ", "\tlocal -i num=${1:-0}\n\tlocal roman=0\n\t# The largest roman\
    \ numeral with 3 digits is \"MMMCMXC\", where MMM and CMX\n\t# are the first and\
    \ last roman numerals with that many digits. We only\n\t# want one extra digit\
    \ in this case.\n\tlocal max_roman=`echo \\($num - 1\\) | awk '{ print ($1 % 1000)\
    \ }'`\n\tlocal roman2=$max_roman\n\tlocal digit\n\tlocal roman3\n\twhile [ $roman\
    \ -lt $max_roman ]; do\n\t\tdigit=$(( $num % 10 ))\n\t\troman=$(( $roman + $digit\
    \ * 1000 ))\n\t\troman3=$roman3$(( $roman % 1000 ))\n\t\tnum=$(expr ${num} - $digit)\n\
    \tdone\n\t# The largest roman numeral with 4 digits is \"MMMMCMXCCD\", where MMM,\n\
    \t# CMX and CDD are the first and last roman numerals with that many\n\t# digits.\
    \ We only want one extra digit in this case.\n\tmax_roman=`echo \\($num - 1\\\
    ) | awk '{ print ($1 % 100000) }'`\n\troman2=$max_roman\n\tdigit\n\troman3=$roman3$((\
    \ $roman % 100000 ))\n\tnum=$(expr ${num} - $digit)\n\tif [ $num -gt 0 ]; then\n\
    \t\troman2=$roman2$(( $num / 1000 ))\n\t\troman3=$roman3$(( $num % 1000 ))\n\t\
    fi\n\tlocal ret\n\tlocal i\n\tfor (( i=1; i <= 6; i++ )); do\n\t\tret=$roman2$roman3\n\
    \t\troman2=$roman2$(expr ${roman2} / 1000)\n\t\troman3=$roman3$(expr ${roman3}\
    \ % 1000)\n\tdone\n\techo $ret", "  local num=\"$1\"\n  shift\n  local roman\n\
    \  local digit\n  local i\n  roman=\"\"\n\n  for ((i=0; i<${#num}; i++)); do\n\
    \    digit=\"${num:$i:1}\"\n    case \"$digit\" in\n      0) continue;;\n    \
    \  1) roman=\"${roman}x\";;\n      2) roman=\"${roman}l\";;\n      3) roman=\"\
    ${roman}c\";;\n      4) roman=\"${roman}d\";;\n      5) roman=\"${roman}m\";;\n\
    \      6) roman=\"${roman}v\";;\n      7) roman=\"${roman}i\";;\n    esac\n  done\n\
    \  echo \"${roman,,}\"", "  local num=$1\n  local roman=\n  # Determine how many\
    \ characters will be required. There are 26 letters and\n  # 3 digits, so we start\
    \ with 26 characters and add 3 as we add digits.\n  local length=${#num}\n  for\
    \ (( i=1; i<${#num}; i++ )); do\n    (( length=length+1 ))\n  done\n  # Add 1\
    \ for the \"I\" and the \"M\" in the roman numeral.\n  (( length=length+1 ))\n\
    \  # Now convert each digit to its equivalent roman numeral.\n  for (( i=1; i<${#num};\
    \ i++ )); do\n    local digit=${num:$i:1}\n    local digitroman=$(roman_num $digit)\n\
    \    if [[ $digitroman ]]; then\n      roman=\"${roman}${digitroman}\"\n    fi\n\
    \  done\n  # The roman numeral is now stored in roman and we can return it.\n\
    \  echo ${roman,,}", "  local num=$1\n  local roman=\"\"\n  local alphabet=\"\
    MCMXC\"\n  local digits=\" IVXLCDM\"\n  local numeral_to_roman=\"\"\n\n  for ((i=0;\
    \ i < ${#num}; i++)); do\n    numeral_to_roman=\"${numeral_to_roman}${digits:$((${#num}\
    \ - i)):1}\"\n  done\n\n  for ((i=0; i < ${#alphabet}; i++)); do\n    local j=${#numeral_to_roman}\
    \ - ${#alphabet}\n\n    # Break if j is now a negative value\n    if [[ \"${numeral_to_roman:$j:1}\"\
    \ =~ ^[${alphabet}]$ ]]; then\n      roman=\"${roman}${alphabet:$j:1}\"\n    \
    \  numeral_to_roman=\"${numeral_to_roman:0:$j}\"\n      break\n    fi\n  done\n\
    \n  echo \"${roman}\"", "  # Convert to an integer to avoid a bug with some versions\
    \ of bc\n  local int_num=${1%% *}\n\n  # Use an associative array to speed up\
    \ the lookup\n  local roman_roman_table=({\n    1=\"I\",\n    2=\"II\",\n    3=\"\
    III\",\n    4=\"IV\",\n    5=\"V\",\n    6=\"VI\",\n    7=\"VII\",\n    8=\"VIII\"\
    ,\n    9=\"IX\",\n    10=\"X\",\n    11=\"XI\",\n    12=\"XII\",\n    13=\"XIII\"\
    ,\n    14=\"XIV\",\n    15=\"XV\",\n    16=\"XVI\",\n    17=\"XVII\",\n    18=\"\
    XVIII\",\n    19=\"XIX\",\n    20=\"XX\",\n    21=\"XXI\",\n    22=\"XXII\",\n\
    \    23=\"XXIII\",\n    24=\"XXIV\",\n    25=\"XXV\",\n    26=\"XXVI\",\n    27=\"\
    XXVII\",\n    28=\"XXVIII\",\n    29=\"XXIX\",\n    30=\"XXX\",\n    31=\"XXXI\"\
    ,\n    32=\"XXXII\",\n    33=\"XXXIII\",\n    34=\"XXXIV\",\n    35=\"XXXV\",\n\
    \    36=\"XXXVI\",\n    37=\"XXXVII\",\n    38=\"XXXVIII\",\n    39=\"XXXIX\"\
    ,\n    40=\"XL\",\n    41=\"L\",\n    42=\"LX\",\n    43=\"LX\",\n    44=\"LXX\"\
    ,\n    45=\"LXXX\",\n    46=\"LXXXX\",\n    47=\"LXXXXX\",\n    48=\"LXXXII\"\
    ,\n    49=\"LXXXIII\",\n    50=\"LXXXIV\",\n    51=\"LXXXV\",\n    52=\"LXXXVI\"\
    ,\n    53=\"LXXXVII\",\n    54=\"LXXXVIII\",\n    55=\"LXXXIX\",\n    56=\"LXXXII\"\
    ,\n    57=\"LXXXIII\",\n    58=\"LXXXIV\",\n    59=\"LXXXV\",\n    60=\"LXXXVI\"\
    ,\n    61=\"LXXXVII\",\n    62=\"LXXXVIII\",\n    63=\"LXXXIX\",", "\tlocal num=\"\
    $1\"\n\tlocal roman_num=\"x\"\n\tlocal index\n\tlocal alphabet=\"MCMXCI\"\n\t\
    for index in \"${!alphabet}\"; do\n\t\tif (( num < index )); then\n\t\t\troman_num=\"\
    ${roman_num}${alphabet[$index]}\"\n\t\t\tnum=\"${num}-${index}\"\n\t\tfi\n\tdone\n\
    \techo \"${roman_num}\"", "\techo \"${1}\" > /tmp/$$\n\tromanize_rc /tmp/$$\n\t\
    rm /tmp/$$\n\techo \"${1}\"", "    local num=\"$1\"\n    if [ \"$num\" -eq 1 ];\
    \ then\n        echo \"$num\"\n    elif [ \"$num\" -lt 1 ] || [ \"$num\" -gt 1000\
    \ ]; then\n        echo \"Invalid argument: $1\"\n        exit 1\n    else\n \
    \       # Roman's numerals are stored in an array indexed from 1\n        local\
    \ roman_numerals=$(roman_numerals)\n\n        # Roman numerals are stored in reverse\
    \ order, so the largest roman\n        # numeral is stored first\n        local\
    \ largest=\"${roman_numerals[-1]}\"\n        local smallest=\"${roman_numerals[0]}\"\
    \n        if [ \"$num\" -eq 2 ] || [ \"$num\" -eq 3 ]; then\n            # If\
    \ the number is 2, 3 or larger, the result is \"III\"\n            echo \"$smallest$smallest$smallest\"\
    \n        elif [ \"$num\" -lt 2 ]; then\n            # If the number is less than\
    \ 2, it is in numeral order and the\n            # result is \"I$num\"\n     \
    \       echo \"$largest$num$smallest\"\n        elif [ \"$num\" -le 2 ] && [ \"\
    $num\" -ge 4 ]; then\n            # If the number is 2 or larger, it is in reverse\
    \ numeral order,\n            # and the result is\n            # \"I$num\" if\
    \ it is even, otherwise \"III\"\n            if [ \"$num\" -le 3 ]; then\n   \
    \             echo \"$smallest$num$largest\"\n            else\n             \
    \   echo \"$smallest$largest$num\"\n            fi\n        elif [ \"$num\" -ge\
    \ 4 ] && [ \"$num\" -lt 7 ]; then\n            echo \"$largest$smallest$smallest$smallest\"\
    \n        elif [ \"$num\" -ge 7 ] && [ \"$num\" -lt 10 ]; then\n            echo\
    \ \"$largest$smallest$num$smallest\"\n        elif [ \"$num\" -ge 10 ] && [ \"\
    $num\" -lt 50 ]; then\n            echo \"$largest$smallest$num$largest\"\n  \
    \      elif [ \"$num\" -ge 50 ] && [ \"$num\" -lt 100 ]; then\n            echo\
    \ \"$largest$smallest$num$largest$smallest\"\n        elif [ \"$num\" -ge 100\
    \ ] && [ \"$num\" -lt 500 ]; then\n            echo \"$largest$smallest$num$largest$smallest$smallest\"\
    \n        elif [ \"$num\" -ge 500 ] && [ \"$num\" -lt 1000 ]; then\n         \
    \   echo \"$largest$smallest$num$largest$smallest$smallest$smallest\"\n      \
    \  else\n            # If the ", "  # Check if valid\n  [[ \"${1:?Parameter must\
    \ be an integer: ${1}\" != \"0\" ]] ||\n  [[ \"$1\" -lt 1 ]] ||\n  [[ \"$1\" -gt\
    \ 1000 ]]\n  \n  # Initialize variables\n  MINI_ROMAN_REP=\"\"\n  MINI_ROMAN_DIGITS=\"\
    \"\n  MINI_ROMAN_INCREMENT=0\n  \n  # If it's 0, return an empty string\n  [[\
    \ \"$1\" -eq 0 ]] && echo \"$MINI_ROMAN_REP\" && return 0\n  \n  # Remove trailing\
    \ zeros\n  echo \"$1\" | awk '{if($1 == \"0\") print $0; else print $0\".\"}'\n\
    \n  # Count leading zeros\n  MINI_ROMAN_DIGITS=\"$(echo \"$1\" | awk '{print length($0)}')\"\
    \n  # If it's the last digit, then no leading 0s needed\n  [[ \"${MINI_ROMAN_DIGITS}\"\
    \ -eq \"$1\" ]] && MINI_ROMAN_DIGITS=\"\"\n  # Iterate through every digit in\
    \ the number\n  for (( i=0; i < MINI_ROMAN_DIGITS; i++ )); do\n    # Get the next\
    \ number from the original number\n    MINI_ROMAN_INCREMENT=\"$(($1-$MINI_ROMAN_INCREMENT))\"\
    \n    # If it's the last digit, then no leading 0s needed\n    [[ \"${MINI_ROMAN_DIGITS}\"\
    \ -eq \"$1\" ]] && MINI_ROMAN_INCREMENT=\n    # Build mini roman numeral\n   \
    \ MINI_ROMAN_REP=\"$MINI_ROMAN_REP$(int_to_mini_roman_digit \"${MINI_ROMAN_INCREMENT}\"\
    )\"\n  done\n  echo \"$MINI_ROMAN_REP\"", "    local num=\"$1\"\n    # Handle\
    \ special case\n    if [[ \"${num}\" -eq \"1\" ]]; then\n        echo \"xix\"\n\
    \        return\n    fi\n    local roman_numeral=''\n    local roman_numeral_string=''\n\
    \    if [[ ${num} -gt 1 ]]; then\n        while [[ ${num} -gt 1 ]]; do\n     \
    \       # Get the next digit of num and push it onto the stack\n            local\
    \ digit=$(echo \"${num}\" | bc)\n            roman_numeral_string=\"${roman_numeral_string}\
    \ ${digit}\"\n            # Drop that digit\n            num=$(echo \"${num} %%\
    \ 10\" | bc)\n        done\n        # Append the top of the stack onto the final\
    \ roman_numeral\n        roman_numeral=\"${roman_numeral} ${roman_numeral_string}\"\
    \n    fi\n    echo -n \"${roman_numeral}\" | tr '[:upper:]' '[:lower:]'", "  \
    \  int_to_roman=\"$1\"\n    mini_roman=\"\"\n    length=\"$#\"\n\n    while [\
    \ $length -gt 0 ]; do\n        # Obtain the remainder from the integer division\
    \ operator\n        remainder=\"$(( ($int_to_roman % 4) * 10 ))\"\n        remainder=\"\
    $(( remainder + 1 ))\"\n\n        # Add the remainder to the current mini-roman\n\
    \        mini_roman=\"${mini_roman}$remainder\"\n\n        # Divide the integer\
    \ by 10\n        int_to_roman=\"$(( $int_to_roman / 4 ))\"\n        int_to_roman=\"\
    $(( $int_to_roman + 1 ))\"\n\n        length=\"$(( $length - 1 ))\"\n    done\n\
    \n    echo \"${mini_roman,,}\"", "  local num=$1\n  local mini_roman\n  case ${num}\
    \ in\n    1)\n      mini_roman=\"xix\";;\n    2)\n      mini_roman=\"cli\";;\n\
    \    3)\n      mini_roman=\"cdx\";;\n    4)\n      mini_roman=\"ccc\";;\n    5)\n\
    \      mini_roman=\"cc\";;\n    6)\n      mini_roman=\"c\";;\n    7)\n      mini_roman=\"\
    x\";;\n    8)\n      mini_roman=\"l\";;\n    9)\n      mini_roman=\"m\";;\n  \
    \  10)\n      mini_roman=\"xc\";;\n    11)\n      mini_roman=\"xl\";;\n    12)\n\
    \      mini_roman=\"lx\";;\n    13)\n      mini_roman=\"ix\";;\n    14)\n    \
    \  mini_roman=\"v\";;\n    15)\n      mini_roman=\"iv\";;\n    16)\n      mini_roman=\"\
    i\";;\n    17)\n      mini_roman=\"vi\";;\n    18)\n      mini_roman=\"ivi\";;\n\
    \    19)\n      mini_roman=\"vii\";;\n    20)\n      mini_roman=\"vix\";;\n  \
    \  21)\n      mini_roman=\"lvi\";;\n    22)\n      mini_roman=\"lvix\";;\n   \
    \ 23)\n      mini_roman=\"ixl\";;\n    24)\n      mini_roman=\"lxvi\";;\n    25)\n\
    \      mini_roman=\"ixvi\";;\n    26)\n      mini_roman=\"xxvi\";;\n    27)\n\
    \      mini_roman=\"xvi\";;\n    28)\n      mini_roman=\"vix\";;\n    29)\n  \
    \    mini_roman=\"ixx\";;\n    30)\n      mini_roman=\"lxx\";;\n    31)\n    \
    \  mini_roman=\"lxxx\";;\n    32)\n      mini_roman=\"xxxx\";;\n    *)\n     \
    \ echo \"$num not a valid roman numeral\"\n      return 1\n  esac\n  echo $mini_roman",
  "  if [[ $1 = 0 ]]; then return 1; fi\n  # Convert given integer to base 10 string\n\
    \  num=$(echo $1 | sed 's/\\./\\&/g') # Escape all periods\n  base=${num:0:1}\n\
    \  num=$(echo $num | sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo\
    \ $num | sed 's/^00/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num |\
    \ sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num | sed 's/^00/\\\
    &/g') # Convert leading zero to '&'\n  num=$(echo $num | sed 's/^0/\\&/g') # Convert\
    \ leading zero to '&'\n  num=$(echo $num | sed 's/^00/\\&/g') # Convert leading\
    \ zero to '&'\n  num=$(echo $num | sed 's/^0/\\&/g') # Convert leading zero to\
    \ '&'\n  num=$(echo $num | sed 's/^00/\\&/g') # Convert leading zero to '&'\n\
    \  num=$(echo $num | sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo\
    \ $num | sed 's/^00/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num |\
    \ sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num | sed 's/^00/\\\
    &/g') # Convert leading zero to '&'\n  num=$(echo $num | sed 's/^0/\\&/g') # Convert\
    \ leading zero to '&'\n  num=$(echo $num | sed 's/^00/\\&/g') # Convert leading\
    \ zero to '&'\n  num=$(echo $num | sed 's/^0/\\&/g') # Convert leading zero to\
    \ '&'\n  num=$(echo $num | sed 's/^00/\\&/g') # Convert leading zero to '&'\n\
    \  num=$(echo $num | sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo\
    \ $num | sed 's/^00/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num |\
    \ sed 's/^0/\\&/g') # Convert leading zero to '&'\n  num=$(echo $num | sed 's/^00/\\\
    &/g') # Convert leading zero to '&'\n  num=$(", "    local num=$1\n    local mini_roman=\"\
    \"\n\n    # Special case for 0 and 1, and don't need to add any more numbers.\n\
    \    if [ $num -eq 0 -o $num -eq 1 ] ; then\n        echo \"$num\"\n        return\n\
    \    fi\n\n    # Add 'm' to the beginning if the number is negative.\n    if [\
    \ $num -le 0 ] ; then\n        mini_roman=\"m\"\n    fi\n\n    # Get the decimal\
    \ equivalent of this integer, starting with 'num'.\n    local dec=`echo $num |\
    \ sed 's/^\\([0-9]*\\)\\([a-zA-Z]*\\)/\\1\\2/'`\n    local remainder\n\n    #\
    \ Get the remainder of this integer divided by 100\n    local remainder_dec=`echo\
    \ $dec | sed 's/\\([0-9]*\\)\\([a-zA-Z]*\\)/\\1\\2/'`\n    remainder=`echo $remainder_dec\
    \ | sed 's/\\([0-9]*\\)\\([a-zA-Z]*\\)/\\1\\2/'`\n\n    # Get the remainder in\
    \ base 10\n    local remainder_10=`echo $remainder | sed 's/\\([0-9]*\\)\\([a-zA-Z]*\\\
    )/\\1\\2/'`\n    local roman=\"\"\n\n    # Get the roman numeral for this remainder.\n\
    \    while [ $remainder_10 -le 100 ] ; do\n        roman=\"$(echo $roman \"i\"\
    )\"\n        remainder_10=`echo $remainder_10*10`\n    done\n\n    # Add the remainder\
    \ to the remainder in base 10\n    roman=\"$(echo $roman \"k\")\"\n\n    # Add\
    \ the remainder to the remainder in base 10\n    roman=\"$(echo $roman \"$remainder_10\"\
    )\"\n    roman=\"$(echo $roman | sed 's/^.*/m')\"\n\n    # Add the remaining dec\
    \ digits to the remaining remainder in base 10\n    roman=\"$(echo $roman \"m$dec\"\
    )\"\n    roman=\"$(echo $roman | sed 's/^.*/m')\"\n\n    # Add the remaining remainder\
    \ digits to the remaining remainder in base 10\n    roman=\"$(echo $roman \"$remainder\"\
    )\"\n    roman=\"$(echo $roman | sed 's/^.*/m')\"\n\n    # Add the remaining remainder\
    \ digits to the remaining remainder in base 10\n    roman=\"$(echo $roman \"$remainder_dec\"\
    )\"\n    roman=\"$(echo $roman | sed 's/^.*/m')\"\n\n    # Add the ", "  local\
    \ num=\"$1\"\n  if [[ \"$num\" =~ ^[0-9]+$ ]]; then\n    local n\n    local roman\n\
    \    local romanstr\n    n=0\n    roman=\"\"\n    while [ $n -lt $((num-1)) ];\
    \ do\n      romanstr=\"$roman $(( 100*$n + $(echo $(( $((num%10)) )) ))\"\n  \
    \    roman=\"${romanstr%?}\"\n      ((n++))\n    done\n    if [[ \"$num\" =~ ^[0-9]+$\
    \ && $roman ]]; then\n      echo \"$roman\"\n    else\n      echo \"$num\"\n \
    \   fi\n  else\n    echo \"$1\"\n  fi", "  # If num is 1, then return 'x'\n  if\
    \ [ $1 == 1 ]; then\n    echo \"x\"\n    return\n  fi\n  # If num is 2, return\
    \ 'i'\n  if [ $1 == 2 ]; then\n    echo \"i\"\n    return\n  fi\n  # If num is\
    \ 3, return 'i'\n  if [ $1 == 3 ]; then\n    echo \"ii\"\n    return\n  fi\n \
    \ # If num is 4, return 'iii'\n  if [ $1 == 4 ]; then\n    echo \"iii\"\n    return\n\
    \  fi\n  # If num is 5, return 'iv'\n  if [ $1 == 5 ]; then\n    echo \"iv\"\n\
    \    return\n  fi\n  # If num is 6, return 'v'\n  if [ $1 == 6 ]; then\n    echo\
    \ \"v\"\n    return\n  fi\n  # If num is 7, return 'vi'\n  if [ $1 == 7 ]; then\n\
    \    echo \"vi\"\n    return\n  fi\n  # If num is 8, return 'vii'\n  if [ $1 ==\
    \ 8 ]; then\n    echo \"vii\"\n    return\n  fi\n  # If num is 9, return 'ix'\n\
    \  if [ $1 == 9 ]; then\n    echo \"ix\"\n    return\n  fi\n  # If num is 10,\
    \ return 'xix'\n  if [ $1 == 10 ]; then\n    echo \"xix\"\n    return\n  fi\n\
    \  # If num is 11, return 'xix'\n  if [ $1 == 11 ]; then\n    echo \"xix\"\n \
    \   return\n  fi\n  # If num is 12, return 'xx'\n  if [ $1 == 12 ]; then\n   \
    \ echo \"xx\"\n    return\n  fi\n  # If num is 13, return 'xc'\n  if [ $1 == 13\
    \ ]; then\n    echo \"xc\"\n    return\n  fi\n  # If num is 14, return 'cd'\n\
    \  if [ $1 == 14 ]; then\n    echo \"cd\"\n    return\n  fi\n  # If num is 15,\
    \ return 'd'\n  if [ $1 == 15 ]; then\n    echo \"d\"\n    return\n  fi\n  # If\
    \ num is 16, return 'dc'\n  if [ $1 == 16 ]; then\n    echo \"dc\"\n    return\n\
    \  fi\n  # If num is 17, return 'cm'\n  if [ $1 == 17 ]; then\n    echo \"cm\"\
    \n    return\n  fi\n  # If num is 18, return 'm'\n  if [ $1 == 18 ]; then\n  \
    \  echo \"m\"\n    return\n  fi\n  # If num is 19, return 'mc'\n  if [ $1 == 19\
    \ ]; then\n    echo \"mc\"\n    return\n  fi\n  # If num is 20, return 'd'\n \
    \ if [ $1 == 20 ]; then\n    echo \"d\"\n    return\n  fi\n  # If num is 21, return\
    \ 'dc'\n  if [ $", "  local NUM\n  NUM=$1\n  if [ $NUM -gt 1000 ] || [ $NUM -eq\
    \ 0 ]; then\n    echo \"Error! The number is not positive.\"\n    return\n  fi\n\
    \  local PREFIX\n  PREFIX=\"\"\n  local SUFFIX\n  SUFFIX=\"i\"\n  local ROMAN\n\
    \  ROMAN=\"i\"\n  local DIGIT\n  local TEMP\n  TEMP=\"0\"\n  while [ \"$TEMP\"\
    \ -lt \"$NUM\" ]\n  do\n    DIGIT=$(echo $TEMP | bc)\n    TEMP=$(( $TEMP + $DIGIT\
    \ ))\n    ROMAN=\"$ROMAN$(($DIGIT - 10)) \"\n  done\n  echo $ROMAN", "    local\
    \ num=$1\n    local roman=\"\"\n    local roman_num=\"\"\n    local roman_num_count=0\n\
    \    local roman_num_index=0\n    local roman_num_length=0\n    local roman_num_index2=0\n\
    \    local roman_num_index3=0\n    local roman_num_length2=0\n    local roman_num_index4=0\n\
    \    local roman_num_length3=0\n    local roman_num_index5=0\n    local roman_num_length4=0\n\
    \    local roman_num_index6=0\n    local roman_num_length5=0\n\n    if [ $num\
    \ -eq 0 ]; then\n        echo \"0\"\n    elif [ $num -eq 1 ]; then\n        roman=\"\
    x\"\n    elif [ $num -gt 1 ] && [ $num -le 3 ]; then\n        roman_num=$(roman_to_dec\
    \ $(int_to_roman_1 $num))\n        roman_num_index=$(( $(echo $roman | wc -c)\
    \ - 1))\n        roman_num_length=$(( $(echo $roman | wc -c) - roman_num_index))\n\
    \        roman_num_index=$(( $(echo $roman | wc -c) - 1))\n        roman_num_length=$((\
    \ $(echo $roman | wc -c) - roman_num_index))\n        roman_num_index=$(( $(echo\
    \ $roman | wc -c) - 1))\n        roman_num_length=$(( $(echo $roman | wc -c) -\
    \ roman_num_index))\n        roman_num_index=$(( $(echo $roman | wc -c) - 1))\n\
    \        roman_num_length=$(( $(echo $roman | wc -c) - roman_num_index))\n   \
    \     roman_num_index=$(( $(echo $roman | wc -c) - 1))\n        roman_num_length=$((\
    \ $(echo $roman | wc -c) - roman_num_index))\n        roman_num_index=$(( $(echo\
    \ $roman | wc -c) - 1))\n        roman_num_length=$(( $(echo $roman | wc -c) -\
    \ roman_num_index))\n        roman_num_index=$(( $(echo $roman | wc -c) - 1))\n\
    \        roman_num_length=$(( $(echo $roman | wc -c) - roman_num_index))\n   \
    \     roman_num_index=$(( $(echo $roman | wc -c) - 1))\n        roman_num_length=$((\
    \ $(echo $roman ", "\tlocal num=$1\n\t# Return an empty string if there are no\
    \ digits.\n\t[ ${#num} -eq 0 ] && return 0\n\t# The string will be comprised of\
    \ the integer's digits and lowercase roman numerals.\n\tlocal num_str=$(printf\
    \ \"%${num}d\")\n\t# The number will be converted from base-10 integer format\
    \ to base-62 character format.\n\tlocal roman_str=\"\"\n\tlocal roman_char_str=\"\
    \"\n\tlocal digit=1\n\twhile [ \"${digit}\" -le 6 ]; do\n\t\troman_str=\"${roman_str}${roman_char_str}\"\
    \n\t\troman_char_str=$(printf \"%d%c\" \"${num}\" \"m\")\n\t\tdigit=$(( ${digit}\
    \ + 1 ))\n\tdone\n\t# Cut the extra leading \"m\" in our string.\n\troman_str=\"\
    ${roman_str%m}\"\n\techo \"${roman_str}\"", "  # Initialize a variable named roman_string\
    \ with the default roman\n  # numeral value of an empty string.\n  roman_string=\"\
    \"\n\n  # Initialize a variable named last_numeral with its default value\n  #\
    \ of 0.\n  last_numeral=0\n\n  # Assign the argument $1 to the variable $arg1.\n\
    \  arg1=$1\n\n  # If the argument is not an integer,\n  # print a message and\
    \ return an error to the shell.\n  expr $1 \\> \\> \\> \\> \\> \\> \\> \\> \\\
    > \\> \\> \\> \\> \\> \\> \\> \\> \\> \\> \\> \\> \\> \\>\n  echo $'Usage: $(basename\
    \ $0) INTEGER\\n' \\\n    'Where: INTEGER is a positive integer\\n' \\\n    'Example:\
    \ $(basename $0) 12\\n'\n  exit 1", "  num=${1:-999}\n  num=$((num/10))\n  res=\"\
    X\"\n  while [ $num -lt 10 ]; do\n    num=$((num+1))\n    res=\"$re${res}\"\n\
    \  done\n  echo -n \"$res${res%%?}\"", "    num=${1:--1}\n    mini_roman=\"\"\n\
    \n    int_to_roman() {\n        int_str=$1\n        int_str_roman=\"\"\n     \
    \   int_str_roman += ${#int_str} + \" \"\n\n        remainder=$((num % 10))\n\
    \        int_str_roman += ${#remainder}\n        int_str_roman += ${remainder}\n\
    \        num=$((num / 10))\n    }\n\n    int_to_roman \"$num\"\n    mini_roman=${mini_roman:1}\n\
    \    int_to_roman \"$num\"\n    mini_roman=${mini_roman:0:(${#mini_roman}-1)}\n\
    \    int_to_roman \"$num\"\n    mini_roman=${mini_roman:0:(${#mini_roman}-1)}\n\
    \    int_to_roman \"$num\"\n    mini_roman=${mini_roman:0:(${#mini_roman}-1)}\n\
    \    int_to_roman \"$num\"\n    mini_roman=${mini_roman:0:(${#mini_roman}-1)}\n\
    \    int_to_roman \"$num\"\n    mini_roman=${mini_roman:0:(${#mini_roman}-1)}\n\
    \    int_to_roman \"$num\"\n\n    echo \"$mini_roman\"", "  if [ $1 -gt 1 ]; then\n\
    \    echo \"$1\"\n  else\n    echo \"$1\"\n  fi\n\n  local NUM\n  NUM=\"$1\"\n\
    \n  local DENOM\n  DENOM=\"xix\"\n\n  local ROMANS\n  ROMANS=\"cx\"\n\n  while\
    \ [ \"$NUM\" -gt 1 ];\n  do\n    local N=`expr $NUM - 2`\n    local M=`expr $NUM\
    \ - 1`\n    DENOM=\"${DENOM}${ROMANS}${ROMANS}\"\n    ROMANS=\"${ROMANS}i\"\n\
    \    NUM=\"$N\"\n  done\n\n  echo \"${DENOM}\"", "    local i num\n    for i in\
    \ $(seq 0 $(($(($1 - 1))))); do\n        num=$(($i * 1000))\n        if [[ $(is_integer\
    \ \"$num\") ]]; then\n            echo $(mini_roman $num)\n            return\n\
    \        fi\n    done\n    echo \"$num\"", "  echo $(expr $1 % 1000)\n  $(expr\
    \ $(expr $1 % 1000) \\* 100)\n  $(expr $(expr $1 % 1000) \\* 10)\n  $(expr $(expr\
    \ $1 % 10) \\* 1)", "  local int_num=$1\n  local roman num_roman num_roman_chars\n\
    \  local i roman_string roman num_roman num_roman_chars char\n  roman_string=()\n\
    \  num_roman_chars=$(( (${#int_num}+1)/2 ))\n  num_roman=$(( (${#int_num}+3)/2\
    \ ))\n  # First character is always \"I\"\n  roman_string+=( \"I\" )\n  roman_string+=(\
    \ \"X\" )\n  roman_string+=( \"L\" )\n  roman_string+=( \"C\" )\n  roman_string+=(\
    \ \"D\" )\n  roman_string+=( \"M\" )\n  roman_string+=( \"V\" )\n  roman_string+=(\
    \ \"I\" )\n  # Iterate over remaining chars, ignoring first and last, since we\
    \ treat them specially\n  for (( i=1; i<num_roman_chars; i++ )); do\n    roman+=(\
    \ ${roman_string[$((i+2))]} )\n    roman+=( ${roman_string[$((i+1))]} )\n  done\n\
    \  # Remove duplicate roman chars, keeping only the first one\n  roman=( ${roman[@]:0:1}\
    \ )\n  roman=( ${roman[@]/$((${#roman[@]}/2))/1} )\n  roman=( ${roman[@]} )  #\
    \ remove duplicates\n  # Convert to lowercase\n  roman=( ${roman[@]} )\n  roman=(\
    \ ${roman[@]/i/ } )  # Remove \"I\" from the beginning\n  roman=( ${roman[@]}\
    \ )\n  roman=( ${roman[@]/L/ } )  # Remove \"L\" from the beginning\n  roman=(\
    \ ${roman[@]} )\n  roman=( ${roman[@]/D/ } )  # Remove \"D\" from the beginning\n\
    \  roman=( ${roman[@]} )\n  roman=( ${roman[@]/M/ } )  # Remove \"M\" from the\
    \ beginning\n  roman=( ${roman[@]} )\n  roman=( ${roman[@]/V/ } )  # Remove \"\
    V\" from the beginning\n  roman=( ${roman[@]} )\n  # Put roman chars back together,\
    \ with space separating the chars\n  roman=( ${roman[@]}${roman[@", "    local\
    \ num=\"$1\"\n    shift\n    local numerals=$(seq 1 ${#})\n    local mini_roman=\"\
    \"\n    local roman\n    local i\n    local length\n\n    length=$(expr ${#num})\n\
    \n    # Convert to decimal and remove non-roman numerals\n    for (( i=1; i<=${length};\
    \ i++ )); do\n        roman=$(echo \"${numerals[i]}\" | tr -d \"[:digit:]\")\n\
    \        mini_roman+=\"$(echo \"${roman}\" | tr -d \"[:alpha:]\")\"\n    done\n\
    \n    # Replace roman numerals with their corresponding \"minim\" ones\n    for\
    \ (( i=2; i<=${length}; i++ )); do\n        roman=$(echo \"${numerals[i]}\" |\
    \ tr -d \"[:digit:]\")\n        mini_roman+=\"$(echo \"${roman}\" | tr -d \"[:alpha:]\"\
    )\"\n    done\n\n    # Convert minims to integers and add them\n    mini_roman+=\"\
    $(echo \"${mini_roman}\" | tr -d \"[:digit:]\")\"\n    echo \"${mini_roman}\"",
  "  # We need a number that's a multiple of 3 for it to make sense\n  if [ $1 -lt\
    \ 1 ] || [ $1 -gt 1000 ]; then\n    echo \"Error! Given num ($1) must be between\
    \ 1 and 1000.\"\n    return 1\n  fi\n\n  # Use this array to find the largest\
    \ possible value of numeral that will\n  # convert back to $1\n  numerals=(\n\
    \    I\n    II\n    III\n    IV\n    V\n    VI\n    VII\n    VIII\n    IX\n  \
    \  X\n    XX\n    XXX\n  )\n\n  # This loop will append numerals to result until\
    \ $1 is reached.\n  result=\"\"\n  while [ $1 -gt 0 ]; do\n    # Find largest\
    \ possible value for numeral that converts back to $1\n    numeral=${numerals[$(($numerals[*]|\
    \ wc -l))]}\n\n    # Convert to mini-roman numeral\n    roman=`echo $numeral |\
    \ sed -e 's/\\(..\\)/\\L\\1/'`\n\n    # Append mini-roman numeral to result\n\
    \    result=$result$roman\n    shift\n\n    # If we added any numerals, remove\
    \ them from our array (since we're only\n    # using the largest value)\n    while\
    \ [ $1 -gt 0 ] && [ $1 -lt 1000 ]; then\n      numerals=(${numerals[@]%?})\n \
    \     shift\n    done\n  done\n  echo \"$result\"", "  local num=$1 digits=$2\n\
    \  case $num in\n    1|[1-9])\n      echo \"$num\"\n      ;;\n    *)\n      #\
    \ find the max number of digits\n      local max_digits=$(python -c 'print \"\
    9\" * \"$2\" | sort -n | head -1')\n      # create a string with as many '0' digits\
    \ as needed (max_digits)\n      local leading_zeros=$(python -c 'print \"0\"*\"\
    $max_digits\"')\n      local mini_roman=\"\"\n      # print each 'digit' of the\
    \ roman numeral string in reverse\n      while [ $num -gt 0 ]; do\n        local\
    \ digit=$(( $num % 10 ))\n        mini_roman+=\"$(int_to_mini_roman $digit $max_digits)\"\
    \n        num=$(echo $(( $num / 10 )) | bc)\n      done\n      # add leading zeros\
    \ (max_digits) to mini_roman\n      while [ $digits -gt 0 ]; do\n        local\
    \ leading_zero=$(python -c 'print \"0\"*\"$digits\"')\n        mini_roman+=\"\
    $leading_zero\"\n        digits=$(expr ${#mini_roman} - 1)\n      done\n     \
    \ # add mini_roman to leading zeros, and return\n      echo \"$mini_roman\"\n\
    \      ;;\n  esac", "    local num=\"$1\"\n    local i\n    local rom\n    local\
    \ romchars\n    local numchars\n    local minirom\n    local minicrom\n    local\
    \ minicromchars\n    local mininum\n    local mininumchars\n    local i\n    for\
    \ i in {1..100}; do\n        minicromchars=\"$(python -c \"print('$i')\"|sed \"\
    s/.//g\")\"\n        miniromchars=\"$(python -c \"print('$i')\"|sed \"s/.//g\"\
    )\"\n        romchars=\"$(python -c \"print('$i')\"|sed \"s/$minicromchars//g\"\
    )\"\n        numchars=\"$(python -c \"print('$i')\"|sed \"s/$miniromchars//g\"\
    )\"\n        mininum=\"$(python -c \"print('$i')\"|sed \"s/$numchars//g\")\"\n\
    \        mininumchars=\"$(python -c \"print('$i')\"|sed \"s/$numchars//g\")\"\n\
    \        minirom=\"$(python -c \"print('$i')\"|sed \"s/$mininum//g\")\"\n    \
    \    minicrom=\"$(python -c \"print('$i')\"|sed \"s/$mininumchars//g\")\"\n  \
    \      rom=\"$(python -c \"print('$i')\"|sed \"s/$minicrom//g\")\"\n        if\
    \ [ \"$minirom\" == \"$num\" ] || [ \"$mininum\" == \"$num\" ]; then\n       \
    \     mininum=\"$rom\"\n        fi\n    done\n    echo $mininum", "  # Write your\
    \ function here\n  local -n args=( \"$@\" )\n  echo \"${args[@]}\"", "  local\
    \ i roman_num\n  roman_num=$1\n  i=1\n  while [ $i -lt $roman_num ]; do\n    roman_num=$roman_num$i\n\
    \    let i++\n  done\n  echo ${roman_num}", "  local number=$1\n\n  # Get the\
    \ largest integer <= number that does not exceed 1000 as an integer.\n  local\
    \ max=1\n  while [ $max -le 1000 ]; do\n    max=`expr $max + 1`\n  done\n\n  #\
    \ Get the number of times the loop will run over the whole range.\n  local num=0\n\
    \  while [ $number -le $max ]; do\n    num=`expr $num + 1`\n    num=`expr $num\
    \ - 1`\n\n    # Get the remainder of the division.\n    local remainder=$(( number\
    \ % 10 ))\n\n    # Only add if remainder > 'I'.\n    if [ $remainder -gt 'I' ];\
    \ then\n      echo \"$remainder\"\n      return\n    fi\n\n    # Move the number\
    \ to the left by one place to move the roman numeral left.\n    number=`expr $number\
    \ / 10`\n  done\n\n  echo \"\"", "  if [[ \"$1\" -le 1 || \"$1\" -gt 1000 ]];\
    \ then\n    echo \"Error: the argument must be an integer between 1 and 1000\"\
    \n    exit 1\n  fi\n\n  ROMAN=\"0\"\n  while [ \"$1\" -gt 1 ]; do\n    ROMAN=\"\
    $ROMAN$1\"\n    echo \"$ROMAN\" | awk '{print toupper($0)}'\n    shift\n  done\n\
    \  ROMAN=\"${ROMAN#0}\" # remove leading zero\n  echo \"$ROMAN\"", "  local num=$1\n\
    \  local str=\"\"\n  if [ \"$num\" -lt 1 -o \"$num\" -gt 1000 ]; then\n    return\
    \ 0\n  fi\n  local digit=$(echo \"$num / 100\" | bc)\n  local last_digit=$(echo\
    \ \"$num % 100\" | bc)\n  local tmp_num=$(($num - $digit*100 - $last_digit))\n\
    \  local tmp_str=\"\"\n  while [ $tmp_num -lt 1 ]; do\n    tmp_str=\"$tmp_strc\"\
    \n    tmp_num=$(($tmp_num + $digit))\n  done\n  local tmp_strc=\"\"\n  local i=$((${#tmp_str}-1))\n\
    \  while [ $i -ne 0 ]; do\n    tmp_strc=\"$tmp_str$((${tmp_str:i:1}*100 + $last_digit))\"\
    \n    tmp_num=$((${tmp_num} - $digit*100))\n    i=$((${#tmp_str}-1))\n  done\n\
    \  str=\"$tmp_str$tmp_strc\"\n  echo ${str:0:1}", "    local num=$1\n    local\
    \ roman=\"\"\n    if [[ $num -gt 0 && $num -le 1000 ]]; then\n        local maxlen=$(echo\
    \ \"$((num+1))\" | bc)\n        local base=\"i\"\n        for (( i=1; i<=maxlen;\
    \ i++ )); do\n            local tmp=${base}\n            if [[ \"$num\" -gt $((i*1000))\
    \ ]]; then\n                tmp=${tmp}m\n            fi\n            if [[ \"\
    $num\" -le $((i*1000)) ]]; then\n                tmp=${tmp}c\n            fi\n\
    \            roman=\"${roman}$tmp\"\n        done\n        echo \"$roman\"\n \
    \   else\n        echo \"error: invalid input ($num)\"\n    fi", "    if [[ $1\
    \ =~ ([0-9]+) ]]\n    then\n        local digits=${BASH_REMATCH[1]}\n        local\
    \ mini_roman=\"\"\n        local count=0\n        while [[ $1 -gt 0 ]]\n     \
    \   do\n            ((count++))\n            (( 1 << (${#digits} - $count) ))\n\
    \        done\n        while [[ $count -gt 0 ]]\n        do\n            (( ${#mini_roman}\
    \ -= 1 ))\n            mini_roman+=\"M\"\n        done\n        while [[ $count\
    \ -gt 0 ]]\n        do\n            (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"\
    CM\"\n        done\n        while [[ $count -gt 0 ]]\n        do\n           \
    \ (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"D\"\n        done\n   \
    \     while [[ $count -gt 0 ]]\n        do\n            (( ${#mini_roman} -= 1\
    \ ))\n            mini_roman+=\"CD\"\n        done\n        while [[ $count -gt\
    \ 0 ]]\n        do\n            (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"\
    C\"\n        done\n        while [[ $count -gt 0 ]]\n        do\n            ((\
    \ ${#mini_roman} -= 1 ))\n            mini_roman+=\"XC\"\n        done\n     \
    \   while [[ $count -gt 0 ]]\n        do\n            (( ${#mini_roman} -= 1 ))\n\
    \            mini_roman+=\"L\"\n        done\n        while [[ $count -gt 0 ]]\n\
    \        do\n            (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"\
    XL\"\n        done\n        while [[ $count -gt 0 ]]\n        do\n           \
    \ (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"X\"\n        done\n   \
    \     while [[ $count -gt 0 ]]\n        do\n            (( ${#mini_roman} -= 1\
    \ ))\n            mini_roman+=\"IX\"\n        done\n        while [[ $count -gt\
    \ 0 ]]\n        do\n            (( ${#mini_roman} -= 1 ))\n            mini_roman+=\"\
    V\"\n        done\n        while [[ $count -gt 0 ]]\n        do\n            ((\
    \ ${#mini_roman", "  local num=\"$1\"\n  local roman=\"\"\n  local i\n  local\
    \ l\n  local num_str=$(to_string \"$num\")\n\n  for ((i = 1; i <= 1000; i++ ))\n\
    \  do\n    roman+=\"$(mini_to_roman_num \"$i\")\"\n  done\n  echo \"$roman\" |\
    \ tr ' ' '-'", "\troman_num=\"$( echo \"$1\"|awk '{print toupper($1) \"I\"}'|sed\
    \ -r \"s/^([1-9])/MI/g;s/(M{0,2}I{0,3})/MI/g;s/(M{0,2}I{0,3})/XI/g;s/(M{0,3}I{0,3})/II/g;s/(M{0,3}I{0,3})/III/g;s/(M{0,4}I{0,4})/IV/g;s/(M{0,4}I{0,4})/V/g;s/(M{0,4}I{0,4})/VI/g;s/(M{0,5}I{0,5})/VII/g;s/(M{0,5}I{0,5})/VIII/g;s/(M{0,5}I{0,5})/IX/g;s/(M{0,6}I{0,6})/XII/g;s/(M{0,6}I{0,6})/XIII/g;s/(M{0,6}I{0,6})/XIV/g;s/(M{0,7}I{0,7})/XIX/g;s/(M{0,7}I{0,7})/XIX/g;s/(M{0,8}I{0,8})/XIII/g;s/(M{0,8}I{0,8})/XIVI/g;s/(M{0,9}I{0,9})/XIII/g;s/(M{0,9}I{0,9})/XIIIV/g;s/(M{0,9}I{0,9})/XIVIV/g;s/(M{0,9}I{0,9})/XVIII/g;s/(M{0,9}I{0,9})/XVIIIV/g;s/(M{0,9}I{0,9})/XVIIV/g;s/(M{0,9}I{0,9})/XXIII/g;s/(M{0,9}I{0,9})/XXIIIV/g;s/(M{0,9}I{0,9})/XXIIV/g;s/(M{0,9}I{0,9})/XIII/g;s/(M{0,9}I{0,9})/XIIIV/g;s/(M{0,9}I{0,9})/XIIV/g;",
  "  local numeral=$1\n  local roman=\"\"\n  if [ $numeral -eq 0 ]; then\n    return\
    \ \"\"\n  fi\n  if [ $numeral -lt 0 ]; then\n    echo \"Error! Input must be positive.\"\
    \ 1>&2\n    return 1\n  fi\n  if [ $numeral -ge 1000 ]; then\n    echo \"Error!\
    \ Input must be less than 1000.\" 1>&2\n    return 1\n  fi\n\n  numeral=$((numeral\
    \ - 48))\n  while [ $numeral -gt 0 ]; do\n    if [ $numeral -eq 3 ]; then\n  \
    \    roman=\"${roman}x\"\n    elif [ $numeral -eq 4 ]; then\n      roman=\"${roman}i\"\
    \n    elif [ $numeral -eq 5 ]; then\n      roman=\"${roman}ii\"\n    elif [ $numeral\
    \ -eq 6 ]; then\n      roman=\"${roman}iii\"\n    elif [ $numeral -eq 7 ]; then\n\
    \      roman=\"${roman}iv\"\n    elif [ $numeral -eq 8 ]; then\n      roman=\"\
    ${roman}v\"\n    elif [ $numeral -eq 9 ]; then\n      roman=\"${roman}vi\"\n \
    \   elif [ $numeral -eq 10 ]; then\n      roman=\"${roman}vii\"\n    elif [ $numeral\
    \ -eq 11 ]; then\n      roman=\"${roman}viii\"\n    elif [ $numeral -eq 12 ];\
    \ then\n      roman=\"${roman}ix\"\n    elif [ $numeral -eq 13 ]; then\n     \
    \ roman=\"${roman}xii\"\n    elif [ $numeral -eq 14 ]; then\n      roman=\"${roman}xiii\"\
    \n    elif [ $numeral -eq 15 ]; then\n      roman=\"${roman}xiv\"\n    elif [\
    \ $numeral -eq 16 ]; then\n      roman=\"${roman}xvi\"\n    elif [ $numeral -eq\
    \ 17 ]; then\n      roman=\"${roman}xvii\"\n    elif [ $numeral -eq 18 ]; then\n\
    \      roman=\"${roman}xviii\"\n    elif [ $numeral -eq 19 ]; then\n      roman=\"\
    ${roman}xix\"\n    elif [ $numeral -eq 20 ]; then\n      roman=\"${roman}xxi\"\
    \n    elif [ $numeral -eq 21 ]; then\n      roman=\"${roman}xxii\"\n    elif [\
    \ $numeral -eq 22 ]; then\n      ro", "  if [ \"$1\" -gt 1 ] ; then echo \"$1\"\
    \ ; return 1; fi\n  local i\n  i=\"$1\"\n  i=\"${i//[^a-zA-Z]}\"\n  while (( $(\
    \ echo \"$i % 1000\" | bc ) )) ; do\n    (( i-- ))\n    i=\"$(( i % 1000 ))\"\n\
    \  done\n  echo \"$(( $i % 1000 ))$(( i / 1000 % 10 ))\""]
stop_tokens:
- "\n}"
