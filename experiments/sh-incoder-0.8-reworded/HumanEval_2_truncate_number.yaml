name: HumanEval_2_truncate_number
language: sh
prompt: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
  \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
  # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
  # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
  \ {\n"
tests: "}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
  \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
completions: ["    local num=\"$1\"\n    # remove everything but digits\n    local\
    \ trimmed=\"${num//[^0-9.]}\"\n    # keep only digits until decimal point\n  \
    \  local decomposed_num=\"${trimmed%.*}\"\n    # trim decimal point\n    local\
    \ trimmed_decimal=\"${decomposed_num#*.}\"\n    # return result (decimal part)\n\
    \    echo \"$trimmed_decimal\"", "  local number=\"$1\"\n  local dec=\"$2\"\n\
    \  local part=\"$3\"\n  local remainder=\"$4\"\n  local decimal=\"$5\"\n\n  local\
    \ ipart=\"$(( ($number / $dec) + 1 ))\"\n  local idec=\"$(( ${ipart} * $dec ))\"\
    \n  local i=\"${ipart}\"\n  (( $dec == 0 )) && i=\"$(( $number + 1))\"\n\n  ((\
    \ idec > dec )) && decimal=0\n  (( idec < dec )) && decimal=1\n\n  if [ \"$i\"\
    \ == \"$number\" ]; then\n    dec=$idec\n    part=$ipart\n    remainder=$number\n\
    \  else\n    (( $dec == 1 )) && decimal=$(( $dec * $ipart ))\n    (( $decimal\
    \ == 0 )) && decimal=1\n    (( $part > 1 )) && decimal=$(( ${decimal} * $part\
    \ ))\n  fi\n\n  (( $decimal > 0 )) && decimal=$(( ${decimal} - 1 ))\n\n  echo\
    \ \"$decimal\"", "\techo \"$1\" | awk '{\n\t\tn=$1;\n\t\te=0;\n\t\ts=\"\";\n\t\
    \twhile(n < 10) {\n\t\t\tn = n + $1;\n\t\t\ts = sprintf(\"%010d\", n%1)\n\t\t\
    }\n\t\tfor(;;) {\n\t\t\tn = 10;\n\t\t\twhile(n <= n) {\n\t\t\t\tn = n * 10;\n\t\
    \t\t\te = e + 1;\n\t\t\t}\n\t\t\ts = sprintf(\"%010d\", n%1) + s;\n\t\t\tif (e\
    \ == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tprint s;\n\t}'", "  local varname=$1\n  local\
    \ number=${!varname}\n  local decimals=${2:-0}\n  local part\n  local sign\n \
    \ local decimal\n  local tmp\n  local i\n  local imax\n  local imin\n  local rval\n\
    \  \n  if [ $decimals -eq 0 ]; then\n    rval=$number\n  elif [ $decimals -gt\
    \ 1 ]; then\n    # Handle rounding towards zero\n    if [ $number -eq 0 ]; then\n\
    \      decimals=0\n    elif [ $number -gt 0 ]; then\n      # Handle negative numbers\n\
    \      number=$((-number))\n      decimals=0\n      sign=\"-\"\n    fi\n  \n \
    \   # Divide the number into parts of size 10\n    for ((imax=${#number} - ${decimals};\
    \ imax >= 0; imax--)); do\n      part=${number:$imax:${#number}}\n      ((imax=imax\
    \ - 1))\n      if [ \"$part\" != \"\" ]; then\n        decimal=$((10#${part}))\n\
    \        break\n      fi\n    done\n    part=${number:0:$imax}\n    decimal=$((10#${part}))\n\
    \    decimals=${decimal}\n  else\n    # Handle rounding to nearest\n    decimal=10#${number:0:${#number}}\n\
    \    decimals=${decimal}\n  fi\n  \n  # Handle rounding up/down\n  if [ $decimals\
    \ -gt $decimal ]; then\n    decimal=$((10#${number:0:${#number}}))\n  fi\n  \n\
    \  # Handle negative numbers\n  if [ $sign != \"-\" ]; then\n    sign=\"+\"\n\
    \  fi\n  \n  tmp=$(truncate_number2 \"$number\" \"$decimal\" \"$decimals\" \"\
    $sign\")\n  rval=$tmp\n  \n  return $rval", "  local number=$1\n  local integer_part=$((${number%.*}))\n\
    \  local decimal_part=${number#*.}\n  \n  \n  if (( ${integer_part} > ${number}\
    \ )); then\n    decimal_part=$((${decimal_part}+1))\n  fi\n  \n  printf \"%0.*f\"\
    \ \"${#decimal_part}\" \"$decimal_part\"", "\tlocal FLOAT=$1\n\tlocal INTEGER\n\
    \tlocal DECIMALS\n\tlocal RESULT\n\tlocal POWER\n\n\t# Break it into integer and\
    \ decimals\n\tINTEGER=$(echo $FLOAT | cut -d '.' -f 1)\n\tDECIMALS=$(echo $FLOAT\
    \ | cut -d '.' -f 2)\n\n\t# Check if there should be decimal places\n\tif [ \"\
    $DECIMALS\" != \"0\" ] ; then\n\t\tDECIMALS=\".${DECIMALS}\"\n\tfi\n\n\t# If there\
    \ are more than 2 decimals, truncate to integer\n\tif [ \"$DECIMALS\" != \".\"\
    \ ] && [ \"$DECIMALS\" != \"\" ] ; then\n\t\tRESULT=$FLOAT\n\telse\n\t\t# Round\
    \ up to the nearest integer\n\t\tRESULT=$(echo \"$INTEGER + $DECIMALS\" | bc -l)\n\
    \tfi\n\t\n\t# Re-add decimal places to ensure we have only integer\n\tRESULT=$(echo\
    \ \"$RESULT$DECIMALS\" | bc -l)\n\n\t# Remove excess decimals\n\tRESULT=$(echo\
    \ \"$RESULT\" | cut -d '.' -f 1-$DECIMALS)\n\n\t# Return it\n\techo $RESULT",
  "    local number=$1\n    local integer\n    local decimal\n\n    # First we check\
    \ that the number is integer\n    if [[ $number =~ ^[0-9]+$ ]]; then\n       \
    \ integer=$(echo \"$number\" | cut -f 1 -d \".\")\n        decimal=$(echo \"$number\"\
    \ | cut -f 2 -d \".\")\n    elif [[ $number =~ ^[0-9]+\\.[0-9]+$ ]]; then\n  \
    \      integer=$(echo \"$number\" | cut -f 1 -d \".\")\n        decimal=$(echo\
    \ \"$number\" | cut -f 2 -d \".\")\n    elif [[ $number =~ ^[0-9]+\\.[0-9]+\\\
    .[0-9]+$ ]]; then\n        integer=$(echo \"$number\" | cut -f 1 -d \".\")\n \
    \       decimal=$(echo \"$number\" | cut -f 2 -d \".\")\n    elif [[ $number =~\
    \ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        integer=$(echo \"$number\"\
    \ | cut -f 1 -d \".\")\n        decimal=$(echo \"$number\" | cut -f 2 -d \".\"\
    )\n    else\n        integer=0\n        decimal=0\n    fi\n\n    # Check if integer\
    \ is bigger than the given number\n    if [[ $integer -gt $1 ]]; then\n      \
    \  integer=$1\n        decimal=0\n    fi\n\n    # Return the decimal part of the\
    \ number\n    echo \"$decimal\"", "    local input_value\n    local output_value\n\
    \n    input_value=${1}\n\n    case \"${input_value}\" in\n        [0-9]*)\n  \
    \          output_value=$(echo \"${input_value}\" | awk '{printf \"%.${BASH_REMATCH}f\"\
    , $1/10}')\n            ;;\n        *)\n            output_value=\"${input_value}\"\
    \n            ;;\n    esac\n\n    echo \"${output_value}\"", "  local number=$1\n\
    \  local number_part=0\n  local decimals=0\n  if [[ \"$number\" =~ ^-?[0-9]+\\\
    .[0-9]*$ ]]; then\n    number_part=`echo \"$number\" | awk '{printf \"%.0f\\n\"\
    , $1}'`\n    decimals=`echo \"$number\" | awk '{printf \".%.0f\\n\", $1}'`\n \
    \ else\n    number_part=`echo \"$number\" | awk '{printf \"%.0f\\n\", $1}'`\n\
    \    decimals=0\n  fi\n\n  local trunc_part\n\n  trunc_part=`echo \"$number_part\"\
    \ | awk '{printf \"%.0f\", $1}'`\n  echo \"${trunc_part:0:$decimals}\"", "\techo\
    \ \"$(python -c 'import fractions; print fractions.Fraction(\"$1\")')\"", "  echo\
    \ $1 | awk -F. '{printf \"%.1f\\n\", $1}'", "\t# Assumptions:\n\t# - number has\
    \ only 2 decimals\n\t# - decimal part always smaller than 1\n\n\t# Split number\
    \ into integer and decimal part\n\tlocal -a integer\n\tlocal -a decimal\n\tlocal\
    \ -a remainder\n\tinteger =( $1 )\n\tdecimal=$(( ${integer[1]}${integer[2]}${integer[3]}${integer[4]}\
    \ ))\n\tremainder=$(( ${integer[0]}${integer[1]}${integer[2]}${integer[3]}${integer[4]}\
    \ ))\n\n\t# Return decimal part of the number\n\techo \"${decimal}\"", "    if\
    \ [ -z \"$1\" ]; then\n        return 0;\n    fi\n    local number=\"$1\"\n  \
    \  local integer=\"$((number * 1000))\"\n    local decimal=\"$((integer % 1000))\"\
    \n    local decimal=\"$((decimal > 9 ? decimal - 9 : decimal))\"\n    echo \"\
    $decimal\"", "    local NUMBER=$1\n    local DECIMALS=0\n    local TEMP_DEC=\n\
    \    local TEMP_DEC_BIG=\n    local TEMP_DEC_SMALL=\n    local TEMP_DEC_BIG_AND_SMALL=\n\
    \    local TEMP_DEC_BIG_AND_SMALL_EQUAL=\n\n    local BIG=1\n    local SMALL=0.1\n\
    \    local BIG_AND_SMALL=1.1\n    local BIG_AND_SMALL_EQUAL=1.2\n\n    local DEC=1\n\
    \    local DEC_BIG=1\n    local DEC_SMALL=0.1\n    local DEC_BIG_AND_SMALL=1.1\n\
    \    local DEC_BIG_AND_SMALL_EQUAL=1.2\n\n    while [ \"$NUMBER\" -gt 0 ]; do\n\
    \        TEMP_DEC=$(( NUMBER % 10 ))\n        TEMP_DEC_SMALL=$(( NUMBER % 100\
    \ ))\n        TEMP_DEC_BIG=$(( NUMBER % 1000000 ))\n\n        TEMP_DEC_BIG_AND_SMALL=$((\
    \ NUMBER % 1000000000 ))\n        TEMP_DEC_BIG_AND_SMALL_EQUAL=$(( NUMBER % 1000000000000\
    \ ))\n\n        TEMP_DEC_SMALL=$(( TEMP_DEC_SMALL * 10 ))\n\n        if [ \"$NUMBER\"\
    \ -gt 10 ]; then\n            DECIMALS=$(( DECIMALS + TEMP_DEC ))\n          \
    \  NUMBER=$(( NUMBER / 10 ))\n        elif [ \"$NUMBER\" -gt 100 ]; then\n   \
    \         DECIMALS=$(( DECIMALS + TEMP_DEC_BIG ))\n            NUMBER=$(( NUMBER\
    \ / 1000000 ))\n        elif [ \"$NUMBER\" -gt 1000000 ]; then\n            DECIMALS=$((\
    \ DECIMALS + TEMP_DEC_BIG_AND_SMALL ))\n            NUMBER=$(( NUMBER / 1000000000\
    \ ))\n        elif [ \"$NUMBER\" -gt 1000000000 ]; then\n            DECIMALS=$((\
    \ DECIMALS + TEMP_DEC_BIG_AND_SMALL_EQUAL ))\n            NUMBER=$(( NUMBER /\
    \ 1000000000000 ))\n        fi\n\n        if [ \"$TEMP_DEC\" -gt \"1\" ]; then\n\
    \            DECIMALS=$(( DECIMALS + TEMP_DEC ))\n            NUMBER=$(( NUMBER\
    \ / 10 ))\n        fi\n    done\n\n    echo \"$DECIMALS\"", "  # Parse first argument\n\
    \  local x=$1 \n\n  # Parse second argument\n  local decimals=$2\n\n  # Extract\
    \ integer part\n  local int_part=${x:0:${#x}-10}\n\n  # Extract decimal part\n\
    \  local decimal_part=${x:${#x}-${#int_part}}\n\n  # If decimal part is 0, return\
    \ integer part\n  if [[ ${decimal_part} == 0 ]]; then\n    echo \"${int_part}\"\
    \n  else\n    # Return rounded decimal part\n    echo \"${decimal_part}\"\n  fi",
  "  local number=$1\n  local decimal_part\n  local integer_part\n  if [[ $(echo \"\
    $number\" | bc -l | awk '{ print $1 }') == *\".\"* ]]; then\n    decimal_part=$(echo\
    \ \"$number\" | sed 's/^.*\\.\\([0-9]*\\)$/\\1/')\n    integer_part=$(echo \"\
    $number\" | sed 's/^[^.]*\\.\\([0-9]*\\)$/\\1/')\n  elif [[ $(echo \"$number\"\
    \ | bc -l | awk '{ print $1 }') -le 1 ]]; then\n    decimal_part=1\n    integer_part=$(echo\
    \ \"$number\" | bc)\n  else\n    decimal_part=$(echo \"$number\" | sed 's/^[^.]*\\\
    .\\([0-9]*\\)$/\\1/')\n    integer_part=$(echo \"$number\" | sed 's/^.*\\.\\([0-9]*\\\
    )$/\\1/')\n  fi\n  echo \"$decimal_part\"", "    local number=$1\n    local decimal_part=$((number\
    \ % 1))\n    local truncate_part=$((number % 10 ** 9))\n    local truncate_decimal=$((truncate_part\
    \ % 10))\n    local truncated=${truncate_decimal}${truncate_part}\n    if [ \"\
    ${truncated}\" -gt 1 ]; then\n        truncated=$(echo \"$truncated\" | bc)\n\
    \    fi\n    truncated #>&2", "    local number=\"$1\"\n    local decimal=\"${number%%.*}\"\
    \n    local decimals=\"$decimal\"\n    local integer=\"${number#*.}\"\n    local\
    \ integers=\"$integer\"\n\n    # Round decimal part up to the next integer.\n\
    \    local decimals=${decimal%.*}\n    local decimals=$(( ${decimals}+1 ))\n\n\
    \    # Round integer part up to the next integer.\n    local integers=${integer%.*}\n\
    \    local integers=$(( ${integers}+1 ))\n\n    # Add trailing zeros if necessary\n\
    \    local decimals=\"${decimals:1}\"\n    local integers=\"${integers:1}\"\n\
    \    decimals=\"${decimals:0:$(( ${#decimals} ))}\"\n    integers=\"${integers:0:$((\
    \ ${#integers} ))}\"\n    echo \"${decimals}.${integers}\"", "    local truncated_number\n\
    \    local decomposed_number\n\n    # Extract integer part and fractional part\n\
    \    truncated_number=$1\n    number_part=${truncated_number%%.*}\n\n    # Extract\
    \ decimals\n    decomposed_number=$number_part\n    decimals=${number_part#*.}\n\
    \n    # Truncate number\n    echo \"${decomposed_number%.*}\"", "    local DECIMAL_SIZE=0\
    \ DECIMAL_VAL=0 DECIMAL_PART=0 DECIMAL_ZERO=0\n    local NUMBER=\"$1\"\n    local\
    \ NUMBER_FOUND_LEFT\n\n    echo \"$NUMBER\" | awk -F. '{ printf(\"%.1f\", $1);\
    \ printf(\"%.0d\", $2); }'\n\n    NUMBER_ZERO=$(echo $NUMBER | awk '{ printf(\"\
    %.0d\", $0); }')\n    NUMBER_FOUND_LEFT=$(echo $NUMBER | awk '{ printf(\"%.0f\"\
    , $0); }')\n\n    DECIMAL_SIZE=$((NUMBER_FOUND_LEFT % 1))\n    DECIMAL_PART=$(echo\
    \ \"$NUMBER_FOUND_LEFT\" | bc | sed 's/^0*//')\n    DECIMAL_VAL=$(echo \"$NUMBER_FOUND_LEFT\"\
    \ | awk '{ printf(\"%d\", (100*$1)); }')\n    DECIMAL_ZERO=$(echo \"$NUMBER_FOUND_LEFT\"\
    \ | awk '{ printf(\"%d\", (100*$0)); }')\n\n    echo\n    echo \"Truncated number\"\
    \n    echo \"Decimal part: $DECIMAL_PART\"\n    echo \"Decimal value: $DECIMAL_VAL\"\
    \n    echo \"Decimal zero: $DECIMAL_ZERO\"\n    echo \"Decimal size: $DECIMAL_SIZE\"\
    \n\n    if [ $DECIMAL_SIZE == 0 ]\n    then\n        # No decimal was found. No\
    \ reason to truncate.\n        exit 0\n    fi\n\n    # Decimal size is larger\
    \ than zero, so we definitely need to truncate.\n    NUMBER_FOUND_LEFT=$(( NUMBER_FOUND_LEFT\
    \ - DECIMAL_SIZE ))\n    echo \"Truncated number\"\n    echo \"Decimal part: $DECIMAL_PART\"\
    \n    echo \"Decimal value: $DECIMAL_VAL\"\n    echo \"Decimal zero: $DECIMAL_ZERO\"\
    \n    echo \"Decimal size: $DECIMAL_SIZE\"\n\n    exit 0", "\tlocal x\n\tx=\"\
    $1\"\n\tlocal sign=\"\"\n\tlocal i=0\n\tlocal decimal=\"\"\n\tlocal decimals=0\n\
    \tlocal r=\"\"\n\n\tif [[ \"$x\" =~ (.*)\\.(.*)$ ]]; then\n\t\tdecimal=\"${BASH_REMATCH[2]}\"\
    \n\t\tdecimals=\"${BASH_REMATCH[1]}\"\n\tfi\n\n\tif [ \"${decimal}\" -eq \"\"\
    \ ]; then\n\t\treturn \"0\"\n\tfi\n\n\tcase \"$x\" in\n\t\t-\\?*)\n\t\techo 1>&2\
    \ \"invalid number: $1\"\n\t\texit 1\n\t\t;;\n\tesac\n\t# Decompose x into sign\
    \ and digits\n\t# If x is an integer, we only need the first digit\n\t# otherwise\
    \ we also need the sign.\n\tif [[ \"$x\" =~ ^([0-9]+)(.*)$ ]]; then\n\t\tx=\"\
    $BASH_REMATCH[1]\"\n\t\tsign=\"+\"\n\t\tdecimal=\"$BASH_REMATCH[2]\"\n\tfi\n\t\
    if [[ \"$x\" =~ ^(-?[0-9]+)$ ]]; then\n\t\tsign=\"-\"\n\t\tx=\"$BASH_REMATCH[1]\"\
    \n\tfi\n\n\t# If x is negative, we need to subtract it before adding the decimal\n\
    \t# part (that cannot be negative)\n\tif [[ \"$sign\" == \"-\" && \"$x\" -gt 0\
    \ ]]; then\n\t\tx=\"$((-$x))\"\n\tfi\n\n\ti=\"$((${#x} - 1))\"\n\t# If decimal\
    \ part is zero, set it to 1\n\tif [ \"$decimal\" -eq 0 ]; then\n\t\tdecimal=\"\
    1\"\n\tfi\n\n\twhile [ \"$i\" -gt 0 ]; do\n\t\tr=\"$decimal$r$x$((10#$((${#decimal}\
    \ * $i))))\"\n\t\t(( i-- ))\n\tdone\n\n\tif [ \"$sign\" == \"-\" ]; then\n\t\t\
    r=\"$r-'$x\"\n\tfi\n\n\t# Add back the sign\n\tr=\"$((10#$((${#r} * $i))))$r\"\
    \n\n\t# Reverse the number\n\techo \"$r\"\n\techo \"${r#-}\"", "  local input_num=\"\
    $1\"\n  # Get input number as integer part\n  input_num=\"${input_num%?}\"\n \
    \ # Get decimal part\n  input_num=\"${input_num%.}\"\n  # Now we need to check\
    \ if integer part is greater than\n  # largest possible int (2**31)-1\n  if [\
    \ $input_num -gt 2147483647 -o $input_num -le -2147483648 ]; then\n    echo \"\
    $input_num\"\n  else\n    # Return 0 here\n    truncate_number=\"0\"\n  fi", " \
    \ if [ -z \"$1\" ]; then\n    echo 1\n  else\n    truncate_number=\"${1}\"\n \
    \   if [ \"$(echo \"$truncate_number\" | bc)\" -eq 1 ]; then\n      echo \"$truncate_number\"\
    \n    else\n      echo $(echo \"$truncate_number\" | bc -l)\n    fi\n  fi", " \
    \   local number=$1\n    local integer=$(echo \"$number\" | grep -oP '\\d+' |\
    \ tail -n1)\n    local decimal=$(echo \"$number\" | grep -oP '\\.\\?\\d+')\n \
    \   if [ -z \"$decimal\" ];\n    then\n        decimal=\"\"\n    else\n      \
    \  decimal=${decimal%?}\n    fi\n    \n    echo \"$integer $decimal\"", "  # https://askubuntu.com/questions/334277/how-do-i-trim-decimal-part-of-a-number-in-shell\n\
    \  local string=\"$1\"\n  local num=\"${string#*.}\"\n  num=\"${num%.}\"\n  echo\
    \ \"${num}\"", "  echo \"$(echo \"$1\" | sed 's/^\\([0-9]*\\.[0-9]*\\)\\..*/\\\
    1/')\"", "  local trunc_num=\"${1%.*}\"\n  local trunc_num_int=\"${trunc_num#*.}\"\
    \n  local decimal=\"${trunc_num%%.*}\"\n  local decimal_int=\"${decimal#*.}\"\n\
    \  if [[ ${trunc_num_int} = \"${trunc_num}\" ]]; then\n    trunc_num_int=0\n \
    \   decimal=\".0\"\n  fi\n  if [[ ${decimal_int} = \"${decimal}\" ]]; then\n \
    \   decimal_int=0\n  fi\n  printf \"%d${decimal}%d\" ${trunc_num_int} ${decimal_int}",
  "    local floating_point floating_point_string decimal_number max_int_part remaining_part\
    \ num_truncating\n    floating_point=\"$1\"\n    if ! [[ $floating_point =~ ^[0-9]+\\\
    .[0-9]+$ ]]; then\n        echo \"$floating_point is not a valid floating point\"\
    \ >&2\n        return 1\n    fi\n    floating_point_string=\"$floating_point\"\
    \n    decimal_number=\"0\"\n    num_truncating=\"2\"\n    max_int_part=\"$((${#floating_point}\
    \ - 1))\"\n    remaining_part=\"$floating_point\"\n    while [[ $num_truncating\
    \ -gt 0 ]]; do\n        remaining_part=\"$(remaining_part - $decimal_number)\"\
    \n        if [[ $remaining_part -gt \"1\" ]]; then\n            decimal_number=\"\
    $decimal_number$decimal_point\"\n        fi\n        num_truncating=\"$((num_truncating\
    \ - 1))\"\n    done\n    decimal_number=\"$decimal_number$decimal_point\"\n  \
    \  echo \"${decimal_number}\"", "    local number=$1\n    local decimals=${2:-0}\n\
    \n    if [[ \"$decimals\" -lt 0 ]]; then\n        decimals=0\n    fi\n    local\
    \ truncate_number\n    local num\n    local decimal\n    local int\n\n    # Find\
    \ a smaller integer\n    if [[ \"$number\" =~ ^[0-9]+$ ]]; then\n        int=\"\
    $number\"\n    else\n        int=0\n        truncate_number=\"$number\"\n    \
    \    until [[ \"$number\" =~ ^[0-9]+$ ]]; do\n            int=\"$int\"\n     \
    \       truncate_number=\"$truncate_number\"\n        done\n    fi\n    num=$(echo\
    \ \"$truncate_number\" | sed -e 's/^.//' -e 's/[^0-9]//g')\n    if [[ $num ==\
    \ 0 ]]; then\n        decimal=0\n    else\n        decimal=$(echo \"$truncate_number\"\
    \ | sed -e 's/^[^0-9]//' -e 's/^.//')\n    fi\n    if [[ $decimal == 0 ]]; then\n\
    \        decimals=0\n    else\n        decimals=$(echo \"$decimal\" -1 | bc)\n\
    \    fi\n    echo $(echo \"$num * 10^$decimals\" + 1)", "    local float=$1\n\
    \    if [[ $float == *[!0-9.]* ]]; then\n        echo \"invalid float $float\"\
    \n        exit 1\n    fi\n    local decimals=$(( ${#float} - $(decimal_pos $float)\
    \ + 1 ))\n    local intpart=$(decimal_pos $float)\n    if [[ ${decimals} == 0\
    \ ]]; then\n        echo \"0\"\n    elif [[ ${decimals} == 1 ]]; then\n      \
    \  echo \"$float\"\n    elif (( decimals > 0 )) && \\\n        (( decimals < 10\
    \ )); then\n        echo \"${float%.*$decimals}.0\"\n    else\n        echo \"\
    ${float%.*$decimals}\"\n    fi", "\tlocal x\n\tlocal num_int\n\tx=\"$1\"\n\tx=\"\
    $(x%1)\"\n\tx=\"$(x%1)\"\n\tnum_int=\"$(( (x/10)))\"\n\tnum_int=\"$(( num_int*10\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1\
    \ ))\"\n\tnum_int=\"$(( num_int + num_", "  echo \"$1\" | awk '{\n    split($1,\
    \ a, \"/\")\n    b=a[1]*10 + a[2]\n    a[1]=b - int(b)\n    a[2]=a[1] - int(a[1])\n\
    \    print a[1]\n  }'", "    local number=$1\n    if [[ $number =~ ^-?[0-9]+\\\
    .[0-9]+$ ]]; then\n        local integer=\"${number%.*}\"\n        local decimal=\"\
    ${number#*.}\"\n        if [[ $integer -lt $1 ]]; then\n            local result=\"\
    ${integer}\"\n        else\n            local result=\"${decimal}\"\n        fi\n\
    \    else\n        local result=\"\"\n    fi\n    echo $result", "  local NUMBER=\"\
    $1\"\n  local DECIMALS=0\n  local DECIMAL=0\n  local NEXT_POINTING\n  local NEXT_DECIMAL\n\
    \  local NEXT_NUMBER\n\n  NEXT_NUMBER=$(( NUMBER % 1 ))\n  DECIMALS=$(($NUMBER\
    \ % 1))\n  if [ -z \"$DECIMALS\" ]; then\n    DECIMAL=1\n  else\n    DECIMAL=$(($DECIMALS\
    \ - 1))\n  fi\n  NEXT_POINTING=$(( NUMBER / $DECIMAL ))\n  NEXT_DECIMAL=$(($NEXT_POINTING\
    \ % 1))\n\n  echo \"${NUMBER:0:$DECIMAL}${NEXT_NUMBER:0:1}\"", "    local number=\"\
    ${1}\"\n    local part=\"${number%%.*}\"\n    local decimal=\"${number##*.}\"\n\
    \    if [[ -z \"$decimal\" ]] ; then\n        decimal=\"0\"\n    fi\n    echo\
    \ \"$part $decimal\"", "  local FLOOR\n  FLOOR=$1\n  local STR_VAL\n  STR_VAL=\"\
    $((FLOOR + 0*$1))\"\n  local STR\n  STR=\"${STR_VAL%.*}\"\n  echo \"$STR\"", " \
    \ local number=$1\n  local integer_part=$(echo \"${number}\" | sed -e \"s/^\\\
    ([0-9]*\\)\\..*$/\\1/\")\n  local decimals=$(echo \"${number}\" | sed -e \"s/^\\\
    ([0-9]*\\).*$/\\1/\")\n  if [ \"$decimals\" -gt 0 ]; then\n    echo \"${decimals}\"\
    \n  else\n    echo \"${integer_part}\"\n  fi", "  local number=$1\n  local intpart=$2\n\
    \  local decimals=$3\n  local decimalpart=$(( $decimals + 1 ))\n  local newintpart=$((\
    \ $intpart - $decimalpart ))\n  if [ $newintpart -eq $intpart ]; then\n    return\
    \ $number\n  fi\n  local tmp=\"$decimalpart\"\n  while [ $tmp -lt 10 ]; do\n \
    \   (( tmp++ ))\n    decimalpart=$(( $decimalpart + 1 ))\n  done\n  decimalpart=$((\
    \ $decimalpart + 1 ))\n  local final=\"$number%.$decimalpart\"\n  (( $decimals\
    \ > 0 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 1 )) && local\
    \ final=\"$final.$decimalpart\"\n  (( $decimals > 2 )) && local final=\"$final.$decimalpart\"\
    \n  (( $decimals > 3 )) && local final=\"$final.$decimalpart\"\n  (( $decimals\
    \ > 4 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 5 )) && local\
    \ final=\"$final.$decimalpart\"\n  (( $decimals > 6 )) && local final=\"$final.$decimalpart\"\
    \n  (( $decimals > 7 )) && local final=\"$final.$decimalpart\"\n  (( $decimals\
    \ > 8 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 9 )) && local\
    \ final=\"$final.$decimalpart\"\n  (( $decimals > 10 )) && local final=\"$final.$decimalpart\"\
    \n  local final2=$(( $final + 1 ))\n  (( $final2 > 100 )) && local final2=$((\
    \ $final2 + 10 ))\n  (( $final2 > 1000 )) && local final2=$(( $final2 + 100 ))\n\
    \  (( $final2 > 10000 )) && local final2=$(( $final2 + 1000 ))\n  (( $final2 >\
    \ 100000 )) && local final2=$(( $final2 + 10000 ))\n  (( $final2 > 1000000 ))\
    \ && local final2=$(( $final2 + 100000 ))\n  (( $final2 > 10000000 )) && local\
    \ final2=$(( $final2 + 1000000 ))\n  (( $final2 > 100000000 )) && local final2=$((\
    \ $final2 + 10000000 ))\n  (( $final2 > 1000000000 )) && local final2=$(( $final2\
    \ + 100000000", "    echo \"$1\" | awk '{print $1%1?$1%1:\"0\"}'", "  local x=\"\
    $1\"\n  # if input is a valid number\n  if [[ \"${#x}\" -gt 0 ]]; then\n    #\
    \ remove trailing zeroes and check if there is decimal part left\n    x=\"${x%.*}\"\
    \n    local decimal=\"${x##*.}\"\n    if [[ \"${decimal}\" -gt 1 ]]; then\n  \
    \    echo \"${decimal}\"\n    else\n      echo \"0\"\n    fi\n  else\n    echo\
    \ \"0\"\n  fi", "  local value=$1\n  echo \"${value%.*}\"", "    local dec\n \
    \   local integer\n    local tmp\n\n    integer=$(echo \"$1\" | sed 's/^\\([0-9.]*\\\
    )$/\\1/')\n    if [ -z \"$integer\" ] ; then\n        echo 1\n        return 0\n\
    \    fi\n    dec=$(echo \"$1\" | sed 's/^[0-9]*\\.\\([0-9]*\\)$/\\1/')\n    if\
    \ [ -z \"$dec\" ] ; then\n        echo 0\n        return 0\n    fi\n    decimals=$(echo\
    \ \"$1\" | sed 's/^[0-9]*\\.\\([0-9]*\\)$/\\1/')\n    if [ \"$decimals\" -gt 0\
    \ ] ; then\n        echo 1\n        return 0\n    fi\n\n    integer=$(echo \"\
    $integer\" | bc)\n    dec=$(echo \"$dec\" | bc)\n    tmp=$(echo \"$integer $dec\"\
    )\n    decimals=$(echo \"$tmp\" | bc)\n\n    echo \"$tmp\"", "\tlocal NUMBER=$1\n\
    \tlocal INTEGER=100000000000\n\tlocal DECIMALS=0\n\tlocal DECIMAL_DIGITS=${2:-0}\n\
    \n\tcase \"$NUMBER\" in\n\t\t# no floating point, nothing to do\n\t\t[0-9]) ;;\n\
    \t\t# integer part\n\t\t[0-9]*)\n\t\t\tINTEGER=$(($NUMBER / $INTEGER))\n\t\t\t\
    # integer part is smaller\n\t\t\tif [ \"$INTEGER\" -gt \"$NUMBER\" ]; then\n\t\
    \t\t\tDECIMALS=$(($DECIMAL_DIGITS - $DECIMALS))\n\t\t\tfi\n\t\t\tDECIMALS=$(($DECIMALS\
    \ + 0))\n\t\t\t;;\n\t\t# decimal part\n\t\t*.[0-9]*)\n\t\t\tDECIMALS=$(($DECIMAL_DIGITS\
    \ - $DECIMALS))\n\t\t\t;;\n\t\t# decimal part is smaller\n\t\t*.[0-9]*[1-9])\n\
    \t\t\tDECIMALS=$(($DECIMALS + 0))\n\t\t\t;;\n\tesac\n\techo \"${NUMBER%.*$DECIMALS}\"",
  "    local float=$1\n    if [[ $float == +([[:digit:]]*\\.?[[:digit:]]+([eE][-+]?[[:digit:]]+)?)[[:digit:]]*\
    \ ]]; then\n        local int_part=${float%%.*}\n        local decimal_part=${float#*.}\n\
    \        local decimal_part_len=$(expr length \"$decimal_part\")\n        if [[\
    \ $decimal_part_len == 0 ]]; then\n            return 0\n        elif [[ $decimal_part_len\
    \ > 2 ]]; then\n            echo \"Truncated decimal part has too many digits\
    \ to display\"\n            return 0\n        fi\n        echo \"$int_part.$decimal_part\"\
    \n    else\n        echo \"$float is not a positive floating point number\"\n\
    \    fi", "\tlocal n=\"$1\"\n\tlocal dec=\"$(echo \"$n\" | awk '{print $1}')\"\
    \n\tlocal int_part=\"$(echo \"$n\" | awk '{print $2}')\"\n\tlocal leftover_part=\"\
    $(echo \"$n\" | awk '{print $3}')\"\n\techo \"$(( $leftover_part / 10 ))\"", " \
    \   if [ \"$1\" = '--help' ]; then\n        echo \"Truncates decimal part of a\
    \ floating point number.\"\n        echo 'Usage: '\n        echo \"$0 <float>\"\
    \n        exit 1\n    fi\n    # $1 is a floating point\n    echo $1 | perl -pe\
    \ 's/^(-?\\d*\\.?\\d*)(\\.\\d+)$/\\1/'", "  local NUMBER=\"$1\"\n  local DECIMAL\n\
    \  DECIMAL=\"${NUMBER%%.*}\"\n  DECIMAL=\"${DECIMAL:1}\"\n  NUMBER=\"${NUMBER#$DECIMAL}\"\
    \n  echo \"${NUMBER}\"", "    local number=${1}\n    local decimal=${2-0}\n  \
    \  if [[ ${decimal} == 0 ]]; then\n        echo \"${number}\"\n        return\n\
    \    fi\n    local integer=${number%%.*}\n    local remainder=${number#*.}\n \
    \   echo $(( ${integer} + ${decimal} ))", "  local val=$1\n  local tmp\n  local\
    \ decimals=0\n  tmp=${val}\n  val=`echo \"$val\" | awk '{print $1}'`\n  tmp=${tmp}\n\
    \  if [[ $val =~ ^-?[0-9]+ ]]; then\n    decimals=`echo \"$val\" | awk '{print\
    \ length($1)}'`\n  fi\n  echo ${val:0:$decimals}", "    local number=\"$1\"\n\
    \    local decimal_point\n    local decimal_points=\"$2\"\n\n    if [ \"${number}\"\
    \ == \"-\" ]; then\n        echo \"-\"\n        return 0\n    fi\n\n    if [ -z\
    \ \"$decimal_points\" ]; then\n        decimal_points=\"0\"\n    fi\n\n    decimal_point=$(echo\
    \ $decimal_points | tr '[:upper:]' '[:lower:]')\n\n    if [ \"$decimal_point\"\
    \ == \"i\" ]; then\n        decimal_points=\"0\"\n        ;;\n    *)\n       \
    \ ;;\n    esac\n\n    local i\n    local digits\n    local digit_count\n\n   \
    \ if [ \"${decimal_points}\" == \"0\" ]; then\n        echo \"0\"\n        return\
    \ 0\n    fi\n\n    digits=${#number} # Length of the number\n\n    # First determine\
    \ if we have decimals or not\n    if [ \"$decimal_point\" == \".\" ]; then\n \
    \       digits=${#number} # Length of the number\n        decimal_points=\"${decimal_points}0\"\
    \n    fi\n\n    # Get the first digit\n    i=$(( digits - decimal_points ))\n\n\
    \    # Split the number into two parts, the first part will include\n    # decimals,\
    \ the second part does not.\n    # Decimal part will always have lesser number\
    \ than decimals\n    local j\n    j=$(( i - decimal_points ))\n\n    # If the\
    \ first digit is greater than the decimals, we can discard\n    # the decimal\
    \ part as it will not be needed.\n    if [ \"$i\" -gt \"$j\" ]; then\n       \
    \ echo \"0\"\n        return 0\n    fi\n\n    local decimal_part\n    decimal_part=${number:$j:$j}\n\
    \    local int_part\n    int_part=${number:0:$i}\n    local result\n\n    # If\
    \ the first digit is an integer we only return the decimal part\n    # as it will\
    \ not include any decimals.\n    if [ \"$decimal_point\" == \".\" ]; then\n  \
    \      echo \"$decimal_part\"\n        return 0\n    fi\n\n    # If the first\
    \ digit is larger than the decimals, we add one to the\n    # decimal part as\
    \ it will not include any decimals.\n    if [ \"$i\" -gt \"$decimal_points\" ];\
    \ then\n        decimal_part=\"$decimal_part.0\"\n        int_part=\"$int_part.0\"\
    \n    fi\n\n    # If the integer part contains no decimals, we discard it\n  \
    \  if [ \"$int_part\" == \"\" ]; then\n        int_part=\"0\"\n    fi\n\n    #\
    \ If the decimal part contains no decimals, we discard it\n    if [ \"$decimal_part\"\
    \ == \"\" ]; then\n        decimal_part=\"0\"\n    fi\n\n    # Build the result\n\
    \    result=\"$int_part.$decimal_part\"\n\n    local digits\n    digits=${#result}\n\
    \n    if [ \"$decimal_", "\tlocal trunc_number=$1\n\tlocal trunc_number_in_int=$((trunc_number%1))\n\
    \tlocal trunc_number_in_frac=$((trunc_number_in_int*10))\n\tlocal trunc_number_in_frac_power=$((trunc_number_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_int=$((trunc_number_in_frac_power%1))\n\t\
    local trunc_number_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_",
  "  local value=$1\n  local intpart=$(\n    (\n    local intpart\n    local decimalpart\n\
    \n    IFS='.' read -r -a decimal <<< \"$value\"\n    for i in \"${!decimal[@]}\"\
    ; do\n      ((decimalpart++))\n    done\n    IFS=+ read -r -a intpart <<< \"$value\"\
    \ <<< \"0.$decimalpart\"\n\n    echo \"${intpart[@]}\"\n    )\n  )\n  echo \"\
    ${intpart}\"", "    local i\n\n    echo $(\n        while [ $1 -gt 0 ]; do\n \
    \           i=$(( ${1/%.*}+1 ))\n            [ $i -eq 0 ] && break\n         \
    \   echo ${1%.*}\n            shift\n        done\n    )", "\ttruncate_number_helper",
  "  if ! [[ $1 =~ ^[+-]?[0-9]+\\.[0-9]+$ ]]; then\n    echo \"Truncate failed: $1\
    \ is not a valid floating number\"\n    exit 1\n  fi\n\n  truncate_number=\"$(echo\
    \ $1 | awk '{printf \"%.2f\", $1;}')\"", "    local NUMBER=\"${1}\"\n    local\
    \ INTEGER=\"\"\n    local DECIMAL=\"\"\n    local MAX_INT=0\n    local DECIMALS=0\n\
    \    local DECIMAL_DIGITS\n\n    # Split number in parts separated by dots\n \
    \   local NUMBER_PARTS=(${NUMBER//./ })\n\n    # Decompose the number\n    for\
    \ (( index = 0; index < ${#NUMBER_PARTS[@]}; ++index )); do\n        local NUMBER_PART=\"\
    ${NUMBER_PARTS[$index]}\"\n        case \"${NUMBER_PART}\" in\n            [0-9]*)\n\
    \                # Extract decimal portion of number\n                DECIMAL=\"\
    ${NUMBER_PART}\"\n                DECIMALS=${#DECIMAL}\n                DECIMAL_DIGITS=${#DECIMAL_DIGITS}\n\
    \                ;;\n            *)\n                # Store the integer part\n\
    \                INTEGER=\"${INTEGER}${NUMBER_PART}\"\n                ;;\n  \
    \      esac\n    done\n\n    # Get the maximum integer part\n    if [ \"${MAX_INT}\"\
    \ = \"0\" ]; then\n        MAX_INT=$(echo \"${INTEGER}${DECIMAL}\" >/dev/null\
    \ 2>&1)\n    fi\n\n    # Convert fractional part to integer\n    local FLOAT=\"\
    ${DECIMAL}\"\n    local EXPONENT_FLOAT=\"${DECIMALS}\"\n\n    # Convert decimal\
    \ part to integer\n    while (( EXPONENT_FLOAT > 0 )); do\n        FLOAT=\"$(echo\
    \ \"${FLOAT}0\" >/dev/null 2>&1)\"\n        EXPONENT_FLOAT=\"${EXPONENT_FLOAT}\"\
    \n    done\n    local INTEGER_PART=\"${INTEGER}${FLOAT}\"\n\n    # Return integer\
    \ part\n    echo \"${INTEGER_PART}\"", "    local float_str=\"$1\"\n    local\
    \ integer decimals\n\n    if [[ \"$float_str\" =~ ^[0-9]+\\.[0-9]*$ ]]; then\n\
    \        integer=\"$(echo \"$float_str\" | cut -d \".\" -f1)\"\n        decimals=\"\
    $(echo \"$float_str\" | cut -d \".\" -f2)\"\n    else\n        integer=\"0\"\n\
    \        decimals=\"0\"\n    fi\n\n    if [[ ${decimals} -lt 1 ]]; then\n    \
    \    decimals=\"0\"\n    fi\n\n    truncate_result=\"$((integer + $decimals))\"\
    \n    echo \"$truncate_result\"", "  echo \"$1\" | awk '{\n    n = $1;\n    t\
    \ = n;\n    m = 0;\n    while(t > 1 && m <= 6) {\n      m = m+1;\n      t = t\
    \ / 10;\n    }\n    print t;\n  }'", "  if [[ $1 =~ ^[0-9]*\\.[0-9]*$ ]]; then\n\
    \    local decimal_part=\"${BASH_REMATCH[1]}\"\n    local trunc_part=\"${truncate_part($decimal_part)}\"\
    \n    local trunc_decimal=\"${trunc_part}.0\"\n    echo $trunc_decimal\n  else\n\
    \    echo \"$1\"\n  fi", "\tlocal number=\"${1}\"\n\tlocal sign=\"\"\n\tlocal\
    \ decimals=0\n\tlocal decimal_part=0\n\n\tif [ \"$number\" -ge 0 ]; then\n\t\t\
    decimals=$(( $( echo \"$number\" | bc -l ) )); \n\t\tdecimal_part=$(( $( echo\
    \ \"$number\" | bc -l ) ))\n\tfi\n\n\tlocal trunc_number=\"${decimals}.${decimal_part}\"\
    \n\tcase \"$decimal_part\" in\n\t\t1)\n\t\t\tsign=\"-\"\n\t\t\tdecimals=0\n\t\t\
    \t;;\n\t\t2)\n\t\t\tsign=\"\"\n\t\t\tdecimals=0\n\t\t\t;;\n\tesac\n\t\n\techo\
    \ \"${sign}${trunc_number}\"", "    local input=${1}\n    local decimal_point=\n\
    \    local integer_part=\n    local truncated_integer_part=\n    local decimal_part_length=\n\
    \    local input_integer=\n\n    # remove trailing zeros in decimal part\n   \
    \ # e.g. 0.123 => 0.1\n    # e.g. 1.123 => 1.1\n    # e.g. 3.456 => 3.45\n   \
    \ local truncated_decimal_part=${input%.*}\n\n    # find decimal part\n    decimal_point=`echo\
    \ \"${truncated_decimal_part}\" | awk '{print index($0, \".\")}'`\n\n    # find\
    \ integer part\n    integer_part=`echo \"${truncated_decimal_part}\" | awk '{print\
    \ index($0, \".\") - 1}'`\n\n    # find decimal part length\n    decimal_part_length=`echo\
    \ \"${truncated_decimal_part}\" | awk '{print length($0)}'`\n\n    # split integer\
    \ part and decimal part in two separate variable\n    input_integer=`echo \"${input}\"\
    \ | awk -v dec=${decimal_part_length} '{print substr($0, dec, length($0))}'`\n\
    \n    # remove leading zeros from integer part\n    # e.g. 01 => 1\n    # e.g.\
    \ 02 => 2\n    # e.g. 10 => 10\n    input_integer=${input_integer#0}\n\n    #\
    \ remove decimal part if input is whole number\n    # e.g. 0 => 0\n    # e.g.\
    \ 1 => 1\n    if [ -z \"$input_integer\" ]; then\n        decimal_part=''\n  \
    \      integer_part=${input_integer}\n        truncated_integer_part=''\n    else\n\
    \        decimal_part=${input%%.*}\n        integer_part=${input_integer}\n  \
    \      truncated_integer_part=${input_integer%.*}\n    fi\n\n    # remove trailing\
    \ zeros from decimal part\n    # e.g. 0.1 => 0.1\n    # e.g. 1.1 => 1.1\n    #\
    \ e.g. 3.45 => 3.45\n    decimal_part=${decimal_part%.*}\n\n    if [ \"$decimal_point\"\
    \ -eq \"0\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$decimal_point\" -eq \"1\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$decimal_point\" -eq \"$decimal_part_length\" ]; then\n        truncate_number='${truncated_integer_part}'\n\
    \    elif [ \"$integer_part\" -lt \"$decimal_point\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$integer_part\" -ge \"$decimal_point\" ]; then\n        truncate_number='${truncated_integer_part}'\n\
    \    else\n        truncate_number='${truncated_integer_part}.'\n    fi\n", " \
    \   local decimal_part integer_part=$1\n    if [[ $decimal_part -eq 0 ]]; then\n\
    \        return 0\n    fi\n    local i decimals=${decimal_part//+([0-9])}\n  \
    \  local j\n    while ((j=${decimals}-1)>0; do\n        decimals=${decimals//[0-9]}\n\
    \    done\n    local k\n    k=$((${decimals}-1))\n    while ((k>=0)); do\n   \
    \     integer_part=$((integer_part*10+$((10^k))))\n        k=$((k-1))\n    done\n\
    \    local k\n    k=0\n    while ((k<${decimals})); do\n        integer_part=$((integer_part*10+$((10^k))))\n\
    \        k=$((k+1))\n    done\n    echo $integer_part", "  local number=$1\n \
    \ # First check, if the floating point number consists of a single digit.\n  #\
    \ This would fail for example with 2.9999999999999997\n  [[ \"$number\" =~ ^[0-9]+\\\
    .[0-9]+$ ]] || return 1\n  # Now, split the floating point number into decimal\
    \ and integer parts\n  # using the shell parameter expansion.\n  local integer=\"\
    ${number%%%.*}\"\n  local decimal=\"${number#*%.}\"\n  # Now, check if the floating\
    \ point number is a single integer or not.\n  # If it is a single integer, we\
    \ cannot use the integer part for\n  # rounding. Thus, we use the integer part\
    \ and set it to 0.\n  [[ $integer -eq 1 ]] || integer=0\n  # Now, check if the\
    \ floating point number is smaller than the precision we want.\n  # If it is,\
    \ we simply return it unchanged.\n  [[ $decimal -le $1 ]] || return \"$number\"\
    \n  # If the floating point number is not smaller than the precision, we round\
    \ it\n  # using the integer part and set the decimal part to 0.\n  local rounded_number=$((\
    \ $decimal+$integer ))\n  local rounded_number=$(( $rounded_number % $1 ))\n \
    \ # Now, add the rounding up if it did not round down to 0.\n  rounded_number=$((\
    \ $rounded_number + 1 ))\n  # Now, return the rounded number.\n  printf \"%0.${decimal}f\"\
    \ $rounded_number", "\tlocal trunc_string=$1\n\t# Cut off trailing zeros. If input\
    \ is \"2.00\", cut off \"2\"\n\tlocal trunc_string=$(echo \"${trunc_string}\"\
    \ | sed 's/^0*\\.\\([0-9]*\\)$/\\1/')\n\tlocal trunc_int=$(echo \"${trunc_string}\"\
    \ | cut -d. -f1)\n\tlocal trunc_dec=$(echo \"${trunc_string}\" | cut -d. -f2)\n\
    \t# Check if decimal part is < 1\n\tif [ -z \"${trunc_dec}\" ] || [ \"${trunc_dec}\"\
    \ -lt 1 ]; then\n\t\ttrunc_dec=\"0.000000001\"\n\tfi\n\t# Add \".0\" before decimal\
    \ part\n\ttrunc_dec=$(\"${trunc_dec}\" printf \"%.0f\")\n\t\n\t# Check if decimal\
    \ part is == 0\n\tif [ -z \"${trunc_dec}\" ] || [ \"${trunc_dec}\" = \"${trunc_int}\"\
    \ ]; then\n\t\ttrunc_dec=\"0\"\n\tfi\n\t# Append \".\" to decimal part\n\ttrunc_dec=\"\
    ${trunc_dec}.0\"\n\t\n\techo \"${trunc_int}${trunc_dec}\"", "  # Convert $1 into\
    \ an integer and truncate to nearest multiple of 10\n  local x=\"$1\"\n  local\
    \ y=$(echo \"$x%0.1\" | bc)\n  local i\n  i=$((y%10))\n  y=$((y/10))\n  i=$((i+x))\n\
    \  y=$((y+i))\n  echo \"$y%.01\"", "    local NUMBER=$1\n    local MAX_FRACTIONAL_DIGITS=$(echo\
    \ \"$NUMBER\" | jq '.'.\"1\")\n    local MIN_DECIMALS=$(echo \"$NUMBER\" | jq\
    \ '.'.\"0\")\n    local MAX_DECIMALS=1\n    local DECIMAL_POINT=$(echo \"$NUMBER\"\
    \ | jq '.'.\"1\")\n\n    if [[ $MAX_FRACTIONAL_DIGITS == $MIN_DECIMALS ]]; then\n\
    \        MAX_DECIMALS=$MAX_FRACTIONAL_DIGITS\n    elif [[ $MAX_FRACTIONAL_DIGITS\
    \ > $MIN_DECIMALS ]]; then\n        MAX_DECIMALS=$MIN_DECIMALS\n    elif [[ $MAX_FRACTIONAL_DIGITS\
    \ < $MIN_DECIMALS ]]; then\n        MAX_DECIMALS=$MAX_FRACTIONAL_DIGITS\n    fi\n\
    \    local DECIMAL_NUMBER=$(echo \"$DECIMAL_POINT\" | jq \".\".\"$MAX_DECIMALS)\n\
    \n    echo \"$DECIMAL_NUMBER\"", "    # echo \"$1\" | awk '{print $1/$2}'\n  \
    \  # echo \"${1%%.*}\"\n    expr \"$1\" : '.*[.]([0-9]*)$'", "  local number=\"\
    $1\"\n  local integer decimal leftover\n  integer=\"${number%.*}\"\n  leftover=\"\
    ${number#*.}\"\n  if [ -z \"$leftover\" ]; then\n    decimal=\"$integer\"\n  else\n\
    \    decimal=\"$integer$decimal\"\n  fi\n  echo \"$decimal\"", '  echo $(echo
    "scale=0;$1" | bc)', "  echo \"$1\" | awk '{print $1-2}';", "    local NUMBER=$1\n\
    \    local DECIMAL=`echo \"$NUMBER\" | sed -e 's/\\.//g'`\n    local NUMBER_INT=`echo\
    \ \"$DECIMAL\" | awk '{print $1/1}'`\n    if [[ $NUMBER == $NUMBER_INT ]]; then\n\
    \        DECIMAL=\"1\"\n    fi\n    echo \"$NUMBER_INT$DECIMAL\"", "    local\
    \ NUMBER=\"${1}\"\n    local PART_OF=\"$(( ${NUMBER} \\% 1 ))\"\n    local DECIMALS=\"\
    $(( ${NUMBER} * 10 ))\"\n    local DECIMAL_PART=\"${PART_OF}\"\n    if [ \"${PART_OF}\"\
    \ -ge \"0\" ]; then\n        local DECIMAL_PART=\"${PART_OF}\"\n    else\n   \
    \     local DECIMAL_PART=\"${DECIMALS}\"\n    fi\n    echo $DECIMAL_PART", " \
    \ local number=$1\n  local int_part=$(echo \"$number\" | awk '{ split($0,arr,\"\
    \\.\"); print arr[1]}')\n  local decimal_part=$(echo \"$number\" | awk '{ split($0,arr,\"\
    .\"); print arr[2]}')\n  local final_number=$int_part$decimal_part\n  echo ${final_number%.*}",
  "    local n=\"$1\"\n    local d=0\n    local ipart\n\n    while [[ $n -gt 1 ]];\
    \ do\n        (( n /= 10 ))\n        (( d += 1 ))\n    done\n\n    # Truncate\
    \ decimals\n    (( d -= 1 ))\n\n    # Find the integer part\n    ipart=$(( $n\
    \ / 10 ))\n\n    # Round integer part down\n    (( ipart = $(( ipart * 10 )) ))\n\
    \n    # Adjust the result to fit decimal part with minimal loss\n    # of precision\n\
    \    (( ipart += $d ))\n\n    # Round integer part up\n    (( ipart = $(( ipart\
    \ / 10 )) ))\n\n    # Return truncated number in the given number of decimal places\n\
    \    printf \"%0.*f\" $d \"$ipart\"", "  local -r number=$1\n\n  # The default\
    \ decimal place is '0'\n  local -r decimal=0\n\n  # If number is already an integer,\
    \ return as is\n  local -r is_int=0\n  if [[ \"$number\" =~ ^[0-9]+$ ]]; then\n\
    \    is_int=1\n  fi\n\n  # If the number is a float, convert it into an integer\n\
    \  local -r is_float=0\n  if [[ \"$number\" =~ ^[0-9]+\\.[0-9]+$ ]]; then\n  \
    \  is_float=1\n    number=${number%.*}\n  fi\n\n  # Decompose the number into\
    \ integer and decimal part\n  local -r intpart=\"${number%%.*}\"\n  local -r decimalpart=\"\
    ${number#$intpart}\"\n\n  # If there are no decimals, default to '0'\n  if [[\
    \ \"$decimalpart\" = \"\" ]]; then\n    decimal=\"0\"\n  else\n    decimal=\"\
    ${decimalpart#*\\.}\"\n  fi\n\n  # If there are no integers, default to '0'\n\
    \  if [[ \"$intpart\" = \"\" ]]; then\n    intpart=\"0\"\n  else\n    intpart=\"\
    ${intpart#*\\.}\"\n  fi\n\n  # If there are no integers nor decimals, default\
    \ to '0'\n  if [[ \"$intpart\" = \"\" || \"$decimalpart\" = \"\" ]]; then\n  \
    \  intpart=\"0\"\n    decimal=\"0\"\n  fi\n\n  # Return formatted string\n  printf\
    \ -v truncate_number_string \"${decimal}%${intpart}\"\n  if [[ \"$is_int\" -ne\
    \ 0 ]]; then\n    echo \"$truncate_number_string\"\n  else\n    echo \"$truncate_number_string\"\
    \n  fi", "    local NUMBER=\"$1\"\n\n    # convert into integer part\n    local\
    \ INT=\"${NUMBER%.*}\"\n    INT=\"${INT#0}\"\n\n    # convert into decimal part\n\
    \    local DEC=\"${NUMBER#$INT.}\"\n    DEC=\"${DEC%.*}\"\n    DEC=\"${DEC#0}\"\
    \n\n    # now we know that we have an integer part and decimal part\n    # we\
    \ check which one is the bigger and truncate it to the other\n    if [ \"${INT}\"\
    \ -gt \"${DEC}\" ]\n    then\n        echo \"${INT}\"\n    else\n        echo\
    \ \"${DEC}\"\n    fi", "\tlocal NUMBER=$1\n\tlocal DECIMAL=1 # default precision\
    \ is 1\n\tif [[ \"$NUMBER\" =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n\t\tlocal INTEGER=`echo\
    \ $NUMBER | sed -e 's/^-\\([0-9]*\\)\\..*$/\\1/'`\n\t\tlocal DECIMAL=`echo $NUMBER\
    \ | sed -e 's/^-\\([0-9]*\\)\\..*/\\1/'`\n\t\tlocal FINAL=`echo $NUMBER | sed\
    \ -e 's/^-\\([0-9]*\\)\\..*$/\\1/'`\n\t\t# if the number is less than 1, return\
    \ 0\n\t\tif [ \"$FINAL\" -lt 1 ]; then\n\t\t\tFINAL=0\n\t\tfi\n\telse\n\t\techo\
    \ \"ERROR: Cannot convert $NUMBER to integer or decimal part\"\n\t\texit 1\n\t\
    fi\n\n\t# get integer part by truncating decimal part\n\techo \"$FINAL\" | awk\
    \ '{$1=$1}1' | cut -d '.' -f 1\n", "  # We use $((...)) to force floating-point\
    \ arithmetic.\n  echo \"$(echo \"$1\" | sed -e 's/^.\\([0-9]*\\)..*/\\1/g')\"",
  "    local truncated number\n    local decimals precision\n\n    number=$1\n   \
    \ if [[ $number =~ ([+-]?([0-9]*)\\\\.([0-9]*)) ]]; then\n        precision=${BASH_REMATCH[2]}\n\
    \        decimals=${BASH_REMATCH[1]}\n        truncated=$(echo \"$number\" | bc\
    \ -l <<< \"scale=$precision\"|cut -d \".\" -f1)\n    else\n        truncated=$number\n\
    \    fi\n    echo \"$truncated\"", "    echo $1 | sed -r 's/([^0-9])([0-9])/\\\
    1 \\2/' | sed -r 's/([^0-9])([0-9])/\\1 \\2/'", "    local number_string=\"$1\"\
    \n    local decimals=0\n    local decimal\n    while [[ ${number_string} =~ ^[0-9]+$\
    \ ]]; do\n        decimal=$((${number_string%.*} / 10 ** ${decimals}))\n     \
    \   decimals=\"$((${decimals} + 1))\"\n        number_string=${number_string#*${decimal}}\n\
    \    done\n    echo \"$decimal\"", "\tlocal number=$1\n\tlocal num_decimals=0\n\
    \tlocal decimal_part\n\tlocal decimal_part2\n\tlocal decimal_part3\n\tlocal decimal_part4\n\
    \tlocal decimal_part5\n\tlocal decimal_part6\n\tlocal decimal_part7\n\tlocal decimal_part8\n\
    \tlocal decimal_part9\n\n\tdecimal_part=$number\n\tdecimal_part2=$(echo \"$decimal_part\"\
    \ | cut -d'.' -f1)\n\tdecimal_part3=$(echo \"$decimal_part2\" | cut -d'.' -f1)\n\
    \tdecimal_part4=$(echo \"$decimal_part3\" | cut -d'.' -f1)\n\tdecimal_part5=$(echo\
    \ \"$decimal_part4\" | cut -d'.' -f1)\n\tdecimal_part6=$(echo \"$decimal_part5\"\
    \ | cut -d'.' -f1)\n\tdecimal_part7=$(echo \"$decimal_part6\" | cut -d'.' -f1)\n\
    \tdecimal_part8=$(echo \"$decimal_part7\" | cut -d'.' -f1)\n\tdecimal_part9=$(echo\
    \ \"$decimal_part8\" | cut -d'.' -f1)\n\n\tif [ \"$decimal_part9\" -eq 0 ]; then\n\
    \t\tnum_decimals=$(( $(echo \"$decimal_part\" | cut -d'.' -f2) - 1 ))\n\telse\n\
    \t\tnum_decimals=$(( $(echo \"$decimal_part9\" | cut -d'.' -f2) - 1 ))\n\tfi\n\
    \n\techo \"$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part\"",
  "    local number=$1\n    local decimals=0\n    local part1=0\n    local part2=1\n\
    \    while [[ ${number} -gt 1 ]]; do\n        decimals=$(expr ${decimals} + 1\
    \ )\n        part1=$(expr ${number} - ${part2} -1 )\n        part2=$(expr ${number}\
    \ - ${part1} )\n        number=$( expr $part1 + $part2 )\n    done\n    echo $(expr\
    \ $number - $decimals - 1)", "\tlocal a=$1\n\techo \"$((10#$a%1)*10#)/10\"", " \
    \   local NUMBER=$1\n\n    local DECOMPOUND_INTEGER=0\n    local DECOMPOUND_DECIMAL=0\n\
    \    local MAX_INTEGER=0\n    local MAX_DECIMAL=0\n\n    local INTEGER_EXPONENT=0\n\
    \    local DECIMAL_EXPONENT=0\n\n    local MIDPOINT_VALUE=0\n    local MIDPOINT_INDEX=0\n\
    \n    local MIDPOINT_INTEGER=0\n    local MIDPOINT_DECIMAL=0\n    local MIDPOINT_EXPONENT=0\n\
    \n    local INTEGER_DIGITS=0\n    local DECIMAL_DIGITS=0\n\n    local MIDPOINT_DIGITS=0\n\
    \n    local DECIMAL=0\n    local INTEGER=0\n\n    # Get the fractional part by\
    \ splitting it into integer and decimal part.\n    local DECOMPOUND_INTEGER=\"\
    $NUMBER\"\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\n    # Get the decimal\
    \ part by splitting it into integer and decimal part.\n    DECOMPOUND_DECIMAL=${DECOMPOUND_INTEGER}\n\
    \    DECOMPOUND_DECIMAL=${DECOMPOUND_DECIMAL#*.}\n\n    # Get the integer part\
    \ by splitting it into integer and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n\
    \    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\n    local MAX_DECIMAL=$((\
    \ ${DECOMPOUND_DECIMAL} + 1 ))\n\n    # Get the exponent value.\n    # Get the\
    \ number of decimal digits to shift right to get an integer part and decimal part.\n\
    \    local DECIMAL_EXPONENT=$(( ${DECOMPOUND_DECIMAL} + 1 ))\n    local INTEGER_EXPONENT=$((\
    \ ${DECOMPOUND_INTEGER} - 1 ))\n\n    # Get the mantissa index based on the exponent.\n\
    \    # Get the integer part of the mantissa by splitting the number into integer\
    \ and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\
    \    DECOMPOUND_DECIMAL=${DECOMPOUND_INTEGER}\n    DECOMPOUND_DECIMAL=${DECOMPOUND_DECIMAL#*.}\n\
    \n    local MIDPOINT_INDEX=$(( ${DECOMPOUND_INTEGER} - 1 ))\n\n    # Get the mantissa\
    \ integer part by splitting it into integer and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n\
    \    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n    DECOMPOUND_DECIMAL=${DECOM",
  "\tlocal var=$1\n\tlocal int=\"${var%.*}\"\n\tlocal decimal=\"${var#$int}\"\n\n\t\
    # If the decimal part is all zeros we return it anyway.\n\t# Otherwise we return\
    \ the float with trailing zeros.\n\tif [ \"${decimal}\" == 0 ]; then\n\t\techo\
    \ \"$var\"\n\t\treturn\n\tfi\n\n\tlocal num_part\n\tnum_part=`expr \"$int\" :\
    \ '([^.]*)'`\n\tlocal remainder\n\n\t# We use \"floor division\" because if we\
    \ use \"integer division\"\n\t# and $num_part is zero, we'll get \"1\" as answer.\n\
    \t# Example: 5 - 1 -> 0 -> \"1\" -> \"0.5\"\n\t#\n\t# We know that $int is a positive\
    \ number. Using \"integer division\"\n\t# we get \"0.5\" if $num_part is zero.\n\
    \t# Example: 6 / 1 -> \"2\" -> \"0.5\"\n\t#\n\t# However, using \"floor division\"\
    \ we get \"5\" if $num_part is zero.\n\t# Example: 6 / 0 -> \"5\"\n\tremainder=`expr\
    \ \"$decimal\" - \"$num_part\"`\n\n\techo \"$int$remainder\"", "   local x=$1\n\
    \   local y=$2\n   local d=0\n   local t=0\n   if (($x <= 0)); then\n      echo\
    \ \"negative number not allowed\"\n      return 1\n   fi\n   if (($y == 0)); then\n\
    \      echo \"negative number not allowed\"\n      return 1\n   fi\n   for ((\
    \ i=0; i<$y; i++ )); do\n      if (( x % 1 == 0 )); then\n         d=$(( $d +\
    \ 1 ))\n      fi\n      x=$(( $x / 10 ))\n   done\n   if (( $d > 0 )); then\n\
    \      t=$(( 10^$d - 1 ))\n   fi\n   echo $(( $t + $x ))", "    local number=$1\n\
    \    # number must be positive\n    [ -n \"${number}\" ] || return 1\n    # we\
    \ cannot decompose the number above zero\n    [ \"${number}\" -gt 0 ] || return\
    \ 1\n    local trunc_part=0 decimal_part=0\n    # we cannot decompose negative\
    \ numbers, we need a negative number\n    # to decompose it into\n    [[ \"${number}\"\
    \ < 0 ]] && return 1\n    # divide the number by 10\n    while [[ \"${number}\"\
    \ > 0 ]]; do\n        local trunc_part=$(( trunc_part + 1 ))\n        local decimal_part=$((\
    \ decimal_part + 1 ))\n        local number=$( echo \"${number}\" / 10 )\n   \
    \ done\n    echo \"${trunc_part}\"", "  local truncate_factor=\"${1}\"\n\n  local\
    \ number=\"${truncate_factor#*[!.0-9]*}\"\n\n  echo \"${number%.*}\"", "    #\
    \ Make sure the number is positive\n    if [ \"$1\" -lt 1 ]; then\n        exit\
    \ 1\n    fi\n\n    # Decompose the number into integer (largest int) and decimals\n\
    \    # (remaining decimals)\n    IFS='.' read -r -a array <<< \"$1\"\n    truncate_part=\"\
    ${array[1]}\"\n    integer_part=\"${array[0]}\"\n\n    # Make sure the integer\
    \ part is smaller than the original number\n    if [ \"$integer_part\" -lt \"\
    $1\" ]; then\n        exit 1\n    fi\n\n    echo $truncate_part", "    local NUMBER=\"\
    $1\"\n    local DECIMALS=$(echo \"$NUMBER\" | sed -e 's/^\\([0-9]*\\)\\..*$/\\\
    1/')\n    local LARGEST_NUMBER=$(echo \"$NUMBER\" | sed -e 's/^\\(.*\\)\\..*$/\\\
    1/')\n    local INT_PART=$(echo \"$NUMBER\" | sed -e 's/^\\(.*\\)\\..*\\([0-9]*\\\
    )\\..*$/\\1/')\n    local DECIMAL_RESULT=$(echo \"$NUMBER\" | sed -e 's/^\\(.*\\\
    )\\..*\\([0-9]*\\)\\..*\\([0-9]*\\)\\..*$/\\1/')\n\n    local RESULT_STRING=\"\
    $DECIMALS\"\n\n    if [ -n \"$INT_PART\" ] ; then\n        RESULT_STRING+=\".${INT_PART}\"\
    \n    fi\n\n    return \"$RESULT_STRING\"", "    local float=\"$1\"\n    local\
    \ int=\"${float%%%.*}\"\n    local dec=\"${float#$int}\"\n    echo \"$dec\"",
  "    # Decompose the given number into integer and decimals\n    local number=$1\n\
    \    local integer=${number%.*}\n    local decimal=${number#*.}\n    decimal=${decimal%.*}\n\
    \    integer > $1 || return $integer\n    decimal == 0 || (\n        decimal=$decimal-1\n\
    \        decimal=$decimal%1\n    )\n    echo $decimal", "  # Check if the first\
    \ parameter is an integer\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    trunc_no=`echo\
    \ ${1} | cut -d. -f1`\n    dec_no=`echo ${1} | cut -d. -f2`\n    dec_len=${#trunc_no}\n\
    \    # Check if the decimal part is smaller than 1\n    if [[ $dec_len -gt 1 ]];\
    \ then\n      # Truncate the decimal part if it is smaller than 1\n      trunc_no=${trunc_no%.*}\n\
    \      # If dec_no is still smaller than 1, then it is impossible to truncate\n\
    \      if [[ $dec_no -lt 1 ]]; then\n        trunc_no=1\n        dec_len=0\n \
    \     fi\n    fi\n    if [[ $dec_len -gt 0 ]]; then\n      trunc_no=$trunc_no\"\
    .\"\n      dec_no=$dec_no\"0\"\n    fi\n    trunc_no=${trunc_no:0:$dec_len}\n\
    \  else\n    trunc_no=${1:%.*}\n    dec_no=`echo ${1} | cut -d. -f2`\n    dec_len=${#trunc_no}\n\
    \  fi\n  trunc_no=$trunc_no\n  if [[ $dec_len -gt 0 ]]; then\n    trunc_no=$trunc_no\"\
    .\"\n    dec_no=$dec_no\"0\"\n  fi\n  trunc_no=${trunc_no:0:$dec_len}\n  trunc_no=$(echo\
    \ $trunc_no | cut -d. -f1)\n  trunc_no=${trunc_no:0:$dec_len}\n  dec_no=${dec_no:0:1}\n\
    \  dec_no=${dec_no:1}\n  echo $dec_no", "  local number=${1}\n  local integer_part=$(printf\
    \ \"%.*f\" ${#number} | sed -e \"s/^0*//\")\n  local decimals=$((${#number} -\
    \ ${#integer_part}))\n  if [ \"${decimals}\" -eq 0 ]; then\n    echo \"0\"\n \
    \ else\n    echo \"${number%%.*f}${decimals}\"\n  fi", "    local var=$1\n   \
    \ local decimals=${#var}\n    local part=$(( ${var} % 1 ))\n    local intpart=$((\
    \ ${var} / 1 ))\n    if [ ${decimals} -gt 2 ] ; then\n        decimals=1\n   \
    \ fi\n    echo \"${decimals}.${part}\"", "  local truncate_to=$1\n  local number=$2\n\
    \n  # Bash has trouble with unary operators (-) so we have to\n  # use the bc\
    \ program\n  # The `<(...)` is needed to keep the output of bc as bash\n  # sees\
    \ it\n  # We also use bc for the arithmetic instead of bc (bc does not support\n\
    \  # floating points as input)\n  local trunc_part=$(echo \"${number}\" | bc -l\
    \ <<< \"$(\n      echo ${number} < ${truncate_to} && echo ${number} - ${truncate_to}\n\
    \  )\")\n\n  # If both numbers are 0, the floating point is 0 too. So\n  # we\
    \ must return the integer part as well.\n  if [[ \"${trunc_part}\" == \"0\" ]];\
    \ then\n    local trunc_part=\"\"\n  fi\n\n  # Now we must remove all decimal\
    \ part from the decimal part.\n  # If the decimal part has more than one digit,\
    \ we need to\n  # keep only one digit. So we round the number to the next\n  #\
    \ highest integer part which is one less than the decimal part.\n  # The bc program\
    \ supports rounding toward negative infinity\n  # (to nearest neighbor) or round\
    \ toward zero (away from zero). This\n  # is what the `-r` option of bc does.\n\
    \  local trunc_part=$(echo \"${trunc_part}\" | bc -l <<< \"$(\n      echo ${trunc_part}\
    \ < ${truncate_to} && echo ${trunc_part} - ${truncate_to}\n  )\")\n\n  # Strip\
    \ trailing zeroes\n  # The `-0` option strips trailing zeroes from floating point\
    \ numbers\n  # We also use `printf` because it is more efficient when dealing\
    \ with strings\n  # than `echo`\n  local trunc_part=$(printf \"%.1f\" \"${trunc_part}\"\
    )\n\n  # Strip trailing decimal part if greater than 1\n  if [[ \"${trunc_part}\"\
    \ -gt \"${truncate_to}\" ]]; then\n    local trunc_part=\"\"\n  fi\n\n  # Return\
    \ decimal part\n  echo \"${trunc_part}\"", "  local float_number=$1\n\n  local\
    \ integer_part=\"$(echo \"$float_number\" | cut -d - -f1)\"\n  local decimal_part=\"\
    $(echo \"$float_number\" | cut -d - -f2)\"\n\n  if [[ \"$decimal_part\" -eq 1\
    \ ]]; then\n    echo \"0\"\n  else\n    echo \"$decimal_part\"\n  fi", "    if\
    \ [[ \"${1}\" =~ ^[0-9]+$ ]]; then\n        local int_part=\"${1}\"\n        local\
    \ decimal_part=\"${1}\"\n        int_part=\"$(echo \"${int_part}\" | sed -e 's/^0*//g'\
    \ -e 's/\\.//g')\"\n        decimal_part=\"$(echo \"${decimal_part}\" | sed -e\
    \ 's/^0*//g' -e 's/\\.//g')\"\n        echo \"${decimal_part}\"\n    else\n  \
    \      echo \"${1}\"\n    fi", "    if [[ \"$1\" =~ ([0-9]+\\.[0-9]+) ]]\n   \
    \ then\n        truncate_number_by_decimals=${BASH_REMATCH[1]}\n    else\n   \
    \     truncate_number_by_decimals=0\n    fi", "    local number=$1\n    local\
    \ decimal_part\n    local decimal_part1\n    local decimal_part2\n    local decimal_part3\n\
    \    local decimal_part4\n    local decimal_part5\n    local decimal_part6\n\n\
    \    decimal_part1=$(echo $number | cut -d. -f1)\n    decimal_part2=$(echo $number\
    \ | cut -d. -f2)\n    decimal_part3=$(echo $number | cut -d. -f3)\n    decimal_part4=$(echo\
    \ $number | cut -d. -f4)\n    decimal_part5=$(echo $number | cut -d. -f5)\n  \
    \  decimal_part6=$(echo $number | cut -d. -f6)\n    \n    echo $decimal_part5",
  "  local DECIMALS=\"${1}\"\n  local NUMBER=\"${2}\"\n  local TRUNCATED=\"${3}\"\n\
    \  local EXPONENT=\"${4}\"\n\n  if [ \"x${TRUNCATED}\" != \"x\" ] ; then\n   \
    \ echo \"${TRUNCATED}\"\n  else\n    TRUNCATED=\"0\"\n  fi\n\n  if [ \"x${NUMBER}\"\
    \ != \"x\" ] ; then\n    local TRUNCATED_NUMBER=\"$(echo \"${NUMBER}\" | cut -d'.'\
    \ -f1-${EXPONENT})\"\n    local TRUNCATED_EXPONENT=\"$(echo \"${NUMBER}\" | cut\
    \ -d'.' -f${EXPONENT})\"\n\n    if [ \"x${TRUNCATED_NUMBER}\" != \"x\" ] ; then\n\
    \      TRUNCATED=\"${TRUNCATED_NUMBER%.}\"\n    fi\n\n    if [ \"x${TRUNCATED_EXPONENT}\"\
    \ != \"x\" ] ; then\n      TRUNCATED=\"${TRUNCATED}e${TRUNCATED_EXPONENT}\"\n\
    \    fi\n\n    echo \"${TRUNCATED}\"\n  else\n    echo \"0\"\n  fi", "  local\
    \ number=\"$1\"\n  local decimals=\"$(python -c \"import locale; print locale.getlocale()[locale.LC_ALL].decimal_point)\"\
    \n  if [ \"$decimals\" == \".\" ]; then\n    echo \"0\"\n  else\n    echo \"$number\"\
    \ | perl -pe \"s/([^$decimals])$decimals*/$decimals/\"\n  fi", "    local var=$1\n\
    \    local part\n    local decimals=0\n\n    while [ \"$var\" -gt 1 ]; do\n  \
    \      var=$(echo \"$var * 10\" | bc)\n        decimals+=1\n    done\n\n    part=$((\
    \ var * 10 ))\n    part=$(( part / 10 ))\n    echo \"$part\"", "    local number=\"\
    $1\"\n    local decimals=\"${number%.*}\"\n    local integer=\"${number#*.}\"\n\
    \    case \"$decimals\" in\n        \"0\") decimals=\"1\"\n            ;;\n  \
    \      \".\")\n            decimals=\"$decimals\"\n            ;;\n        \"\"\
    ) decimals=\"0\"\n            ;;\n    esac\n    case \"$decimals\" in\n      \
    \  \"\") integer_part=\"$integer\"\n            decimals=0\n            ;;\n \
    \       \"0\") integer_part=\"$integer\"\n            decimals=0\n           \
    \ ;;\n        \"1\") integer_part=\"$integer\"\n            decimals=0\n     \
    \       ;;\n        *)\n            local remainder\n            # Truncate decimal\
    \ part and get number of remainder\n            decimals=$((10#$decimals))\n \
    \           integer_part=\"$integer\"\n            remainder=\"$((10#$decimal\
    \ - 10#$decimals))\"\n            if [ $remainder -lt 10 ]; then\n           \
    \     integer_part=\"$integer_part.$remainder\"\n            else\n          \
    \      integer_part=\"$integer_part.0\"\n            fi\n    ;;\n    esac\n  \
    \  integer_part=\"$(echo \"$integer_part\" | bc -l)\"\n    echo \"$decimals\"",
  "  local float=\"$1\"\n  local num=\"${float}\"\n  local num_dec=\"${float%%.*}\"\
    \n  local num_int=\"${float#*.}\"\n\n  # If it's integer, then it's whole number\
    \ after decimal point\n  if [ \"$num_int\" -eq \"$num\" -a \"$num_int\" -lt \"\
    $num_dec\" ]; then\n    echo $num_int\n    return\n  fi\n\n  # If fractional part,\
    \ then it's whole number before decimal point\n  if [ \"$num_int\" -eq \"$num\"\
    \ -a \"$num_int\" -ge \"$num_dec\" ]; then\n    echo $num_int\n    return\n  fi\n\
    \n  # If it's integer part is greater, then return fractional part\n  if [ \"\
    $num_int\" -gt \"$num\" -a \"$num_int\" -le \"$num_dec\" ]; then\n    echo \"\
    $num_dec\"\n    return\n  fi\n\n  # If fractional part is greater, then return\
    \ whole number part\n  if [ \"$num_int\" -gt \"$num\" -a \"$num_int\" -lt \"$num_dec\"\
    \ ]; then\n    echo \"$num_int\"\n    return\n  fi\n\n  # Otherwise just return\
    \ the whole number part\n  echo $num_int", "  local x=\"${1}\"\n  local dec=0\n\
    \  local d\n  while [ \"${x}\" -gt 0 ]; do\n    dec=$((${dec}+1))\n    d=\"${x/10}\"\
    \n    x=\"${x%${d}}\"\n  done\n  echo \"${dec}\"", "  local IFS=.\n  local a=$1\n\
    \  local i=${#a}\n  local decimals=0\n  while ((i > 0)); do\n    decimals+=$(echo\
    \ $i | bc)\n    i=$(echo $i | bc -l)\n  done\n  echo ${a%%.*}\n  echo ${decimals}",
  "    IFS=\".\" read -r n d <<< \"$1\"\n    printf -v n \"%.${#d}s\" \"$n\"\n   \
    \ printf -v d \"%.${#d}f\" \"$d\"\n    echo \"${d%.*}\"", "    local number=$1\n\
    \    local decimal=$((${number%.*}+1))\n    local integer=$((${number#*.}-1))\n\
    \    local decimal_string=${decimal#0}\n    local integer_string=${integer#0}\n\
    \n    echo \"${decimal_string}.${integer_string}\"", "    local decimals=0\n \
    \   local integer=\"\"\n    local decimal=\"${1%.}\"\n    case \"${decimal}\"\
    \ in\n        \"\") decimal=\".0\" ;;\n        *)  decimal=\"${decimal}.0\" ;;\n\
    \    esac\n    if [ $(echo \"${decimal}\" | awk '{print $1+0} > ${decimal}\" |\
    \ bc -l) -eq 0 ]; then\n        integer=\"${1#*\\.}\"\n    else\n        integer=\"\
    ${1}\"\n        decimals=${#integer}\n    fi\n    echo ${integer}${decimal}",
  "  local value=$1\n  local int_part=$(expr \"$value\" : \"\\+([0-9]*)\")\n  local\
    \ dec_part=$(expr ${value}  - \"${int_part}\" )\n  echo \"${dec_part}\"", "  \
    \  local number_string=\"$1\"\n\n    number_string=\"${number_string%.*}\"\n \
    \   local truncate_part=\"${number_string##*.}\"\n\n    while [[ ${truncate_part}\
    \ != 0\\.0\\. ]]; do\n        truncate_part=\"${number_string##*.}\"\n    done\n\
    \n    echo \"${truncate_part}\"", "  local number=$1\n  local precision=\"${2}\"\
    \n  local digits=$((${precision}-1)) # get the number of digits before the decimal\
    \ point to truncate to\n  if [ \"${number}\" -gt 0 ]; then # check for negative\
    \ numbers\n    local -a truncated\n    local max_trunc_digits=$((${precision}-1))\
    \ # get the number of digits before the decimal point to truncate to\n    local\
    \ max_trunc_digits_without_decimal=$((${precision}-1))\n    local max_trunc_digits_without_decimal_trunc_before_decimal=$((${precision}-1))\n\
    \    while [ $max_trunc_digits -gt \"$max_trunc_digits_without_decimal\" ]; do\
    \ # find maximum number of truncated digits without decimal to prevent infinite\
    \ loop\n      local trunc_digits_without_decimal=$((max_trunc_digits-max_trunc_digits_without_decimal_trunc_before_decimal))\n\
    \      truncated=( $(echo \"${number}\" | sed -n \"s/^\\(.\\)\\(${trunc_digits_without_decimal}\\\
    )$/\\1\\2/gp\"))\n      max_trunc_digits_without_decimal_trunc_before_decimal=$((${max_trunc_digits_without_decimal_trunc_before_decimal}-1))\n\
    \      max_trunc_digits_without_decimal=$((max_trunc_digits_without_decimal-1))\n\
    \    done\n    if [ \"${#truncated}\" -gt 1 ]; then # if we have multiple digits\
    \ before the decimal point\n      local trunc_digits=${truncated[1]} # get the\
    \ truncated digits\n    else\n      local trunc_digits=\"0\"\n    fi\n    local\
    \ trunc_digits_without_decimal=${trunc_digits_without_decimal}\n    local trunc_digits_without_decimal_trunc_before_decimal=${trunc_digits_without_decimal_trunc_before_decimal}\n\
    \    local trunc_digits_truncated=$((${trunc_digits}-${trunc_digits_without_decimal}))\
    \ # get the truncated digits without decimal part\n    local trunc_digits_truncated_trunc_before_decimal=$((${trunc_digits_truncated}+${trunc_digits_without_decimal_trunc_before_decimal}))\n\
    \    local decimal_truncated=$(echo \"${number}\" | sed -n \"s/^\\(.\\)\\(${trunc_digits_truncated_trunc_before_decimal}\\\
    )$/\\1/gp\")\n    local trunc_decimals=$(echo \"${decimal_truncated}\" | sed -n\
    \ \"s/^\\(.\\)\\(${trunc_digits_truncated}\\)$", "  local number=$1\n  local decimal_part=0\n\
    \  local integer=0\n\n  # Remove decimals\n  while [ \"$number\" -gt 0 ]; do\n\
    \    local remainder=$(( $number % 10 ))\n    number=$(( $number / 10 ))\n   \
    \ decimal_part=$(( decimal_part + remainder ))\n  done\n\n  # Add leading zeros\n\
    \  while [ \"$decimal_part\" -lt 10 ]; do\n    decimal_part=$(( $decimal_part\
    \ + 0 ))\n    integer=$(( $integer + 1 ))\n  done\n\n  if [ \"$number\" -gt 0\
    \ ]; then\n    integer=$(( $integer + 1 ))\n  fi\n\n  printf -v truncated_number\
    \ \"%.0f\" $decimal_part\n  printf -v truncated_integer \"%.0f\" $integer\n\n\
    \  printf \"$truncated_number\"", "  # Convert to decimal number\n  local number=$1\n\
    \  local factor=1\n  local decimal=0\n  local decimal_part\n\n  if [[ $1 =~ \"\
    ^-?[0-9]+(.[0-9]+)?$\" ]]; then\n    # Remove leading negative sign\n    number=${1#-}\n\
    \  fi\n\n  # Break into integer and decimal parts\n  while [[ $number =~ ^[0-9]+$\
    \ ]]; do\n    decimal_part=$((factor*$number))\n    factor=$((factor*10)) # For\
    \ decimal part we need to multiply by 10\n    decimal=$((decimal+decimal_part))\n\
    \    number=${number#0}\n  done\n  decimal_part=$((factor*$number)) # Remainder\
    \ is the last decimal part\n  decimal=$((decimal+decimal_part))\n  decimal=$((decimal<0?-decimal:decimal))\n\
    \  decimal=${decimal%.*}\n  if [[ -z ${decimal// } ]]; then\n    echo \"0\"\n\
    \  else\n    echo \"${decimal}\"\n  fi", "  local a=$1\n  a=${a%.*}\n  a=${a#*.}\n\
    \  if [[ ${a} -gt 0 ]]; then\n    a=`echo \"${a}\"|awk '{print int($1)}'`\n  fi\n\
    \  echo \"${a}\"", "    IFS=\".\" read -r -a array <<< \"$1\"\n    len=${#array[@]}\n\
    \    decimal=${array[1]}\n    integer=${array[0]}\n    if [ \"$decimal\" -lt 1\
    \ ]; then\n        echo \"$integer\"\n    else\n        echo \"$integer\"\n  \
    \  fi", "  local -r number=$1\n  (( ${#number} < 1 )) && return 1\n  local -a\
    \ parts=()\n  local -r num_string=$(echo \"${number}\" | sed 's/^\\(-?[0-9]+\\\
    )\\.\\(-?[0-9]+\\)$/\\1\\2/')\n  IFS=. read -ra parts <<< \"$num_string\"\n  ((\
    \ ${#parts[@]} > 1 )) && return 1\n  local decimal_part=${parts[-1]}\n  [ \"${decimal_part}\"\
    \ -gt 1 ] || return 0\n  echo \"${decimal_part}\"", "  local NUMBER=\"$1\"\n \
    \ # The last char is always a decimal point\n  local DECIMAL_POINT=\"${NUMBER%%.*}\"\
    \n  local TRUNCATED_NUMBER=\"${NUMBER#$DECIMAL_POINT}\"\n  # The decimal part\
    \ is always the largest number smaller than $NUMBER\n  local TRUNCATED_DECIMAL=\"\
    ${TRUNCATED_NUMBER%.*}\"\n  # If the decimal part is larger than 1, the number\
    \ is too small\n  if [ \"$TRUNCATED_DECIMAL\" -gt 1 ]; then\n    TRUNCATED_DECIMAL=1\n\
    \  fi\n  echo $TRUNCATED_DECIMAL", "    truncate_decimal=.0\n    truncate_part=0\n\
    \    number=\"$1\"\n    echo \"${number}\" | while read -a part; do\n        truncate_part=$((truncate_part\
    \ + ${#part[@]} + 1))\n        truncate_decimal=$((truncate_decimal + ${part[0]}))\n\
    \    done\n    echo \"${truncate_part}${truncate_decimal}\"", "  local float_number=\"\
    $1\"\n  local decimal_part=\"$2\"\n\n  # We don't care about number of zeros,\
    \ we just need decimal part\n  if [ \"$decimal_part\" == \"0\" ]; then\n    echo\
    \ \"$decimal_part\"\n  else\n    # We can have negative sign at the beginning,\
    \ so we check it first\n    if [[ \"$decimal_part\" =~ ^-([0-9]*)\\.?([0-9]*)$\
    \ ]]; then\n      decimal_part=\"$BASH_REMATCH[1]\"\n    fi\n\n    # Remove all\
    \ decimal parts that are not equal to zero\n    decimal_part=$(echo \"$decimal_part\"\
    \ | tr -cd \".0123456789\")\n\n    if [ \"$decimal_part\" == \"0\" ]; then\n \
    \     echo \"0\"\n    else\n      echo \"$decimal_part\"\n    fi\n  fi", "   \
    \ if [ \"$1\" -eq 0 ]; then\n        return 0\n    fi\n    truncate_float=\"$(echo\
    \ \"$1\" | sed -e 's/^[0-9]*\\..*$//')\"\n    truncate_int=\"$(echo \"$truncate_float\"\
    \ | sed -e 's/\\..*$//')\"\n    echo \"$truncate_int\"", "  local FLOOR=${1}\n\
    \  local TRUNCATED=${2}\n  local DECIMAL=${3}\n\n  # We need bash 3.1 for the\
    \ -r and -F options\n  # (to support -F0 but not -F0 0)\n  local IFS='.' read\
    \ -r -d '' -a NUMBER <<<\"$(echo \"$FLOOR\" | sed -e 's/^0*//')\"\n  local DECIMAL_LEFT=${#NUMBER[@]}\n\
    \  if (( DECIMAL_LEFT >= 0 )); then\n    TRUNCATED=\n    while (( DECIMAL_LEFT\
    \ >= 0 )) ; do\n      TRUNCATED=$(( TRUNCATED + NUMBER[DECIMAL_LEFT] ))\n    \
    \  DECIMAL_LEFT=$(( DECIMAL_LEFT - 1 ))\n    done\n  fi\n  echo \"$TRUNCATED\"",
  "    local n=\"$1\"\n    shift\n\n    if [[ $n =~ (^[0-9]*\\.[0-9]+$) ]]; then\n\
    \        # n contains fractional part\n        echo \"${n%.*}\"\n    else\n  \
    \      echo \"$(( n//1))\"\n    fi", "    local FP=$1\n    # Decompose number\n\
    \    if [[ ${FP} == *\"-\"* ]]; then\n        FP=$(echo \"${FP}\" | awk '{printf(\"\
    %f\", $1 / $2)}')\n    fi\n    if [[ ${FP} == *\"+\"* ]]; then\n        FP=$(echo\
    \ \"${FP}\" | awk '{printf(\"%f\", $1 + $2)}')\n    fi\n    local DECIMALS=1\n\
    \    if [[ ${FP} > 1 ]]; then\n        DECIMALS=$(echo \"${FP}\" | awk '{printf(\"\
    %.0f\", $2 / $1)}')\n    fi\n    local INT_PART=${FP}\n    local INT_PART=${INT_PART%.*}\n\
    \    if [[ ${INT_PART} -lt ${FP} ]]; then\n        INT_PART=$(printf \"%.0f\"\
    \ ${INT_PART})\n    fi\n    # Return results\n    echo \"${DECIMALS}${INT_PART}\"",
  "    local trunc=$1\n    local dec=${trunc:1}\n    local int=$((${trunc:0:1} + ${trunc:1}\
    \ - ${trunc:0:-1}))\n    local result=$((${trunc:0:-1} + ${trunc:1} - ${trunc:0:-1}))\n\
    \    case \"${trunc:0:1}\" in\n        \"0\") result=${trunc:0:-1} ;;\n      \
    \  \"1\") result=${trunc:1:-1} ;;\n    esac\n    local res=${result}\n    local\
    \ i=${#trunc}\n    while [[ $i -gt 0 ]]; do\n        local digit=${trunc:$((i-1))}\n\
    \        case \"${digit}\" in\n            \"0\") res=\"$res.$digit\";;\n    \
    \        \"1\") res=\"$res.$digit.$dec\";;\n        esac\n        let \"i=$i-1\"\
    \n    done\n    echo $res", "    local NUM=\"${1}\"\n    local INT=\"${NUM}\"\n\
    \    local DEC=\"\"\n    local DEC_PART=\"\"\n\n    while [ \"$INT\" -ne \"0\"\
    \ ]; do\n        DEC=\"${DEC}0\"\n        INT=\"${INT}1\"\n    done\n\n    INT=\"\
    ${INT%1}\"\n    DEC_PART=\"${DEC}${INT}\"\n    echo \"${DEC_PART}\"", "    # Check\
    \ if $1 is a floating point number\n    if [[ -z \"$1\" ]]; then\n        return\
    \ 1\n    fi\n\n    # Convert $1 to integer\n    truncate_int=$(echo \"$1\" | sed\
    \ \"s/\\..*$//\")\n\n    # Check if truncate_int is an integer\n    if [[ ${#truncate_int}\
    \ -ne ${#1} ]]; then\n        return 1\n    fi\n\n    # Check if the truncated\
    \ integer is positive\n    if [[ ${truncate_int} -lt 0 ]]; then\n        return\
    \ 1\n    fi\n\n    # Check if truncate_int is smaller than $1\n    if [[ ${truncate_int}\
    \ -gt $1 ]]; then\n        return 1\n    fi\n\n    # Decompose the integer part\
    \ and decimals\n    truncate_int=$((truncate_int - 1))\n    truncate_decimal=$(echo\
    \ \"$1\" | awk \"{print $truncate_int}\") || exit 1\n\n    # Check if decimals\
    \ are 0\n    if [[ ${#truncate_decimal} -eq 0 ]]; then\n        truncate_decimal=1\n\
    \    fi\n\n    # Return truncated number\n    echo \"${truncate_decimal}\"", " \
    \   truncate_number_string=\"$1\"\n    echo $truncate_number_string\n    truncate_number_string=\"\
    $(echo $truncate_number_string | tr -d '\\\\')\"\n    truncate_number_string=\"\
    $(echo $truncate_number_string | tr '.' '\\\\.')\"\n    truncate_number_string=\"\
    $(echo $truncate_number_string | sed 's/^[0-9]*\\\\\\.//')\"\n    echo \"${truncate_number_string}\"",
  "    if [[ $1 =~ ^-?[0-9]+$ ]]; then\n        # integer part\n        trunc_num=\"\
    ${BASH_REMATCH[0]}\"\n        trunc_num_int=\"${trunc_num//[^0-9]/}\"\n      \
    \  trunc_num_int=\"${trunc_num_int:0:1}\"\n        trunc_num_int=\"${trunc_num_int}.0\"\
    \n        trunc_num_int=\"${trunc_num_int}${trunc_num_int:1}\"\n        trunc_num_int=\"\
    ${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int}${trunc_num_int:1}\"\
    \n        trunc_num_int=\"${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int:0:-1}\"\
    \n        trunc_num_int=\"${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int:0:-1}\"\
    \n        # decimal part\n        trunc_num_dec=\"${trunc_num_int:0:1}\"\n   \
    \     trunc_num_dec=\"${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec//[^0-9]/}\"\
    \n        trunc_num_dec=\"${trunc_num_dec:0:1}\"\n        trunc_num_dec=\"${trunc_num_dec}.0\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_", "  local NUMBER=\"$1\"\
    \n  echo \"${NUMBER%%.*}\"", "  local trunc=0\n  local orig=${1%%.*}\n  local\
    \ ndec=${orig#*\\.}\n  local ddec=${ndec%%.*}\n  local frac=${ndec}\n\n  if [[\
    \ $ndec -lt 0 ]]; then\n    echo \"Truncation number ${orig} is not a real number.\"\
    \n    return 1\n  fi\n\n  if [[ $ddec -lt 0 ]]; then\n    echo \"Truncation number\
    \ ${orig} does not end in a digit.\"\n    return 1\n  fi\n\n  if [[ $frac -lt\
    \ 1 ]]; then\n    echo \"Truncation number ${orig} does not contain a digit.\"\
    \n    return 1\n  fi\n\n  trunc=\"${ndec%%.*}\"\n  if [[ $ndec -eq 1 ]]; then\n\
    \    trunc=\"0\"\n  fi\n\n  echo \"$trunc${ddec}\"", "    local decimal=$1\n \
    \   local factor=$(( 10#$decimal / 10 ))\n    local remainder=$(( 10#$decimal\
    \ - 10#$factor * 10 ))\n    local truncated=$(( $factor ))\n    if [[ -z $truncated\
    \ ]]; then\n        truncated=0\n    fi\n    echo \"$truncated $remainder\"",
  "    local FP DECOMP INTEG DECL EXCL\n    FP=$1\n    FP=`echo \"${FP}\" | sed 's/^\\\
    ([0-9]*\\)\\.\\([0-9]*\\).*$/\\1/'`\n    DECOMP=`echo \"${FP}\" | sed 's/^\\([0-9]*\\\
    )\\.\\([0-9]*\\).*$/\\1/'`\n    EXCL=`echo \"${FP}\" | sed 's/^\\([0-9]*\\).*$/\\\
    1/'`\n    INTEG=`echo \"${FP}\" | sed 's/^\\([0-9]*\\).*$/\\1/'`\n    echo \"\
    ${INTEG}\"", "  local number=\"$1\"\n  # If $number is a float, we can get the\
    \ decimal part\n  local decimal\n  # If $number is an integer, the number will\
    \ be a zero\n  local zero\n\n  if [[ -f $1 ]]; then # If the file is a real number\n\
    \    # Get the decimal part from the last char of the string\n    decimal=\"${number##*.}\"\
    \n    # Get the integer part from the first char of the string\n    number=\"\
    ${number%.*}\"\n    # If the number is non-zero and negative, zero the number\n\
    \    zero=\"$(echo \"$number\" | grep -Eq '^[+-]$')\" && echo \"$zero\" || 0\n\
    \    # Round the number\n    number=\"$(echo \"$number\" | bc | tr -d '\\n')\"\
    \n  else # Otherwise, assume $number is an integer\n    zero=\"$(echo \"$number\"\
    \ | grep -Eq '^[+-]$')\" && echo \"$zero\" || 0\n    decimal=\"$(echo \"$number\"\
    \ | cut -c1-1)\"\n    number=\"$(echo \"$number\" | cut -c2)\"\n  fi\n\n  echo\
    \ \"$decimal $number\"", "    local NUMBER=$1\n    local DECIMALS=0\n    local\
    \ DECIMAL_NUM\n\n    IFS=. read -r -a DECIMAL_NUM <<< \"$NUMBER\"\n    DECIMALS=${#DECIMAL_NUM[@]}\n\
    \n    if [ \"$DECIMALS\" -eq 0 ]; then\n        echo \"${DECIMAL_NUM[0]}\"\n \
    \   else\n        echo \"$(echo \"${DECIMAL_NUM[0]}\" | cut -d. -f1)\"\n    fi\n",
  "  if [ \"$(echo \"$1\" | awk '{print $1}')\" == \"$1\" ]; then\n    echo \"$1\"\
    \n  else\n    local number_int=\"$1\"\n    local number_dec=\"$1\"\n    local\
    \ number_dec1=\"$(echo \"$number_dec\" | awk '{print $1}')\"\n    local number_dec2=\"\
    $(echo \"$number_dec\" | awk '{print $2}')\"\n    local number_dec3=\"$(echo \"\
    $number_dec\" | awk '{print $3}')\"\n\n    if [ -n \"$number_dec1\" ]; then\n\
    \      if [ -n \"$number_dec2\" ]; then\n        if [ -n \"$number_dec3\" ]; then\n\
    \          echo \"${number_int}${number_dec1}.${number_dec2}.${number_dec3}\"\n\
    \        else\n          echo \"${number_int}${number_dec1}.${number_dec2}\"\n\
    \        fi\n      else\n        echo \"${number_int}${number_dec1}\"\n      fi\n\
    \    elif [ -n \"$number_dec2\" ]; then\n      echo \"${number_int}.${number_dec2}\"\
    \n    elif [ -n \"$number_dec3\" ]; then\n      echo \"${number_int}.${number_dec3}\"\
    \n    else\n      echo \"${number_int}\"\n    fi\n  fi", "    local x=\"${1%%+(.)}\"\
    \n    local x=\"${x##*.}\"\n    local x=\"${x%+(.)}\"\n    echo \"${x%.}\"", "\t\
    truncate_number=\"$1\"\n\n\tlocal truncate_number\n\tIFS=\".\"\n\ttruncate_number=\"\
    ${truncate_number%?}\"\n\tlocal truncate_number_part\n\tlocal truncate_number_part_int\n\
    \tlocal truncate_number_part_dec\n\tlocal truncate_number_part_frac\n\n\t# Strip\
    \ off trailing \".0\" or \".00\", if present.\n\tcase \"${truncate_number}\" in\n\
    \t\t*.0)\n\t\ttruncate_number=${truncate_number%.0}\n\t\t;;\n\t\t*.00)\n\t\ttruncate_number=${truncate_number%.00}\n\
    \t\t;;\n\tesac\n\n\t# Test whether truncate_number is empty or zero.\n\t# Test\
    \ whether truncate_number is positive integer. Bail out if not.\n\tif [[ -z \"\
    ${truncate_number}\" ]]; then\n\t\treturn 0\n\telif (( truncate_number+0 != truncate_number\
    \ )); then\n\t\treturn 0\n\telif (( \"${truncate_number}\" < 1 )); then\n\t\t\
    return 0\n\telif (( \"${truncate_number}\" > 10E30 )); then\n\t\treturn 0\n\t\
    fi\n\n\t# If truncate_number is a floating point, extract integer part\n\t# and\
    \ decimal part.\n\ttruncate_number_part=\"$(echo \"${truncate_number}\" | bc)\"\
    \n\n\ttruncate_number_part_int=\"$(echo \"${truncate_number_part}\" | cut -d'('\
    \ -f 1)\"\n\ttruncate_number_part_dec=\"$(echo \"${truncate_number_part}\" | cut\
    \ -d'(' -f 2)\"\n\n\tlocal truncate_number_part_dec_final\n\tcase \"${truncate_number_part_dec}\"\
    \ in\n\t\t*.0)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec%.0}\n\
    \t\t;;\n\t\t*.00)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec%.00}\n\
    \t\t;;\n\t\t*)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec}\n\
    \t\t;;\n\tesac\n\n\t# Strip off trailing \".0\" or \".00\", if present.\n\tcase\
    \ \"${truncate_number_part_dec_final}\" in\n\t\t*.0)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final%.0}\n\
    \t\t;;\n\t\t*.00)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final%.00}\n\
    \t\t;;\n\t\t*)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final}\n\
    \t\t;;\n\tesac\n\n\tlocal truncate_number_part_int\n\t", "  local f=\"$1\"\n \
    \ local ipart=\"$(( ${f%%.*} + 1 ))\"\n  local decpart=\"$(( ${f#$ipart%.*} ))\"\
    \n  printf \"%.${decpart}f\" $ipart", "    if [[ \"$1\" =~ $((\\([^\\)]*\\) -\
    \ \\([^\\)]*\\))*[^-]*[^0-9]\\([0-9]*\\)$((\\([^\\)]*\\) - \\([^\\)]*\\))*[^-]*[^0-9]\\\
    ([0-9]*\\) ]]; then\n        # e.g. \"3.5\" -> \"3.50\" -> \"3.499995\" -> \"\
    3.50\"\n        echo \"${BASH_REMATCH[1]%.}\"\n    else\n        echo \"$1\"\n\
    \    fi", "  if ! [[ $1 =~ ^[0-9.]+$ ]]; then\n    echo\n    echo \"Bad argument\
    \ to truncate_number: \\\"$1\\\".\"\n    echo\n    exit 1\n  fi\n\n  local trunc=\"\
    $1\"\n  local dec=0\n\n  if [[ $trunc =~ (^[0-9]+\\.[0-9]*)$ ]]; then\n    trunc=\"\
    ${BASH_REMATCH[1]}\"\n    dec-=1\n  fi\n\n  echo \"$trunc$((10#$dec))\"", "  local\
    \ num_string=$1\n  local truncated\n  local num_parts\n  local num\n  local num_dec\n\
    \  num_parts=$(echo \"${num_string}\" | perl -nle '/\\./||print for/^\\d*$/')\n\
    \  num_dec=$(echo \"${num_parts}\" | perl -nle 'print 0+$_;END{exit $?}')\n  num=$(echo\
    \ \"${num_string}\" | perl -nle '/^\\d*$/&&{print 0+$_;END{exit $?}}')\n  truncated=$(echo\
    \ \"${num}\" | bc)\n  if [ ${truncated} -le ${num_dec} ]; then\n    echo \"${num_string}\"\
    \n  else\n    echo \"${truncated}\"\n  fi", "    local val=\"$1\"\n    local intpart\n\
    \    local decimalpart\n    local decpart\n    if [[ ${val} =~ ^[0-9]+\\.[0-9]+$\
    \ ]]; then\n        local part1=\"${BASH_REMATCH[1]}\"\n        local part2=\"\
    ${BASH_REMATCH[2]}\"\n        local part3=\"${BASH_REMATCH[3]}\"\n        if [[\
    \ ${part2} -eq 0 ]]; then\n            intpart=\"${part1}\"\n            decimalpart=\"\
    ${part3}\"\n        else\n            intpart=\"${part1}.${part2}\"\n        \
    \    decimalpart=\"${part3}.${part2}\"\n        fi\n    else\n        intpart=\"\
    ${val}\"\n        decimalpart=\"0\"\n    fi\n    if [[ ${decimalpart} == *\".\"\
    * ]]; then\n        decpart=\"${decimalpart%.*}\"\n    else\n        decpart=\"\
    0\"\n    fi\n    echo \"${intpart}.${decpart}\"", "  local input=${1+\"$@\"}\n\
    \  local output=${input%.*}\n  local int_part\n  [[ -z \"$int_part\" ]] && int_part=\"\
    $output\"\n  local dec_part\n  [[ -z \"$dec_part\" ]] && dec_part=$output\n  local\
    \ remain\n  [[ -z \"$remain\" ]] && remain=1\n  echo \"$int_part\"", "  local\
    \ input=${1:-1.0}\n  # Python doesn't support floating point rounding.\n  local\
    \ integer=${input}\n  local decimal=${integer}\n\n  # Make sure we at least have\
    \ one decimal point.\n  [[ \"$decimal\" != \"$input\" ]] || return 0\n\n  local\
    \ decimal=${decimal%%.*}\n\n  # If there is enough digits to round the number\
    \ up\n  # to the correct decimal point then rounding is easy.\n  if [[ \"$decimal\"\
    \ -ge 1 ]]; then\n    return 0\n  fi\n\n  # We know that there are more digits\
    \ to round the number up\n  # than decimal points. We'll round the number up to\
    \ the next\n  # whole number and then truncate the decimals.\n  local next_whole=0\n\
    \  local next_decimal=\n  while (( \"$decimal\" > 0 )); do\n    (( next_whole++\
    \ ))\n    (( decimal = decimal / 10 ))\n  done\n  next_decimal=$(( $next_whole\
    \ - 1 ))\n\n  (( next_decimal > 0 )) || return 0\n\n  # We now know there are\
    \ more decimal places to round the number up to.\n  # The number we are rounding\
    \ up is $next_whole.\n  (( next_whole++ ))\n\n  # If the decimal part is smaller\
    \ than 1, we round the number up\n  # to the next whole number. Otherwise we just\
    \ return the decimals.\n  if (( \"$decimal\" < 1 )); then\n    (( next_whole >\
    \ 1 )) || return 0\n  else\n    (( next_whole > 0 )) || return 0\n  fi\n\n  #\
    \ Since we know that there are more decimal places,\n  # we'll round the number\
    \ up to the next whole number.\n  (( next_whole++ ))\n\n  # The number we are\
    \ rounding up is $next_whole.\n  (( next_whole > 1 )) || return 0\n\n  # Since\
    \ we know that there are more decimal places,\n  # we'll round the number up to\
    \ the next whole number.\n  (( next_whole++ ))\n\n  # The number we are rounding\
    \ up is $next_whole.\n  (( next_whole > 1 )) || return 0\n\n  # Now that we've\
    \ rounded up, we know the number we are rounding\n  # to is always greater than\
    \ or equal to 0.5. We can truncate the\n  # decimal part without worrying about\
    \ truncating the decimals.\n  return $next_whole ${decimal}", "    local number_to_truncate=\"\
    $1\"\n    # Easy out if number already is a multiple of 1\n    if [ \"$number_to_truncate\"\
    \ = \"$number_to_truncate.0\" ]; then\n        echo \"$number_to_truncate\"\n\
    \        return 0\n    fi\n    number_to_truncate=$($(echo ${number_to_truncate}|sed\
    \ 's/^0\\+\\([0-9]*\\)\\..*/\\1/'))\n    # Round down if decimal part is greater\
    \ than 1\n    if [ \"${number_to_truncate%.*}\" -gt 1 ]; then\n        number_to_truncate=$(echo\
    \ \"$number_to_truncate - 1\"|bc)\n    fi\n    echo \"$number_to_truncate\"",
  "  local number=$1\n  local fraction\n  local decimal\n  local integer\n  local\
    \ sign\n  local decimals\n  local length\n  decimals=0\n  while [ \"${number}\"\
    \ -gt 0 ]; do\n    integer=\"$((10#$((number%1)*10#-1)))\"\n    fraction=\"$((10#(number/${integer})))\"\
    \n    decimal=\"$((10#${fraction}*10#-1))\"\n    if [ \"${integer}\" -lt 1 ] ||\
    \ [ \"${fraction}\" -lt 1 ] || [ \"${decimal}\" -lt 1 ]; then\n      # This can\
    \ happen for negative numbers (i.e. -1.5e-3): fraction is < 1 and\n      # integer\
    \ is less than 1, but decimal part is > 1.\n      break\n    fi\n    decimals=\"\
    $((${decimals} + ${decimal}))\"\n    number=\"${integer}${decimal}\"\n  done\n\
    \  if [ -z \"${number}\" ]; then\n    # This happens for 0, which has integer\
    \ part 0 but decimal part 0\n    return 0\n  fi\n  sign=${number#+}\n  number=${number%+}\n\
    \  length=${#number}\n  if [ ${length} -eq 0 ]; then\n    return 0\n  fi\n  #\
    \ Only keep if length is not even\n  if [ ${length} -eq 2 ]; then\n    number=\"\
    $((${number} + 1))\"\n  fi\n  printf \"%.${decimals}f\" ${number} || printf \"\
    0\"", "    local trunc_str=\"$(echo \"$1\") # cut away trailing zeros\n    local\
    \ trunc_int=\"$(echo \"$trunc_str\" | sed 's/^\\([0-9]*\\)\\.\\([0-9]*\\)$/\\\
    1\\2/') # convert fractional part to whole part\n    local trunc_dec=\"$(($trunc_str\
    \ - $trunc_int))\" # cut away decimal part\n    if [ \"$trunc_dec\" -lt 1 ]; then\n\
    \        trunc_dec=1\n    fi\n    echo $trunc_dec", "  local IFS='.' read -r -a\
    \ NUMBER <<<\"$1\"\n  local MAX=\"$(( ${NUMBER[@]:0:1} ))\"\n  local MIN=\"$((\
    \ ${NUMBER[@]:0:1} ))\"\n  local DEC=\"$(( ${#NUMBER[@]} - 1 ))\"\n  local DEC_UPP=\"\
    $(echo \"$DEC\" | bc)\"\n\n  if [ $DEC -lt 0 ]; then\n    echo \"$MAX\"\n  else\n\
    \    echo \"$(( MAX / 10 ))\"\n  fi", "  local number=$1\n  local decimals=${1:-10}\n\
    \  local integer_part=${number/%.*}\n  local decimal_part=$(( $number % $decimals\
    \ ))\n  echo \"$decimal_part\"", "    local NUM\n    NUM=\"${1%.*}\"\n    local\
    \ DECIMAL\n    DECIMAL=\"${NUM%.*}\"\n    local INTEGER\n    INTEGER=\"${NUM#*.}\"\
    \n    local PART\n    PART=\"${DECIMAL}\"\n    DECIMAL=\"0\"\n    while [ \"${DECIMAL}\"\
    \ -lt 1 ]; do\n        DECIMAL=\"${DECIMAL}0\"\n        INTEGER=\"${INTEGER}1\"\
    \n    done\n    echo -n \"${PART}\"", "  local decimals=0\n  local number=0\n\
    \  local decimal=0\n  local tempnum=0\n  local decpart\n\n  if [[ $1 =~ ^[0-9]+\\\
    .[0-9]+$ ]]; then\n    decimals=$(echo $1 | sed 's/\\.//g' | awk '{print length($1)}')\n\
    \    number=$1\n  elif [[ $1 =~ ^[0-9]+$ ]]; then\n    decimals=0\n    number=$1\n\
    \  else\n    echo \"Cannot determine number of decimals for $1\"\n    return 1\n\
    \  fi\n\n  tempnum=$(echo \"$number\" | sed 's/\\.//g')\n\n  while [[ $tempnum\
    \ -ne 0 ]]; do\n    decimal=$((decimal + 1))\n    tempnum=$(echo \"$tempnum\"\
    \ | cut -d. -f1)\n  done\n\n  if [ \"$decimal\" -gt \"$decimals\" ]; then\n  \
    \  echo \"Number of decimals $decimals for $1 greater than number of decimals\
    \ $decimals for $2\"\n    return 1\n  fi\n\n  decpart=$((decimal-decimals))\n\n\
    \  echo \"$number\"\n  echo \"${number%.$decpart}\"", '  echo "${1%.*}"', "  \
    \  # $1: Float\n    local n=$1\n    local frac\n    local dec\n    local int\n\
    \n    if [[ $n -eq $n ]]; then\n        int=$n\n        frac=0 # integer part\n\
    \    else\n        frac=$n\n        int=0\n    fi\n    dec=$(( ${#frac} % 10 ))\n\
    \n    if [[ \"$dec\" -gt 0 ]]; then\n        echo -n \"0.\"\n    fi\n    echo\
    \ ${frac%%.*}", "  echo \"$1\" | cut -d \".\" -f1 | sed 's/^0*//;s/^0*\\.//;s/^0*$//'",
  "    local number=$1\n    local decimal_part\n    local decimal_part_num\n    local\
    \ fractional_part\n    local whole_part\n    local number_part\n    local trunc_result\n\
    \n    decimal_part=$(echo \"$number\" | awk -F. -v x=\"$number\" 'BEGIN{print\
    \ x/10; exit}')\n    decimal_part_num=$(echo \"$decimal_part\" | sed -e 's/\\\
    ./0/g')\n    fractional_part=$(echo \"$decimal_part\" | sed -e 's/^0*//')\n  \
    \  whole_part=$(echo \"$number\" | awk 'BEGIN{print x}')\n    number_part=$(echo\
    \ \"$whole_part*10\" | bc)\n\n    trunc_result=$(echo \"scale=3; $number_part\
    \ * $decimal_part_num / $fractional_part\" | bc)\n\n    # If the number is a non-positive\
    \ integer, the decimal part is returned.\n    case \"$trunc_result\" in\n    \
    \    0)\n            echo \"0\"\n            ;;\n        *)\n            echo\
    \ \"$trunc_result\"\n            ;;\n    esac", "    # $1\n    truncate_part=$1\n\
    \    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.1f\", $1/1}')\n\
    \    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.2f\", $1/2}')\n    # echo \"$truncate_part\"\n    # echo \"\
    $truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"\
    %.3f\", $1/3}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\"\
    \ | awk '{printf \"%.4f\", $1/4}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.5f\", $1/5}')\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.6f\", $1/6}')\n\
    \    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.7f\", $1/7}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.8f\", $1/8}')\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.9f\", $1/9}')\n\
    \    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.10f\", $1/10}')\n\
    \    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.12f\", $1/12}')\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.14f\", $1/14}')\n\
    \    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"\
    $truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    truncate_part", "   local x=\"$1\"\n   if [ \"$x\" = \"--help\" -o \"$x\"\
    \ = \"-h\" -o \"$x\" = \"--h\" -o \"$x\" = \"-?\" -o \"$x\" = \"help\" -o \"$x\"\
    \ = \"\\?\" ]; then\n      echo \"Usage: $(basename $0) [floating point number]\"\
    \n      echo \"Displays the decimal part of the given floating number.\"\n   \
    \   exit 0\n   fi\n\n   if [[ \"$x\" =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n      local\
    \ integer=\"$1\"\n      integer=\"$(echo \"$integer\" | sed 's/^-//')\"\n    \
    \  local decimal=\"$x\"\n      decimal=\"$(echo \"$decimal\" | sed 's/^.-//')\"\
    \n\n      local integer_part=\"${integer%.*}\"\n      local decimal_part=\"${x#$integer_part}\"\
    \n\n      if (( $decimal_part == 0 )) ; then\n         decimal=\"0\"\n      fi\n\
    \n      echo \"$decimal_part\"\n   elif [[ $x =~ ^[0-9]+\\.?[0-9]*$ ]]; then\n\
    \      echo \"$x\"\n   elif [[ $x =~ ^[0-9]+$ ]]; then\n      echo \"$x\"\n  \
    \ else\n      echo \"$x\"\n   fi", "\tlocal x\n\tx=\"$1\"\n\tshift\n\tlocal d\n\
    \td=\"$(echo \"$x\" | awk '{print int('$1', 8)}')\"\n\techo \"${x%.*}\"", "  \
    \  if [[ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        echo \"$1\"\n        echo \"\
    $1\"\n        echo \"$1\"\n        echo \"$1\"\n        echo \"$1\"\n        echo\
    \ \"$1\"\n        echo \"$1\"\n    else\n        echo \"0\"\n    fi", "   local\
    \ x=\"${1}\"\n   local integer=\"${x%?}\"\n   local decimal=\"${x#$integer}\"\n\
    \   echo \"${decimal}\"", "  local float=$1\n  local int_part=$(expr floor $float)\n\
    \  local frac_part=$(expr rem $float $int_part)\n  printf \"%.1f\" $frac_part",
  "\tlocal trunc=$1\n\tlocal dec=$(echo \"$trunc\" | bc)\n\techo \"$dec\"", "    local\
    \ input=\"$1\"\n    local IFS=.\n    local dec=0\n    local IFS_backup=\"$IFS\"\
    \n    IFS=$'\\n' dec=$(echo \"$input\" | sed -e 's/^'\"$input\"'//')\n    IFS=\"\
    $IFS_backup\"\n    echo \"$dec\"", "    local fp dec i\n    fp=${1}\n    IFS=.\
    \ read -ra dec <<< \"$(echo \"$fp\" | sed 's/^\\(-*[0-9]*\\.\\)\\([0-9]*\\).*$/\\\
    1/')\"\n    if [[ -n \"${dec[1]}\" ]]; then\n        i=\"${#dec[@]}\"\n      \
    \  if [[ -n \"${dec[i - 1]}\" ]]; then\n            if (( ${dec[1]} > ${dec[i\
    \ - 1]} )) ; then\n                dec[1]=\"${dec[i - 1]}\"\n            else\n\
    \                dec[1]=0\n            fi\n        else\n            i=0\n   \
    \     fi\n    fi\n    echo \"${fp%.*}.${dec[1]}\"", "\t# Strip leading 0s from\
    \ the number or else the result\n\t# is incorrect: 0.045 -> 0.4\n\tlocal NUMBER=$1\n\
    \tif [[ $NUMBER == *\".\"* ]]; then\n\t\tNUMBER=\"${NUMBER%.*}\"\n\tfi\n\tlocal\
    \ PART_INTEGER\n\tlocal PART_DECIMAL\n\tPART_INTEGER=${NUMBER#0}\n\tPART_DECIMAL=${NUMBER%.*}\n\
    \tif [[ \"$1\" == \"$NUMBER\" ]]; then\n\t\techo \"$PART_DECIMAL\"\n\telse\n\t\
    \techo \"$PART_INTEGER\"\n\tfi", "    local number=$1\n    local intpart=$(echo\
    \ $number | cut -d\"e\" -f1)\n    local decimals=$(echo $number | cut -d\"e\"\
    \ -f2)\n    local decimalpart=$(echo $number | cut -d\"e\" -f3)\n\n    # Ensure\
    \ that decimalpart is a positive integer\n    if (( $decimalpart > 0 )); then\n\
    \        echo \"$intpart.$decimalpart\"\n    else\n        echo \"$intpart\"\n\
    \    fi", "  local x=\"$1\" # Input floating point number\n  local integer=\"\
    $(( (x | cut -d '.' -f 1) | cut -d '' -f 1) )\" # Get integer part (ignore decimal\
    \ part)\n  local decimal=\"$(( (x | cut -d '.' -f 2) | cut -d '' -f 1) )\" # Get\
    \ decimal part\n  [ -n \"$decimal\" ] && decimal=\"$(( decimal / 10 ))\" # Scale\
    \ decimal part to 10 (right side is never less than 1)\n  printf \"%.1f\" \"$decimal\"\
    \ # Return decimal part", "    local number=$1\n\n    echo \"${number%.*}\" |\
    \ bc -l | sed -e \"s/^\\..*//\"", "    local number=$1\n    local int_part\n \
    \   local dec\n    int_part=$(( ${number} % 1 ))\n    dec=$(( ${number} - $int_part\
    \ ))\n    echo \"${dec}\"", "  local var_name=\"$1\"\n  local value=\"$2\"\n \
    \ local precision=\"$3\"\n\n  local precision_int precision_dec\n  local int_part\
    \ dec_part\n  local int_part_len dec_part_len\n\n  # Remove leading zeroes if\
    \ precision is zero\n  if [[ $precision == 0 ]]; then\n    precision=8\n  fi\n\
    \n  int_part=\"$(\n    IFS=.\n    echo \"$value\"\n  )\"\n  dec_part=\"$(\n  \
    \  IFS=.\n    echo \"$value\"\n  )\"\n\n  precision=\"$((${precision}-1))\"\n\
    \  int_part_len=\"$(\n    echo $int_part |\n    awk -F. '{print length}'\n  )\"\
    \n  dec_part_len=\"$(\n    echo $dec_part |\n    awk -F. '{print length}'\n  )\"\
    \n\n  # If precision is too small and the integer part contains only one digit,\n\
    \  # we round up to the next higher integer\n  if [[ $int_part_len == 1 && $dec_part_len\
    \ > $precision ]]; then\n    dec_part=\"$dec_part.$((${precision}-1))\"\n  fi\n\
    \n  if [[ ${precision} -gt ${int_part_len} ]]; then\n    echo \"$dec_part\"\n\
    \  else\n    echo \"$int_part.$dec_part\"\n  fi", "  local number=\"$1\"\n  local\
    \ integer_part=\"$(echo \"$number\" | awk '{print int($1)}')\"\n  local decimal_part=\"\
    $(echo \"$number\" | awk '{print int($1 / $1)}')\"\n  if [ \"$decimal_part\" -eq\
    \ 0 ]; then\n    echo \"$integer_part\"\n  else\n    echo \"$integer_part$decimal_part\"\
    \n  fi", "\tlocal trunc_num=${1%.*}\n\tlocal trunc_str=\"${trunc_num}\"\n\t# strip\
    \ trailing zeros\n\tlocal trunc_num=${trunc_num%%.*}\n\tlocal trunc_str=\"${trunc_str%%.*}\"\
    \n\tlocal trunc_int=0\n\tlocal trunc_dec=0\n\n\twhile true; do\n\t\tlocal char=${trunc_str:0:1}\n\
    \t\ttrunc_str=\"${trunc_str:1:1}\"\n\t\tcase \"$char\" in\n\t\t\t0)\n\t\t\t\t\
    break\n\t\t\t\t;;\n\t\t\t[!0-9])\n\t\t\t\techo \"Invalid float '$trunc_str'\"\
    \ >&2\n\t\t\t\treturn -1\n\t\t\t\t;;\n\t\tesac\n\t\ttrunc_int=$((trunc_int + $char))\n\
    \t\ttrunc_dec=$((trunc_dec + ${trunc_int:-0}))\n\tdone\n\n\techo \"${trunc_int:-0}.${trunc_dec:-0}\"",
  "  local num=$(echo \"$1\" | bc)\n  local intpart=$(echo \"$num\" | sed -r \"s/^([0-9]+)\\\
    .*$/\\1/\")\n  local decpart=$(echo \"$num\" | sed -r \"s/^([0-9]+)\\.0+$/\\1/\"\
    )\n  if (( intpart != num )); then\n    echo \"$decpart\"\n  else\n    echo \"\
    $1\"\n  fi", "  if ! echo \"${1}\" | egrep -E \"^[+-]?[0-9]+\\.?[0-9]*$\" > /dev/null;\
    \ then\n    echo \"FAIL: invalid number: ${1}\" >&2\n    exit -1\n  fi\n  x=$(echo\
    \ \"${1}\" | sed 's/^\\([+-]?[0-9]+\\)\\.\\([0-9]*\\)$/\\1\\2/')\n  echo ${x}",
  "\t# Truncate a number from its decimal part.\n\t# $1 is number\n\tcase \"$1\" in\n\
    \t\t*)\n\t\t\t[ \"${#1}\" -gt \"2\" ] && echo \"number too long!\" && exit 1;\n\
    \t\t\t[ \"${#1}\" -eq \"1\" ] && echo \"number too short!\" && exit 1;\n\t\t\t\
    [ \"${#1}\" -lt \"5\" ] && echo \"number too short!\" && exit 1;\n\t\t\ttruncate_number_parts=$(echo\
    \ \"$1\" | cut -d. -f1)\n\t\t\tnumber_part=$(echo \"$truncate_number_parts\" |\
    \ cut -d. -f1)\n\t\t\tdecimal_part=$(echo \"$truncate_number_parts\" | cut -d.\
    \ -f2)\n\t\t\techo \"$number_part\"\n\t\t\techo \"$decimal_part\"\n\t\t;;\n\t\
    esac", "\tlocal trunc=$1; shift\n\tlocal d=$1; shift\n\techo $(( $d % 1 ))\n\t\
    while (( $d > 1 )); do\n\t\techo 0\n\t\td=$(echo \"$d/10\" | bc)\n\tdone\n\ttrunc=$(($trunc+$d))\
    \ ;\n\techo \"$trunc\"", "    local number=$1\n    local decimals=0\n    local\
    \ integer\n    local remainder\n\n    if [[ $number == * ([^.]*).* ]]; then\n\
    \        integer=${BASH_REMATCH[1]}\n        decimals=${#integer}\n        number=${number#*.*}\n\
    \    else\n        integer=0\n        decimals=0\n    fi\n\n    # In case integer\
    \ part is zero\n    if [[ $integer == 0 ]]; then\n        echo \"$number\"\n \
    \       return 0\n    fi\n\n    remainder=`echo \"$number\" | bc -l`\n    echo\
    \ $(($remainder%1))", "    local number=$1\n    local decimals=0\n    local truncate_decimal\n\
    \    while [[ $number > 1 || $number == 1 ]]; do\n        decimals=$(expr ${decimals}\
    \ + 1)\n        if [[ $number > 1 ]]; then\n            truncate_decimal=$(echo\
    \ \"$number*10\" | bc)\n        else\n            truncate_decimal=$(echo \"$number\"\
    \ | bc)\n        fi\n        number=$($truncate_decimal %)\n    done\n    echo\
    \ \"$decimals\"", "    trunc_part=${1%.*}\n    trunc_part=$(echo \"$trunc_part\"\
    \ | bc)\n    trunc_part=${trunc_part%.*}\n    trunc_part=${trunc_part:-0}\n  \
    \  trunc_part=$(echo \"$trunc_part\" | bc)\n    echo \"$trunc_part\"", "  local\
    \ number=$1\n  local number_in_int=$(( ${number} % 1 ))\n  local decimals=$((\
    \ (${number}%1)*10^(( ${#number}-1 )) ))\n  echo \"${decimals:-0}\"", "    local\
    \ number=$1\n    local decimals=$2\n    local integer_part=$(( ${number%.*} ))\n\
    \    if [[ ${decimals} -lt 1 ]]; then\n        local decimal_part=0\n    else\n\
    \        local decimal_part=$(( ${decimals%.*} ))\n    fi\n    echo \"${integer_part}.${decimal_part}\"",
  "  local num=$1\n  local truncated=$(echo $num | awk -F. -v n=${num%.*} -v d=1<<31|bc)\n\
    \  [[ $truncated -gt $num ]] && truncated=$(expr ${truncated}+1 \\* ${d})\n  echo\
    \ $truncated", "  if [[ $1 == 0 ]]; then\n    echo \"0\"\n  else\n    if [[ $1\
    \ == \"0\" ]]; then\n      echo \"0\"\n    else\n      echo $(($1 / 10 + $1 %\
    \ 10))\n    fi\n  fi", "  echo \"$1\"\n  if [[ $1 =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n\
    \    echo \"${1%%.*}\"\n  fi", "  local number=$1\n  local integer=0\n  local\
    \ decimal=0\n  while [ \"$number\" != \"\" ]; do\n    decimal=$(( $decimal + 1\
    \ ))\n    integer=$(( $integer + 1 ))\n    number=$(echo \"$number\" | cut -c\
    \ -$(( $decimal + 1 ))) | tail -n 1\n  done\n  echo \"$integer\"", "  local number=$1\n\
    \  local trunc_part\n  local decomp\n  trunc_part=${number%.*}\n  decomp=`echo\
    \ \"$number\" | bc -l`\n  if [[ $decomp -ge 0 ]]; then\n    echo \"$trunc_part\"\
    \n  else\n    echo \"0\"\n  fi", "  local v=\"$1\"\n  local d=0\n\n  while [ \"\
    ${v:0:1}\" != \".\" ]; do\n    v=\"${v:0:1}\"\n    d=$(( ${#v} - 1 ))\n  done\n\
    \n  # if the original number is smaller than 1 then return it\n  if [ \"${d}\"\
    \ -lt 1 ]; then\n    echo \"0\"\n    return 0\n  fi\n\n  # find the decimal part\
    \ length\n  local d=0\n  while [ \"${v:0:1}\" == \".\" ]; do\n    v=\"${v:1}\"\
    \n    d=$(( ${d} + 1 ))\n  done\n\n  local i\n\n  # if the original number is\
    \ smaller than 1 then return it\n  if [ \"${d}\" -lt 1 ]; then\n    echo \"0\"\
    \n    return 0\n  fi\n\n  # now v is of form \"99.99\"\n  local frac\n\n  # if\
    \ d is odd, then v is 99.99, otherwise v is 99.999...\n  if [ \"${d}\" -eq 1 ];\
    \ then\n    if [ \"${#v}\" -eq 4 ]; then\n      v=\"${v:0:3}\"\n    else\n   \
    \   v=\"${v:0:2}\"\n    fi\n  fi\n\n  # now v is 99 if d is odd, or 99.999...\
    \ if d is even\n  local i\n  for i in {1..d}; do\n    frac=\"${frac}.${v:0:1}\"\
    \n    v=\"${v:1}\"\n  done\n\n  # we now have frac that has the form \"0....\"\
    \n  # now we must check if this frac can be represented as an integer\n  local\
    \ i\n  for i in {0..0}; do\n    local f=\"${frac}.${i}\"\n    local fint\n   \
    \ fint=$(python -c \"\n      import re;\n      print float(re.sub('0+$', '', re.sub('\\\
    \\.$', '', $f)))\n      \"\n    )\n    if [ \"${fint}\" == \"${f}\" ]; then\n\
    \      break\n    fi\n  done\n  unset i\n\n  # we now have the integer part of\
    \ the frac if possible\n  echo \"${frac}\"", "  # Avoid division by zero\n  local\
    \ IFS\n  IFS=.\n  # $1 is a floating point\n  local x=$1\n  # Get the integer\
    \ part and decimal part\n  local y=$(( $1 / $x ))\n  # Truncate decimal part\n\
    \  local z=$(( $x * $y ))\n  # Return integer part and decimal part\n  echo $z",
  "    local number=\"${1}\"\n    local trunc=0\n    local intpart\n    local decimals\n\
    \    while [[ -n \"$number\" ]]; do\n        intpart=\"${number%%.*}\"\n     \
    \   decimals=\"${number#$intpart}\"\n        trunc=$(( intpart*10 + $decimals\
    \ ))\n        number=\"${number%$decimals}\"\n    done\n    echo $trunc", "  \
    \  local x=\"${1}\"\n    local -a parts=($x)\n    local -i dec=${#parts[@]}\n\
    \    local -i factor=${#parts[0]}\n\n    if [ \"$dec\" -ne \"$factor\" ]; then\n\
    \        echo \"Truncating number $x to $dec decimal digits.\"\n        dec=0\n\
    \    fi\n\n    local -i i\n    i=0\n    while [ $((++i)) -lt \"$dec\" ];\n   \
    \ do\n        parts[$i]=$(expr \"$parts[$i]\" + \"1)\"\n    done\n\n    echo \"\
    ${parts[@]%.*}\"", "  truncate_number_str=$(echo \"$1\" | bc)\n  echo \"${truncate_number_str%%\\\
    .}\"", "    local string=\"$1\"\n    local intpart=\"1\"\n    local decimals=\"\
    0\"\n\n    if [[ $string == [+-]?[0-9]([.][0-9]*) ]]; then\n        intpart=$(echo\
    \ \"$string\" | sed -e 's/^[+-]\\?//g')\n        decimals=\"$(echo \"$string\"\
    \ | sed -e 's/^[+-]\\?//g' | sed -e 's/^[+-]\\([0-9]\\)//g' | sed -e 's/^\\([0-9.]\\\
    )//g')\"\n        if [[ $string =~ [+-]?[0-9]([.][0-9]*) ]]; then\n          \
    \  echo \"$intpart$decimals\"\n        else\n            echo \"$decimals\"\n\
    \        fi\n    else\n        echo \"$string\"\n    fi", "\tlocal number=\"$1\"\
    \n\tlocal decimals=${1%.*}\n\techo \"${decimals}\"", "    local NUMBER=\"$1\"\n\
    \    local IFS=.\n    local RESULT\n    local EXITCODE=0\n\n    # Sanitize input\n\
    \    # - If no number is given, we set the exit code.\n    # - If empty string\
    \ is given, we set the exit code.\n    # - If the number is invalid, we set the\
    \ exit code.\n    if [ -z \"$NUMBER\" ]; then\n        echo \"Missing number.\
    \ Exiting.\"\n        EXITCODE=1\n        exit $EXITCODE\n    fi\n    if [ \"\
    $NUMBER\" == \"\" ]; then\n        echo \"Invalid number. Exiting.\"\n       \
    \ EXITCODE=1\n        exit $EXITCODE\n    fi\n\n    # Strip leading and trailing\
    \ spaces and dots.\n    NUMBER=$(echo \"$NUMBER\" | sed -e 's/^[[:space:]]*//'\
    \ -e 's/[[:space:]]*$//')\n\n    # Strip trailing zeros.\n    NUMBER=$(echo \"\
    $NUMBER\" | sed -e 's/^0*$//')\n\n    # Remove leading and trailing dots.\n  \
    \  NUMBER=$(echo \"$NUMBER\" | sed -e 's/^\\.*//' -e 's/\\.*$//')\n\n    # Strip\
    \ extra leading 0s\n    NUMBER=$(echo \"$NUMBER\" | sed -e 's/^0*//')\n\n    #\
    \ Make sure number is positive.\n    if [ \"$NUMBER\" < 0 ]; then\n        echo\
    \ \"Invalid number. Exiting.\"\n        EXITCODE=1\n        exit $EXITCODE\n \
    \   fi\n\n    # If the number has only one digit, there is nothing to do.\n  \
    \  if [ ${#NUMBER} == 1 ]; then\n        echo \"Invalid number. Exiting.\"\n \
    \       EXITCODE=1\n        exit $EXITCODE\n    fi\n\n    # Truncate decimal part.\n\
    \    RESULT=$(echo \"$NUMBER\" | awk 'BEGIN{a=\"\";b=0}')\n    while [ \"$RESULT\"\
    \ -gt \"0\" ]; do\n        if [ \"$b\" == 0 ]; then\n            a=\"1\"\n   \
    \     else\n            a=\"$a\"\n        fi\n        b=`expr $b - 1`\n      \
    \  RESULT=$(echo \"$RESULT\" | awk 'BEGIN{a=\"\";b=0}')\n    done\n\n    # Return\
    \ the decimal part or 0.\n    if [ \"$RESULT\" -gt \"0\" ]; then\n        echo\
    \ $a\n    else\n        echo \"0\"\n    fi", "    local x=\"${1}\"\n    # truncate\
    \ x to 1 decimal place\n    # x is negative\n    if [[ $x =~ ([-+])([0-9]+\\.[0-9]+)\
    \ ]]; then\n        x=${BASH_REMATCH[1]}\n    fi\n    # x is positive\n    if\
    \ [[ $x =~ ([0-9]*\\.[0-9]+) ]]; then\n        x=${BASH_REMATCH[1]}\n    fi\n\
    \    echo \"$x\"", "  local float=$1\n  local num=0;\n  local dec=0;\n  local\
    \ decstr=0;\n  local laststr=0;\n\n  # find decimal point\n  for (( i=${#float}-2;\
    \ i>=0; i-- )); do\n    case ${float:$i:1} in\n      [Ee][-+]* )\n        decstr=$i;\n\
    \        laststr=${float:$i:1}\n        break\n        ;;\n      * ) break\n \
    \   esac\n  done\n  if [[ -z ${decstr} ]]; then\n    echo \"ERROR: input is not\
    \ in floating point format\"\n    return 1\n  fi\n\n  # find integer part\n  while\
    \ [[ ${#decstr} -gt 0 ]] && [[ ${decstr} -le ${#float} ]]; do\n    ((num+=${float:${#float}-1:${#float}-1}*10))\
    \ dec=${decstr}\n    laststr=${float:$((i-1)):1}\n    ((i--))\n  done\n  # if\
    \ there are no digits left in the input string,\n  # the result will be zero.\n\
    \  if [[ -z ${i} ]]; then\n    echo \"ERROR: input string has no digits left in\
    \ the floating point part\"\n    return 1\n  fi\n  ((dec=num%10))\n\n  # if decimal\
    \ is larger than 1, remove it\n  if [[ ${dec} -gt 1 ]]; then\n    echo \"${float:0:${#float}-1}.\"\
    \n  else\n    echo \"${float}\"\n  fi", "  if (( $# != 1 )) ; then\n    echo \"\
    Usage: $(basename $0) <number>\"\n    return 1\n  fi\n  local num=$1\n  local\
    \ i=$(( ${#num} - 1 ))\n  local frac\n  local fracstr=\"0.\"\n  while (( $i >\
    \ 0 )); do\n    frac=`echo ${num:i:1}`\n    fracstr=\"${fracstr}${frac}\"\n  \
    \  num=`expr $num \\% 10`\n    ((i--))\n  done\n  echo $fracstr"]
stop_tokens:
- "\n}"
