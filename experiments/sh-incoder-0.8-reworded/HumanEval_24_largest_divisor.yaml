name: HumanEval_24_largest_divisor
language: sh
prompt: "#!/bin/bash\n# For a given number n, find the largest number that divides\
  \ n evenly, smaller than n\n# >>> $(largest_divisor \"15\")\n# \"5\"\n#\n# $1 is\
  \ an integer\nlargest_divisor() {\n"
tests: "}\n\ncandidate() {\n    largest_divisor \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"3\") = \"1\" ]]\n    [[ $(candidate \"7\") = \"1\" ]]\n  \
  \  [[ $(candidate \"10\") = \"5\" ]]\n    [[ $(candidate \"100\") = \"50\" ]]\n\
  \    [[ $(candidate \"49\") = \"7\" ]]\n}\n\nrun_test"
completions: ["        (( $# )) || { echo \"Usage: $0 number\" >&2; exit 1; }\n\t\
    echo \"${1/$1/}\" \\\n\t\t| awk -F . '{if(($1 % $2 == 0)&&($1 % $3 == 0)){print}}'\
    \ \\\n\t\t| sort -r -n | head -n 1", "  local n result\n  n=$(echo \"$1\" | bc)\n\
    \  result=0\n  while (( (n%2) == 0)); do\n    n=n/2\n    result=$((result+1))\n\
    \  done\n  if (( n <= 1 )); then\n    echo \"0\"\n  else\n    echo \"$((result+1))\"\
    \n  fi", "    local a b i\n\n    a=$1\n    # Loop while $a is less than the number\
    \ to be divided\n    while [ $a -le $2 ]\n    do\n        # Calculate the remainder\n\
    \        b=$(( $a % $2 ))\n        # Check to see if the remainder is even or\
    \ odd\n        [ $b -eq 0 ] && break\n        # Increment the variable a to the\
    \ new remainder\n        a=$b\n    done\n    # Return the largest number less\
    \ than the number to be divided\n    echo $a", "  local n=$1\n  local max_divisor\n\
    \  local i\n\n  # Find the largest divisor >= n\n  for ((i=1; i<$n; i++))\n  do\n\
    \    local divisor\n    (( divisor=n / i ))\n    if (( divisor >= n ))\n    then\n\
    \      max_divisor=$i\n    else\n      max_divisor=$divisor\n    fi\n  done\n\n\
    \  echo \"$max_divisor\"", "  local number=$1\n  local factors\n  local max\n\n\
    \  max=1\n  while (( $(echo \"$number > 1\"); ));\n  while (( $number > 1 ));\n\
    \  do\n    factors=$(( (number % $max) + 1 ))\n    if [ $factors -gt 1 ]; then\n\
    \      max=$factors\n    elif [ $factors -eq 1 ]; then\n      echo \"$max\"\n\
    \      break\n    fi\n    number=$(( $number / $max ))\n  done", "    local number=$1\n\
    \    local maxnum=0\n    local max\n    local i\n    for ((i=2; i<=number/2; ++i));\
    \ do\n        if [ $((number/i)) -eq 0 ]; then\n            max=$i\n         \
    \   maxnum=$number\n            fi\n        fi\n    done\n    echo $maxnum", " \
    \ local -r n=\"$1\"\n  local -r max_divisor=1\n  local -r divisor\n  while ((\
    \ max_divisor <= n )); do\n    divisor=$(( max_divisor * 2 ))\n    if (( n % divisor\
    \ == 0 )); then\n      max_divisor=\"$divisor\"\n    fi\n  done\n  echo \"$max_divisor\"",
  '    echo "$1" | xargs -I {} sh -c "echo $(find {} -mindepth 1 -type d | sort -k
    1 | head -1 | xargs basename {} | wc -l) 2> /dev/null"', "  local n=$1\n  echo\
    \ $n | awk '{\n    for (i=1;i<=n;i++) {\n      if ( (n % i == 0) && (n != i))\
    \ {\n        j = i\n      }\n    }\n    print j\n  }'", "    number=$1\n\n   \
    \ while [[ $number -gt 1 ]]; do\n        (( number %= number ))\n        (( ++divisor\
    \ ))\n    done\n\n    echo \"$divisor\"", "    local num=\"$1\"\n    # Loop through\
    \ all the numbers starting from 100 and checking if they divide evenly\n    for\
    \ num in $(seq 1 100); do\n        if [ \"$(($num % $num))\" -eq \"$num\" ]; then\n\
    \            echo $num\n            break\n        fi\n    done", "    if [[ \"\
    $1\" -lt 1 ]]; then\n        return 1\n    fi\n\n    if [[ \"$1\" -le 9 ]]; then\n\
    \        echo \"$1\"\n    else\n        largest_divisor $(largest_divisor \"$((\
    \ $(echo \"$1\" / 5) | floor )+1)\")\n    fi", "    local n=$1\n\n    if [ $n\
    \ -lt 1 ]; then \n        echo \"$n is not positive\"\n        exit 1\n    elif\
    \ [ $n -eq 1 ]; then \n        echo \"$n is 1\"\n        exit 1\n    fi\n\n  \
    \  # Start from the smallest number, and decrease until we get to the smallest\n\
    \    # number that divides n evenly\n    local max_divisor=3\n    while [ $max_divisor\
    \ -le $n ]; do\n        if [ $(($n % $max_divisor)) -eq 0 ]; then break; fi\n\
    \        max_divisor=$max_divisor+1\n    done\n\n    # Return $max_divisor\n \
    \   echo \"$max_divisor\"", "  echo \"$1\" |\n  xargs -n1 -I% echo \"$(echo \"\
    $1\" %% $2 | bc)\"", "    local a b\n    a=$1\n    while [ $a -le $(( n - 1 ))\
    \ ]\n    do\n        b=$(( a + 1 ))\n        if [ $(b % $a) -eq 0 ]; then\n  \
    \          echo \"$b\"\n            exit 1\n        fi\n        a=$b\n    done",
  "  local n=$1\n  local max_divisor_count=0\n  local max_divisor=1\n  while [ $max_divisor_count\
    \ -lt $max_divisor ]\n  do\n    local max_divisor=$(echo \"$n\" | bc)\n    local\
    \ divisor_count=0\n    local divisor=1\n    while [ $divisor_count -lt $divisor\
    \ ]\n    do\n      (( divisor *= max_divisor ))\n      (( divisor_count += 1))\n\
    \    done\n    local remainder=$(( (n % divisor) + 1 ))\n    [ $remainder -lt\
    \ $divisor ] && max_divisor=$divisor\n    max_divisor_count=$divisor_count\n \
    \ done\n  echo \"$max_divisor\"", "    local n=\"$1\"\n    echo \"$n/2\" | bc\n\
    \    local max=0\n    while [[ $n -gt $max/2 ]]; do\n        n=$(( n / 2 ))\n\
    \        max=$max\n    done\n    echo \"$max\"", "    local n=$1\n    local max_so_far\n\
    \    max_so_far=1\n    local i\n    for i in $(seq 2 ${#n}); do\n        if [[\
    \ $(echo \"$n / $i\" | bc -l | awk '{print $1}') -eq 0 ]]; then\n            max_so_far=$i\n\
    \            break\n        fi\n    done\n    echo \"$max_so_far\"", "    local\
    \ divisor=$1 \n    local i\n    local max\n    for i in `seq 1 $divisor`; do\n\
    \        if [ $(( ($i % $divisor) == 0)) -eq 0 ]; then\n            ((max = i))\n\
    \            break\n        fi\n    done\n    echo \"$max\"", "    local number=$1\n\
    \    local max_num=$(echo $number | awk '{print $1*$1*$1*$1*$1*$1}')\n    local\
    \ num=2\n    local max_num2\n    while [ $num -le $max_num ]; do\n        local\
    \ num2=$(echo \"$num*$max_num\" | bc -l)\n        if [ $num2 -gt $max_num2 ];\
    \ then\n            max_num2=$num2\n        fi\n        (( num+=1 ))\n    done\n\
    \    echo $max_num2", "  local n=$1\n  local max=0\n  while [ $n -gt 1 ]; do\n\
    \    (( max = ( max % n )) || (( n = $n / 2 ) ))\n  done\n  echo $max", "    local\
    \ n=$1\n    local num\n    local divisor \n    local max_divisor\n\n    if [ $n\
    \ -lt 1 ]; then\n        echo \"Invalid input! Input must be a positive integer!\"\
    \ >&2\n        return 1\n    fi\n\n    # Initialize max divisor to 1 (i.e. the\
    \ first divisor)\n    max_divisor=1\n\n    # Loop through the divisor numbers\n\
    \    while [ $n -gt $max_divisor ]; do\n        # If the current divisor divides\
    \ n, the maximum divisor is it\n        if [ $n % $divisor -eq 0 ]; then\n   \
    \         max_divisor=$divisor\n        fi\n        ((divisor++))\n    done\n\n\
    \    echo \"$max_divisor\"", "    local n=\"${1}\"\n    local nDiv\n    local\
    \ maxDiv\n    nDiv=$(( (n-1)/( (( ( ${n%%} ))%2 )) + 1 ))\n    [ ! -z \"${nDiv}\"\
    \ ] && maxDiv=$nDiv\n    # echo \"nDiv=${nDiv}\"\n    # echo \"maxDiv=${maxDiv}\"",
  "  local -i j=$1\n  local -i remainder\n  local -i max\n\n  max=0\n\n  for ((j=1;\
    \ j<=i; j++)); do\n    remainder=$((${j} % ${i}))\n    if [ \"${remainder}\" -eq\
    \ 0 ]; then\n      remainder=$((${j} / ${i}))\n      max=$((${max} > ${remainder}\
    \ || ${max} < ${j} || ${max} == ${remainder}))\n    fi\n  done\n  echo $max",
  "    local num=\"$1\"\n    while [ $num -gt 1 ]; do\n        (( num--))\n      \
    \  if [ $((num%2)) == 0 ]; then\n            echo $num\n            return $num\n\
    \        fi\n    done", "\tdeclare -i n=$1\n\twhile (( n > 0 )); do\n\t\t(( n\
    \ = n / 2 ))\n\tdone\n\techo $n", "    local n=$1\n    local m=$((n-1))\n    while\
    \ [ $m -le 0 ]; do\n        if [ $((n%m)) -eq 0 ]; then\n            echo $((m))\n\
    \            break\n        fi\n        m=$((m-1))\n    done", "  local number=$1\n\
    \  local divisor=1\n  local max_value\n\n  max_value=0\n\n  # Iterate from 1 to\
    \ $number\n  for (( i=1; i <= number; i++ )); do\n    local remainder=$(( number\
    \ % divisor ))\n    if [[ $remainder -eq 0 ]]; then\n      max_value=$divisor\n\
    \      break\n    elif [[ $max_value -eq $divisor ]]; then\n      divisor=$max_value\n\
    \    fi\n  done\n  echo $max_value", "    local n=$1\n    echo \"$(( ${n} / $(count_divisors\
    \ $n) ))\"", "  local n=$1\n  local largest_div=1\n  local div\n\n  until [[ $n\
    \ -eq 0 ]]; do\n    div=$((n/div))\n    [ $div -gt $largest_div ] && { largest_div=$div;\
    \ }\n    n=$((n/div))\n  done\n  echo \"$largest_div\"", "  if [ $1 -eq 0 ]; then\n\
    \    echo 0\n    return\n  fi\n  # Make sure $1 is odd\n  (( is_odd_num=\"${1}\"\
    \ ));\n  (( $is_odd_num % 2 != 0 ));\n  # $2 is n / 2\n  (( div=\"${2}/2\" ));\n\
    \  (( div < 2 ));\n  (( div++ ));\n  \n  while [ $1 -gt 0 ]; do\n    if (( $div\
    \ == 0 )); then\n      # Exit if $1 is even\n      echo \"$1\"\n      break\n\
    \    fi\n    # $div is less than $2\n    (( div-- ));\n    (( is_odd_num=\"${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}${is_odd_num}",
  "    local number=$1\n    local largest_divisor=0\n    local divisor_found=1\n \
    \   local divisor_candidate\n    while [ $divisor_found -ne 1 ]; do\n        divisor_candidate=$((\
    \ $number % $divisor_found ))\n        if [ $divisor_candidate -eq 0 ]; then\n\
    \            largest_divisor=$divisor_found\n            divisor_found=1\n   \
    \     else\n            divisor_found=$divisor_candidate\n        fi\n    done\n\
    \    echo \"$largest_divisor\"", "    local n=$1\n    local max_divisor\n    local\
    \ max_divisor2\n    local max_divisor3\n\n    # Handle negative numbers specially\
    \ so we don't get zero division\n    if [[ \"$n\" == -* ]]; then\n        n=$((\
    \ ${n}*2 ))\n    fi\n\n    for (( divisor = 2; divisor <= n; divisor++ )); do\n\
    \        (( max_divisor = divisor ))\n        (( max_divisor2 = divisor ))\n \
    \       (( max_divisor3 = divisor ))\n\n        for (( divisor2 = 0; divisor2\
    \ < divisor; divisor2++ )); do\n            if [[ $(( ${n} % divisor )) -eq 0\
    \ ]]; then\n                (( max_divisor = divisor ))\n            fi\n    \
    \    done\n\n        for (( divisor2 = 0; divisor2 < max_divisor; divisor2++ ));\
    \ do\n            if [[ $(( ${n} % max_divisor )) -eq 0 ]]; then\n           \
    \     (( max_divisor2 = max_divisor ))\n            fi\n        done\n\n     \
    \   for (( divisor2 = 0; divisor2 < max_divisor2; divisor2++ )); do\n        \
    \    if [[ $(( ${n} % max_divisor2 )) -eq 0 ]]; then\n                (( max_divisor3\
    \ = max_divisor2 ))\n            fi\n        done\n\n        if [[ $max_divisor\
    \ -gt $max_divisor2 ]]; then\n            if [[ $max_divisor2 -gt $max_divisor3\
    \ ]]; then\n                echo \"$max_divisor\"\n            elif [[ $max_divisor3\
    \ -gt $max_divisor ]]; then\n                echo \"$max_divisor2\"\n        \
    \    else\n                echo \"$max_divisor3\"\n            fi\n        fi\n\
    \    done", "  local number=$1\n  local max_div\n  local divisor\n  local remainder\n\
    \  local max_divisor\n  local max_number\n  while true ; do\n    divisor =$((\
    \ $number % 2 ))\n    remainder =$(( $number % $divisor ))\n    if [ \"$divisor\"\
    \ -eq 0 ] ; then\n      max_div=$(( $divisor + 1 ))\n      max_divisor=$(( $divisor\
    \ ))\n      max_number=$number\n    fi\n    if [ \"$remainder\" -eq 0 ] ; then\n\
    \      break\n    fi\n    max_div=$(( $divisor + 1 ))\n    max_divisor=$divisor\n\
    \    max_number=$number\n    number=$(( $number / $divisor ))\n  done\n  echo\
    \ $max_div\n  echo $max_divisor\n  echo $max_number", "  echo \"$1\" | awk '{\
    \ n=int(\"$1\"/3); print n; }'", "    local N=$1\n    local max_div\n    local\
    \ div\n    local i\n\n    max_div=0\n    div=1\n    for(( i=1; i<=$N; i++ ));\
    \ do\n        if [ $(( N % i )) -eq 0 ]; then\n            div=$i\n          \
    \  if (( div > max_div )); then\n                max_div=$div\n            fi\n\
    \        fi\n    done\n    echo \"$max_div\"", "  local n d\n  for n in \"$@\"\
    ; do\n    for d in $(seq 1 $((n - 1)) 2> /dev/null); do\n      if (( n % d ==\
    \ 0 )); then\n        echo \"$n\"\n        return\n      fi\n    done\n  done",
  "    local n max_divisor divisor current_divisor\n    n=$1\n    max_divisor=1\n\
    \    current_divisor=1\n    while [ $current_divisor -ge 1 ]; do\n        if [\
    \ $n -eq $divisor ]; then\n            max_divisor=$divisor\n        fi\n    \
    \    (( divisor *= current_divisor ))\n        (( current_divisor -= 1 ))\n  \
    \  done\n    echo \"$max_divisor\"", "    local n=\"$1\"\n    if [ \"$n\" == \"\
    0\" ]; then return 0; fi # n == 0 is a special case\n    if [ -z \"$n\" ]; then\
    \ return $n; fi\n    # find divisor of n by dividing by all other numbers from\
    \ 1 to n\n    local divisor=1\n    local max_divisor\n    while [ $divisor -le\
    \ $n ]; do\n        max_divisor=$divisor\n        ((divisor+=1))\n    done\n\n\
    \    local max_divisor_value\n    for ((divisor=max_divisor; divisor>=1; divisor--));\
    \ do\n        if [ $((n % divisor)) -eq 0 ]; then break; fi\n    done\n    \n\
    \    # convert back to integer\n    max_divisor_value=\"$((max_divisor+1))\"\n\
    \    \n    if [ $divisor -eq $n ]; then \n        return $max_divisor_value #\
    \ largest divisor of n is n\n    else\n        echo \"ERROR: divisor of $n with\
    \ $max_divisor_value is not evenly divisble by all numbers from 1 to $n.\"\n \
    \       return 1\n    fi", "  local number=$1\n  local max_divisor\n  local last_divisor\n\
    \  max_divisor=1\n  last_divisor=1\n  while [ $last_divisor -le $number ]; do\n\
    \    if (( $last_divisor % $number )); then\n      last_divisor=$(( $last_divisor\
    \ + 1 ))\n      max_divisor=$last_divisor\n    else\n      last_divisor=1\n  \
    \  fi\n  done\n  echo $max_divisor", "    echo \"$1 cannot be divided evenly.\
    \ Null is returned\"\n    return 0", "  local n=\"$1\"\n  local divisor\n  local\
    \ max\n  local min\n  local maxNum\n\n  if [[ \"$n\" < 1 ]]; then\n    echo \"\
    $n is negative\"\n    return 1\n  fi\n\n  local numbers=$(seq 1 \"$n\")\n\n  maxNum=${numbers[-1]}\n\
    \  max=${maxNum}\n\n  min=${numbers[0]}\n\n  while (( ${#numbers} > 0 ))\n  do\n\
    \    divisor=$(( ${numbers[-1]} / ${numbers[0]} ))\n    if [[ \"$max\" -lt \"\
    $divisor\" ]]; then\n      max=$divisor\n    fi\n    numbers=(${numbers[@]/$divisor/})\n\
    \n    min=${numbers[0]}\n  done\n\n  echo \"$max\"", "  local n=\"$1\"\n  local\
    \ d=0\n  while [ \"$d\" -lt \"$n\" ]; do\n    local m=$(( $n % $d ))\n    if [\
    \ $m -eq 0 ]; then\n      d=$(( $d + 1 ))\n    else\n      n=$(( $n - $m ))\n\
    \    fi\n  done\n  echo $d", "  local -r num=\"$1\"\n  local -r max_divisor\n\
    \  max_divisor=$(echo \"$num\" | cut -d ' ' -f 1 | sort -g | tail -n 1)\n  for\
    \ (( divisor = 2; divisor <= $max_divisor; divisor++ )); do\n    if [ $num % $divisor\
    \ -eq 0 ]; then\n      echo \"$divisor\"\n      break\n    fi\n  done", "\tlocal\
    \ number=$1\n\tlocal divisor=\n\tlocal max_divisor=\n\tlocal remainder\n\n\tfor\
    \ ((i=1; i <= number; i++)); do\n\t\tif [[ \"$i\" == \"$number\" ]]; then\n\t\t\
    \techo \"$i\"\n\t\t\treturn\n\t\tfi\n\t\tif [[ $((i % $divisor)) == 0 ]]; then\n\
    \t\t\tdivisor=$((divisor+1))\n\t\t\tif [[ $divisor -gt \"$max_divisor\" ]]; then\n\
    \t\t\t\tmax_divisor=$divisor\n\t\t\tfi\n\t\tfi\n\tdone\n\n\techo \"$max_divisor\"",
  "\tlocal number=$1\n\n\t# Find the largest divisor that is smaller than the given\
    \ number\n\tfor divisor in $(seq 3 $number); do\n\t\tif [ $(( number % divisor\
    \ )) == 0 ]; then\n\t\t\techo \"$divisor\"\n\t\t\tbreak\n\t\tfi\n\tdone", "  local\
    \ n=\"$1\"\n  if (( n <= 0 )) ; then\n    echo \"$n: invalid argument\"\n    exit\
    \ 1\n  fi\n  local max_div=\"$(echo \"$n-1\" | bc)\"\n  while (( \"$max_div\"\
    \ > 0 )); do\n    if (( \"$max_div\" > \"$n\" )) ; then\n      max_div=\"$n\"\n\
    \    fi\n    (( \"$max_div\" -= 2 ))\n  done\n  echo \"$max_div\"", "  local number=$1\n\
    \  local divisor\n  local max\n  local i\n  max=\"${number}\"\n  for ((i=2; i<=number;\
    \ i++)); do\n    divisor=$(echo \"$number % $i\" | bc)\n    if [ \"$divisor\"\
    \ == \"0\" ]; then\n      max=$i\n      break\n    fi\n  done\n  echo \"$max\"",
  "\t[ $# -ne 1 ] && echo \"usage: $0 integer\" >&2 && return\n\tlocal integer=\"\
    $1\"\n\t[ \"$integer\" -eq 1 ] && return 1\n\tlocal i\n\ti=1\n\twhile [ $i -le\
    \ ${integer} ]; do\n\t\tlocal imax\n\t\timax=$(( ${integer} * $(( 10#$(( ${integer}+1\
    \ )) )) ))\n\t\t[ $imax -ge $integer ] && return $imax\n\t\ti=$(( i+1 ))\n\tdone",
  "    local n divisor\n    n=$1\n    # Iterate through all divisors of n\n    for\
    \ ((divisor=1; divisor<=n; divisor++))\n    do\n        if [ $(( $(expr $divisor\
    \ / $n) % 2)) -eq 0 ]\n        then\n            echo \"$divisor\"\n        fi\n\
    \    done", "  local n result\n  n=$1\n  result=0\n  # Iterate from 1 to sqrt(n)\
    \ and check if each number divides n evenly.\n  for (( i=1; i<=sqrt(n); i++ ));\
    \ do\n    (( n % i == 0 )&& result=i)\n  done\n  echo $result", "  local arg=\"\
    $1\"\n  if [ -z \"$arg\" ] ; then\n    echo 0\n  else\n    local d=0\n    while\
    \ [ \"$d\" -lt \"$arg\" ] ; do\n      ((d+=2))\n    done\n    echo \"$d\"\n  fi",
  "  local number=$1\n  local max_num\n  local remainder\n  for (( i=2; i<$((${#number}));\
    \ i++ )); do\n    remainder=$(( $number % $i ))\n    if [[ \"$remainder\" -eq\
    \ 0 ]]; then\n      max_num=$i\n      break\n    fi\n  done\n  echo \"$max_num\"",
  "  local number=$1\n  local largest_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count\n  local last_divisor\n  local divisor_count\n  local last_divisor\n\
    \  local divisor_count", "  local n x\n  n=$1\n  ((n > 0)) || return $?\n  for\
    \ ((x=2; x * x <= n; x++)); do\n    [[ $((n % x)) -eq 0 ]] && return $x\n  done",
  "  if [ \"$1\" = \"1\" ]; then\n    echo 1\n  else\n    while [ \"$1\" -gt 0 ];\
    \ do\n      echo $(( $(echo \"$1 divides n evenly\" | bc -l) / $(echo \"$1\" |\
    \ bc -l) ))\n      shift\n    done\n  fi", "    local i n num\n    local max_divisor\
    \ max_divisor_or_one\n    # Convert $1 into integer\n    i=\"$1\"\n    # Initialize\
    \ max divisor to 1 and max divisor or one to 1\n    n=1\n    max_divisor_or_one=1\n\
    \    # While $n is greater than or equal to 1\n    while [ $n -gt 0 ]; do\n  \
    \      # Divide n by 2 and add it to the number of divisors\n        (( n%2 )\n\
    \        (( n+=1 ))\n        )\n        # Keep the largest divisor so far\n  \
    \      if [ $n -gt $max_divisor_or_one ]; then\n            max_divisor=\"$n\"\
    \n        fi\n        # Update max divisor or one and n if the new divisor is\
    \ greater than current max\n        if [ $n -gt $max_divisor ]; then\n       \
    \     max_divisor_or_one=\"$n\"\n        fi\n    done\n    echo \"$max_divisor\"",
  "    n=$1\n    n=$((n+1))\n    answer=0\n    while [ \"$n\" -ge 1 ]\n    do\n  \
    \      (( n-- ))\n        (( answer++ ))\n    done\n    echo \"$answer\"", " \
    \ local -n a=$1\n  local a1=0;\n  local a2=0;\n  local a3=0;\n  local a4=0;\n\
    \  local a5=0;\n  local a6=0;\n  local a7=0;\n  local a8=0;\n  local a9=0;\n \
    \ local a10=0;\n  local a11=0;\n  local a12=0;\n  local a13=0;\n  local a14=0;\n\
    \  local a15=0;\n\n  a=`seq $a -1`;\n  for i in $a; do\n    for j in $a; do\n\
    \      if [ \"$j\" == \"$i\" ]; then\n        continue;\n      fi\n      if [\
    \ $(( (j%$i)+$a1 )) -gt $a1 ]; then\n        a1=$(( (j%$i)+$a1 ));\n      fi\n\
    \      if [ $(( (j%$i)+$a2 )) -gt $a2 ]; then\n        a2=$(( (j%$i)+$a2 ));\n\
    \      fi\n      if [ $(( (j%$i)+$a3 )) -gt $a3 ]; then\n        a3=$(( (j%$i)+$a3\
    \ ));\n      fi\n      if [ $(( (j%$i)+$a4 )) -gt $a4 ]; then\n        a4=$((\
    \ (j%$i)+$a4 ));\n      fi\n      if [ $(( (j%$i)+$a5 )) -gt $a5 ]; then\n   \
    \     a5=$(( (j%$i)+$a5 ));\n      fi\n      if [ $(( (j%$i)+$a6 )) -gt $a6 ];\
    \ then\n        a6=$(( (j%$i)+$a6 ));\n      fi\n      if [ $(( (j%$i)+$a7 ))\
    \ -gt $a7 ]; then\n        a7=$(( (j%$i)+$a7 ));\n      fi\n      if [ $(( (j%$i)+$a8\
    \ )) -gt $a8 ]; then\n        a8=$(( (j%$i)+$a8 ));\n      fi\n      if [ $((\
    \ (j%$i)+$a9 )) -gt $a9 ]; then\n        a9=$(( (j%$i)+$a9 ));\n      fi\n   \
    \   if [ $(( (j%$i)+$a10 )) -gt $a10 ]; then\n        a10=$(( (j%$i)+$a10 ));\n\
    \      fi\n      if [ $((", "  local n=\"$1\"\n  local max_divisor\n\n  max_divisor=$(gshuf\
    \ -e ${n} ${n}-1 | head -n 1)\n\n  while [ \"$max_divisor\" -gt \"0\" ]; do\n\
    \    if [ $(($max_divisor % 2)) -eq 0 ]; then\n      # $max_divisor divides evenly\
    \ into $n, so return it\n      echo $max_divisor\n      return\n    fi\n    #\
    \ $max_divisor does not divide evenly into $n; keep looking\n    max_divisor=$(gshuf\
    \ -e ${n} ${max_divisor}-1 | head -n 1)\n  done", "\tlocal number=$1\n\tlocal\
    \ biggest\n\t\n\t# If n is even, no divisors are possible\n\tif [ $(($number %\
    \ 2)) -eq 1 ]\n\tthen\n\t\techo $1\n\t\n\t# If n is odd, find largest divisor\
    \ by trial division\n\telse\n\t\tfor i in $(seq 1 $(( $number / 2 ))); do\n\t\t\
    \t\n\t\t\t# if number is even, divide it by 2, return it\n\t\t\tif [ $(($number\
    \ % 2)) -eq 0 ]\n\t\t\tthen\n\t\t\t\tbiggest=$i\n\t\t\t\tbreak\n\t\t\t\t\n\t\t\
    \t# if number is odd, divide it by 2, add 1, and return the biggest value\n\t\t\
    \telse\n\t\t\t\tbiggest=$(($i * $i))\n\t\t\t\n\t\t\t\t# if divisor is larger,\
    \ return it\n\t\t\t\tif [[ $biggest -gt $number ]]\n\t\t\t\tthen\n\t\t\t\t\tbreak\n\
    \t\t\t\t\n\t\t\t\t# if divisor is smaller, do not return it\n\t\t\t\telse\n\t\t\
    \t\t\tcontinue\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\n\t\t# Return the largest divisor\n\
    \t\techo ${biggest}\n\tfi", "\tif (( ! $1 )) then\n\t\techo \"No number provided\"\
    \n\t\treturn\n\tfi\n\tlocal n=$1\n\tlocal max=0\n\tlocal i\n\tfor i in $(seq 1\
    \ $n); do\n\t\tif (( $i % 2 == 0 )); then\n\t\t\tif (( $n % i == 0 )); then\n\t\
    \t\t\tmax=$i\n\t\t\tfi\n\t\tfi\n\tdone\n\techo $max", "  # First try the usual\
    \ solution\n  local divisor=$1\n  local max_divisor=1\n  for divisor_count in\
    \ $(seq 1 ${divisor}); do\n    if [ ${divisor} -eq ${max_divisor} ]; then\n  \
    \    max_divisor=$divisor\n    else\n      max_divisor=$((max_divisor * divisor_count))\n\
    \    fi\n  done\n  echo \"${max_divisor}\"", "  local n=$1\n  local max_divisor\n\
    \  local divisor_count\n\n  max_divisor=1\n  divisor_count=1\n  while [ $n -le\
    \ $max_divisor ]; do\n    if [ $((n%$max_divisor)) -eq 0 ]; then\n      divisor_count=$((divisor_count+1))\n\
    \      if [ $divisor_count -gt $max_divisor ]; then\n        max_divisor=$divisor_count\n\
    \      fi\n    fi\n    n=$((n/$max_divisor))\n  done\n  echo \"$max_divisor\"",
  "    local i n max_divisor result\n    printf -v n \"%i\" \"$1\"\n    for ((i=1;\
    \ i<=n; i+=1)); do\n        if [ \"`expr $i % $n \\* $n % $n \\* $n % $n \\* $n\
    \ % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n\
    \ \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\*\
    \ $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n % $n \\* $n %\
    \ $n \\* $n % $n \\* $n % $n \\* $n % $n`\" -eq 0 ]; then\n            max_divisor=\"\
    $i\"\n        fi\n    done\n    echo \"$max_divisor\"", "  local x=\"$1\"\n  local\
    \ y\n  local n\n  local divisor\n  local output\n\n  n=0\n  while (( x /= 2 ));\
    \ do n=$(expr $n + 1); done\n\n  divisor=$n\n\n  while (( $divisor > 0 )); do\n\
    \    if (( $n % $divisor )); then\n      divisor=$n\n    else\n      (( n /= divisor\
    \ ))\n    fi\n  done\n\n  output=$divisor\n\n  echo \"$output\"", "    local x=\"\
    $1\"\n    local y\n    if [ \"--help\" == \"$1\" ] ; then \n        echo \"Usage:\
    \ $(basename $0) [integer]\" >&2\n        return 1\n    elif [ \"--help\" == `echo\
    \ $1 $2` ] ; then\n        echo \"Usage: $(basename $0) [integer]\" >&2\n    \
    \    return 1\n    else\n        local n=\"1\"\n        local i\n        for ((\
    \ ; n <= ${#x}; n++ ))\n        do\n            (( i = n/${x//[!0-9]/} ))\n  \
    \          if [ $i -eq $n ] ; then\n                y=\"$n\"\n               \
    \ break\n            fi\n        done\n        echo $y\n        return $?\n  \
    \  fi", "    local n divisor divisor_list divisor_sum divisor_max\n    local count=0\n\
    \    n=$1\n    divisor_list=($(echo \"scale=2;${n}\"|bc -l))\n    divisor_sum=0\n\
    \    divisor_max=0\n    for divisor in ${divisor_list[@]}; do\n        (( divisor_sum\
    \ += divisor ))\n        if [ ${divisor_sum} -gt ${divisor_max} ]; then\n    \
    \        divisor_max=${divisor_sum}\n        fi\n    done\n    echo \"$divisor_max\"",
  "  local n=\"$1\"\n  local max_factor=1\n  local max_factor=1\n\n  while (( $n >\
    \ 1 )); do\n    (( n % max_factor ))\n    (( max_factor *= 2 ))\n    (( n /= max_factor\
    \ ))\n  done\n\n  echo $max_factor", "  local NUM=${1:?'Number is not an integer'}\n\
    \n  for (( i=1; i <= $NUM; i++ )); do\n    if (( $i % $NUM )); then\n      echo\
    \ \"$i\"\n      break\n    fi\n  done", "    local n=$1\n    local maxdiv\n  \
    \  local maxdiv_index\n    local divisor\n    local divisor_index\n\n    for i\
    \ in $(seq 1 $n); do\n        divisor=`echo $i | bc`\n        if [[ $divisor ==\
    \ 0 ]]; then\n            continue\n        fi\n        for j in $(seq 0 $((n-1)));\
    \ do\n            if [[ $j -eq $((i-1)) ]]; then\n                continue\n \
    \           fi\n            divisor_index=$(echo $j | bc)\n            if [[ $divisor_index\
    \ -eq $divisor ]]; then\n                if [[ $divisor_index -gt $maxdiv_index\
    \ ]]; then\n                    maxdiv=$divisor\n                    maxdiv_index=$divisor_index\n\
    \                fi\n            fi\n        done\n    done\n\n    echo \"$maxdiv_index\"",
  "  declare -r n=$1\n  while true; do\n    (( n -= 2 ))\n    test $((n % 2)) -eq\
    \ 0\n    if test $n -lt $n; then\n      echo $n\n      return 0\n    fi\n  done",
  "    local i\n    local n\n    for (( i = 0; i < $1; i++ )); do\n        (( n =\
    \ $i * 2 ))\n        if ( test $(($n % 2)) -eq 0 ) then\n            echo \"$n\"\
    \n            break\n        fi\n    done", "  local max_divisor_num=$1\n  local\
    \ divisor_num\n  local divisor_nums\n  local max_divisor_nums\n  local max_divisor_nums\n\
    \  local max_divisor_num\n  local max_divisor_num_count\n  local max_divisor_num_count\n\
    \n  divisor_nums=$(\n    # count how many divisors we can get from max_divisor_num\n\
    \    for((i=1; i<=${max_divisor_num}; i++)) ; do\n      for((j=1; j<=i; j++))\
    \ ; do\n        test $(( i % $j )) -eq 0\n        (( divisor_nums++ ))\n     \
    \ done\n    done\n  )\n\n  if (( divisor_nums <= max_divisor_nums )) ; then\n\
    \    return 0\n  fi\n\n  max_divisor_num=$(\n    # get the first max_divisor_nums\n\
    \    for((i=1; i<=${max_divisor_num}; i++)) ; do\n      for((j=1; j<=i; j++))\
    \ ; do\n        test $(( i % $j )) -eq 0\n        max_divisor_num=$(( max_divisor_num\
    \ > $j ? $j : $max_divisor_num ))\n      done\n    done\n  )\n\n  max_divisor_num_count=$(\n\
    \    # count how many max_divisor_nums we can get from max_divisor_num\n    for((i=1;\
    \ i<=${max_divisor_num}; i++)) ; do\n      for((j=1; j<=i; j++)) ; do\n      \
    \  test $(( i % $j )) -eq 0\n        (( max_divisor_num_count++ ))\n      done\n\
    \    done\n  )\n\n  # find max_divisor_num that has most divisors\n  max_divisor_nums=$(\n\
    \    # get the second max_divisor_nums\n    for((i=1; i<=${max_divisor_num_count};\
    \ i++)) ; do\n      for((j=1; j<=i; j++)) ; do\n        test $(( i % $j )) -eq\
    \ 0\n        max_divisor_nums=$(( max_divisor_nums > $j ? $j : $max_divisor_nums\
    \ ))\n      done\n    done\n  )\n\n  if (( max_divisor_nums <= max_divisor_num\
    \ )) ; then\n    return 0\n  fi\n\n  max_divisor_num=$(\n    # get the third max_divisor_nums\n\
    \    for((i=1; i<=${max_divisor_nums}; i++)) ; do\n      for((", "\t# This algorithm\
    \ is from http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\t# We compute primes\
    \ in reverse order, so that the first n is prime\n\t# For a given n, we compute\
    \ the next n that are divisible by the current one\n\t# For a given n, we check\
    \ if it is divisible by the next ones, and if not, we remove the next ones\n\t\
    local i prime nextDivisor divisor\n\n\ti=2\n\tnextDivisor=1\n\twhile [ $i -le\
    \ $1 ]\n\tdo\n\t\t# if i is prime, add it to prime list\n\t\tif [ $(( prime %\
    \ 2 )) == 0 ]; then\n\t\t\tprime=\"$prime\"\n\t\tfi\n\t\t# if i is prime, add\
    \ it to prime list\n\t\tif [ $(( prime % 3 )) == 0 ]; then\n\t\t\tprime=\"$prime\"\
    \n\t\tfi\n\t\t# if i is prime, add it to prime list\n\t\tif [ $(( prime % 5 ))\
    \ == 0 ]; then\n\t\t\tprime=\"$prime\"\n\t\tfi\n\n\t\t# if i is divisible by nextDivisor,\
    \ remove it from nextDivisor and prime list\n\t\tdivisor=$(( nextDivisor ))\n\t\
    \tif [ $(( nextDivisor % i )) == 0 ]; then\n\t\t\tnextDivisor=\"$nextDivisor\"\
    \n\t\t\tprime=\"$prime$nextDivisor\"\n\t\tfi\n\t\ti=$(( $i + 1 ))\n\tdone\n\t\
    echo $prime", "\twhile [ $1 -gt 0 ]; do\n\t\t[ \"$(( 1 % $1 ))\" -eq 0 ] && return\n\
    \t\t(( 1 = $1 ))\n\tdone\n\techo \"$1\"", "\tlocal num=\"$1\"\n\tlocal ret=\"\
    $2\"\n\tlocal digit=\"$1\"\n\tlocal factor=\"1\"\n\tlocal i\n\tlocal factor_count=1\n\
    \twhile (( factor*factor <= num )); do\n\t\t((factor++))\n\t\t((factor_count++))\n\
    \tdone\n\tfor ((i=1; i<=factor_count; i++)); do\n\t\tif [ \"$(( factor*factor\
    \ < num ))\" -gt \"$ret\" ]; then\n\t\t\tret=\"$(( factor*factor ))\"\n\t\t\t\
    digit=\"$i\"\n\t\tfi\n\tdone\n\techo \"$digit\"", "    local n=$1\n    local count=0\n\
    \    local divisor\n    for divisor=2\n    do\n        if [ \"$n\" -eq \"$divisor\"\
    \ ];\n        then\n            count=$((count+1))\n            if [ \"$count\"\
    \ -ge \"$2\" ]; then\n                echo \"$divisor\"\n                break\n\
    \            fi\n        fi\n    done", "  n=$1\n  (( n /= 2 ))\n  while (( $n\
    \ % 2 != 0 )); do\n    (( n-- ))\n  done\n  echo $n", "\tlocal number=$1\n\tlocal\
    \ max_divisor_num=$(python -c '\n\t\tfrom math import gcd\n\t\tdef largest_divisor(n):\n\
    \t\t\tif n % 2 == 0:\n\t\t\t\tfor i in range(1, n / 2 + 1):\n\t\t\t\t\tif gcd(i,\
    \ n) == 1:\n\t\t\t\t\t\treturn i\n\t\t\t\treturn n\n\t\t\telif n > 1:\n\t\t\t\t\
    return largest_divisor(n - 1)\n\t\t\telse:\n\t\t\t\treturn 1\n\t\tprint(largest_divisor(number))\n\
    \t\t')\n\techo \"$max_divisor_num\"", "  local n=$1\n  local div\n  ((n > 1))\
    \ || return 0\n  ((div = n)) || return 0\n  ((div > 5)) || return 0\n  while ((div\
    \ > 1)); do\n    ((div = div % n)) && return $div\n    ((div = n)) && return $div\n\
    \  done", "    local number=$1\n    echo \"$(( $(( $(divide $number 0 ) % 2 ))\
    \ ))\"", "  local n=\"$1\"\n  local max_divisor\n  local max_divisor_value\n \
    \ local max_divisor_counter\n  local max_divisor_counter_value\n\n  if (( n <=\
    \ 1 )); then\n    echo \"$1\"\n  else\n    max_divisor=$((n-1))\n    max_divisor_value=$n\n\
    \    max_divisor_counter=\n    max_divisor_counter_value=1\n    while (( $max_divisor_counter\
    \ <= max_divisor )); do\n      local next_divisor_value=$(( max_divisor_counter_value*max_divisor_counter_value\
    \ ))\n      local next_divisor_value_in_max_divisor=$(( $next_divisor_value +\
    \ max_divisor_counter_value ))\n      local next_divisor=$(( $next_divisor_value_in_max_divisor\
    \ / max_divisor_counter_value ))\n      if (( $next_divisor_value == $max_divisor_counter_value\
    \ )); then\n        echo \"$next_divisor\"\n      else\n        echo \"$next_divisor\"\
    \n      fi\n      max_divisor=$(( next_divisor ))\n      max_divisor_value=$next_divisor_value_in_max_divisor\n\
    \      max_divisor_counter=$(( max_divisor_counter + 1 ))\n      max_divisor_counter_value=$next_divisor_value_in_max_divisor\n\
    \    done\n  fi", "  local n=$1 divisor=$2\n  local max count\n\n  max=0\n  count=0\n\
    \n  while [ \"$n\" -gt \"$max\" ]; do\n    (( n /= divisor ))\n    (( count++\
    \ ))\n  done\n\n  echo \"$max\"", "    local n=$1\n    local highest_divisor_of_n\n\
    \    local divisor\n\n    if [ $n -gt 0 ]; then\n        highest_divisor_of_n=0\n\
    \        divisor=1\n        while [ $divisor -le $n ] && [ $divisor -gt 0 ]; do\n\
    \            (( divisor = divisor + 1 ))\n        done\n        if [ $divisor\
    \ -lt $n ]; then\n            echo \"$n\"\n        fi\n    else\n        echo\
    \ \"0\"\n    fi", "  local n=\"$1\"\n  local i\n  local max\n  for i in $(seq\
    \ 1 $n); do\n    if (( (n%i == 0) && (n != i)) ); then\n      max=\"$i\"\n   \
    \ fi\n  done\n  echo \"$max\"", "  local x\n  x=\"$1\"\n  local n\n  n=`echo \"\
    $x\" | awk '{ printf \"%d\\n\",$1 }'`\n  while [ $x -gt 0 ]; do\n    local m\n\
    \    m=`echo \"$x/$n\" | awk '{ printf \"%d\\n\",$1 }'`\n    if [ \"$m\" -eq 0\
    \ ]; then\n      echo \"$n\"\n      break\n    fi\n    n=$m\n    x=$((n-1))\n\
    \  done\n  exit 1", "  local i result\n  i=$1\n  result=$(expr $i / 2)\n  while\
    \ [ $i -gt 0 ]; do\n    if [ $i -eq 0 ]; then break; fi\n    ((i % 2 != 0)) &&\
    \ result=$((result - 1))\n    i=$(expr $i / 2)\n  done\n  echo \"$result\"", " \
    \   local x y\n    if [ $# -ne 1 ] ; then\n       echo \"Usage: $(basename $0)\
    \ number\"\n       echo \"  where 'number' is an integer greater than 1\"\n  \
    \     exit $?\n    fi\n    y=$1 \n    while [ $((y%2)) -eq 0 ]; do\n       x=$((y*y))\n\
    \       if (( $x==$y )); then\n          y=$x\n       else\n          y=$x\n \
    \      fi\n    done\n    echo $y", "  local NUM=$1\n  local MAX=$(($NUM-1))\n\n\
    \  while [ $(($MAX)) -ge $(($NUM/2)) ]\n  do\n    let MAX-=1\n  done\n\n  echo\
    \ $(($MAX + 1))", '    echo $(( ($1 % $2) == 0 )) | bc', "    local n max_n max_div\
    \ divisor div divs\n    read -r \"$1\" n\n    max_n=$n\n    max_div=0\n    divs=$(seq\
    \ -w \"$n\" \"$n\")\n    for div in $divs; do\n        (( div == 0 || div % 2\
    \ == 0 )) || continue\n        if [ \"$div\" -gt \"$max_div\" ]; then\n      \
    \      max_div=$div\n            max_n=$n\n        fi\n    done\n    echo \"$max_n\"",
  "    local -r number=\"$1\"\n    local -r max > /dev/null\n    max=0\n    for i\
    \ in $(seq 2 $((number/2))); do\n        local -r current=$((number % i))\n  \
    \      [ $current -eq 0 ] && { max=$i; break; }\n    done\n    echo \"$max\"",
  "    local i n\n    # loop through all numbers starting from $1\n    for ((i=$1;\
    \ i<=$1; i+=1)); do\n        # if the remainder is 0, then n divides evenly into\
    \ i\n        n=$(($i%$i))\n        # if the remainder is not 0, then n is not\
    \ a divisor of i\n        if [ \"$n\" -ne 0 ]; then\n            echo \"$n\"\n\
    \            # exit the for loop\n            break\n        fi\n    done", " \
    \ local n max_divisor divisor remainder divisor_count\n  read n\n  (( divisor_count\
    \ = 1 ))\n  while [ $divisor_count -lt 10 ]; do\n    (( remainder = 0 ))\n   \
    \ for divisor in {1..100}; do\n      if [ $(( (n * divisor) / divisor )) -eq 0\
    \ ]; then\n        remainder=`expr $remainder + $divisor - $divisor`\n      fi\n\
    \    done\n    max_divisor=$(( $divisor + 1 ))\n    if [ $n -gt $max_divisor ];\
    \ then\n      divisor=$max_divisor\n    fi\n    (( divisor_count = divisor_count\
    \ + 1 ))\n  done\n  echo $max_divisor", "    local -r n=$1\n    local -r max=$(echo\
    \ \"$n\" | bc)\n    local -r ret=\n    for (( div = 2; div <= $(( 10#$max / div\
    \ )); div++ )); do\n        if [ \"$div\" -eq \"$(( $max / div ))\" ] \\\n   \
    \     && (( $div * $div < $max )); then\n            ret=$div\n            break\n\
    \        fi\n    done\n    echo \"$ret\"", "    local number=$1\n    local largest=0\n\
    \    local i\n\n    for ((i=1; i<=number; i++)); do\n        local div=$(echo\
    \ \"$number / $i\" | bc)\n        if [ $div -eq 0 ]; then\n            largest=$i\n\
    \            break\n        fi\n    done\n\n    echo \"$largest\"", "\techo \"\
    $1\" | awk '{print $1}' | sort -n | tail -n 1", "    local number=$1\n    local\
    \ max_divisor=0\n    local divisor\n    local max_divisor_name\n    local divisor_array=()\n\
    \    local i\n\n    divisor_array=($number/2)\n    max_divisor=${divisor_array[0]}\n\
    \    divisor_array=()\n    for (( i=1; i<${#divisor_array[@]}; i++ )); do\n  \
    \      divisor=${divisor_array[i]}\n        if (( divisor % 2 == 0 )); then\n\
    \            divisor_array+=( ${divisor} )\n            if (( divisor > max_divisor\
    \ )); then\n                max_divisor=${divisor}\n                max_divisor_name=$(basename\
    \ ${divisor})\n            fi\n        fi\n    done\n\n    echo \"$max_divisor_name\
    \ $max_divisor\"", "    local n=$1\n    local result=0\n    for ((i=1; i<$n; i++))\n\
    \    do\n        local remain=$((n-i))\n        local div=$((i%2))\n        if\
    \ [ $div -eq 0 ] ; then \n            if [ $remain -gt $result ]; then\n     \
    \           result=$remain\n            fi\n        fi\n    done\n    echo \"\
    $result\"", "    local n=\"$1\"\n\n    if [ \"$n\" -eq 1 ] ; then\n        echo\
    \ \"1\"\n        return\n    fi\n\n    local largest\n    if [ \"$(grep -o -E\
    \ \"[0-9]+\" | sort -n -r | head -1)\" == \"1\" ] ; then\n        echo \"1\"\n\
    \        return\n    fi\n\n    local next_n\n    local count\n    for next_n in\
    \ $(seq 1 $n) ; do\n        count=0\n        local next_n\n        for next_n\
    \ in $(seq 1 $n) ; do\n            (( count+=($next_n % $next_n) == 0 && next_n\
    \ ))\n        done\n        if [ $count -eq 0 ] ; then\n            largest=$next_n\n\
    \            break\n        fi\n    done\n    echo \"$largest\"", "\tlocal number=$1\n\
    \twhile [ $number -eq 0 ]\n\tdo\n\t\tnumber=$(($number / 2))\n\tdone\n\techo $number",
  "    local n=\"${1}\"\n\n    local max\n    for (( n = 3; n <= ${n}; n++ )); do\n\
    \        if (( ${n} % 2 == 0 )); then\n            max=$(expr $n \\/ 2)\n    \
    \    else\n            if (( ${n} > ${max} )); then\n                max=${n}\n\
    \            fi\n        fi\n    done\n    echo \"${max}\"", "  local n=$1\n \
    \ if [ $n -eq 1 ]; then return 1\n  fi\n  local i\n  for ((i = 1; i <= n; i++));\
    \ do\n    if (( $((n % i)) )) ; then \n      echo $i\n      return\n    fi\n \
    \ done\n  echo \"$n\"", "  local number=\"$1\"\n\n  local factor\n  local max_number\n\
    \  local index\n  local found\n  local max_divisor\n\n  for (( index = 0; index\
    \ < \"${number}\"; index++ )); do\n    factor=$(echo $number | cut -d'(' -f1)\n\
    \    found=\"false\"\n    while [ \"${found}\" = false ]; do\n      if [ \"$factor\"\
    \ -eq 0 ]; then\n        found=\"true\"\n      else\n        echo \"$index\"\n\
    \        found=\"true\"\n      fi\n      factor=\"$(( ${factor} * 2 ))\"\n   \
    \ done\n  done\n\n  echo \"$index\"", "    # Initialize variable\n    largest=$1\n\
    \    # Initialize counter variable (initialize to 1 to keep count of the largest\
    \ divisor)\n    counter=1\n\n    while [ $counter -le $1 ]\n    do\n        if\
    \ [ $(($2 % $counter)) == 0 ]\n        then\n            largest=$counter\n  \
    \      fi\n        counter=$(($counter + 1))\n    done\n    echo -n \"Largest\
    \ divisor: \"\n    echo $largest", "    declare -i n x\n    x=$1\n    y=$2\n \
    \   for (( n = 3; n <= $x; n++ )); do\n        if [ $(($x % $n)) -eq 0 ]; then\n\
    \            y=$n\n        fi\n    done\n    echo \"$y\"", "    local i n max_div\
    \ divisor\n    n=$1\n    max_div=$(n)  # initial value of max_div\n    while [\
    \ $n -gt 1 ]; do\n        n=$(n-2)\n        i=$((n/max_div))\n        if [ $((i%2))\
    \ -eq 0 ]; then\n            max_div=$n\n        fi\n    done\n    echo $max_div",
  "  local n=\"$1\"\n  local factor=1 factors=0\n  while [ $n -gt 1 ]; do\n    ((\
    \ factor++))\n    (( n%factor )) && factors+=1 || factors=$factor\n  done\n  echo\
    \ \"$(( n - factors ))\"", "    if [ -z \"$1\" ]\n    then\n        echo \"Usage:\
    \ $0 number\"\n        return\n    fi\n    local n=\"$1\"\n    while [ $n -ge\
    \ 1 ]; do\n        [ $(( n / 2 )) -eq 0 ] && echo \"$n\" && break\n        n=$((\
    \ n / 2 ))\n    done", "  local n=\"$1\"\n  (( n%2 == 0 && n%3 == 0 && n%5 ==\
    \ 0 && n%7 == 0 && n%9 == 0 )) && echo 9 || \\\n    (( n%3 == 0 && n%5 == 0 &&\
    \ n%7 == 0 && n%9 == 0 )) && echo 7 || \\\n    (( n%5 == 0 && n%7 == 0 && n%9\
    \ == 0 )) && echo 5 || \\\n    (( n%7 == 0 && n%9 == 0 )) && echo 3 || \\\n  \
    \  (( n%9 == 0 )) && echo 1", "  local d=1\n  local n=$1\n  while [[ $d -gt 1\
    \ && $n % $d == 0 ]]; do\n    d=$((d+1))\n  done\n  echo \"$d\"", "    local n=$1\n\
    \n    local factors=$(biglor $n)\n\n    local max_factor=0\n    local max_divisor_n=1\n\
    \n    local divisor_n=1\n    while [ $divisor_n -le $n ]; do\n        local divisor_n=$((\
    \ $divisor_n * 2 ))\n        local divisor=$(( $divisor * 2 ))\n        if [ $divisor_n\
    \ -eq $divisor ]; then\n            factors=\"$factors $divisor_n\"\n        else\n\
    \            if [ $divisor_n -gt $max_factor ]; then\n                max_factor=$divisor_n\n\
    \                max_divisor_n=$divisor\n            fi\n        fi\n    done\n\
    \    echo $max_divisor_n", "    if [ $1 -lt 1 ]; then\n        echo 1\n    else\n\
    \        local d=$(( ${1/2} - 1 ))\n        echo $(( ${1/2} - 1 ))\n        while\
    \ [ ${1/2} -le $1 ]\n        do\n            d=$(( ${d} + 1 ))\n            if\
    \ [[ $1 -eq $(( ${d} + 1 )) ]]; then break; fi\n        done\n        echo $d\n\
    \    fi", "  echo $(\n    awk -v d=\"$1\" '\n      BEGIN {\n        a[1]=d;\n\
    \      }\n      {\n        for (i=2; i<=length(a); i++) {\n          if (d%i==0)\
    \ {\n            d=d;\n          }\n          else {\n            d=d%i\n    \
    \      }\n          if (d==0) {\n            largest_divisor=a[i];\n         \
    \ }\n        }\n      }\n      END {\n        print largest_divisor\n      }\n\
    \    '\n  )", "  local i j\n  local n x divisor output\n  ((i = $1; output=\"\
    $1\"; n=\"$1\"; divisor=\"1\"; while [ $i -gt 1 ]; do j=\"$((${n}%$divisor))\"\
    ; output=\"$j\"; if (( j == 0 )); then break; else n=\"$n\"; divisor=\"$j\"; fi;\
    \ i=$(( $i -1 )); done; echo $output))", "    local -i n divisor remainder\n \
    \   # First we find the largest divisor of a number n where n / divisor is greater\
    \ than 1\n    # Then we go through all the possible divisors of n / divisor and\
    \ see if they divide n evenly.\n    # If the divisor divides n evenly, then it\
    \ is the largest divisor.\n    # In case the divisor is 1, there is no such divisor\
    \ and so we return n\n    for divisor = 1; $divisor <= $1 && $1 / $divisor > 1;\
    \ divisor=$(( $divisor + 1 )) ; do\n        if [[ $( $1 / $divisor | bc -l ) ==\
    \ 1 ]]; then\n            echo \"$divisor\"\n            return\n        fi\n\
    \    done\n    # We have not found a divisor for n <= $1 that divides n evenly.\n\
    \    # In this case we assume that n <= 2n and return the greatest number that\
    \ divides n evenly.\n    echo $1", "  local i j\n  i=\"${1%%,*}\"\n  j=\"${i#*,}\"\
    \n  (( i % j == 0 )) && echo \"$i\" || echo \"${j}\"", "  [ $1 -eq 0 ] && return\
    \ 1\n  x=$2\n  for i in $(seq 1 $1) ; do\n    y=$((x / $i))\n    [ \"$y\" -eq\
    \ \"$x\" ] && break || x=$y\n  done\n  echo ${y}", "  local n=$1\n  local max\n\
    \  local div\n\n  (( $# > 1 )) && { echo \"Usage: $0 [integer]\" && exit 1; }\n\
    \n  (( $# == 1 )) && { echo \"Usage: $0 [integer]\" && exit 1; }\n\n  max=$((\
    \ 1 / 2 ))\n  (( n > 0 )) || { echo \"Usage: $0 [integer]\" && exit 1; }\n  ((\
    \ n > 1 )) || { echo \"Usage: $0 [integer]\" && exit 1; }\n\n  while (( $(( n%2\
    \ )) > 0 )); do\n    div=$(( n / 2 ))\n    if (( $div > max )); then\n      max=$div\n\
    \    fi\n    (( n -= 2 ))\n  done\n\n  echo $max", "   local number=$1\n   local\
    \ largest=\n   local quotient=\n\n   # if the number is equal to or less than\
    \ 1, then there is no divisor\n   if (( number < 1 )); then\n      return 0\n\
    \   fi\n\n   while (( number > 1 )); do\n      quotient=$(( number / 2 ))\n  \
    \    # if the remainder of the division is 0, then it's the last divisor to divide\
    \ evenly\n      if (( quotient == 0 )); then\n         # update the largest divisor\
    \ to the remainder\n         if (( number > largest )); then\n            largest=$quotient\n\
    \         fi\n         # break the while loop\n         break\n      else\n  \
    \       # if the remainder of the division is not zero, then\n         # we must\
    \ find the largest divisor less than the remainder\n         if (( number % quotient\
    \ > 0 )); then\n            # update the largest divisor to the remainder\n  \
    \          if (( number > largest )); then\n               largest=$quotient\n\
    \            fi\n         fi\n      fi\n   done\n   # return the largest divisor\
    \ that is smaller than the number\n   return $(( $largest ))", "    (( $# < 1\
    \ )) && return 1\n    local -r n=$1\n    local -r max_divisor=8\n    local -r\
    \ max_divisor_remainder=0\n    local -r max_divisor_in_place=0\n    local -i factor=1\n\
    \    local -i max_divisor_in_place_index=0\n    local -i max_divisor_in_place_remainder=0\n\
    \    local divisor\n    local i\n    # count factors\n    for ((i=1; i <= n; i++))\n\
    \    do\n        (( i % factor )) && factor++\n    done\n    IFS=+ read -r -a\
    \ divisor < <(echo \"($n)/($factor)\" | bc)\n    # remove factor from n\n    while\
    \ (( n /= factor ))\n    do\n        max_divisor_in_place=( ${max_divisor_in_place[@]}\
    \ $(( max_divisor_in_place + 1 )))\n        max_divisor_in_place_index=$(( $max_divisor_in_place_index\
    \ + 1 ))\n        max_divisor_in_place_remainder=$(( $max_divisor_in_place_remainder\
    \ + divisor [[ $(( max_divisor_in_place_index )) -eq $(( max_divisor )) ]] ))\n\
    \    done\n    # find largest divisor in place\n    max_divisor_in_place[[ $((\
    \ max_divisor_in_place_index )) -eq $(( max_divisor )) ]] && max_divisor=$(( max_divisor_in_place_remainder\
    \ ))\n    # print result\n    echo \"$max_divisor\"", "  local n=\"$1\"\n\n  local\
    \ max\n  max=$(( (${n}-1)/2 ))\n  local i\n  for (( i=1; i<${max}; i++ )); do\n\
    \    (( ${i}%${n} )) && break || let \"i\"=$(( i-1 ))\n  done\n  echo \"$i\"",
  "    local divisor max\n    divisor=1 # start dividing by 1\n    while (( ${divisor}\
    \ < $1 )); do\n        if (( ${1} % ${divisor} )); then\n            divisor=$((\
    \ ${divisor} + 1 ))\n        fi\n    done\n    max=$(( ${1} / ${divisor} ))\n\
    \    echo \"${max}\"", "    local n=$1\n    local i\n    local max_div\n    local\
    \ max_div_sz\n    local max_div_bsz\n    local max_div_bsz_n\n\n    if [[ \"$n\"\
    \ == \"1\" ]]; then\n        echo \"1\"\n        return 0\n    fi\n\n    if [[\
    \ \"$n\" == \"0\" ]]; then\n        echo \"0\"\n        return 0\n    fi\n\n \
    \   if [[ \"$n\" == \"-1\" ]]; then\n        echo \"0\"\n        return 0\n  \
    \  fi\n\n    max_div=$(echo \"$(( 10#$n - 1 ))\" | bc)\n    max_div_sz=$(echo\
    \ \"$max_div * 2\" | bc)\n    max_div_bsz=$(echo \"$max_div * 4\" | bc)\n    max_div_bsz_n=$(echo\
    \ \"$max_div * $max_div\" | bc)\n\n    for (( i = $max_div_bsz_n; $i > 0; --i\
    \ )); do\n        if [ $n % $i -eq 0 ]; then\n            if [ $max_div -le $i\
    \ ]; then\n                echo \"$i\"\n                return 0\n           \
    \ fi\n        fi\n    done\n\n    echo \"0\"", "  local n=$1\n  local m\n  local\
    \ i\n\n  for ((i = 0; i <= n; i++)); do\n    m=$(($n % $i))\n    if ((m == 0));\
    \ then\n      break\n    fi\n    n=$i\n  done\n\n  if ((m == 0)); then\n    return\
    \ 0\n  fi\n  echo \"$m\"", "  local max_divisible=0\n  local n=$1\n  local remainder\n\
    \  local divisor_count=1\n  while [ $((n/2)) -le $n ]; do\n    ((divisor_count=divisor_count+1))\n\
    \    ((remainder=n%$n))\n    ((max_divisible=$((divisor_count>max_divisible?divisor_count:max_divisible)))\
    \ && echo ${n})\n    ((n=$remainder))\n  done\n  echo \"$max_divisible\"", " \
    \ local n=$1\n  while [ `expr $n % 2` -eq 0 ] ; do\n    n=$((n/2))\n  done\n \
    \ echo $n", "  local n=$1\n  local div=1\n  local mod\n  for i in $(seq 1 $n);\
    \ do\n    mod=$(( $n % $div ))\n    if [ $mod -eq 0 ]; then\n      div=$(( $div\
    \ + 1 ))\n    fi\n  done\n  echo $div", "\tlocal n n c d dx result\n\tn=${1:--1}\n\
    \tc=0 dx=0 d=0\n\tfor i in $(seq 1 ${n}); do\n\t\tdx=$((dx + i))\n\tdone\n\tfor\
    \ i in $(seq 1 ${dx}); do\n\t\td=$(echo \"$d*$i\" | bc)\n\t\tif [ \"$d\" -ge \"\
    $n\" ]; then\n\t\t\tresult=$((${n}+1))\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo \"\
    $result\"", "    local NUMBER=$1\n    local LARGEST_DIVISOR=1\n    local DIVISOR=1\n\
    \    while [ $DIVISOR -le $NUMBER ]\n    do\n        DIVISOR=$(( $DIVISOR + 1\
    \ ))\n        DIVISOR=$(($DIVISOR / 2))\n        if [ $DIVISOR -eq 0 ]\n     \
    \   then\n            LARGEST_DIVISOR=$DIVISOR\n        fi\n    done\n    return\
    \ $LARGEST_DIVISOR", "  local number=$1\n  # Make sure it is a number\n  [[ \"\
    ${number}\" =~ ^[0-9]+$ ]] || return 1\n  local greatest_divisor\n  greatest_divisor=0\n\
    \  local greatest_divisor_count=1\n  while (( ${number} > 0 )); do\n    local\
    \ divisor_count=`expr ${number} % ${greatest_divisor}`\n    (( divisor_count >\
    \ 0 )) && greatest_divisor_count=$divisor_count\n    (( greatest_divisor == 0\
    \ )) && greatest_divisor=$number\n    (( number /= 2 ))\n  done\n  echo ${greatest_divisor}",
  "  local n=$1\n  local remainder\n  local max\n  (( max = 0 ))\n  while (( n > 1\
    \ )); do\n    remainder=`echo \"$n % 2\" | bc`\n    if (( remainder == 0 )); then\n\
    \      max=$(( max ))\n    fi\n    n=$(( n - remainder ))\n  done\n  echo $max",
  "    echo \"$1\" | sed 's/\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\1\\2\\3\\4\\5/'",
  "    local n=$1\n    local largest\n    local divisor_count\n    local divisor_sum\n\
    \n    largest=$((n/2))\n    while (( (n%2) == 0 ))\n    do\n        n=$((n/2))\n\
    \        divisor_count=$((n%$largest))\n        divisor_sum=$((divisor_sum+$divisor_count))\n\
    \    done\n    echo \"$divisor_sum\"", "    (( $# < 1 )) && return 1\n    local\
    \ n=\"$1\"\n    local max\n    local divisor\n    local divisor2\n    local divisor3\n\
    \    local divisor4\n    local divisor5\n    local divisor6\n    local divisor7\n\
    \    local divisor8\n    local divisor9\n    local divisor10\n    local divisor11\n\
    \    local divisor12\n    local divisor13\n    local divisor14\n    local divisor15\n\
    \    local divisor16\n    local divisor17\n    local divisor18\n    local divisor19\n\
    \    local divisor20\n    local divisor21\n    local divisor22\n    local divisor23\n\
    \    local divisor24\n    local divisor25\n    local divisor26\n    local divisor27\n\
    \    local divisor28\n    local divisor29\n    local divisor30\n    local divisor31\n\
    \    local divisor32\n    local divisor33\n    local divisor34\n    local divisor35\n\
    \    local divisor36\n    local divisor37\n    local divisor38\n    local divisor39\n\
    \    local divisor40\n    local divisor41\n    local divisor42\n    local divisor43\n\
    \    local divisor44\n    local divisor45\n    local divisor46\n    local divisor47\n\
    \    local divisor48\n    local divisor49\n    local divisor50\n    local divisor51\n\
    \    local divisor52\n    local divisor53\n    local divisor54\n    local divisor55\n\
    \    local divisor56\n    local divisor57\n    local divisor58\n    local divisor59\n\
    \    local divisor60\n    local divisor61\n    local divisor62\n    local divisor63\n\
    \    local divisor64\n    local divisor65\n    local divisor66\n    local divisor67\n\
    \    local divisor68\n    local divisor69\n    local divisor70\n    local divisor71\n\
    \    local divisor72\n    local divisor73\n    local divisor74\n    local divisor75\n\
    \    local divisor76\n    local divisor77\n    local divisor78\n    local divisor79\n\
    \    local divisor80\n    local divisor81\n    local divisor82\n    local divisor83\n\
    \    local divisor84\n    local divisor85\n    local divisor86\n    local divisor87\n\
    \    local divisor88\n    local divisor89\n    local divisor90\n    local divisor91\n\
    \    local divisor92\n    local divisor93\n    local divisor94\n    local divisor95\n\
    \    local divisor96\n    local divisor97\n    local divisor98\n    local divisor",
  "  local n=\"${1:-}\"\n  local answer\n  local num_divisors\n  (( num_divisors=${#n}+1\
    \ ))\n  local divisor\n  for divisor in $(seq 0 $num_divisors); do\n    (( n %\
    \ $divisor == 0 )) && continue\n    (( answer=$divisor > $n )) && break\n  done\n\
    \  echo \"$answer\"", "    local n=\"$1\"\n    if [[ ! $n =~ ^[0-9]+$ ]]; then\n\
    \        echo \"ERROR: Invalid integer ($1)\"\n        return 1;\n    fi\n   \
    \ local max_num=\"\"\n    while [[ ! $max_num =~ ^[0-9]+$ ]] && [[ ! $max_num\
    \ =~ ^0$ && $max_num -ne $n ]]; do\n        if [ $(( $(echo \"$n / 2\" | bc) ))\
    \ -eq $n ]; then\n            max_num=$n\n        else\n            n=$(( $n /\
    \ 2 ))\n        fi\n    done\n    echo \"$max_num\"", "  local n=$1\n  local largest_divisor=\"\
    $(( (($(n)) + ($(n))/2))/2)\"\n  echo \"$largest_divisor\"", "  local n i divisor_value\
    \ max_divisor max_divisor_value remainder max_remainder\n  \n  n=$(echo \"$1\"\
    \ | sed \"s/ //g\")\n  divisor_value=1\n  max_divisor_value=1\n  max_remainder=1\n\
    \  max_divisor=1\n  while [ \"$divisor_value\" -le \"$n\" ]; do\n    remainder=$(echo\
    \ \"$n / $divisor_value\" | bc)\n    if [ \"$remainder\" -gt \"$max_remainder\"\
    \ ]; then\n      max_remainder=\"$remainder\"\n      max_divisor=\"$divisor_value\"\
    \n    fi\n    ((divisor_value++))\n  done\n  echo \"$max_divisor\"", "  local\
    \ n=$1\n  local i\n  local max_div\n  local max_div_index\n  local max_div_n\n\
    \  local max_div_b\n  local max_div_r\n\n  max_div_n=$(( ${n}-1 ))\n  max_div_b=\n\
    \  max_div_r=\n  for i in $(seq ${max_div_n}); do\n    local div=$(( ${n}/$i ))\n\
    \    if [ ${div} == ${n} ]; then\n      max_div=${i}\n      max_div_index=$i\n\
    \      max_div_n ${n}\n      max_div_b=${n}\n      max_div_r=$(( ${max_div_n}+1\
    \ ))\n      break\n    fi\n  done\n\n  echo $max_div_r", "  # shellcheck disable=SC2145\n\
    \  local -r n=\"$1\"\n  local -r max_num=\"$2\"\n  local -r greatest_num\n  local\
    \ i\n  local num\n\n  # If n is less than or equal to 0\n  if [ \"$n\" -eq \"\
    0\" ]; then\n    echo \"$max_num\"\n    return 0\n  fi\n\n  num=$(echo \"scale=4;\
    \ $n/$max_num\" | bc)\n  greatest_num=$((max_num*$num))\n  while [ \"$greatest_num\"\
    \ -lt \"$n\" ]; do\n    ((greatest_num+=$max_num))\n    num=$((greatest_num/2))\n\
    \  done\n\n  echo \"$num\"", "    local number=$1\n    local divisor\n    local\
    \ max=0\n    local max_num\n    for (( i=1; i<number; i++ ))\n    do\n       \
    \ divisor=$(( $number % i ))\n        if [ $divisor -eq 0 ]\n        then\n  \
    \          (( max = max < divisor )) || break\n        else\n            (( max\
    \ = divisor )) || break\n        fi\n    done\n    if [ $divisor -eq 0 ]\n   \
    \ then\n        max_num=$(( $number ))\n    else\n        max_num=$(( $max ))\n\
    \    fi\n    echo \"$max_num\"", "  local -r n=$1\n  local -r s=0\n  local -r\
    \ d=0\n\n  while (( s < n )); do\n    (( s += d ))\n    (( d += 1 ))\n  done\n\
    \  echo \"$d\"", "   local a b c d e f g h i j k l m n o p q r s t u v w x y z\n\
    \   local -i n v\n\n   read -r n && [ -z \"$n\" ] && echo empty || echo \"$n\"\
    \n\n   # We can't use set -e, since that requires bash version 4.\n   for (( v\
    \ = 1; v <= $n; v++ )); do\n      a=$v\n      for (( b = 1; b <= $v; b++ )); do\n\
    \         for (( c = 1; c <= $b; c++ )); do\n            for (( d = 1; d <= $c;\
    \ d++ )); do\n               for (( e = 1; e <= $d; e++ )); do\n             \
    \     for (( f = 1; f <= $e; f++ )); do\n                     for (( g = 1; g\
    \ <= $f; g++ )); do\n                        for (( h = 1; h <= $g; h++ )); do\n\
    \                           for (( i = 1;  i <= $h; i++ )); do\n             \
    \                 for (( j = 1;  j <= $i; j++ )); do\n                       \
    \         for (( k = 1;  k <= $j; k++ )); do\n                               \
    \    for (( l = 1;  l <= $k; l++ )); do\n                                    \
    \  for (( m = 1;  m <= $l; m++ )); do\n                                      \
    \   for (( n = 1;  n <= $m; n++ )); do\n                                     \
    \       # For each number between $n and $v inclusively, increment $n\n      \
    \                                      if (( n <= v )); then\n               \
    \                              let n=$n+1\n                                  \
    \           fi\n                                             break\n         \
    \                                  done\n                                    \
    \   done\n                                    done\n                         \
    \        done\n                              done\n                          \
    \ done\n                        done\n                     done\n            \
    \      done\n               done\n            done\n         done\n      done\n\
    \   done\n   echo \"$n\"", "  local n=$1 ret=1 divisor count\n\n  for i in $(seq\
    \ 1 $n); do\n    divisor=1\n    while [ $(( $divisor % $n )) -eq 0 ]; do\n   \
    \   divisor=$(( 1 + divisor ))\n    done\n    count=$(( count + 1 ))\n    if [\
    \ $count -gt $ret ]; then\n      ret=$count\n    fi\n  done\n  echo $ret", " \
    \ local i n m\n  i=\"$1\"\n  n=\"$2\"\n  m=$(expr \"$i\" \\% \"$n\")\n  while\
    \ [ \"$m\" -gt 0 ]\n  do\n    m=$(expr \"$m\" \\/ \"$n\")\n    n=$n\n  done\n\
    \  echo \"$n\"", "   local n=$1\n   if [ $n -eq 0 ]; then \n      echo \"0\";\n\
    \      return 0;\n   fi\n   local max\n   max=$(echo \"($n-1) / $n\" | bc)\n \
    \  while [ \"$max\" -ge \"$n\" ]; do \n      ((max--))\n      ((n--))\n   done\n\
    \   echo \"$max\"", "  local n=$1\n  local max_divisor_nr=0\n  local max_divisor\n\
    \  local divisor\n  local i\n\n  (( n > 1 )) && echo 'Usage: $(basename $0) <integer>'\n\
    \n  for i in $(seq 2 $(( $n - 1 ))); do\n    divisor=$(( $n / $i ))\n    if [\
    \ $divisor -eq $n ]; then\n      (( max_divisor_nr++ ))\n      max_divisor=$divisor\n\
    \    fi\n  done\n  echo $max_divisor", "    number=$1\n    local -n largest_divisor_var_name=\"\
    largest_divisor_var_name\"\n    local -n largest_divisor_var_num=\"largest_divisor_var_num\"\
    \n    local -n largest_divisor_var_max=\"largest_divisor_var_max\"\n    local\
    \ -n largest_divisor_var_current=\"largest_divisor_var_current\"\n    local -n\
    \ largest_divisor_var_prev=\"largest_divisor_var_prev\"\n    local -n largest_divisor_var_test=\"\
    largest_divisor_var_test\"\n\n    largest_divisor_var_name=\"\"\n    largest_divisor_var_num=\"\
    \"\n    largest_divisor_var_max=\"1\"\n    largest_divisor_var_current=\"1\"\n\
    \    largest_divisor_var_prev=\"1\"\n    largest_divisor_var_test=\"1\"\n\n  \
    \  while [ $number -gt 0 ]; do\n        largest_divisor_var_name=\"$largest_divisor_var_name$1\"\
    \n        (( largest_divisor_var_num+=\"$1\" ))\n        (( largest_divisor_var_current+=\"\
    $1\" ))\n        (( largest_divisor_var_max+=\"$1\" ))\n        (( largest_divisor_var_num+=\"\
    1\" ))\n        (( largest_divisor_var_current+=\"1\" ))\n        (( largest_divisor_var_max+=\"\
    1\" ))\n        (( largest_divisor_var_num-=1 ))\n        (( largest_divisor_var_current-=1\
    \ ))\n        (( largest_divisor_var_max-=1 ))\n        (( largest_divisor_var_num%=\"\
    $1\" ))\n        (( largest_divisor_var_current%=\"$1\" ))\n        (( largest_divisor_var_max%=\"\
    $1\" ))\n        if [[ $largest_divisor_var_num -eq 0 ]]; then\n            ((\
    \ largest_divisor_var_test+=\"$1\" ))\n        fi\n        (( largest_divisor_var_current+=1\
    \ ))\n        (( largest_divisor_var_max+=1 ))\n        (( largest_divisor_var_num-=1\
    \ ))\n        (( largest_divisor_var_current-=1 ))\n        (( largest_divisor_var_max-=1\
    \ ))\n        (( largest_divisor_var_num%=\"$1\" ))\n        (( largest_divisor_var_current%=\"\
    $1\" ))\n        (( largest_divisor_var_max%=\"$1\" ))\n        if [ $largest_divis",
  "  number=$1\n  divisor=$2\n  while [ $divisor -gt 0 ]; do\n    (( number % divisor\
    \ == 0 )) && break\n    (( divisor-- ))\n  done\n  echo $(( $number / divisor\
    \ ))", "    local x=\"$1\"\n    local max_divisor_found\n    max_divisor_found=0\n\
    \    # A faster way to find the largest divisor than using grep.\n    local divisor_found\n\
    \    while [[ \"$x\" -gt 0 ]]; do\n        x=$(echo \"$x / 2\" | bc)\n       \
    \ divisor_found=$(echo \"$x / $1\" | bc)\n        if [ \"$divisor_found\" -ge\
    \ \"$max_divisor_found\" ]; then\n            max_divisor_found=\"$divisor_found\"\
    \n        fi\n    done\n    echo \"$max_divisor_found\"", "  local n=\"$1\"\n\
    \  if (( n <= 0 )); then\n    echo \"Number must be positive\"\n    exit 1\n \
    \ fi\n  local max_val=\"$(( (n - 1) * (n - 2) / 2 + 1 ))\"\n  local i\n  for i\
    \ in $(seq 1 ${max_val}); do\n    local val=\"$(( (n - 1) * (n - 2) / $i + 1 ))\"\
    \n    if [[ $val -eq ${n} ]]; then\n      echo \"$i\"\n      break\n    fi\n \
    \   if [[ \"$val\" -gt \"${max_val}\" ]]; then\n      echo \"$val\"\n      break\n\
    \    fi\n  done", '    echo $(($(nproc) / 2))', "    local n=$1\n    local highest=0\
    \ # largest prime that divides n evenly\n    local divisor=1\n    while [ $divisor\
    \ -le $n ]; do\n        ((divisor++))\n        if [ $n % $divisor -eq 0 ]; then\n\
    \            if [ $divisor -gt $highest ]; then\n                highest=$divisor\n\
    \            fi\n        fi\n    done\n    echo \"$highest\"", "  # Use bc to\
    \ calculate the highest integer dividing n\n  echo \"$(echo \"($1/2)\" | bc -l)\"",
  "    # Make sure $1 is an integer\n    if [ \"${1:0:1}\" = \"-\" ]; then\n     \
    \   echo \"ERROR: You did not provide an integer (at least a positive number)\"\
    \n        return 1\n    elif [ \"${1:0:1}\" != \"-\" ] && [ \"${1:0:1}\" != \"\
    +\" ]; then\n        echo \"ERROR: You did not provide an integer (at least a\
    \ positive number)\"\n        return 1\n    fi\n\n    # Store value of $1\n  \
    \  NUM=\"${1}\"\n\n    # Store the result of the division\n    DIV=\"1\"\n\n \
    \   # Loop through all the numbers\n    for (( i=0; i<${#NUM}; i++ )); do\n  \
    \      # Store the number after dividing by $1\n        (( MOD=\"${NUM}${DIV}\"\
    \ % ${1}))\n        if [ \"${MOD}\" -eq \"0\" ]; then\n            # Store the\
    \ largest divisor in the variable DIV\n            DIV=\"${NUM}${DIV}\"\n    \
    \    fi\n    done\n    echo \"${DIV}\"", "    local max_divisor\n    local divisor_of_max\n\
    \    local n\n    local i\n    local divisor_of_min\n    local j\n\n    echo \"\
    $1\"\n    n=$1\n\n    # Loop through the entire range of numbers from 1 to n\n\
    \    for (( i=1; i<=$n; i++ )); do\n        divisor_of_max=0\n        max_divisor=0\n\
    \        # Find the largest divisor < n\n        for (( j=1; j<=i; j++ )); do\n\
    \            (( divisor_of_max+=$(echo \"$j/$i\" | bc -l) ))\n            # If\
    \ the divisor is evenly divisible, ignore it\n            if [[ $(echo \"$j/$i\"\
    \ | bc -l ) == $((j%2)) ]]; then\n                echo \"$j/$i evenly divisible\"\
    \n            fi\n        done\n        (( divisor_of_min = divisor_of_max ))\n\
    \        # Keep updating the max_divisor until we find a divisor < n\n       \
    \ for (( j=1; j<=i; j++ )); do\n            (( max_divisor = $(echo \"$j/$i\"\
    \ | bc -l) ))\n            if [[ $(echo \"$j/$i\" | bc -l ) == $((j%2)) ]]; then\n\
    \                if [[ $max_divisor > $divisor_of_max ]]; then\n             \
    \       echo \"$max_divisor > $divisor_of_max, ignoring $max_divisor as $divisor_of_max\"\
    \n                    max_divisor=$divisor_of_max\n                fi\n      \
    \          divisor_of_max=$max_divisor\n            fi\n        done\n       \
    \ if [[ $divisor_of_min == $max_divisor ]]; then\n            echo \"$divisor_of_min\
    \ < $n, ignoring $divisor_of_min as $n\"\n        fi\n    done", "    local n=\"\
    $1\"\n    # Initialize max and min to smallest and largest\n    # possible values.\n\
    \    max=\"$(echo \"$n\" | bc)\"\n    min=\"$(echo \"$n\" | bc)\"\n\n    while\
    \ (( $(echo \"$n/2\" | bc) < $n )); do\n        n=\"$(( $n % 2 ))\"\n        ((\
    \ max = $n )) || (( max = $min ))\n    done\n\n    echo \"$max\"", "  local n=$1\n\
    \  local i\n  for i in $(seq 1 $((n-2))); do\n    if [ $(($i & $(n/i))) -ne 0\
    \ ]; then\n      break\n    fi\n  done\n  echo \"$i\"", "  local n=\"$1\"\n  #\
    \ We start with the smallest divisor\n  local d i\n  local a\n  a=$(( (($n % 2)\
    \ == 0)? $n : 2*$n ))\n  while true; do\n    d=$(( ($n % d) == 0)? $d : d+1 )\n\
    \    if [ $d -eq 2 ]; then\n      echo $d\n      break\n    fi\n  done", "   if\
    \ (( 1 ))\n   then\n      return 1\n   fi\n   # Be sure to quote \"$1\" since\
    \ we are using it as a string.\n   local divisor=\"$1\"\n   # $2 will contain\
    \ the largest divisor found so far.\n   local max_divisor=\"$2\"\n   # Divide\
    \ n by divisor until you get to 1. This will loop for n times \n   # until you\
    \ find one.\n   while (( \"$divisor\" > 1 ))\n   do\n      (( max_divisor = divisor\
    \ ))\n      # Divide n by divisor and save remainder.\n      (( n = n % divisor\
    \ ))\n      # If remainder is 0, the divisor divides evenly, \n      # so use\
    \ it.\n      if (( n == 0 ))\n      then\n         # Return the largest divisor\
    \ found so far.\n         echo \"$max_divisor\"\n         break\n      fi\n  \
    \    # If remainder is not 0, try the next divisor.\n      (( divisor = divisor\
    \ / 2 ))\n   done\n   # Reached 1. Return largest divisor found so far.\n   echo\
    \ \"$max_divisor\"", "  local i n x\n  n=$1\n  x=$(echo \"$n\" | bc)\n  while\
    \ [[ $(( n/x )) -le 1 ]]; do\n    i=$((i + 1))\n    n=$((n/divisor))\n  done\n\
    \  echo $i", "    local -n n=$1\n    local -n max_num=1 divisor_num\n    local\
    \ -i divisor_limit\n\n    divisor_limit=10\n    while [ $divisor_limit -le $n\
    \ ]; do\n        divisor_num=$(( $max_num + 1 ))\n        [ $(( $divisor_num /\
    \ $n )) -eq $divisor_num ] && [ $divisor_num -gt $n ] && return $divisor_num\n\
    \        [ $divisor_num -ge $divisor_limit ] && return $divisor_limit\n      \
    \  max_num=$divisor_num\n        divisor_limit=$(( $divisor_limit * 2 ))\n   \
    \ done", "  echo -n \"Enter a number:\"\n  read number\n  \n  if [ $number -eq\
    \ 0 ]; then\n    echo \"0 is the largest divisor of $number.\"\n    return 0\n\
    \  fi\n  \n  local remainder\n  local max_divisor\n  local i\n  \n  max_divisor=$number\n\
    \  for i in $(seq 0 $(($(num_digits $number) / 2)-1)); do\n    remainder=$((number\
    \ % $max_divisor))\n    if (($remainder == 0)); then\n      max_divisor=$max_divisor+1\n\
    \    fi\n  done\n\n  echo \"$max_divisor\"", "  local number=$1\n  local max_divisor_num=\"\
    \"\n\n  while (( $(divmod $number 2 | awk '{ print $1 }') > 0 ))\n  do\n    max_divisor_num=$number\n\
    \    (( number *= 2 ))\n  done\n\n  if [ \"$max_divisor_num\" -ne \"$number\"\
    \ ]; then\n    echo ${max_divisor_num}\n  else\n    echo \"ERROR! No number greater\
    \ than or equal to $number can be divided by two evenly (greater than or equal\
    \ to $number)\"\n  fi", "  local n=$1\n  local max_divisor_seen=0 max_divisor=0\
    \ count=0\n\n  for divisor in {1..n}; do\n    (( count++ ))\n    if [ $(( n %\
    \ divisor )) -eq 0 ] ; then\n      if [ $(( divisor > max_divisor_seen )) -eq\
    \ 0 ] ; then\n        max_divisor_seen=$divisor\n        max_divisor=$count\n\
    \      fi\n    fi\n  done\n\n  echo $max_divisor", "  local n divisor result\n\
    \  (( n = $1 ))\n  result=0\n  while [ $n -gt 1 ]; do\n    (( divisor = n / 2\
    \ ))\n    while [ $divisor -eq 0 ]; do\n      divisor=`expr $divisor + 1`\n  \
    \  done\n    if [ $n -eq $divisor ]; then\n      result=$divisor\n      break\n\
    \    else\n      n=$divisor\n    fi\n  done\n  echo \"$result\"", "  number=\"\
    $1\"\n  declare -i number=\"${number}\"\n\n  # The last divisor must be less than\
    \ or equal to n\n  for i in $(seq 0 $(($number / 2))); do\n    divisor=\"$((number\
    \ * 2))\"\n    [[ \"$divisor\" -gt \"$number\" ]] \\\n      && break || echo \"\
    $i\"\n  done", "    n=$1\n    local divisor result\n    [[ \"$n\" -lt 1 ]] &&\
    \ return\n    while [ $n -gt 1 ]; do\n        divisor=$((n//2))\n        result=$((divisor))\n\
    \        (( n -= divisor ))\n    done\n    echo \"$result\"", "  echo $1 | awk\
    \ -v n=\"$1\" '\n    { n = n / $1;\n      print n % 10; } '", "    local n=$1\n\
    \    local max_divisor\n    while (( $n > 0 )) ; do\n        max_divisor=$(( n\
    \ / 2 ))\n        if (( $n % max_divisor == 0)) ; then\n            break\n  \
    \      fi\n        n=$(( $max_divisor + 1 ))\n    done\n    echo \"$max_divisor\"",
  "  local n=$1 \n  # loop while n > 1\n  while [ $n -gt 1 ]; do \n    # find biggest\
    \ divisor by trial division up to sqrt of n\n    local i=$(expr $n \\* 4 / 3)\n\
    \    # if a divisor is bigger than n, we still keep going\n    if [ $i -gt $n\
    \ ]; then\n      # update n to its biggest divisor\n      n=$i\n      break\n\
    \    # else, we just did one division, so break\n    else\n      # if we did one\
    \ division, and still didn't break, n had to divide evenly\n      n=1\n    fi\n\
    \  done\n  echo $n", "  local n=$1\n  local max_div\n\n  # First get all the divisors\
    \ of n\n  local divisor_count=$(( (n * (n + 1) ) / 2 ))\n  local divisors=()\n\
    \  for (( i=0; i<${divisor_count}; i++ )); do\n    local divisor\n    divisor=$((\
    \ $i % n ))\n    if [[ ${divisor} -eq 0 ]]; then\n      if [[ ${divisors[*]} !=\
    \ ${divisor} ]]; then\n        divisors[${#divisors[@]}]=${divisor}\n      fi\n\
    \    fi\n  done\n\n  # Now get the largest divisor amongst them\n  local max_div=0\n\
    \  for (( i=1; i<${#divisors[@]}; i++ )); do\n    if [[ ${divisors[$i]} -gt ${divisors[$max_div]}\
    \ ]]; then\n      max_div=$i\n    fi\n  done\n\n  printf \"%d\\n\" \"$max_div\"",
  "    local n=$1\n    local largest\n    for (( i=1; i <= n; i++ )); do\n       \
    \ if [[ $(( (n%i)  )) -eq 0 ]]; then\n            largest=$i\n            break\n\
    \        fi\n    done\n    echo \"$largest\"", "  # if n is odd, then n / 2 ==\
    \ 1, and we get the largest\n  # number that divides n evenly\n  if [ \"$1\" -gt\
    \ 1 ]; then\n    local n=\"$1\"\n    local result=\"$((n/2))\"\n    if [ \"$result\"\
    \ -eq 1 ]; then\n      result=\"$n\"\n    fi\n    if [ \"$result\" -gt \"$n\"\
    \ ]; then\n      result=\"$n\"\n    fi\n    echo \"$result\"\n  else\n    echo\
    \ \"1\"\n  fi", "  local n=$1\n  local max=0\n  while [ $n -gt 1 ]\n  do\n   \
    \ test $((n%2)) -eq 0\n    let \"max += 1\"\n    n=$((n/2))\n  done\n  echo $max",
  "    n=$1\n    div=$(( ((n%2==0) && (n%4==0)) && ((n %6==0)) ))\n    echo \"${div}\"\
    \ | bc", "    local n=\"$1\"\n    if [ $n -le 0 ]; then\n        echo \"$n is\
    \ not valid\"\n        return 1\n    fi\n    local m\n    local m1=$(echo \"$n\"\
    \ | awk '{print int($1/2)}')\n    local m2=$(echo \"$n\" | awk '{print int($1/2)}')\n\
    \    local m3=$(echo \"$n\" | awk '{print int($1/2)}')\n    while [ $m1 -gt 0\
    \ ] && [ $m2 -le 0 ] && [ $m3 -le 0 ]; then\n        local m=$(echo \"$m1 * $m2\
    \ * $m3\" | bc)\n        local m1=$(echo \"$m1 / $m2\" | bc)\n        local m2=$(echo\
    \ \"$m1 / $m3\" | bc)\n        local m3=$(echo \"$m1 % $m3\" | bc)\n    done\n\
    \    echo $(echo \"$m1 * $m2 * $m3\" | bc)", "  local n=$1\n  local max_num=$(nix\
    \ call --json \"import nix.helpers; nix.helpers.divide(builtins.int($n), builtins.int($n))\"\
    \ | jq -r '.[0]')\n  echo \"$max_num\"", "    local -r n=\"$1\"\n\n    if [ \"\
    ${n}\" -eq \"$n\" ] 2>/dev/null; then\n        return $n\n    fi\n\n    local\
    \ -r max_divisor=$(divmod \"$n\" \"$(( $(divmod \"$n\" 2 | cut -f1) ))\")\n  \
    \  if [ -z \"$max_divisor\" ] 2>/dev/null; then\n        return $n\n    fi\n\n\
    \    local -r max_divisor_abs=$(echo \"$max_divisor\" | awk '{abs+=abs($1); $1=\"\
    \"; print abs}')\n\n    if [ \"$max_divisor_abs\" -gt \"$n\" ]; then\n       \
    \ return \"$max_divisor\"\n    fi", "    # Convert the number to an integer.\n\
    \    local number \n    number=$1\n    # Loop through all numbers less than number.\n\
    \    for ((i=2; i<=$number; i++)); do\n        # Check if i divides number evenly.\n\
    \        if (( $number % i )); then\n            # Assign the number that divides\
    \ number evenly to variable result.\n            result=$i\n            break\n\
    \        fi\n    done\n    # Return the largest of the two numbers that divides\
    \ number evenly, smaller than number.\n    echo \"$result\"", '  echo $(( (n=$1<<0)|(
    ( n|( (n>>1)&1 ) ) >n|( (n>>2)&1 ) ) ))', "    local number=$1\n    local max_divisor=$(echo\
    \ \"$number\" | awk -F \"/\" '{print $NF}' | sort -nr | head -1)\n    while true;\
    \ do\n        local new_divisor=$(echo \"$number/$max_divisor\" | bc)\n      \
    \  if [ \"$new_divisor\" -eq \"$max_divisor\" ]; then\n            echo \"$max_divisor\"\
    \n            break\n        elif [ \"$new_divisor\" -lt \"$max_divisor\" ]; then\n\
    \            max_divisor=$new_divisor\n        fi\n    done", "    local n max=0\n\
    \n    while [ $1 -gt 1 ]\n    do\n        ((n=$1/2))\n        if [ $n % 2 -eq\
    \ 0 ]\n        then\n            ((max=$n))\n        fi\n        ((n=$n/2))\n\
    \    done\n\n    echo \"$max\"", "  local n=$1\n  local i=0\n  while [ $i -lt\
    \ ${#n} ]; do\n    local j=0\n    while [ $j -lt ${#n} ]; do\n      # If $i is\
    \ evenly divisible by $j, remove it\n      if [ ${n:$i:1} = 0 ]; then\n      \
    \  echo \"${n:$i:1}\"\n        break\n      fi\n      ((j++))\n    done\n    ((i++))\n\
    \  done", "    local number=$1\n    local max_divisor\n    local max_divisor_num\n\
    \    max_divisor=1\n    max_divisor_num=1\n    for (( i=1 ; i <= $number ; i++\
    \ )); do\n        local divisor_num=$(( $number % $i ))\n        if [ $divisor_num\
    \ -eq 0 ]; then\n            if [ $divisor_num -gt $max_divisor ]; then\n    \
    \            max_divisor=$divisor_num\n                max_divisor_num=$i\n  \
    \          fi\n        fi\n    done\n    echo \"$max_divisor_num\"", "  local\
    \ n=$1\n  local i=1\n  local max=i\n  while [ $n -gt 0 ]\n  do\n    [ $(( $n %\
    \ $i )) -eq 0 ] && let i++\n    [ $(( $n % $i )) -lt $max ] && let max=$i\n  \
    \  n=$(( $n / $i ))\n  done\n  echo $max", "  local n=$1\n  if [ -z $n ]; then\n\
    \    echo \"You must provide a positive integer\"\n    exit 1\n  fi\n  local m=$((n-1))\n\
    \  local i=$((m+1))\n  while (( i <= n )); do\n    if (( n % i == 0 )); then\n\
    \      m=$i\n      i=$((m+1))\n    fi\n    (( i++, ))\n  done\n  echo \"$m\"",
  "  # We use bc to do the division\n  result=$(echo \"scale=3; $1/$2\" | bc)\n  #\
    \ Now we format it again to have the correct sign, etc.\n  echo \"${result#-}\"",
  "    local num=\"$1\"\n    # $2 is used to count the number of iterations\n    local\
    \ count=0\n    # $3 is used to accumulate the largest number\n    local max_num=\"\
    \"\n    while ((num != 0)); do\n        ((count++))\n        if (( num % 2 ==\
    \ 0 )); then\n            if (( $count > 0 )); then\n                if (( $count\
    \ > $max_num )); then\n                    max_num=\"$count\"\n              \
    \  fi\n            fi\n        fi\n        (( num / 2 ))\n    done\n    if ((\
    \ $count == 0 )); then\n        echo \"$max_num\"\n    fi", "  local number=$1\n\
    \  local result=0\n  local divisor 1\n\n  echo \"number: $number\"\n\n  while\
    \ [ $number -gt 0 ]; do\n    if [ $(( (number % divisor) == 0) = 0 ) ]; then\n\
    \      result=$(( $divisor ))\n      break\n    fi\n\n    divisor=$(( $divisor\
    \ + 1 ))\n  done\n\n  echo \"result: $result\"", "  # For numbers greater than\
    \ 10, we can't compute a larger one that doesn't divide evenly\n  if [ \"$1\"\
    \ -gt 10 ]; then\n    echo \"No largest divisor for $1\"\n    return 1\n  fi\n\
    \n  # If we don't have a number, don't bother looking for a divisor\n  test -z\
    \ \"$1\"\n  return 0", "  local n divisor\n  (( n=\"$1\" ))\n  (( divisor=\"$2\"\
    \ ))\n  # Echo \"$1\" to stdout and stderr for debugging\n  echo \"$1: n=$n\"\
    \ 1>&2\n  echo \"$1: divisor=$divisor\" 1>&2\n  # Do the division\n  if (( n %\
    \ divisor == 0 )); then\n    echo \"$n: is a divisor of $divisor\" 1>&2\n  else\n\
    \    echo \"$n: is a divisor of $divisor\" 1>&2\n    local max\n    if (( n >\
    \ 0 )); then\n      # Recurse\n      (( max=\"$(( n / divisor + 1 ))\" ))\n  \
    \    largest_divisor \"$max\" \"$divisor\"\n    else\n      echo \"$n: is less\
    \ than 1\" 1>&2\n      echo \"$n is a divisor of 1!\" 1>&2\n    fi\n  fi", " \
    \ local n=\"$1\"\n  if (( $n <= 1 )); then\n    echo \"0\"\n    return\n  fi\n\
    \n  local factor=1\n  local max_num=0\n  local max=1\n\n  # Find the largest number\
    \ smaller than n that divides n evenly\n  for ((i=1; i<=$(( $n-1 )); i++)); do\n\
    \    if (( $(( $i % $n )) == 0 )); then\n      factor=$(( factor * $n ))\n   \
    \   if (( $factor > $max )); then\n        max=$factor\n      fi\n    fi\n  done\n\
    \n  echo \"$max\"", "    local -r n=$1\n    echo $(( (n % $(( (n % 2) * 2 )) )\
    \ + $(( (n % 2) * 2 )) )) )", "  n=$1\n  max_div=1000000000\n  for i in {1..$n};\
    \ do\n    div=$((i%$n))\n    if [[ $div -eq 0 ]]; then\n      max_div=$((max_div+i))\n\
    \    fi\n  done\n  echo $max_div", "  local n m max\n  n=\"$1\"\n  max=\"$n\"\n\
    \  m=$n\n  while (( m > 1 )); do\n    m=$(($m/2))\n    [ $(( (n%m) )) -gt $max\
    \ ] && max=$n\n  done\n  echo $max", "\tlocal val=\"$1\"\n\tlocal div=\"$2\"\n\
    \tlocal maxval=\"$div\"\n\tlocal maxdiv=\"$div\"\n\tlocal i\n\tlocal n\n\n\tfor\
    \ (( i = 3; i <= 16; i++ )); do\n\t\tn=$(( (val % i) > 0 ? val % i : i ))\n\t\t\
    [ \"$n\" -eq \"$maxval\" ] && [ \"$n\" -eq \"$maxdiv\" ] && maxval=\"$n\"\n\t\t\
    [ \"$n\" -eq \"$div\" ] && maxdiv=\"$n\"\n\tdone\n\techo \"$maxval\"", "    ((\
    \ n = $1 ))\n    (( div = n ))\n    (( max_div = div))\n    while (( $div > 1\
    \ )); do\n        (( div = div / 2 ))\n        (( max_div = div))\n    done\n\
    \    echo \"$max_div\""]
stop_tokens:
- "\n}"
