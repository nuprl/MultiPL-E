name: HumanEval_145_order_by_points
language: sh
prompt: "#!/bin/bash\n# Write a function which sorts the given list of integers\n\
  # in ascending order according to the sum of their digits.\n# Note: if there are\
  \ several items with similar sum of their digits,\n# order them based on their index\
  \ in original list.\n# For example:\n# >>> $(order_by_points \"1 11 -1 -11 -12\"\
  )\n# ['\"-1\"', '\"-11\"', '\"1\"', '\"-12\"', '\"11\"']\n# >>> $(order_by_points\
  \ \"\")\n# []\n#\n# $1 is a space-separated list\norder_by_points() {\n"
tests: "}\n\ncandidate() {\n    order_by_points \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"1 11 -1 -11 -12\") = \"-1 -11 1 -12 11\" ]]\n    [[ $(candidate\
  \ \"1234 423 463 145 2 423 423 53 6 37 3457 3 56 0 46\") = \"0 2 3 6 53 423 423\
  \ 423 1234 145 37 46 56 463 3457\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[\
  \ $(candidate \"1 -11 -32 43 54 -98 2 -3\") = \"-3 -32 -98 -11 1 2 43 54\" ]]\n\
  \    [[ $(candidate \"1 2 3 4 5 6 7 8 9 10 11\") = \"1 10 2 11 3 4 5 6 7 8 9\" ]]\n\
  \    [[ $(candidate \"0 6 6 -76 -21 23 4\") = \"-76 -21 0 4 23 6 6\" ]]\n}\n\nrun_test"
completions: ["  local list=\"$1\"\n  local tmp sum i digits result\n  IFS=' ' read\
    \ -r -a tmp <<<\"$list\"\n  IFS=+ sum=0\n  for ((i=0;i<${#tmp[@]};i++)) do\n \
    \   digits=${tmp[i]}\n    ((sum+=digits))\n  done\n  IFS=- read -r -a result <<<\"\
    @(${tmp[@]}|sort|sort -nr -k ${sum})\" #-n for numeric sort\n  echo \"${result[@]}\"",
  "    local -n arr=$1\n    local -a res\n    local sum\n    local -a tmp\n    for\
    \ idx in \"${!arr[@]}\"; do\n        sum=0\n        for i in \"${!arr[@]}\"; do\n\
    \            (( sum += ${arr[i]}))\n        done\n        echo \"${idx:+${idx}:\
    \ \\\"${sum}\\\"}\"\n    done", "    local i i2 i3 i4\n    local list_str=$1\n\
    \    local list_arr=(${list_str// *})\n    local order_arr=()\n    local total_digits=0\n\
    \    local j=1\n    for ((i = 0; i < ${#list_arr[@]}; i++)); do\n        i2=$(echo\
    \ \"${list_arr[i]}\" | tr ' ' '.' | awk '{print $2}')\n        i3=$(echo \"${list_arr[i]}\"\
    \ | tr ' ' '.' | awk '{print $3}')\n        i4=$(echo \"${list_arr[i]}\" | tr\
    \ ' ' '.' | awk '{print $4}')\n        (( total_digits += i3 + i4 + i2 ))\n  \
    \      order_arr[$j]=${list_arr[i]}\n        j=$(( $j + 1 ))\n    done\n    local\
    \ tmp_arr=()\n    local k=1\n    while [[ $k -lt ${#order_arr[@]} ]]; do\n   \
    \     tmp_arr[$k]=${order_arr[$k]}\n        k=$(( $k + 1 ))\n    done\n    local\
    \ count_idx=0\n    while [[ $count_idx -lt ${#tmp_arr[@]} ]]; do\n        local\
    \ tmp_str=\n        local tmp_sum=$(echo \"${tmp_arr[$count_idx]}\" | tr ' ' '.'\
    \ | awk '{print $3}')\n        if [[ $total_digits -gt 0 ]]; then\n          \
    \  if [[ ${tmp_sum} > ${total_digits} ]]; then\n                for (( i = 0;\
    \ i < ${#order_arr[@]}; i++ )); do\n                    if [[ ${order_arr[$i]}\
    \ = ${tmp_arr[$count_idx]} ]]; then\n                        tmp_str=${order_arr[$i]}\n\
    \                        break;\n                    fi\n                done\n\
    \            fi\n        fi\n        count_idx=$(( $count_idx + 1 ))\n       \
    \ order_arr[$count_idx]=${tmp_str}\n    done\n    echo \"${order_arr[@]}\"", " \
    \ local L=(${1//[^ ]/})\n  local A=( ${L[@]/#/} )\n  local B=(${L[@]/-/} )\n \
    \ local C=(${L[@]/./} )\n  local E=${#B[@]}\n  local D\n  local I\n  local I1\n\
    \  local J\n  local J1\n  local M\n  local S\n  local T\n  local O\n  local R\n\
    \  local U\n  local W\n  local X\n  local Y\n  local Z\n  local SZ\n  local OIFS\n\
    \n  OIFS=$IFS\n  IFS=\"-\"\n  R=$(printf \"%s\\n\" \"${A[@]}\" | sort -n)\n  IFS=$OIFS\n\
    \n  S=$(printf \"%s\\n\" \"${A[@]}\" | sort -n | uniq -c | sort -n -r | head -n\
    \ 1)\n  M=$(echo \"${S}\" | sed \"s/^[[:space:]]*\\([0-9][0-9]*\\)[^[:space:]]*$/\\\
    1/\")\n  IFS=$OIFS\n\n  if [[ \"${M}\" =~ ^[0-9]+$ ]]; then\n    A=($(echo \"\
    ${S}\" | sed \"s/^[[:space:]]*\\([0-9][0-9]*\\)[^[:space:]]*$/\\1/\"))\n    D=$(echo\
    \ \"${A[@]}\" | sort -n | uniq -c | sort -n -r)\n    if [[ ${D[0]} -gt 1 ]]; then\n\
    \      W=\"$(echo \"${A[@]}\" | sort -n | uniq -c | sort -n -r | head -n 1)\"\n\
    \      X=\"$(echo \"${D}\" | sed \"s/^[[:space:]]*\\([0-9][0-9]*\\)[^[:space:]]*$/\\\
    1/\")\"\n      SZ=$(printf \"%s\" \"${A[@]}\" | sort -n | uniq -c | sort -n -r\
    \ | head -n 1)\n      for I in $(seq 0 \"${E}\"); do\n        I1=$(expr \"$I\"\
    \ '<=' \"${E}\")\n        J1=$(expr \"$I1\" '+' '1')\n        for J in $(seq 0\
    \ \"${E}\"); do\n          J1=$(expr \"$J1\" '+' '1')\n          M=$(printf \"\
    %s\\n\" \"${B[@]}\" | sort -n | uniq -c | sort -n -r | head -n ", "    local _points\
    \ _sum $1 i len\n    _points=$( echo \"$1\" | tr ' ' ',' ) # Split by space\n\
    \    _sum=$( echo \"${_points}\" | tr ',' '+' )\n    # Remove leading +, since\
    \ this will be summed later\n    local _sum=${_sum#+}\n    local _sort\n    local\
    \ -i j k\n    _sort=\"\"\n    for (( i=${#_points[@]}-1 ; i>=0 ; i-- )); do\n\
    \        local _point=${_points[$i]}\n        local _sum=${_sum%?}\n        if\
    \ (( _sum == 0 )); then\n            if (( ${_point} > 0 )); then\n          \
    \      _sort=\"${_sort},\\\"${_point}\\\"\"\n            else\n              \
    \  _sort=\"${_sort},\\\"${_point}\\\"\"\n            fi\n        else\n      \
    \      if (( _sum > 0 )); then\n                _sort=\"${_sort},\\\"${_point}\\\
    \"\"\n            else\n                j=$i\n                for (( k=${#_points[$j]}\
    \ ; k>0 ; k-- )); do\n                    local _point1=\"${_points[$j]}${_points[$k]:0:1}\"\
    \n                    if (( ${_sum} == ${_point1} )); then\n                 \
    \       j=$k\n                        break\n                    fi\n        \
    \        done\n                if (( j < i )); then\n                    local\
    \ _point2=\"${_points[$i]}${_points[$j]:0:1}\"\n                    if (( ${_sum}\
    \ < ${_point2} )); then\n                        _sort=\"${_sort},\\\"${_point2}\\\
    \"\"\n                    fi\n                else\n                    _sort=\"\
    ${_sort},\\\"${_point}\\\"\"\n                fi\n            fi\n        fi\n\
    \    done\n    echo \"${_sort}\"", "    if [ -z \"$1\" ] ; then\n        echo\
    \ \"[ -z \"$1 ]\" > /dev/stderr\n        echo \"[empty list]\" > /dev/stderr\n\
    \        exit 1\n    fi\n    IFS=' ' read -ra array <<< \"$1\"\n\n    # sort elements\
    \ by sum of digits\n    local sorted=()\n    local -n sums=$BASH_REMATCH\n   \
    \ local digits=$(( ${#sums[@]} ))\n    local index=0\n\n    # sort elements\n\
    \    for element in \"${array[@]}\"; do\n        sum=${element:$digits:1}\n  \
    \      sums[$index]=$sum\n        ((index++))\n    done\n    sorted=( \"${sorted[@]}\"\
    \ )\n\n    # sort elements by their index in original list\n    for index in \"\
    ${!sums[@]}\"; do\n        sorted[$index]=\"$index\"\n    done\n\n    # sort elements\
    \ by their sum\n    for index in \"${!sums[@]}\"; do\n        sorted[$index]=\"\
    \\\"${sums[$index]}\\\"\"\n    done\n\n    local last=${sorted[${#sorted[@]} -\
    \ 1]}\n    local first=${sorted[0]}\n\n    # output sorted elements\n    local\
    \ result=()\n    for element in \"${sorted[@]:0:$(( $last - $first + 1 ))}\";\
    \ do\n        result+=(\"$element\")\n    done\n    echo \"${result[@]}\" > /dev/stderr",
  "    local number=$1\n    # split numbers into array based on space\n    IFS=' '\
    \ read -r -a numbers_array <<< \"$number\"\n    # initialize sum array\n    local\
    \ sums_array=()\n    # initialize point sum array\n    local point_sums_array=()\n\
    \    # initialize indexes array\n    local indexes_array=()\n    # initialize\
    \ output array\n    local output_array=()\n    # loop through the numbers\n  \
    \  for (( i=1; i <= ${#numbers_array[@]}; i++ )); do\n        sums_array+=(0)\n\
    \        point_sums_array+=(0)\n        indexes_array+=(0)\n        local number=$numbers_array[i]\n\
    \        # split number into digits and put into array using bash regex split\n\
    \        IFS=- read -r -a number_digits <<< \"$number\"\n        # loop through\
    \ the digits\n        for (( j=0; j < ${#number_digits[@]}; j++ )); do\n     \
    \       # get current digit in current loop\n            local digit=${number_digits[j]}\n\
    \            # calculate sum of current digit\n            local point_sum=${point_sums_array[j]}+$digit\n\
    \            # put current sum into array and add it to the point sum\n      \
    \      sums_array+=($point_sum)\n            point_sums_array+=($point_sum)\n\
    \            indexes_array+=($j)\n        done\n        # get the max point sum\
    \ from the point sums array\n        local max_point_sum=${point_sums_array[0]}\n\
    \        # loop through the point sums array\n        for (( j=1; j < ${#point_sums_array[@]};\
    \ j++ )); do\n            # get current point sum in current loop\n          \
    \  local point_sum=${point_sums_array[j]}\n            # if the point sum is the\
    \ max point sum, sort it first\n            if [[ $point_sum == $max_point_sum\
    \ ]]; then\n                indexes_array+=(${indexes_array[j]})\n           \
    \ # if the point sum isn't, find out which index is the max point sum\n      \
    \      elif [[ $point_sum != $max_point_sum ]]; then\n                # get the\
    \ index of maximum point sum\n                local max_index=${indexes_array[j]}\n\
    \                # get the current max point sum\n                local max_point_sum=${point_sums_array[$max_index]}\n\
    \                # find the index where current max point sum exceeds the max\
    \ point sum\n                while [[ $max_point_sum > $point_sum ]]; do\n   \
    \                 indexes_array+=(${indexes_array[$max_index]}-1)\n          \
    \          point_sums_array+", "  local LIST=\"$1\"\n  [[ -z \"$LIST\" ]] || return\n\
    \  local SORT_FUNC=\"-n\"\n  local ORDERED=()\n  local INDEX=\n  local N=0\n \
    \ local INDEXS=()\n  local VAL\n  local CHARACTERS=()\n\n  while read -ra CHARACTERS;\
    \ do\n    ((N++))\n    INDEX=\"$N\"\n    while (( \"$N\" < \"${#CHARACTERS[@]}\"\
    \ )); do\n      VAL=\"$(echo \"${CHARACTERS[$N]}\" | cut -c1-2)\"\n      if [[\
    \ ! -z \"$INDEX\" ]]; then INDEXS+=( \"$INDEX\" ); fi\n      (( N++ ))\n    done\n\
    \    (( INDEXS[ ${#INDEXS[@]} ] += 1 ))\n    INDEXS[ ${#INDEXS[@]} ]=\"${INDEXS[\
    \ ${#INDEXS[@]} ]}\"\n    ORDERED+=( \"${INDEXS[*]}\" )\n  done <<< \"$LIST\"\n\
    \  echo \"${ORDERED[@]}\"", "    # Sort by points (for now) but use original order\
    \ for tie\n    sort -g $1 | while read p; do\n        local n=0\n        local\
    \ x=0\n        local y=0\n        local i=0\n        local s=0\n        local\
    \ d=${p}\n\n        while [[ $d =~ ^[0-9]+ ]]; do\n            d=$(expr $(expr\
    \ <<<\"$d\"*\"$p\")*$(expr <<<\"$s\"*\"$p\")/$(expr <<<\"$n\"*\"$p\"))\n     \
    \       i=$(( ${#d} - 1 ))\n            (( n += ${#d}))\n            (( x -= ${#d}\
    \ * $i ))\n            (( s += ${#d} * $(( ${#d} * ( $i + 1 ))))\n        done\n\
    \        echo \"$s\"\n    done", "  local ii sum\n  local str=\"$1\"\n\n  ii=${str//-/\
    \ }\n  for ii in $ii; do\n    sum=\"$( echo \"$ii*$i\" | bc | tr -d '.' )\" \n\
    \    [ $sum != $ii ] && echo \"$sum - $ii\" || echo \"$ii\"\n  done", "  local\
    \ -n arr=(\"$@\")\n  arr=( \"${arr[@]}\" )\n  local sum\n  local index\n  local\
    \ elements\n  local sorted\n  local key\n  local i\n  local j\n\n  elements=(${(@:)arr[@]})\n\
    \  sum=$(echo \"${elements[*]}\" | xargs printf '%d')\n  sorted=()\n\n  for key\
    \ in \"${!arr[@]}\"; do\n    index=\"${key}\"\n    sorted+=(\"${arr[index]}\"\
    )\n  done\n\n  local i1\n  local i2\n\n  for (( i1=0; i1<${#sorted[*]}; i1++ ));\
    \ do\n    local sum1=\"${sorted[$i1]}\"\n    local i1i1\n    local i1i2\n    local\
    \ j\n\n    for (( j=0; j<${#sorted[*]}; j++ )); do\n      local sum2=\"${sorted[j]}\"\
    \n      local i1i1=\"${i1}\"\n      local i1i2=\"${i1}\"\n\n      # The key must\
    \ be less, equal to or greater than the first sum.\n      [[ \"$sum1\" -le \"\
    $sum2\" ]] \\\n        || [[ \"$sum2\" -ge \"$sum1\" ]] \\\n        || [[ \"$i1i1\"\
    \ -ge \"$i1i2\" ]]\n\n      if [[ \"$sum1\" -le \"$sum2\" ]]; then\n        sorted=(\"\
    ${sorted[@]/$i1i1/$i1i2}\" \"${sorted[@]/$i1i2/$i1i1}\")\n        break\n    \
    \  fi\n\n      if [[ \"$sum2\" -ge \"$sum1\" ]]; then\n        sorted=(\"${sorted[@]/$i1i2/$i1i1}\"\
    )\n        break\n      fi\n\n      if [[ \"$i1i1\" -ge \"$i1i2\" ]]; then\n \
    \       sorted=(\"${sorted[@]/$i1i1/$i1i2}\")\n        break\n      fi\n    done\n\
    \  done\n\n  echo \"${sorted[@]}\"", "  local -n array=\"$1\"\n  # The array is\
    \ empty.\n  echo \"$array\"\n\n  # Set variable for number of array elements (the\
    \ length of the list).\n  local length=\"${#array[@]}\"\n\n  # The array to hold\
    \ the result.\n  local -n result=\"$2\"\n\n  # Start at index 1, not 0, to allow\
    \ looping upwards.\n  local index=1\n\n  # Add up each digit, starting from the\
    \ one on the left. At each index\n  # where there is a tie, increment the index\
    \ by 1, and move on to the next digit.\n  while [ \"$index\" -le \"$length\" ];\
    \ do\n    local sum=\"$(cut -d \" \" -f1 <<< \"${array[$index]}\" | xargs)\"\n\
    \    local index=\"${index} + 1\"\n\n    # If this digit already exists in the\
    \ result already, increment it's\n    # value and keep going.\n    if [[ \" ${result[@]}\
    \ \" =~ \" ${sum} \" ]]; then\n      ((index+=1))\n      continue\n    fi\n\n\
    \    array[$index]=\"${sum}\"\n    result+=(${sum})\n  done\n  unset sum\n\n \
    \ # Sort the result array in ascending order, using the sort command.\n  # The\
    \ sort command will compare strings lexicographically, so the\n  # strings that\
    \ should be equal in the array will match exactly\n  # when the string in the\
    \ array is compared to itself.\n  # This is accomplished using \"=~\", which is\
    \ a regular expression matching\n  # operator. Basically, this tells the sort\
    \ command to only use characters\n  # that match the regex \"^[a-zA-Z0-9]+$\"\
    \ from the beginning of the\n  # string, and the strings are exactly the same.\n\
    \  local -n strings=$result\n  echo \"${result[@]}\" | sort -n | sed 's/ /\\\\\
    \ /g' | \\\n    sort -nr | sed 's/ /\\\\ /g' | sort -n | sed 's/^/\"/' | \\\n\
    \    sed 's/$/\"/g' | sed 's/\"\\\\\"/\"/g'", "    local sorted_list\n\n    sorted_list=$(bc\
    \ <<< \"$1\" | \\\n    sed -e 's/\\([0-9][0-9]*\\)/\"\\1\"/g' -e 's/ \\(\\-[0-9][0-9]*\\\
    )/\"-\"\\1/g' | \\\n    grep -Eo \"([0-9]+)\")\n\n    sort -n \"${sorted_list}\"",
  "  # We assume $1 is a space-separated list which contains\n  # one or more integers\n\
    \  local -a input=(\"$@\")\n  local -A sums\n  local -a output\n\n  for i in \"\
    ${!input[@]}\"; do\n    local -a digits=($i)\n    local sum\n    for ((i=0; i<${#digits[@]};\
    \ ++i)); do\n      sum=\"${digits[$i]}+$sum\"\n    done\n    ((sums[sum]++))\n\
    \  done\n\n  output=($(sort -n -k 2 <<<\"${!sums[@]}\"))\n\n  for idx in \"${!output[@]}\"\
    ; do\n    printf \"%s\\t%s\\n\" \"${input[$idx]}\" \"$idx\"\n  done\n\n  echo\
    \ \"\"", "  local IFS=\\\n    '([0-9]' '([0-9-]' '([0-9.]' '([0-9.e-]' '([0-9.e+]'\
    \ '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]'\
    \ '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]'\
    \ '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]'\
    \ '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]'\
    \ '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]'\
    \ '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]'\
    \ '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]'\
    \ '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]'\
    \ '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]'\
    \ '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]'\
    \ '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]'\
    \ '[0-9.e-]' '[0-9.e+]' '[0-9.-]' '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-]'\
    \ '[0-9.]' '[0-9.-]' '[0-9.e-]' '[0-9.e+]' '[0-9.-", "    local input=\"${1:-}\"\
    \n    local output_list\n    local point=\"\"\n    local num_list\n    local index=\"\
    \"\n    local num_sum=\"\"\n    local i=0\n\n    if [[ \"${input}\" == \"\" ]];\
    \ then\n        return\n    fi\n\n    output_list=$(sed 's/,$//' <<< \"${input}\"\
    )\n    for num_string in $output_list; do\n        num_list=($num_string)\n  \
    \      num=${num_list[0]}\n        if [[ ${num} =~ ^-?[0-9]+$ ]]; then\n     \
    \       num_sum=$(echo \"${num}\" | awk '{print $1+$2}')\n            if [[ ${num_sum}\
    \ -gt 0 ]]; then\n                point=\"${num_list[1]}\"\n                index=\"\
    ${num_list[0]}\"\n            fi\n        else\n            continue\n       \
    \ fi\n    done\n    i=$(($i + 1))\n    if [[ ${i} -gt ${#output_list} ]]; then\n\
    \        return\n    fi\n    sort_list \"${i}\" \"${output_list}\" \"${point}\"\
    \ \"${index}\"", "  local strings=( $1 )\n  local tmp=${strings[0]}\n  local sum=0\n\
    \  local sorted_strings=()\n  while [[ -n \"${tmp}\" ]]; do\n    sum=$(( ${sum}+${tmp}\
    \ ))\n    sorted_strings+=(\"${tmp}\")\n    tmp=${strings[$(( $idx-1 ))]}\n  done\n\
    \n  local first_item=${sorted_strings[0]}\n  local index=0\n  local sums=()\n\
    \  local max_index=$(expr $#strings - 1)\n  local last_item=${sorted_strings[$max_index]}\n\
    \  local last_sum=0\n\n  # find the sum of each digits in the sorted_strings\n\
    \  for index in $(seq 0 $max_index); do\n    sum=$(( ${sum}+${index}*${strings[$index]}\
    \ ))\n    sums+=(\"${sum}\")\n  done\n\n  # find the index of item with the max\
    \ sum\n  max_index=0\n  for index in $(seq 0 $max_index); do\n    if [[ $(( ${sums[$index]}\
    \ > ${sums[$(( $index-1 ))] }) -eq 0 ]]; then\n      max_index=$index\n    fi\n\
    \  done\n\n  # sort by first item then second item...\n  sorted_strings+=(\"${first_item}\"\
    )\n  sorted_strings+=(\"${sorted_strings[$(( $max_index-1 ))]}\")\n\n  # ...and\
    \ remove the first and last items\n  sorted_strings=( \"${sorted_strings[@]:0:$max_index-1}\"\
    \ )\n\n  if [ -n \"${strings[$max_index]}\" ]; then\n    sorted_strings+=(\"${last_item}\"\
    )\n    sorted_strings+=(\"${sorted_strings[$(( $idx-1 ))]}\")\n  fi\n\n  # print\
    \ the sorted_strings as list to stdout\n  for index in \"${sorted_strings[@]}\"\
    ; do\n    echo \"$index\"\n  done\n", "    # your code here\n    local tmp1 tmp2\n\
    \    tmp1=$(echo $1 | tr \" \" \",\")\n    tmp2=$(echo $1 | tr \" \" \",\" | sort\
    \ -n | tr -d '\"')\n    echo $tmp1,$tmp2", "\tlocal list=\"${1:-}\"\n\tlocal result=\"\
    \"\n\n\tfor element in $list; do\n\t\tlocal digits=$(echo \"$element\" | cut -c1-2\
    \ | sort -nr | sed -r 's/^(.{1})(.{1})(.*)$/\\\\2\\\\3/g')\n\t\tlocal sortpoint=$(echo\
    \ \"$element\" | cut -c2-3 | sort -nr | sed -r 's/^(.{1})(.{1})(.*)$/\\\\2\\\\\
    3/g')\n\t\tif [ \"$digits\" != \"$sortpoint\" ]; then\n\t\t\tresult=\"$result\
    \ $sortpoint $digits\"\n\t\telse\n\t\t\tresult=\"$result $sortpoint $element\"\
    \n\t\tfi\n\tdone\n\n\techo ${result}", "\tlocal -a items=(\"$1\")\n\tlocal -a\
    \ keys=()\n\tlocal -a sorted_items=()\n\tlocal -a sorted_keys=()\n\tlocal -a sorted_indices=()\n\
    \tlocal -a index_to_key\n\tlocal index_to_item\n\tlocal item\n\tlocal index\n\t\
    local -a key\n\tlocal sum\n\tlocal -a sums\n\tlocal -a sums_count\n\tlocal -a\
    \ sums_indices\n\tlocal -a sums_index\n\tlocal i\n\tlocal j\n\tlocal k\n\tlocal\
    \ sum\n\n\t# If the number of items is 0, return an empty list\n\t[[ $#items -gt\
    \ 0 ]] || return 0\n\n\t# Initialize the sums list\n\tsums_count=${#items[@]}\n\
    \tfor (( i=0; i<${#items[@]}; i++ )); do\n\t\tsums_index[$i]=0\n\tdone\n\n\t#\
    \ Add items to sums list\n\tfor (( i=0; i<${#items[@]}; i++ )); do\n\t\tsum=0\n\
    \t\tsums_index[i]=0\n\t\twhile (( \"${sums_count}\" )); do\n\t\t\t(( sum = sum\
    \ + ${items[$sums_index[$i]]} ))\n\t\t\t(( sums_index[$(( $sums_index[$i] + 1\
    \ ))] ))\n\t\t\t(( sums_count-- ))\n\t\tdone\n\t\tsums[$i]=$sum\n\tdone\n\n\t\
    # Order the sums list\n\t[[ $#sums -gt 0 ]] || return 0\n\twhile (( \"${#sums[@]}\"\
    \ )); do\n\t\tsum=${sums[$(( $#sums ))]}\n\t\t(( $# > 1 )) && break\n\t\tfor ((\
    \ i=0; i<${#sums[@]}; i++ )); do\n\t\t\t(( ${sums[$i]} > $sum )) && break\n\t\t\
    done\n\t\t(( $i < ${#sums[@]} )) && continue\n\t\tsum=${sums[$(( $#sums ))]}\n\
    \t\tbreak\n\tdone\n\n\t# Order the sums list according to the sums list\n\tfor\
    \ (( i=1; i<${#sums[@]}; i++ )); do\n\t\tsums_index[$i]=$i\n\tdone\n\tlocal -a\
    \ sorted_indices\n\tlocal -a sorted_sums\n\tlocal -a sorted_sums_index\n\tlocal\
    \ -a sorted_keys\n\tlocal sums_index_i\n\tlocal sums_i\n\t", "  local lines=$1\n\
    \  local output\n\n  # Removing non-integers\n  local stripped_lines\n  while\
    \ read line; do\n    [ -z \"$line\" ] && continue\n    stripped_lines+=$(remove_non_digits\
    \ \"$line\")\n  done <<< \"$lines\"\n\n  # Sorting\n  local sorted_lines\n  local\
    \ tmp\n  local digit\n  local num\n  local count\n  local sorted_tmp\n\n  count=1\n\
    \  for line in $stripped_lines; do\n    digit=$(echo $line | sed 's/^\\([0-9]*\\\
    )$/\\1/')\n    if [ \"$digit\" -eq \"0\" ]; then\n      digit=\"00\"\n    fi\n\
    \n    num=\"$(echo $line | sed 's/^-\\([0-9]*\\)$/\\1/')\"\n    if [ \"$num\"\
    \ -eq \"0\" ]; then\n      num=\"00\"\n    fi\n\n    sorted_tmp=\"$(echo $num\
    \ ${digit})\" #e.g. '01 00'\n\n    # Check if this element already exists in sorted_lines\n\
    \    sorted_line=\"\"\n    for sorted_line in $sorted_lines; do\n      sorted_line=\"\
    ${sorted_line} ${sorted_tmp}\"\n    done\n\n    if [ \"$sorted_line\" != \"\"\
    \ ]; then\n      # sort using original order if it already exists\n      sorted_lines+=$sorted_line\n\
    \    else\n      # else use alphabetical sorting\n      sorted_lines+=\"$line\"\
    \n    fi\n\n    count=$(( count+1 ))\n  done\n\n  if [ \"$count\" -gt 1 ]; then\n\
    \    echo -e \"WARNING: There are $count similar elements in the given list.\"\
    \n  fi\n\n  output=$(echo $sorted_lines | sort -nk)\n  echo -e \"$(echo $output\
    \ | sed 's/^ *//g')\"", "    local digits=\"${1// /}\".\n    local i=0\n    local\
    \ items=()\n    while [[ $i -lt ${#digits} ]]; do\n        local digit=\"${digits:$i:1}\"\
    \n        items+=(\"$digit\")\n        i=$((i+1))\n    done\n    local j=0\n \
    \   local sorted=()\n    for x in \"${items[@]}\"; do\n        local sum=\"${x:10}\"\
    \n        local j=0\n        while [[ $j -le ${#digits} ]]; do\n            local\
    \ digit=\"${digits:$j:1}\"\n            local v=\"${x:$j:10}\"\n            ((sum-=digit))\n\
    \            if (( sum > 0 )); then\n                sorted+=(\"$v\")\n      \
    \      fi\n            ((j+=($j+1)))\n        done\n    done\n    echo ${sorted[@]}",
  "    local input=\"$1\"\n    local result=()\n    local digits=()\n    local digit\n\
    \    local digits_string\n    local sum\n    local i\n\n    # parse given input\
    \ string into list of integers\n    while read -r i; do\n        digits+=(\"${i}\"\
    )\n    done\n\n    # sort digits by sum of digits\n    for ((i = 0; i < ${#digits[@]};\
    \ i++)); do\n        digits_string=\"${digits[i]#-}\"\n        sum=\"${digits_string#0}\"\
    +0\n        if (( ${sum} < ${#digits[@]} )); then\n            digits_string=\"\
    ${digits[${sum}]}\"\n        fi\n        digits[i]=${digits_string}\n    done\n\
    \n    # sort digits from original list according to given ordering\n    for ((i\
    \ = 0; i < ${#digits[@]}; i++)); do\n        sum=\"${digits[i]#-}\"\n        sum=\"\
    ${sum#0}\"+0\n        if (( ${#result[@]} <= ${sum} )); then\n            result+=(\"\
    ${digits[i]}\")\n        fi\n    done\n    IFS=\" \"\n    IFS=\"$IFS\"\n    echo\
    \ \"${result[@]}\"", "    local input=\"${1#?}\"\n    local sum\n    local sums=()\n\
    \    IFS=$'\\n'\n    for input in $input; do\n        sum=$(echo $input | sed\
    \ 's/\\([0-9]\\+\\)$/ \\1/')\n        if [ -z \"$sum\" ] || [ \"$(echo $sum |\
    \ sed 's/^0//')\" == \"$sum\" ]; then\n            sum=$input\n        fi\n  \
    \      sums+=(\"$sum\")\n    done\n    if [ -z \"$sum\" ]; then\n        sum=$input\n\
    \    fi\n    local sorted=()\n    local num\n    for num in \"${sums[@]}\"; do\n\
    \        if [ \"$(echo $num | cut -c1)\" == \"-\" ]; then\n            sorted+=(\"\
    $num\")\n        else\n            sorted+=(\"${sorted[@]}-$num\")\n        fi\n\
    \    done\n    IFS=$' \\t\\n'\n    IFS=\"\n\"\n    local sorted\n    for sorted\
    \ in \"${sorted[@]}\"; do\n        printf '\"%s\"\\n' \"$sorted\"\n    done",
  "    set -f\n    # Remove all newlines characters\n    set +f\n    local str=$1\n\
    \    set -f\n    # Iterate through input string\n    while read -a str; do\n \
    \       local i=0\n        local sum=0\n        local num=\n        for n in $str;\
    \ do\n            ((i++))\n            ((sum+=i==2 || i==4) ? sum+=n : sum+=n*10)\n\
    \        done\n        # Check if the sum of the digits is unique\n        # i.e.\
    \ if all digits are different.\n        [[ -z $num ]] || [[ \"$sum\" != $((10#$sum))\
    \ ]]\n    done < <(echo \"$str\")\n    # Return result as space-separated list\n\
    \    echo \"${str[@]}\"", "    local arr=($1)\n    local sum\n    local count\n\
    \n    for index in ${!arr[*]}; do\n        sum=$(expr $sum + ${arr[$index]})\n\
    \        count=$(($count+1))\n    done\n\n    # Sort the elements by descending\
    \ order of sum of their digits\n    # and order by their index in original list.\n\
    \    local sorted=()\n    local index\n    for index in $(seq 0 $(($count-1)));\
    \ do\n        sorted+=(\"${arr[$index]}\")\n    done\n    for index in $(seq 0\
    \ $(($count-1))); do\n        local key=$(expr $index + 1)\n        local val=${sorted[$key]}\n\
    \        sorted[$key]=${arr[$index]}\n        arr[$index]=${val}\n    done\n \
    \   echo \"${arr[*]}\"", "  local sorted_points=\"\"\n  local sum_digits=0\n \
    \ local i=0\n  for point in $@; do\n    i=$((i+1))\n    sum_digits=$((sum_digits\
    \ + $(point_digits $point)))\n    sorted_points=\"$sorted_points \\\"$point\\\"\
    \"\n  done\n  sorted_points=\"$sorted_points \\\"$i\\\"\"\n  if [[ $sum_digits\
    \ -gt 9 ]]; then\n    sorted_points=\"$sorted_points \\\"${sum_digits:0:1}\\\"\
    \"\n  fi\n  sorted_points=\"$sorted_points \\\"$sum_digits\\\"\"\n  echo \"$sorted_points\"",
  "\tlocal list=$(echo \"$1\" | sed -n 's/^\\([0-9]*\\) \\([0-9]*\\)/\"\\1\" \\2/p')\n\
    \tlocal sortedlist\n\tlocal sum\n\n\tsum=$(echo $list | xargs | sed 's/ //g' |\
    \ sort -nr | awk '{ print $1$2 }')\n\n\twhile [ \"$sum\" != \"0\" ]; do\n\t\t\
    sortedlist+=$(echo \"$sum\" | awk '{printf \"%i%s%s\", $1*10, $1, $2}')\n\t\t\
    sum=$(echo $list | xargs | sed 's/ //g' | sort -nr | awk '{ print $1$2 }')\n\t\
    done\n\tsortedlist+=$(echo \"$sum\" | awk '{printf \"%i%s%s\", $1*10, $1, $2}')\n\
    \n\techo \"$sortedlist\"", "  local sorted_list=$1\n  local sorted_list_length=${#sorted_list}\n\
    \  for (( i=0; i<${sorted_list_length}; i++ ))\n  do\n    local current_point=${sorted_list:$i:1}\n\
    \    local current_point_length=${#current_point}\n    local new_point=\"\"\n\
    \    for (( j=0; j<${current_point_length}; j++ ))\n    do\n      local next_point=${current_point:$j:1}\n\
    \      new_point=\"$new_point ${next_point}\"\n    done\n    local next_point_length=${#new_point}\n\
    \    local next_point_value=$(printf \"%d\" \"${new_point}\")\n    local next_point_sum=$(printf\
    \ \"%d\" \"${current_point_value}\" \"${next_point_value}\")\n    if [[ ${next_point_sum}\
    \ -gt ${sorted_list_sum} ]]\n    then\n      sorted_list=\"${sorted_list} ${next_point}\"\
    \n    fi\n    sorted_list_sum=$(printf \"%d\" \"${sorted_list_sum}\" \"${next_point_sum}\"\
    )\n  done\n  echo ${sorted_list}", "    IFS=$'\\n' read -r -a array <<< \"$1\"\
    \n    mapfile -t array < <(\n        sort -k 2 -t '\"' -k 4 \"$array[@]\"\n  \
    \  )\n    IFS=$' \\t\\n' \"${array[@]}\"", "    local items=$(echo $1 | tr \"\
    \ \" \"\\n\")\n    local tmp\n    local tmp2\n    local tmp3\n    local sort_str=\n\
    \    local index\n    local digits=\n\n    # Add extra quotes for string values\n\
    \    for str in $items; do\n        # Remove quotes\n        tmp=\"${str#\\\"\
    }\"\n        digits=\"$digits $(expr index $tmp 0)\"\n    done\n\n    # Sorting\
    \ logic\n    for str in $items; do\n        # Parse out digits and calculate sum\n\
    \        tmp=\"${str#\\\"}\"\n        tmp2=\"${tmp:0:1#\\\"}\"\n        tmp3=\"\
    ${tmp:2:1#\\\"}\"\n        index=\"$(expr index $tmp $tmp2 $tmp3)\"\n        sort_str=\"\
    $sort_str'\\\"$index\\\"'\"\n    done\n\n    # Remove extra quotes\n    sort_str=\"\
    ${sort_str#\\\"}\"\n\n    # Sort string with quotes\n    sort_str=$(echo $sort_str\
    \ | sed -e 's/\\\"/\\\"\\\"/g')\n    sort_str=$(echo $sort_str | sed -e 's/,/\"\
    ,\"/g')\n    sort_str=$(echo $sort_str | sed -e 's/^/\\\"/g')\n    sort_str=$(echo\
    \ $sort_str | sed -e 's/$/\\\"/g')\n    sort_str=$(echo $sort_str | sed -e 's/%/%/g')\n\
    \    sort_str=$(echo $sort_str | sed -e 's/,/\",\"/g')\n    sort_str=$(echo $sort_str\
    \ | sed -e 's/^/\\\"/g')\n    sort_str=$(echo $sort_str | sed -e 's/$/\\\"/g')\n\
    \    sort_str=$(echo $sort_str | sed -e 's/%/%/g')\n\n    # Sort numerically\n\
    \    items=$(echo $items | tr \" \" \"\\n\")\n    items=$(echo $items | tr \"\
    ,\" \"\\n\")\n    items=$(echo $items | tr \";\" \"\\n\")\n    items=$(echo $items\
    \ | tr \":\" \"\\n\")\n    items=$(echo $items | tr \"/\" \"\\n\")\n    items=$(echo\
    \ $items | tr \":\" \"\\n\")\n    items=$(echo $items | tr \"=\" \"\\n\")\n  \
    \  items=$(echo $items | tr \".\" \"\\n\")\n    items=$(echo $items | tr \"@\"\
    \ \"\\n\")\n    items=$(echo $items | tr \"|\" \"\\n\")\n    items=$(echo $items\
    \ | tr \"\\\"\" \"\\n\")\n    items=$(echo $items | tr \"[\" \"\\n\")\n    items=$(echo\
    \ $", "  local i\n  i=1\n  while [ $# -gt 0 ]; do\n    if [[ \"$1\" == -* ]];\
    \ then\n      shift # ignore \"-\"\n    else\n      i=1\n      while [ -n \"$1\"\
    \ ] && [ $i -gt 0 ]; do\n        # sort by digits\n        if [ \"$(echo \"$1\"\
    \ | awk '{print $1}'| sort --numeric-sort | tr -d '\\n')\" = \"$1\" ]; then\n\
    \          break\n        fi\n        ((i++))\n      done\n      if [ $i -eq 1\
    \ ]; then\n        echo \"$1\" >> $2\n      else\n        if [ \"$(echo \"$1\"\
    \ | awk '{print $1}'| sort --numeric-sort | tr -d '\\n')\" = \"$1\" ]; then\n\
    \          sort -t $'\\t' -k 2 $2 | sort -t $'\\t' -k 1n > $2\n        else\n\
    \          sort -t $'\\t' -k 2 $2 | sort -t $'\\t' -k 2n > $2\n        fi\n  \
    \    fi\n      shift\n    fi\n  done", "  local i s sum\n  i=1\n  s=''\n  while\
    \ [ $i -lt \"$#\" ];\n  do\n    sum=`echo \"${!i}\" | awk -F'[- ]' '{print $1+$2+$3+$4+$5}'`\n\
    \    if [ \"${!i}\" = \"${!sum}\" ]; then\n      s=\"$i$s\"\n    else\n      if\
    \ [ \"$s\" != \"\" ]; then\n        if [ $s != \"\" ]; then\n          echo \"\
    $s\"\n        else\n          echo \"$i\"\n        fi\n      fi\n      s=\"$s\"\
    \n      i=$i\n    fi\n    i=$((i+1))\n  done\n  if [ \"$s\" != \"\" ]; then\n\
    \    if [ $s != \"\" ]; then\n      echo \"$s\"\n    else\n      echo \"$i\"\n\
    \    fi\n  fi", "    local LIST\n    LIST=\"$1\"\n    local SORT_COMMAND\n   \
    \ SORT_COMMAND=\"sort -rnk4\"\n\n    if [[ -z \"$LIST\" ]]; then\n        echo\
    \ \"[]\"\n    else\n        echo \"$LIST\" | $SORT_COMMAND\n    fi", "  local\
    \ list=\"$1\"\n  shift\n  local result\n  local sum\n\n  while read number; do\n\
    \    sum=$(echo \"$number\" | awk '{print $1*$1*$2*$2*$3*$3}')\n    if [ \"$sum\"\
    \ = \"0\" ]; then\n      result=\"$number\"\n    elif [[ \" ${result// }\" !=\
    \ \" $number \" ]]; then\n      result=\"${result}, $number\"\n    fi\n  done\
    \ <<< \"$list\"\n\n  # Sort based on original order in list\n  echo \"${result//,\
    \ /$'\\n'}\"", "    local -n arr=$1\n    local -n result=$2\n    local -n digits=${3:-0}\n\
    \n    [[ $# -eq 0 ]] && return 0\n\n    local -a sorted_arr\n    local -a index_arr\n\
    \    local -i cnt\n    local -i sum\n\n    [[ -n $arr ]] || return 1\n\n    arr=(\"\
    ${(@usorted)arr}\")\n    result=(\"${(@usorted)result}\")\n    digits=${digits:-0}\n\
    \n    [[ -z $digits ]] && digits=${#arr[@]}\n\n    # Compute sum of digits in\
    \ arr\n    for ((cnt=0; cnt<${#arr[@]}; cnt++)); do\n        sum=0\n        while\
    \ [[ $((sum+arr[cnt])) < 10 ]]; then\n            sum=$((sum+arr[cnt]))\n    \
    \    done\n        result[$cnt]=$sum\n    done\n\n    # Sort by sum\n    sorted_arr=(${(@usorted)result[@]})\n\
    \n    # Re-arrange arr according to result\n    for ((cnt=0; cnt<${#sorted_arr[@]};\
    \ cnt++)); do\n        index_arr[$cnt]=${sorted_arr[$cnt]}\n    done\n\n    for\
    \ ((cnt=0; cnt<${#index_arr[@]}; cnt++)); do\n        arr[$index_arr[$cnt]]=${arr[cnt]}\n\
    \    done\n\n    echo \"${arr[@]}\"", "    IFS=' ' read -r -a points <<< \"$1\"\
    \n    local -n result=\n    for index in ${!points[@]}; do\n        point=\"${points[$index]}\"\
    \n        case \"$point\" in\n            \"0\") point=$(printf \"%02x\" \"${index}\"\
    )\n                ;;\n            \"1\") point=$(printf \"%02x\" \"${index}${point:+0}\"\
    )\n                ;;\n            *) point=${point/+/-}\n                point=$(printf\
    \ \"%02x\" \"${index}${point}\")\n                ;;\n        esac\n        ((\
    \ result[$index] = point ))\n    done\n    echo \"${result[*]}\"", "  local list=\"\
    $1\"\n  local sum\n  sum=0\n  while read -a array; do\n    (( sum += ${array[0]}\
    \ * ${array[1]} ))\n    case \"$sum\" in\n      0|*)\n        echo \"$array[@]\"\
    \ >> \"$list.sorted\"\n        ;;\n    esac\n  done\n  echo \"$(cat $list.sorted)\"",
  "  local i sum\n  local list=$1\n\n  # remove leading and trailing quotes\n  list=${#list#?}\n\
    \  list=${list%?}\n\n  # remove empty items\n  list=$(echo \"$list\" | sed -e\
    \ '/^$/d' -e '/^\\s*$/d')\n\n  # split list into items\n  items=$(echo \"$list\"\
    \ | sed -e 's/ \\+/ -/g')\n\n  # split items according to whitespace\n  for item\
    \ in $items; do\n    sum=$(echo $item | sed -e 's/ \\+/ -/g')\n    i=$(echo $item\
    \ | awk '{print index($0, $2)}')\n  done\n\n  # sort items by sum\n  items=$(echo\
    \ \"$items\" | awk '{print $1, $2, $3, $4, $5, $6, $7, $8}')\n  items=$(echo \"\
    $items\" | sort -t '-' -k 6n -k 8n -k 9n -k 10n | awk '{print $4, $2, $6, $3,\
    \ $1, $5, $7, $8}')\n\n  echo $items", "\tlocal sorted_list item\n\tsorted_list=\"\
    $1\"\n\tfor item in $sorted_list; do\n\t\t(($(echo $item | awk '{ print $1 + $2\
    \ + $3 }' | awk '{ print $1*3 + $2*3 + $3*3 }' | awk '{ print $1 }')))\n\tdone",
  "  # Check arguments\n  if [[ \"${#}\" -ne 1 ]]; then\n    echo \"Usage: $(basename\
    \ \"$0\") [list]\"\n    return 1\n  fi\n  local LIST=\"$1\"\n  # Convert list\
    \ to a sorted string\n  local LIST_SORTED=$(\n  echo \"${LIST}\"\n  | tr \" \"\
    \ \"\\n\"\n  | sort -g --numeric-sort --key=2 | sort --numeric-sort --key=1) #\
    \ Sort with GNU sort\n  # Extract sorted indices from LIST\n  local LIST_INDICES=$(\n\
    \  echo \"${LIST_SORTED}\"\n  | awk '{print $1}')\n  local RESULT=\"\"\n  # Loop\
    \ over LIST_INDICES and append each index to RESULT\n  for i in $(seq 0 \"${#LIST_INDICES}\"\
    ); do\n    RESULT=\"${RESULT}${LIST_INDICES[i]} \"\n  done\n  # Remove last space\
    \ from RESULT\n  RESULT=$(echo \"${RESULT}\" | cut -d \" \" -f 1)\n  # Return\n\
    \  echo \"${RESULT}\"\n  return 0", "    local L\n    L=$1\n    local i sum sorted_list\
    \ result\n    # parse input list\n    IFS=' ' read -a L <<< \"$L\"\n    read -a\
    \ sorted_list <<<\"$(set -- $(echo ${L[@]} | tr \" \" \"\\n\" | sort -n | awk\
    \ '{print $2}' | tr '\\n' ' ' | cut -d \" \" -f1))\"\n    result=()\n    i=0\n\
    \    # compute sum while computing sorted list\n    while ((i < ${#sorted_list[*]}))\n\
    \    do\n        sum=0\n        while ((i < ${#sorted_list[*]})) && (( sum < 10\
    \ ))\n        do\n            ((sum+=${sorted_list[i]}))\n            i=$((i+1))\n\
    \        done\n        # save result in result if sum is in the list\n       \
    \ if ((${result[@]} == \"\")); then\n            result+=(\"$sum\")\n        else\n\
    \            sum_to_append=\"$sum\"\n            index_to_append=$i\n        \
    \    while((i > 0)); do\n                sum_to_append=\"$(echo \"$sum_to_append+$result[i-1]\"\
    )\"\n                ((i--))\n            done\n            result+=(\"$sum_to_append\"\
    )\n        fi\n    done\n    echo \"${result[@]}\"", "    local result=$(eval\
    \ \"echo \\${${1//-/ }//+/-} ${1//-/;})\";\n    local sum=\"$(eval \"echo \\${${result//;/\
    \ }//+/ }\");\n    local i=0\n    local sorted=$(eval \"echo \\${${result//[0-9]/\
    \ }//;}\" | sort | uniq);\n    local num_list=\"\";\n    while [ -n \"$sorted\"\
    \ ]; do\n        num_list=\"$num_list \\\"$sorted\\\"\";\n        ((i++))\n  \
    \      sorted=$(eval \"echo \\${${result//[0-9]/ }//;}\" | sort | uniq | sed -e\
    \ \"s/$sorted,//\" -e \"s/$sorted//\");\n        if [ \"$i\" -eq \"$num_list\"\
    \ ];then\n            num_list=\"\";\n        fi\n    done\n    if [ -z \"$num_list\"\
    \ ]; then\n        local empty_list=\"\"\n    else\n        local empty_list=\"\
    []\"\n    fi\n    echo \"$empty_list\"", "    local inList num\n    local outList\n\
    \    local strLen lastStr prevSum idx\n    local chars prevChar chr tmp\n    #\
    \ Prepare an input list to work on\n    inList=$(tr ' ' '\\n' <<< \"$1\")\n\n\
    \    # Initialize the output list\n    outList=\"\"\n    # Initialize the current\
    \ sum\n    prevSum=0\n    # Initialize last string\n    lastStr=\"\"\n    # Initialize\
    \ the current index\n    idx=0\n    # Iterate through the input list\n    while\
    \ read -a chars; do\n        # Get current string\n        currStr=$(echo \"${chars[*]}\"\
    \ | tr ' ' '\\n' | sort -n)\n        # Get current sum\n        currSum=$(echo\
    \ \"${chars[*]}\" | tr ' ' '\\n' | sort -n | awk '{sum+=$1} END {print sum}')\n\
    \        # Save previous sum\n        prevSum=$currSum\n        # Save current\
    \ string\n        lastStr=\"${lastStr}\\n${currStr}\"\n        # Update index\n\
    \        idx=$((idx+1))\n    done <<< \"$inList\"\n\n    # Prepare output list\
    \ to work on\n    strLen=${#lastStr}\n    while (( \"$idx\" < \"$strLen\" ));\n\
    \    do\n        # Parse current string to get a char array\n        tmp=$(echo\
    \ \"${lastStr:$idx:1}\")\n        # Check if this is an invalid char\n       \
    \ if [[ \"$tmp\" =~ ^[0-9-]$ ]]; then\n            # If it is invalid, break out\
    \ the loop\n            break\n        fi\n        # Get current char\n      \
    \  chr=$(echo $tmp | sed 's/^[0-9-]//g')\n        # Push it to the output list\n\
    \        outList=\"${outList}\\n${chr}\"\n        # Increment the index\n    \
    \    idx=$((idx+1))\n    done\n\n    # Sort the output list according to its sum\n\
    \    outList=$(echo \"${outList}\" | tr ' ' '\\n' | sort -n)\n    # If there is\
    \ an output list, remove the trailing \\n\n    if [[ \"$outList\" != \"\" ]];\
    \ then\n        outList=${outList%$'\\n'}\n    fi\n\n    # Return the sorted list\n\
    \    echo \"$outList\"", "    local items=$(echo \"$1\" | tr \" \" \"\\n\")\n\
    \    if [ ${#items} -eq 0 ]; then return 0; fi\n    local total=0\n    for i in\
    \ $items; do\n        if [[ ${i} =~ ^-?[0-9]+$ ]]; then\n            local digits=$(echo\
    \ \"${i}\" | tr -cd '0-9')\n            local item=${digits:0:1}\n           \
    \ local other=${digits:1}\n            local tmp=${item}\n            while [\
    \ $tmp -lt ${other} ]; do\n                tmp=${item}${tmp}\n               \
    \ item=${other}\n                other=${item}\n            done\n           \
    \ total=$(( $total + $item ))\n        fi\n    done\n    local sorted\n    sorted=$(\
    \ IFS=\" \"; echo \"${items[@]}\" | tr \" \" \"\\n\" | sort -n -k ${total} -k\
    \ 2 -k 4 -k 6 -k 8)\n    echo \"$sorted\"", "    local numbers=$1\n    local sorted=\n\
    \    for (( i=0; i<${#numbers}; i++ )); do\n        local sum=0\n        for ((\
    \ j=0; j<${#numbers[*]} && (( ${numbers[$j]}+0 )); j++ )); do\n            sum=$((\
    \ $sum + ${numbers[$j]}+0 ))\n        done\n        sorted+=$(\n            IFS=$'\\\
    n' IFS=$'\\n' sort -n -k${sum} -k ${i} -k ${i} <<<\"$numbers\"\n        )\n  \
    \  done\n    echo $(IFS=' ' read -ra line; printf '%s\\n' \"${line[*]}\")", " \
    \   local sorted\n    local sorted_point\n    local input\n\n    for input in\
    \ \"$@\"; do\n        sorted=''\n        sorted_point=''\n        for point in\
    \ $input; do\n            if [[ ${#sorted_point} -lt ${#point} ]]; then\n    \
    \            sorted_point=${sorted_point}'\"$point\"'\n            else\n    \
    \            sorted+='\"$sorted_point\"'\n                sorted_point=''\n  \
    \          fi\n        done\n        if [ -z \"$sorted\" ]; then\n           \
    \ sorted='\"$sorted_point\"'\n        fi\n        echo $sorted\n    done", " \
    \ local items=$1\n  local index=1\n  local sum=0\n  local i\n  local item\n  local\
    \ output\n  sum=$(echo $items | sed 's/ *$//' | sed 's/ //g')\n  for item in $items;\
    \ do\n    (( index++ ))\n    digits=$(echo \"$item\" | sed 's/ //g' | sed 's/^\\\
    ([[:digit:]]\\+\\)$/\\1/')\n    (( sum += digits ))\n  done\n  output=$(echo \"\
    $items\" | sed \"s/ //g\" | sed \"s/^\\([[:digit:]]\\+\\)$/\\1/\" | sort -n |\
    \ sed \"s/^\\([[:digit:]]\\+\\)$/\\1/\")\n  output=\"${output} $index\"\n  if\
    \ [ \"$sum\" -eq \"$index\" ]; then\n    output=\"${output} 0\"\n  else\n    output=\"\
    ${output} $sum\"\n  fi\n  output=\"${output}\"\n  output=\"${output}\"\n  output=\"\
    ${output} $items\"\n  output=\"${output}\"\n  echo \"$output\"", "  local sorted_arr=(\
    \ )\n  for item in $(echo $1 | tr ' ' '\\n'); do\n    digits=$(echo $item | awk\
    \ '{print ($1 * 10 + $2)}')\n    sum=$(echo $digits | bc -l)\n    echo \"$sum\
    \ $item\"\n    sorted_arr+=( \"$item\" )\n  done\n  sorted_arr=($(sort -n \"${sorted_arr[@]}\"\
    \ | uniq))", "  local sorted_list=$(echo \"$1\" | tr '\\n' ' ' | sed 's/^ *//g'\
    \ | sort -n -k 2 \\\n    | sed 's/^ *\"\\(.*\\)\\(.*\\)\\(.*\\)\\(.*\\)\\(.*\\\
    )\"$/\\3 \"\\1\\2\"/g')\n  local sorted_list_sorted=$(echo \"$sorted_list\" |\
    \ sed 's/ /\\n/g' | sort -n -k 1 )\n  echo \"$sorted_list_sorted\"", "    local\
    \ -n list=$1\n    local -n sum=0\n    local -n max=0\n    local -n min=${#list[@]}\n\
    \    local -n result=()\n    local -n digit=0\n\n    for (( i=0; i<min; i++ ));\
    \ do\n        sum=${list[$i]+sum}\n        if (( sum > max )); then\n        \
    \    max=sum\n        fi\n    done\n    for (( i=0; i<min; i++ )); do\n      \
    \  digit=${sum%10}\n        sum=${sum/10}\n        if (( sum < min )); then\n\
    \            min=sum\n        fi\n        if (( list[$i] == $digit )); then\n\
    \            result=( \"${result[@]}\" \"$i\" )\n        fi\n    done\n\n    IFS=$'\\\
    n'\n    for (( i=1; i<min; i++ )); do\n        eval \"result=( \\${result[@]:0:$((i-1))}\
    \ '$i' )\"\n    done\n    IFS=", "\tlocal result=$1\n\tlocal digits=()\n\tlocal\
    \ i=0\n\twhile read -r item; do\n\t\tdigits[$i]=$item\n\t\t((++i))\n\tdone < <(echo\
    \ \"$result\" | tr ' ' '\\n' | sort -rn)\n\techo \"$digits\"", "\tIFS=\" \"\n\t\
    set -- \"$1\"\n\tdeclare -A points\n\twhile [[ $# -gt 0 ]]\n\tdo\n\t\t(( points[$((10#$(($(echo\
    \ \"$1\" | cut -d + | bc) + $points[$((10#$(($(echo \"$1\" | cut -d + | bc))))))])]++\
    \ ))\n\t\tpoints=( \"$@\" )\n\t\tshift\n\tdone\n\tunset IFS\n\techo \"${points[@]}\"",
  "  local input=\"$1\"\n  local -a points\n  IFS=$'\\n' read -r -a points <<< \"\
    $input\"\n  local -a results\n  local i=0 j=0\n  results=()\n  while [ $i -lt\
    \ ${#points[@]} ] || [ $j -lt ${#points[@]} ]; do\n    if [ $i -lt ${#points[@]}\
    \ ]; then\n      sum=$(sum_digits \"${points[$i]}\")\n    else\n      sum=$(sum_digits\
    \ \"${points[$j]}\")\n    fi\n    local ii=${i}\n    local jj=${j}\n    while\
    \ [ $ii -le ${#points[@]} ] && [ $jj -ge ${#points[@]} ]; do\n      local digit=${points[$ii]}\n\
    \      local other=${points[$jj]}\n      if [ $digit -gt $other ]; then\n    \
    \    results+=(\"$sum\")\n        break\n      fi\n      if [ $digit -le $other\
    \ ]; then\n        jj=$((jj+1))\n      fi\n      ii=$((ii+1))\n    done\n    i=$((i+1))\n\
    \    j=$((j+1))\n  done\n  results=$(printf \"'%s'\" \"${results[@]}\")\n  echo\
    \ \"$results\"", "  local sum=0\n  local i\n  local temp\n  local list=$1\n  local\
    \ count=0\n  local result=\"\"\n  local item\n  local temp_list=\"\"\n  local\
    \ sorted_list=\"\"\n\n  while IFS='' read -r line || [[ -n \"$line\" ]]; do\n\
    \    item=$line\n    temp_list=\"$temp_list '$item'\"\n  done <<< \"$list\"\n\
    \  temp_list=\"${temp_list#*$'\\n'}\"\n  temp_list=\"${temp_list%%$'\\n'*}\"\n\
    \  temp_list=\"${temp_list//$'\\n'/ }\"\n  temp_list=\"$temp_list\"\n\n  for i\
    \ in \"$temp_list\"; do\n    sum=$((sum + i))\n  done\n\n  while [ \"$count\"\
    \ -lt 10 ]; do\n    temp=$(printf \"%s\" \"$sum\" | bc)\n    sum=$((sum % 10))\n\
    \    if [ \"$temp\" -ge 0 ]; then\n      sorted_list=\"$sorted_list '$temp'\"\n\
    \    fi\n    count=$((count + 1))\n  done\n\n  echo \"$sorted_list\"", "  local\
    \ input_str=\"$1\"\n  local int_arr=($(echo \"$input_str\" | tr \" \" \"\\n\"\
    \ | sort -n -b -r | cut -d \" \" -f 1-1))\n  if [ -z \"$input_str\" ]; then\n\
    \    return 0\n  fi\n  local int_sum=$(echo \"$input_str\" | tr \" \" \"\\n\"\
    \ | sort -n -b -r | cut -d \" \" -f 1 | awk '{s+=$1} END {print s}')\n  local\
    \ sorted_ints=()\n  for (( i = 0; i < ${#int_arr[@]}; i++ )); do\n    if [[ $int_arr[$i]\
    \ == $int_sum ]]; then\n      sorted_ints+=(\"$int_arr[$i]\")\n    fi\n  done\n\
    \  echo \"${sorted_ints[@]}\"", "  local sorted_list\n  local numbers_w_digits\
    \ sort_function\n  local i\n  local number_to_sort_with_points\n  numbers_w_digits=$(echo\
    \ $1 | sed 's/ /,/g')\n  sort_function=\"$(sort_digits \"$numbers_w_digits\")\"\
    \n  echo \"$1\" | $sort_function > sorted_list\n  IFS=\" \"\n  sorted_list=\"\
    $(head -n-1 sorted_list)\"\n  echo $(tail -n+2 sorted_list)", "  local items=$(\n\
    \    echo \"$1\" |\n    sed \"s/^/\\\"/g; s/$/\\\"/g; s/ /, /g; s/,$//;\" |\n\
    \    cut -d, -f1 |\n    paste -sd+ - |\n    sort -n |\n    awk '\n    { a[$1]\
    \ = (a[$1])?a[$1] \",\" $0:$0; }\n    END { for (i in a) print a[i] }' |\n   \
    \ sed \"s/^\\\"//; s/\\\"$//\" |\n    tr '\\n' '\\0' |\n    sed \"s/,$//\"\n \
    \ )\n  echo \"${items[*]}\"", "    # Check if $1 is empty\n    if [ -z \"$1\"\
    \ ]\n    then\n        echo \"\"\n        return\n    fi\n\n    # Initialize variables\
    \ $sorted_list and $sum\n    sorted_list=\"\"\n    sum=\"0\"\n\n    # Loop through\
    \ all items in $1\n    for elem in $1;\n    do\n        # Extract a number from\
    \ $elem\n        num=\"$(expr \"$elem\" : '[0-9]+')\"\n\n        # Extract a digit\
    \ from $elem\n        digit=\"$(expr \"$elem\" : '\\([0-9]\\)')\"\n\n        #\
    \ Compute sum\n        sum=\"$(( $sum + $num))\"\n    done\n\n    # Sort the numbers\
    \ according to the sum of their digits\n    sorted_list=\"$(echo \"$1\" | \\\n\
    \        awk -F\" \" '{ print $1, $sum }' | \\\n        sort -n -k 2 -k 3 -k 4\
    \ | \\\n        awk '{printf \"%s\", $1}')\"\n\n    # Return $sorted_list\n  \
    \  echo \"$sorted_list\"", "    local input_list=\"$1\"\n    local input_list_sorted\n\
    \    input_list_sorted=$(\n        sort -n |\n        sed -e 's/^[+-][0-9]* *//'\
    \ -e 's/^[+-]//' -e 's/^ *//' -e 's/ *$//' |\n        sort -n\n    )\n    # order\
    \ each element of input_list based on its position in input_list_sorted\n    local\
    \ output_list\n    for input_item in $input_list; do\n        output_list=\"$output_list\
    \ \\\"${input_list_sorted[$((input_item-1))]}\\\"\"\n    done\n    # sort input_list\
    \ based on their sum of digits in ascending order\n    local output_list_sorted\n\
    \    output_list_sorted=$(\n        sort -n |\n        sed -e 's/^[+-][0-9]* *//'\
    \ -e 's/^[+-]//' -e 's/^ *//' -e 's/ *$//' |\n        sort -n\n    )\n    local\
    \ output_list_sorted_reversed\n    output_list_sorted_reversed=$(\n        sort\
    \ -n |\n        sed -e 's/^[+-][0-9]* *//' -e 's/^[+-]//' -e 's/^ *//' -e 's/\
    \ *$//' |\n        sort -rn\n    )\n    echo \"$output_list $output_list_sorted\
    \ $output_list_sorted_reversed\"", "        local input=$1\n        local output=\"\
    \"\n        local sum=0\n        local i=0\n        local j=0\n        local list_size=${#input[@]}\n\
    \        local input1=($input)\n        echo \"${input1[*]}\" | while read line;\
    \ do\n                sum=$(( $sum + $line ))\n                if [ $(( i%2 ))\
    \ -ne 0 ]; then\n                        output=\"$output \\\"$line\\\" \" \n\
    \                else\n                        output=\"$output \\\"$line\\\"\
    \ \"\n                fi\n                i=$(( i + 1 ))\n        done\n     \
    \   echo \"$output\" | sort -n | sed -e 's/^/\\\"/'", "\techo \"$1\" | sed -e\
    \ 's/^[ \\t]*//' -e '/^[ \\t]*$/d' -e 's/[ \\t]*$//' | sort -n -k2 | sed -e 's/^[\
    \ \\t]*//' -e '/^[ \\t]*$/d' | sed -e 's/[ \\t]*$//'", "    local list=$1\n  \
    \  local max_sum=0\n    local max_index=0\n    local sorted_list=\"\"\n    local\
    \ digits=\"\"\n    local index\n    local item\n    local sum\n    \n    # Iterate\
    \ through each item in the list and calculate the sum of its digits\n    # Then\
    \ compare the sum and index to decide which one is bigger\n    # If the sum is\
    \ bigger, the item is added to the sorted list\n    # If the sum is smaller, the\
    \ item is moved to the end of the list\n    for ((i=0; i < ${#list}; i++)); do\n\
    \        item=${list:$i:1}\n        digits=$(echo \"${item}\" | tr \" \" \"\\\
    n\" | sed \"s/\\(.*\\)\\(\\([0-9]\\)\\)\\(.*\\)/\\1 \\3/\")\n        sum=$(echo\
    \ \"${digits}\" | awk '{ sum += $1 + $2 } END { print sum}')\n        [[ $max_sum\
    \ == 0 || $sum > $max_sum ]] && max_sum=$sum || [[ $max_sum != 0 && $sum < $max_sum\
    \ ]] && max_sum=$sum\n        [[ $max_index == 0 || $i > $max_index ]] && max_index=$i\
    \ || [[ $max_index != 0 && $i < $max_index ]] && max_index=$i\n    done\n\n  \
    \  # Sort the list according to max_index\n    for ((i=max_index+1; i<${#list};\
    \ i++)); do\n        item=${list:$i:1}\n        digits=$(echo \"${item}\" | tr\
    \ \" \" \"\\n\" | sed \"s/\\(.*\\)\\(\\([0-9]\\)\\)\\(.*\\)/\\1 \\3/\")\n    \
    \    sum=$(echo \"${digits}\" | awk '{ sum += $1 + $2 } END { print sum}')\n \
    \       [[ $max_sum == 0 || $sum > $max_sum ]] && max_sum=$sum || [[ $max_sum\
    \ != 0 && $sum < $max_sum ]] && max_sum=$sum\n        sorted_list=$(echo $sorted_list\
    \ \"$(echo \"$item\" | sed \"s/\\\"//g\")\")\n    done\n\n    # Remove commas\
    \ in the list to separate each item\n    sorted_list=$(echo $sorted_list | tr\
    \ \",\" \" \")\n    sorted_list=$(echo $sorted_list | tr \" \" \",\" | sed 's/\\\
    \"//g')\n    echo $sorted_list", "  local list=\"$1\"\n  local sorted_points=()\n\
    \n  for number in $list; do\n    local digits=$(echo \"$number\" | sed -n 's/^.*\\\
    ((.*\\))$/\\1/p')\n    local index=$((10#$digits))\n    local sum=$((10#$digits))\n\
    \n    # sort according to sum of digits first\n    if [ \"$index\" -gt 0 ]; then\n\
    \      sum=$((10#$sum + 10#$index))\n    fi\n\n    # then sort according to original\
    \ list index\n    if [ \"$number\" != \"$sorted_points[${#sorted_points[*]}]\"\
    \ ]; then\n      sorted_points+=(\"$number\")\n    fi\n  done\n\n  echo \"${sorted_points[*]}\"",
  "    local sum=0\n    local numbers=( $1 )\n    local order\n    for number in \"\
    ${numbers[@]}\"; do\n        sum=$(($sum + $number))\n    done\n    local index=0\n\
    \    for number in \"${numbers[@]}\"; do\n        local item=$(echo ${number}\
    \ | tr -d '-' | sed -e 's/^\"//' -e 's/\"$//')\n        if [ \"$item\" -gt 0 ];\
    \ then\n            if [ \"$sum\" -gt 0 ]; then\n                if [ \"$item\"\
    \ -ne \"$order\" ]; then\n                    echo \"$index $order\"\n       \
    \             order=item\n                    index=0\n                fi\n  \
    \          else\n                echo \"$index $item\"\n                order=$item\n\
    \                index=$((index+1))\n            fi\n        fi\n    done\n  \
    \  echo \"$index $order\"", "    local input_line=$1\n    local input_line_elements=$(echo\
    \ \"$input_line\" | tr -cs '[:digit:]' '\\n')\n    local sorted_input=$(echo \"\
    $input_line_elements\" | sort -n -r | tr '\\n' ' ')\n    echo \"$sorted_input\"",
  "  local IFS=\\\\n \n  read -ra numbers <<<\"$1\"\n  local i\n  local numsum\n \
    \ local sorted\n  local temp\n\n  sorted=()\n  numsum=0\n  for ((i = 0; i < ${#numbers[*]};\
    \ i++)); do\n    numsum=$((${numbers[$i]} + numsum))\n  done\n  for ((i = 0; i\
    \ < ${#numbers[*]}; i++)); do\n    if [[ $numsum -ge ${numbers[$i]} ]]; then\n\
    \      temp=$(echo \"${numbers[$i]}\"|bc)\n      sorted+=($(echo \"${sorted[$i]}\
    \ ${temp}\"|bc -l))\n      numsum=$((numsum - ${numbers[$i]}))\n      i=$((i+1))\n\
    \    fi\n  done\n  unset IFS\n  echo \"${sorted[*]}\"", "    local input=\"$1\"\
    \n    local digits=$(echo \"$input\" | sed 's/ /+/g' | sed 's/-//g' | sed 's/^-//g'\
    \ | sed 's/^/-/g')\n    local sorted=$(echo \"$input\" | sed 's/^/+/g' | sort\
    \ -g | sed 's/^\\+//g')\n    local result=$(echo \"$sorted\" | sed 's/^\\+//g')\n\
    \    \n    if [ -z \"$input\" ]; then \n        echo \"[]\" \n    elif [ \"$input\"\
    \ = \"--help\" ]; then \n        echo \"Sort in ascending order according to the\
    \ sum of their digits:\n        Usage: $(basename \"$0\") [-h] [-p | --points-only]\
    \ [-w | --with-weight] [-t | --total] [-i | --index] [-s [START END]] [-f | --format-string\
    \ FORMAT] [-f | --format-output FORMAT]\"\n        echo \"    -h, --help     \
    \         display this help and exit\"\n        echo \"    -p, --points-only \
    \      output only points\"\n        echo \"    -w, --with-weight      output\
    \ with weight\"\n        echo \"    -t, --total             output with total\
    \ sum\"\n        echo \"    -i, --index             output with index per digit\"\
    \n        echo \"    -s, --start-end START   start number for output\"\n     \
    \   echo \"    -f, --format-string FORMAT  output format\"\n        echo \"  \
    \  -f, --format-output FORMAT output format\"\n        exit 0\n    elif [ \"$input\"\
    \ = \"--points-only\" -o \"$input\" = \"-p\" ]; then\n        echo \"$result\"\
    \ \n    elif [ \"$input\" = \"--with-weight\" -o \"$input\" = \"-w\" ]; then\n\
    \        echo \"$result $weight\"\n    elif [ \"$input\" = \"--total\" -o \"$input\"\
    \ = \"-t\" ]; then\n        echo \"$result $total_sum\"\n    elif [ \"$input\"\
    \ = \"--index\" -o \"$input\" = \"-i\" ]; then\n        echo \"$result $index_sum\"\
    \n    elif [ \"$input\" = \"--start-end\" ]; then\n        if [ \"$2\" ]; then\n\
    \            start=\"$2\"\n            end=\"$3\"\n        else\n            start=\"\
    $1\"\n            end=\"$1\"\n        fi\n        \n        echo \"$result $index_sum\
    \ $index_point\"\n    elif [ \"$input\" = \"--format-string\" ]; then\n      \
    \  if [ \"$2\" ]; then\n            format=\"$2\"\n        else\n            format=\"\
    %.0f\"\n        fi\n        echo \"$result $format\"\n    elif [ \"$input\" =\
    \ \"--format", "    local list_str=\"$1\"\n    local list sum\n\n    list=($list_str)\n\
    \    sum=()\n    for i in ${list[@]}; do\n\tsum+=($(echo \"$i $i $i $i $i $i $i\"\
    \ | sed \"s/-/ /g\" | awk '{sum += $1} END {print sum}'))\n    done\n    sorted=($(sort\
    \ -n -k 2 <<<\"${sum[@]}\"))\n    \n    for ((i=1; i < ${#list[@]}; ++i)) ; do\n\
    \tsorted[$i]=\"${list[$i]}\"\n    done\n\n    echo \"${sorted[@]}\"", '  echo
    "$1" | tr " " "\n" | sort -nr -k 2 | cut -d "(" -f 2 | cut -d ")" -f 2 | tr "
    " "\n"', "    local array=( $1 )\n    local sum=$( echo ${array[@]} | sed 's/\
    \ /+/g' )\n    local sort_by\n    local index\n    local sorted_list\n\n    #\
    \ sort by sum of digits, if two items have same sum, sort by their index in original\
    \ list\n    sort_by=\"-${sum}\"\n    if [ -n ${array[@]} ]; then\n        sorted_list=($(\
    \ IFS=$'\\n' ; printf \"%s\\n\" \"${array[@]}\" | sort -k $sort_by ))\n    else\n\
    \        sorted_list=()\n    fi\n\n    # return ordered list\n    IFS=$'\\n';\
    \ echo \"${sorted_list[@]}\"", "    local input=$(echo $1 |  tr ' ' \"\\n\" |\
    \ sort -n -t)\n    IFS=\"\\n\"\n    local output=$(echo $input | sort -n -t)\n\
    \    IFS=$'\\n'\n    echo $output", "    local num_list sort_list\n    num_list=$1\n\
    \    sort_list=$2\n    [[ $num_list == \"\" ]] && return 0\n    IFS=' ' read -ra\
    \ number_list <<< \"$num_list\"\n    [[ ${#number_list[@]} -eq 1 ]] && number_list+=(\"\
    0\") && num_list=\"$num_list\" || num_list=\"$(echo $num_list | sed 's/ /\" \"\
    /')\"\n    IFS=' ' read -ra sort_list <<< \"$sort_list\"\n    sum=0\n    for i\
    \ in \"${number_list[@]}\"; do\n        [[ $i =~ ^-?[0-9]+$ ]] || return 0\n \
    \       sum=\"$(( $sum + ${BASH_REMATCH[0]} ))\"\n    done\n    sort_list=($(sort\
    \ -n -k 1 <<< \"$sum\" \"$num_list\"))\n    sort_list=(\"${sort_list[@]}\")\n\
    \    sort_list=($(\n        echo -n \"${sort_list[@]:0:1}\"\n        echo \"${sort_list[1]}\"\
    \n    ))\n    sort_list=($(\n        echo -n \"${sort_list[2]}\"\n        echo\
    \ \"${sort_list[3]}\"\n    ))", "\tlocal input_arr=( $1 )\n\tlocal sorted=( $(\
    \ eval echo \\$\\{${input_arr[*]}\\} \\| sort -rnk4,4 | sed 's/^\\([^0-9]\\+\\\
    ).*/\"\\1\"/' ) )\n\tlocal output\n\tif [ ${#sorted[@]} -gt 0 ]; then\n\t\toutput=\"\
    ( ${sorted[*]} )\"\n\telse\n\t\toutput=\"[]\"\n\tfi\n\techo \"${output[@]}\"",
  "\tlocal input=\"$1\"\n\tlocal sorted_input=\"$(echo -e \"$input\" | sed -e 's/\
    \ \\+/\" \"/g')\"\n\tlocal total=$(echo \"$sorted_input\" | awk '{ print $1 }')\n\
    \tlocal sorted_total=\"$(echo -e \"$total\" | awk '{ print $1 }')\"\n\tlocal sorted_index=\"\
    $(echo -e \"$sorted_input\" | awk '{ print index($0, $1) }')\"\n\tlocal sorted_input2=\"\
    $sorted_input\"\n\tfor index in $(seq 0 $((${#sorted_input}-1)))\n\tdo\n\t\tlet\
    \ \"index--\"\n\t\tlocal item=\"${sorted_input2[$index]}\";\n\t\tlocal item_points=\"\
    $(echo \"$item\" | awk '{ print $1 }')\";\n\t\tlocal item_total=\"$(echo \"$item_points\"\
    \ | awk '{ print $1 }')\";\n\t\tlocal item_sorted_index=\"$(echo \"$item_sorted_index\"\
    \ | awk '{ print $1 }')\";\n\t\tlet \"item_total--\"\n\t\tif [ \"$item_total\"\
    \ -gt \"$sorted_total\" ]\n\t\tthen\n\t\t\tlet \"item_sorted_index++\"\n\t\telse\n\
    \t\t\tlet \"item_sorted_index--\"\n\t\tfi\n\t\tlocal item_sorted=\"${sorted_input2[$item_sorted_index]}\"\
    ;\n\t\tlet \"item_points-=\"\n\t\tlet \"item_total-=\"\n\t\tlet \"sorted_total+=\"\
    \n\t\tlet \"sorted_index+=\"\n\t\tlet \"sorted_input2[$index]=\"$item_sorted\"\
    \n\tdone\n\tlocal output=\"${sorted_input2[@]}\"\n\techo \"${output}\"", "  local\
    \ list order\n  list=( $1 )\n  order=($(printf '%s\\n' \"${list[*]}\" | sort -r\
    \ -n | uniq -c | sort -rn))\n  printf '%s\\n' \"${list[@]}\"", "  local -n points=$1\n\
    \  echo \"${points[@]}\" | sort -n", "    local input_str=\"$1\"\n    local input_arr=(\
    \ $input_str )\n    local input_arr_len=${#input_arr[@]}\n    local input_arr_num_digits=${#input_arr[*]:0:$input_arr_len-1}\n\
    \    local sorted_arr=()\n    # Sort the array of integers according to their\
    \ sum\n    # of their digits in descending order.\n    for (( i=0; i<$input_arr_num_digits;\
    \ i++ )); do\n        local input_str_reversed=${input_arr[$(( ${#input_arr[*]}\
    \ - 1 ))]:0:$i}\n        local input_arr_digits_sum=$(echo \"$input_str_reversed\"\
    \ | awk '{printf \"%.0f\\n\", $0+$1}')\n        local input_arr_sum=$(echo \"\
    $input_str_reversed\" | awk '{printf \"%.0f\\n\", $1}')\n        if [ \"$input_arr_sum\"\
    \ -gt \"$input_arr_digits_sum\" ]; then\n            local input_str_reversed_sorted=${input_str_reversed##-}\n\
    \            local input_arr_sorted_index=$(echo \"$input_str_reversed_sorted\"\
    \ | awk '{printf \"%d\\n\", $0+1}')\n            local input_arr_sorted_num=${input_arr[$input_arr_sorted_index]}\n\
    \            local input_arr_sorted_digits=${input_arr[$input_arr_sorted_index]:0:$i}\n\
    \            local input_arr_sorted_digits_sum=$(echo \"$input_arr_sorted_digits\"\
    \ | awk '{printf \"%.0f\\n\", $0+$1}')\n            local input_arr_sorted_sum=$(echo\
    \ \"$input_arr_sorted_digits\" | awk '{printf \"%.0f\\n\", $1}')\n           \
    \ if [ \"$input_arr_sorted_sum\" -gt \"$input_arr_digits_sum\" ]; then\n     \
    \           local input_arr_sorted=(${input_arr[@]})\n                local input_arr_sorted_arr=(\"\
    ${input_arr_sorted[@]}\")\n                local input_arr_sorted_arr_length=${#input_arr_sorted_arr[@]}\n\
    \                local input_arr_sorted_num_digits=${#input_arr_sorted_arr[*]:0:$input_arr_sorted_arr_length-1}\n\
    \                if [ \"$input_arr_sorted_num_digits\" -gt \"$i\" ]; then\n  \
    \                  local input_arr_sorted_num_index=${input_arr[@]:$i}\n     \
    \               local input_arr_sorted_num_num_digits=${#input_arr_sorted_num_num[*]:0:$i-1}\n\
    \                    local input_arr_sorted_num_num_digits_sum=$(echo \"$input_arr_sorted_num_num_digits\"\
    \ | awk '{printf \"%.0f\\n\", $0+1}')\n                    local input_arr_sorted_num_sum=$(",
  "  local sorted_list\n  local temp\n\n  sorted_list=$(echo \"$1\" | sed 's/[[:space:]]//g'\
    \ | sort -r)\n  while read -r temp; do\n    sorted_list+=(\"$temp\")\n  done <\
    \ <(echo \"$sorted_list\")\n  echo \"${sorted_list[@]}\"", "  local sum=0\n  local\
    \ index=0\n  local arr=( $1 )\n  IFS=$'\\n' arr=(${arr[@]})\n  for v in \"${arr[@]}\"\
    ; do\n    sum=$((sum+${v}+${sum}))\n  done\n  arr=()\n  local inum=0\n  local\
    \ sumnum=${sum}\n  while [ $sumnum -gt 0 ]; do\n    arr[$inum]=\"${sumnum}\"\n\
    \    inum=$((inum+1))\n    sumnum=${sumnum%?}\n  done\n  local res=()\n  local\
    \ first\n  for v in \"${arr[@]}\"; do\n    if [ \"$v\" == \"0\" ]; then\n    \
    \  first=\"$first\"\n    else\n      first=$v\n    fi\n  done\n  for v in \"${arr[@]}\"\
    ; do\n    if [ \"$v\" == \"0\" ]; then\n      continue\n    fi\n    sumnum=${v}\n\
    \    sumnum=$((sumnum+$first))\n    sumnum=$((sumnum+$first))\n    res[$index++]=\"\
    ${sumnum}\"\n  done\n  echo \"${res[@]}\"", "    local numbers=\"$1\"\n    local\
    \ prefix=\"\"\n    local suffix=\"\"\n    local max_sum=0\n\n    while read -r\
    \ number; do\n        if [ \"$numbers\" = \"\" ]; then\n            prefix=\"\
    $number\"\n            continue\n        fi\n\n        local sum=$(echo \"$number\"\
    \ | awk '{printf \"%.0f\", $0}')\n        max_sum=$((max_sum+sum))\n\n       \
    \ if [ \"$number\" = \"$prefix\" ]; then\n            suffix=\"$number\"\n   \
    \         continue\n        fi\n\n        if [ \"$sum\" -gt \"$max_sum\" ]; then\n\
    \            prefix=\"$number\"\n            suffix=\"$max_sum\"\n           \
    \ max_sum=$sum\n        fi\n    done < <(echo \"$numbers\" | tr \" \" \"\\n\"\
    \ | sort -n)\n    echo \"$suffix\"", "    if [ \"$1\" = \"\" ]; then\n       \
    \ echo \"Error: order_by_points: missing 1st argument.\"\n        return 1\n \
    \   fi\n    set -- \"$1\"\n    while (( \"$#\" )); do\n        if (( ${#BASH_REMATCH}\
    \ > 1 )); then\n            echo \"Error: order_by_points: too many matches.\"\
    \n            return 1\n        fi\n        local -n sum=${BASH_REMATCH[${#BASH_REMATCH}\
    \ - 1]}\n        local -n val=${BASH_REMATCH[0]}\n        if (( val =~ ^-?[0-9]+$\
    \ )); then\n            (( sum += ${BASH_REMATCH[0]} ))\n        elif (( val =~\
    \ ^[+-]?[0-9]+\\.[0-9]+$ )); then\n            (( sum += ${BASH_REMATCH[0]} ))\n\
    \        elif (( val =~ ^[+-]?[0-9]+\\.[0-9]+[Ee][+-][0-9]+$ )); then\n      \
    \      (( sum += ${BASH_REMATCH[0]} ))\n        fi\n        echo \"$val\"\n  \
    \      shift \"$(( ${#BASH_REMATCH} - 1 ))\"\n    done", "    local sorted_list\
    \ index_of_digit tmp i sum\n    sorted_list=\"\"\n    index_of_digit=0\n    for\
    \ i  in $( echo $1 | tr ' ' '\\n' | sort -n ); do\n        sum=$( echo $i | awk\
    \ '{print $1+$2+$3+$4+$5}')\n        if [ \"$sum\" -lt 0 ]; then\n           \
    \ sum=0\n        fi\n        if [ \"$sum\" -gt 9 ]; then\n            sum=$(echo\
    \ \"$sum / 10\" | bc)\n        fi\n        sorted_list=\"$sorted_list \\\"$i\\\
    \"\\t$sum\"\n        index_of_digit=$(( index_of_digit + 1 ))\n    done\n    echo\
    \ \"$sorted_list\" | tail -n $( expr $(wc -l <<< \"$1\") - 1 )", "  local items=$1\n\
    \  local sorted=\n  local i=${#items}\n  for i in $(( 0 )) $(( ${#items} - 1 ));\
    \ do\n    local j=$(( i - 1 ))\n    local sum\n    local prev_sum\n    sum=$(echo\
    \ $items | cut -d\" \" -f$j | paste -sd \"+\")\n    prev_sum=$(echo $items | cut\
    \ -d\" \" -f$j | paste -sd \"+\" | tr -d '\\n' | sort -n)\n    while [ \"$sum\"\
    \ != \"$prev_sum\" ];\n    do\n      j=$(( j - 1 ))\n      sum=$(echo $items |\
    \ cut -d\" \" -f$j | paste -sd \"+\")\n      prev_sum=$(echo $items | cut -d\"\
    \ \" -f$j | paste -sd \"+\" | tr -d '\\n' | sort -n)\n    done\n    sorted+=\"\
    \ $items\"\n    items=$(echo $items | cut -d\" \" -f${j+1} | tr -d '\\n' | sort\
    \ -n)\n  done\n  echo \"$sorted\"", "  local list=\"$1\"\n\n  # Split string into\
    \ array\n  IFS=' ' read -r -a array <<< \"$list\"\n\n  # Sum digits per element\n\
    \  local item_sums=()\n  for item in \"${array[@]}\"; do\n    item_sums[${#item_sums[*]}]=\"\
    $item\"\n  done\n\n  # Sort digits by sum order\n  IFS=' ' read -r -a array <<<\"\
    ${item_sums[*]}\"\n  array=(\"${array[@]}\")\n  local sorted_list=()\n  for index\
    \ in \"${!item_sums[@]}\"; do\n    local sum=\"${item_sums[$index]}\"\n    local\
    \ item=\"${array[$index]}\"\n    local index2\n    for index2 in \"${!array[@]}\"\
    ; do\n      if [ \"${sum}\" == \"${array[$index2]}\" ]; then\n        sorted_list+=(\"\
    \\\"$item\\\"\")\n        break\n      fi\n    done\n  done\n\n  # Return sorted\
    \ array\n  echo \"${sorted_list[@]}\"", "  local input=\"$(echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]')\"\n  local sum=0\n  local result\n  # The list of items is sorted\
    \ in-place\n  for item in $input; do\n    sum=$(echo \"$item\" | awk '{printf\
    \ \"%010d\", $1+$2}')\n    echo \"$item $sum\"\n  done\n  return $result", " \
    \ local input_list=$1\n  local input_list_len=$(expr length \"$input_list\")\n\
    \  local input_list_items_sum=$(expr sum \"$input_list\")\n  local input_list_items_sum_digits=$(expr\
    \ substr \"$input_list_items_sum\" 1 $((${#input_list_items_sum} - 1))) # extract\
    \ digits from sum\n  local input_list_items_sum_digits_count=$(expr len \"$input_list_items_sum_digits\"\
    )\n  local input_list_items_sort_index=$(expr sort -n \"$input_list_items_sum\"\
    \ -k $((input_list_items_sum_digits_count)) -r) # sort input list items based\
    \ on their sum of digits from right (descending)\n  local sorted_input_list_items=$(sort\
    \ -n -k $((input_list_items_sum_digits_count)) -r \"$input_list\") # sort input\
    \ list items based on their sum of digits from right (descending)\n  local sorted_input_list_items_sort_index=$(expr\
    \ length \"$sorted_input_list_items\")\n  local sorted_input_list_items_sorted=\n\
    \  # for each input list item\n  for i in $(seq 0 $(($sorted_input_list_items_sort_index\
    \ - 1))); do\n    # check if the current input list item has same sum of digits\
    \ as any of the other input list items\n    local input_list_item_is_similar=\n\
    \    for j in $(seq 0 $(($sorted_input_list_items_sort_index - 1))); do\n    \
    \  if [[ $((i+j)) -lt $input_list_len_and_items_sum_digits_count ]]; then\n  \
    \      input_list_item_is_similar=true\n        break\n      fi\n    done\n  \
    \  # if current input list item has same sum of digits as any of the other input\
    \ list items\n    if [[ $input_list_item_is_similar ]]; then\n      # if current\
    \ input list item is smaller than any of the other input list items\n      if\
    \ [[ $i -lt $j ]]; then\n        # append current input list item to the sorted\
    \ input list items list\n        sorted_input_list_items_sorted+=$(echo \"$sorted_input_list_items[i]\"\
    )\n      else\n        # append current input list item to the sorted input list\
    \ items list\n        sorted_input_list_items_sorted+=$(echo \"$sorted_input_list_items[j]\"\
    )\n      fi\n      # increment input list items sort index\n      input_list_items_sort_index=$(($input_list_items_sort_index\
    \ + 1))\n    fi\n  done\n  echo $sorted_input_list_items_sorted", "  local numbers=(\
    \ ${1//[, ]/} )\n  local sums=( ${#numbers[@]} )\n  local max_sum=0\n  local index=0\n\
    \n  local sorted_numbers=()\n  while [ ${index} -lt ${#numbers[@]} ]; do\n   \
    \ if [ ${sums[$index]} -gt ${max_sum} ]; then\n      max_sum=${sums[$index]}\n\
    \    fi\n    ((index++))\n  done\n\n  index=${#sorted_numbers[@]}\n  while [ ${index}\
    \ -gt 0 ]; do\n    local sum=${sums[$index]}\n    local pos=0\n    local num=${numbers[$pos]}\n\
    \    while [[ $pos < ${#sorted_numbers[@]} && \\\n           $num -eq ${sorted_numbers[$pos]}\
    \ ]]; do\n      ((pos++))\n      ((num+=${sorted_numbers[$pos]}))\n    done\n\n\
    \    if [[ $pos == ${#sorted_numbers[@]} ]]; then\n      sorted_numbers+=( \"\
    $num\" )\n    else\n      (( sorted_numbers[$pos] ))\n    fi\n\n    ((index--))\n\
    \  done\n\n  printf \"%s\" ${sorted_numbers[@]}", "    local sorted_list sum_list\n\
    \    local i\n    sum_list=($( echo \"$1\" | grep -o \"^[0-9]+\" | sort -k 2 -r\
    \ ))\n    for i in ${!sum_list[@]}; do\n        sorted_list+=(${sum_list[i]})\n\
    \    done\n    echo \"${sorted_list[@]}\"", "    local n=0\n    local sorted=()\n\
    \    local input=${1//-/ }\n    while [[ $n -lt ${#input} ]]; do\n        local\
    \ sum=0\n        for v in ${input:n}; do\n            sum=$(($sum + $v))\n   \
    \     done\n        local key=$(echo $sum | awk '{printf \"%04d\\n\", $0}' | tr\
    \ -d '\"')\n        local found=0\n        for v in ${sorted[*]}; do\n       \
    \     local key1=$v\n            local key2=$key\n            if [[ $v == $key\
    \ ]]; then\n                found=1\n            fi\n        done\n        if\
    \ [[ $found == 0 ]]; then\n            sorted[$n]=$(echo $key)\n            n=$((n\
    \ + 1))\n        fi\n    done\n    sorted[$n]=$input\n    echo \"${sorted[*]}\"",
  "  [[ -z \"$1\" ]] && return 0\n  local L=($1)\n  local A=($(\n    IFS=$'\\n'\n\
    \    A=($(IFS='\\n' sort -n -k 2 -n -k3 ${L[*]}|awk '{print $1}'))\n    IFS=$'\\\
    n'\n    echo $A[@]\n  ))\n  printf \"%s\" ${A[@]}", "  local i j\n  local sum\n\
    \  local arr\n  if [ -z \"$1\" ]; then\n    return 0\n  fi\n  arr=( $1 )\n  #\
    \ Iterate through the list and sort it based on sum\n  # of digits from left to\
    \ right. For example, 1 11 -1\n  # -11 12 will be treated as 1 11 -1\n  for ((i=0;\
    \ i<${#arr[@]}; i++)); do\n    sum=0\n    for ((j=0; j<${#arr[@]}; j++)); do\n\
    \      # Check if we already found the item with same sum\n      if [ \"$j\" -eq\
    \ \"$i\" ]; then\n        continue\n      fi\n      sum=$(( $sum + ${arr[$j]}\
    \ ))\n    done\n    # Check if we found the item with same sum\n    if [ \"$sum\"\
    \ -eq 0 ]; then\n      # If not found, just append it to the end\n      arr=(\
    \ \"${arr[@]}\" )\n      break\n    else\n      # Found item with same sum. Rearrange\
    \ the list\n      # based on original index of item in list\n      arr=( \"${arr[@]:$i:1}\"\
    \ \"${arr[@]:$j}\" )\n    fi\n  done\n  # Print the new sorted array\n  for ((i=0;\
    \ i<${#arr[@]}; i++)); do\n    echo \"$arr[$i]\"\n  done\n  return 0", "    local\
    \ IFS=' ' sorted=() sorted_indices=()\n\n    while read -a list; do\n        local\
    \ sum=0\n        for i in \"${list[@]}\"; do\n            (( sum += i ))\n   \
    \     done\n        sorted+=( \"${list[*]}\" )\n        sorted_indices+=( \"${#sorted[@]}\"\
    \ )\n    done < <(echo \"$1\" | tr \" \" \"\\n\" | sort -n)\n\n    local sorted\n\
    \    local sorted_indices", "  local string=\"${1}\"\n\n  [[ \"${string}\" = \"\
    \" ]] && return 0\n\n  # Turn string into a list of numbers in string form.\n\
    \  local numbers=()\n  while read -r; do numbers+=(\"$REPLY\"); done <<< \"$string\"\
    \n\n  # Sort numbers in ascending order\n  local ordered_numbers=()\n  local ordered_index=0\n\
    \  local sum=0\n  for (( i=0; i<${#numbers[@]}; i++ )); do\n    (( sum += ${numbers[$i]}\
    \ ))\n    ordered_numbers+=(\"$((i + ordered_index))\")\n    (( ordered_index\
    \ = i + 1 ))\n  done\n\n  # Reconstruct original string from sorted numbers\n\
    \  local ordered_string=\"\"\n  for (( i=0; i<${#ordered_numbers[@]}; i++ ));\
    \ do\n    ordered_string+=\"${ordered_numbers[$i]} \"\n  done\n  echo \"$ordered_string\"",
  "  local i\n  local sum\n  local sorted\n  sum=$(sum_digits $1)\n  sorted=()\n \
    \ for i in $*; do\n    sorted+=$(echo $i|awk -v sum=$sum '{printf \"%s %d\\t\"\
    ,$0,$1+sum}' | \\\n             sed -e 's/^\"\\(.*\\)\"$/\\1/')\n  done\n  echo\
    \ $(echo $sorted | tr '\\t' ' ')", "    # Split $1 into words with space-char\
    \ as delimeter\n    IFS=\" \"\n    # Sort function returns negative numbers as\
    \ string\n    # Need to convert them into integers\n    local sorted_list_string=$(IFS=-\
    \ echo \"$1\")\n    # Trim whitespace and convert each word to integer\n    sorted_list=$(echo\
    \ \"$sorted_list_string\" | tr \" \" \"\\n\" | sort -n)\n    # Convert to original\
    \ format string\n    sorted_list_string=\"$(echo \"$sorted_list\" | sed -E \"\
    s/^\\\"(.*)\\\"$/\\1/\")\"\n    # Return empty string if the original list was\
    \ empty\n    [[ -z \"$sorted_list_string\" ]] && return 0\n    echo \"$sorted_list_string\"",
  "  # The sum of digits should be unique\n  local digits=$1\n  if [ -z \"$digits\"\
    \ ]; then digits=\"0\"; fi\n  local sorted_items=$(echo \"$digits\" | tr \" \"\
    \ \"\\n\" | sort -n)\n  local sorted_indices=$(echo \"$digits\" | tr \" \" \"\\\
    n\" | sort -n)\n  while read -r line; do\n    local sum=$(echo \"$line\" | grep\
    \ -o '[0-9]\\+' | wc -l)\n    if [ \"$sum\" -ne 1 ]; then continue; fi\n    local\
    \ index=$(echo \"$line\" | grep -o '[0-9]\\+')\n    local item=\"$sorted_items[$sorted_indices[$index]]\"\
    \n    sorted_items=$(echo \"$sorted_items\" | grep -v \"$item\")\n    sorted_indices=$(echo\
    \ \"$sorted_indices\" | sed \"s/^$index //\")\n    echo \"$item\"\n  done", " \
    \   local sorted_list tmp sum sorted_list tmp sum\n    sum=0\n    sorted_list=\"\
    \"\n    while read -r i\n    do\n        sum=$((sum+$i))\n    done <<< \"$1\"\n\
    \    IFS=$'\\n' read -a tmp <<< \"$sorted_list\"\n    for ((i=0; i<${#tmp[@]};\
    \ i++)); do\n        if [ \"${tmp[$i]}\" -gt \"${sum}\" ]; then\n            tmp[$i]=$((sum-tmp[$i]))\n\
    \        else\n            tmp[$i]=$((tmp[$i]-sum))\n        fi\n    done\n  \
    \  for ((i=0; i<${#tmp[@]}; i++)); do\n        sorted_list=\"$sorted_list \\\"\
    ${tmp[$i]}\\\"\"\n    done\n    printf '[%s]' \"${sorted_list[@]}\"", "  local\
    \ sorted_list=\"\"\n  local total_sum=0\n  local index=0\n  for item in $( echo\
    \ $1 | tr ' ' '\\n' ); do\n    local item_sum=${item%% *}\n    if [[ $item_sum\
    \ ]]; then\n      total_sum=$(( total_sum + item_sum))\n      sorted_list=\"${sorted_list}\\\
    \"${index}\\\",\"\n      index=$(( index + 1 ))\n    fi\n  done\n  echo \"${sorted_list[*]}\"",
  "  local list=$1\n  local sum=$2\n\n  if [[ -z $list ]]; then\n    return 0\n  fi\n\
    \n  IFS=$'\\n'\n  local temp_list=\"\"\n  local num_list=\"\"\n  local point=0\n\
    \  local num=0\n  local temp=0\n  local sum_list=\"\"\n\n  for line in $list;\
    \ do\n    IFS=$'\\t'\n    temp=`echo \"$line\" | awk '{print $1}'`\n    temp_list=$temp_list\"\
    $temp\"\n  done\n\n  local tmp_sum=$(echo $temp_list | awk '{sum += $1; sum_list\
    \ = $1; print sum; print $0}' FS=$'\\t' | awk '{print $1}')\n  if [[ $tmp_sum\
    \ == $sum ]]; then\n    return 0\n  fi\n\n  for line in $list; do\n    IFS=$'\\\
    t'\n    num=`echo \"$line\" | awk '{print $1}'`\n    num_list=$num_list\"$num\"\
    \n  done\n\n  local tmp_num_list=$(echo $num_list | awk '{sum += $1; sum_list\
    \ = $1; print sum; print $0}' FS=$'\\t' | awk '{print $1}')\n  if [[ $tmp_num_list\
    \ < $tmp_sum ]]; then\n    return 0\n  fi\n  local tmp=$(echo $temp_list | awk\
    \ '{sum += $1; sum_list = $1; print sum; print $0}' FS=$'\\t' | awk '{print $1}')\n\
    \  local tmp_num=$(echo $num_list | awk '{sum += $1; sum_list = $1; print sum;\
    \ print $0}' FS=$'\\t' | awk '{print $1}')\n\n  if [[ $tmp > $tmp_num ]]; then\n\
    \    return 0\n  fi\n  local tmp_num=$(($tmp_num-$tmp))\n  echo $tmp_num", " \
    \   # split the line into space-separated numbers\n    local IFS=$'\\n'\n    local\
    \ arr=($1)\n    local len=${#arr[@]}\n    local max_sum=${arr[0]}\n    # calculate\
    \ the sum of each digit\n    for ((i=1; i<len; i++))\n    do\n        max_sum=$(echo\
    \ $max_sum + ${arr[i]} | bc)\n    done\n    # sort the list with maximum sum\n\
    \    local sorted_arr=()\n    local i\n    for ((i=0; i<len; i++)); do\n     \
    \   local sum=$(echo $max_sum + ${arr[i]} | bc)\n        if (( $i )); then\n \
    \           if (( sum < $sorted_arr[$i-1] ));\n            then\n            \
    \    sorted_arr[$i-1]=$sum\n                sorted_arr=( \"${sorted_arr[@]:0:i}\"\
    \ \"$sorted_arr[$i]\" )\n            fi\n        else\n            sorted_arr[$i]=$sum\n\
    \        fi\n    done\n    local re=\"^[+-]*[0-9]+$\"\n    local sorted_arr_size=${#sorted_arr[@]}\n\
    \    # sort it again if the list has similar sum of each digits\n    if (( $sorted_arr_size\
    \ > $len )); then\n        # sort it according to the sum of each digit\n    \
    \    for ((j=0; j<$len; j++))\n        do\n            local tmp_sum=$(echo $sorted_arr[$j]\
    \ | bc)\n            if (( $j > 0 ))\n            then\n                if [[\
    \ $sorted_arr[$j-1] == $tmp_sum ]];\n                then\n                  \
    \  sorted_arr[$j-1]=${sorted_arr[$j]}\n                    sorted_arr=( \"${sorted_arr[@]:0:j}\"\
    \ \"$sorted_arr[$j]\" )\n                fi\n            fi\n        done\n  \
    \  fi\n    # sort the list according to the original order\n    local i\n    for\
    \ ((i=0; i<len; i++)); do\n        local tmp_sum=$(echo $sorted_arr[$i] | bc)\n\
    \        if (( $i > 0 ))\n        then\n            if [[ $sorted_arr[$i-1] ==\
    \ $tmp_sum ]];\n            then\n                sorted_arr[$i-1]=${sorted_arr[$i]}\n\
    \                sorted_arr=( \"${sorted_arr[@]:0:i}\" \"$sorted_arr[$i]\" )\n\
    \            fi\n        fi\n    done\n    # remove the extra quotes\n    local\
    \ sorted_arr_string\n    for ((i=0; i<$sorted_arr_size; i++)); do\n        if\
    \ [[ $sorted_arr[$i] == $max_sum ]];\n        then\n            sorted_arr_string=`echo\
    \ $sorted_arr[$i] | tr -d '\"'`\n", "  local IFS=$'\\n';\n  local sorted_list=\"\
    \"\n  local num\n  local max_points=0\n  local tmp\n  local sum\n\n  IFS=\" \"\
    \n  for num in $(echo $1 | sed 's/^[ \\t]*//g'); do\n    sum=$(echo $num | awk\
    \ '{print $1+$2}')\n    if [[ $max_points -lt $sum ]]; then\n      max_points=$sum\n\
    \      tmp=\"$num\"\n    fi\n  done\n\n  IFS=$IFS\n\n  sorted_list=$(echo $tmp\
    \ | sed 's/\"//g')\n\n  if [[ $max_points -eq 0 ]]; then\n    sorted_list=$(echo\
    \ $sorted_list | sed 's/ /\\n/g')\n  else\n    sorted_list=$(echo $sorted_list\
    \ | sed 's/ /\\n/g' | sort -k 1 -r -n -k 2 | head -1)\n  fi\n  sorted_list=$(echo\
    \ $sorted_list | sed 's/^[[:space:]]*//g')\n\n  echo \"$sorted_list\"", "    #\
    \ use shell sort\n    local IFS=' ' a=($1 $(echo $1 | sed 's/[[:space:]]//g'));\
    \ printf '%s\\n' \"${a[@]}\"; return", "  local s=$1\n\n  IFS=' '\n  echo \"$s\"\
    \ | grep -v '^$' | sed -e 's/^[ \\t]*//' -e 's/[ \\t]*$//' | sort -n | awk '{s+=$1;c[$1]++;\
    \ print} END{for (i in c) {print i\" \"$c[i]}}'", "  # Write your code here\n\
    \  IFS=\" \"\n  sorted=$(sort -n | cut -d ' ' -f 3- | sort -nr)\n  \n  for i in\
    \ $sorted; do\n      temp=$(echo $i | cut -d'\"' -f 2)\n      arr=( $temp ${arr[@]}\
    \ )\n  done\n  \n  arr=($(for i in ${arr[@]}; do echo \"\\\"$i\\\"\";done))\n\
    \  echo \"${arr[@]}\"", "    # Convert inputs to integers\n    # and sort the\
    \ list\n    local input=\"${1//[!0-9]/}\"\n    local -a points\n    for x in $input;\
    \ do\n        local xx yy zz\n        xx=$(( 10#$x ))\n        yy=$(( 10#$(( $x\
    \ + $(( 10#$x )) )) ))\n        zz=$(( 10#$(( $x + $(( 10#$xx )) )) ))\n     \
    \   points=( \"${points[@]}\" \"$xx\" \"$yy\" \"$zz\" )\n    done\n\n    # Sort\
    \ points\n    local sorted=()\n    for (( i=0; i<${#points[@]} && i<$(( ${#points[@]}\
    \ - 1 )); i++ )); do\n        local j=$(( i + 1 ))\n        if [ ${points[$i]}\
    \ -gt ${points[$j]} ]; then\n            sorted=( \"${sorted[@]}\" \"${points[$i]}\"\
    \ \"${points[$j]}\" )\n            points[$i]=$(( ${points[$j]} - ${points[$i]}\
    \ ))\n            points[$j]=${points[$i]}\n        fi\n    done\n\n    # Build\
    \ sorted string\n    local -a sorted_points=()\n    for (( i=0; i<${#points[@]}\
    \ && i<$(( ${#points[@]} - 1 )); i++ )); do\n        local j=$(( i + 1 ))\n  \
    \      if [ ${points[$i]} -gt ${points[$j]} ]; then\n            sorted_points=(\
    \ \"${sorted_points[@]}\" \"${points[$i]}\" )\n            points[$i]=$(( ${points[$j]}\
    \ - ${points[$i]} ))\n            points[$j]=${points[$i]}\n        fi\n    done\n\
    \n    # Return sorted list\n    for (( i=0; i<${#sorted_points[@]} && i<$(( ${#sorted_points[@]}\
    \ - 1 )); i++ )); do\n        local j=$(( i + 1 ))\n        if [ ${sorted_points[$i]}\
    \ -gt ${sorted_points[$j]} ]; then\n            sorted=( \"${sorted[@]}\" \"${sorted_points[$i]}\"\
    \ )\n            sorted_points[$i]=$(( ${sorted_points[$j]} - ${sorted_points[$i]}\
    \ ))\n            sorted_points[$j]=${sorted_points[$i]}\n        fi\n    done\n\
    \n    for (( i=0; i<${#sorted_points[@]} && i<$(( ${#sorted_points[@]} - 1 ",
  "    local number=$1\n    local points=$(echo \"$number\" | tr '-' ' ')\n    local\
    \ sorted_points=()\n    local i=0 j=0\n    while [[ $i -lt ${#points[@]} ]]; do\n\
    \        local sum=$(echo \"${points[i]}\" | sed 's/-/ /g' | awk '{s+=$1; gsub(\"\
    \ \",\"\",s); print s}')\n        if [[ $sum -gt 0 ]]; then\n            sorted_points+=(\"\
    ${points[i++]}\")\n        else\n            sorted_points+=(\"${points[j++]}\"\
    )\n        fi\n    done\n    echo \"${sorted_points[@]}\"", "    local sorted_list\n\
    \    sorted_list=$1\n    # Remove extra spaces in the beginning\n    sorted_list=${sorted_list#*\
    \ }\n    sorted_list=$(echo $sorted_list | tr \" \" \"\\n\")\n    local sort_function=\"\
    sort -s -t '\"\n    local sort_arguments=\"| sed 's/\\([0-9]\\+\\)/\\1 /g'\"\n\
    \    local sort_arguments_space=\"| sed 's/\\([0-9]\\+\\)/\\1 /g' | sort -s -t\
    \ '\"\n    local sort_arguments_number=\"| sort -s -t '\"\n    local sort_arguments_spaces=\"\
    | sort -s -t '\"\n    local sort_arguments_numbers=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces2=\"| sort -s -t '\"\n    local sort_arguments_spaces3=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces4=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces5=\"| sort -s -t '\"\n    local sort_arguments_spaces6=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces7=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces8=\"| sort -s -t '\"\n    local sort_arguments_spaces9=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces10=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces11=\"| sort -s -t '\"\n    local sort_arguments_spaces12=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces13=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces14=\"| sort -s -t '\"\n    local sort_arguments_spaces15=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces16=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces17=\"| sort -s -t '\"\n    local sort_arguments_spaces18=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces19=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces20=\"| sort -s -t '\"\n    local sort_arguments_spaces21=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces22=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces23=\"| sort -s -t '\"\n    local sort_arguments_spaces24=\"\
    | sort -s -t '\"\n    local sort_arguments_spaces25=\"| sort -s -t '\"\n    local\
    \ sort_arguments_spaces26=\"| sort -", "  local sorted_list=$(sed 's/^[ ]*//'\
    \ <<<$1)\n  local list_len=${#sorted_list[@]}\n  local sums=${sorted_list[@]/#/}\n\
    \  local sorted_list2=()\n  local idx\n  for (( idx=1; idx<list_len; idx++ ));\
    \ do\n    local digit=${sums:$idx}\n    local idx2\n    for (( idx2=1; idx2<idx;\
    \ idx2++ )); do\n      local other_digit=${sums:$idx2}\n      if (( other_digit\
    \ > digit )); then\n        break\n      fi\n    done\n    sorted_list2+=(\"${sorted_list[$idx2]}\"\
    )\n  done\n  echo ${sorted_list2[@]}", "  local IFS=' ' res\n  res=\"$1\"\n  shift\n\
    \  # Get all numbers without minus sign, sort them by their\n  # digits and add\
    \ them to res\n  # Note: this can fail if $res has no digits.\n  while [[ $1 =~\
    \ (^|[^-]-)(\\D+) ]]; do\n    res=\"$res$1\"\n    shift\n  done\n  # Sort digits\
    \ by their digits\n  IFS=+ read -r -a arr <<< \"$res\"\n  local sum\n  # Add all\
    \ digits of the same number\n  for i in \"${arr[@]}\"; do\n    (( sum += i ))\n\
    \  done\n  # Now sort all numbers by their sum\n  printf '%s\\n' \"${arr[@]}\"\
    \ | sort -n -k 2 | sed 's/^ *//g' | sed 's/ *$//g'", "  local -n arr=$1\n  sort\
    \ -t $'\\t' -k 2,2 -k 3,3 -k 1,1 -k 4,4 -k 5,5n <<<$arr", "  local s=$(echo \"\
    $1\" | awk '{sum=0; for (i=1;i<NF;i++) {sum+=$i; i++}; print $sum}')\n  echo \"\
    $@\"\n  [[ $s -ne 0 ]] \\\n    | sort -n \\\n    | awk '{print $2}' >| \\\n  \
    \    awk '{print $0}' |\n      sort -n |\\\n      awk '{print $1}'", "    local\
    \ items=$1\n\n    local sorted_items=$(\n        sort --field-separator=\":\"\
    \ --key=2 --key=3 --key=4 \\\n            <(echo \"$items\") |\n        awk -F:\
    \ '{print \"\\\"\"$3\"-\"$2\"-\"$1\"\\\"\" }'\n    )\n\n    # strip extra quotes\n\
    \    sorted_items=$(echo \"$sorted_items\" | sed 's/^\"//; s/\"$//')\n\n    [[\
    \ -n $items ]] &&\n        [[ -n $sorted_items ]] &&\n        printf '%s\\n' \"\
    $sorted_items\"", "  # Scan the whole list only once while keeping track of the\
    \ index\n  # of current item\n  local -r sum=\"${1//[^0-9]}\"; shift\n\n  # Scan\
    \ the whole list\n  local -a tmp\n  local i=0; local j=0; local last_index=-1\n\
    \  for n in \"$@\"; do\n    if (( i )); then\n      # If sum of next item is higher\
    \ than current item,\n      # swap them and update index\n      (( i > last_index\
    \ )) && tmp[j]=${tmp[i - 1]}; last_index=$i\n      (( j == 0 )) && j=1\n     \
    \ tmp[i]=$n\n      (( i++ ))\n    elif (( sum == $(echo \"$n\" | awk '{print $1+$2}')\
    \ )); then\n      tmp[j]=$n\n      (( j++ ))\n    else # sum < $n\n      tmp[i]=$n\n\
    \      (( i++ ))\n    fi\n  done\n\n  # Sort the result based on the original\
    \ index\n  sort -n -t \\: '${tmp[@]}'", "  local sorted_list=\"$1\"\n  if [[ \"\
    ${sorted_list}\" != \"\" ]]; then\n    IFS=\" \" read -ra sorted_array <<< \"\
    ${sorted_list}\"\n  else\n    sorted_array=()\n  fi\n\n  local sum=\"$2\"\n  local\
    \ sorted=()\n  local i\n  for ((i=0; i < ${#sorted_array[@]}; i++)); do\n    local\
    \ digit=${sorted_array[i]}\n    local remainder=${sum} % $digit\n    if (( ${remainder}\
    \ > 0 )); then\n      sorted+=(\"${sorted_array[i]}\")\n      sum=\"${sum} - $remainder\
    \ + $digit\"\n    fi\n  done\n\n  local sort_index\n  IFS=\" \" read -ra sorted_array_index\
    \ <<< \"${sorted[*]}\"\n  for ((i=0; i < ${#sorted_array_index[@]}; i++)); do\n\
    \    sort_index=\"${i}\"\n  done\n\n  local sort_string\n  IFS=\" \" read -ra\
    \ sorted_array_string <<< \"${sorted[*]}\"\n  for ((i=0; i < ${#sorted_array_string[@]};\
    \ i++)); do\n    sort_string=\"${sorted_array_string[i]}\"\n  done\n  echo \"\
    ${sorted_array_index[@]}\"", "    sort -nr | sed -e 's/^/\"$1 \"/g'", "  local\
    \ list_string sorted_list\n  list_string=$(echo $1 | sed 's/^[ \\t]*//g;s/[ \\\
    t]*$//g;s/ .*//g;s/^$//g;s/[ \\t]*$//g')\n  sorted_list=$(echo \"$list_string\"\
    \ | sort -n -k1,1 -t)\n  echo $sorted_list", "  # Convert all values to numbers\n\
    \  local stringlist=\"$1\"\n  stringlist=\"${stringlist// /+}\"\n  stringlist=\"\
    ${stringlist// +/ }\"\n  stringlist=\"${stringlist//$'\\n'/ }\"\n  stringlist=\"\
    $(echo \"$stringlist\" | sed -e 's/^[[:space:]]*//g' -e 's/^[[:digit:]]*//g')\"\
    \n  # Sort each line\n  local sorted_stringlist=\"$(awk -v RS=\"[ \\n]\" '{split($0,\
    \ a, \"[[:space:]]+\"); print a[1]}' <<< \"$stringlist\")\"\n  # Reverse the order\
    \ of sorted items\n  sorted_stringlist=\"$(echo \"$sorted_stringlist\" | sed -e\
    \ 's/^[[:space:]]*//g' -e 's/^[[:digit:]]*//g' -e 's/^\"//' -e 's/\"$//')\"\n\
    \  sorted_stringlist=\"$(echo \"$sorted_stringlist\" | sed -e 's/^\"//' -e 's/\"\
    $//')\"\n  # Add quote to the beginning/end of each string\n  sorted_stringlist=\"\
    $(echo \"$sorted_stringlist\" | sed -e 's/^/\"/' -e 's/\"$/\"/')\"\n  echo \"\
    $sorted_stringlist\"", "    local IFS=$'\\n'\n    local IFS= read -r -a nums <<<\
    \ \"$1\"\n    local sums=()\n    for i in \"${nums[@]}\"; do\n        sums+=($((10#$i)))\n\
    \    done\n    sums=$(printf '[%s]' \"${sums[@]}\")\n    local -r res=\"${sums%?}\"\
    \n    if [[ ${#nums[@]} -gt 0 && ${#res} -gt ${#sums} ]]; then\n        res=\"\
    ${res}\"\n    fi\n    echo \"${nums[@]}\"", "  local L\n  local S\n  local S2\n\
    \  local S2sum\n  local S2count\n  local i\n  S=\"$(IFS=' ' read -a L<<<\"$1\"\
    )\"\n  for (( i=0; i<${#L[*]}; i++ )); do\n    S2=\"$(IFS=' ' read -a S2<<<\"\
    $S[$i])\"\n    S2sum=\"${S2[0]}${S2[1]}${S2[2]}\"\n    S2count=\"${S2[1]}${S2[2]}\"\
    \n    echo \"${L[i]} ${S2sum} ${S2count}\"\n  done", "    local line\n    # Sort\
    \ the line by sum of digits of numbers\n    IFS=\" \"\n    for line; do\n    \
    \  local numbers=$line\n      # Remove leading and trailing double quote from\
    \ numbers\n      numbers=${numbers#\\\"}\n      numbers=${numbers%\\\"}\n    \
    \  numbers=${numbers//\\\"/}\n      # Sum the digits of numbers\n      local sum=0\n\
    \      for number in $numbers; do\n        sum=$(($sum + $number))\n      done\n\
    \      # Put numbers sorted by sum into the sorted list\n      echo $sum\n   \
    \   echo $numbers\n      echo $line >>$2\n    done", "    local list_str=\"$1\"\
    \n\n    local list=()\n    for list_element in $list_str; do\n        element=${list_element#-\
    \ }\n        digits=$(echo \"$element\" | awk '{print $1}')\n        sum=$(echo\
    \ \"$element\" | awk '{print $1}')\n        index_sum=$(( $sum | awk -F. '{print\
    \ $1}' ))\n        list_element=\"$index_sum $element\"\n        list+=(\"$list_element\"\
    )\n    done\n\n    local sorted_list=()\n    local index=$(expr $(sort -n -k1\
    \ <<< \"${list[@]}\" | uniq -c | sort -nr -k2 | head -n1) \\* 2)\n    for element\
    \ in \"${list[@]}\"; do\n        element=${element#- }\n        digits=$(echo\
    \ \"$element\" | awk '{print $1}')\n        sum=$(echo \"$element\" | awk '{print\
    \ $1}')\n        index_sum=$(( $sum | awk -F. '{print $1}' ))\n        if (( index_sum\
    \ == index )); then\n            sorted_list+=(\"$element\")\n        fi\n   \
    \     index=$(( $index + 1 ))\n    done\n\n    IFS=$'\\n'\n    echo \"${sorted_list[@]}\"",
  "    local tmp1=(\"${1// */}\" \"${1//-/ }\" \"${1//^/ }\" \"${1//$/ }\" \"${1//\\\
    # }\")\n    local tmp2=(\"${tmp1[0]}\" \"${tmp1[1]}\" \"${tmp1[2]}\" \"${tmp1[3]}\"\
    \ \"${tmp1[4]}\" \"${tmp1[5]}\" \"${tmp1[6]}\" \"${tmp1[7]}\" \"${tmp1[8]}\" \"\
    ${tmp1[9]}\" \"${tmp1[10]}\")\n    local tmp3=$(echo \"${tmp2}\" | sort -n)\n\
    \    local tmp4=${tmp3//\" \"/\" \"}\n    local tmp5=${tmp4//'\"'/''}\n    local\
    \ tmp6=${tmp5//$'\\n'/\\n}\n    local tmp7=${tmp6//'\"'/''}\n    echo \"${tmp7}\"",
  "  local i n sum=$(echo \"$1\" | tr '.' ' ')\n  IFS=' ' read -a points <<< \"$sum\"\
    \n  IFS=- read a b c d <<< \"${points[@]}\"\n  local sorted=()\n  for i in $(seq\
    \ $a $b); do\n    local j\n    for j in $(seq $c $d); do\n      local csum=\"\
    ${points[i]+points[j]+1}\"\n      [[ \"$csum\" =~ ^[0-9]+$ ]] || continue\n  \
    \    sorted+=(\"$i$j\")\n    done\n  done\n  echo \"${sorted[@]}\"", "  local\
    \ -i index=0\n  local -i sorted_index\n  local -a sorted_array\n  local -a sorted_array_sorted\n\
    \  local -a sorted_array_sorted_index\n  local -a sorted_array_sorted_index2\n\
    \  local -a sorted_array_sorted_index3\n  local -a sorted_array_sorted_index4\n\
    \  local -a sorted_array_sorted_index5\n\n  IFS=' ' read -r -a sorted_array_sorted_index\
    \ <<< \"$1\"\n  IFS=' ' read -r -a sorted_array_sorted_index2 <<< \"$2\"\n  IFS='\
    \ ' read -r -a sorted_array_sorted_index3 <<< \"$3\"\n  IFS=' ' read -r -a sorted_array_sorted_index4\
    \ <<< \"$4\"\n  IFS=' ' read -r -a sorted_array_sorted_index5 <<< \"$5\"\n\n \
    \ if [ -z \"${sorted_array_sorted_index[0]}\" ]; then\n    return 0\n  fi\n\n\
    \  local sorted_array_sorted_index3_index=0\n  for index in \"${!sorted_array_sorted_index[@]}\"\
    ; do\n    if [ ${sorted_array_sorted_index3_index} -eq 0 ]; then\n      sorted_array_sorted_index3=${sorted_array_sorted_index[index]}\n\
    \      sorted_array_sorted_index3_index=$index\n    fi\n    if [ ${sorted_array_sorted_index3}\
    \ -gt ${sorted_array_sorted_index2[index]} ]; then\n      sorted_array_sorted_index3=${sorted_array_sorted_index[index]}\n\
    \      sorted_array_sorted_index3_index=$index\n    fi\n  done\n\n  if [ -z \"\
    ${sorted_array_sorted_index3_index}\" ]; then\n    return 0\n  fi\n\n  local sorted_array_sorted_index4_index=0\n\
    \  for index in \"${!sorted_array_sorted_index[@]}\"; do\n    if [ ${sorted_array_sorted_index4_index}\
    \ -eq 0 ]; then\n      sorted_array_sorted_index4=${sorted_array_sorted_index[index]}\n\
    \      sorted_array_sorted_index4_index=$index\n    fi\n    if [ ${sorted_array_sorted_index4}\
    \ -gt ${sorted_array_sorted_index3[index]} ]; then\n      sorted_array_sorted_index4=${sorted_array_sorted_index[index]}\n\
    \      sorted_array_sorted_index4_index=$index\n    fi\n  done\n\n  if [ -z \"\
    ${sorted_array_sorted_index4_index}\" ]; then\n    return 0\n  fi\n\n  local sorted_array_sorted_index5_index=0\n\
    \  for index in \"${!sorted_array_sorted_index[@]}\"; do\n    if [ ${sorted_array_sorted_index5_index}\
    \ -eq 0 ]; then\n      sorted_array_sorted_index", "  local list=\"$1\"\n  local\
    \ sum=\"0\"\n  local tmp\n  local out\n  local idx\n  local tmp_idx\n  local ret\n\
    \  \n  out=\"$1\"\n\n  while read -r item ; do\n    tmp=\"$(echo \"$item\" | awk\
    \ '{printf \"%04d%04d%04d%04d\\n\",$1,$2,$3,$4}' | fold -w 4 | paste -s -d \"\
    \ \")\"\n    ((sum += tmp))\n  done <<< \"$list\"\n\n  tmp=$(echo \"$sum\" | sort\
    \ -n -s -k 1,1n)\n  idx=0\n\n  while [ \"$tmp\" != \"$sum\" ]; do\n    tmp_idx=$((\
    \ $idx + 1 ))\n    tmp=$(echo \"$sum\" | sort -n -s -k $(( $idx + 1 )),1n)\n \
    \   out=\"$out $tmp_idx\"\n  done\n\n  printf -v ret '[%s]' \"$out\"\n  printf\
    \ -v \"$out\" '%s\\n' \"$ret\"\n  echo \"$out\"", "    # sort by total points\
    \ and then by points\n    local str=\"$1\"\n    local points=0\n    local total=0\n\
    \    IFS=$'\\n'\n    for str in $str; do\n        ((points += $((10#${str##* }))))\
    \ # subtract '* ' for negative\n        ((total += $points))\n    done\n\n   \
    \ # sort by points first\n    if [[ \"$total\" -gt 0 ]]; then\n        local str=${str%\
    \ *}\n        local points=0\n        local total=0\n        for str in $str;\
    \ do\n            ((points += $((10#${str##* })))) # subtract '* ' for negative\n\
    \            ((total += $points))\n        done\n\n        if [[ \"$total\" -gt\
    \ 0 ]]; then\n            echo \"$str\"\n        fi\n    fi", "    local sum=0\n\
    \    local i=0\n    local output=\"\"\n\n    for val in $1; do\n        ((sum+=$(echo\
    \ \"$val*10\" | bc -l)))\n        i=$(($i+1))\n    done\n\n    echo -n \"[\"\n\
    \    for val in $1; do\n        ((sum+=$(echo \"$val*10\" | bc -l)))\n       \
    \ if ((sum<0)); then\n            sum=$(($sum+$((10#$((sum+$1))))))\n        else\n\
    \            sum=$(($sum+$((10#$((sum-$1))))))\n        fi\n\n        if ((i<1));\
    \ then\n            output+=\"\\\"$val\\\"\"\n        elif ((sum)); then\n   \
    \         output+=\"\\\"$val\\\" \"\n        fi\n        i=$(($i-1))\n    done\n\
    \    output+=\"]\"\n    echo $output", "    local line\n    local numbers=()\n\
    \    local num_sum\n    local num_digits=0\n    local num_points=0\n    local\
    \ num_index\n    local num_same=0 # how many equal sums are there\n    local num_diff=0\
    \ # how many different sums are there\n\n    while read -r line; do\n        IFS='\
    \ ' read -ra numbers <<< \"$line\"\n        local num_sum=0\n        local num_digits=0\n\
    \n        for num in \"${numbers[@]}\"; do\n            num_digits=$((num_digits\
    \ + ${#num}))\n            num_sum=$((num_sum + num))\n        done\n\n      \
    \  num_digits=$((num_digits - ${#num_sum}))\n        if (( num_digits > 0 ));then\n\
    \            num_points=$((num_points + 1))\n            IFS=- read -r num_index\
    \ <<< \"${num_sum}\"\n            numbers[$num_index]=\"$line\"\n        fi\n\
    \    done < <(\n        sort -n -k${num_digits},${num_points} <(\n           \
    \ awk '{\n            for(i=1;i<NF;++i){\n                sum=sum*10+$i\n    \
    \            nums[++nums]=$i\n                if(nums==NR){\n                \
    \    sums[sum]=$0\n                }\n            }\n            for(sum in sums)\n\
    \            {\n                if(sum==sums[sum]){\n                    num_same=num_same+1\n\
    \                }else{\n                    num_diff=num_diff+1\n           \
    \     }\n            }\n            printf(\"[%s]\\n\",sum)\n            }'\n\
    \        )\n    )\n\n    IFS=$'\\n' read -r -d '' -a sorted <<< \"${numbers[@]}\"\
    \n    for num in \"${sorted[@]}\"; do\n        printf '%s\\n' \"$num\"\n    done\n\
    \n    echo \"$num_same: $num_diff $num_points\"", "\tlocal list_str=\"$1\"\n\n\
    \tlist_str=$(echo \"$list_str\" | sed -e 's/ /\\\",\\\"/g')\n\n\t# split into\
    \ array and sort it\n\tarr=($(echo \"$list_str\" | tr \" \" \"\\n\"))\n\tIFS=','\
    \ read -ra arr <<< \"$list_str\"\n\tunset IFS\n\tarr_sorted=($(sort <<<\"${arr[*]}\"\
    \n\t))\n\n\t# get unique values and order them by the sum of their digits\n\t\
    IFS=',' read -ra arr_unique <<< \"$(echo \"${arr_sorted[*]}\" | tr \" \" \"\\\
    n\" | sort -n -r)\"\n\tunset IFS\n\tarr_unique_sorted=($(echo \"${arr_unique[*]}\"\
    \ | sort -n))\n\n\t# append all values with similar digits to front and sort the\
    \ rest\n\tarr_output=($(echo \"${arr_unique_sorted[@]}\" | sed -e 's/^/\\\"&\\\
    \"/g' | sort -n -r))\n\n\t# return output\n\techo \"${arr_output[@]}\"", "  local\
    \ sum=\"$1\"\n  shift\n  local items=\"$@\"\n  local sorted=()\n  local index=0\n\
    \  while [[ $index -lt ${#items} ]]; do\n    local item=\"${items[$index]}\"\n\
    \    local sum2=\"$(( sum / 10 + item % 10 ))\"\n    if [[ ${sum:0:1} == \"-\"\
    \ ]]; then\n      sum2=\"${sum2:(-1)}\"\n    fi\n    sum=\"${sum2}$sum\"\n   \
    \ sorted+=($item)\n    ((++index))\n  done\n  echo \"${sorted[@]}\"", "    local\
    \ sorted_list\n    IFS=$'\\n'\n    sorted_list=($(sort -n -k 1,1 -k 2,2n -k 3,3n\
    \ -k 4,4n -k 5,5n \"$1\"))\n    IFS=$' '\n    echo \"${sorted_list[@]}\"", " \
    \ local str=\"${1:-}\"\n  local -a list\n  list=($str)\n  local -n max=\"max\"\
    \n  local sum=\"${max:-}\"\n  local -i maxindex=\"${#list[@]}\"\n  local -i index=0\n\
    \n  while ((index<maxindex)) ; do\n    if [[ $sum != ${list[$index]} ]]; then\n\
    \      sum=\"${list[$index]}\"\n      max=\"${list[$maxindex]}\"\n      ((maxindex--))\n\
    \    fi\n    ((index++))\n  done\n  list=(${list[@]:0:$maxindex})\n  ((index--))\n\
    \n  echo \"${list[*]}\"", "  local -n arr=( \"${@}\" )\n  local sorted_list=()\n\
    \  local tmp_sum\n  local -i index\n  local -a sorted_arr\n  local i\n\n  # initialize\
    \ sorted_arr with original elements (if any)\n  sorted_arr=( \"${arr[@]}\" )\n\
    \n  # initialize sorted_list with original elements (if any)\n  sorted_list=(\
    \ \"${sorted_arr[@]}\" )\n\n  # initialize tmp_sum to 0 (sum of digits of all\
    \ elements)\n  tmp_sum=0\n\n  # iterate over all elements\n  for (( i=0; i<${#arr[@]};\
    \ i++ )); do\n\n    # store sum of digits in tmp_sum\n    (( tmp_sum+=${arr[$i]}\
    \ ))\n\n    # store current element in sorted_arr\n    (( sorted_arr[$i]=\"${arr[$i]}\"\
    \ ))\n\n    # store index in sorted_list if it is smaller\n    # than current\
    \ tmp_sum\n    [[ -n $sorted_list[$i] ]] || \\\n      (( index=\"${i}\" ))\n\n\
    \  done\n\n  # if tmp_sum is same, sort them by their index in sorted_list\n \
    \ # (note: when tmp_sum is same for two elements,\n  # sort them by their index\
    \ in sorted_arr)\n  if (( tmp_sum == ${sorted_list[$index]} )) ; then\n    sorted_arr+=(\
    \ \"${sorted_list[$index]}\" )\n    sorted_list+=( \"${sorted_arr[@]}\" )\n  else\n\
    \    # sort them by their index in sorted_arr\n    sorted_list=( \"${sorted_list[@]}\"\
    \ )\n    sorted_arr+=( \"${sorted_list[$index]}\" )\n  fi\n\n  # convert sorted_arr\
    \ to original order\n  IFS=$'\\n'\n  sorted_arr=( \"${sorted_arr[@]}\" )\n  unset\
    \ IFS\n\n  # return sorted_arr\n  echo -n \"$(IFS=\\n; echo \"${sorted_arr[*]}\"\
    )\"", "    local i i_sum index\n    local list=$(echo \"$1\" | sed 's/,/\" \"\
    /g' | tr '\"' ' ')\n    for (( i = 0; i < ${#list[@]}; i++ )); do\n        if\
    \ [ ! -z \"${list[$i]}\" ]; then\n            i=$(echo \"${list[$i]}\" | awk '{print\
    \ $1}')\n            i_sum=$(echo \"${list[$i]}\" | awk '{print $2}')\n      \
    \      index=$(echo \"${list[$i]}\" | awk '{print $3}' )\n            [[ -z ${index}\
    \ ]] && index=$i\n            [[ ${#index} -eq 2 ]] && index=\"$index\"\n    \
    \        [[ ${#index} -eq 0 ]] && index=$(expr $i + 1)\n            (( ${#index}\
    \ > i )) && index=$(expr $index + 1)\n            list[i]=\"\\\"${index}\\\"\"\
    \n        fi\n    done\n    echo \"$list\"", "  local list_=\"$1\"\n  local list_no_comments=\"\
    $(echo \"$list_\" | sed 's/#.*//g' | sed 's/\\([^ ]*\\) \\([^ ]*\\)/\\1\\t\\2/g')\"\
    \n  local list_sorted=$(echo -e \"$list_no_comments\" | sort -k 2,2 -k1,1n | sed\
    \ 's/\\t*//g')\n  echo \"${list_sorted}\"", "    local list=\"${1}\"\n    local\
    \ IFS=\" \"\n    local sorted_list=\"\"\n    local sum=$(\n        awk -F\"+\"\
    \ '{\n            for (i=1;i<NF;i++) sum += $i\n            print sum\n      \
    \  }'\n    )\n    IFS=' '\n    for (( i = 0; i < ${#list}; i++ )); do\n      \
    \  local index=$(( ${i}-1 ))\n        if [ ${list[ ${i} ]} -eq $sum ]; then\n\
    \            sorted_list=\"${sorted_list} ${list[ ${index} ]}\"\n            echo\
    \ \"${sorted_list}\"\n        else\n            sorted_list=\"${sorted_list} ${list[\
    \ ${i} ]}\"\n        fi\n    done", "    local digits=${1:-}\n    IFS=\" -\" read\
    \ -a array <<< $digits\n    local sorted_array=()\n    local total_points=0\n\
    \    for (( index = 0; index < ${#array[@]}; index++ )); do\n        points=${array[index]};\n\
    \        sum_points=0;\n        for (( i = 0; i < ${#points}; i++ )); do\n   \
    \         digit=${points:i:1}\n            sum_points=$((sum_points + digit))\n\
    \        done\n        sorted_array+=( $(printf \"%q\" ${sum_points}) )\n    \
    \    total_points=$((total_points + sum_points))\n    done\n    IFS=' ' read -a\
    \ array <<< \"$total_points\"\n    IFS=' ' read -a sorted_array <<< \"$total_points\"\
    \n    echo \"${sorted_array[@]}\"", "    set -- $1 $2 $3 $4\n    local i\n   \
    \ local temp\n    local sum=0\n\n    for i in $@; do\n        local j\n      \
    \  local sum\n        sum=0\n        for j in $@; do\n            ((sum += j))\n\
    \        done\n        (( sum += i))\n        if (( sum != 0 )) { break }\n  \
    \  done\n    if (( sum == 0 )) { echo \"$@\" ; }\n    else { echo \"$@\" | sort\
    \ | uniq -u; }", "  if [[ $# -eq 0 ]]; then\n    return 0\n  fi\n  local sum\n\
    \  local index len\n  local tmp\n  sum=$(echo $1 | tr \" \" \"+\" | tr \"+\" \"\
    -\" | awk '{sum +=$1} END {print sum}')\n  index=$(echo $1 | tr \" \" \"+\" |\
    \ tr \"+\" \"-\" | awk '{print $1}')\n  len=$(echo $1 | tr \" \" \"+\" | tr \"\
    +\" \"-\" | wc -l)\n  local maxIndex=$(expr ${index}+1)\n  local maxSum=$(expr\
    \ ${sum}+0)\n\n  while [[ $index -lt ${len} ]] && [[ $sum -lt ${maxSum} ]]; do\n\
    \    local tmp=${index}\n    local curSum=${sum}\n    sum=$(expr $curSum - $(expr\
    \ ${tmp} * 10))\n    index=$(expr $index + 1)\n    len=$(expr $len - 1)\n    local\
    \ maxIndex=$(expr ${index}+1)\n    local maxSum=$(expr ${sum}+0)\n  done\n  local\
    \ result=()\n  while [[ $index -lt ${len} ]] && [[ $sum -lt ${maxSum} ]]; do\n\
    \    local tmp=${index}\n    local curSum=${sum}\n    sum=$(expr $curSum - $(expr\
    \ ${tmp} * 10))\n    index=$(expr $index + 1)\n    len=$(expr $len - 1)\n    local\
    \ maxIndex=$(expr ${index}+1)\n    local maxSum=$(expr ${sum}+0)\n    result+=(\"\
    ${tmp}\")\n  done\n  result+=(\"${index}\")\n  result+=(\"${sum}\")\n  echo ${result[*]}",
  "  if [ -z \"$1\" ]; then\n    return 0\n  fi\n  IFS=' ' read -r -a array <<< \"\
    $1\"\n  sorted_array=()\n  max_sum=${array[0]}\n  max_i=0\n  for (( i=1; i<${#array[@]};\
    \ i++ )); do\n    if [[ ${array[i]} -ge ${array[i-1]} ]]; then\n      digits=$(echo\
    \ \"${array[i]}\" | sed -re 's/^(0*)([[:digit:]]*)$/\\1\\2/p')\n      sum=${digits:-0}\n\
    \      index=0\n      for (( j=0; j<${#max_sum}; j++ )); do\n        if [ ${sum}\
    \ -ge ${max_sum} ]; then\n          max_sum=${sum}\n          max_i=$i\n     \
    \     break\n        fi\n        index=$(( index + ${#max_sum} ))\n        if\
    \ [ ${sum} -ge ${array[index+max_i]} ]; then\n          sum=${array[index+max_i]}\n\
    \        fi\n      done\n      sorted_array+=(\"${array[i-1]}\")\n      sorted_array+=(\"\
    ${array[index+max_i]}\")\n      sorted_array+=(\"${array[i]}\")\n    else\n  \
    \    sorted_array+=(\"${array[i-1]}\")\n      sorted_array+=(\"${array[i]}\")\n\
    \    fi\n  done\n  printf '%s\\n' \"${sorted_array[@]}\"", "    local IFS=$'\\\
    n' arr=()\n    # parse input argument\n    for arg in \"$@\"; do\n        local\
    \ elems=()\n        local j=0\n        while IFS= read -r elem; do\n         \
    \   ((j++))\n            elems+=( \"$elem\" )\n        done\n        # sort elements\
    \ and remove spaces and double quotes\n        arr+=( $(sort -n -k 1,1 -k \"$j\"\
    \ <<<\"${elems[*]}\")  )\n    done\n    # return sorted list\n    printf '[%s]'\
    \ \"${arr[@]}\"", "  local -n arr=$1\n  echo \"$arr\" | sort -n | sed -r 's/^(-?[0-9]+)(-[0-9]+)(-[0-9]+)(-[0-9]+)?$/-\\\
    1 -\\2 -\\3 -\\4/g' | sort | uniq", "  local -n arr=$1 n\n  echo \"$1\"\n  arr=(\
    \ $1 )\n  n=${#arr[@]}\n  local i sum\n  for ((i=1; i<=$n; i++)); do\n    sum=$(echo\
    \ $((${arr[i]} * $i)) | bc -l)\n    if [[ \"$sum\" -gt $(echo $((${arr[i]} / $i))\
    \ | bc -l) ]]; then\n      arr[i]=\"$sum\"\n    fi\n  done\n  printf '%s\\n' \"\
    ${arr[@]}\"", "  local sorted=()\n  local sorted_index=()\n  local sum=0\n  local\
    \ index=0\n  for item in \"$1\"; do\n    sum=$(( 10#$item + sum ))\n    sorted_index[$index++]=${item}\n\
    \  done\n  unset sum\n  unset item\n  local last\n  while IFS=$'\\t' read -r -a\
    \ lines; do\n    sum=0\n    for element in \"${lines[@]}\"; do\n      sum=$((\
    \ 10#$element + sum ))\n    done\n    sorted+=(\"${lines[@]}\")\n    if [ -n \"\
    $last\" -a -n \"${sorted[$(( index - 1 ))]}\" ]; then\n      if [ \"$last\" -gt\
    \ \"$sum\" ]; then\n        sorted+=(\"${sorted_index[$(( index - 1 ))]}\")\n\
    \      fi\n    fi\n    last=\"$sum\"\n  done < <(tr ' ' '\\t' <<< \"$1\") # replace\
    \ spaces by tabs\n  echo \"${sorted[@]}\"", "    local -n arr=$1; shift\n    local\
    \ -a tmp_arr=()\n    local -n result=()\n    while read -r point; do\n       \
    \ tmp_arr+=(\"$point\")\n    done <<< \"$1\"\n    for i in \"${!tmp_arr[@]}\"\
    ; do\n        tmp_arr[i]=$(echo \"${tmp_arr[i]}\" | \\\n        awk '{ printf(\"\
    \\\"%d\\\"\", $1) }')\n    done\n    arr_to_str \"${tmp_arr[@]}\" \"${result[@]}\"",
  "        local IFS=$'\\n'\n        local sorted_points=\"$1\"\n        local sorted_points_list=\"\
    \"\n        local max_points=0\n        local max_sum=0\n        local total_points=0\n\
    \        for point in $sorted_points\n        do\n                local current_sum=${point//[^0-9]}\n\
    \                local current_index=$((10#${point}))\n                local current_point=\"\
    $(get_point_name $current_index $total_points)\"\n                if [[ \"$current_sum\"\
    \ -gt \"$max_sum\" ]]\n                then\n                        max_sum=$current_sum\n\
    \                        max_points=$current_index\n                fi\n     \
    \           total_points+=1\n        done\n        if [ \"$max_points\" -eq \"\
    0\" ]\n        then\n                return $sorted_points\n        fi\n     \
    \   for point in $sorted_points\n        do\n                local current_sum=${point//[^0-9]}\n\
    \                local current_index=$((10#${point}))\n                local current_point=\"\
    $(get_point_name $current_index $total_points)\"\n                local current_sum_in_current_point=\"\
    $((${current_sum}+${max_sum}))\"\n                local current_sum_in_all_points=\"\
    $((${total_points}+${max_points}))\"\n                local index_of_current_point=$(get_index_of_point_name\
    \ $current_point)\n                if [ \"$current_sum_in_current_point\" -ge\
    \ \"$current_sum_in_all_points\" ]\n                then\n                   \
    \     local current_point_index=\"$(get_index_of_point_name \"$current_point\"\
    )\"\n                        local point_at_current_sum=\"$(get_point_name $current_point_index\
    \ $total_points)\"\n                        local point_at_current_sum_in_current_point=\"\
    $(get_point_name $current_point_index $current_sum_in_all_points)\"\n        \
    \                local point_at_current_sum_in_all_points=\"$(get_point_name $current_point_index\
    \ $total_points)\"\n                        local point_at_current_sum_in_all_points_with_point=\"\
    $(get_point_name $current_point_index $((total_points-1)+1))\"\n             \
    \           local point_at_current_sum_in_all_points_with_point_and_point=\"$(get_point_name\
    \ $current_point_index $total_points+2)\"\n                        local current_point_index_with_point=\"\
    $(get_point_name $current_index $((total_points-1)+1))\"\n                   \
    \     local current_point_index_with_point_and_point=\"$(get_point_name $current_index\
    \ $total_points+2)\"\n                        local point_at_current_sum_in_current_point_with_point=\"\
    $(get_point_name $current_point_index $current_sum_in_all_points_with_point_and_point)\"\
    \n                        ", "\t[[ $1 == \"\" ]] && return 0\n\t[[ $1 == *\"-\"\
    * ]] && return 0\n\tIFS=\" \" read -a nums <<< \"$1\"\n\tlocal -a tmp\n\tlocal\
    \ -a nums_tmp\n\tlocal -i i\n\tlocal tmp_index\n\tfor (( i = 1; i != ${#nums[@]}\
    \ - 1; i++ )); do\n\t\t(( tmp_index = 0 )\n\t\tcase \"${nums[$i]}\" in\n\t\t\t\
    -*) tmp_index=$(( ${#nums[$i]} - 1 )); break ;;\n\t\tesac\n\t\ttmp[$tmp_index]+=\"\
    ${nums[$i]}\"\n\tdone\n\tfor (( i = 1; i != ${#nums[@]} - 1; i++ )); do\n\t\t\
    [[ $tmp[$i - 1] -ge $tmp[$i] ]] && continue\n\t\tnums_tmp[$i]=true\n\tdone\n\t\
    echo $(IFS=' ' printf \"[%s]\" ${nums_tmp[@]})", "    local -n arr=$1\n    local\
    \ -a sorted_arr=()\n\n    # Sort the array\n    for i in \"${arr[@]}\"; do\n \
    \       let sum=$((10#$i + $sum))\n        sorted_arr+=($sum)\n    done\n\n  \
    \  # Sort the array by its elements\n    IFS=$'\\n' sorted_arr=($(printf '%s\\\
    n' \"${sorted_arr[@]}\"))\n    IFS=$' '\n\n    # Remove the redundant entries\
    \ from array\n    local -n result=()\n    for j in \"${!sorted_arr[@]}\"; do\n\
    \        [[ ${sorted_arr[j]} != ${sorted_arr[i]} ]] && result+=(\"${sorted_arr[j]}\"\
    )\n    done\n\n    echo \"${result[@]}\"", "  # Get the given input\n  list=\"\
    $1\"\n  # Trim the whitespace\n  list=$(echo \"${list}\" | sed -e 's/^[ \\t]*//'\
    \ -e 's/[ \\t]*$//')\n  # Split the input into a list of integers\n  list_numbers=$(echo\
    \ \"${list}\" | sed -e 's/ /\\n/g' | tr ' ' '\\n')\n  # Sort the list by the sum\
    \ of the digits in each integer\n  list_numbers=$(echo \"${list_numbers[@]}\"\
    \ | awk '{sum=0; for (i=1; i<=NF; i++) sum+=$i; print sum}')\n  # Sort the list\
    \ by the original index\n  list_numbers=$(echo \"${list_numbers[@]}\" | sort --stable\
    \ -n)\n  # Print the results\n  for i in $(seq 0 $((${#list_numbers[@]}-1)))\n\
    \  do\n    echo ${list_numbers[i]}\n  done", "    local sorted_list=\"$(printf\
    \ \"%s\" \"$@\" | sed -z 's/^\"(.*)\" \"$/\\1/' | sort -n | sed 's/^\"\\(.*\\\
    )\"$/\\1/')\"\n    echo ${sorted_list}", "\tlocal points=$1\n\tlocal sorted_points=()\n\
    \tlocal count=1\n\n\tfor point in $points; do\n\t\tcase \"${point}\" in\n\t\t\t\
    -*)\n\t\t\t\tsum=$(( 10#$point ))\n\t\t\t\tsorted_points[$count]=${sum}\n\t\t\t\
    \tcount=$(expr $count + 1)\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tsum=$(expr $(expr 10#$point\
    \ + $count) % 10)\n\t\t\t\tsorted_points[$count]=${sum}\n\t\t\t\tcount=$(expr\
    \ $count + 1)\n\t\t\t\t;;\n\t\tesac\n\tdone\n\n\tlocal sorted_points_sorted\n\t\
    for sorted_point in \"${sorted_points[@]}\"; do\n\t\tcase \"${sorted_point}\"\
    \ in\n\t\t\t-*)\n\t\t\t\tsorted_points_sorted+=${sorted_point#-}\n\t\t\t\t;;\n\
    \t\t\t*)\n\t\t\t\tsorted_points_sorted+=${sorted_point}\n\t\t\t\t;;\n\t\tesac\n\
    \tdone\n\n\techo ${sorted_points_sorted[@]}", "    local sorted_list\n    local\
    \ -n arr=$1\n    local num_list\n    local num_str\n    local index\n    local\
    \ sum_str\n    local num_digit\n\n    # Initialize variables for loop control\
    \ and sums\n    local -n sum=0\n    local -n max_idx=0\n\n    # Get the sum of\
    \ every number in arr\n    for((i=0; i<${#arr[@]}; i++)); do\n        ((sum+=${arr[i]}))\n\
    \    done\n\n    # Sort the numbers in arr according to their sum of digits\n\
    \    # (the sort algorithm is stable and does not cause a sort\n    # stability\
    \ issue when two numbers have the same sum of digits)\n    sorted_list=()\n  \
    \  for((i=0; i<${#arr[@]}; i++)); do\n        sum_str=\"${sum%:*}:\"\n       \
    \ sum_str=\"${sum_str//:/+}\"\n        sum_str=\"${sum_str//-/}\"\n        sum_str=\"\
    ${sum_str//+/}\"\n        sum_str=\"${sum_str//,/}\"\n        num_str=\"${arr[i]}\"\
    \n        num_str=\"${num_str//-/}\"\n        num_str=\"${num_str//+/}\"\n   \
    \     num_str=\"${num_str//,/}\"\n        num_str=\"${num_str//:/}\"\n       \
    \ num_str=\"${num_str//+/}\"\n        num_str=\"${num_str//,/}\"\n        num_str=\"\
    ${num_str//:*}\"\n        num_str=\"${num_str//:}\"\n        num_str=\"${num_str//,/}\"\
    \n        num_digit=$(expr length \"$num_str\")\n        if (( num_digit < max_idx\
    \ )); then\n            max_idx=${num_digit}\n        fi\n        sorted_list=(\"\
    ${sorted_list[@]}\" \"$num_str\")\n        sum=$((sum%num_digit))\n    done\n\
    \    echo \"${sorted_list[@]}\"", "    local IFS=$'\\n'\n    local arr=($1)\n\
    \    arr=(${arr[*]})\n    local tmp\n    local -a res\n    local sum=0\n    local\
    \ i\n\n    for ((i=0; i<${#arr[@]}; i++)); do\n        sum=$(echo $arr[i] | awk\
    \ '{printf(\"%u\", $1 + 0)}')\n        res[sum]=\"${arr[i]}\"\n    done\n    res=(\"\
    ${res[@]}\")\n    res=(\"${res[*]}\" )\n    for ((i=0; i<${#res[@]}; i++)); do\n\
    \        tmp=\"${res[i]}\"\n        echo \"${tmp%% *}\"\n    done", "    local\
    \ sorted_points=\"\"\n    local points=$(eval \"echo ${1}\")\n    # Sort the given\
    \ points array in ascending order\n    for point in ${points[@]}; do\n       \
    \ local point_sum=$(get_point_sum \"$point\")\n        local point_index=$(get_point_index\
    \ \"$point\")\n        case \"$point_sum\" in\n            # Points with \"-\"\
    \ in their name will be ordered at the\n            # top if they have same sum\
    \ of their digits\n            \"-\")\n                local top_index=${point_index}\n\
    \            ;;\n            *)\n                local top_index=0\n         \
    \   ;;\n        esac\n        local top_point=$(get_point_name \"$point\")\n \
    \       local top_point_index=$(get_point_index \"$top_point\")\n        case\
    \ \"$point_sum\" in\n            \"-\")\n                local point=\"-$point\"\
    \n            ;;\n            *)\n                local point=\"$point\"\n   \
    \         ;;\n        esac\n        local top_point_sum=$(get_point_sum \"$point\"\
    )\n        case \"$top_point_sum\" in\n            \"-\")\n                local\
    \ top_point=\"-$top_point\"\n            ;;\n            *)\n                local\
    \ top_point=\"$top_point\"\n            ;;\n        esac\n        sorted_points=\"\
    $sorted_points \\\"$top_point\\\" \\\"$point\\\" $top_index\"\n    done\n    echo\
    \ ${sorted_points[@]}", "  local list=\"$1\"\n  local index=0\n  local digit=0\n\
    \  local nums=()\n  local total=0\n  local item\n\n  # Extract numbers from original\
    \ list\n  while read -r item; do\n    case \"$item\" in\n      -*) continue;;\n\
    \      *) num=$(echo \"$item\" | sed -E 's/^(-?[0-9]+)$/\\1/');\n        nums+=(\"\
    $num\");\n        total=$(( total + num ));\n        ;;\n    esac\n  done <<<\
    \ \"$list\"\n\n  # Get index of first number\n  index=0\n  while [[ $nums[$index]\
    \ ]]; do\n    index=$(( index + 1 ))\n  done\n\n  # Sort numbers\n  while (( index\
    \ < ${#nums[@]} )); do\n    num=${nums[$index]}\n    digit=`echo $num | awk '{print\
    \ length($0)}'`\n\n    case \"$digit\" in\n      0) item=`echo $num | awk '{print\
    \ \"\"}'`;;\n      1) item=\"$num\";;\n      2) item=\"$num 0\"\n        case\
    \ \"$num\" in\n          \"\") item='\"\"';;\n          *) item='\"0\"';;\n  \
    \      esac;;\n      3) item=\"$num 1\";;\n      4) item=\"$num 2\"\n        case\
    \ \"$num\" in\n          \"\") item='\"\"';;\n          *) item='\"2\"';;\n  \
    \      esac;;\n      *) item=\"$num 3\";;\n    esac\n\n    nums[$index]=\"$item\"\
    \n    (( total = $total - $num ))\n\n    (( index++ ))\n  done\n\n  # Extract\
    \ sorted numbers to original list\n  while read -r item; do\n    case \"$item\"\
    \ in\n      -*) continue;;\n      *) list=\"$list $item\";;\n    esac\n  done\
    \ <<< \"$nums\"", "    local sorted_points=$(echo \"$1\" | tr ' ' ',')\n    local\
    \ sorted=\n    local sum\n    local index\n    local i=0\n    while read -r sum;\
    \ do\n        index=\"$(echo \"${sorted_points[i]}\" | awk '{ print $1 }')\"\n\
    \        (( sorted_points[index] += $sum ))\n        sorted+=\"$sum,$index\"\n\
    \        (( i+=1 ))\n    done < <(echo \"$sorted_points\" | sort -nr)\n    echo\
    \ \"$sorted\"", "  local items=$1\n  local sum=0\n  local max_sum=0\n  local i=0\n\
    \  while read -r item; do\n    sum=$((sum+${item//[[:space:]]/}))\n    if [[ $sum\
    \ > $max_sum ]]; then\n      max_sum=$sum\n    fi\n    i=$((i+1))\n  done <<<\
    \ \"$items\"\n  if [[ $i -eq 0 ]]; then\n    return 0\n  fi\n  local items_with_max_sum=$(for\
    \ i in $(seq 1 $i); do echo \"$items[$i]\"; done)\n  sort -n -k ${items_with_max_sum}\
    \ <<< \"$items_with_max_sum\"", "    local IFS=\n    local -a output\n    local\
    \ sorted_points\n\n    IFS=' '\n    sorted_points=( $(echo \"$1\" | awk '{for\
    \ (i=2; i <= NF; i+=2) sum+=i; print sum, NF, sum}' ) )\n    IFS=\n    output=(\
    \ $( sort -n \"${sorted_points[@]}\") )", "    local tmp tmp2 points\n    read\
    \ -a points <<< \"$1\"\n    points+=(\"0\")\n    for idx in \"${!points[@]}\"\
    ; do\n        # Sum digits of tmp and tmp2\n        tmp=$(echo \"${points[$idx]}${points[$((idx+1))]}\"\
    \ | bc -l | tr -d '.')\n        tmp2=$(echo \"${points[$idx]}${points[$((idx+2))]}\"\
    \ | bc -l | tr -d '.')\n        if [ \"${tmp:-0}\" -gt \"${tmp2:-0}\" ]; then\n\
    \            points[$idx]=${points[$idx]} \"$tmp\"\n            points[$((idx+1))]=${points[$((idx+1))]}\
    \ \"$tmp2\"\n        else\n            points[$idx]=${points[$idx]} \"$tmp2\"\n\
    \            points[$((idx+1))]=${points[$((idx+1))]} \"$tmp\"\n        fi\n \
    \   done\n    echo \"${points[*]}\"", "  local sort_cmd=\"sort -n -k1 --shell-escape\
    \ --field-separator=\\\";\\\" --numeric-sort --key=2\";\n  # Sort the list of\
    \ numbers based on the sum of their digits\n  echo $(eval $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd | $sort_cmd\
    \ | $sort_cmd | $sort_cmd | $sort_cmd | ", "  local list_=\"${1:-}\"\n  local\
    \ sorted_list=''\n  local sum=0\n  local index=0\n  local item\n  while IFS= read\
    \ -r; do\n    sum=$(echo \"$sum + $REPLY\" | bc)\n    sorted_list+=\"$REPLY\"\n\
    \  done < <(echo -n \"$list_\" | tr ' ' '\\n' | sort -nk 2 | tr '\\n' ' ')\n \
    \ for item in $sorted_list; do\n    index=$(echo \"$item + $sum\" | bc)\n    echo\
    \ \"$index\"\n  done", "    local string=\"$1\"\n    if [[ \"$string\" =~ \\'\
    \ ' ]]; then\n        string=${string#?}\n        string=${string%?}\n    fi\n\
    \    local IFS=' '\n    local -a numbers=( )\n    local -a points=( )\n    local\
    \ -a sorted=( )\n    local -i i\n\n    # Parse string into an array of numbers\n\
    \    while IFS=' ' read -a number; do\n        numbers+=( \"$(( ${number[0]} *\
    \ 10 + ${number[1]} ))\" )\n    done <<< \"$string\"\n\n    # Sort arrays in numerical\
    \ order\n    for ((i = 0; i < ${#numbers[@]}; i++)); do\n        local sum\n \
    \       sum=$(( ${numbers[i]} + ${numbers[i]} ))\n        points[$i]=\"${sum}${numbers[i]}\"\
    \n    done\n\n    # Sort arrays in alphabetical order within each number\n   \
    \ local k\n    for ((k = 0; k < ${#points[@]}; k++)); do\n        local i\n  \
    \      local point\n        for ((i = 0; i < (k + 1); i++)); do\n            point=\"\
    ${points[i]}\"\n            local digit\n            digit=\"${point:$(( ${#point}\
    \ / 2 ))}\"\n            local offset\n            offset=${#digit}\n        \
    \    local temp\n            temp=${point:$(( ${#point} - ${#digit} + offset ))}\n\
    \            points[$i]=\"${point}${digit}${temp}\"\n        done\n        sorted[k]=\"\
    ${points[$k]}\"\n    done\n\n    # Remove duplicate entries\n    local j\n   \
    \ for ((j = 0; j < ${#sorted[@]}; j++)); do\n        local point\n        point=\"\
    ${sorted[j]}\"\n        sorted[j]=${point:$(( ${#point} / 2 ))}\n    done\n\n\
    \    # Return sorted list\n    echo $(IFS=', ';echo \"${sorted[*]}\")", "  local\
    \ numbers=$1\n  local output=''\n  local original_index=0\n  local total_sum=0\n\
    \  local count_points=0\n  while [[ $numbers ]]; do\n    local index=$(echo $numbers\
    \ | awk -F \".\" '{print $1}')\n    local sum=$(echo $numbers | awk -F \".\" '{print\
    \ $2}')\n    ((total_sum+=${#sum}+1))\n    ((count_points+=1))\n    local temp_index=$(echo\
    \ $original_index+$index | bc)\n    local temp_sum=$(echo $total_sum+$index |\
    \ bc)\n    if [ $temp_sum -gt $total_sum ]; then\n      temp_index=$(echo $temp_index+1\
    \ | bc)\n      temp_sum=$(echo $temp_sum+1 | bc)\n    fi\n    original_index=$temp_index\n\
    \    output=\"${output}\\\"${index}\\\"\"\n    numbers=$(echo $numbers | sed 's/^\\\
    ([0-9]\\+\\) .*/\\1/')\n  done\n  if [ $count_points -gt 1 ]; then\n    output=\"\
    ${output}\\\"${original_index}\\\"\"\n  fi\n  output=\"${output}\"\n  echo $output",
  "  local input=\"$1\"\n  local inputLines\n  inputLines=$(echo $input | tr \" \"\
    \ \"\\n\")\n  local sortedInputLines\n  sortedInputLines=$(\n    local inputLines\n\
    \    local sortedInputLines\n    local inputLine\n    local inputLine\n    local\
    \ sum\n    local i\n    local count\n    local countIndex\n    sum=0\n    countIndex=0\n\
    \    count=0\n    for inputLine in $inputLines; do\n      inputLine=$(echo $inputLine\
    \ | tr \" \" \"\\n\")\n      for inputItem in $inputLine; do\n        if [ \"\
    $inputItem\" == \"-\" ]; then\n          sum=-1\n        elif [ \"$inputItem\"\
    \ == \"+\" ]; then\n          sum=1\n        elif [ \"$inputItem\" == \".\" ];\
    \ then\n          sum=0\n        else\n          sum=$(expr $(echo \"$sum + $inputItem\"\
    \ | bc -l))\n        fi\n      done\n      sortedInputLines=$(\n        local\
    \ sortedInputLines\n        local inputLine\n        local inputLine\n       \
    \ local inputItem\n        local sum\n        local i\n        local count\n \
    \       local countIndex\n        sortedInputLines=\"$sortedInputLines \\\"$sum\\\
    \"\"\n      done\n      sortedInputLines=$(echo $sortedInputLines | tr \" \" \"\
    \\n\")\n      if [ \"$sortedInputLines\" != \"0\" ]; then\n        countIndex=$(echo\
    \ $sortedInputLines | tr \" \" \"\\n\" | sort -n -k 2 | head -1)\n        count=$((\
    \ $(echo $countIndex | tr -s ' ' | wc -l | tr -d ' ') ))\n        sortedInputLines=\"\
    $sortedInputLines \\\"$countIndex\\\" \\\"$count\\\"\"\n      fi\n      sortedInputLines=$(echo\
    \ $sortedInputLines | tr \" \" \"\\n\")\n      sortedInputLines=$(echo $sortedInputLines\
    \ | tr \" \" \"\\n\")\n      sortedInputLines=$(echo $sortedInputLines | tr \"\
    \ \" \"\\n\")\n      sortedInputLines=$(echo $sortedInputLines | tr \" \" \"\\\
    n\")\n      sortedInputLines=$(echo $sortedInputLines | tr \" \" \"\\n\")\n  \
    \    sortedInputLines=$(echo $sortedInputLines | tr \" \" \"\\n\")\n      sortedInputLines=$(echo\
    \ $sortedInputLines | tr \" \" \"\\n\")\n      sortedInputLines=$(echo $sortedInputLines\
    \ | tr \" \" \"\\n\")\n      sortedInputLines=$(echo $sortedInputLines | tr \"\
    \ \" \"\\n\")\n    done\n    sortedInputLines=$(echo $sortedInputLines | tr ",
  "  local input=\"$1\"\n  if [ \"${input}\" = \"\" ]; then\n    return 0\n  fi\n\
    \  local points=($(echo \"${input}\" | awk '{for(i=1;i<=NF;i++) {sum+=$i;}}END{print\
    \ sum}'));\n  local -A numbered_input=();\n  local -A output=();\n  local -A sums=();\n\
    \  for idx in \"${!points[@]}\"; do\n    local sum=$(echo \"${points[$idx]}\"\
    \ | awk '{print ($0+$1)}')\n    local key=${!sums[$sum]}\n    if [ \"${key}\"\
    \ == \"${idx}\" ]; then\n      local tmp=$(echo \"${input[$idx]}\" | cut -c1);\n\
    \      local key=$(echo \"${input[$idx]}\" | cut -c2);\n      local value=${!numbered_input[$key]};\n\
    \      numbered_input[$key]=$idx\n      sums[$sum]=\"${idx}\";\n      output[$idx]=\"\
    ${tmp}${value}\"\n    fi\n  done\n  IFS=$'\\n' echo \"${!output[@]}\"", "    local\
    \ sorted_points_list number_of_digits sum_list\n    number_of_digits=\"${#1}\"\
    \n    sum_list=\"$(\n        echo \"$1\" |\n        awk '\n            function\
    \ sum2str(sum, digit_sum) {\n                if (digit_sum == 0) {\n         \
    \           printf(\"%0*d\\n\", 4, sum);\n                } else {\n         \
    \           digit_sum += sum;\n                    printf(\"%0*d\\n\", 4, digit_sum);\n\
    \                }\n            }\n            BEGIN {\n                sum_list\
    \ = sprintf(\"%0*d\", 4, 0);\n            }\n            {\n                for\
    \ (i = 1; i <= NF; i++) {\n                    sum2str($i, sum_list);\n      \
    \          }\n                printf(\"%s\\t\", $i);\n            }\n        \
    \    END {\n                printf(\"\\n\");\n                for (i = 1; i <=\
    \ number_of_digits; i++) {\n                    sum2str($i, sum_list);\n     \
    \           }\n            }\n        '\n    )\"\n    # Remove the quotes\n  \
    \  sorted_points_list=\"$(\n        echo \"$sum_list\" |\n        awk -F, '{\n\
    \            for (i = 1; i <= NF; i++) {\n                if ($i ~ /^\"(.*)\"\
    $/) {\n                    gsub(/\"/,\"\",$i);\n                    print substr($i,2)\n\
    \                }\n            }\n        }'\n    )\"\n    # Sort them\n    sorted_points_list=\"\
    $(\n        echo \"$sorted_points_list\" |\n        awk '{\n            n = length($1);\n\
    \            for (i = 1; i <= n; i++) {\n                a = substr($1, i, 1);\n\
    \                b = substr($1, i+1, 1);\n                c = substr($0, i+1,\
    \ 1);\n                d = substr($0, i, 1);\n                gsub(/-/, \"+\"\
    , a);\n                gsub(/-/, \"+\", b);\n                if (a == b) {\n \
    \                   if (c == d) {\n                        print $1\n        \
    \            } else {\n                        print a \" \" $0\n            \
    \        }\n                } else if (a > b) {\n                    print a \"\
    \ \" $0\n                } else {\n                    print b \" \" $0\n    \
    \            }\n            }\n        }'\n    )\"\n    echo \"$sorted_points_list\"",
  "  local arr=(\"$@\")\n  # If given empty string, return an empty list\n  [[ \"\
    ${arr[@]}\" = \"\" ]] && return 0;\n  local tmp;\n  # Initialize result array\n\
    \  result=();\n  # Sort given list in the descending order\n  # by summing up\
    \ the digits of the given numbers\n  for num in \"${arr[@]}\"; do\n    tmp_str=$(echo\
    \ \"$num\" | awk '{print $1}');\n    tmp_num=$(echo \"$num\" | awk '{print $2}');\n\
    \    if [[ ! \"$tmp_str\" =~ ^[[:digit:]]+$ ]]; then\n      echo \"ERROR: Not\
    \ a valid input number: \\\"$num\\\"\" > error;\n      continue;\n    fi\n   \
    \ if [[ $tmp_num -gt 0 ]]; then\n      tmp_str=$(echo \"$tmp_str\" | awk '{printf\
    \ \"%i\" $1}');\n    fi\n    tmp=($(echo \"$tmp_str\"|bc -l))\n    tmp_sum=$(echo\
    \ \"${tmp[0]} + ${tmp[1]}\"|bc -l);\n    echo \"$tmp_sum\"\n    echo \"${arr[$((${#arr[@]}-1))]}\"\
    \n    if [ \"$tmp_sum\" -lt 0 ]; then\n      tmp=($(echo \"$tmp_str\"|bc -l))\n\
    \      tmp_sum=$(echo \"${tmp[0]} + ${tmp[1]}\"|bc -l);\n      echo \"$tmp_sum\"\
    \n      echo \"${arr[$((${#arr[@]}-1))]}\"\n    fi\n    tmp_sum=$(echo \"$tmp_str\"\
    |bc -l)\n    if [ \"$tmp_sum\" -eq 0 ]; then\n      tmp=($(echo \"$tmp_str\"|bc\
    \ -l))\n      tmp_sum=$(echo \"${tmp[0]} + ${tmp[1]}\"|bc -l);\n      echo \"\
    $tmp_sum\"\n      echo \"${arr[$((${#arr[@]}-1))]}\"\n    fi\n    if [ \"$tmp_sum\"\
    \ -gt 0 ]; then\n      result=(\"${result[@]}\" \"${num}\")\n    fi\n  done\n\
    \  echo \"${result[@]}\"", "\techo \"$1\" | sed 's/ /\\n/g' | sed 's/^/\\n/g'\
    \ | sort -n -k 2", "  local str=$1\n  local -a arr=( )\n  local i sum\n  for i\
    \ in $(echo $str | awk -F\" \" '{for(i=1;i<=NF;i++)sum+=$i; print $i}')\n  do\n\
    \    arr[$i]=$(echo $i | awk '{printf \"%s%s\", sum, length($0) > 1 ? OFS : \"\
    \"}')\n    sum=0\n  done\n  for i in $(seq 0 $((${#arr[@]}-1)) )\n  do\n    if\
    \ [[ ${arr[$i]} == ${arr[$(( i + 1 ))] } ]]; then\n      arr[$i]=\"${arr[$(( i\
    \ + 1 ))]}\"\n      arr[$(( i + 1 ))]=\"${arr[$i]}\"\n    fi\n  done\n  echo ${arr[@]}",
  "  local items=$1\n  shift\n  local sum=0\n  local i=0 j=1\n  for i in $items; do\n\
    \    (( sum += ${#i} ))\n  done\n  local res=()\n  while [ $j -le ${#items} ];\
    \ do\n    (( sum = ${sum%9} + ${items} ))\n    res[$j-1]=${items%${#items}}\n\
    \    (( items = ${items#${res[$j-1]}} ))\n    (( j++ ))\n  done\n  local sort_items=()\n\
    \  for i in \"${res[@]}\"; do\n    sort_items=($sort_items \"$i\")\n  done\n \
    \ local j=1\n  for j in \"${!res[@]}\"; do\n    sort_items=($sort_items \"$j\"\
    )\n  done\n  eval \"sort -n <<< ${sort_items}\"", "  local items=$(echo $1 |sed\
    \ \"s/ /\",\"/g\")\n  local sum=$(echo $items |sed 's/^\\(.*\\)\\(.*\\)\\(.*\\\
    )\\(.*\\)/\\3\\2\\1/'|bc)\n  local i=0\n  while read -r item; do\n    i=$((i+1))\n\
    \    if [[ -n $item ]]; then \n      local j=0\n      while read -r jitem; do\n\
    \        j=$((j+1))\n        if [[ -n $jitem ]]; then \n          local sum=$(echo\
    \ $jitem |sed 's/^\\(.*\\)\\(.*\\)\\(.*\\)/\\3\\2/'|bc)\n          if [[ $sum\
    \ -eq $sum ]]; then \n            echo $(echo $jitem |sed 's/^\\(.*\\)\\(.*\\\
    )/\\2\\1/')\n          fi\n        fi\n      done < <(echo $item |sed 's/^\\(.*\\\
    )\\(.*\\)/\\1\\2/'|bc)\n    fi\n  done < <(echo $items |sed 's/^\\(.*\\)/\\1/'|bc)",
  "    local sorted_points=$(echo \"$1\" | tr \" \" \"\\n\" | sort -r | \\\n     \
    \   sed \"s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^ *//g;s/^\
    \ *//g;s/^ *", "    local n\n    local sum=0\n    local i=0\n    while [ $i -lt\
    \ ${#1[*]} ]; do\n        n=${1:$i:1}\n        if [ \"$n\" != \"$n\" ] 2>/dev/null;\
    \ then\n            sum=$(( ${sum}+$n ))\n        else\n            sum=$(( ${sum}\
    \ ))\n        fi\n        i=$(( i+1 ))\n    done\n    declare -a result=($*)\n\
    \    local j=0\n    local last=-1\n    while [ $j -lt ${#result[@]} ]; do\n  \
    \      if [ $last -gt ${result[$j]} ]; then\n            result[$j+1]=$result[$j]\n\
    \        else\n            result[$j+1]=$last\n        fi\n        i=$(( j+1 ))\n\
    \        j=$(( j+1 ))\n        last=${result[$j]}\n    done\n    echo ${result[@]}",
  "    if [[ \"$1\" = \"\" ]]; then\n        echo \"[]\"\n        return\n    fi\n\
    \    local sorted_points=$(\n        echo \"$1\" | awk '\n        {\n        \
    \    sum=0;\n            for (i = 1; i <= NF; i++) {\n                for (j =\
    \ 1; j <= NF; j++)\n                    if ((j > 1) && ($i == $j)) {\n       \
    \                 sum+=$(echo \"$i\" | cut -d\"-\" -f1)\n                    \
    \    i=$j\n                        break\n                    }\n            }\n\
    \            if (sum > 0) {\n                printf \"[\\\"%s\\\"]\", $i;\n  \
    \              sum=0\n            }\n        }'\n    )\n    echo $sorted_points",
  "    local i sum=$(get_sum \"$1\")\n    echo \"[${sum}${i}]\"", "    read -n1 -p\
    \ \"Input a list of integers (separated by spaces):\" input\n    declare -A nums=()\n\
    \    for n in $input; do\n        # Read each number and compute its sum\n   \
    \     ((nums[\"$n\"]++))\n    done\n    # Sort the number according to their sum\n\
    \    IFS=' ' read -r -a sorted <<<$(sort -n -t / -k 2,2 -k 3,3 -k 4,4 -k 1,1 <<<\"\
    ${!nums[@]}\")\n    for n in ${sorted[@]}; do\n        echo \"$n\"\n    done",
  "  local input_list=$1\n  local sorted_list\n  local item_sum\n  local item_order_index\n\
    \  sorted_list=\"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo\
    \ \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\\
    n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"\
    $( IFS=$'\\n'; echo \"$( IFS=$'\\n'; echo \"", "  local list=\"$1\"\n  local items=($(IFS=$'\\\
    n'; echo \"$list\"))\n  local sum=()\n  local i\n  local j\n  local sort\n\n \
    \ for i in \"${items[@]}\"; do\n    for j in \"${items[@]}\"; do\n      if ((\
    \ $(echo \"$i > $j\" | bc -l) )); then\n        sort=\"${sort} $i\"\n      fi\n\
    \    done\n    sum+=($(echo \"$sum | bc -l\"))\n    sort=\"${sort} $i\"\n  done\n\
    \n  echo \"${list[@]}\"", "  local -a nums=(\"$@\")\n  local -a sorted=()\n  local\
    \ -a sums=()\n  local i\n  for i in \"${nums[@]}\"; do\n    sums+=(\"$((10#$i))\"\
    )\n  done\n  for i in \"${!sums[@]}\"; do\n    sorted+=(\"${nums[$i]}\")\n  done\n\
    \  local tmp\n  for ((i=${#sorted[@]}-1; i>0; i--)); do\n    local sum\n    sum=$(echo\
    \ \"${sums[$i]}\" | tr -d '\\n' | sort -n -k 2 | head -1 | awk '{print $3}')\n\
    \    if [[ -z \"$sum\" ]]; then\n      continue\n    fi\n    sorted[$i]=\"$((10#$sum))\"\
    \n  done\n  echo \"${sorted[@]}\"", "  local i\n  local sum\n  local sorted_list\n\
    \  local i\n\n  sum=0\n  for ((i=${#1}; i; i--)); do\n    sum=$(expr \"$sum\"\
    \ + ${1%i}) 2>/dev/null\n  done\n\n  sorted_list=($1)\n  for i in ${!sorted_list[@]};\
    \ do\n    if [[ \"${sorted_list[i]}\" == \"${sum}\" ]]; then\n      sorted_list[i]=${sorted_list[i-1]}\n\
    \    fi\n  done\n\n  printf '%s\\n' \"${sorted_list[@]}\"", "    local sorted=\n\
    \    # split by space\n    IFS=\" \" read -r -a items <<< \"$1\"\n    local max_score=0\n\
    \    local max_idx=0\n\n    # sort by sum of digits\n    for idx in \"${!items[@]}\"\
    ; do\n        score=\n        IFS='.' read -r -a piece <<< \"${items[$idx]:1}\"\
    \n        # strip leading zeros\n        for (( i=0; i<${#piece[@]}; i++ )); do\n\
    \            if [[ \"${piece[$i]}\" =~ ^[[:digit:]]*$ ]]; then\n             \
    \   score+=\"$(echo \"${piece[$i]}\" | bc)\"\n            else\n             \
    \   score+=\"0\"\n            fi\n        done\n        if [[ $score -gt $max_score\
    \ ]]; then\n            sorted=( \"${sorted[@]}\" \"$idx\" )\n            max_score=$score\n\
    \            max_idx=$idx\n        fi\n    done\n\n    # sort by original order\
    \ if necessary\n    for idx in \"${!items[@]}\"; do\n        if [[ \"$idx\" ==\
    \ \"$max_idx\" ]]; then\n            sorted=( \"${sorted[@]}\" \"$idx\" )\n  \
    \      fi\n    done\n    IFS=\" \" printf '\"%s\"\\n' \"${sorted[@]}\"", "  local\
    \ -n items=$1; shift\n  local -A itemsBySum\n  local -n sum=items\n  local -n\
    \ idx\n  for idx in \"${!sum[@]}\"; do\n    itemsBySum[\"$(sum_digits \"${sum[idx]}\"\
    )\"]=\"${items[idx]}\"\n  done\n  printf '%s\\n' \"${!itemsBySum[@]}\"", "  local\
    \ list=\"${1:-}\"\n  if [[ -z \"$list\" ]]; then\n    return 0\n  fi\n  local\
    \ digits=$(echo -en ${list} | sed \"s/[[:space:]]//g\" | sort -n | cut -d \" \"\
    \ -f 3)\n  local sorted_list=\"$(echo -en ${list} | sed \"s/[[:space:]]//g\" |\
    \ sort -n | cut -d \" \" -f 1)\"\n  local num=0\n  for (( i=1; i<${#sorted_list};\
    \ i++ )); do\n    if [[ $sorted_list = \"$i\" ]]; then\n      (( num++ ))\n  \
    \  fi\n  done\n  local output=''\n  for (( i=0; i<num; i++ )); do\n    output+=\"\
    ${digits[$i]}\"\n  done\n  echo -en \"${output}\\n\"", "    local -n arr=$1\n\
    \    local -a sorted=()\n    local index sum sum_in_digits digit\n    local i\n\
    \n    for ((i=1; i<${#arr[@]}; i++)); do\n        sum_in_digits=0\n        sum=$(echo\
    \ \"${arr[i]}\" | awk '{ printf \"%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
  "  local input=\"$1\"\n  local points\n\n  points=\"$input\" | sed -n 's/^\\(.*\\\
    )[\\t ]*\\([0-9]\\+\\)[\\t ]\\+\\([0-9]\\+\\)[\\t ]\\+\\([0-9]\\+\\)$/\\2 \\3\
    \ \\4 \\1/p'\n  IFS=' ' read -r -a points <<< \"$points\"\n\n  printf \"[%s]\\\
    n\" \"${points[@]}\" | sort -n -r -k1,2 | awk '{printf \"%s %s %s\\n\", $1, $2,\
    \ $3 | \"sort -n\"}'", "  local IFS=' '\n  sort -n -r -k2,2 -k3,3 -k3,3 \"$1\"\
    \ |\n    awk '{\n      printf(\"%s\", ($1 == \"#\" ? \"#\" : $1)) ;\n      for\
    \ (i = 2; i <= NF; i++) {\n        sum = 0 ;\n        for (j = 2; j <= length($i);\
    \ j++) {\n          sum = sum * 10 + $i[j] - '0' ;\n        }\n        printf(\"\
    \ %s\", sum) ;\n      }\n      printf(\"\\n\");\n    }'", "    local sorted_list=\"\
    $1\"\n    if [[ \"${sorted_list}\" == \"\" ]]; then\n        echo \"[]\"\n   \
    \     return\n    fi\n\n    local -a sorted_by_digit\n    local digit\n    local\
    \ digits_with_leading_zero\n    local i\n    local j\n\n    echo \"${sorted_list}\"\
    \ | while read i; do\n        # split into array of digits\n        digits_with_leading_zero=\"\
    $(echo \"${i}\" | awk '{print $1}')\"\n\n        for j in \"${!digits_with_leading_zero}\"\
    ; do\n            # get digit\n            digit=\"${digits_with_leading_zero[j]}\"\
    \n\n            # sort them in numerical order\n            sorted_by_digit[${digit}]=\"\
    ${i}\"\n        done\n    done\n\n    # re-arrange them based on their sum\n \
    \   echo \"${sorted_by_digit[@]}\"", "    local -n arr=$1\n    arr=(\"${(@s:-$1)}\"\
    )\n    local sorted_arr=()\n    local sum_of_digits=0\n    local sorted_index=()\n\
    \    local index_count=${#arr[@]}\n    if [ $index_count -eq 0 ]; then\n     \
    \   return 0\n    fi\n    for ((i=0; i<${#arr[@]}; i++)); do\n        sum_of_digits+=${arr[i]}\n\
    \        sorted_index+=($i)\n    done\n    sum_of_digits=$((10#${sum_of_digits%$index_count}))\n\
    \    for ((i=1; i<${#arr[@]}; i++)); do\n        sum_of_digits+=${arr[i]}\n  \
    \      sum_of_digits=$((10#${sum_of_digits%$index_count}))\n    done\n    local\
    \ i\n    for ((i=0; i<${#sorted_index[@]}; i++)); do\n        arr[$sorted_index[i]]=${arr[$sorted_index[i]]#0}\n\
    \        arr[$sorted_index[i]]=$((sum_of_digits+${arr[$sorted_index[i]]%10}))\n\
    \    done\n    arr=(\"${arr[@]}\")\n    for ((i=0; i<${#arr[@]}; i++)); do\n \
    \       arr[$i]=$((${arr[$i]}%10))\n    done\n    local j\n    for ((j=0; j<${#arr[@]};\
    \ j++)); do\n        arr[j]=${arr[j]}\n        if [[ ${arr[j]} -eq 0 ]]; then\n\
    \            arr=(\"${arr[@]:0:j}\" \"${arr[@]:j}\")\n            break\n    \
    \    fi\n    done\n    for ((j=0; j<${#arr[@]}; j++)); do\n        arr[j]=\"${arr[j]}\
    \ ${arr[j]}\"\n    done\n    arr=(\"${arr[@]}\")\n    sorted_arr=(\"${sorted_arr[@]}\"\
    )", "  # Get a list of space-separated integers\n  local integers=$(echo \"$1\"\
    \ | sed 's/^\\([0-9]*\\)[ ]*\\([0-9]*\\)[ ]*\\([0-9]*\\)$/\\1 \\2 \\3/')\n  if\
    \ [ -z \"$integers\" ]\n  then\n    echo \"$integers\"\n    return\n  fi\n\n \
    \ local sorted_integers=\"\"\n  # For each number, get the sum of its digits\n\
    \  local num_sum\n  for num in $integers\n  do\n    num_sum=0\n    while [[ $num\
    \ >0 ]]\n    do\n      num_sum=$((num_sum + $num % 10))\n      num=$((num / 10))\n\
    \    done\n    sorted_integers=\"$sorted_integers $num_sum\"\n  done\n  echo \"\
    $sorted_integers\"", "    local str=$1\n    local sums=\"\"\n    local sorted=()\n\
    \    local tmp\n\n    IFS=' ' read -ra strarr <<< \"$str\"\n    for idx in \"\
    ${!strarr[@]}\"; do\n        tmp=${strarr[idx]}\n        sums=${sums+\"${tmp//\
    \ /+}\"}\n    done\n\n    IFS=+\n    read -ra strarr <<< \"$sums\"\n    for idx\
    \ in \"${!strarr[@]}\"; do\n        sorted+=( \"$strarr[idx]\" )\n    done\n\n\
    \    for idx in \"${!sorted[@]}\"; do\n        echo \"\\\"${sorted[idx]}\\\"\"\
    \ \n    done", "  local number=$1\n  local sum=$(printf \"%.0f\" $(( $(echo \"\
    $number\" | cut -c1-9) )) )\n  local digits=$(echo $number | tr -cd '0-9')\n \
    \ local max_index=$(echo $digits | wc -c)\n\n  local i=0\n  local num_sorted=()\n\
    \  local new_sum\n  local num_to_add\n\n  for (( i=0; i<$max_index; i++ )); do\n\
    \    num_to_add=$(echo \"$sum * $i\" | bc)\n    if [[ ${#num_to_add} -eq 0 ]];\
    \ then\n      num_to_add=1\n    fi\n    new_sum=$(echo \"$sum + $num_to_add\"\
    \ | bc)\n    num_sorted+=($new_sum)\n    sum=$new_sum\n  done\n\n  echo $num_sorted",
  "  local arr\n  if [[ -z \"$1\" ]]; then\n    arr=()\n  else\n    IFS=' ' read -ra\
    \ arr <<< \"$1\"\n  fi\n  local order\n  local tmp\n  local i=0\n  local size=${#arr[@]}\n\
    \  local max_i\n\n  while [[ $i -lt $size ]]; do\n    max_i=0\n    for j in $(seq\
    \ 0 $i); do\n      if [[ $arr[$j] =~ ^[+-]?[0-9]+$ ]]; then\n        max_i=$((max_i+${#arr[$j]}))\n\
    \      fi\n    done\n    order=\"$max_i\"\n    if [[ $i -lt $max_i ]]; then\n\
    \      tmp=\"${arr[$i]}\"\n      arr[$i]=\"${arr[$max_i]}\"\n      arr[$max_i]=\"\
    $tmp\"\n      max_i=$((max_i-1))\n    fi\n    i=$((i+1))\n  done\n\n  IFS=' '\
    \ read -ra arr <<< \"${arr[@]}\"\n  printf '%s\\n' \"${arr[@]}\"", "    set -f\n\
    \    echo \"$1\" | sort -n -k 2 | sed 's/^ *//g' | sed 's/^ //g' | sort -n -k\
    \ 1 | sed 's/^ //g'", "  local -n arr=$1 sum=0\n  # Sort the list into ascending\
    \ order based on sum\n  for i in $(echo $arr | tr ' ' , | sort -rn | cut -d' '\
    \ -f 2); do\n    ((sum += $i))\n  done\n  echo \"$arr\" | tr ' ' , | sort -rn\
    \ | cut -d' ' -f 2", "    local sorted_list\n    local input\n    IFS=' ' read\
    \ -r -a input <<< \"$1\"\n    for element in \"${input[@]}\"; do\n        local\
    \ digit\n        for digit in $(echo \"${element}\" | tr '[:upper:]' '[:lower:]'\
    \ | sed 's/\\([0-9]*\\)$/.\\1/'); do\n            local tmp_sum=\"${digit} + ${digit}\
    \ * ${digit}\"\n            local tmp_count=\"${digit} + ${digit}\"\n        \
    \    # Check if we already have this sum, otherwise add it to the list\n     \
    \       if [[ \"$sorted_list\" =~ \"$tmp_sum\" ]];\n            then\n       \
    \         # Sort based on index number\n                (( ${BASH_REMATCH[1]}\
    \ ))\n                tmp_count=\"${BASH_REMATCH[1]}\"\n            else\n   \
    \             sorted_list=\"$element $tmp_count $tmp_sum\"\n            fi\n \
    \       done\n    done\n    echo $sorted_list", "  # Convert list to array of\
    \ integers.\n  local integers=($(echo \"$1\" | tr \" \" \"\\n\"))\n\n  # Get sum\
    \ of all digits.\n  local digits=$( echo \"${integers[@]}\" | sed 's/^\\([0-9]*\\\
    )$/\\1/g;s/^0*//;s/^ *//g;s/ *$//g;s/-/ /g;s/^ *//g;s/^ *//g;s/ *$//g;s/^ *//g;s/\
    \ *$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g'\
    \ |sort -n)\n\n  # Sort list by sum.\n  integers=( $(echo \"${integers[@]}\" |\
    \ sort -n) )\n\n  # Sort list by original index.\n  local sorted_indexes=$(echo\
    \ \"${integers[@]}\" | sort -n | awk '{print $1}')\n\n  # Re-construct sorted\
    \ list.\n  local sorted_list=\"\"\n  local sorted_string=\"\"\n  for index in\
    \ $(echo \"${sorted_indexes}\" | sort -n)\n  do\n    sorted_string=\"$sorted_string'${sorted_list[$index]}'\"\
    \n  done\n  sorted_list=\"$sorted_string\"", "  local input=\"$1\"\n  shift\n\n\
    \  local output\n  output=\"$(IFS=' ' read -ra words <<<\"$input\")\"\n  IFS=\"\
    , \" read -r -a sorted_words <<<\"${output[@]}\"\n\n  # Sort input array using\
    \ custom sort function\n  local -n custom_sort\n  custom_sort=(\n    declare -n\
    \ IFS\n    IFS=' '\n    # Read each word from the input array in a new array and\
    \ sort it\n    # in the following way:\n    # - If it is an even number of digits,\
    \ sort by sum of their digits\n    # - If it is a odd number of digits, sort by\
    \ index of original array\n    # Note: the function below is independent from\
    \ IFS and uses it internally.\n    local -a words\n    words=(\"$@\")\n    IFS=\"\
    -\" custom_sort=(\n      ((${#words[@]} % 2) == 0)\n      # Sort even number of\
    \ digits by sum of their digits\n      local -i i\n      for ((i = 0; i < ${#words[@]};\
    \ i+=2)); do\n        ((sum=${words[i]}+${words[i+1]}))\n        words[i]=\"${sum}\"\
    \n        words[i+1]=\n      done\n      # Sort odd number of digits by index\
    \ of original array\n      for ((i = 1; i < ${#words[@]}; i+=2)); do\n       \
    \ custom_sort+=(${i})\n      done\n    )\n  )\n\n  # Sort the array\n  custom_sort\
    \ \"${sorted_words[@]}\"\n\n  # Join elements from sorted array and return\n \
    \ printf '%s\\n' \"${sorted_words[@]}\"", "  # First count how many numbers have\
    \ similar digits.\n  local nums=$1\n  local nums_len=$(echo $nums | wc -w)\n\n\
    \  if [[ $nums_len -eq 0 ]]; then\n    return 0\n  fi\n\n  local num_sums=()\n\
    \  local num_sums_len=$(echo $num_sums | wc -w)\n\n  local sorted_nums=()\n  local\
    \ sorted_nums_len=$(echo $sorted_nums | wc -w)\n\n  for ((i=0; i<$nums_len; i++));\
    \ do\n    ((num_sums[$i]+=( $(echo $nums | cut -d ' ' -f $i | sed \"s/^0*//\"\
    \ | bc) ))\n  )\n\n  local sorted_nums_tmp\n  local sorted_nums_tmp_len\n  local\
    \ sorted_nums_tmp_len2\n  local num_sort_flag=0\n  local num_sort\n\n  for ((j=0;\
    \ j<$num_sums_len; j++)); do\n    ((num_sort_flag=1))\n    num_sums_tmp_len=$(echo\
    \ $num_sums | wc -w)\n    sorted_nums_tmp_len=$num_sums_tmp_len\n    while [[\
    \ ${sorted_nums_tmp_len} = 0 ]] && [[ ${j} -eq $num_sums_len ]]; do\n      num_sort_flag=0\n\
    \      ((j++))\n      if [[ $num_sort_flag = 0 ]]; then\n        ((sorted_nums_tmp_len=1))\n\
    \      fi\n    done\n    num_sums_tmp_len2=$(echo $num_sums | wc -w)\n\n    ((num_sums_tmp_len2=num_sums_tmp_len))\n\
    \    while [[ $num_sort_flag -ne 0 ]] && [[ ${j} -eq $num_sums_len ]] && [[ $num_sums_tmp_len2\
    \ -eq $num_sums_tmp_len ]]; do\n      ((num_sort_flag=0))\n      ((j++))\n   \
    \   if [[ $num_sort_flag = 0 ]]; then\n        ((num_sums_tmp_len2=num_sums_tmp_len))\n\
    \      fi\n    done\n    sorted_nums_tmp_len2=$num_sums_tmp_len2\n    ((sorted_nums_tmp_len2=sorted_nums_tmp_len2))\n\
    \n    if [[ ${sorted_nums_tmp_len2} -lt ${num_sums_tmp_len2} ]]; then\n      num_sort=$(echo\
    \ ${num_sums[$j]:0:$num_sums_tmp_len2} | sort -n -k 2 -r | head -n 1)\n    else\n\
    \      num_sort=$(echo ${num_sums[$j]:$num_sums_", "  local list_str=$1\n  # Split\
    \ list into its elements\n  local items=$( echo \"$list_str\" | sed \"s/[[:space:]]*[[:digit:]]\\\
    +\\s/ /g\")\n  local sort_cmd=\"sort\"\n  # Sort elements based on their sum\n\
    \  local order_cmd=\"sort -s\"\n  # Store result\n  local order_list_str=$( echo\
    \ $items | $sort_cmd | $order_cmd)\n  # Remove extra spaces\n  local order_list=$(\
    \ echo \"$order_list_str\" | sed \"s/ /\\n/g\")\n  # Remove quotes\n  local order_list_noquotes=$(\
    \ echo \"$order_list\" | sed \"s/'//g\")\n  # Remove double quotes\n  local order_list_noquotes_no_double_quotes=$(\
    \ echo \"$order_list_noquotes\" | sed \"s/\\\"//g\")\n  # Remove line end\n  local\
    \ order_list_noquotes_no_double_quotes_no_line_end=$( echo \"$order_list_noquotes_no_double_quotes_no_line_end\"\
    \ | sed \"s/\\$//g\")\n  # Remove last line\n  local order_list_noquotes_no_double_quotes_no_line_end_no_last_line=$(\
    \ echo \"$order_list_noquotes_no_double_quotes_no_line_end_no_last_line\" | sed\
    \ \"s/\\$//g\")\n  # Remove last line and quote\n  local order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_quote=$(\
    \ echo \"$order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_quote\"\
    \ | sed \"s/\\$//g\")\n  # Remove last space (should be only one before last element\
    \ in list)\n  local order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_space_no_quote=$(\
    \ echo \"$order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_space_no_quote\"\
    \ | sed \"s/\\$//g\")\n  # Remove last space (should be only one before last element\
    \ in list)\n  local order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_space_no_quote_no_last_space_no_quote=$(\
    \ echo \"$order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_space_no_quote_no_last_space_no_quote\"\
    \ | sed \"s/\\$//g\")\n  # Remove last space (should be only one before last element\
    \ in list)\n  local order_list_noquotes_no_double_quotes_no_line_end_no_last_line_no_space_no_quote_no_last_space_no_quote_no_last_space"]
stop_tokens:
- "\n}"
