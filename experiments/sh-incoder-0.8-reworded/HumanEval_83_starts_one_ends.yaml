name: HumanEval_83_starts_one_ends
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
  \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
  starts_one_ends() {\n"
tests: "}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
  \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
  \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
completions: ["  local n=$1 res=0\n  local i starts_one_ends_i=0 starts_one_ends_j=0\n\
    \  for ((i=1; i<=n; i++)); do\n    ((j=$((i-1)))) #j is i - 1\n    if (( $i ==\
    \ $j )); then\n      # first iteration\n      starts_one_ends_i=1\n    elif (\
    \ $i == ((j+1) % $n) ); then\n      # the middle iteration\n      starts_one_ends_i=2\n\
    \    else\n      # second iteration\n      starts_one_ends_i=3\n    fi\n    #\
    \ j is i-1\n    if (( $i == $j )); then\n      # last iteration\n      starts_one_ends_j=1\n\
    \    elif ( $i == ((j-1) % $n) ); then\n      # the middle iteration\n      starts_one_ends_j=2\n\
    \    else\n      # the middle iteration\n      starts_one_ends_j=3\n    fi\n \
    \   if (( $starts_one_ends_i == 3 )); then\n      # j=i+1\n      if (( $starts_one_ends_j\
    \ == 3 )); then\n        # j=i-1\n        ((res++))\n      fi\n    fi\n  done\n\
    \  echo \"$res\"", "  local -r n=\"${1}\"\n  (( n < 10 )) || return\n  (( n %\
    \ 10 )) == 1 || (( n > 10 )) && return\n  local num=1\n  while (( num < n ));\
    \ do\n    (( num *= 10 ))\n    (( num += 1 ))\n  done\n  echo ${num}", "  local\
    \ n=$1\n  local count=1\n  local i\n\n  for i in $(seq $n $((10#$n + 1)) -1 0);\
    \ do\n    (( n % 10 == 1 && n % 1 == 1 )) && count=$((count + 1))\n  done\n\n\
    \  echo $count", "  local number=$1\n  local n=$2\n\n  if [ $n -lt 10 ]\n  then\n\
    \    echo \"$number\"\n    return 0\n  fi\n  while [ $n -gt 0 ]\n  do\n    local\
    \ i=$(( $n % 10 ))\n    local count=$(( $count + $n ))\n    if [ $i -eq 1 ]\n\
    \    then\n      local count=$(( $count + $n ))\n      echo $count\n    fi\n \
    \   n=$(( $n / 10 ))\n  done", "  local num_args=$(wc -l \"$1\") # Number of arguments\
    \ in $1, $2...\n  local count=$1 # First argument is the integer to check\n  if\
    \ [ \"$num_args\" -gt 1 ]; then # $1 is non-empty\n    for (( count = 1; count\
    \ <= $1; count++ )); do\n      for (( i = $count; i >= 1; i-- )); do\n       \
    \ local temp=$1\n        local digit=$(( $temp % 10 ))\n        [ $digit -eq 1\
    \ ] || return $count\n        temp=$(( $temp / 10 ))\n      done\n    done\n \
    \ fi", "    # Start with the first 1-digit number\n    local num=1\n\n    # Iterate\
    \ through remaining numbers, counting the numbers\n    # where the first digit\
    \ is 1.\n    for (( num=$1; $num >=1; $num++ ))\n    do\n        local i=0;\n\
    \        local nums=$(seq 1 $num)\n        for n in $nums; do\n            # Count\
    \ how many times this number ends with a 1\n            if [[ (($(n+1)%10)==1)\
    \ ]]; then\n                (( i++ ))\n            fi\n        done\n        echo\
    \ $i\n    done", "    local n=$1\n    local count=0\n    while test $n -gt 0\n\
    \    do\n        local digit=$(( n % 10 ))\n        test \"$digit\" = 1 && ((\
    \ digit==1 )) && count=$(( count+1 ))\n        n=$(( n / 10 ))\n    done\n   \
    \ echo $count", "    local i\n    local count=0\n    local digits=$(($(echo \"\
    $1\" | awk '{printf \"%d\", $1}')))\n    for ((i=1; i<=digits; ++i)); do\n   \
    \   if (( $(( $1 % 10 )) )); then\n          ((count++))\n      fi\n      (( 1\
    \ = $1 % 10 ))\n    done\n    echo \"$count\"", "    local number=$1\n    local\
    \ ones=0\n    local tens=0\n    local hundreds=0\n    local thousands=0\n    local\
    \ i=0\n    local count=$(expr 1 + $number)\n    while [ $i -lt $count ]; do\n\
    \        local number=$(( 10#$number ))\n        local digit=$(echo $number |\
    \ cut -c1)\n        case \"$digit\" in\n            1) ones=$(( ones + 1 ));;\n\
    \            10) tens=$(( tens + 1 ));;\n            100) hundreds=$(( hundreds\
    \ + 1 ));;\n            1000) thousands=$(( thousands + 1 ));;\n            *)\
    \ echo \"Bad number in starts_one_ends: $number\" >&2\n              return 1;;\n\
    \        esac\n        i=$(( $i + 1 ))\n    done", "  if (( $1 )) ; then\n   \
    \ local n=$1\n    (( $n > 0 )) || return\n    (( $n < 10 )) || return\n    local\
    \ startsone=0\n    local endsone=0\n    local count=0\n    while (( $n >= 10 ))\
    \ ; do\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      ((\
    \ $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) ||\
    \ return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n     \
    \ (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 ))\
    \ || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n  \
    \    (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % ", "  (( $# != 1 )) && echo \"starts_one_ends: $1\
    \ not an integer\" && return 1\n\n  local n=$1\n  (( n > 1 )) && echo \"starts_one_ends:\
    \ $n must be greater than 1\" && return 1\n\n  local -i i=0\n  (( $# == 1 )) &&\
    \ return $n\n\n  (( $# > 1 )) && echo \"starts_one_ends: too many arguments\"\
    \ && return 1\n\n  local -i j=0\n  (( $# > 2 )) && echo \"starts_one_ends: too\
    \ many arguments\" && return 1\n\n  local -r starts_one_ends=true\n  local -r\
    \ ends_one_starts=false\n  local -r one_at_beginning=false\n\n  (( $# == 2 ))\
    \ && starts_one_ends=$2\n  (( $# == 3 )) && ends_one_starts=$3\n  (( $# == 4 ))\
    \ && one_at_beginning=$4\n\n  local -r prefix=1\n  local -r suffix=$(expr `expr\
    \ $n - 1` \\* 10)\n  (( suffix > 0 )) && prefix=$n\n  (( $(( suffix - 1 )) <=\
    \ $n )) && prefix=$(( prefix + 1 ))\n\n  local -r start=$(expr `expr $prefix \\\
    * 10` \\* `expr $i + 1` \\* 10)\n  local -r end=$(expr `expr $prefix \\* 10` \\\
    * `expr $j + 1` \\* 10)\n  (( $(( $start + 1 )) <= $n )) && end=$(( $n \\* 10\
    \ \\* 2 ))\n\n  (( end <= $n )) && end=$(( $n \\* 10 ))\n  (( $(( $end - 1 ))\
    \ <= $n )) && end=$(( $n \\* 10 \\* 2 ))\n\n  (( $ends_one_starts == true )) &&\
    \ echo \"starts_one_ends: prefix $prefix suffix $suffix start $start end $end\"\
    \ && return 0\n  (( $one_at_beginning == true )) && echo \"starts_one_ends: prefix\
    \ $prefix suffix $suffix start $start end $end\" && return 0\n  (( $ends_one_starts\
    \ == false )) && echo \"starts_one_ends: suffix $suffix start $start end $end\"\
    \ && return 0\n  (( $one_at_beginning == false )) && echo \"starts_one_ends: suffix\
    \ $suffix start $start end $end\" && return 0", '  starts_one_ends "$@"', "  local\
    \ input=$1\n  local output=$2\n  local -a candidates=()\n\n  # count the number\
    \ of numbers that start or end with 1\n  for n in $(seq 1 $input); do\n    case\
    \ \"${input:$n:1}\" in\n      1|[1-9])\n        candidates+=($n)\n        ;;\n\
    \      *)\n        break\n        ;;\n    esac\n  done\n  if (( ${#candidates[@]}\
    \ > $output )); then\n    echo >&2 'Usage:  starts_one_ends n output'\n    exit\
    \ 1\n  fi", "    local n=$1\n    local count=0\n    for i in $(seq 1 $n); do\n\
    \        local digit=$( echo $i | sed 's/\\(.\\)/\\1/g' )\n        if [ \"$digit\"\
    \ == \"1\" ]; then\n            count=$(($count+1))\n        elif [ \"$digit\"\
    \ == \"0\" ]; then\n            count=$(($count-1))\n        fi\n    done\n  \
    \  return $count", "    (( $# != 1 )) && return 1;\n    # count the number of\
    \ starting and ending 1's in the number\n    local n=\"$1\"\n    local nstr=\"\
    $n\"\n    local nstart=0\n    local nend=0\n    # scan the string one char at\
    \ a time\n    local i=0\n    while [[ $nstr != 0 ]]; do\n        (( i-- ))\n \
    \       local c=${nstr:$i:1}\n        # only count if character is 1\n       \
    \ if [[ $c -eq 1 ]]; then\n            (( nstart++ ))\n        elif [[ $c -eq\
    \ 0 ]]; then\n            (( nend++ ))\n            # nstr = nstr - 1\n      \
    \      # nstr = nstr + 1\n            nstr=$(( $nstr + 1 ))\n        fi\n    done\n\
    \    echo \"$nstart\"", "  # Input validation\n  if [[ \"$1\" -gt 0 ]]; then\n\
    \    echo -n \"Invalid input: \\\"$1\\\" is not greater than 0\"\n    return 1\n\
    \  fi\n\n  # Process parameters\n  local n=\"$1\"\n  local nstr=\"\"\n  local\
    \ lenstr=\"\"\n  local i=0 j=0\n  local count=0\n\n  while (( i < n )); do\n \
    \   (( j=i * 10 ))\n    (( j += 1 ))\n    (( j > n ))\n    (( j %= 10 ))\n   \
    \ (( j %= 10 ))\n    (( i %= 10 ))\n\n    (( count += 1 ))\n\n    if (( ( i )\
    \ == ( j )) || [[ ${nstr} == 1 ]]; then\n      (( lenstr = lenstr + ${nstr} ))\n\
    \      (( nstr = ${nstr} + \"0\" ))\n    else\n      (( nstr = ${nstr} + \"1\"\
    \ ))\n    fi\n    (( i ++))\n  done\n\n  # Output parameter\n  echo \"$count\"",
  "  local n=$1\n  # If n is 0, it won't work. Return 0.\n  if [ $n -eq 0 ]\n  then\n\
    \    return 0\n  fi\n  local count=0\n  local digits=0\n  local i\n  # Use a while\
    \ loop to keep a count of the number of starting numbers with 1\n  # in them (including\
    \ starting numbers with 1 at the end).\n  while [ $n -gt 0 ]; do\n    # Get the\
    \ last digit in $n\n    digit=$(( n % 10 ))\n    # If this digit is a 1, count\
    \ it\n    if [ $digit -eq 1 ]\n    then\n      # Add one to the count\n      count=$((\
    \ $count + 1 ))\n    fi\n    # Decrement $n by one and get the last digit in $n\n\
    \    digit=$(( n % 10 ))\n    # Keep going if $n is non-zero\n    if [ $n -eq\
    \ 0 ]\n    then\n      break\n    fi\n  done\n  echo \"$count\"", "  (( $# !=\
    \ 1 )) && { echo \"Usage: starts_one_ends n\"; exit 1; }\n\n  # The count is the\
    \ number of ones in $1 which ends with 1 so for\n  # 123 we have 1s, 123 then\
    \ 2s and 123 then 3s\n  # For numbers less than 10, we only have one 1 which ends\
    \ with 1\n  # For numbers 0 through 9 we have one 1 which ends with 1\n  # And\
    \ for numbers 10 through 99 we have two 1s which ends with 1\n  # And for numbers\
    \ 100 through 999 we have three 1s which ends with 1\n  # And for numbers 1000\
    \ through 9999 we have four 1s which ends with 1\n  # And for numbers 10000 through\
    \ 99999 we have five 1s which ends with 1\n  # And for numbers 100000 through\
    \ 999999 we have six 1s which ends with 1\n  # And for numbers 1000000 through\
    \ 999990 we have seven 1s which ends with 1\n  # And for numbers 10000000 through\
    \ 9999990 we have eight 1s which ends with 1\n  # And for numbers 100000000 through\
    \ 9999999 we have nine 1s which ends with 1\n  # And for numbers 1000000000 through\
    \ 999999999 we have ten 1s which ends with 1\n  (( ${1:0:1} > 10 )) && \\\n  \
    \  (( ( ${1:0:1} == 10 && ( ${1:1} % 10 == 0 )) || \\\n        ( ${1:0:1} == 0\
    \ )) && \\\n      (( ( ${1:0:1} == ${1:0:0:1} && \\\n        ( ${1:0:1} % ${1:0:1}\
    \ == 0 ) && \\\n        ( ${1:0:1} % 10 == 0 )) || \\\n        ( ${1:0:1} == ${1:0:0:1}\
    \ && \\\n          ( ${1:0:1} % ${1:0:1} == 0 ) && \\\n          ( ${1:0:1} %\
    \ 10 != 0 ))))", "    if [ \"$1\" -ne 1 ]; then\n        echo \"error: expect\
    \ a positive integer\"\n        return 1\n    fi\n    \n    local -r n=$1\n  \
    \  local -r \"count\"=( $( ( echo {0..$(echo $n-1|bc|awk '{print $1+1}')} | sed\
    \ 's/.// {n;s/.$//;p;q}') <<< 1 ) )\n    echo \"${count[@]}\"", "  if [[ $1 -lt\
    \ 10 ]] || [[ $1 -gt 19 ]]; then\n    echo \"$1 is not a positive integer.\"\n\
    \    exit 1\n  fi\n  local n=$1\n  local cnt=0\n  local one=1\n  local zero=0\n\
    \  local i\n  for (( i = 0; i < n; i++ )); do\n    (( one += ( $( echo $1 | bc\
    \  $(echo $1 | cut -d ' ' -f $i)) ))\n    (( zero += ( $( echo $1 | bc $(echo\
    \ $1 | cut -d ' ' -f $i-1) ) ))\n    (( zero -= ( $( echo $1 | bc $(echo $1 |\
    \ cut -d ' ' -f $i+1) ) ))\n    (( cnt += ( one > zero )))\n    (( cnt += ( zero\
    \ < one )))\n  done\n  echo $cnt", "  local n=$1\n  local count=1\n  while [ $n\
    \ -gt 1 ]; do\n    ((n--))\n    if [ $(( n % 10 )) -eq 1 ]; then\n      if [ $((\
    \ n % 100 )) -eq 1 ]; then\n        ((count++))\n      fi\n    fi\n  done\n  echo\
    \ $count", "  local n=$1\n  local count=0\n  local start=1\n  local end=0\n  while\
    \ [ $n -gt 0 ]; do\n    if [ $n -eq 0 ]; then\n      count=$((count+end-start))\n\
    \      start=$end\n      end=0\n    elif [ $((n % 10)) -eq 1 ]; then\n      count=$((count+end-start))\n\
    \      start=$((start+1))\n      end=$((start+1))\n    else\n      count=$((count+end-start))\n\
    \      start=$((start+1))\n      end=$((end+1))\n    fi\n    n=$((n-1))\n  done\n\
    \  echo \"$count\"", "    # Based on the example in http://www.math.utah.edu/~behr/spring07/digit-count-problem/count-digits.shtml\n\
    \n    local n=$1\n    if [ $n -lt 10 ]\n    then\n        echo \"Error: $1 must\
    \ be an integer.\"\n        return 1\n    fi\n\n    local numbers=$(seq 1 $n)\n\
    \    local first=1\n    local second=1\n    local rest=1\n\n    for i in ${numbers};\
    \ do\n        local one_end=$(echo $i | bc -l | grep -E '^1')\n        if [ $one_end\
    \ != \"\" ]\n        then\n            if [ $first -eq 1 ]\n            then\n\
    \                first=$one_end\n                second=$i\n            else\n\
    \                rest=$one_end\n            fi\n        fi\n    done\n\n    echo\
    \ $first $second $rest", '  [ $1 -gt 0 ] && [ $1 -le 100 ] && starts_one_ends
    $(( 10#$1 - 10 )) || starts_one_ends $(( 10#$1 + 1 )) || exit 0', "    local i\
    \ iend counter=0 number=0\n    local i1\n    for i1=${1}; ; do\n        number=$((10#$i1))\n\
    \        if (( $number == 0 )); then\n            ((counter++))\n        else\n\
    \            if (( $number == 10 )); then\n                iend=1\n          \
    \  else\n                if (( $number == $end )); then\n                    iend=0\n\
    \                else\n                    if (( iend == 0 )); then\n        \
    \                ((counter++))\n                    fi\n                fi\n \
    \           fi\n        fi\n    done\n    if (( counter != 0 )); then\n      \
    \  echo \"$1 starts or ends with $(( 10#$end )) $(( 10#$number )) times each\"\
    \n        echo \"$1 ends with $(( 10#$iend )) $(( 10#$number )) times each\"\n\
    \        echo \"$1 starts with $(( 10#$i1 )) $(( 10#$number )) times each\"\n\
    \        echo \"$1 is $counter times $(( 10#$number )) digits starting with $((\
    \ 10#$i1 )) and ending with $(( 10#$iend ))\"\n    else\n        echo \"$1 is\
    \ $number digits starting with $(( 10#$i1 )) and ending with $(( 10#$iend ))\"\
    \n    fi", "\tlocal -i j=1\n\tlocal -i n=$1\n\n\twhile [ $n -gt 0 ]; do\n\t\t\
    local -i k=$((j-1))\n\t\t[ $((k*10)) == $n ] && return $((n-k))\n\t\t[ $((k*10+1))\
    \ == $n ] && return $((n-k+1))\n\t\tj=$((n-1))\n\tdone\n\n\techo \"$n is invalid\
    \ input\"\n\texit 1", "  local n=$1\n  ((n>0)) && echo \"$(( n-( $(expr $n \\\
    % 9) ))\") || return 1\n  ((n<0)) && echo \"$(( $(expr $n \\% 9 \\* -1 ) + 9 ))\"\
    \ || return 1", "  if [ $# -eq 0 ]\n  then\n    echo \"Usage: $0 n\"\n    exit\
    \ 0\n  fi\n\n  local n=$1\n  local s=0\n  local e=0\n  local c=0\n\n  while [\
    \ $n -gt 0 ]\n  do\n    [ $((n%10)) -eq 1 ] && c=$((c+1))\n    [ $((n%10)) -eq\
    \ 9 ] && e=$((e+1))\n    n=$((n/10))\n  done\n\n  [ $((c+1)) -gt 0 ] && s=$((s+c))\n\
    \  [ $((e+1)) -gt 0 ] && s=$((s+e))\n\n  echo \"$s\"", "  n=$1\n  count=0\n  while\
    \ [ $n -gt 0 ]; do\n    if [ $((n & 1)) == 0 ]; then\n      count=$((count+1))\n\
    \      n=$((n/10))\n    else\n      n=$((n/10))\n    fi\n  done\n  echo $count",
  "  n=$1\n  i=0\n  while [[ $((n%10)) -ne 1 ]]; do\n    i=$((i+1))\n    n=$((n-1))\n\
    \  done\n  echo $i", "    (( ! $1 )) && return 1\n    local n=$1\n    echo $((\
    \ $n / 10 )) | bc\n    starts_one_ends $(( n - $(( $n / 10 )) ))", "    if [ -z\
    \ $1 ]; then echo \"No argument given\"; return 1; fi\n    if [ $(($1%10)) -eq\
    \ 1 ]; then return 0; fi\n    local n=$1\n    local i=0\n    local count=0\n \
    \   local ndigits=$(echo \"$n\" | bc -l | grep -o \"[0-9][0-9]*\")\n    while\
    \ [ $i -lt $ndigits ]; do\n        if [ $(($1%10)) -eq 1 ]; then count=$(($count+1));\
    \ fi\n        i=$(($i+1))\n    done\n    echo \"$count\"", "  local n=$1\n\n \
    \ local count\n  count=0\n\n  # iterate over all possible numbers from 1 to 9\n\
    \  for (( c=1; c<=9; c++ )); do\n    # check whether any of our numbers is equal\
    \ to n\n    if (( $( echo \"$c\" | bc -l ) == $n )); then\n      # if the number\
    \ is 1, we can terminate this loop\n      break\n    fi\n    # increase the count\
    \ by 1\n    count=$(( $count + 1 ))\n  done\n\n  # return the count\n  echo $count",
  "  if (( $# != 1 )); then\n    echo \"Usage: starts_one_ends <integer>\"\n    exit\
    \ 1;\n  fi\n  # Make sure $1 is really an integer.\n  local integer=$1\n  if ((\
    \ $integer <= 0 ))\n  then\n    echo \"Usage: starts_one_ends <integer>\"\n  \
    \  exit 1;\n  fi\n  # $2 will contain our result.\n  local count=0\n  while true\n\
    \  do\n    local integer=$(( $integer - 1 ))\n    # This is how we count the number\
    \ of integers that start with or end\n    # with 1.\n    if (( $integer == 1 ))\n\
    \    then\n      (( count++ ))\n      break\n    fi\n    (( $integer > 0 ))\n\
    \  done\n  echo $count", "  local -i n count\n  (( n = $1 ))\n  (( count = 0 ))\n\
    \  while (( n > 0 )); do\n    (( count++ ))\n    (( n = n / 10 ))\n  done\n  echo\
    \ $count", "  n=$1\n  local -a array\n  local starts_one starts_one_ends\n  starts_one=$(n-`expr\
    \ $n / 10` - 1)\n  starts_one_ends=$(n-$starts_one)\n  array=( {1..n}; {starts_one};\
    \ {starts_one_ends} )\n  echo ${#array[@]}", "  local n=$1\n  local result\n \
    \ result=0\n  for ((i=1; i<=n; i++)); do\n    if [[ $((i-1)) -eq 0 ]]; then result=$((result+1))\
    \ fi\n    if [[ $((i)) -eq 0 ]]; then result=$((result+1)) fi\n    if [[ $((i))\
    \ -eq $((n-1)) ]]; then result=$((result+1)) fi\n  done\n  echo $result", "  local\
    \ num=$1\n  local sum=0\n  local n=$1\n\n  if [ $n -lt 10 ]\n  then\n    echo\
    \ $n\n    return\n  fi\n\n  while [ $n -gt 1 ]\n  do\n    sum=$(( $sum + $(( $num\
    \ % $n )) ))\n    n=$(( $n / 10 ))\n  done\n\n  echo $(( $sum + 1 ))", "  local\
    \ starts_one_ends=$1\n  local n=$2\n\n  local count=0\n  local num=1\n  while\
    \ [[ $num -le $n ]]; do\n    local digit=`echo $num | cut -d $(( 10#$num % $n\
    \ )) -f 1`\n    if [ $(( $digit + 1 )) -eq $starts_one_ends ]; then\n      count=$((\
    \ count + 1 ))\n    fi\n    (( num++ ))\n  done\n\n  echo ${count}", "  local\
    \ n=\"$1\"\n  local count\n  count=0\n  while [ \"$n\" -gt 0 ]; do\n    # If the\
    \ first digit is 1, we know that it is not the last digit.\n    if [ $((n%10))\
    \ -eq 1 ] ; then\n      count=$((count + 1))\n    fi\n    n=$((n/10))\n  done\n\
    \  echo \"$count\"", "    declare -i number=$1\n    declare -i result\n\n    for\
    \ (( i = 0; i < number; i++ )); do\n        result=$(($result + $(expr \"$i\"\
    \ : '^\\(1\\).*$\\|^\\(.\\1\\).*$' <<< \"$i\")))\n    done\n\n    echo \"$result\"",
  "  [[ $# -lt 1 ]] || [[ $1 -gt 36 ]] || { echo >&2 \"Usage: starts_one_ends n\"\
    ; exit 1; }\n\n  local -r n=\"$1\"\n  local -r s=\"$2\"\n\n  local -r count=0\n\
    \  local -r result=''\n  while test $n -gt 0 ; do\n    local -r digit=\"$((10#$n%10))\"\
    \n    test \"$digit\" = \"1\"\n    if test \"$s\" = \"start\"; then\n      ((count++))\n\
    \    elif test \"$s\" = \"end\"; then\n      ((count--))\n    else\n      { echo\
    \ >&2 \"Usage: $0 n\"; exit 1; }\n    fi\n    n=\"$((10#$n//10))\"\n  done\n \
    \ echo $count", "  test -z \"$1\" || {\n    echo \"$FUNCNAME: invalid argument\
    \ for $1: missing argument\" >&2\n    return 1\n  fi\n\n  # Count the number of\
    \ lines in file that start with 1.\n  local n\n  n=$(( $1 + 0 ))\n  head -n $n\
    \ \"$1\" | wc -l | xargs", "  local n=$1\n  (( n > 0 )) || return 1\n  (( n ==\
    \ 1 )) || return 0\n  starts_one_ends $(( n - 1 ))\n  starts_one_ends $(( n -\
    \ 1 )) && echo 1\n  starts_one_ends $(( n - 2 )) && echo 1 || return 0", "  #\
    \ Check whether the start is 0 or 1\n  if [ \"$1\" -eq 0 -o \"$1\" -eq 1 ]; then\n\
    \    # Return 1 if number is zero\n    echo \"$1\"\n    return 1\n  fi\n  # Set\
    \ up parameters\n  start=$1\n  shift 1\n  # Set up array\n  arr=( $(eval echo\
    \ {1..$start}) )\n  # Count number of starts\n  count=0\n  for i in \"${arr[@]}\"\
    ; do\n    if [ \"$i\" -eq \"$start\" -o \"$i\" -eq 1 ]; then\n      count=$((count+1))\n\
    \    fi\n  done\n  # Count number of ends\n  for i in \"${arr[@]}\"; do\n    if\
    \ [ \"$i\" -eq 0 -o \"$i\" -eq 1 ]; then\n      count=$((count+1))\n    fi\n \
    \ done\n  # Return count\n  echo \"$count\"", "  number=$1\n  i=2\n  while [ $i\
    \ -le $number ]; do\n    digit=$(( $i % 10 ))\n    if [[ $digit -eq 1 && $number\
    \ -eq $i ]]; then\n      count=$(( $count + 1 ))\n    fi\n    (( i++ ))\n  done\n\
    \  echo \"$count\"", "  # Check to see if a number was passed in\n  if [[ -z \"\
    $1\" ]]; then\n    echo \"Usage: starts_one_ends <integer>\"\n    return 1\n \
    \ fi\n\n  # Initialize variables\n  count=$((${1}))\n  digit=0\n\n  # Iterate\
    \ through each digit of the input number\n  while [ $count -ge 0 ]; do\n    digit=$((${digit}+${count}))\n\
    \    count=$((${count}-1))\n  done\n\n  # Check to see if the last digit is 1\
    \ or not\n  if [ ${digit} -eq ${1} ]; then\n    return 0\n  else\n    return 1\n\
    \  fi", "\tlocal n=$1\n\tlocal starts_one_ends=\"\"\n\tlocal nstr=$(( $n - 1 ))\n\
    \tlocal remainder\n\tlocal digit\n\twhile [ \"$n\" -gt 0 ]; do\n\t\tdigit=$((\
    \ $n % 10 ))\n\t\tremainder=$(( $n % 10 ))\n\t\tif [ \"$digit\" -eq \"1\" ]; then\n\
    \t\t\tstarts_one_ends=\"$starts_one_ends $n\"\n\t\tfi\n\t\tn=$(( $n / 10 ))\n\t\
    \tif [ \"$remainder\" -eq \"0\" ]; then\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo -n\
    \ \"$starts_one_ends\"", "    local n=$1\n    local -i count=0\n    for ((i=1;\
    \ i <= n; i++)); do\n        if (( i % 100 == 0 )); then\n            printf -v\
    \ cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 10 ==\
    \ 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 100 == 0 )); then\n            printf -v cnt \"\
    %d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 1000 == 0 ));\
    \ then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n      \
    \  fi\n        if (( i % 100000 == 0 )); then\n            printf -v cnt \"%d\"\
    \ $i\n            echo ${#cnt}\n        fi\n        if (( i % 10000000 == 0 ));\
    \ then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n      \
    \  fi\n        if (( i % 100000000 == 0 )); then\n            printf -v cnt \"\
    %d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 1000000000 ==\
    \ 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 10000000000 == 0 )); then\n            printf -v\
    \ cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 100000000000\
    \ == 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 1000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 10000000000000\
    \ == 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 100000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 1000000000000000\
    \ == 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 10000000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 100000000000000000\
    \ == 0 )); ", "\tlocal i=$1\n\twhile test $i -lt 100\n\tdo\n\t\tlocal j=$((i+1))\n\
    \t\twhile test $((j-1)) -lt 100\n\t\tdo\n\t\t\tlocal k=$((j-1))\n\t\t\ttest $((k*10+k))\
    \ -eq $((j*10+j)) && echo \"$i $j\"\n\t\t\tk=$((k-1))\n\t\tdone\n\t\ti=$((i+1))\n\
    \tdone", "    echo \"$1\" | awk -v n=1 '{\n        if ((n - $1) % 2 == 0) count++\n\
    \        for (i = 1; i <= n - 1; i++)\n            if ($i % (2 * i - 1) == 0)\
    \ count++\n        if ($1 == n) count++\n        END{\n            print \"$count\"\
    \n        }\n    }'", "    local n=$1\n    local count=$(echo \"$n\" | sed -e\
    \ 's/^\\([0-9]*\\).*1\\(.*\\)\\([0-9]*\\)/\\2/' | wc -w)\n    echo \"$count\"",
  "  local n=$1\n  local count res\n\n  # count the number of times this number appears\n\
    \  count=0\n  while ((n > 0)); do\n    (( count++ ))\n    (( n -= 10 ))\n  done\n\
    \  # add one\n  (( count++ ))\n\n  # reserve the result\n  res=$count\n\n  # if\
    \ the number ends in 1 add one\n  (( n-- ))\n  (( res-- ))\n  while ((n != 0));\
    \ do\n    (( n-- ))\n    (( res-- ))\n  done\n  # add one\n  (( res-- ))\n  return\
    \ \"$res\"", "    if [ \"$1\" -ne \"0\" ]; then\n        echo 0\n        return\
    \ 1\n    fi\n    for i in {1..100}; do\n        if [ $(expr \"$i\" \"$1\" = 1)\
    \ -eq 1 ]; then\n            echo 1\n            return 0\n        fi\n    done\n\
    \    return 1", "  if [ $1 -lt 1 ]; then\n    echo 1\n    return 0\n  fi\n  count=0\n\
    \  twos=0\n  fives=0\n  tens=0\n  for i in {1..$1}; do\n    if [ $i -eq 1 ]; then\n\
    \      count=$((count+1))\n    elif [ $i -ge 10 ]; then\n      if [ $i -le 5 ];\
    \ then\n        fives=$((fives+1))\n      else\n        twos=$((twos+1))\n   \
    \   fi\n    else\n      if [ $i -le 9 ]; then\n        tens=$((tens+1))\n    \
    \  fi\n    fi\n  done\n  echo \"$count $twos $fives $tens\"", "    local n=$1\n\
    \    local count=0\n    for i in {1..n}; do\n        ((n%10==1 && n!=1)) || continue\n\
    \        ((n%10==9 && n!=9)) || continue\n        ((n%10==0 && n!=0) || continue)\n\
    \        ((n==1 || n==9 || n==0) && (++count))\n    done\n    echo \"${count}\"",
  "    local n=$1\n    if [ $n -lt 1 ]; then return 1\n    elif [ $n -gt 1 ]; then\
    \ return 0\n    else\n        local sum=0\n        while [ $n -gt 0 ]; do\n  \
    \          ((sum+=$(expr $n % 10)))\n            n=$(expr $n / 10)\n        done\n\
    \        return $sum\n    fi", "    local i j\n    for ((i=0; i<$1; i++)); do\n\
    \        for ((j=1; j<$1; j++)); do\n            [[ \"$i\" = \"$j\" ]]\n     \
    \       [[ \"$i\" = \"${j#1}\" ]]\n            [[ \"$i\" = \"${j%1}\" ]]\n   \
    \         [[ \"$i\" = \"$j#${j%1}\" ]]\n        done\n    done", "  local int_num=$1\n\
    \  local int_count=${int_num}\n\n  for (( digit=$(( ${int_num} -1 )); digit >=\
    \ 1; digit-- )) ; do\n    local num_count=$(math -w \"${int_num}${digit}\")\n\
    \    if [ ${num_count} -eq 1 ] ; then\n      int_count=${int_count}${digit}\n\
    \    fi\n  done\n  echo \"${int_count}\"", "    local n count\n    n=$1\n    count=0\n\
    \    while [[ $n -le 9 ]]; do\n        if (( $(echo $n | grep -Eq \"^1\" | wc\
    \ -l) == 0 )) ; then\n            count=$(( count+1 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^10\" | wc -l) == 0 )) ; then\n            count=$(( count+2\
    \ ))\n        elif (( $(echo $n | grep -Eq \"^11\" | wc -l) == 0 )) ; then\n \
    \           count=$(( count+3 ))\n        elif (( $(echo $n | grep -Eq \"^12\"\
    \ | wc -l) == 0 )) ; then\n            count=$(( count+4 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^13\" | wc -l) == 0 )) ; then\n            count=$(( count+5\
    \ ))\n        elif (( $(echo $n | grep -Eq \"^14\" | wc -l) == 0 )) ; then\n \
    \           count=$(( count+6 ))\n        elif (( $(echo $n | grep -Eq \"^15\"\
    \ | wc -l) == 0 )) ; then\n            count=$(( count+7 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^16\" | wc -l) == 0 )) ; then\n            count=$(( count+8\
    \ ))\n        elif (( $(echo $n | grep -Eq \"^17\" | wc -l) == 0 )) ; then\n \
    \           count=$(( count+9 ))\n        fi\n        n=$(( n-1 ))\n    done\n\
    \    printf \"count: %6d\\n\" $count", "\tif [ $1 -eq 0 ]; then exit 0; fi\n\t\
    \n\t# We use 10 to indicate the last digit. e.g. 123 or 234\n\tfor i in `seq 10`;\
    \ do\n\t\t# Start with 1 and end with n\n\t\techo -n $i\n\t\tif [ $i -eq $1 ];\
    \ then\n\t\t\techo \"1\"\n\t\t\tbreak\n\t\telse\n\t\t\tif [ $i -le $1 ]; then\n\
    \t\t\t\tstarts_one_ends $(($i - 1))\n\t\t\tfi\n\t\tfi\n\tdone", "  local n=$1\n\
    \  local output\n  output=$(for ((i=n+1; i <= 9; ++i)); do\n    [ \"${i}\" -eq\
    \ \"1\" -o \"${i}\" -eq \"$i\" ] && return $(( n - i ))\n  done)\n  return $output",
  "    local n=$1\n    local -i cnt=0\n    local i j\n    for (( i=1; i<=$n; i++ ));\
    \ do\n        (( cnt=(cnt+n%i==0))||( cnt+=n -i ))\n    done\n    printf \"$cnt\\\
    n\"", '  echo $(($1%$(($1%10000))+1))', "  n=$1\n  count=0\n  while [ $n -gt 0\
    \ ]\n  do\n    if [ $(( n % 10 )) -eq 1 ] || [ $(( n % 10 )) -eq 2 ] || [ $((\
    \ n % 10 )) -eq 3 ] || [ $(( n % 10 )) -eq 4 ] || [ $(( n % 10 )) -eq 5 ] || [\
    \ $(( n % 10 )) -eq 6 ] || [ $(( n % 10 )) -eq 7 ] || [ $(( n % 10 )) -eq 8 ]\
    \ || [ $(( n % 10 )) -eq 9 ]\n    then\n      (( count++ ))\n    fi\n    n=$((\
    \ n / 10 ))\n  done\n  echo $count", "  case $1 in\n    0) printf \"1\\n\";;\n\
    \    1) printf \"0\\n\";;\n    2) printf \"1\\n\";;\n    *) printf \"%d\\n\" $(starts_one_ends\
    \ $(( $1 * 10 )) );;\n  esac", "  local n=$1\n  # A number with zero digits at\
    \ the start is one too.\n  (( $n )) || return\n  (( $(( $n - 1 )) )) || return\n\
    \  (( $n %% 10 )) || return\n  (( $(( $n - 1 )) )) || return\n  (( $n >= 10 ))\
    \ || return\n  (( $(( $n - 1 )) )) || return\n  (( $(( $n - 2 )) )) || return\n\
    \  (( $(( $n - 3 )) )) || return\n  (( $(( $n - 5 )) )) || return\n  (( $(( $n\
    \ - 7 )) )) || return\n  (( $(( $n - 9 )) )) || return\n  (( $(( $n - 11 )) ))\
    \ || return\n  (( $(( $n - 13 )) )) || return\n  (( $(( $n - 17 )) )) || return\n\
    \  (( $(( $n - 19 )) )) || return\n  (( $(( $n - 21 )) )) || return\n  (( $((\
    \ $n - 23 )) )) || return\n  (( $(( $n - 25 )) )) || return\n  (( $(( $n - 27\
    \ )) )) || return\n  (( $(( $n - 29 )) )) || return\n  (( $(( $n - 31 )) )) ||\
    \ return\n  (( $(( $n - 33 )) )) || return\n  (( $(( $n - 35 )) )) || return\n\
    \  (( $(( $n - 37 )) )) || return\n  (( $(( $n - 39 )) )) || return\n  (( $((\
    \ $n - 41 )) )) || return\n  (( $(( $n - 43 )) )) || return\n  (( $(( $n - 45\
    \ )) )) || return\n  (( $(( $n - 47 )) )) || return\n  (( $(( $n - 49 )) )) ||\
    \ return\n  (( $(( $n - 51 )) )) || return\n  (( $(( $n - 53 )) )) || return\n\
    \  (( $(( $n - 55 )) )) || return\n  (( $(( $n - 57 )) )) || return\n  (( $((\
    \ $n - 59 )) )) || return\n  (( $(( $n - 61 )) )) || return\n  (( $(( $n - 63\
    \ )) )) || return\n  (( $(( $n - 65 )) )) || return\n  (( $(( $n - 67 )) )) ||\
    \ return\n  (( $(( $n - 69 )) )) || return\n  (( $(( $", "    local n\n    for\
    \ n in $1\n    do\n        if [ $n -le 1000 ] && [ $n -ge 0 ]\n        then\n\
    \            start=$(echo \"$n\" | awk '{print substr(\"$n\",1,1)}')\n       \
    \     end=$(echo \"$n\" | awk '{print substr(\"$n\",length($n),1)}')\n       \
    \ fi\n    done", "    local n=$1\n    local count=0\n    for (( i = 0; i < n;\
    \ i++ )); do\n        if (( i % 3 == 0)); then\n            if (( i % 5 == 0));\
    \ then\n                if (( i == 0 )); then\n                    count=$(( count\
    \ + 1 ))\n                else\n                    count=$(( count + 0 ))\n \
    \               fi\n            else\n                if (( i == 0 )); then\n\
    \                    count=$(( count + 0 ))\n                else\n          \
    \          count=$(( count + 1 ))\n                fi\n            fi\n      \
    \  else\n            if (( i % 3 == 0 )); then\n                if (( i % 5 ==\
    \ 0 )); then\n                    if (( i == 0 )); then\n                    \
    \    count=$(( count + 1 ))\n                    else\n                      \
    \  count=$(( count + 0 ))\n                    fi\n                else\n    \
    \                if (( i == 0 )); then\n                        count=$(( count\
    \ + 0 ))\n                    else\n                        count=$(( count +\
    \ 1 ))\n                    fi\n                fi\n            else\n       \
    \         if (( i % 3 == 0 )); then\n                    if (( i % 5 == 0 ));\
    \ then\n                        if (( i == 0 )); then\n                      \
    \      count=$(( count + 1 ))\n                        else\n                \
    \            count=$(( count + 0 ))\n                        fi\n            \
    \        else\n                        if (( i == 0 )); then\n               \
    \             count=$(( count + 0 ))\n                        else\n         \
    \                   count=$(( count + 1 ))\n                        fi\n     \
    \               fi\n                else\n                    if (( i % 5 == 0\
    \ )); then\n                        if (( i == 0 )); then\n                  \
    \          count=$(( count + 1 ))\n                        else\n            \
    \                count=$(( count + 0 ))\n                        fi\n        \
    \            else\n                        if (( i == 0 )); then\n           \
    \                 count=$(( count + 0 ))\n                        else\n     \
    \                       count=$(( count + 1 ))\n                        fi\n \
    \                   fi\n                fi\n            fi\n        fi\n    done",
  "    # Initialize all values to 0\n    local numbers=()\n\n    # If the input is\
    \ non-positive\n    if [ $1 -gt 0 ]; then\n        # Create a loop that iterates\
    \ over all possible values from 1 to n\n        for number in $(seq 1 $1); do\n\
    \            # If the number is odd\n            if [ $number -eq 1 ]; then\n\
    \                # Set is_odd to true\n                is_odd=1\n            #\
    \ Otherwise\n            elif [ $number -eq $((number-1)) ]; then\n          \
    \      # Set is_odd to false\n                is_odd=0\n            # Else (number\
    \ is even)\n            else\n                # Set is_odd to true\n         \
    \       is_odd=1\n                # Add (number) to numbers\n                numbers+=(\
    \ $number )\n            fi\n\n            # If is_odd and number is equal to\
    \ 1\n            if is_odd -eq 1 ] && [ \"$number\" -eq 1 ]; then\n          \
    \      # Increment the count of numbers that start or end with 1\n           \
    \     count=$((count+1))\n            fi\n        done\n    fi\n\n    # Return\
    \ count\n    echo \"$count\"", "    local n=$1\n    local count=0\n    # Loop\
    \ from 1 to n-1, because 1 is 1 digit, 2 is 2 digits, etc.\n    for (( i=1; i\
    \ <= n; i++ )); do\n        # Loop until we hit a number that starts or ends with\
    \ 1.\n        while [ $i -le $n ] && [ $(( $(echo $(( $i % $n )) | bc -l )) |\
    \ bc) -eq 1 ]; do\n            (( count++ ))\n            (( i++ ))\n        done\n\
    \    done\n    echo \"$count\"", "  local n=$1\n  local count=1\n  (( $n )) ||\
    \ return 0\n  while (( $n )); do\n    (( $n == 1 || n % 10 == 1 )) && break ||\
    \ count=$(( $count + 1 ))\n    (( $n % 10 )) && break || n=$(( $n / 10 ))\n  done\n\
    \  echo $count", "  local num_starts_one_ends=$(\n    expr ${1%%-*} + \\\n   \
    \ $(\n      seq ${1}\n      awk '$2 ~ /^1/ {print $1}'\n      echo ${1}\n    )\n\
    \  )", "    local n=\"$1\"\n    local count\n    count=0\n    echo $((n-1) | grep\
    \ -n '^1'\\>)\n    echo $((n) | grep -n '^1'\\<)", "    local n\n    n=$1\n  \
    \  local count\n    local digits\n    digits=()\n    local i\n    for ((i=1; i<n;\
    \ i+=1)); do\n        digits[$i]=$((10#$i))\n        digits[$i]=$((10#$digits[$i]))\n\
    \    done\n    for ((i=1; i<n; i+=1)); do\n        if ((($digits[$i] | cut -c$i)\
    \ == 1)); then\n            ((count+=1))\n        fi\n    done\n    echo \"$count\"",
  "  if (( ! $1 )); then\n    echo \"Usage: starts_one_ends n\" >&2\n    exit 1\n\
    \  fi\n  (( n = $1 ))\n  (( m = $(( (n + 1) * (n + 2) ) ))\n  (( k = ( $n / 2\
    \ ) + 1 ))\n  (( n0 = $n ))\n  (( i0 = 1 ))\n  (( k0 = 1 ))\n  (( z0 = 1 ))\n\
    \  (( d1 = 1 ))\n  (( i1 = 1 ))\n  (( k1 = 1 ))\n  (( z1 = 1 ))\n  (( d2 = 1 ))\n\
    \  (( i2 = 1 ))\n  (( k2 = 1 ))\n  (( z2 = 1 ))\n  (( d3 = 1 ))\n  (( i3 = 1 ))\n\
    \  (( k3 = 1 ))\n  (( z3 = 1 ))\n  (( d4 = 1 ))\n  (( i4 = 1 ))\n  (( k4 = 1 ))\n\
    \  (( z4 = 1 ))\n  (( d5 = 1 ))\n  (( i5 = 1 ))\n  (( k5 = 1 ))\n  (( z5 = 1 ))\n\
    \  (( d6 = 1 ))\n  (( i6 = 1 ))\n  (( k6 = 1 ))\n  (( z6 = 1 ))\n  (( d7 = 1 ))\n\
    \  (( i7 = 1 ))\n  (( k7 = 1 ))\n  (( z7 = 1 ))\n  (( d8 = 1 ))\n  (( i8 = 1 ))\n\
    \  (( k8 = 1 ))\n  (( z8 = 1 ))\n  (( d9 = 1 ))\n  (( i9 = 1 ))\n  (( k9 = 1 ))\n\
    \  (( z9 = 1 ))\n  (( d10 = 1 ))\n  (( i10 = 1 ))\n  (( k10 = 1 ))\n  (( z10 =\
    \ 1 ))\n  (( d11 = 1 ))\n  (( i11 = 1 ))\n  (( k11 = 1 ))\n  (( z11 = 1 ))\n \
    \ (( d12 = 1 ))\n  (( i12 = 1 ))\n  (( k12 = 1 ))\n  (( z12 = 1 ))\n  (( d13 =\
    \ 1 ))\n  (( i13 = 1 ))\n  (( k13 = 1 ))\n  (( z13 = 1 ))\n  ((", "  local -i\
    \ n count\n  n=$1\n  count=0\n  for (( i=1; i<=n; i++ )); do\n    if (( $i % 10\
    \ == 1 && $i > 9 )); then\n      (( count++ ))\n    fi\n    if (( $i % 10 == 0\
    \ && $i > 9 )); then\n      (( count++ ))\n    fi\n  done\n  echo $count", " \
    \   local n count\n    ((count=0))\n    for (( n=1 ; n<$1 ; n++ ))\n    do\n \
    \       if (( ${1:0:n} == 0 ))\n        then\n            (( count+=1 ))\n   \
    \     elif (( ${1:n-1:n} == 1 ))\n        then\n            (( count+=1 ))\n \
    \       fi\n    done\n    echo $count", "    local n count\n    for n in $*; do\n\
    \        if [[ $n -eq 0 ]]; then\n            continue\n        fi\n        if\
    \ [[ $(( $n % 10 )) -eq 1 ]]; then\n            (( count += 1 ))\n        fi\n\
    \    done\n    echo \"$count\"", "    local N=$1\n    local -a S\n    local Slen\n\
    \    local e\n    local p\n    local t\n    local starts\n    local ends\n   \
    \ local s\n    local -e\n    local p\n    local -a x\n    local t\n    local s\n\
    \    local -e\n    local -a x\n    local s\n    local e\n    local p\n    local\
    \ -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local e\n\
    \    local p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local\
    \ s\n    local e\n    local p\n    local -a x\n    local s\n    local -e\n   \
    \ local -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local\
    \ e\n    local p\n    local -a x\n    local s\n    local -e\n    local -a x\n\
    \    local s\n    local -e\n    local -a x\n    local s\n    local e\n    local\
    \ p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local s\n\
    \    local -e\n    local -a x\n    local s\n    local e\n    local p\n    local\
    \ -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local -e\n\
    \    local -a x\n    local s\n    local e\n    local p\n    local -a x\n    local\
    \ s\n    local -e\n    local -a x\n    local s\n    local -e\n    local -a x\n\
    \    local s\n    local e\n    local p\n    local -a x\n    local s\n    local\
    \ -e\n    local -a x\n    local s\n    local -e\n    local -a x\n    local s\n\
    \    local e\n    local p\n    local -a x\n    local s\n    local -e\n    local\
    \ -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local e\n\
    \    local p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local\
    \ s\n    local -e\n    local -a x\n    local s\n    ", "  local n=\"$1\"\n  local\
    \ result\n  result=\"$(echo \"${n}\" | wc -w)\"\n  printf \"$result\\n\"", " \
    \ starts=0\n  for i in $(seq 1 1 $1); do\n    starts=$(expr ${starts}+${i})\n\
    \  done\n  for i in $(seq ${1} 1 $1); do\n    count=$( expr ${count} - $starts\
    \ )\n  done\n  echo $count", "   local N=$1\n   for (( i=1; i<=N; i++ ))\n   do\n\
    \      [[ \"$i\" = 1 ]] && { n=$(( n - 1 )); break; }\n      [[ \"$i\" = N ]]\
    \ && { n=$(( n + 1 )); break; }\n   done", "  local count\n  (( count=0; n=${1#}\
    \ ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n \
    \ (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  ((", "    local n val\n    n=$1\n    if [ $n -eq 0 ]; then\n        return\
    \ 0\n    fi\n    local -a nums\n    local nc start end\n    local i tmp len\n\
    \    nums=()\n    for ((i = 0; i < $n; i++)); do\n        ((i++))\n        num=$(printf\
    \ \"%05d\" $i)\n        val=${num//./}\n        start=$(echo $val |cut -c -10)\n\
    \        end=$(echo $val |cut -c -${#start})\n        nc=$((end - start))\n  \
    \      if [ $start -eq 1 ] && [ $end -eq 1 ]; then\n            ((nc++))\n   \
    \     elif [ $start -eq 0 ] && [ $end -eq 0 ]; then\n            ((nc++))\n  \
    \      elif [ $start -eq 1 ] && [ $end -eq 0 ]; then\n            ((nc++))\n \
    \       elif [ $start -eq 0 ] && [ $end -eq 1 ]; then\n            ((nc++))\n\
    \        fi\n        nums+=($nc)\n    done\n    len=$(echo $n | wc -w)\n    for\
    \ i in $(seq 0 $((len-1)); do\n        tmp=$(( ${nums[$i]} % 2 ))\n        if\
    \ [ $tmp -eq 1 ]; then\n            (( ${nums[$i]}++ ))\n        fi\n    done\n\
    \    echo $nums", "  # Input validation\n  [[ -z \"$1\" ]] && echo \"Invalid input\
    \ given for $0\" && exit 1\n  [[ -z \"$2\" ]] && echo \"Invalid input given for\
    \ $0\" && exit 1\n  [[ $1 =~ ^-?[0-9]+$ ]] || echo \"Invalid input given for $0\"\
    \ && exit 1\n  [[ $2 =~ ^-?[0-9]+$ ]] || echo \"Invalid input given for $0\" &&\
    \ exit 1\n\n  # The algorithm\n  local starts_one_ends=$(\n    local i=1\n   \
    \ local result=0\n    local count=0\n    while [ $i -le $1 ]; do\n      [ $((\
    \ (10#$i)%$2 )) -eq 0 ] || { count=$(( (count+2)%9 )); result=$(( $result + (((10#$count)%$2)\
    \ )); break; }\n      i=$(( $i + 1 ))\n    done\n    $result\n  )", "  if [[ $1\
    \ -eq 1 ]]; then\n    return 1\n  fi\n  local n=\"$1\"\n  local s=0\n  local e\n\
    \  for (( i = 1 ; i < n ; i++ )); do\n    e=\"$(\n      local x=\"$i\"\n     \
    \ while (( $x / 10 )); do\n        (( x += $i % 10 ))\n        (( s += 1 ))\n\
    \      done\n      (( x -= $i % 10 ))\n      (( s += 1 ))\n    )\"\n    if [[\
    \ $x -eq 1 ]]; then\n      (( s += 1 ))\n    fi\n  done\n  return $s", "  if [[\
    \ $1 -eq 0 ]] ; then\n    return 0\n  fi\n  local count=0\n  local n=$1\n  local\
    \ current\n  local previous\n  while true ; do\n    current=$(( (n / 10) + 1 ))\n\
    \    previous=$(( (previous + 10) % 10 ))\n    if [[ $previous -eq 1 ]] ; then\n\
    \      count=$(expr $count + 1)\n    fi\n    if [[ $current -eq 10 ]] ; then\n\
    \      break\n    fi\n    n=$n%10\n  done\n  echo $count", "        local n\n\
    \        n=$1\n        local count\n\n        count=`expr $n \\* $n`\n       \
    \ local i\n\n        for ((i=0; i<=$(( ($count-1) / 2 )); i++)); do\n        \
    \        if [ $(( $n % $i )) -ne 0 ]; then\n                        count=$((\
    \ $count - 1 ))\n                fi\n        done\n        echo $count", "  if\
    \ [ \"$1\" -eq 0 ]\n  then\n    echo \"0 1 2 3 4 5 6 7 8 9\"\n    return\n  fi\n\
    \n  local start=1\n  local end=$1\n  local counter=1\n\n  while [ \"$start\" -le\
    \ \"$end\" ]\n  do\n    echo -n \"${counter}. \"$start\n    local test_str=\"\
    $(printf \"%0${1}d\" \"$start\")\"\n    if [ \"$test_str\" = \"1\" ]\n    then\n\
    \      counter=$(( counter + 1 ))\n    fi\n    start=$(( start + 1 ))\n  done\n\
    \n  echo -n \"${counter}. \"", "  local n=\"$1\"\n  shift\n  local count=0\n \
    \ while (( \"$#\" )); do\n    local c=$1\n    shift\n    (( c==1 )) && break\n\
    \    (( c==$n )) && count=\"$count$count\"\n  done\n  echo $(( $count ))", " \
    \ local x=\"$1\"\n  local count=0;\n  while [ \"$x\" -le 9 ]; do\n    (( count++))\n\
    \    (( x *= 10 ))\n  done\n  (( count++ ))\n  while [ \"$x\" -gt 0 ]; do\n  \
    \  (( count-- ))\n    (( x *= 10 ))\n  done\n  echo \"$count\"", "  declare -r\
    \ n=\"$1\"\n  ((n > 0)) || { printf '%s\\n' \"n must be positive\" && return 1;\
    \ }\n  local n=\"$1\"\n  (( n == 0 )) || { printf '%s\\n' \"n must be non-zero\"\
    \ && return 1; }\n\n  local -a counts\n  counts=()\n  local -r last=$(( (n - 1)\
    \ * 10 + 1 ))\n  counts[last]=0\n\n  for (( i = 1; i <= n; i += 10 )); do\n  \
    \  local -r last=$(( i * 10 ))\n    (( counts[last] += 1 ))\n  done\n  printf\
    \ '%s\\n' \"${counts[*]}\"", "\tlocal count=0\n\tlocal digit=$1\n\tlocal factor=1\n\
    \tlocal i\n\twhile [ \"$factor\" -le \"$digit\" ] ; do\n\t\t(( factor *= 10 ))\n\
    \t\t(( count++ ))\n\tdone\n\t(( digit -= 1 ))\n\t(( count++ ))\n\tfor (( i=digit+1\
    \ ; i <= $#1 ; i++ )); do\n\t\tif [[ $1 == $i ]] ; then\n\t\t\t(( count-- ))\n\
    \t\t\tbreak\n\t\tfi\n\tdone\n\techo \"$count\"", "  local -a nums\n  local -i\
    \ start end\n\n  local num\n  local -i one_count zero_count\n\n  start=1\n  end=$(printf\
    \ \"%$1\" \"$1\")\n  (( end -= 1 ))\n  while (( \"$start\" <= \"$end\" )) {\n\
    \    num=$(printf \"%$1\" \"$start\")\n    (( nums[$num]++ ))\n    (( start =\
    \ start + 1 ))\n  }\n  num=$(printf \"%$1\" \"$end\")\n  (( nums[$num]++ ))\n\
    \  (( end = end - 1 ))\n  while (( \"$start\" <= \"$end\" )) {\n    num=$(printf\
    \ \"%$1\" \"$start\")\n    (( nums[$num]++ ))\n    (( start = start + 1 ))\n \
    \ }\n\n  one_count=0\n  zero_count=0\n  for (( i = 0; i < ${#nums[@]}; i++ ));\
    \ do\n    if (( nums[$i] == 1 )); then\n      (( one_count++ ))\n    elif (( nums[$i]\
    \ == 0 )); then\n      (( zero_count++ ))\n    fi\n  done\n\n  echo \"$one_count\"\
    \n  echo \"$zero_count\"", "    local n x\n    printf -v n \"$1\" && n=$(($n +\
    \ 1))\n    local s=$(printf \"%4d\" 1)\n    local e=$(printf \"%4d\" $((n)));\
    \ let \"e=$e+$(($(($n%5)+5))))\"\n    echo -n \"$s\"\n    local i=1\n    while\
    \ [ $i -le $e ] ; do\n        echo -n \".$((i+1))\"\n        i=$(expr \"$i\" +\
    \ 1)\n    done\n    echo -n \"$e\"", "  local n=$1\n  local a\n  local count\n\
    \  local digit\n  a=($(for ((digit=3; digit<=n; digit+=2)); do\n    echo -n \"\
    1\"\n  done))\n  count=0\n  while ((a[n-1] -lt 10)); do\n    ((count+=$a[n-1]))\n\
    \    ((n--))\n  done\n  echo \"${count}\"", "  if [ $1 -lt 1 ]; then\n    echo\
    \ \"Usage: starts_one_ends n\"\n    exit 1\n  fi\n\n  # count the number of n-1\
    \ digit positive integers that end with 1\n  echo \"$(( $(printf \"%.0s\" {1..$1}\
    \ | wc -c ) - 1 ))\"", "        [ $# -ne 1 ] && echo \"Not enough arguments.\"\
    \ && exit 1\n        local n=\"$1\"\n        local count=0\n        local i\n\
    \        local j\n        local m\n        for (( i=1; i<=n; i++ )); do\n    \
    \            if (( n % i == 0 )); then\n                        m=($(( n/i )))\n\
    \                        if (( $m == 1 )); then\n                            \
    \    if (( $i == 0 )); then\n                                        (( count++\
    \ ))\n                                else\n                                 \
    \       (( count--, count++ ))\n                                fi\n         \
    \               else\n                                (( count-- ))\n        \
    \                fi\n                fi\n        done\n        echo \"$count\"",
  "  local i n=$1\n  local start end\n  local zeroes ones\n  local ret=0\n  local\
    \ digits=0\n\n  i=2\n  while [ $i -le $n ]; do\n    start=$(expr $i / 10)\n  \
    \  end=$(expr $i % 10)\n    if (( $start == 1 )); then\n      (( ones++ ))\n \
    \     if (( $end == 0 )); then\n        (( zeroes += 1 ))\n      else\n      \
    \  (( zeroes ))\n      fi\n    fi\n    i=$(( $i + 1 ))\n  done\n\n  # print number\
    \ of possible combinations for number of digits\n  # if zeroes == ones == 2, this\
    \ number is trivially 2\n  if [ $zeroes == $ones ] && [ $zeroes == 2 ]; then\n\
    \    echo 2\n    return\n  fi\n\n  # if zeroes == ones == 3, this number is trivially\
    \ 3\n  if [ $zeroes == $ones ] && [ $zeroes == 3 ]; then\n    echo 3\n    return\n\
    \  fi\n\n  # for larger numbers, it is obviously not possible to have a count\
    \ of\n  # numbers that start or end with 1 without having a combination of two\n\
    \  # digits that ends in either 1 or 0\n  echo \"not possible\"\n  return", " \
    \ local n=$1\n  local start\n  local end\n  local count\n\n  count=$(expr $( (\
    \ ( $(expr $( ( ( $(expr $(expr ${n} + 1) - 1 ) / ${n} )) * ${n} - 1 ) / ${n}\
    \ ) + 1 ) / ${n} )\n\n  printf \"$count\\n\"", "  local n b\n  ((n=$1))\n  ((b=$((n-1))))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n", "    local n count\n\
    \    n=$1\n    count=0\n    while [ $n -gt 0 ]; do\n        [ $((n % 10)) -eq\
    \ 1 ] && count=$(($count + 1))\n        (( n = $((n/ 10)))\n    done\n    echo\
    \ \"$count\"", "  local n i c ret\n  n=$1\n  shift\n  while (( $# > 0 )); do\n\
    \    i=$(( $n - 1 ))\n    c=$(( $i + 1 ))\n    (( n >= i && n >= c ))\n    ((\
    \ n > c ))\n    (( n <= i ))\n    (( n <= c ))\n    (( ! ( (n == i) || (n == c)\
    \ ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n    (( ! ( (n == c) ) ))\n    ((\
    \ ! ( (n == i) || (n == c) ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n    ((\
    \ ! ( (n == c) && (n == i) ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n    ((\
    \ ! ( (n == c) && (n == i) ) ))\n    (( n == 3 ))\n    (( n == 4 ))\n    (( n\
    \ == 5 ))\n    (( n == 6 ))\n    (( n == 7 ))\n    (( n == 8 ))\n    (( n == 9\
    \ && $1 ))\n    (( n == 10 ))\n    (( n == 11 && $1 ))\n    (( n == 12 ))\n  \
    \  (( n == 13 ))\n    (( n == 14 && $1 ))\n    (( n == 15 ))\n    (( n == 16 ))\n\
    \    (( n == 17 && $1 ))\n    (( n == 18 ))\n    (( n == 19 && $1 ))\n    (( n\
    \ == 20 ))\n    (( n == 21 && $1 ))\n    (( n == 22 && $1 ))\n    (( n == 23 ))\n\
    \    (( n == 24 && $1 ))\n    (( n == 25 && $1 ))\n    (( n == 26 && $1 ))\n \
    \   (( n == 27 && $1 ))\n    (( n == 28 && $1 ))\n    (( n == 29 && $1 ))\n  \
    \  (( n == 30 ))\n    (( n == 31 && $1 ))\n    (( n == 32 && $1 ))\n    (( n ==\
    \ 33 ))\n    (( n == 34 && $1 ))\n    (( n == 35 ))\n    (( n == 36 && $1 ))\n\
    \    (( n == 37 ))\n    (( n == 38 && $1 ))\n    (( n == 39 ))\n    (( n == 40\
    \ ))\n    (( n == 41 && $1 ))\n    (( n == 42 && $1 ))\n    (( n == 43))\n   \
    \ (( n == 44 ))\n    (( n == 45 && $1 ))\n    (( n == 46 ))\n    ((", "  echo\
    \ \"$1\" | awk '{print length($1)}' | sort -n | uniq -c | sed -n '/^1$/,/1$/p'",
  "  local n=\"$1\"\n  local numbers=()\n  local number\n  for number in {1..$n};\
    \ do\n    if [ $number -eq 1 ]; then\n      numbers+=(\"$number\")\n    fi\n \
    \ done\n  echo \"${#numbers[@]}\"", "  local n\n  n=$1\n  if (( n < 10 )); then\n\
    \    echo 'starts_one_ends: n must be in range 0...9.'\n    return\n  fi\n  local\
    \ ndigits\n  ndigits=$(( $n - 1 ))\n  local count=0\n  local i\n  for i in $(seq\
    \ 1 $ndigits); do\n    if (( 10#$i == 1 )); then\n      (( count++ ))\n    fi\n\
    \  done\n  echo $count", "  echo \"$1\"\n  echo \"$1\"\n  echo \"$1\"\n  echo\
    \ \"$1\"\n  echo \"$1\"", "  local -r n=\"$1\"\n\n  (( n > 0 )); then\n    local\
    \ -r count=0\n\n    # Count how many n digit numbers in [0, n] start with 1.\n\
    \    while (( n /= 10 )); do\n      # Add one if n % 10 is 1.\n      if (( n %\
    \ 10 == 1 )); then\n        count=$(( count+1 ))\n      fi\n    done\n\n    #\
    \ Count how many n digit numbers in [0, n] end with 1.\n    for (( i=0; i < n-1;\
    \ i++ )); do\n      (( n /= 10 ))\n      if (( n % 10 == 1 )); then\n        count=$((\
    \ count+1 ))\n      fi\n    done\n  fi\n\n  echo \"$count\"", "  if [ ! $1 -ge\
    \ 0 ] || [ ! $1 -le 2147483647 ]; then\n    echo \"Usage: $0 INTEGER\"\n    return\
    \ 1\n  fi\n  local N=$1\n  local NUM=0\n  local N=1\n  while [ $N -lt $1 ]\n \
    \ do\n    ((N+=1))\n    if [ $N -ge 10 ]; then\n      NUM=$((NUM*10+$N))\n   \
    \ elif [ $N -le 0 ]; then\n      NUM=$((NUM*10+$N))\n    elif [ $N -eq 1 ]; then\n\
    \      NUM=$((NUM+1))\n    fi\n  done\n  echo $NUM", "  local starts=$1\n  local\
    \ ends=$2\n  local total=0\n  local count=0\n  local digits=$(( (ends/10) + 1\
    \ ))\n  local i=1\n  while (( i <= ends )) ; do\n    if (( starts == 1 )) ; then\n\
    \      count=$(( starts + count ))\n      break\n    fi\n    (( i++ ))\n    starts=$((\
    \ $starts - 10 ))\n  ends=$(( $ends - 10 ))\n  echo -n \"$count\"\n  (( total\
    \ += count ))\n  echo -n \"$total\"\n  echo $total", "  local n=$1\n  printf \"\
    starts_one_ends called\"\n  if (( n < 1 )); then\n    return 0\n  fi\n  local\
    \ count=0\n  local p\n  for (( p=2; p<=9; p++ )); do\n    if (( p == n )); then\n\
    \      count=$count+1\n    fi\n    if (( p == n-1 )); then\n      count=$count+1\n\
    \    fi\n  done\n  return $count", "    local n=$1\n    echo \"$(( $n + 1 ))\"\
    \n    if [ ! \"$n\" -eq \"1\" ]; then\n        echo \"$(( $n - 1 ))\"\n    fi",
  "  local n=$1\n  local count=0\n  local last=$(( 10**(n-1) - 1 ))\n  while [[ $n\
    \ -gt 0 ]]; do\n    [ $(( n%10 )) -eq 1 ] || break\n    (( count++ ))\n    n=$((\
    \ n/10 ))\n  done\n  echo ${count}", "  n=$1\n  starts_one_ends_sum=0\n  n=$((n-1))\n\
    \  while [ $n -gt 0 ]; do\n    if [ ${n} == 0 ]; then\n      starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      n=$((n-1))\n    else\n      starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      if [ ${n} == 1 ]; then\n        n=$((n-1))\n        starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      fi\n    fi\n  done", "  local n=$1\n  # return 0 when the number is too\
    \ big\n  (( n > 9 && n < 100 )) || return 0\n  # return 0 when the number is negative\n\
    \  (( n < 0 )) || return 0\n  local count=0\n  # loop through the digits\n  local\
    \ digit\n  while (( n > 0 )); do\n    # get the last digit\n    digit=$(( n %\
    \ 10 ))\n    (( n /= 10 ))\n    # if the last digit is 1 or 0, increment the counter\n\
    \    (( digit == 1 || digit == 0 )) && count=$(( count + 1 ))\n  done\n  # return\
    \ the count\n  return $count", "    local n=$1\n    local result\n\n    # Count\
    \ all positive integers with at least n digits and that do not\n    # start or\
    \ end with 1\n    local start=$(seq -f \"%08g\" 0 $((n-1)) )\n    local end=$(seq\
    \ -f \"%08g\" 1 $n | tail -n 1)\n    result=( $(echo $start | grep -v 1 ) && echo\
    \ 0 || echo 0 )\n\n    # Count all positive integers with at least n digits and\
    \ that do not\n    # start or end with 1\n    local start1=$(seq -f \"%08g\" 0\
    \ $((n-1)) )\n    local end1=$(seq -f \"%08g\" 1 $n | tail -n 1)\n    result=(\
    \ $result && echo 0 || echo 0 )\n\n    # Count the remaining positive integers\
    \ with at least n digits\n    result=( $result && echo 1 || echo 0 )\n    # Add\
    \ the counts\n    result=( $( IFS=$'\\n' printf \"%s\\n\" \"${result[@]}\" ) |\
    \ tr ' ' '\\n' | paste -s -d '\\n' ) \n    # Convert to a string\n    result=$(\
    \ printf \"%s\\n\" ${result[@]} | sed 's/^[ \\t]*//;s/[ \\t]*$//;s/^0*//;s/1//;s/^1//'\
    \ )\n    # Remove leading 0s\n    result=$( printf \"%s\\n\" ${result[@]} | sed\
    \ 's/^0*//' )\n    # Remove leading 1\n    result=$( printf \"%s\\n\" ${result[@]}\
    \ | sed 's/^1//' )\n\n    # Return the result\n    echo $result", "  if [ $1 -eq\
    \ 0 ] ; then\n    echo 1\n    return 0\n  else\n    [ $1 -le 1000000000 ] &&\n\
    \      starts_one_ends $(( $1 / 101 )) &&\n      starts_one_ends $(( $1 % 101\
    \ ))\n  fi", "  local start\n  local end\n\n  start=1\n  end=${1}\n  while [ \"\
    $start\" -le \"$end\" ]\n  do\n    if [[ $(( \"${start}\" )) -eq 1 ]]\n    then\n\
    \      (( start++ ))\n    fi\n\n    if [[ $(( \"${end}\" )) -eq $(( \"${start}\"\
    \ )) ]]\n    then\n      (( end-- ))\n    fi\n\n    (( end - start ))\n  done",
  "  n=$1\n  ns=$(echo $n | sed 's/^\\./& /;s/\\./& /;s/^&\\./& /;s/\\.$//;')\n  ones=$(echo\
    \ $n | sed 's/^\\./& /;s/\\./& /;s/^&\\./& /;s/\\.$//;')\n  echo \"$((${#ns}/2))\"",
  "  local n=$1\n  local count=$(echo $((${n}+${n}-1) % ${n}*9)) ;\n  if [ $count\
    \ -gt 0 ] ; then\n    echo ${count} ;\n  else\n    echo 0 ;\n  fi", "    # $1\
    \ is a positive integer\n    if [ $1 -eq 1 ] ; then\n        return 1\n    fi\n\
    \n    # Return 0 if the argument is nonpositive\n    if [ $1 -eq 0 ] ; then\n\
    \        return 0\n    fi\n\n    # Store the digit count in $count\n    count=$(expr\
    \ ${1} \\* ${10})\n    local i\n\n    # Loop until $count is 0 or 1 to avoid infinite\
    \ loops\n    while [ $count -gt 1 ] ; do\n        # Store the remainder in $rem\n\
    \        rem=$(expr ${1} \\% ${10})\n\n        # If the remainder is 0, add it\
    \ to the count\n        if [ \"${rem}\" -eq 0 ] ; then\n            count=$((\
    \ ${count} + 1 ))\n            continue\n        fi\n\n        # If we got here,\
    \ increment the count by 2 and decrement the reminder\n        count=$(( ${count}\
    \ + 2 ))\n        rem=$(expr ${rem} - 1 )\n\n        # Add the remainder to the\
    \ count\n        count=$(( ${count} + 1 ))\n\n        # Exit the loop if we added\
    \ a digit\n        if [ $count -gt 1 ] ; then\n            break\n        fi\n\
    \    done\n\n    return $count", "    local starts_one_ends_result\n    starts_one_ends_result=0\n\
    \    for (( i = 0; i < $1; i++ ))\n    do\n        (( n % 10 ))\n        if [[\
    \ ${starts_one_ends_result} -gt 0 ]]; then\n            starts_one_ends_result=$((\
    \ $starts_one_ends_result + 1 ))\n        fi\n        (( n = n / 10 ))\n    done\n\
    \    return $starts_one_ends_result", "  local n=$1\n  local count=0\n  (( n %\
    \ 2 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 100 != 0 )) &&\
    \ count++\n  (( n % 100 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n \
    \ (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && ", "\tif [ \"$1\" -lt\
    \ 1 ]; then\n\t\techo \"Illegal argument: $1\"\n\t\texit 1\n\tfi\n\n\tlocal n=$1\n\
    \tlocal count=0\n\tlocal last_non_one\n\tlocal last_non_one_pos\n\tlocal last_non_one_neg\n\
    \tlocal first_one\n\tlocal first_one_pos\n\tlocal first_one_neg\n\tlocal pos_ends_one_neg\n\
    \tlocal neg_ends_one_pos\n\tlocal i\n\n\tfor i in {1..n}; do\n\t\tfirst_one=`expr\
    \ $i + 1`\n\t\tfirst_one_pos=`expr $i + 1`\n\t\tfirst_one_neg=`expr $i - 1`\n\t\
    \tpos_ends_one_neg=`expr $first_one - 1`\n\t\tneg_ends_one_pos=`expr $first_one_pos\
    \ - 1`\n\t\tif [ $first_one -eq 1 ]; then\n\t\t\tif [ $first_one_pos -eq 1 ];\
    \ then\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\telif [ $first_one_neg -eq 1 ];\
    \ then\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\tfi\n\t\tfi\n\t\tif [ $first_one_neg\
    \ -eq 1 ]; then\n\t\t\tif [ $first_one_pos -eq 1 ]; then\n\t\t\t\tcount=$(( $count\
    \ + 1 ))\n\t\t\telif [ $pos_ends_one_neg -eq 1 ]; then\n\t\t\t\tcount=$(( $count\
    \ + 1 ))\n\t\t\telif [ $neg_ends_one_pos -eq 1 ]; then\n\t\t\t\tcount=$(( $count\
    \ + 1 ))\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"$count\"", "  if (( $# != 1 )); then\n\
    \    echo \"usage: starts_one_ends [number]\"\n    exit 1\n  fi\n  local number=$1\n\
    \  local count=0\n  while (( $number > 0 )); do\n    if (( $number % 10 == 1 ));\
    \ then\n      (( count++ ))\n    fi\n    number=$(( $number / 10 ))\n  done\n\
    \  echo $count", "  local i ret=0\n  local n digit\n  for i in $(seq $1)\n  do\n\
    \    digit=$(printf %02d $i)\n    if [ $digit -eq 1 ]\n    then\n      ((ret++))\n\
    \    fi\n  done\n  echo $ret", "  n=$1\n  nums=$(seq 1 $n)\n  ones=$(echo $nums\
    \ | grep -Eo '[1-9][0-9]*$')\n  tail=$(( $(expr $n - ${#ones}) ))\n  echo $tail",
  "    local NUM=\"${1}\"\n\n    # Convert to base-10.\n    local BASE10=\"${NUM}\"\
    \n    echo \"$((10#$BASE10 - 1))\"", "  local n=$1\n  local counter=0\n  local\
    \ i\n  for i in $(seq -f \"%0${n}d\" 1 $((100*n))); do\n    if (( $i | egrep \"\
    ^1$|^$((100*(n-1)))$\" )) ; then\n      (( counter+=1 ))\n    fi\n  done\n  echo\
    \ $(( $counter ))", "  local -i count\n  local -i number\n  local -r count\n\n\
    \  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"${FUNCNAME[0]}: ${1:-Missing integer}\"\
    \ 1>&2\n    return 1\n  fi\n\n  local -r count=$(( ${1%-*}-1 ))\n  number=$((\
    \ $1 ))\n  local i\n  while (( ${number} > 9 )); do\n    (( ${count} += 1 ))\n\
    \    number=$(( $number / 10 ))\n  done\n\n  local -r last=$(( ${number} + 1 ))\n\
    \  for i in $(seq 0 $(( $count + 1 ))); do\n    if (( ${last} == ${number} ));\
    \ then\n      (( ${count} += 1 ))\n    fi\n    number=$(( $number - 10 ))\n  done\n\
    \n  echo \"$count\"", "  if [ \"$1\" = \"--help\" ] || [ \"$1\" = \"-h\" ] ||\
    \ [ \"$1\" = \"-?\" ] || [ \"$1\" = \"help\" ]; then\n    echo \"Usage: starts_one_ends\
    \ <n>\"\n    echo \"  <n> is an integer\"\n    echo \"Returns: count of n-digit\
    \ positive integers that start or end with 1\"\n  else\n    local n=$1\n    echo\
    \ \"$(( $(nproc) > 1 )) starts_one_ends $n started\"\n    local count=0\n    for\
    \ (( i=1; i<=n; i++ )); do\n      for (( j=i; j>0; j-- )); do\n        if [ $(expr\
    \ $i - $j) = 1 ]; then\n          count=$(( $count + 1 ))\n        fi\n      done\n\
    \    done\n    echo \"$(( $count )) starts_one_ends $n ended\"\n    echo \"$((\
    \ $count )) starts_one_ends $n ended\"\n  fi", "    local n=\"$1\"\n    local\
    \ count=0\n    while [ -n \"$n\" ]; do\n        (( n /= 10)) && count=$(($count\
    \ + 1))\n    done\n    echo \"$count\"", "  local n=\"$1\"\n  local one\n  local\
    \ one_count\n  local two_ones\n  local two_ones_count\n  local three_count\n \
    \ local three_ones\n  local three_ones_count\n  local four_count\n  local four_ones\n\
    \  local four_ones_count\n  local five_count\n  local five_ones\n  local five_ones_count\n\
    \  local nine_count\n  local nine_ones\n  local nine_ones_count\n  local ten_count\n\
    \  local ten_ones\n  local ten_ones_count\n  local fifteen_count\n  local fifteen_ones\n\
    \  local fifteen_ones_count\n  local twenty_count\n  local twenty_ones\n  local\
    \ twenty_ones_count\n  local hundred_count\n  local hundred_ones\n  local hundred_ones_count\n\
    \  local thousand_count\n  local thousand_ones\n  local thousand_ones_count\n\
    \  local thousand_ten_count\n  local thousand_ten_ones\n  local thousand_ten_ones_count\n\
    \  local million_count\n  local million_ones\n  local million_ones_count\n  local\
    \ billion_count\n  local billion_ones\n  local billion_ones_count\n  local billion_ten_count\n\
    \  local billion_ten_ones\n  local billion_ten_ones_count\n  local trillion_count\n\
    \  local trillion_ones\n  local trillion_ones_count\n  local trillion_ten_count\n\
    \  local trillion_ten_ones\n  local trillion_ten_ones_count\n  local quadrillion_count\n\
    \  local quadrillion_ones\n  local quadrillion_ones_count\n  local quadrillion_ten_count\n\
    \  local quadrillion_ten_ones\n  local quadrillion_ten_ones_count\n  local quintillion_count\n\
    \  local quintillion_ones\n  local quintillion_ones_count\n  local quintillion_ten_count\n\
    \  local quintillion_ten_ones\n  local quintillion_ten_ones_count\n  local sextillion_count\n\
    \  local sextillion_ones\n  local sextillion_ones_count\n  local ", "  local n=$1\n\
    \  local x\n  ((n--)); local result=0\n  while ((n>0)); do\n    x=$(expr $n /\
    \ 10)\n    ((n%=10)) && result=$((result+$x))\n    ((n--))\n  done\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$", "    if\
    \ [ $1 -lt 1 ]; then\n        echo \"starts_one_ends: ERROR: Invalid integer $1\"\
    \n        return 1\n    fi\n    local starts=$(( ($1-1) % 10 ))\n    local ends=$((\
    \ ($1-1) / 10  ))\n    local zeros=$(( ($1-1) % 100 ))\n    local ones=$(( starts\
    \ + ends + zeros))\n    local count=$(( starts + ends + zeros + ones))\n    echo\
    \ \"starts_one_ends: $starts $ends $zeros $ones $count\"\n    return 0", "   \
    \ local n=\"$1\"\n    if [[ $n -lt 1 ]]\n    then\n        return 1\n    fi\n\
    \    local count=0\n    while [[ $n -gt 1 ]]\n    do\n        if [[ $((n % 10))\
    \ -eq 1 ]]\n        then\n            ((count++))\n        fi\n        n=$(( n\
    \ / 10 ))\n    done\n    return $count", "    local n=$1\n    local count\n  \
    \  local prefixes\n    local suffixes\n    local a\n    local b\n\n    count=0\n\
    \    prefixes=$(awk -v PREFIXES=\"$n\" '{ for (i = 2; i <= $1; i++)\n        for\
    \ (j = i - 1; j >= 0; j--)\n            if ($i % $j == 0) {\n                prefixes=$j\n\
    \                break\n            }\n        }\n        print prefixes\n   \
    \ }')\n\n    suffixes=$(awk -v PREFIXES=\"$n\" '{ for (i = 2; i <= $1; i++)\n\
    \        for (j = i; j < $1; j++)\n            if ($i % $j == 0) {\n         \
    \       suffixes=$j\n                break\n            }\n        }\n       \
    \ print suffixes\n    }')\n\n    for ((a=1; a <= $prefixes; a++))\n    do\n  \
    \      for ((b=$(a); b >= 1; b--))\n        do\n            count=$((count+1))\n\
    \        done\n    done\n\n    for ((a=$(a-1); a >= 1; a--))\n    do\n       \
    \ for ((b=$(a); b >= 1; b--))\n        do\n            count=$((count+1))\n  \
    \      done\n    done\n\n    echo $count", "    local i=$1\n    local n=$2\n \
    \   # Print all the numbers from $n to $n to STDOUT.\n    # Count all such numbers.\n\
    \    for ((j=$n; j>0; j--)) do\n        echo $j\n        count=$((count + $(cd\
    \ ./${i}/ > /dev/null && cd ../../${i}/ && echo `expr $j + $(cd ../${i}/ > /dev/null\
    \ && cd ../../${i}/ && echo `expr $j - 1)`)))\n    done\n    # Print the last\
    \ number if $n is odd and $n is even.\n    if [ $(( $n % 2 )) -ne 0 ]; then\n\
    \        echo $n\n        count=$((count + $n))\n    fi\n    return $count", " \
    \   local n=$1\n    local i\n    local result\n    if [[ $n -lt 10 ]]; then\n\
    \        result=1\n        for i in $(seq $n -1 -1 -1); do\n            result=$(($result\
    \ + $(expr ${i} % 10 == 1)))\n        done\n    elif [[ $n -gt 10 ]]; then\n \
    \       result=$(expr $(expr ${n} % 10) + 1)\n    else\n        echo \"Error:\
    \ n is too large.\"\n    fi\n    echo $result", "  local num_args=$#\n  local\
    \ num_args=$((num_args > 0 ? num_args : 1))\n  local i\n  local length=\"${1:-${num_args}}\"\
    \n  local start\n  local end\n  local count\n  local number_to_count\n  local\
    \ number_found\n  local number_not_found\n  local digits\n  local n\n\n  # If\
    \ no length is specified, default to $num_args.\n  case ${num_args} in\n    1)\n\
    \      number_to_count=${1}\n      (( num_args = 2 ))\n      ;;\n    *)\n    \
    \  number_to_count=${num_args}\n      (( num_args = 1 ))\n      ;;\n  esac\n\n\
    \  (( num_args = $num_args - 1 ))\n\n  # Set the \"found\" flag.\n  number_found=0\n\
    \  number_not_found=0\n\n  while [[ $number_to_count -ne 0 ]]; do\n    # Grab\
    \ the next number.\n    (( number_to_count -= 1 ))\n    number_found=1\n    number_not_found=0\n\
    \    (( i = 1 ))\n\n    # Loop until we find one that starts with 1.\n    while\
    \ [[ $(( i * 10 )) -lt $(( length - 1 )) ]]; do\n      # Make sure we don't go\
    \ past the end.\n      if [[ $(( i * 10 )) -gt $(( length - 1 )) ]]; then\n  \
    \      break\n      fi\n      # Make sure we haven't already found this number.\n\
    \      if [[ $(( number_found )) == 0 ]]; then\n        (( number_found = 1 ))\n\
    \        break\n      fi\n      (( i++ ))\n    done\n    # Make sure we haven't\
    \ already found this number.\n    if [[ $(( number_found )) == 0 ]]; then\n  \
    \    # Make sure we don't go past the end.\n      if [[ $(( i * 10 )) -gt $((\
    \ length - 1 )) ]]; then\n        break\n      fi\n      (( number_not_found =\
    \ 1 ))\n    fi\n\n    # Count the digits in the number.\n    digits=0\n    while\
    \ (( i )) do\n      (( i /= 10 ))\n      digits=$(( digits + 1 ))\n    done\n\n\
    \    # Make sure we haven't already found this number.\n    if [[ $(( number_found\
    \ )) == 0 ]]; then\n      (( number_not_found = 1 ))\n    fi\n\n    if [[ $((\
    \ number_not_found )) == 1 ]]; then\n      (( count = number_found ))\n    elif\
    \ [[ $(( number_not_found )) == 0 ]]; then\n      (( count = number_not_found\
    \ ))\n    fi\n\n    echo ${number_to_count}\n", "    local n=$1\n    local count=0\n\
    \    local cur=1\n    while [ $cur -le $n ]; do\n        if [ $cur -eq 1 ]; then\n\
    \            ((count++))\n        elif [ $cur -eq 0 ]; then\n            ((count--))\n\
    \        fi\n        cur=$((cur+1))\n    done\n    return $count", "  local number=$1\n\
    \  (( n < 0 )) || return 1\n\n  local count=0\n  local remainder=n\n  while ((\
    \ remainder > 0 )) ; do\n    (( remainder = remainder % 10 ))\n    (( count++\
    \ ))\n    [ $remainder -eq 1 ] && break\n  done\n\n  return $count", "  if [ $1\
    \ -lt 10 ]\n  then\n    echo 'usage: starts_one_ends [positive integer]'\n   \
    \ return 1\n  fi\n\n  if [ $1 -gt 9999 ]\n  then\n    echo 'usage: starts_one_ends\
    \ [positive integer]'\n    return 1\n  fi\n\n  local n=$1\n  local count=0\n\n\
    \  # the numbers from 1 to 10\n  for ((i=1; i<=10; i=i+1))\n  do\n    local ii=i\n\
    \    while [ $((ii)) -ge 10 ]\n    do\n      # check whether $ii is divisible\
    \ by n\n      [ $((ii%n)) -eq 0 ] && break\n      ii=$((ii/10))\n    done\n  \
    \  if [ $((ii)) -eq 1 ]\n    then\n      count=$((count+1))\n    fi\n  done\n\n\
    \  echo $count", "  declare -i n=$1 count=1\n  for ((i=0; i < n; i++))\n    ((\
    \ i % 10 )) && continue\n    (( i % 100 )) && continue\n    (( i % 1000 )) &&\
    \ continue\n    (( i % 10000 )) && continue\n    (( i % 100000 )) && continue\n\
    \    (( i % 1000000 )) && continue\n    (( i % 10000000 )) && continue\n    ((\
    \ i % 100000000 )) && continue\n    (( i % 1000000000 )) && continue\n    (( i\
    \ % 10000000000 )) && continue\n    (( i % 100000000000 )) && continue\n    ((\
    \ i % 1000000000000 )) && continue\n    (( i % 10000000000000 )) && continue\n\
    \    (( i % 100000000000000)) && continue\n    (( i % 1000000000000000)) && continue\n\
    \    (( i % 10000000000000000)) && continue\n    (( i % 100000000000000000)) &&\
    \ continue\n    (( i % 1000000000000000000)) && continue\n    (( i == n-1 )) &&\
    \ count++\n  done\n  echo $count", "  local n=$1\n\n  local count\n  count=0\n\
    \  for (( k=0 ; k<=n ; k++ ))\n  do\n    if (( k%10 ))\n    then\n      if ((\
    \ k%100 ))\n      then\n        if (( k%1000 ))\n        then\n          if ((\
    \ k%10000 ))\n          then\n            if (( k%100000 ))\n            then\n\
    \              if (( k%1000000 ))\n              then\n                if (( k%10000000\
    \ ))\n                then\n                  if (( k%100000000 ))\n         \
    \         then\n                    (( count++ ))\n                  fi\n    \
    \            fi\n              fi\n            fi\n          fi\n        fi\n\
    \      fi\n    fi\n  done\n  echo $count", "  local n=$1\n  local -r count=0\n\
    \  (( n > 0 )); # n > 0\n  (( n % 10 == 0 )); # n % 10 == 0\n  local last=1\n\
    \  local start=1\n  while (( n >= 10 )); do\n    (( last = n % 10 )); # last is\
    \ last digit of n\n    (( n == start * 10 + last )); # n == start * 10 + last\n\
    \    (( start *= 10 )); # start is 10 ** start\n    (( n-- )); # n is n / 10\n\
    \    (( count++ )); # count is count + 1\n  done\n  echo $count", "  local n starts_one_ends\n\
    \n  # Check that the input is valid\n  if [ -z \"$1\" ]\n  then\n    return 0\n\
    \  fi\n\n  # Initialize variables\n  starts_one_ends=\"$1 $2 1 2 1 3 1 4 1 5 1\
    \ 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13 1 14 1 15 1 16 1 17 1 18 1 19 1 20 1 21 1\
    \ 22 1 23 1 24 1 25 1 26 1 27 1 28 1 29 1 30 1 31 1 32 1 33 1 34 1 35 1 36 1 37\
    \ 1 38 1 39 1 40 1 41 1 42 1 43 1 44 1 45 1 46 1 47 1 48 1 49 1 50 1 51 1 52 1\
    \ 53 1 54 1 55 1 56 1 57 1 58 1 59 1 60 1 61 1 62 1 63 1 64 1 65 1 66 1 67 1 68\
    \ 1 69 1 70 1 71 1 72 1 73 1 74 1 75 1 76 1 77 1 78 1 79 1 80 1 81 1 82 1 83 1\
    \ 84 1 85 1 86 1 87 1 88 1 89 1 90 1 91 1 92 1 93 1 94 1 95 1 96 1 97 1 98 1 99\
    \ 1 100\"\n\n  # Loop over all numbers 1...n\n  for (( i=1; i<=$(($1+1)) ))\n\
    \  do\n    # Increment the counters\n    starts_one_ends=\"$starts_one_ends $2\
    \ $(($1-1))\"\n  done\n\n  # Return the count\n  echo \"$starts_one_ends\"", " \
    \   local n=$1\n    local count=0\n    for (( i=1; i<=$n; i++ )); do\n       \
    \ if [[ $(($i % 10)) -eq 1 && $(($i % 10)) -eq 1 ]]; then\n            count=$((\
    \ count + 1 ))\n        elif [[ $(($i % 10)) -eq 0 && $(($i % 10)) -eq 1 ]]; then\n\
    \            count=$(( count + 1 ))\n        elif [[ $(($i % 10)) -eq 1 && $(($i\
    \ % 10)) -eq 0 ]]; then\n            count=$(( count + 1 ))\n        fi\n    done\n\
    \    echo \"$count\"", '  echo $1 | grep -o "1{${1}}$"', "    local n=$1\n   \
    \ local count=0\n\n    for (( i=0; i < n; i++ )); do\n        if (( i % 10 ==\
    \ 1 || i % 10 == 9 )); then\n            (( count++ ))\n        fi\n    done\n\
    \n    echo $count", "\tlocal n=$1\n\tlocal count=0\n\tlocal i=2\n\twhile [ \"\
    $i\" -le \"$n\" ]; do\n\t\t(( count += 1 ))\n\t\t(( i -= 1 ))\n\tdone\n\treturn\
    \ $count", "  if [ $# -ne 1 ]; then\n    echo \"Usage: $0 integer_to_count\"\n\
    \  fi\n\n  local integer=$1\n\n  local count=0\n\n  while (( $integer > 0 ));\
    \ do\n    local digit=$(( $integer % 10 ))\n\n    if [ $digit -eq 1 ]; then\n\
    \      (( count++ ))\n    fi\n\n    local remainder=$(( $integer / 10 ))\n   \
    \ integer=$remainder\n  done\n\n  echo $count", "  echo \"${1}\" | while read\
    \ line\n  do\n    [ $line == 1 ] && echo \"$((${line}-1))\"\n  done", "    local\
    \ n=$1\n    local sum=0\n    if [ $n -eq 0 ]; then\n        return 1\n    elif\
    \ [ $n -lt 10 ]; then\n        sum=starts_one_ends $(($n - 1))\n    elif [ $n\
    \ -ge 10 ]; then\n        local b=$(($n % 10) + 1)\n        local c=$((10#$n -\
    \ b) + 1)\n        sum=$((sum + starts_one_ends $c))\n    fi\n    echo $((sum\
    \ + 1))", "    local n starts_one=0\n    local i j num\n    # Read n\n    read\
    \ n\n    \n    # Read the list of numbers\n    read -r -d '' -a nums\n    \n \
    \   # Iterate over array nums\n    for ((i=0; i<${#nums[@]}; i++)); do\n     \
    \   # Get integer value of current number in array nums\n        j=$(echo \"${nums[$i]}\"\
    \ | sed -e 's/^ *//' -e 's/ *$//')\n        \n        # If current number starts\
    \ with 1, add 1 to starts_one\n        if [ $j == 1 ]; then\n            starts_one=$((\
    \ starts_one + 1 ))\n        fi\n        \n        # If current number ends with\
    \ 1, add 1 to ends_one\n        if [ $(( (j+1) - 1 )) -eq $n ]; then\n       \
    \     starts_one=$(( starts_one + 1 ))\n        fi\n    done\n    \n    echo \"\
    $starts_one\"", "    n=$1\n    if [ \"$n\" -lt 2 ] ; then echo \"n must be greater\
    \ than 1\"; return; fi\n    i=2\n    while [ $i -le $n ]; do\n        echo \"\
    $i $(( (i % 100) ))\"\n        i=$(( $i + 1 ))\n    done", "  local n\n  ((n =\
    \ ${1}))\n\n  (( ${#n} >= 0 ))\n  (( ${#n} != 10 ))\n  (( ${#n} != 11 ))\n\n \
    \ (( ${#n} >= 3 ))\n\n  # If the first character is 1 then there is only 1 starting\
    \ or ending 1.\n  # If it is 0, then there are 0 or 1 starting or ending 1s.\n\
    \  (( ${#n} >= 1 && ${n} == 1 ))\n\n  # If the first character is 0 then there\
    \ is one starting or ending 1.\n  # If it is 1, then there are 0 or 1 starting\
    \ or ending 1s.\n  (( ${#n} >= 1 && ${n} == 0 ))", "  local n=$1\n  local c=0\n\
    \  (( n > 0 )); # Avoid negative zero\n  (( n == 0 || n == 1 )); # Avoid single\
    \ digit\n  (( n == 1 )); # Avoid starting with 1\n  (( n > 1 )); # Avoid ending\
    \ with a zero\n  for i in {1..n}; do\n    (( i ));\n    (( c++ ));\n  done\n \
    \ echo $c", "\tlocal n=$1\n\tlocal -a starts=()\n\tlocal -a ends=()\n\tlocal i\n\
    \tlocal num=0\n\n\tfor i in $(seq $n); do\n\t\tlocal j\n\t\tlocal num=$(($(($i-1)*n+1)\
    \ % $n))\n\t\tlet num=$num+1\n\t\tif [ $num -gt $n ]; then num=$((num%$n)); fi\n\
    \t\tstarts+=( $(($i-1)*n+1)/$n )\n\t\tends+=( $num/$n )\n\tdone\n\n\tlocal -a\
    \ counts=()\n\tfor (( i=0; i<${#starts[@]}; i++ )); do\n\t\tif [ ${starts[$i]}\
    \ == ${ends[$i]} ]; then\n\t\t\tcounts[$i]=$((${counts[$i]}+1))\n\t\telse\n\t\t\
    \tcounts[$i]=1\n\t\tfi\n\tdone\n\n\techo ${counts[@]}", "    if [ \"$1\" -lt 1\
    \ ]; then\n        echo \"Usage: $0 n\"\n        return 1\n    fi\n    local n=$1\n\
    \    local -i ones=0\n    while [ $n -gt 0 ]; do\n        if [ $((n % 10)) -eq\
    \ 1 ]; then\n            if [ $((n % 100)) -eq 1 ]; then\n                if [\
    \ $((n % 1000)) -eq 1 ]; then\n                    ((ones++))\n              \
    \  else\n                    ((ones++))\n                fi\n            else\n\
    \                ((ones++))\n            fi\n        else\n            ((ones++))\n\
    \        fi\n        n=$((n-1))\n    done\n    echo \"$ones\"", "    local n=$1\n\
    \    local count=0\n    while [ $n -gt 0 ]; do\n        local digit=$((n%10))\n\
    \        if [ $digit -eq 1 ]; then\n            count=$((count+1))\n        elif\
    \ [ $digit -eq 0 ]; then\n            count=$((count-1))\n        fi\n       \
    \ n=$((n/10))\n    done\n    echo $count", '  starts_one_ends "$1"', "  (( num=$1\
    \ ))\n  (( ones=0 ))\n  (( zeros=0 ))\n  (( threes=0 ))\n  (( tens=0 ))\n  ((\
    \ hundreds=0 ))\n  (( thousands=0 ))\n\n  while (( num > 0 )); do\n    (( num--\
    \ ))\n    case $(expr $(echo \"${num}\" | cut -c1) in\n      \"1\") (( ones++\
    \ ))\n        ;;\n      \"0\") (( zeros++ ))\n        ;;\n      \"3\") (( threes++\
    \ ))\n        ;;\n      \"10\") (( tens++ ))\n        ;;\n      \"100\") (( hundreds++\
    \ ))\n        ;;\n      \"1000\") (( thousands++ ))\n        ;;\n    esac\n  done\n\
    \n  echo \"${#ones} ones, ${#zeros} zeroes, ${#threes} threes, ${#tens} tens,\
    \ ${#hundreds} hundreds, ${#thousands} thousands\"", "\t(( $# != 1 )) && return\
    \ 1\n\tlocal -r n=$1\n\t(( n > 0 )) && return 0\n\tlocal -r ret=0\n\tlocal -r\
    \ i\n\t(( n > 0 )) || return 0\n\t(( n == 0 )) || return 0\n\t(( n == 1 )) &&\
    \ return 0\n\tfor (( i = 2; i <= n; i++ )); do\n\t\t(( i % 10 == 0 )) && ret=$(expr\
    \ $ret + 1)\n\t\t(( i % 100 != 0 )) || ret=$(expr $ret + 1)\n\t\t(( i % 10000\
    \ != 0 )) || ret=$(expr $ret + 1)\n\t\t(( i % 100000 == 0 )) && ret=$(expr $ret\
    \ + 1)\n\t\t(( i % 1000000 == 0 )) || ret=$(expr $ret + 1)\n\tdone\n\treturn $ret",
  "  local n=$1\n  local count=0\n  local n1=$(seq $n)\n  local n2=$(seq $n)\n\n \
    \ # Count number of 1-digit 1-digit numbers that start or end with 1.\n  for n1\
    \ in $n1; do\n    # Loop through all remaining 1-digit numbers, adding 1 each\
    \ time\n    # it starts or ends with 1.\n    for n2 in $n2; do\n      if [[ $n1\
    \ == 1 ]] && [[ $n2 == 1 ]]; then\n        ((count++))\n      fi\n    done\n \
    \ done\n  echo \"$count\"", "  # shellcheck disable=SC2086\n  local n=$1\n  local\
    \ count=0\n  local i\n  for i in {1..n}; do\n    (( n % i == 0 )&& count+=1 )\n\
    \  done\n  echo \"$count\"", "  declare -i n_ends=0\n  for ((i=0; i < $1; i++));\
    \ do\n    ((n_ends+=(( $i != 0 ) && ($((10#$i)) %% $1 == 0))))\n  done\n  echo\
    \ \"$n_ends\"", "    local n=$1\n    echo \"$n\" | bc -l\n    local ndigits=$((\
    \ ( \"$1\" + 1 ) / 10 ))\n    for i in $(seq 1 \"$ndigits\"); do\n        if [\
    \ $(( \"$1\" + 1 )) -lt 10 ]; then\n            echo \"$(( $i - 1 ))\"\n     \
    \   else\n            echo \"$(( $i - 2 ))\"\n        fi\n        local next=$((\
    \ ( \"$1\" + 1 ) % 10 ))\n        if [ $next -eq 0 ]; then\n            echo \"\
    $(( $i - 1 ))\"\n        else\n            echo \"$(( $i - 2 ))\"\n        fi\n\
    \    done", '  echo $1', "  n=$1\n  # start count at zero\n  count_start=0\n \
    \ # end count at zero\n  count_end=0\n  # loop over every number less than n\n\
    \  for ((i=0; i<${n}; i++))\n  do\n    # start is all numbers with 1 to the left\
    \ of the number\n    # end is all numbers with 1 to the right of the number\n\
    \    start=$(printf \"%${i}d\" $1)\n    end=$(printf \"%${i}d\" $((${n}-${i})))\n\
    \    if [ $((${start}%2)) -eq 0 ]\n    then\n      count_start=$((${count_start}+1))\n\
    \    else\n      count_end=$((${count_end}+1))\n    fi\n  done\n  printf \"count_start=%d\
    \ count_end=%d\\n\" $count_start $count_end", "    local n=$1\n    if [ $n -eq\
    \ 1 ]; then\n        return 1\n    fi\n    local sum=0\n    for i in {1..10};\
    \ do\n        if [ $(( $i % $n )) -eq 1 ]; then\n            sum=$(( $sum + 1\
    \ ))\n        fi\n    done\n    return $sum", "    local n=\"$1\"\n    echo \"\
    $(( 10#$n ))\"\n    echo \"$(( 10#$n ))\" > /tmp/1\n    local count=\"$(grep -c\
    \ '^1' /tmp/1)\"\n    echo \"$(( 10#$n ))\" >> /tmp/1\n    echo \"$(( 10#$n ))\"\
    \ > /tmp/2\n    local count2=\"$(grep -c '^1' /tmp/2)\"\n    echo $(( 10#$n ))\
    \ > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n\
    \    local count3=\"$(grep -c '^1' /tmp/3)\"\n    echo $(( 10#$n )) > /tmp/1\n\
    \    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local\
    \ count4=\"$(grep -c '^1' /tmp/4)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo\
    \ \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local count5=\"\
    $(grep -c '^1' /tmp/5)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n\
    \ ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local count6=\"$(grep\
    \ -c '^1' /tmp/6)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\"\
    \ > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local count7=\"$(grep -c '^1'\
    \ /tmp/7)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n\
    \    echo \"$(( 10#$n ))\" > /tmp/3\n    local count8=\"$(grep -c '^1' /tmp/8)\"\
    \n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo\
    \ \"$(( 10#$n ))\" > /tmp/3\n    local count9=\"$(grep -c '^1' /tmp/9)\"\n   \
    \ echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"\
    $(( 10#$n ))\" > /tmp/3\n    local count10=\"$(grep -c '^1' /tmp/10)\"\n    echo\
    \ \"$(( ", "    local n=$1\n    local count=0\n    while [ \"$n\" -gt 0 ]\n  \
    \  do\n        count=`expr $count + 1`\n        if [ \"$n\" -lt 10 ]; then\n \
    \           (( n = $n*10 + 1 ))\n        else\n            (( n = $n/10 ))\n \
    \       fi\n    done", "    if [ $1 -lt 1 ]\n    then\n        return 0\n    fi\n\
    \n    local i j count=0\n    local a\n    while [ $1 -gt 0 ]; do\n        a=$(expr\
    \ $1/10 | bc)\n        if [ \"$(expr \"$a\" + *1)\" == \"$a\" ]\n        then\n\
    \            (( count++ ))\n            (( i=0 ))\n            continue\n    \
    \    fi\n        i=$(( $i+1 ))\n        (( j=$i ))\n        (( count=$(( $count\
    \ + (( $1 mod $j ) == 0) && (( $j + 1 < $1 ) )) ))\n        (( i=0 ))\n    done\n\
    \    echo $count", "  local n sum\n  for ((n=$1; n>0; n--))\n  do\n    sum=0\n\
    \    for (( i=0; i<n; i++ ))\n    do\n      if (( $(( n+i-i )) ))\n      then\n\
    \        sum=$(( sum + 1 ))\n      fi\n    done\n  done\n  echo $sum", "    local\
    \ digit=$1\n    local numbers=$2\n    local starts_one_ends=$(( numbers / 10 ))\n\
    \    for (( i = 1; i <= numbers; i++ )); do\n        local ends_one=$(\n     \
    \       echo '($ends_one_${digit})' |\n            bash <<<$'\n              \
    \  export ends_one_$digit='$(( i % 10 ))'\n            ')\n        if [ $i -eq\
    \ $starts_one_ends ]; then\n            starts_one_ends+=$ends_one\n        fi\n\
    \    done\n    echo $starts_one_ends", "  local -n count=\"$1\"\n  local -n n=\"\
    $2\"\n\n  (( $n > 0 )) || return 1\n\n  # This loop is unrolled to loop only once,\
    \ for speed\n  for (( i = 0; i < n; i++ )); do\n    (( count[$(expr $i + 1)] ))\
    \ ||\n      (( count[$(expr $i + 1)] = 1 ))\n  done\n\n  echo $n", "    local\
    \ -i start_end count=0\n    while (( start_end < ${#1} )); do\n        if [ $((\
    \ ${#1} - start_end - 1 )) -eq 1 ]; then\n            (( start_end++))\n     \
    \   else\n            break\n        fi\n    done\n    if (( start_end == ${#1}\
    \ )); then\n        echo \"0\"\n    else\n        (( start_end++ ))\n        while\
    \ (( start_end < ${#1} )); do\n            if [ ${#1} -ge $start_end ] && [ ${#1}\
    \ -le $(( $start_end + $2 )) ]; then\n                (( start_end++ ))\n    \
    \        else\n                break\n            fi\n        done\n        count=$(echo\
    \ $(( ${#1} - $start_end )) | bc)\n    fi", "   local n=$1 count=0\n   local z\n\
    \n   if [ \"$n\" = 1 ]; then\n      echo $n\n   else\n      echo 1\n      while\
    \ (( n > 0 )); do\n         z=$(( n / 10 ))\n         if [ $z -eq 1 ]; then\n\
    \            (( count++ ))\n         fi\n         n=$(( n - z ))\n      done\n\
    \   fi\n   echo $count", "    local x=\"$1\"\n    local y\n    local z\n    local\
    \ count\n    local n\n    local w\n\n    if [[ $n -lt 1 || $n -gt 10 ]]; then\n\
    \        return 0\n    fi\n\n    if [[ $(( n - 1 )) -eq 0 ]]; then\n        return\
    \ 1\n    fi\n\n    if (( x % 10 == 1 )) && (( x % 10 == 0 ))\n    then\n     \
    \   if [[ $(( n - 2 )) -eq 0 ]]; then\n            return 1\n        fi\n    \
    \    (( count++ ))\n    elif [[ $(( n - 2 )) -eq 1 ]]; then\n        (( count++\
    \ ))\n    elif [[ $(( n - 3 )) -eq 1 ]]; then\n        (( count++ ))\n    elif\
    \ [[ $(( n - 4 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 5\
    \ )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 6 )) -eq 1 ]];\
    \ then\n        (( count++ ))\n    elif [[ $(( n - 7 )) -eq 1 ]]; then\n     \
    \   (( count++ ))\n    elif [[ $(( n - 8 )) -eq 1 ]]; then\n        (( count++\
    \ ))\n    elif [[ $(( n - 9 )) -eq 1 ]]; then\n        (( count++ ))\n    elif\
    \ [[ $(( n - 10 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n -\
    \ 11 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 12 )) -eq 1\
    \ ]]; then\n        (( count++ ))\n    elif [[ $(( n - 13 )) -eq 1 ]]; then\n\
    \        (( count++ ))\n    elif [[ $(( n - 14 )) -eq 1 ]]; then\n        (( count++\
    \ ))\n    elif [[ $(( n - 15 )) -eq 1 ]]; then\n        (( count++ ))\n    fi\n\
    \n    while (( n >= 100 ))\n    do\n        if [[ $(( n - 100 )) -eq 1 ]]; then\n\
    \            (( count++ ))\n        fi\n        n=$(( n - 10 ))\n    done\n\n\
    \    while (( n >= 10 ))\n    do\n        if [[ $(( n - 10 )) -eq 1 ]]; then\n\
    \            (( count++ ))\n        fi\n        n=$(( n - 1 ))\n    done\n\n \
    \   if (( n >= 1 ))\n    then\n        (( count++ ))\n    fi\n\n", "    if [[\
    \ $1 != 0 ]]; then\n        return 0\n    fi\n    local i j\n    for i in {0..9};\
    \ do\n        j=$(expr $i + 1)\n        if [[ $j -eq $1 ]]; then\n           \
    \ return $((j - 1))\n        fi\n    done\n    return $((10 - 1))", "  if (( $#\
    \ != 1 )); then\n    echo \"Usage: $0 integer\" >&2\n    exit 1\n  fi\n\n  local\
    \ integer n digit count\n  integer=$1\n\n  n=0\n  while (( $integer > 0 )); do\n\
    \    n=$(($n + 1))\n    integer=$(($integer / 10))\n  done\n\n  digit=$(($n -\
    \ 1))\n  count=$(($integer % $digit))\n\n  echo $count", "    local n=$1\n   \
    \ local -i count=0\n\n    if [[ $n -lt 10 ]]; then\n        return 0\n    fi\n\
    \n    for (( i=1; i<=n; i++ )); do\n        [[ $(( i % 10 )) -eq 1 ]] && count=$((\
    \ count + 1 ))\n        [[ $(( n % 10 )) -eq 1 ]] && count=$(( count + 1 ))\n\
    \    done\n\n    echo \"$count\"", "    (( $# > 1 ))\n    local num=\"$1\"\n \
    \   local n=\"$2\"\n    local zero=\"000000000\"\n    # Count 1s\n    local count=0\n\
    \    while [[ $num -lt 10 ]]; do\n        (( num *= 10 ))\n        (( n-- ))\n\
    \        (( num *= 10 ))\n        (( n-- ))\n        (( num *= 10 ))\n       \
    \ (( n-- ))\n        (( num *= 10 ))\n        (( n-- ))\n        (( num *= 10\
    \ ))\n        (( n-- ))\n        count=$(( count + 1 ))\n    done\n    # Count\
    \ leading zeros\n    local count=0\n    while [[ ${num:0:1} =~ ^0+$ ]]; do\n \
    \       (( n-- ))\n        (( num *= 10 ))\n        (( count++ ))\n    done\n\
    \    # Count trailing zeros\n    count=0\n    while [[ ${num:(-1)} =~ ^0+$ ]];\
    \ do\n        (( n-- ))\n        (( num *= 10 ))\n        (( count++ ))\n    done\n\
    \    echo $(( $count - $(n) ))", "    (($# == 0)) && return 0\n\n    local digit=\"\
    $1\"\n    ((${#digit} < 0)) || return\n\n    local count=0\n    local num=1\n\
    \    local i=2\n    while ((${#digit} > i)); do\n        [ \"${digit:$i:1}\" ==\
    \ '1' ] && count=$((${count}+1)) && break\n        ((i+=1))\n    done\n\n    ((${#digit}\
    \ > i)) && count=$((${count}+1))\n    ((digit=0))\n\n    echo ${count}", "  if\
    \ [[ -n $1 ]]; then\n    local n=$1\n    local count=0\n    while [[ -n ${1#-}\
    \ ]]; do\n      (( count++ ))\n      shift\n    done\n    while [[ ${count} -ne\
    \ 0 ]]; do\n      (( count-- ))\n      [[ \"$1\" == \"$(( n -1))\" ]] && break\n\
    \      shift\n    done\n    echo \"$count\"\n  else\n    echo 0\n  fi", "    if\
    \ [ $1 -le 0 ] ; then\n        echo \"usage: $0 integer\"\n        return 1\n\
    \    fi\n    local n=$1\n    if [ $n -le 0 ] ; then\n        echo \"usage: $0\
    \ integer\"\n        return 1\n    fi\n    local count=0\n    for (( i=1; i <=\
    \ n; i++ )); do\n        (( i == 1 )) && continue\n        (( i == n )) && break\n\
    \        local j=$(( i - 1 ))\n        (( j == 0 )) && continue\n        (( j\
    \ == -1 )) && break\n        (( j * 10 + i - 1 == n )) && count=$(( count + 1\
    \ ))\n    done\n    return $count", "  local n=$1\n  local x=1\n  local count=0\n\
    \  while [ $x -le $n ]; do\n    if [ $x -eq $(( n - 1 )) ]; then\n      echo \"\
    $count\"\n      break\n    fi\n    if [ $x -eq $(( n - 2 )) ]; then\n      if\
    \ [ $x -eq 1 ]; then\n        echo \"$count\"\n      fi\n      break\n    fi\n\
    \    count=$(( count + 1 ))\n    x=$(( x + 1 ))\n  done", "  # TODO: This could\
    \ be improved. A loop starting from 0 to $1 would\n  # be more efficient.\n  for\
    \ (( i=1; i<=$1; i++ )); do\n    [[ \"$i\" -eq 1 ]] || continue\n    [[ \"$i\"\
    \ -eq $1 ]] && return $(( $(i-1) + $(i-2) + ... + $2 ))\n  done\n  return 0",
  "    if [ \"$#\" -eq \"0\" ]; then\n        echo \"Error: starts_one_ends needs\
    \ one argument.\"\n        exit 1\n    fi\n\n    local integer=\"$1\"\n\n    if\
    \ [ \"$integer\" -gt 0 ]; then\n        local number\n        local count\n  \
    \      local i\n\n        number=0\n        count=0\n        i=0\n        while\
    \ [[ $((i++)) -le \"$integer\" ]]; do\n            if [[ $(echo \"$number % 10\"\
    \ | bc | tr -d ' ') -eq 1 ]]; then\n                count=$((count+1))\n     \
    \       fi\n            number=$(($number+1))\n        done\n        echo $count\n\
    \    else\n        echo \"Error: negative or zero integer passed for start.\"\n\
    \        exit 1\n    fi", "  # TODO(mbelshe): this currently counts 1's in the\
    \ input string\n  # TODO(mbelshe): this currently doesn't handle negative numbers\n\
    \  local n=$1\n  local count=0\n  local digits=$((10#$n))\n  local digits_minus_one=$((10#$(n-1)))\n\
    \  for (( i=1; i <= digits_minus_one; i++ )); do\n    (( digits_minus_one -= i\
    \ ))\n    (( digits_minus_one %= 10 ))\n    (( digits -= i ))\n    if (( digits\
    \ < n )); then\n      (( count++ ))\n    fi\n    (( digits /= 10 ))\n  done\n\
    \  echo $count", "  if [[ $1 == \"${1:-}\" ]] || [[ -z $1 ]]; then\n    echo \"\
    ${2:-No input given}\"\n    return 1\n  fi\n  local n=$1\n  local out\n  local\
    \ i\n  local cnt\n  out=''\n  cnt=0\n  for (( i=1; i<=n; i++ )); do\n    if [[\
    \ ${i} == ${i} ]] ; then\n      (( cnt++ ))\n      if [[ ${i} == 1 ]] ; then\n\
    \        out+=\"1\"\n      else\n        out+=\"${i}\"\n      fi\n    else\n \
    \     (( cnt-- ))\n      out+=\"${i}\"\n    fi\n  done\n  if [[ ${cnt} -gt 0 ]]\
    \ ; then\n    echo \"${out}\"\n  else\n    echo \"0\"\n  fi\n  return 0", "  local\
    \ i=$1\n  local n=$2\n  (( n == 1 )) && return 0\n  (( n > 1 )) && return $((\
    \ starts_one_ends ( n-1 ) + 1 ))\n  (( n <= 1 )) && return 1\n  local count=0\n\
    \  while (( n % 10 == 1 )); do\n    count=$(($count+1))\n    n=$(( n/10 ))\n \
    \ done\n  (( n % 10 != 1 )) && count=$(($count+1))\n  return $count", "  local\
    \ n=$1\n  local i count=0\n  \n  (( $# )) || return 1\n  \n  for (( i=1; ( ( i*i\
    \ )<= n ); i++ )); do\n    if (( n % i == 0 )); then\n      (( count++ ))\n  \
    \    if (( n % i == 1 )); then\n        break\n      fi\n    fi\n  done\n  \n\
    \  echo $count", "    local n=$1\n    local n1=${n}\n    local n2=${n}\n    local\
    \ i count\n    local base=1\n    while ((n1 != 1)); do\n        n1=${n1/$base}\n\
    \        count=$((count+1))\n        base=$((base+1))\n    done\n    while ((n2\
    \ != 1)); do\n        n2=${n2/$base}\n        count=$((count+1))\n        base=$((base+1))\n\
    \    done\n    echo $count", "  local n=$1 starts_one_ends # local variable to\
    \ ensure local scope in function\n  starts_one_ends=\"$(echo \"$1\" | sed -n -e\
    \ 's/^[0-9]*//' -e 's/\\([1-9][0-9]*\\)\\([0-9]\\)/\\2\\1/p')\" # find n digits\
    \ starting with 1\n  printf \"%s\\n\" \"$starts_one_ends\" # return result\n \
    \ printf \"%d\\n\" $(echo \"$starts_one_ends\" | wc -l | sed \"s/^ *//\") # print\
    \ # of digits starting with 1", "  local n=$1\n  # if n is less than one return\
    \ 0\n  if [ $n -lt 1 ] ; then\n    echo \"0\"\n    return\n  fi\n  # if n is 1,\
    \ return n\n  if [ $n = \"1\" ] ; then\n    echo \"$n\"\n    return\n  fi\n  #\
    \ if n is 2, return 1\n  if [ $n = \"2\" ] ; then\n    echo \"1\"\n    return\n\
    \  fi\n  # if n is 3, return 0\n  if [ $n = \"3\" ] ; then\n    echo \"0\"\n \
    \   return\n  fi\n  # if n is 4, return 2\n  if [ $n = \"4\" ] ; then\n    echo\
    \ \"2\"\n    return\n  fi\n  # if n is 5, return 1\n  if [ $n = \"5\" ] ; then\n\
    \    echo \"1\"\n    return\n  fi\n  # if n is 6, return 1\n  if [ $n = \"6\"\
    \ ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is 7, return 2\n  if [\
    \ $n = \"7\" ] ; then\n    echo \"2\"\n    return\n  fi\n  # if n is 8, return\
    \ 1\n  if [ $n = \"8\" ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is\
    \ 9, return 1\n  if [ $n = \"9\" ] ; then\n    echo \"1\"\n    return\n  fi\n\
    \  # if n is 10, return 0\n  if [ $n = \"10\" ] ; then\n    echo \"0\"\n    return\n\
    \  fi\n  # if n is 11, return 0\n  if [ $n = \"11\" ] ; then\n    echo \"0\"\n\
    \    return\n  fi\n  # if n is 12, return 0\n  if [ $n = \"12\" ] ; then\n   \
    \ echo \"0\"\n    return\n  fi\n  # if n is 13, return 1\n  if [ $n = \"13\" ]\
    \ ; then\n    echo \"1\"\n    return\n  fi\n  # if n is 14, return 1\n  if [ $n\
    \ = \"14\" ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is 15, return\
    \ 2\n  if [ $n = \"15\" ] ; then\n    echo \"2\"\n    return\n  fi\n  # if n is\
    \ 16, return 1\n  if [ $n = \"16\" ] ; then\n    echo \"1\"\n    return\n  fi\n\
    \  # if n is 17, return 1\n  if [ $n = \"17\" ] ; then\n    echo \"1\"\n    return\n\
    \  fi\n  # if n is 18, return 2\n  if [ $n = \"18\" ] ; then\n    echo \"2\"\n\
    \    return\n  fi\n  # if n is 19, return 1\n  if [ $n = \"19\" ] ; then\n   \
    \ echo \"1\"\n    return\n  fi\n  # if ", "\tif [ $1 -eq 1 ] ; then\n\t\techo\
    \ \"1\"\n\telse\n\t\techo \"$(expr $(echo \"$1\" | sed -e \"s/\\(.*\\)\\(.\\)\\\
    (\\1\\)$/\\1\\2/g\") - $(echo \"$1\" | sed -e \"s/\\(.*\\)\\(..\\)$/\\1\\2/g\"\
    ))\"\n\tfi", "    local n=$1\n    local result=0\n    local base=1\n    while\
    \ [ $n -gt 1 ]; do\n        (( result+=( $n%base ) ))\n        (( n//=base ))\n\
    \        base*=10\n    done\n    echo \"$result\""]
stop_tokens:
- "\n}"
