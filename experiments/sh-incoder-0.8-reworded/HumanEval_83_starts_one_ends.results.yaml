language: sh
name: HumanEval_83_starts_one_ends
results:
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1 res=0\n  local i starts_one_ends_i=0 starts_one_ends_j=0\n\
    \  for ((i=1; i<=n; i++)); do\n    ((j=$((i-1)))) #j is i - 1\n    if (( $i ==\
    \ $j )); then\n      # first iteration\n      starts_one_ends_i=1\n    elif (\
    \ $i == ((j+1) % $n) ); then\n      # the middle iteration\n      starts_one_ends_i=2\n\
    \    else\n      # second iteration\n      starts_one_ends_i=3\n    fi\n    #\
    \ j is i-1\n    if (( $i == $j )); then\n      # last iteration\n      starts_one_ends_j=1\n\
    \    elif ( $i == ((j-1) % $n) ); then\n      # the middle iteration\n      starts_one_ends_j=2\n\
    \    else\n      # the middle iteration\n      starts_one_ends_j=3\n    fi\n \
    \   if (( $starts_one_ends_i == 3 )); then\n      # j=i+1\n      if (( $starts_one_ends_j\
    \ == 3 )); then\n        # j=i-1\n        ((res++))\n      fi\n    fi\n  done\n\
    \  echo \"$res\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmplj5hh8g3.sh: line 14: syntax error near unexpected token `(''

    /tmp/tmplj5hh8g3.sh: line 14: `    elif ( $i == ((j+1) % $n) ); then''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -r n=\"${1}\"\n  (( n < 10 )) || return\n  (( n %\
    \ 10 )) == 1 || (( n > 10 )) && return\n  local num=1\n  while (( num < n ));\
    \ do\n    (( num *= 10 ))\n    (( num += 1 ))\n  done\n  echo ${num}\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp394w5na2.sh: line 9: syntax error near unexpected token `==''

    /tmp/tmp394w5na2.sh: line 9: `  (( n % 10 )) == 1 || (( n > 10 )) && return''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=1\n  local i\n\n  for i in $(seq\
    \ $n $((10#$n + 1)) -1 0); do\n    (( n % 10 == 1 && n % 1 == 1 )) && count=$((count\
    \ + 1))\n  done\n\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "seq: extra operand \u20180\u2019\nTry 'seq --help' for more information.\n\
    seq: extra operand \u20180\u2019\nTry 'seq --help' for more information.\n"
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local number=$1\n  local n=$2\n\n  if [ $n -lt 10 ]\n \
    \ then\n    echo \"$number\"\n    return 0\n  fi\n  while [ $n -gt 0 ]\n  do\n\
    \    local i=$(( $n % 10 ))\n    local count=$(( $count + $n ))\n    if [ $i -eq\
    \ 1 ]\n    then\n      local count=$(( $count + $n ))\n      echo $count\n   \
    \ fi\n    n=$(( $n / 10 ))\n  done\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpit8xjooh.sh: line 10: [: -lt: unary operator expected

    /tmp/tmpit8xjooh.sh: line 15: [: -gt: unary operator expected

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local num_args=$(wc -l \"$1\") # Number of arguments in\
    \ $1, $2...\n  local count=$1 # First argument is the integer to check\n  if [\
    \ \"$num_args\" -gt 1 ]; then # $1 is non-empty\n    for (( count = 1; count <=\
    \ $1; count++ )); do\n      for (( i = $count; i >= 1; i-- )); do\n        local\
    \ temp=$1\n        local digit=$(( $temp % 10 ))\n        [ $digit -eq 1 ] ||\
    \ return $count\n        temp=$(( $temp / 10 ))\n      done\n    done\n  fi\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp22mxyr5n.sh: line 9: [: 3 1: integer expression expected

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    # Start with the first 1-digit number\n    local num=1\n\
    \n    # Iterate through remaining numbers, counting the numbers\n    # where the\
    \ first digit is 1.\n    for (( num=$1; $num >=1; $num++ ))\n    do\n        local\
    \ i=0;\n        local nums=$(seq 1 $num)\n        for n in $nums; do\n       \
    \     # Count how many times this number ends with a 1\n            if [[ (($(n+1)%10)==1)\
    \ ]]; then\n                (( i++ ))\n            fi\n        done\n        echo\
    \ $i\n    done\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptk71aeev.sh: line 18: expected `)''

    /tmp/tmptk71aeev.sh: line 18: syntax error near `(($(n+1)%10)==1)''

    /tmp/tmptk71aeev.sh: line 18: `            if [[ (($(n+1)%10)==1) ]]; then''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    while test $n -gt\
    \ 0\n    do\n        local digit=$(( n % 10 ))\n        test \"$digit\" = 1 &&\
    \ (( digit==1 )) && count=$(( count+1 ))\n        n=$(( n / 10 ))\n    done\n\
    \    echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local i\n    local count=0\n    local digits=$(($(echo\
    \ \"$1\" | awk '{printf \"%d\", $1}')))\n    for ((i=1; i<=digits; ++i)); do\n\
    \      if (( $(( $1 % 10 )) )); then\n          ((count++))\n      fi\n      ((\
    \ 1 = $1 % 10 ))\n    done\n    echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbe6djm74.sh: line 14: ((: 1 = 1 % 10 : attempted assignment to
    non-variable (error token is "= 1 % 10 ")

    /tmp/tmpbe6djm74.sh: line 14: ((: 1 = 2 % 10 : attempted assignment to non-variable
    (error token is "= 2 % 10 ")

    /tmp/tmpbe6djm74.sh: line 14: ((: 1 = 2 % 10 : attempted assignment to non-variable
    (error token is "= 2 % 10 ")

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local number=$1\n    local ones=0\n    local tens=0\n\
    \    local hundreds=0\n    local thousands=0\n    local i=0\n    local count=$(expr\
    \ 1 + $number)\n    while [ $i -lt $count ]; do\n        local number=$(( 10#$number\
    \ ))\n        local digit=$(echo $number | cut -c1)\n        case \"$digit\" in\n\
    \            1) ones=$(( ones + 1 ));;\n            10) tens=$(( tens + 1 ));;\n\
    \            100) hundreds=$(( hundreds + 1 ));;\n            1000) thousands=$((\
    \ thousands + 1 ));;\n            *) echo \"Bad number in starts_one_ends: $number\"\
    \ >&2\n              return 1;;\n        esac\n        i=$(( $i + 1 ))\n    done\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if (( $1 )) ; then\n    local n=$1\n    (( $n > 0 )) ||\
    \ return\n    (( $n < 10 )) || return\n    local startsone=0\n    local endsone=0\n\
    \    local count=0\n    while (( $n >= 10 )) ; do\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n\
    \      (( $n % 10 )) || return\n      (( $n % 10 )) || return\n      (( $n % 10\
    \ )) || return\n      (( $n % 10 )) || return\n      (( $n % \n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpt_u1vq48.sh: line 65: unexpected EOF while looking for matching
    `)''

    /tmp/tmpt_u1vq48.sh: line 82: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  (( $# != 1 )) && echo \"starts_one_ends: $1 not an integer\"\
    \ && return 1\n\n  local n=$1\n  (( n > 1 )) && echo \"starts_one_ends: $n must\
    \ be greater than 1\" && return 1\n\n  local -i i=0\n  (( $# == 1 )) && return\
    \ $n\n\n  (( $# > 1 )) && echo \"starts_one_ends: too many arguments\" && return\
    \ 1\n\n  local -i j=0\n  (( $# > 2 )) && echo \"starts_one_ends: too many arguments\"\
    \ && return 1\n\n  local -r starts_one_ends=true\n  local -r ends_one_starts=false\n\
    \  local -r one_at_beginning=false\n\n  (( $# == 2 )) && starts_one_ends=$2\n\
    \  (( $# == 3 )) && ends_one_starts=$3\n  (( $# == 4 )) && one_at_beginning=$4\n\
    \n  local -r prefix=1\n  local -r suffix=$(expr `expr $n - 1` \\* 10)\n  (( suffix\
    \ > 0 )) && prefix=$n\n  (( $(( suffix - 1 )) <= $n )) && prefix=$(( prefix +\
    \ 1 ))\n\n  local -r start=$(expr `expr $prefix \\* 10` \\* `expr $i + 1` \\*\
    \ 10)\n  local -r end=$(expr `expr $prefix \\* 10` \\* `expr $j + 1` \\* 10)\n\
    \  (( $(( $start + 1 )) <= $n )) && end=$(( $n \\* 10 \\* 2 ))\n\n  (( end <=\
    \ $n )) && end=$(( $n \\* 10 ))\n  (( $(( $end - 1 )) <= $n )) && end=$(( $n \\\
    * 10 \\* 2 ))\n\n  (( $ends_one_starts == true )) && echo \"starts_one_ends: prefix\
    \ $prefix suffix $suffix start $start end $end\" && return 0\n  (( $one_at_beginning\
    \ == true )) && echo \"starts_one_ends: prefix $prefix suffix $suffix start $start\
    \ end $end\" && return 0\n  (( $ends_one_starts == false )) && echo \"starts_one_ends:\
    \ suffix $suffix start $start end $end\" && return 0\n  (( $one_at_beginning ==\
    \ false )) && echo \"starts_one_ends: suffix $suffix start $start end $end\" &&\
    \ return 0\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  starts_one_ends \"$@\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local input=$1\n  local output=$2\n  local -a candidates=()\n\
    \n  # count the number of numbers that start or end with 1\n  for n in $(seq 1\
    \ $input); do\n    case \"${input:$n:1}\" in\n      1|[1-9])\n        candidates+=($n)\n\
    \        ;;\n      *)\n        break\n        ;;\n    esac\n  done\n  if (( ${#candidates[@]}\
    \ > $output )); then\n    echo >&2 'Usage:  starts_one_ends n output'\n    exit\
    \ 1\n  fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbi71zjbh.sh: line 22: ((: 0 >  : syntax error: operand expected
    (error token is ">  ")

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    for i in $(seq 1 $n);\
    \ do\n        local digit=$( echo $i | sed 's/\\(.\\)/\\1/g' )\n        if [ \"\
    $digit\" == \"1\" ]; then\n            count=$(($count+1))\n        elif [ \"\
    $digit\" == \"0\" ]; then\n            count=$(($count-1))\n        fi\n    done\n\
    \    return $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    (( $# != 1 )) && return 1;\n    # count the number of\
    \ starting and ending 1's in the number\n    local n=\"$1\"\n    local nstr=\"\
    $n\"\n    local nstart=0\n    local nend=0\n    # scan the string one char at\
    \ a time\n    local i=0\n    while [[ $nstr != 0 ]]; do\n        (( i-- ))\n \
    \       local c=${nstr:$i:1}\n        # only count if character is 1\n       \
    \ if [[ $c -eq 1 ]]; then\n            (( nstart++ ))\n        elif [[ $c -eq\
    \ 0 ]]; then\n            (( nend++ ))\n            # nstr = nstr - 1\n      \
    \      # nstr = nstr + 1\n            nstr=$(( $nstr + 1 ))\n        fi\n    done\n\
    \    echo \"$nstart\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"\
    2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"\
    4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=30 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=28 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # Input validation\n  if [[ \"$1\" -gt 0 ]]; then\n   \
    \ echo -n \"Invalid input: \\\"$1\\\" is not greater than 0\"\n    return 1\n\
    \  fi\n\n  # Process parameters\n  local n=\"$1\"\n  local nstr=\"\"\n  local\
    \ lenstr=\"\"\n  local i=0 j=0\n  local count=0\n\n  while (( i < n )); do\n \
    \   (( j=i * 10 ))\n    (( j += 1 ))\n    (( j > n ))\n    (( j %= 10 ))\n   \
    \ (( j %= 10 ))\n    (( i %= 10 ))\n\n    (( count += 1 ))\n\n    if (( ( i )\
    \ == ( j )) || [[ ${nstr} == 1 ]]; then\n      (( lenstr = lenstr + ${nstr} ))\n\
    \      (( nstr = ${nstr} + \"0\" ))\n    else\n      (( nstr = ${nstr} + \"1\"\
    \ ))\n    fi\n    (( i ++))\n  done\n\n  # Output parameter\n  echo \"$count\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptx_9c6ke.sh: line 30: syntax error near unexpected token `==''

    /tmp/tmptx_9c6ke.sh: line 30: `( ( i ) == ( j )) ''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  # If n is 0, it won't work. Return 0.\n \
    \ if [ $n -eq 0 ]\n  then\n    return 0\n  fi\n  local count=0\n  local digits=0\n\
    \  local i\n  # Use a while loop to keep a count of the number of starting numbers\
    \ with 1\n  # in them (including starting numbers with 1 at the end).\n  while\
    \ [ $n -gt 0 ]; do\n    # Get the last digit in $n\n    digit=$(( n % 10 ))\n\
    \    # If this digit is a 1, count it\n    if [ $digit -eq 1 ]\n    then\n   \
    \   # Add one to the count\n      count=$(( $count + 1 ))\n    fi\n    # Decrement\
    \ $n by one and get the last digit in $n\n    digit=$(( n % 10 ))\n    # Keep\
    \ going if $n is non-zero\n    if [ $n -eq 0 ]\n    then\n      break\n    fi\n\
    \  done\n  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=26 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=24 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  (( $# != 1 )) && { echo \"Usage: starts_one_ends n\"; exit\
    \ 1; }\n\n  # The count is the number of ones in $1 which ends with 1 so for\n\
    \  # 123 we have 1s, 123 then 2s and 123 then 3s\n  # For numbers less than 10,\
    \ we only have one 1 which ends with 1\n  # For numbers 0 through 9 we have one\
    \ 1 which ends with 1\n  # And for numbers 10 through 99 we have two 1s which\
    \ ends with 1\n  # And for numbers 100 through 999 we have three 1s which ends\
    \ with 1\n  # And for numbers 1000 through 9999 we have four 1s which ends with\
    \ 1\n  # And for numbers 10000 through 99999 we have five 1s which ends with 1\n\
    \  # And for numbers 100000 through 999999 we have six 1s which ends with 1\n\
    \  # And for numbers 1000000 through 999990 we have seven 1s which ends with 1\n\
    \  # And for numbers 10000000 through 9999990 we have eight 1s which ends with\
    \ 1\n  # And for numbers 100000000 through 9999999 we have nine 1s which ends\
    \ with 1\n  # And for numbers 1000000000 through 999999999 we have ten 1s which\
    \ ends with 1\n  (( ${1:0:1} > 10 )) && \\\n    (( ( ${1:0:1} == 10 && ( ${1:1}\
    \ % 10 == 0 )) || \\\n        ( ${1:0:1} == 0 )) && \\\n      (( ( ${1:0:1} ==\
    \ ${1:0:0:1} && \\\n        ( ${1:0:1} % ${1:0:1} == 0 ) && \\\n        ( ${1:0:1}\
    \ % 10 == 0 )) || \\\n        ( ${1:0:1} == ${1:0:0:1} && \\\n          ( ${1:0:1}\
    \ % ${1:0:1} == 0 ) && \\\n          ( ${1:0:1} % 10 != 0 ))))\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp6hdu8z76.sh: line 31: syntax error near unexpected token `}''

    /tmp/tmp6hdu8z76.sh: line 31: `}''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ \"$1\" -ne 1 ]; then\n        echo \"error: expect\
    \ a positive integer\"\n        return 1\n    fi\n    \n    local -r n=$1\n  \
    \  local -r \"count\"=( $( ( echo {0..$(echo $n-1|bc|awk '{print $1+1}')} | sed\
    \ 's/.// {n;s/.$//;p;q}') <<< 1 ) )\n    echo \"${count[@]}\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp75gfpai_.sh: line 13: syntax error near unexpected token `(''

    /tmp/tmp75gfpai_.sh: line 13: `    local -r "count"=( $( ( echo {0..$(echo $n-1|bc|awk
    ''{print $1+1}'')} | sed ''s/.// {n;s/.$//;p;q}'') <<< 1 ) )''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [[ $1 -lt 10 ]] || [[ $1 -gt 19 ]]; then\n    echo \"\
    $1 is not a positive integer.\"\n    exit 1\n  fi\n  local n=$1\n  local cnt=0\n\
    \  local one=1\n  local zero=0\n  local i\n  for (( i = 0; i < n; i++ )); do\n\
    \    (( one += ( $( echo $1 | bc  $(echo $1 | cut -d ' ' -f $i)) ))\n    (( zero\
    \ += ( $( echo $1 | bc $(echo $1 | cut -d ' ' -f $i-1) ) ))\n    (( zero -= (\
    \ $( echo $1 | bc $(echo $1 | cut -d ' ' -f $i+1) ) ))\n    (( cnt += ( one >\
    \ zero )))\n    (( cnt += ( zero < one )))\n  done\n  echo $cnt\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpa5ci9ovv.sh: line 17: syntax error near unexpected token `(''

    /tmp/tmpa5ci9ovv.sh: line 17: `( one += ( $( echo $1 | bc  $(echo $1 | cut -d
    '' '' -f $i)) ))''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=1\n  while [ $n -gt 1 ]; do\n\
    \    ((n--))\n    if [ $(( n % 10 )) -eq 1 ]; then\n      if [ $(( n % 100 ))\
    \ -eq 1 ]; then\n        ((count++))\n      fi\n    fi\n  done\n  echo $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=0\n  local start=1\n  local end=0\n\
    \  while [ $n -gt 0 ]; do\n    if [ $n -eq 0 ]; then\n      count=$((count+end-start))\n\
    \      start=$end\n      end=0\n    elif [ $((n % 10)) -eq 1 ]; then\n      count=$((count+end-start))\n\
    \      start=$((start+1))\n      end=$((start+1))\n    else\n      count=$((count+end-start))\n\
    \      start=$((start+1))\n      end=$((end+1))\n    fi\n    n=$((n-1))\n  done\n\
    \  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    # Based on the example in http://www.math.utah.edu/~behr/spring07/digit-count-problem/count-digits.shtml\n\
    \n    local n=$1\n    if [ $n -lt 10 ]\n    then\n        echo \"Error: $1 must\
    \ be an integer.\"\n        return 1\n    fi\n\n    local numbers=$(seq 1 $n)\n\
    \    local first=1\n    local second=1\n    local rest=1\n\n    for i in ${numbers};\
    \ do\n        local one_end=$(echo $i | bc -l | grep -E '^1')\n        if [ $one_end\
    \ != \"\" ]\n        then\n            if [ $first -eq 1 ]\n            then\n\
    \                first=$one_end\n                second=$i\n            else\n\
    \                rest=$one_end\n            fi\n        fi\n    done\n\n    echo\
    \ $first $second $rest\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  [ $1 -gt 0 ] && [ $1 -le 100 ] && starts_one_ends $(( 10#$1\
    \ - 10 )) || starts_one_ends $(( 10#$1 + 1 )) || exit 0\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059158
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local i iend counter=0 number=0\n    local i1\n    for\
    \ i1=${1}; ; do\n        number=$((10#$i1))\n        if (( $number == 0 )); then\n\
    \            ((counter++))\n        else\n            if (( $number == 10 ));\
    \ then\n                iend=1\n            else\n                if (( $number\
    \ == $end )); then\n                    iend=0\n                else\n       \
    \             if (( iend == 0 )); then\n                        ((counter++))\n\
    \                    fi\n                fi\n            fi\n        fi\n    done\n\
    \    if (( counter != 0 )); then\n        echo \"$1 starts or ends with $(( 10#$end\
    \ )) $(( 10#$number )) times each\"\n        echo \"$1 ends with $(( 10#$iend\
    \ )) $(( 10#$number )) times each\"\n        echo \"$1 starts with $(( 10#$i1\
    \ )) $(( 10#$number )) times each\"\n        echo \"$1 is $counter times $(( 10#$number\
    \ )) digits starting with $(( 10#$i1 )) and ending with $(( 10#$iend ))\"\n  \
    \  else\n        echo \"$1 is $number digits starting with $(( 10#$i1 )) and ending\
    \ with $(( 10#$iend ))\"\n    fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp00j78vox.sh: line 9: syntax error near unexpected token `;''

    /tmp/tmp00j78vox.sh: line 9: `    for i1=${1}; ; do''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal -i j=1\n\tlocal -i n=$1\n\n\twhile [ $n -gt 0 ];\
    \ do\n\t\tlocal -i k=$((j-1))\n\t\t[ $((k*10)) == $n ] && return $((n-k))\n\t\t\
    [ $((k*10+1)) == $n ] && return $((n-k+1))\n\t\tj=$((n-1))\n\tdone\n\n\techo \"\
    $n is invalid input\"\n\texit 1\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  ((n>0)) && echo \"$(( n-( $(expr $n \\% 9)\
    \ ))\") || return 1\n  ((n<0)) && echo \"$(( $(expr $n \\% 9 \\* -1 ) + 9 ))\"\
    \ || return 1\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1pfg1lk6.sh: line 22: unexpected EOF while looking for matching
    `"''

    /tmp/tmp1pfg1lk6.sh: line 26: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $# -eq 0 ]\n  then\n    echo \"Usage: $0 n\"\n   \
    \ exit 0\n  fi\n\n  local n=$1\n  local s=0\n  local e=0\n  local c=0\n\n  while\
    \ [ $n -gt 0 ]\n  do\n    [ $((n%10)) -eq 1 ] && c=$((c+1))\n    [ $((n%10)) -eq\
    \ 9 ] && e=$((e+1))\n    n=$((n/10))\n  done\n\n  [ $((c+1)) -gt 0 ] && s=$((s+c))\n\
    \  [ $((e+1)) -gt 0 ] && s=$((s+e))\n\n  echo \"$s\"\n}\n\ncandidate() {\n   \
    \ starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  count=0\n  while [ $n -gt 0 ]; do\n    if [ $((n\
    \ & 1)) == 0 ]; then\n      count=$((count+1))\n      n=$((n/10))\n    else\n\
    \      n=$((n/10))\n    fi\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  i=0\n  while [[ $((n%10)) -ne 1 ]]; do\n    i=$((i+1))\n\
    \    n=$((n-1))\n  done\n  echo $i\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    (( ! $1 )) && return 1\n    local n=$1\n    echo $((\
    \ $n / 10 )) | bc\n    starts_one_ends $(( n - $(( $n / 10 )) ))\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=38 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=25 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ -z $1 ]; then echo \"No argument given\"; return\
    \ 1; fi\n    if [ $(($1%10)) -eq 1 ]; then return 0; fi\n    local n=$1\n    local\
    \ i=0\n    local count=0\n    local ndigits=$(echo \"$n\" | bc -l | grep -o \"\
    [0-9][0-9]*\")\n    while [ $i -lt $ndigits ]; do\n        if [ $(($1%10)) -eq\
    \ 1 ]; then count=$(($count+1)); fi\n        i=$(($i+1))\n    done\n    echo \"\
    $count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n\n  local count\n  count=0\n\n  # iterate over\
    \ all possible numbers from 1 to 9\n  for (( c=1; c<=9; c++ )); do\n    # check\
    \ whether any of our numbers is equal to n\n    if (( $( echo \"$c\" | bc -l )\
    \ == $n )); then\n      # if the number is 1, we can terminate this loop\n   \
    \   break\n    fi\n    # increase the count by 1\n    count=$(( $count + 1 ))\n\
    \  done\n\n  # return the count\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if (( $# != 1 )); then\n    echo \"Usage: starts_one_ends\
    \ <integer>\"\n    exit 1;\n  fi\n  # Make sure $1 is really an integer.\n  local\
    \ integer=$1\n  if (( $integer <= 0 ))\n  then\n    echo \"Usage: starts_one_ends\
    \ <integer>\"\n    exit 1;\n  fi\n  # $2 will contain our result.\n  local count=0\n\
    \  while true\n  do\n    local integer=$(( $integer - 1 ))\n    # This is how\
    \ we count the number of integers that start with or end\n    # with 1.\n    if\
    \ (( $integer == 1 ))\n    then\n      (( count++ ))\n      break\n    fi\n  \
    \  (( $integer > 0 ))\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=42 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=12 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -i n count\n  (( n = $1 ))\n  (( count = 0 ))\n \
    \ while (( n > 0 )); do\n    (( count++ ))\n    (( n = n / 10 ))\n  done\n  echo\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  local -a array\n  local starts_one starts_one_ends\n\
    \  starts_one=$(n-`expr $n / 10` - 1)\n  starts_one_ends=$(n-$starts_one)\n  array=(\
    \ {1..n}; {starts_one}; {starts_one_ends} )\n  echo ${#array[@]}\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8tmttcht.sh: line 12: syntax error near unexpected token `;''

    /tmp/tmp8tmttcht.sh: line 12: `  array=( {1..n}; {starts_one}; {starts_one_ends}
    )''

    /tmp/tmp8tmttcht.sh: line 14: syntax error near unexpected token `}''

    /tmp/tmp8tmttcht.sh: line 14: `}''

    '
  stdout: '0

    '
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local result\n  result=0\n  for ((i=1; i<=n;\
    \ i++)); do\n    if [[ $((i-1)) -eq 0 ]]; then result=$((result+1)) fi\n    if\
    \ [[ $((i)) -eq 0 ]]; then result=$((result+1)) fi\n    if [[ $((i)) -eq $((n-1))\
    \ ]]; then result=$((result+1)) fi\n  done\n  echo $result\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7juq5s5o.sh: line 14: syntax error near unexpected token `done''

    /tmp/tmp7juq5s5o.sh: line 14: `  done''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local num=$1\n  local sum=0\n  local n=$1\n\n  if [ $n\
    \ -lt 10 ]\n  then\n    echo $n\n    return\n  fi\n\n  while [ $n -gt 1 ]\n  do\n\
    \    sum=$(( $sum + $(( $num % $n )) ))\n    n=$(( $n / 10 ))\n  done\n\n  echo\
    \ $(( $sum + 1 ))\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local starts_one_ends=$1\n  local n=$2\n\n  local count=0\n\
    \  local num=1\n  while [[ $num -le $n ]]; do\n    local digit=`echo $num | cut\
    \ -d $(( 10#$num % $n )) -f 1`\n    if [ $(( $digit + 1 )) -eq $starts_one_ends\
    \ ]; then\n      count=$(( count + 1 ))\n    fi\n    (( num++ ))\n  done\n\n \
    \ echo ${count}\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=\"$1\"\n  local count\n  count=0\n  while [ \"\
    $n\" -gt 0 ]; do\n    # If the first digit is 1, we know that it is not the last\
    \ digit.\n    if [ $((n%10)) -eq 1 ] ; then\n      count=$((count + 1))\n    fi\n\
    \    n=$((n/10))\n  done\n  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    declare -i number=$1\n    declare -i result\n\n    for\
    \ (( i = 0; i < number; i++ )); do\n        result=$(($result + $(expr \"$i\"\
    \ : '^\\(1\\).*$\\|^\\(.\\1\\).*$' <<< \"$i\")))\n    done\n\n    echo \"$result\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'expr: Invalid back reference

    /tmp/tmpa_fk_5i4.sh: line 11: + : syntax error: operand expected (error token
    is "+ ")

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  [[ $# -lt 1 ]] || [[ $1 -gt 36 ]] || { echo >&2 \"Usage:\
    \ starts_one_ends n\"; exit 1; }\n\n  local -r n=\"$1\"\n  local -r s=\"$2\"\n\
    \n  local -r count=0\n  local -r result=''\n  while test $n -gt 0 ; do\n    local\
    \ -r digit=\"$((10#$n%10))\"\n    test \"$digit\" = \"1\"\n    if test \"$s\"\
    \ = \"start\"; then\n      ((count++))\n    elif test \"$s\" = \"end\"; then\n\
    \      ((count--))\n    else\n      { echo >&2 \"Usage: $0 n\"; exit 1; }\n  \
    \  fi\n    n=\"$((10#$n//10))\"\n  done\n  echo $count\n}\n\ncandidate() {\n \
    \   starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'Usage: starts_one_ends n

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  test -z \"$1\" || {\n    echo \"$FUNCNAME: invalid argument\
    \ for $1: missing argument\" >&2\n    return 1\n  fi\n\n  # Count the number of\
    \ lines in file that start with 1.\n  local n\n  n=$(( $1 + 0 ))\n  head -n $n\
    \ \"$1\" | wc -l | xargs\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1k92gudv.sh: line 10: syntax error near unexpected token `fi''

    /tmp/tmp1k92gudv.sh: line 10: `  fi''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  (( n > 0 )) || return 1\n  (( n == 1 )) ||\
    \ return 0\n  starts_one_ends $(( n - 1 ))\n  starts_one_ends $(( n - 1 )) &&\
    \ echo 1\n  starts_one_ends $(( n - 2 )) && echo 1 || return 0\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # Check whether the start is 0 or 1\n  if [ \"$1\" -eq\
    \ 0 -o \"$1\" -eq 1 ]; then\n    # Return 1 if number is zero\n    echo \"$1\"\
    \n    return 1\n  fi\n  # Set up parameters\n  start=$1\n  shift 1\n  # Set up\
    \ array\n  arr=( $(eval echo {1..$start}) )\n  # Count number of starts\n  count=0\n\
    \  for i in \"${arr[@]}\"; do\n    if [ \"$i\" -eq \"$start\" -o \"$i\" -eq 1\
    \ ]; then\n      count=$((count+1))\n    fi\n  done\n  # Count number of ends\n\
    \  for i in \"${arr[@]}\"; do\n    if [ \"$i\" -eq 0 -o \"$i\" -eq 1 ]; then\n\
    \      count=$((count+1))\n    fi\n  done\n  # Return count\n  echo \"$count\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  number=$1\n  i=2\n  while [ $i -le $number ]; do\n    digit=$((\
    \ $i % 10 ))\n    if [[ $digit -eq 1 && $number -eq $i ]]; then\n      count=$((\
    \ $count + 1 ))\n    fi\n    (( i++ ))\n  done\n  echo \"$count\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # Check to see if a number was passed in\n  if [[ -z \"\
    $1\" ]]; then\n    echo \"Usage: starts_one_ends <integer>\"\n    return 1\n \
    \ fi\n\n  # Initialize variables\n  count=$((${1}))\n  digit=0\n\n  # Iterate\
    \ through each digit of the input number\n  while [ $count -ge 0 ]; do\n    digit=$((${digit}+${count}))\n\
    \    count=$((${count}-1))\n  done\n\n  # Check to see if the last digit is 1\
    \ or not\n  if [ ${digit} -eq ${1} ]; then\n    return 0\n  else\n    return 1\n\
    \  fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal n=$1\n\tlocal starts_one_ends=\"\"\n\tlocal nstr=$((\
    \ $n - 1 ))\n\tlocal remainder\n\tlocal digit\n\twhile [ \"$n\" -gt 0 ]; do\n\t\
    \tdigit=$(( $n % 10 ))\n\t\tremainder=$(( $n % 10 ))\n\t\tif [ \"$digit\" -eq\
    \ \"1\" ]; then\n\t\t\tstarts_one_ends=\"$starts_one_ends $n\"\n\t\tfi\n\t\tn=$((\
    \ $n / 10 ))\n\t\tif [ \"$remainder\" -eq \"0\" ]; then\n\t\t\tbreak\n\t\tfi\n\
    \tdone\n\techo -n \"$starts_one_ends\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local -i count=0\n    for ((i=1; i <=\
    \ n; i++)); do\n        if (( i % 100 == 0 )); then\n            printf -v cnt\
    \ \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 10 == 0 ));\
    \ then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n      \
    \  fi\n        if (( i % 100 == 0 )); then\n            printf -v cnt \"%d\" $i\n\
    \            echo ${#cnt}\n        fi\n        if (( i % 1000 == 0 )); then\n\
    \            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n \
    \       if (( i % 100000 == 0 )); then\n            printf -v cnt \"%d\" $i\n\
    \            echo ${#cnt}\n        fi\n        if (( i % 10000000 == 0 )); then\n\
    \            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n \
    \       if (( i % 100000000 == 0 )); then\n            printf -v cnt \"%d\" $i\n\
    \            echo ${#cnt}\n        fi\n        if (( i % 1000000000 == 0 )); then\n\
    \            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n \
    \       if (( i % 10000000000 == 0 )); then\n            printf -v cnt \"%d\"\
    \ $i\n            echo ${#cnt}\n        fi\n        if (( i % 100000000000 ==\
    \ 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 1000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 10000000000000\
    \ == 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 100000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 1000000000000000\
    \ == 0 )); then\n            printf -v cnt \"%d\" $i\n            echo ${#cnt}\n\
    \        fi\n        if (( i % 10000000000000000 == 0 )); then\n            printf\
    \ -v cnt \"%d\" $i\n            echo ${#cnt}\n        fi\n        if (( i % 100000000000000000\
    \ == 0 )); \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpac9fiqyc.sh: line 71: syntax error near unexpected token `}''

    /tmp/tmpac9fiqyc.sh: line 71: `}''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal i=$1\n\twhile test $i -lt 100\n\tdo\n\t\tlocal j=$((i+1))\n\
    \t\twhile test $((j-1)) -lt 100\n\t\tdo\n\t\t\tlocal k=$((j-1))\n\t\t\ttest $((k*10+k))\
    \ -eq $((j*10+j)) && echo \"$i $j\"\n\t\t\tk=$((k-1))\n\t\tdone\n\t\ti=$((i+1))\n\
    \tdone\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=68 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=54 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    echo \"$1\" | awk -v n=1 '{\n        if ((n - $1) % 2\
    \ == 0) count++\n        for (i = 1; i <= n - 1; i++)\n            if ($i % (2\
    \ * i - 1) == 0) count++\n        if ($1 == n) count++\n        END{\n       \
    \     print \"$count\"\n        }\n    }'\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'awk: cmd. line:6:         END{

    awk: cmd. line:6:         ^ syntax error

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=$(echo \"$n\" | sed -e 's/^\\\
    ([0-9]*\\).*1\\(.*\\)\\([0-9]*\\)/\\2/' | wc -w)\n    echo \"$count\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count res\n\n  # count the number of\
    \ times this number appears\n  count=0\n  while ((n > 0)); do\n    (( count++\
    \ ))\n    (( n -= 10 ))\n  done\n  # add one\n  (( count++ ))\n\n  # reserve the\
    \ result\n  res=$count\n\n  # if the number ends in 1 add one\n  (( n-- ))\n \
    \ (( res-- ))\n  while ((n != 0)); do\n    (( n-- ))\n    (( res-- ))\n  done\n\
    \  # add one\n  (( res-- ))\n  return \"$res\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=41 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=9 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ \"$1\" -ne \"0\" ]; then\n        echo 0\n     \
    \   return 1\n    fi\n    for i in {1..100}; do\n        if [ $(expr \"$i\" \"\
    $1\" = 1) -eq 1 ]; then\n            echo 1\n            return 0\n        fi\n\
    \    done\n    return 1\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $1 -lt 1 ]; then\n    echo 1\n    return 0\n  fi\n\
    \  count=0\n  twos=0\n  fives=0\n  tens=0\n  for i in {1..$1}; do\n    if [ $i\
    \ -eq 1 ]; then\n      count=$((count+1))\n    elif [ $i -ge 10 ]; then\n    \
    \  if [ $i -le 5 ]; then\n        fives=$((fives+1))\n      else\n        twos=$((twos+1))\n\
    \      fi\n    else\n      if [ $i -le 9 ]; then\n        tens=$((tens+1))\n \
    \     fi\n    fi\n  done\n  echo \"$count $twos $fives $tens\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp16bjc5i7.sh: line 16: [: {1..1}: integer expression expected

    /tmp/tmp16bjc5i7.sh: line 18: [: {1..1}: integer expression expected

    /tmp/tmp16bjc5i7.sh: line 25: [: {1..1}: integer expression expected

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    for i in {1..n}; do\n\
    \        ((n%10==1 && n!=1)) || continue\n        ((n%10==9 && n!=9)) || continue\n\
    \        ((n%10==0 && n!=0) || continue)\n        ((n==1 || n==9 || n==0) && (++count))\n\
    \    done\n    echo \"${count}\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    if [ $n -lt 1 ]; then return 1\n    elif\
    \ [ $n -gt 1 ]; then return 0\n    else\n        local sum=0\n        while [\
    \ $n -gt 0 ]; do\n            ((sum+=$(expr $n % 10)))\n            n=$(expr $n\
    \ / 10)\n        done\n        return $sum\n    fi\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local i j\n    for ((i=0; i<$1; i++)); do\n        for\
    \ ((j=1; j<$1; j++)); do\n            [[ \"$i\" = \"$j\" ]]\n            [[ \"\
    $i\" = \"${j#1}\" ]]\n            [[ \"$i\" = \"${j%1}\" ]]\n            [[ \"\
    $i\" = \"$j#${j%1}\" ]]\n        done\n    done\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local int_num=$1\n  local int_count=${int_num}\n\n  for\
    \ (( digit=$(( ${int_num} -1 )); digit >= 1; digit-- )) ; do\n    local num_count=$(math\
    \ -w \"${int_num}${digit}\")\n    if [ ${num_count} -eq 1 ] ; then\n      int_count=${int_count}${digit}\n\
    \    fi\n  done\n  echo \"${int_count}\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpzvn3qixh.sh: line 11: math: command not found

    /tmp/tmpzvn3qixh.sh: line 12: [: -eq: unary operator expected

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n count\n    n=$1\n    count=0\n    while [[ $n\
    \ -le 9 ]]; do\n        if (( $(echo $n | grep -Eq \"^1\" | wc -l) == 0 )) ; then\n\
    \            count=$(( count+1 ))\n        elif (( $(echo $n | grep -Eq \"^10\"\
    \ | wc -l) == 0 )) ; then\n            count=$(( count+2 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^11\" | wc -l) == 0 )) ; then\n            count=$(( count+3\
    \ ))\n        elif (( $(echo $n | grep -Eq \"^12\" | wc -l) == 0 )) ; then\n \
    \           count=$(( count+4 ))\n        elif (( $(echo $n | grep -Eq \"^13\"\
    \ | wc -l) == 0 )) ; then\n            count=$(( count+5 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^14\" | wc -l) == 0 )) ; then\n            count=$(( count+6\
    \ ))\n        elif (( $(echo $n | grep -Eq \"^15\" | wc -l) == 0 )) ; then\n \
    \           count=$(( count+7 ))\n        elif (( $(echo $n | grep -Eq \"^16\"\
    \ | wc -l) == 0 )) ; then\n            count=$(( count+8 ))\n        elif (( $(echo\
    \ $n | grep -Eq \"^17\" | wc -l) == 0 )) ; then\n            count=$(( count+9\
    \ ))\n        fi\n        n=$(( n-1 ))\n    done\n    printf \"count: %6d\\n\"\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=32 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=17 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tif [ $1 -eq 0 ]; then exit 0; fi\n\t\n\t# We use 10 to\
    \ indicate the last digit. e.g. 123 or 234\n\tfor i in `seq 10`; do\n\t\t# Start\
    \ with 1 and end with n\n\t\techo -n $i\n\t\tif [ $i -eq $1 ]; then\n\t\t\techo\
    \ \"1\"\n\t\t\tbreak\n\t\telse\n\t\t\tif [ $i -le $1 ]; then\n\t\t\t\tstarts_one_ends\
    \ $(($i - 1))\n\t\t\tfi\n\t\tfi\n\tdone\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local output\n  output=$(for ((i=n+1; i <=\
    \ 9; ++i)); do\n    [ \"${i}\" -eq \"1\" -o \"${i}\" -eq \"$i\" ] && return $((\
    \ n - i ))\n  done)\n  return $output\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local -i cnt=0\n    local i j\n    for\
    \ (( i=1; i<=$n; i++ )); do\n        (( cnt=(cnt+n%i==0))||( cnt+=n -i ))\n  \
    \  done\n    printf \"$cnt\\n\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo $(($1%$(($1%10000))+1))\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  count=0\n  while [ $n -gt 0 ]\n  do\n    if [ $((\
    \ n % 10 )) -eq 1 ] || [ $(( n % 10 )) -eq 2 ] || [ $(( n % 10 )) -eq 3 ] || [\
    \ $(( n % 10 )) -eq 4 ] || [ $(( n % 10 )) -eq 5 ] || [ $(( n % 10 )) -eq 6 ]\
    \ || [ $(( n % 10 )) -eq 7 ] || [ $(( n % 10 )) -eq 8 ] || [ $(( n % 10 )) -eq\
    \ 9 ]\n    then\n      (( count++ ))\n    fi\n    n=$(( n / 10 ))\n  done\n  echo\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  case $1 in\n    0) printf \"1\\n\";;\n    1) printf \"\
    0\\n\";;\n    2) printf \"1\\n\";;\n    *) printf \"%d\\n\" $(starts_one_ends\
    \ $(( $1 * 10 )) );;\n  esac\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  # A number with zero digits at the start\
    \ is one too.\n  (( $n )) || return\n  (( $(( $n - 1 )) )) || return\n  (( $n\
    \ %% 10 )) || return\n  (( $(( $n - 1 )) )) || return\n  (( $n >= 10 )) || return\n\
    \  (( $(( $n - 1 )) )) || return\n  (( $(( $n - 2 )) )) || return\n  (( $(( $n\
    \ - 3 )) )) || return\n  (( $(( $n - 5 )) )) || return\n  (( $(( $n - 7 )) ))\
    \ || return\n  (( $(( $n - 9 )) )) || return\n  (( $(( $n - 11 )) )) || return\n\
    \  (( $(( $n - 13 )) )) || return\n  (( $(( $n - 17 )) )) || return\n  (( $((\
    \ $n - 19 )) )) || return\n  (( $(( $n - 21 )) )) || return\n  (( $(( $n - 23\
    \ )) )) || return\n  (( $(( $n - 25 )) )) || return\n  (( $(( $n - 27 )) )) ||\
    \ return\n  (( $(( $n - 29 )) )) || return\n  (( $(( $n - 31 )) )) || return\n\
    \  (( $(( $n - 33 )) )) || return\n  (( $(( $n - 35 )) )) || return\n  (( $((\
    \ $n - 37 )) )) || return\n  (( $(( $n - 39 )) )) || return\n  (( $(( $n - 41\
    \ )) )) || return\n  (( $(( $n - 43 )) )) || return\n  (( $(( $n - 45 )) )) ||\
    \ return\n  (( $(( $n - 47 )) )) || return\n  (( $(( $n - 49 )) )) || return\n\
    \  (( $(( $n - 51 )) )) || return\n  (( $(( $n - 53 )) )) || return\n  (( $((\
    \ $n - 55 )) )) || return\n  (( $(( $n - 57 )) )) || return\n  (( $(( $n - 59\
    \ )) )) || return\n  (( $(( $n - 61 )) )) || return\n  (( $(( $n - 63 )) )) ||\
    \ return\n  (( $(( $n - 65 )) )) || return\n  (( $(( $n - 67 )) )) || return\n\
    \  (( $(( $n - 69 )) )) || return\n  (( $(( $\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpzo8qw7oa.sh: line 49: unexpected EOF while looking for matching
    `)''

    /tmp/tmpzo8qw7oa.sh: line 66: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n\n    for n in $1\n    do\n        if [ $n -le\
    \ 1000 ] && [ $n -ge 0 ]\n        then\n            start=$(echo \"$n\" | awk\
    \ '{print substr(\"$n\",1,1)}')\n            end=$(echo \"$n\" | awk '{print substr(\"\
    $n\",length($n),1)}')\n        fi\n    done\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    for (( i = 0; i <\
    \ n; i++ )); do\n        if (( i % 3 == 0)); then\n            if (( i % 5 ==\
    \ 0)); then\n                if (( i == 0 )); then\n                    count=$((\
    \ count + 1 ))\n                else\n                    count=$(( count + 0\
    \ ))\n                fi\n            else\n                if (( i == 0 )); then\n\
    \                    count=$(( count + 0 ))\n                else\n          \
    \          count=$(( count + 1 ))\n                fi\n            fi\n      \
    \  else\n            if (( i % 3 == 0 )); then\n                if (( i % 5 ==\
    \ 0 )); then\n                    if (( i == 0 )); then\n                    \
    \    count=$(( count + 1 ))\n                    else\n                      \
    \  count=$(( count + 0 ))\n                    fi\n                else\n    \
    \                if (( i == 0 )); then\n                        count=$(( count\
    \ + 0 ))\n                    else\n                        count=$(( count +\
    \ 1 ))\n                    fi\n                fi\n            else\n       \
    \         if (( i % 3 == 0 )); then\n                    if (( i % 5 == 0 ));\
    \ then\n                        if (( i == 0 )); then\n                      \
    \      count=$(( count + 1 ))\n                        else\n                \
    \            count=$(( count + 0 ))\n                        fi\n            \
    \        else\n                        if (( i == 0 )); then\n               \
    \             count=$(( count + 0 ))\n                        else\n         \
    \                   count=$(( count + 1 ))\n                        fi\n     \
    \               fi\n                else\n                    if (( i % 5 == 0\
    \ )); then\n                        if (( i == 0 )); then\n                  \
    \          count=$(( count + 1 ))\n                        else\n            \
    \                count=$(( count + 0 ))\n                        fi\n        \
    \            else\n                        if (( i == 0 )); then\n           \
    \                 count=$(( count + 0 ))\n                        else\n     \
    \                       count=$(( count + 1 ))\n                        fi\n \
    \                   fi\n                fi\n            fi\n        fi\n    done\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    # Initialize all values to 0\n    local numbers=()\n\n\
    \    # If the input is non-positive\n    if [ $1 -gt 0 ]; then\n        # Create\
    \ a loop that iterates over all possible values from 1 to n\n        for number\
    \ in $(seq 1 $1); do\n            # If the number is odd\n            if [ $number\
    \ -eq 1 ]; then\n                # Set is_odd to true\n                is_odd=1\n\
    \            # Otherwise\n            elif [ $number -eq $((number-1)) ]; then\n\
    \                # Set is_odd to false\n                is_odd=0\n           \
    \ # Else (number is even)\n            else\n                # Set is_odd to true\n\
    \                is_odd=1\n                # Add (number) to numbers\n       \
    \         numbers+=( $number )\n            fi\n\n            # If is_odd and\
    \ number is equal to 1\n            if is_odd -eq 1 ] && [ \"$number\" -eq 1 ];\
    \ then\n                # Increment the count of numbers that start or end with\
    \ 1\n                count=$((count+1))\n            fi\n        done\n    fi\n\
    \n    # Return count\n    echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpt0w3p1a9.sh: line 31: is_odd: command not found

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    # Loop from 1 to n-1,\
    \ because 1 is 1 digit, 2 is 2 digits, etc.\n    for (( i=1; i <= n; i++ )); do\n\
    \        # Loop until we hit a number that starts or ends with 1.\n        while\
    \ [ $i -le $n ] && [ $(( $(echo $(( $i % $n )) | bc -l )) | bc) -eq 1 ]; do\n\
    \            (( count++ ))\n            (( i++ ))\n        done\n    done\n  \
    \  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp_xs_i2go.sh: line 12: 0: command not found

    /tmp/tmp_xs_i2go.sh: line 12: [: -eq: unary operator expected

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=1\n  (( $n )) || return 0\n \
    \ while (( $n )); do\n    (( $n == 1 || n % 10 == 1 )) && break || count=$(( $count\
    \ + 1 ))\n    (( $n % 10 )) && break || n=$(( $n / 10 ))\n  done\n  echo $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local num_starts_one_ends=$(\n    expr ${1%%-*} + \\\n\
    \    $(\n      seq ${1}\n      awk '$2 ~ /^1/ {print $1}'\n      echo ${1}\n \
    \   )\n  )\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=63 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=56 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=\"$1\"\n    local count\n    count=0\n    echo\
    \ $((n-1) | grep -n '^1'\\>)\n    echo $((n) | grep -n '^1'\\<)\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpxz47h7yr.sh: line 10: n-1: command not found

    /tmp/tmpxz47h7yr.sh: line 11: n: command not found

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n\n    n=$1\n    local count\n    local digits\n\
    \    digits=()\n    local i\n    for ((i=1; i<n; i+=1)); do\n        digits[$i]=$((10#$i))\n\
    \        digits[$i]=$((10#$digits[$i]))\n    done\n    for ((i=1; i<n; i+=1));\
    \ do\n        if ((($digits[$i] | cut -c$i) == 1)); then\n            ((count+=1))\n\
    \        fi\n    done\n    echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if (( ! $1 )); then\n    echo \"Usage: starts_one_ends\
    \ n\" >&2\n    exit 1\n  fi\n  (( n = $1 ))\n  (( m = $(( (n + 1) * (n + 2) )\
    \ ))\n  (( k = ( $n / 2 ) + 1 ))\n  (( n0 = $n ))\n  (( i0 = 1 ))\n  (( k0 = 1\
    \ ))\n  (( z0 = 1 ))\n  (( d1 = 1 ))\n  (( i1 = 1 ))\n  (( k1 = 1 ))\n  (( z1\
    \ = 1 ))\n  (( d2 = 1 ))\n  (( i2 = 1 ))\n  (( k2 = 1 ))\n  (( z2 = 1 ))\n  ((\
    \ d3 = 1 ))\n  (( i3 = 1 ))\n  (( k3 = 1 ))\n  (( z3 = 1 ))\n  (( d4 = 1 ))\n\
    \  (( i4 = 1 ))\n  (( k4 = 1 ))\n  (( z4 = 1 ))\n  (( d5 = 1 ))\n  (( i5 = 1 ))\n\
    \  (( k5 = 1 ))\n  (( z5 = 1 ))\n  (( d6 = 1 ))\n  (( i6 = 1 ))\n  (( k6 = 1 ))\n\
    \  (( z6 = 1 ))\n  (( d7 = 1 ))\n  (( i7 = 1 ))\n  (( k7 = 1 ))\n  (( z7 = 1 ))\n\
    \  (( d8 = 1 ))\n  (( i8 = 1 ))\n  (( k8 = 1 ))\n  (( z8 = 1 ))\n  (( d9 = 1 ))\n\
    \  (( i9 = 1 ))\n  (( k9 = 1 ))\n  (( z9 = 1 ))\n  (( d10 = 1 ))\n  (( i10 = 1\
    \ ))\n  (( k10 = 1 ))\n  (( z10 = 1 ))\n  (( d11 = 1 ))\n  (( i11 = 1 ))\n  ((\
    \ k11 = 1 ))\n  (( z11 = 1 ))\n  (( d12 = 1 ))\n  (( i12 = 1 ))\n  (( k12 = 1\
    \ ))\n  (( z12 = 1 ))\n  (( d13 = 1 ))\n  (( i13 = 1 ))\n  (( k13 = 1 ))\n  ((\
    \ z13 = 1 ))\n  ((\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp77tjn7no.sh: line 13: syntax error near unexpected token `(''

    /tmp/tmp77tjn7no.sh: line 13: `  (( k = ( $n / 2 ) + 1 ))''

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -i n count\n  n=$1\n  count=0\n  for (( i=1; i<=n;\
    \ i++ )); do\n    if (( $i % 10 == 1 && $i > 9 )); then\n      (( count++ ))\n\
    \    fi\n    if (( $i % 10 == 0 && $i > 9 )); then\n      (( count++ ))\n    fi\n\
    \  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n count\n    ((count=0))\n    for (( n=1 ; n<$1\
    \ ; n++ ))\n    do\n        if (( ${1:0:n} == 0 ))\n        then\n           \
    \ (( count+=1 ))\n        elif (( ${1:n-1:n} == 1 ))\n        then\n         \
    \   (( count+=1 ))\n        fi\n    done\n    echo $count\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n count\n    for n in $*; do\n        if [[ $n\
    \ -eq 0 ]]; then\n            continue\n        fi\n        if [[ $(( $n % 10\
    \ )) -eq 1 ]]; then\n            (( count += 1 ))\n        fi\n    done\n    echo\
    \ \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local N=$1\n    local -a S\n    local Slen\n    local\
    \ e\n    local p\n    local t\n    local starts\n    local ends\n    local s\n\
    \    local -e\n    local p\n    local -a x\n    local t\n    local s\n    local\
    \ -e\n    local -a x\n    local s\n    local e\n    local p\n    local -a x\n\
    \    local s\n    local -e\n    local -a x\n    local s\n    local e\n    local\
    \ p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local s\n\
    \    local e\n    local p\n    local -a x\n    local s\n    local -e\n    local\
    \ -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local e\n\
    \    local p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local\
    \ s\n    local -e\n    local -a x\n    local s\n    local e\n    local p\n   \
    \ local -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local\
    \ -e\n    local -a x\n    local s\n    local e\n    local p\n    local -a x\n\
    \    local s\n    local -e\n    local -a x\n    local s\n    local -e\n    local\
    \ -a x\n    local s\n    local e\n    local p\n    local -a x\n    local s\n \
    \   local -e\n    local -a x\n    local s\n    local -e\n    local -a x\n    local\
    \ s\n    local e\n    local p\n    local -a x\n    local s\n    local -e\n   \
    \ local -a x\n    local s\n    local -e\n    local -a x\n    local s\n    local\
    \ e\n    local p\n    local -a x\n    local s\n    local -e\n    local -a x\n\
    \    local s\n    local -e\n    local -a x\n    local s\n    local e\n    local\
    \ p\n    local -a x\n    local s\n    local -e\n    local -a x\n    local s\n\
    \    local -e\n    local -a x\n    local s\n    \n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpzo0y7z6e.sh: line 16: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 21: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 28: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 35: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 42: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 45: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 52: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 55: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 62: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 65: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 72: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 75: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 82: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 85: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 92: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 95: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 102: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 105: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 112: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    /tmp/tmpzo0y7z6e.sh: line 115: local: -e: invalid option

    local: usage: local [option] name[=value] ...

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=\"$1\"\n  local result\n  result=\"$(echo \"${n}\"\
    \ | wc -w)\"\n  printf \"$result\\n\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  starts=0\n  for i in $(seq 1 1 $1); do\n    starts=$(expr\
    \ ${starts}+${i})\n  done\n  for i in $(seq ${1} 1 $1); do\n    count=$( expr\
    \ ${count} - $starts )\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "expr: syntax error: unexpected argument \u20180+1\u2019\n"
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n   local N=$1\n   for (( i=1; i<=N; i++ ))\n   do\n     \
    \ [[ \"$i\" = 1 ]] && { n=$(( n - 1 )); break; }\n      [[ \"$i\" = N ]] && {\
    \ n=$(( n + 1 )); break; }\n   done\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local count\n  (( count=0; n=${1#} ))\n  (( n-- ))\n  ((\
    \ count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++;\
    \ n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n\
    \  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n--\
    \ ))\n  (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  (( n-- ))\n \
    \ (( count++; n-- ))\n  (( n-- ))\n  (( count++; n-- ))\n  ((\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfnl7xr_z.sh: line 67: unexpected EOF while looking for matching
    `)''

    /tmp/tmpfnl7xr_z.sh: line 84: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n val\n    n=$1\n    if [ $n -eq 0 ]; then\n  \
    \      return 0\n    fi\n    local -a nums\n    local nc start end\n    local\
    \ i tmp len\n    nums=()\n    for ((i = 0; i < $n; i++)); do\n        ((i++))\n\
    \        num=$(printf \"%05d\" $i)\n        val=${num//./}\n        start=$(echo\
    \ $val |cut -c -10)\n        end=$(echo $val |cut -c -${#start})\n        nc=$((end\
    \ - start))\n        if [ $start -eq 1 ] && [ $end -eq 1 ]; then\n           \
    \ ((nc++))\n        elif [ $start -eq 0 ] && [ $end -eq 0 ]; then\n          \
    \  ((nc++))\n        elif [ $start -eq 1 ] && [ $end -eq 0 ]; then\n         \
    \   ((nc++))\n        elif [ $start -eq 0 ] && [ $end -eq 1 ]; then\n        \
    \    ((nc++))\n        fi\n        nums+=($nc)\n    done\n    len=$(echo $n |\
    \ wc -w)\n    for i in $(seq 0 $((len-1)); do\n        tmp=$(( ${nums[$i]} % 2\
    \ ))\n        if [ $tmp -eq 1 ]; then\n            (( ${nums[$i]}++ ))\n     \
    \   fi\n    done\n    echo $nums\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn9qrmwa9.sh: line 35: unexpected EOF while looking for matching
    `)''

    /tmp/tmpn9qrmwa9.sh: line 58: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # Input validation\n  [[ -z \"$1\" ]] && echo \"Invalid\
    \ input given for $0\" && exit 1\n  [[ -z \"$2\" ]] && echo \"Invalid input given\
    \ for $0\" && exit 1\n  [[ $1 =~ ^-?[0-9]+$ ]] || echo \"Invalid input given for\
    \ $0\" && exit 1\n  [[ $2 =~ ^-?[0-9]+$ ]] || echo \"Invalid input given for $0\"\
    \ && exit 1\n\n  # The algorithm\n  local starts_one_ends=$(\n    local i=1\n\
    \    local result=0\n    local count=0\n    while [ $i -le $1 ]; do\n      [ $((\
    \ (10#$i)%$2 )) -eq 0 ] || { count=$(( (count+2)%9 )); result=$(( $result + (((10#$count)%$2)\
    \ )); break; }\n      i=$(( $i + 1 ))\n    done\n    $result\n  )\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp2e2lbilx.sh: line 14: unexpected EOF while looking for matching
    `)''

    /tmp/tmp2e2lbilx.sh: line 40: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [[ $1 -eq 1 ]]; then\n    return 1\n  fi\n  local n=\"\
    $1\"\n  local s=0\n  local e\n  for (( i = 1 ; i < n ; i++ )); do\n    e=\"$(\n\
    \      local x=\"$i\"\n      while (( $x / 10 )); do\n        (( x += $i % 10\
    \ ))\n        (( s += 1 ))\n      done\n      (( x -= $i % 10 ))\n      (( s +=\
    \ 1 ))\n    )\"\n    if [[ $x -eq 1 ]]; then\n      (( s += 1 ))\n    fi\n  done\n\
    \  return $s\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [[ $1 -eq 0 ]] ; then\n    return 0\n  fi\n  local count=0\n\
    \  local n=$1\n  local current\n  local previous\n  while true ; do\n    current=$((\
    \ (n / 10) + 1 ))\n    previous=$(( (previous + 10) % 10 ))\n    if [[ $previous\
    \ -eq 1 ]] ; then\n      count=$(expr $count + 1)\n    fi\n    if [[ $current\
    \ -eq 10 ]] ; then\n      break\n    fi\n    n=$n%10\n  done\n  echo $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=31 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=15 encoding='utf-8'>
  timestamp: 1660059161
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n        local n\n        n=$1\n        local count\n\n  \
    \      count=`expr $n \\* $n`\n        local i\n\n        for ((i=0; i<=$(( ($count-1)\
    \ / 2 )); i++)); do\n                if [ $(( $n % $i )) -ne 0 ]; then\n     \
    \                   count=$(( $count - 1 ))\n                fi\n        done\n\
    \        echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"\
    2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"\
    4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpakkq7u4u.sh: line 15: 1 % 0 : division by 0 (error token is "0
    ")

    '
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ \"$1\" -eq 0 ]\n  then\n    echo \"0 1 2 3 4 5 6 7\
    \ 8 9\"\n    return\n  fi\n\n  local start=1\n  local end=$1\n  local counter=1\n\
    \n  while [ \"$start\" -le \"$end\" ]\n  do\n    echo -n \"${counter}. \"$start\n\
    \    local test_str=\"$(printf \"%0${1}d\" \"$start\")\"\n    if [ \"$test_str\"\
    \ = \"1\" ]\n    then\n      counter=$(( counter + 1 ))\n    fi\n    start=$((\
    \ start + 1 ))\n  done\n\n  echo -n \"${counter}. \"\n}\n\ncandidate() {\n   \
    \ starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=\"$1\"\n  shift\n  local count=0\n  while (( \"\
    $#\" )); do\n    local c=$1\n    shift\n    (( c==1 )) && break\n    (( c==$n\
    \ )) && count=\"$count$count\"\n  done\n  echo $(( $count ))\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local x=\"$1\"\n  local count=0;\n  while [ \"$x\" -le\
    \ 9 ]; do\n    (( count++))\n    (( x *= 10 ))\n  done\n  (( count++ ))\n  while\
    \ [ \"$x\" -gt 0 ]; do\n    (( count-- ))\n    (( x *= 10 ))\n  done\n  echo \"\
    $count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059156
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  declare -r n=\"$1\"\n  ((n > 0)) || { printf '%s\\n' \"\
    n must be positive\" && return 1; }\n  local n=\"$1\"\n  (( n == 0 )) || { printf\
    \ '%s\\n' \"n must be non-zero\" && return 1; }\n\n  local -a counts\n  counts=()\n\
    \  local -r last=$(( (n - 1) * 10 + 1 ))\n  counts[last]=0\n\n  for (( i = 1;\
    \ i <= n; i += 10 )); do\n    local -r last=$(( i * 10 ))\n    (( counts[last]\
    \ += 1 ))\n  done\n  printf '%s\\n' \"${counts[*]}\"\n}\n\ncandidate() {\n   \
    \ starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpztohisco.sh: line 9: local: n: readonly variable

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal count=0\n\tlocal digit=$1\n\tlocal factor=1\n\tlocal\
    \ i\n\twhile [ \"$factor\" -le \"$digit\" ] ; do\n\t\t(( factor *= 10 ))\n\t\t\
    (( count++ ))\n\tdone\n\t(( digit -= 1 ))\n\t(( count++ ))\n\tfor (( i=digit+1\
    \ ; i <= $#1 ; i++ )); do\n\t\tif [[ $1 == $i ]] ; then\n\t\t\t(( count-- ))\n\
    \t\t\tbreak\n\t\tfi\n\tdone\n\techo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -a nums\n  local -i start end\n\n  local num\n  local\
    \ -i one_count zero_count\n\n  start=1\n  end=$(printf \"%$1\" \"$1\")\n  (( end\
    \ -= 1 ))\n  while (( \"$start\" <= \"$end\" )) {\n    num=$(printf \"%$1\" \"\
    $start\")\n    (( nums[$num]++ ))\n    (( start = start + 1 ))\n  }\n  num=$(printf\
    \ \"%$1\" \"$end\")\n  (( nums[$num]++ ))\n  (( end = end - 1 ))\n  while (( \"\
    $start\" <= \"$end\" )) {\n    num=$(printf \"%$1\" \"$start\")\n    (( nums[$num]++\
    \ ))\n    (( start = start + 1 ))\n  }\n\n  one_count=0\n  zero_count=0\n  for\
    \ (( i = 0; i < ${#nums[@]}; i++ )); do\n    if (( nums[$i] == 1 )); then\n  \
    \    (( one_count++ ))\n    elif (( nums[$i] == 0 )); then\n      (( zero_count++\
    \ ))\n    fi\n  done\n\n  echo \"$one_count\"\n  echo \"$zero_count\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7pj54as4.sh: line 16: syntax error near unexpected token `{''

    /tmp/tmp7pj54as4.sh: line 16: `  while (( "$start" <= "$end" )) {''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n x\n    printf -v n \"$1\" && n=$(($n + 1))\n\
    \    local s=$(printf \"%4d\" 1)\n    local e=$(printf \"%4d\" $((n))); let \"\
    e=$e+$(($(($n%5)+5))))\"\n    echo -n \"$s\"\n    local i=1\n    while [ $i -le\
    \ $e ] ; do\n        echo -n \".$((i+1))\"\n        i=$(expr \"$i\" + 1)\n   \
    \ done\n    echo -n \"$e\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyxdf06jp.sh: command substitution: line 10: syntax error near unexpected
    token `+5''

    /tmp/tmpyxdf06jp.sh: command substitution: line 10: `($n%5)+5''

    /tmp/tmpyxdf06jp.sh: line 10: let: e=   2+0): syntax error in expression (error
    token is ")")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local a\n  local count\n  local digit\n \
    \ a=($(for ((digit=3; digit<=n; digit+=2)); do\n    echo -n \"1\"\n  done))\n\
    \  count=0\n  while ((a[n-1] -lt 10)); do\n    ((count+=$a[n-1]))\n    ((n--))\n\
    \  done\n  echo \"${count}\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpx4dnr8vn.sh: line 15: ((: a[n-1] -lt 10: syntax error in expression
    (error token is "10")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $1 -lt 1 ]; then\n    echo \"Usage: starts_one_ends\
    \ n\"\n    exit 1\n  fi\n\n  # count the number of n-1 digit positive integers\
    \ that end with 1\n  echo \"$(( $(printf \"%.0s\" {1..$1} | wc -c ) - 1 ))\"\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n        [ $# -ne 1 ] && echo \"Not enough arguments.\" &&\
    \ exit 1\n        local n=\"$1\"\n        local count=0\n        local i\n   \
    \     local j\n        local m\n        for (( i=1; i<=n; i++ )); do\n       \
    \         if (( n % i == 0 )); then\n                        m=($(( n/i )))\n\
    \                        if (( $m == 1 )); then\n                            \
    \    if (( $i == 0 )); then\n                                        (( count++\
    \ ))\n                                else\n                                 \
    \       (( count--, count++ ))\n                                fi\n         \
    \               else\n                                (( count-- ))\n        \
    \                fi\n                fi\n        done\n        echo \"$count\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local i n=$1\n  local start end\n  local zeroes ones\n\
    \  local ret=0\n  local digits=0\n\n  i=2\n  while [ $i -le $n ]; do\n    start=$(expr\
    \ $i / 10)\n    end=$(expr $i % 10)\n    if (( $start == 1 )); then\n      ((\
    \ ones++ ))\n      if (( $end == 0 )); then\n        (( zeroes += 1 ))\n     \
    \ else\n        (( zeroes ))\n      fi\n    fi\n    i=$(( $i + 1 ))\n  done\n\n\
    \  # print number of possible combinations for number of digits\n  # if zeroes\
    \ == ones == 2, this number is trivially 2\n  if [ $zeroes == $ones ] && [ $zeroes\
    \ == 2 ]; then\n    echo 2\n    return\n  fi\n\n  # if zeroes == ones == 3, this\
    \ number is trivially 3\n  if [ $zeroes == $ones ] && [ $zeroes == 3 ]; then\n\
    \    echo 3\n    return\n  fi\n\n  # for larger numbers, it is obviously not possible\
    \ to have a count of\n  # numbers that start or end with 1 without having a combination\
    \ of two\n  # digits that ends in either 1 or 0\n  echo \"not possible\"\n  return\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp449guv2f.sh: line 30: [: ==: unary operator expected

    /tmp/tmp449guv2f.sh: line 36: [: ==: unary operator expected

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local start\n  local end\n  local count\n\
    \n  count=$(expr $( ( ( $(expr $( ( ( $(expr $(expr ${n} + 1) - 1 ) / ${n} ))\
    \ * ${n} - 1 ) / ${n} ) + 1 ) / ${n} )\n\n  printf \"$count\\n\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpavv38yq0.sh: line 12: unexpected EOF while looking for matching
    `)''

    /tmp/tmpavv38yq0.sh: line 31: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n b\n  ((n=$1))\n  ((b=$((n-1))))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n\
    \  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n  ((b--))\n  ((b++))\n\
    \  ((b--))\n  ((b++))\n  ((b--))\n\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n count\n    n=$1\n    count=0\n    while [ $n\
    \ -gt 0 ]; do\n        [ $((n % 10)) -eq 1 ] && count=$(($count + 1))\n      \
    \  (( n = $((n/ 10)))\n    done\n    echo \"$count\"\n}\n\ncandidate() {\n   \
    \ starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5sqap3we.sh: line 15: syntax error near unexpected token `}''

    /tmp/tmp5sqap3we.sh: line 15: `}''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n i c ret\n  n=$1\n  shift\n  while (( $# > 0 ));\
    \ do\n    i=$(( $n - 1 ))\n    c=$(( $i + 1 ))\n    (( n >= i && n >= c ))\n \
    \   (( n > c ))\n    (( n <= i ))\n    (( n <= c ))\n    (( ! ( (n == i) || (n\
    \ == c) ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n    (( ! ( (n == c) ) ))\n\
    \    (( ! ( (n == i) || (n == c) ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n\
    \    (( ! ( (n == c) && (n == i) ) ))\n    (( ! ( (n == i) && (n == c) ) ))\n\
    \    (( ! ( (n == c) && (n == i) ) ))\n    (( n == 3 ))\n    (( n == 4 ))\n  \
    \  (( n == 5 ))\n    (( n == 6 ))\n    (( n == 7 ))\n    (( n == 8 ))\n    ((\
    \ n == 9 && $1 ))\n    (( n == 10 ))\n    (( n == 11 && $1 ))\n    (( n == 12\
    \ ))\n    (( n == 13 ))\n    (( n == 14 && $1 ))\n    (( n == 15 ))\n    (( n\
    \ == 16 ))\n    (( n == 17 && $1 ))\n    (( n == 18 ))\n    (( n == 19 && $1 ))\n\
    \    (( n == 20 ))\n    (( n == 21 && $1 ))\n    (( n == 22 && $1 ))\n    (( n\
    \ == 23 ))\n    (( n == 24 && $1 ))\n    (( n == 25 && $1 ))\n    (( n == 26 &&\
    \ $1 ))\n    (( n == 27 && $1 ))\n    (( n == 28 && $1 ))\n    (( n == 29 && $1\
    \ ))\n    (( n == 30 ))\n    (( n == 31 && $1 ))\n    (( n == 32 && $1 ))\n  \
    \  (( n == 33 ))\n    (( n == 34 && $1 ))\n    (( n == 35 ))\n    (( n == 36 &&\
    \ $1 ))\n    (( n == 37 ))\n    (( n == 38 && $1 ))\n    (( n == 39 ))\n    ((\
    \ n == 40 ))\n    (( n == 41 && $1 ))\n    (( n == 42 && $1 ))\n    (( n == 43))\n\
    \    (( n == 44 ))\n    (( n == 45 && $1 ))\n    (( n == 46 ))\n    ((\n}\n\n\
    candidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpxre_itbn.sh: line 69: unexpected EOF while looking for matching
    `)''

    /tmp/tmpxre_itbn.sh: line 86: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo \"$1\" | awk '{print length($1)}' | sort -n | uniq\
    \ -c | sed -n '/^1$/,/1$/p'\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=\"$1\"\n  local numbers=()\n  local number\n  for\
    \ number in {1..$n}; do\n    if [ $number -eq 1 ]; then\n      numbers+=(\"$number\"\
    )\n    fi\n  done\n  echo \"${#numbers[@]}\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpppkaktzl.sh: line 11: [: {1..1}: integer expression expected

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n\n  n=$1\n  if (( n < 10 )); then\n    echo 'starts_one_ends:\
    \ n must be in range 0...9.'\n    return\n  fi\n  local ndigits\n  ndigits=$((\
    \ $n - 1 ))\n  local count=0\n  local i\n  for i in $(seq 1 $ndigits); do\n  \
    \  if (( 10#$i == 1 )); then\n      (( count++ ))\n    fi\n  done\n  echo $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo \"$1\"\n  echo \"$1\"\n  echo \"$1\"\n  echo \"$1\"\
    \n  echo \"$1\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -r n=\"$1\"\n\n  (( n > 0 )); then\n    local -r\
    \ count=0\n\n    # Count how many n digit numbers in [0, n] start with 1.\n  \
    \  while (( n /= 10 )); do\n      # Add one if n % 10 is 1.\n      if (( n % 10\
    \ == 1 )); then\n        count=$(( count+1 ))\n      fi\n    done\n\n    # Count\
    \ how many n digit numbers in [0, n] end with 1.\n    for (( i=0; i < n-1; i++\
    \ )); do\n      (( n /= 10 ))\n      if (( n % 10 == 1 )); then\n        count=$((\
    \ count+1 ))\n      fi\n    done\n  fi\n\n  echo \"$count\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp6_w12bew.sh: line 9: syntax error near unexpected token `then''

    /tmp/tmp6_w12bew.sh: line 9: `  (( n > 0 )); then''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ ! $1 -ge 0 ] || [ ! $1 -le 2147483647 ]; then\n  \
    \  echo \"Usage: $0 INTEGER\"\n    return 1\n  fi\n  local N=$1\n  local NUM=0\n\
    \  local N=1\n  while [ $N -lt $1 ]\n  do\n    ((N+=1))\n    if [ $N -ge 10 ];\
    \ then\n      NUM=$((NUM*10+$N))\n    elif [ $N -le 0 ]; then\n      NUM=$((NUM*10+$N))\n\
    \    elif [ $N -eq 1 ]; then\n      NUM=$((NUM+1))\n    fi\n  done\n  echo $NUM\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local starts=$1\n  local ends=$2\n  local total=0\n  local\
    \ count=0\n  local digits=$(( (ends/10) + 1 ))\n  local i=1\n  while (( i <= ends\
    \ )) ; do\n    if (( starts == 1 )) ; then\n      count=$(( starts + count ))\n\
    \      break\n    fi\n    (( i++ ))\n    starts=$(( $starts - 10 ))\n  ends=$((\
    \ $ends - 10 ))\n  echo -n \"$count\"\n  (( total += count ))\n  echo -n \"$total\"\
    \n  echo $total\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpsph7_q46.sh: line 25: syntax error near unexpected token `}''

    /tmp/tmpsph7_q46.sh: line 25: `}''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  printf \"starts_one_ends called\"\n  if ((\
    \ n < 1 )); then\n    return 0\n  fi\n  local count=0\n  local p\n  for (( p=2;\
    \ p<=9; p++ )); do\n    if (( p == n )); then\n      count=$count+1\n    fi\n\
    \    if (( p == n-1 )); then\n      count=$count+1\n    fi\n  done\n  return $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    echo \"$(( $n + 1 ))\"\n    if [ ! \"\
    $n\" -eq \"1\" ]; then\n        echo \"$(( $n - 1 ))\"\n    fi\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=0\n  local last=$(( 10**(n-1)\
    \ - 1 ))\n  while [[ $n -gt 0 ]]; do\n    [ $(( n%10 )) -eq 1 ] || break\n   \
    \ (( count++ ))\n    n=$(( n/10 ))\n  done\n  echo ${count}\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  starts_one_ends_sum=0\n  n=$((n-1))\n  while [\
    \ $n -gt 0 ]; do\n    if [ ${n} == 0 ]; then\n      starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      n=$((n-1))\n    else\n      starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      if [ ${n} == 1 ]; then\n        n=$((n-1))\n        starts_one_ends_sum=$((starts_one_ends_sum+1))\n\
    \      fi\n    fi\n  done\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  # return 0 when the number is too big\n \
    \ (( n > 9 && n < 100 )) || return 0\n  # return 0 when the number is negative\n\
    \  (( n < 0 )) || return 0\n  local count=0\n  # loop through the digits\n  local\
    \ digit\n  while (( n > 0 )); do\n    # get the last digit\n    digit=$(( n %\
    \ 10 ))\n    (( n /= 10 ))\n    # if the last digit is 1 or 0, increment the counter\n\
    \    (( digit == 1 || digit == 0 )) && count=$(( count + 1 ))\n  done\n  # return\
    \ the count\n  return $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local result\n\n    # Count all positive\
    \ integers with at least n digits and that do not\n    # start or end with 1\n\
    \    local start=$(seq -f \"%08g\" 0 $((n-1)) )\n    local end=$(seq -f \"%08g\"\
    \ 1 $n | tail -n 1)\n    result=( $(echo $start | grep -v 1 ) && echo 0 || echo\
    \ 0 )\n\n    # Count all positive integers with at least n digits and that do\
    \ not\n    # start or end with 1\n    local start1=$(seq -f \"%08g\" 0 $((n-1))\
    \ )\n    local end1=$(seq -f \"%08g\" 1 $n | tail -n 1)\n    result=( $result\
    \ && echo 0 || echo 0 )\n\n    # Count the remaining positive integers with at\
    \ least n digits\n    result=( $result && echo 1 || echo 0 )\n    # Add the counts\n\
    \    result=( $( IFS=$'\\n' printf \"%s\\n\" \"${result[@]}\" ) | tr ' ' '\\n'\
    \ | paste -s -d '\\n' ) \n    # Convert to a string\n    result=$( printf \"%s\\\
    n\" ${result[@]} | sed 's/^[ \\t]*//;s/[ \\t]*$//;s/^0*//;s/1//;s/^1//' )\n  \
    \  # Remove leading 0s\n    result=$( printf \"%s\\n\" ${result[@]} | sed 's/^0*//'\
    \ )\n    # Remove leading 1\n    result=$( printf \"%s\\n\" ${result[@]} | sed\
    \ 's/^1//' )\n\n    # Return the result\n    echo $result\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyai3pu1v.sh: line 14: syntax error near unexpected token `&&''

    /tmp/tmpyai3pu1v.sh: line 14: `    result=( $(echo $start | grep -v 1 ) && echo
    0 || echo 0 )''

    /tmp/tmpyai3pu1v.sh: line 18: local: can only be used in a function

    /tmp/tmpyai3pu1v.sh: line 19: local: can only be used in a function

    /tmp/tmpyai3pu1v.sh: line 20: syntax error near unexpected token `&&''

    /tmp/tmpyai3pu1v.sh: line 20: `    result=( $result && echo 0 || echo 0 )''

    /tmp/tmpyai3pu1v.sh: line 23: syntax error near unexpected token `&&''

    /tmp/tmpyai3pu1v.sh: line 23: `    result=( $result && echo 1 || echo 0 )''

    /tmp/tmpyai3pu1v.sh: line 25: syntax error near unexpected token `|''

    /tmp/tmpyai3pu1v.sh: line 25: `    result=( $( IFS=$''\n'' printf "%s\n" "${result[@]}"
    ) | tr '' '' ''\n'' | paste -s -d ''\n'' ) ''

    /tmp/tmpyai3pu1v.sh: line 35: syntax error near unexpected token `}''

    /tmp/tmpyai3pu1v.sh: line 35: `}''

    '
  stdout: '

    '
  timestamp: 1660059157
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $1 -eq 0 ] ; then\n    echo 1\n    return 0\n  else\n\
    \    [ $1 -le 1000000000 ] &&\n      starts_one_ends $(( $1 / 101 )) &&\n    \
    \  starts_one_ends $(( $1 % 101 ))\n  fi\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=40 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=5 encoding='utf-8'>
  timestamp: 1660059162
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local start\n  local end\n\n  start=1\n  end=${1}\n  while\
    \ [ \"$start\" -le \"$end\" ]\n  do\n    if [[ $(( \"${start}\" )) -eq 1 ]]\n\
    \    then\n      (( start++ ))\n    fi\n\n    if [[ $(( \"${end}\" )) -eq $((\
    \ \"${start}\" )) ]]\n    then\n      (( end-- ))\n    fi\n\n    (( end - start\
    \ ))\n  done\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  ns=$(echo $n | sed 's/^\\./& /;s/\\./& /;s/^&\\\
    ./& /;s/\\.$//;')\n  ones=$(echo $n | sed 's/^\\./& /;s/\\./& /;s/^&\\./& /;s/\\\
    .$//;')\n  echo \"$((${#ns}/2))\"\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=$(echo $((${n}+${n}-1) % ${n}*9))\
    \ ;\n  if [ $count -gt 0 ] ; then\n    echo ${count} ;\n  else\n    echo 0 ;\n\
    \  fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8s0we8qb.sh: command substitution: line 8: syntax error near unexpected
    token `%''

    /tmp/tmp8s0we8qb.sh: command substitution: line 8: `(${n}+${n}-1) % ${n}*9''

    /tmp/tmp8s0we8qb.sh: line 9: [: -gt: unary operator expected

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    # $1 is a positive integer\n    if [ $1 -eq 1 ] ; then\n\
    \        return 1\n    fi\n\n    # Return 0 if the argument is nonpositive\n \
    \   if [ $1 -eq 0 ] ; then\n        return 0\n    fi\n\n    # Store the digit\
    \ count in $count\n    count=$(expr ${1} \\* ${10})\n    local i\n\n    # Loop\
    \ until $count is 0 or 1 to avoid infinite loops\n    while [ $count -gt 1 ] ;\
    \ do\n        # Store the remainder in $rem\n        rem=$(expr ${1} \\% ${10})\n\
    \n        # If the remainder is 0, add it to the count\n        if [ \"${rem}\"\
    \ -eq 0 ] ; then\n            count=$(( ${count} + 1 ))\n            continue\n\
    \        fi\n\n        # If we got here, increment the count by 2 and decrement\
    \ the reminder\n        count=$(( ${count} + 2 ))\n        rem=$(expr ${rem} -\
    \ 1 )\n\n        # Add the remainder to the count\n        count=$(( ${count}\
    \ + 1 ))\n\n        # Exit the loop if we added a digit\n        if [ $count -gt\
    \ 1 ] ; then\n            break\n        fi\n    done\n\n    return $count\n}\n\
    \ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[\
    \ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n \
    \   [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local starts_one_ends_result\n    starts_one_ends_result=0\n\
    \    for (( i = 0; i < $1; i++ ))\n    do\n        (( n % 10 ))\n        if [[\
    \ ${starts_one_ends_result} -gt 0 ]]; then\n            starts_one_ends_result=$((\
    \ $starts_one_ends_result + 1 ))\n        fi\n        (( n = n / 10 ))\n    done\n\
    \    return $starts_one_ends_result\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=0\n  (( n % 2 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 100 != 0 )) && count++\n  (( n % 100\
    \ != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 !=\
    \ 0 )) && count++\n  (( n % 10 != 0 )) && count++\n  (( n % 10 != 0 )) && count++\n\
    \  (( n % 10 != 0 )) && \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpoaof0zs0.sh: line 51: syntax error near unexpected token `}''

    /tmp/tmpoaof0zs0.sh: line 51: `}''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tif [ \"$1\" -lt 1 ]; then\n\t\techo \"Illegal argument:\
    \ $1\"\n\t\texit 1\n\tfi\n\n\tlocal n=$1\n\tlocal count=0\n\tlocal last_non_one\n\
    \tlocal last_non_one_pos\n\tlocal last_non_one_neg\n\tlocal first_one\n\tlocal\
    \ first_one_pos\n\tlocal first_one_neg\n\tlocal pos_ends_one_neg\n\tlocal neg_ends_one_pos\n\
    \tlocal i\n\n\tfor i in {1..n}; do\n\t\tfirst_one=`expr $i + 1`\n\t\tfirst_one_pos=`expr\
    \ $i + 1`\n\t\tfirst_one_neg=`expr $i - 1`\n\t\tpos_ends_one_neg=`expr $first_one\
    \ - 1`\n\t\tneg_ends_one_pos=`expr $first_one_pos - 1`\n\t\tif [ $first_one -eq\
    \ 1 ]; then\n\t\t\tif [ $first_one_pos -eq 1 ]; then\n\t\t\t\tcount=$(( $count\
    \ + 1 ))\n\t\t\telif [ $first_one_neg -eq 1 ]; then\n\t\t\t\tcount=$(( $count\
    \ + 1 ))\n\t\t\tfi\n\t\tfi\n\t\tif [ $first_one_neg -eq 1 ]; then\n\t\t\tif [\
    \ $first_one_pos -eq 1 ]; then\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\telif [\
    \ $pos_ends_one_neg -eq 1 ]; then\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\telif\
    \ [ $neg_ends_one_pos -eq 1 ]; then\n\t\t\t\tcount=$(( $count + 1 ))\n\t\t\tfi\n\
    \t\tfi\n\tdone\n\techo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: "expr: non-integer argument\nexpr: non-integer argument\nexpr: non-integer\
    \ argument\nexpr: syntax error: unexpected argument \u20181\u2019\nexpr: syntax\
    \ error: unexpected argument \u20181\u2019\n/tmp/tmpggobgi6d.sh: line 30: [: -eq:\
    \ unary operator expected\n/tmp/tmpggobgi6d.sh: line 37: [: -eq: unary operator\
    \ expected\n"
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if (( $# != 1 )); then\n    echo \"usage: starts_one_ends\
    \ [number]\"\n    exit 1\n  fi\n  local number=$1\n  local count=0\n  while ((\
    \ $number > 0 )); do\n    if (( $number % 10 == 1 )); then\n      (( count++ ))\n\
    \    fi\n    number=$(( $number / 10 ))\n  done\n  echo $count\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local i ret=0\n  local n digit\n  for i in $(seq $1)\n\
    \  do\n    digit=$(printf %02d $i)\n    if [ $digit -eq 1 ]\n    then\n      ((ret++))\n\
    \    fi\n  done\n  echo $ret\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  nums=$(seq 1 $n)\n  ones=$(echo $nums | grep -Eo\
    \ '[1-9][0-9]*$')\n  tail=$(( $(expr $n - ${#ones}) ))\n  echo $tail\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local NUM=\"${1}\"\n\n    # Convert to base-10.\n   \
    \ local BASE10=\"${NUM}\"\n    echo \"$((10#$BASE10 - 1))\"\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local counter=0\n  local i\n  for i in $(seq\
    \ -f \"%0${n}d\" 1 $((100*n))); do\n    if (( $i | egrep \"^1$|^$((100*(n-1)))$\"\
    \ )) ; then\n      (( counter+=1 ))\n    fi\n  done\n  echo $(( $counter ))\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "seq: format \u2018%01d\u2019 has unknown %d directive\n"
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -i count\n  local -i number\n  local -r count\n\n\
    \  if [[ ! $1 =~ ^[0-9]+$ ]]; then\n    echo \"${FUNCNAME[0]}: ${1:-Missing integer}\"\
    \ 1>&2\n    return 1\n  fi\n\n  local -r count=$(( ${1%-*}-1 ))\n  number=$((\
    \ $1 ))\n  local i\n  while (( ${number} > 9 )); do\n    (( ${count} += 1 ))\n\
    \    number=$(( $number / 10 ))\n  done\n\n  local -r last=$(( ${number} + 1 ))\n\
    \  for i in $(seq 0 $(( $count + 1 ))); do\n    if (( ${last} == ${number} ));\
    \ then\n      (( ${count} += 1 ))\n    fi\n    number=$(( $number - 10 ))\n  done\n\
    \n  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"\
    2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"\
    4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpfpq0ltpo.sh: line 16: local: count: readonly variable

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ \"$1\" = \"--help\" ] || [ \"$1\" = \"-h\" ] || [\
    \ \"$1\" = \"-?\" ] || [ \"$1\" = \"help\" ]; then\n    echo \"Usage: starts_one_ends\
    \ <n>\"\n    echo \"  <n> is an integer\"\n    echo \"Returns: count of n-digit\
    \ positive integers that start or end with 1\"\n  else\n    local n=$1\n    echo\
    \ \"$(( $(nproc) > 1 )) starts_one_ends $n started\"\n    local count=0\n    for\
    \ (( i=1; i<=n; i++ )); do\n      for (( j=i; j>0; j-- )); do\n        if [ $(expr\
    \ $i - $j) = 1 ]; then\n          count=$(( $count + 1 ))\n        fi\n      done\n\
    \    done\n    echo \"$(( $count )) starts_one_ends $n ended\"\n    echo \"$((\
    \ $count )) starts_one_ends $n ended\"\n  fi\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=\"$1\"\n    local count=0\n    while [ -n \"\
    $n\" ]; do\n        (( n /= 10)) && count=$(($count + 1))\n    done\n    echo\
    \ \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=66 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=62 encoding='utf-8'>
  timestamp: 1660059162
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=\"$1\"\n  local one\n  local one_count\n  local\
    \ two_ones\n  local two_ones_count\n  local three_count\n  local three_ones\n\
    \  local three_ones_count\n  local four_count\n  local four_ones\n  local four_ones_count\n\
    \  local five_count\n  local five_ones\n  local five_ones_count\n  local nine_count\n\
    \  local nine_ones\n  local nine_ones_count\n  local ten_count\n  local ten_ones\n\
    \  local ten_ones_count\n  local fifteen_count\n  local fifteen_ones\n  local\
    \ fifteen_ones_count\n  local twenty_count\n  local twenty_ones\n  local twenty_ones_count\n\
    \  local hundred_count\n  local hundred_ones\n  local hundred_ones_count\n  local\
    \ thousand_count\n  local thousand_ones\n  local thousand_ones_count\n  local\
    \ thousand_ten_count\n  local thousand_ten_ones\n  local thousand_ten_ones_count\n\
    \  local million_count\n  local million_ones\n  local million_ones_count\n  local\
    \ billion_count\n  local billion_ones\n  local billion_ones_count\n  local billion_ten_count\n\
    \  local billion_ten_ones\n  local billion_ten_ones_count\n  local trillion_count\n\
    \  local trillion_ones\n  local trillion_ones_count\n  local trillion_ten_count\n\
    \  local trillion_ten_ones\n  local trillion_ten_ones_count\n  local quadrillion_count\n\
    \  local quadrillion_ones\n  local quadrillion_ones_count\n  local quadrillion_ten_count\n\
    \  local quadrillion_ten_ones\n  local quadrillion_ten_ones_count\n  local quintillion_count\n\
    \  local quintillion_ones\n  local quintillion_ones_count\n  local quintillion_ten_count\n\
    \  local quintillion_ten_ones\n  local quintillion_ten_ones_count\n  local sextillion_count\n\
    \  local sextillion_ones\n  local sextillion_ones_count\n  local \n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local x\n  ((n--)); local result=0\n  while\
    \ ((n>0)); do\n    x=$(expr $n / 10)\n    ((n%=10)) && result=$((result+$x))\n\
    \    ((n--))\n  done\n  ((n--)) && result=$((result+$n))\n  ((n--))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n\
    \  ((n--)) && result=$((result+$n))\n  ((n--)) && result=$((result+$n))\n  ((n--))\
    \ && result=$((result+$\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpv2pnvy1e.sh: line 47: unexpected EOF while looking for matching
    `)''

    /tmp/tmpv2pnvy1e.sh: line 64: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ $1 -lt 1 ]; then\n        echo \"starts_one_ends:\
    \ ERROR: Invalid integer $1\"\n        return 1\n    fi\n    local starts=$((\
    \ ($1-1) % 10 ))\n    local ends=$(( ($1-1) / 10  ))\n    local zeros=$(( ($1-1)\
    \ % 100 ))\n    local ones=$(( starts + ends + zeros))\n    local count=$(( starts\
    \ + ends + zeros + ones))\n    echo \"starts_one_ends: $starts $ends $zeros $ones\
    \ $count\"\n    return 0\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=\"$1\"\n    if [[ $n -lt 1 ]]\n    then\n   \
    \     return 1\n    fi\n    local count=0\n    while [[ $n -gt 1 ]]\n    do\n\
    \        if [[ $((n % 10)) -eq 1 ]]\n        then\n            ((count++))\n \
    \       fi\n        n=$(( n / 10 ))\n    done\n    return $count\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count\n    local prefixes\n   \
    \ local suffixes\n    local a\n    local b\n\n    count=0\n    prefixes=$(awk\
    \ -v PREFIXES=\"$n\" '{ for (i = 2; i <= $1; i++)\n        for (j = i - 1; j >=\
    \ 0; j--)\n            if ($i % $j == 0) {\n                prefixes=$j\n    \
    \            break\n            }\n        }\n        print prefixes\n    }')\n\
    \n    suffixes=$(awk -v PREFIXES=\"$n\" '{ for (i = 2; i <= $1; i++)\n       \
    \ for (j = i; j < $1; j++)\n            if ($i % $j == 0) {\n                suffixes=$j\n\
    \                break\n            }\n        }\n        print suffixes\n   \
    \ }')\n\n    for ((a=1; a <= $prefixes; a++))\n    do\n        for ((b=$(a); b\
    \ >= 1; b--))\n        do\n            count=$((count+1))\n        done\n    done\n\
    \n    for ((a=$(a-1); a >= 1; a--))\n    do\n        for ((b=$(a); b >= 1; b--))\n\
    \        do\n            count=$((count+1))\n        done\n    done\n\n    echo\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'awk: cmd. line:8:         print prefixes

    awk: cmd. line:8:         ^ syntax error

    awk: cmd. line:9:     }

    awk: cmd. line:9:     ^ syntax error

    awk: cmd. line:8:         print suffixes

    awk: cmd. line:8:         ^ syntax error

    awk: cmd. line:9:     }

    awk: cmd. line:9:     ^ syntax error

    /tmp/tmpggn7emjh.sh: line 37: ((: a <= : syntax error: operand expected (error
    token is "<= ")

    /tmp/tmpggn7emjh.sh: line 45: a-1: command not found

    /tmp/tmpggn7emjh.sh: line 45: ((: a=: syntax error: operand expected (error token
    is "=")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local i=$1\n    local n=$2\n    # Print all the numbers\
    \ from $n to $n to STDOUT.\n    # Count all such numbers.\n    for ((j=$n; j>0;\
    \ j--)) do\n        echo $j\n        count=$((count + $(cd ./${i}/ > /dev/null\
    \ && cd ../../${i}/ && echo `expr $j + $(cd ../${i}/ > /dev/null && cd ../../${i}/\
    \ && echo `expr $j - 1)`)))\n    done\n    # Print the last number if $n is odd\
    \ and $n is even.\n    if [ $(( $n % 2 )) -ne 0 ]; then\n        echo $n\n   \
    \     count=$((count + $n))\n    fi\n    return $count\n}\n\ncandidate() {\n \
    \   starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpkl09ws9p.sh: line 13: unexpected EOF while looking for matching
    ``''

    /tmp/tmpkl09ws9p.sh: line 37: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local i\n    local result\n    if [[\
    \ $n -lt 10 ]]; then\n        result=1\n        for i in $(seq $n -1 -1 -1); do\n\
    \            result=$(($result + $(expr ${i} % 10 == 1)))\n        done\n    elif\
    \ [[ $n -gt 10 ]]; then\n        result=$(expr $(expr ${n} % 10) + 1)\n    else\n\
    \        echo \"Error: n is too large.\"\n    fi\n    echo $result\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "seq: extra operand \u2018-1\u2019\nTry 'seq --help' for more information.\n\
    seq: extra operand \u2018-1\u2019\nTry 'seq --help' for more information.\n"
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local num_args=$#\n  local num_args=$((num_args > 0 ? num_args\
    \ : 1))\n  local i\n  local length=\"${1:-${num_args}}\"\n  local start\n  local\
    \ end\n  local count\n  local number_to_count\n  local number_found\n  local number_not_found\n\
    \  local digits\n  local n\n\n  # If no length is specified, default to $num_args.\n\
    \  case ${num_args} in\n    1)\n      number_to_count=${1}\n      (( num_args\
    \ = 2 ))\n      ;;\n    *)\n      number_to_count=${num_args}\n      (( num_args\
    \ = 1 ))\n      ;;\n  esac\n\n  (( num_args = $num_args - 1 ))\n\n  # Set the\
    \ \"found\" flag.\n  number_found=0\n  number_not_found=0\n\n  while [[ $number_to_count\
    \ -ne 0 ]]; do\n    # Grab the next number.\n    (( number_to_count -= 1 ))\n\
    \    number_found=1\n    number_not_found=0\n    (( i = 1 ))\n\n    # Loop until\
    \ we find one that starts with 1.\n    while [[ $(( i * 10 )) -lt $(( length -\
    \ 1 )) ]]; do\n      # Make sure we don't go past the end.\n      if [[ $(( i\
    \ * 10 )) -gt $(( length - 1 )) ]]; then\n        break\n      fi\n      # Make\
    \ sure we haven't already found this number.\n      if [[ $(( number_found ))\
    \ == 0 ]]; then\n        (( number_found = 1 ))\n        break\n      fi\n   \
    \   (( i++ ))\n    done\n    # Make sure we haven't already found this number.\n\
    \    if [[ $(( number_found )) == 0 ]]; then\n      # Make sure we don't go past\
    \ the end.\n      if [[ $(( i * 10 )) -gt $(( length - 1 )) ]]; then\n       \
    \ break\n      fi\n      (( number_not_found = 1 ))\n    fi\n\n    # Count the\
    \ digits in the number.\n    digits=0\n    while (( i )) do\n      (( i /= 10\
    \ ))\n      digits=$(( digits + 1 ))\n    done\n\n    # Make sure we haven't already\
    \ found this number.\n    if [[ $(( number_found )) == 0 ]]; then\n      (( number_not_found\
    \ = 1 ))\n    fi\n\n    if [[ $(( number_not_found )) == 1 ]]; then\n      ((\
    \ count = number_found ))\n    elif [[ $(( number_not_found )) == 0 ]]; then\n\
    \      (( count = number_not_found ))\n    fi\n\n    echo ${number_to_count}\n\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmplaim0uvo.sh: line 69: syntax error near unexpected token `do''

    /tmp/tmplaim0uvo.sh: line 69: `    while (( i )) do''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    local cur=1\n    while\
    \ [ $cur -le $n ]; do\n        if [ $cur -eq 1 ]; then\n            ((count++))\n\
    \        elif [ $cur -eq 0 ]; then\n            ((count--))\n        fi\n    \
    \    cur=$((cur+1))\n    done\n    return $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local number=$1\n  (( n < 0 )) || return 1\n\n  local count=0\n\
    \  local remainder=n\n  while (( remainder > 0 )) ; do\n    (( remainder = remainder\
    \ % 10 ))\n    (( count++ ))\n    [ $remainder -eq 1 ] && break\n  done\n\n  return\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $1 -lt 10 ]\n  then\n    echo 'usage: starts_one_ends\
    \ [positive integer]'\n    return 1\n  fi\n\n  if [ $1 -gt 9999 ]\n  then\n  \
    \  echo 'usage: starts_one_ends [positive integer]'\n    return 1\n  fi\n\n  local\
    \ n=$1\n  local count=0\n\n  # the numbers from 1 to 10\n  for ((i=1; i<=10; i=i+1))\n\
    \  do\n    local ii=i\n    while [ $((ii)) -ge 10 ]\n    do\n      # check whether\
    \ $ii is divisible by n\n      [ $((ii%n)) -eq 0 ] && break\n      ii=$((ii/10))\n\
    \    done\n    if [ $((ii)) -eq 1 ]\n    then\n      count=$((count+1))\n    fi\n\
    \  done\n\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  declare -i n=$1 count=1\n  for ((i=0; i < n; i++))\n  \
    \  (( i % 10 )) && continue\n    (( i % 100 )) && continue\n    (( i % 1000 ))\
    \ && continue\n    (( i % 10000 )) && continue\n    (( i % 100000 )) && continue\n\
    \    (( i % 1000000 )) && continue\n    (( i % 10000000 )) && continue\n    ((\
    \ i % 100000000 )) && continue\n    (( i % 1000000000 )) && continue\n    (( i\
    \ % 10000000000 )) && continue\n    (( i % 100000000000 )) && continue\n    ((\
    \ i % 1000000000000 )) && continue\n    (( i % 10000000000000 )) && continue\n\
    \    (( i % 100000000000000)) && continue\n    (( i % 1000000000000000)) && continue\n\
    \    (( i % 10000000000000000)) && continue\n    (( i % 100000000000000000)) &&\
    \ continue\n    (( i % 1000000000000000000)) && continue\n    (( i == n-1 )) &&\
    \ count++\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpyijutnw_.sh: line 9: syntax error near unexpected token ` i % 10
    ''

    /tmp/tmpyijutnw_.sh: line 9: `    (( i % 10 )) && continue''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n\n  local count\n  count=0\n  for (( k=0 ;\
    \ k<=n ; k++ ))\n  do\n    if (( k%10 ))\n    then\n      if (( k%100 ))\n   \
    \   then\n        if (( k%1000 ))\n        then\n          if (( k%10000 ))\n\
    \          then\n            if (( k%100000 ))\n            then\n           \
    \   if (( k%1000000 ))\n              then\n                if (( k%10000000 ))\n\
    \                then\n                  if (( k%100000000 ))\n              \
    \    then\n                    (( count++ ))\n                  fi\n         \
    \       fi\n              fi\n            fi\n          fi\n        fi\n     \
    \ fi\n    fi\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local -r count=0\n  (( n > 0 )); # n > 0\n\
    \  (( n % 10 == 0 )); # n % 10 == 0\n  local last=1\n  local start=1\n  while\
    \ (( n >= 10 )); do\n    (( last = n % 10 )); # last is last digit of n\n    ((\
    \ n == start * 10 + last )); # n == start * 10 + last\n    (( start *= 10 ));\
    \ # start is 10 ** start\n    (( n-- )); # n is n / 10\n    (( count++ )); # count\
    \ is count + 1\n  done\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n starts_one_ends\n\n  # Check that the input is\
    \ valid\n  if [ -z \"$1\" ]\n  then\n    return 0\n  fi\n\n  # Initialize variables\n\
    \  starts_one_ends=\"$1 $2 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13\
    \ 1 14 1 15 1 16 1 17 1 18 1 19 1 20 1 21 1 22 1 23 1 24 1 25 1 26 1 27 1 28 1\
    \ 29 1 30 1 31 1 32 1 33 1 34 1 35 1 36 1 37 1 38 1 39 1 40 1 41 1 42 1 43 1 44\
    \ 1 45 1 46 1 47 1 48 1 49 1 50 1 51 1 52 1 53 1 54 1 55 1 56 1 57 1 58 1 59 1\
    \ 60 1 61 1 62 1 63 1 64 1 65 1 66 1 67 1 68 1 69 1 70 1 71 1 72 1 73 1 74 1 75\
    \ 1 76 1 77 1 78 1 79 1 80 1 81 1 82 1 83 1 84 1 85 1 86 1 87 1 88 1 89 1 90 1\
    \ 91 1 92 1 93 1 94 1 95 1 96 1 97 1 98 1 99 1 100\"\n\n  # Loop over all numbers\
    \ 1...n\n  for (( i=1; i<=$(($1+1)) ))\n  do\n    # Increment the counters\n \
    \   starts_one_ends=\"$starts_one_ends $2 $(($1-1))\"\n  done\n\n  # Return the\
    \ count\n  echo \"$starts_one_ends\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpuwrn3rzx.sh: line 19: syntax error: arithmetic expression required

    /tmp/tmpuwrn3rzx.sh: line 19: syntax error: `(( i=1; i<=$(($1+1)) ))''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    for (( i=1; i<=$n;\
    \ i++ )); do\n        if [[ $(($i % 10)) -eq 1 && $(($i % 10)) -eq 1 ]]; then\n\
    \            count=$(( count + 1 ))\n        elif [[ $(($i % 10)) -eq 0 && $(($i\
    \ % 10)) -eq 1 ]]; then\n            count=$(( count + 1 ))\n        elif [[ $(($i\
    \ % 10)) -eq 1 && $(($i % 10)) -eq 0 ]]; then\n            count=$(( count + 1\
    \ ))\n        fi\n    done\n    echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo $1 | grep -o \"1{${1}}$\"\n}\n\ncandidate() {\n  \
    \  starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n\n    for (( i=0; i <\
    \ n; i++ )); do\n        if (( i % 10 == 1 || i % 10 == 9 )); then\n         \
    \   (( count++ ))\n        fi\n    done\n\n    echo $count\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal n=$1\n\tlocal count=0\n\tlocal i=2\n\twhile [ \"\
    $i\" -le \"$n\" ]; do\n\t\t(( count += 1 ))\n\t\t(( i -= 1 ))\n\tdone\n\treturn\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [ $# -ne 1 ]; then\n    echo \"Usage: $0 integer_to_count\"\
    \n  fi\n\n  local integer=$1\n\n  local count=0\n\n  while (( $integer > 0 ));\
    \ do\n    local digit=$(( $integer % 10 ))\n\n    if [ $digit -eq 1 ]; then\n\
    \      (( count++ ))\n    fi\n\n    local remainder=$(( $integer / 10 ))\n   \
    \ integer=$remainder\n  done\n\n  echo $count\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo \"${1}\" | while read line\n  do\n    [ $line == 1\
    \ ] && echo \"$((${line}-1))\"\n  done\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local sum=0\n    if [ $n -eq 0 ]; then\n\
    \        return 1\n    elif [ $n -lt 10 ]; then\n        sum=starts_one_ends $(($n\
    \ - 1))\n    elif [ $n -ge 10 ]; then\n        local b=$(($n % 10) + 1)\n    \
    \    local c=$((10#$n - b) + 1)\n        sum=$((sum + starts_one_ends $c))\n \
    \   fi\n    echo $((sum + 1))\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpie5ggf76.sh: line 12: 0: command not found

    /tmp/tmpie5ggf76.sh: line 12: 1: command not found

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n starts_one=0\n    local i j num\n    # Read n\n\
    \    read n\n    \n    # Read the list of numbers\n    read -r -d '' -a nums\n\
    \    \n    # Iterate over array nums\n    for ((i=0; i<${#nums[@]}; i++)); do\n\
    \        # Get integer value of current number in array nums\n        j=$(echo\
    \ \"${nums[$i]}\" | sed -e 's/^ *//' -e 's/ *$//')\n        \n        # If current\
    \ number starts with 1, add 1 to starts_one\n        if [ $j == 1 ]; then\n  \
    \          starts_one=$(( starts_one + 1 ))\n        fi\n        \n        # If\
    \ current number ends with 1, add 1 to ends_one\n        if [ $(( (j+1) - 1 ))\
    \ -eq $n ]; then\n            starts_one=$(( starts_one + 1 ))\n        fi\n \
    \   done\n    \n    echo \"$starts_one\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=39 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=16 encoding='utf-8'>
  timestamp: 1660059162
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    n=$1\n    if [ \"$n\" -lt 2 ] ; then echo \"n must be\
    \ greater than 1\"; return; fi\n    i=2\n    while [ $i -le $n ]; do\n       \
    \ echo \"$i $(( (i % 100) ))\"\n        i=$(( $i + 1 ))\n    done\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n\n  ((n = ${1}))\n\n  (( ${#n} >= 0 ))\n  (( ${#n}\
    \ != 10 ))\n  (( ${#n} != 11 ))\n\n  (( ${#n} >= 3 ))\n\n  # If the first character\
    \ is 1 then there is only 1 starting or ending 1.\n  # If it is 0, then there\
    \ are 0 or 1 starting or ending 1s.\n  (( ${#n} >= 1 && ${n} == 1 ))\n\n  # If\
    \ the first character is 0 then there is one starting or ending 1.\n  # If it\
    \ is 1, then there are 0 or 1 starting or ending 1s.\n  (( ${#n} >= 1 && ${n}\
    \ == 0 ))\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local c=0\n  (( n > 0 )); # Avoid negative\
    \ zero\n  (( n == 0 || n == 1 )); # Avoid single digit\n  (( n == 1 )); # Avoid\
    \ starting with 1\n  (( n > 1 )); # Avoid ending with a zero\n  for i in {1..n};\
    \ do\n    (( i ));\n    (( c++ ));\n  done\n  echo $c\n}\n\ncandidate() {\n  \
    \  starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_yjvtovr.sh: line 14: ((: {1..n}: syntax error: operand expected
    (error token is "{1..n}")

    /tmp/tmp_yjvtovr.sh: line 14: ((: {1..n}: syntax error: operand expected (error
    token is "{1..n}")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tlocal n=$1\n\tlocal -a starts=()\n\tlocal -a ends=()\n\t\
    local i\n\tlocal num=0\n\n\tfor i in $(seq $n); do\n\t\tlocal j\n\t\tlocal num=$(($(($i-1)*n+1)\
    \ % $n))\n\t\tlet num=$num+1\n\t\tif [ $num -gt $n ]; then num=$((num%$n)); fi\n\
    \t\tstarts+=( $(($i-1)*n+1)/$n )\n\t\tends+=( $num/$n )\n\tdone\n\n\tlocal -a\
    \ counts=()\n\tfor (( i=0; i<${#starts[@]}; i++ )); do\n\t\tif [ ${starts[$i]}\
    \ == ${ends[$i]} ]; then\n\t\t\tcounts[$i]=$((${counts[$i]}+1))\n\t\telse\n\t\t\
    \tcounts[$i]=1\n\t\tfi\n\tdone\n\n\techo ${counts[@]}\n}\n\ncandidate() {\n  \
    \  starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpw_vghl7_.sh: command substitution: line 15: syntax error near unexpected
    token `*n+1''

    /tmp/tmpw_vghl7_.sh: command substitution: line 15: `($i-1)*n+1''

    /tmp/tmpw_vghl7_.sh: line 15: % 1: syntax error: operand expected (error token
    is "% 1")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ \"$1\" -lt 1 ]; then\n        echo \"Usage: $0 n\"\
    \n        return 1\n    fi\n    local n=$1\n    local -i ones=0\n    while [ $n\
    \ -gt 0 ]; do\n        if [ $((n % 10)) -eq 1 ]; then\n            if [ $((n %\
    \ 100)) -eq 1 ]; then\n                if [ $((n % 1000)) -eq 1 ]; then\n    \
    \                ((ones++))\n                else\n                    ((ones++))\n\
    \                fi\n            else\n                ((ones++))\n          \
    \  fi\n        else\n            ((ones++))\n        fi\n        n=$((n-1))\n\
    \    done\n    echo \"$ones\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    while [ $n -gt 0 ];\
    \ do\n        local digit=$((n%10))\n        if [ $digit -eq 1 ]; then\n     \
    \       count=$((count+1))\n        elif [ $digit -eq 0 ]; then\n            count=$((count-1))\n\
    \        fi\n        n=$((n/10))\n    done\n    echo $count\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  starts_one_ends \"$1\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059162
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  (( num=$1 ))\n  (( ones=0 ))\n  (( zeros=0 ))\n  (( threes=0\
    \ ))\n  (( tens=0 ))\n  (( hundreds=0 ))\n  (( thousands=0 ))\n\n  while (( num\
    \ > 0 )); do\n    (( num-- ))\n    case $(expr $(echo \"${num}\" | cut -c1) in\n\
    \      \"1\") (( ones++ ))\n        ;;\n      \"0\") (( zeros++ ))\n        ;;\n\
    \      \"3\") (( threes++ ))\n        ;;\n      \"10\") (( tens++ ))\n       \
    \ ;;\n      \"100\") (( hundreds++ ))\n        ;;\n      \"1000\") (( thousands++\
    \ ))\n        ;;\n    esac\n  done\n\n  echo \"${#ones} ones, ${#zeros} zeroes,\
    \ ${#threes} threes, ${#tens} tens, ${#hundreds} hundreds, ${#thousands} thousands\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpm486enra.sh: line 18: syntax error near unexpected token `(''

    /tmp/tmpm486enra.sh: line 18: `      "1") (( ones++ ))''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\t(( $# != 1 )) && return 1\n\tlocal -r n=$1\n\t(( n > 0\
    \ )) && return 0\n\tlocal -r ret=0\n\tlocal -r i\n\t(( n > 0 )) || return 0\n\t\
    (( n == 0 )) || return 0\n\t(( n == 1 )) && return 0\n\tfor (( i = 2; i <= n;\
    \ i++ )); do\n\t\t(( i % 10 == 0 )) && ret=$(expr $ret + 1)\n\t\t(( i % 100 !=\
    \ 0 )) || ret=$(expr $ret + 1)\n\t\t(( i % 10000 != 0 )) || ret=$(expr $ret +\
    \ 1)\n\t\t(( i % 100000 == 0 )) && ret=$(expr $ret + 1)\n\t\t(( i % 1000000 ==\
    \ 0 )) || ret=$(expr $ret + 1)\n\tdone\n\treturn $ret\n}\n\ncandidate() {\n  \
    \  starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local count=0\n  local n1=$(seq $n)\n  local\
    \ n2=$(seq $n)\n\n  # Count number of 1-digit 1-digit numbers that start or end\
    \ with 1.\n  for n1 in $n1; do\n    # Loop through all remaining 1-digit numbers,\
    \ adding 1 each time\n    # it starts or ends with 1.\n    for n2 in $n2; do\n\
    \      if [[ $n1 == 1 ]] && [[ $n2 == 1 ]]; then\n        ((count++))\n      fi\n\
    \    done\n  done\n  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # shellcheck disable=SC2086\n  local n=$1\n  local count=0\n\
    \  local i\n  for i in {1..n}; do\n    (( n % i == 0 )&& count+=1 )\n  done\n\
    \  echo \"$count\"\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpg8luhvwv.sh: line 12: n: command not found

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  declare -i n_ends=0\n  for ((i=0; i < $1; i++)); do\n \
    \   ((n_ends+=(( $i != 0 ) && ($((10#$i)) %% $1 == 0))))\n  done\n  echo \"$n_ends\"\
    \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n\
    \    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp690vm3_z.sh: line 9: ((: n_ends+=(( 0 != 0 ) && (0 %% 1 == 0)):
    syntax error: operand expected (error token is "% 1 == 0))")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    echo \"$n\" | bc -l\n    local ndigits=$((\
    \ ( \"$1\" + 1 ) / 10 ))\n    for i in $(seq 1 \"$ndigits\"); do\n        if [\
    \ $(( \"$1\" + 1 )) -lt 10 ]; then\n            echo \"$(( $i - 1 ))\"\n     \
    \   else\n            echo \"$(( $i - 2 ))\"\n        fi\n        local next=$((\
    \ ( \"$1\" + 1 ) % 10 ))\n        if [ $next -eq 0 ]; then\n            echo \"\
    $(( $i - 1 ))\"\n        else\n            echo \"$(( $i - 2 ))\"\n        fi\n\
    \    done\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  echo $1\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  n=$1\n  # start count at zero\n  count_start=0\n  # end\
    \ count at zero\n  count_end=0\n  # loop over every number less than n\n  for\
    \ ((i=0; i<${n}; i++))\n  do\n    # start is all numbers with 1 to the left of\
    \ the number\n    # end is all numbers with 1 to the right of the number\n   \
    \ start=$(printf \"%${i}d\" $1)\n    end=$(printf \"%${i}d\" $((${n}-${i})))\n\
    \    if [ $((${start}%2)) -eq 0 ]\n    then\n      count_start=$((${count_start}+1))\n\
    \    else\n      count_end=$((${count_end}+1))\n    fi\n  done\n  printf \"count_start=%d\
    \ count_end=%d\\n\" $count_start $count_end\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    if [ $n -eq 1 ]; then\n        return\
    \ 1\n    fi\n    local sum=0\n    for i in {1..10}; do\n        if [ $(( $i %\
    \ $n )) -eq 1 ]; then\n            sum=$(( $sum + 1 ))\n        fi\n    done\n\
    \    return $sum\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=\"$1\"\n    echo \"$(( 10#$n ))\"\n    echo \"\
    $(( 10#$n ))\" > /tmp/1\n    local count=\"$(grep -c '^1' /tmp/1)\"\n    echo\
    \ \"$(( 10#$n ))\" >> /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    local count2=\"\
    $(grep -c '^1' /tmp/2)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n\
    \ ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local count3=\"$(grep\
    \ -c '^1' /tmp/3)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\"\
    \ > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n    local count4=\"$(grep -c '^1'\
    \ /tmp/4)\"\n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n\
    \    echo \"$(( 10#$n ))\" > /tmp/3\n    local count5=\"$(grep -c '^1' /tmp/5)\"\
    \n    echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo\
    \ \"$(( 10#$n ))\" > /tmp/3\n    local count6=\"$(grep -c '^1' /tmp/6)\"\n   \
    \ echo $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"\
    $(( 10#$n ))\" > /tmp/3\n    local count7=\"$(grep -c '^1' /tmp/7)\"\n    echo\
    \ $(( 10#$n )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n\
    \ ))\" > /tmp/3\n    local count8=\"$(grep -c '^1' /tmp/8)\"\n    echo $(( 10#$n\
    \ )) > /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" >\
    \ /tmp/3\n    local count9=\"$(grep -c '^1' /tmp/9)\"\n    echo $(( 10#$n )) >\
    \ /tmp/1\n    echo \"$(( 10#$n ))\" > /tmp/2\n    echo \"$(( 10#$n ))\" > /tmp/3\n\
    \    local count10=\"$(grep -c '^1' /tmp/10)\"\n    echo \"$(( \n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpzdzsuv0r.sh: line 46: unexpected EOF while looking for matching
    `)''

    /tmp/tmpzdzsuv0r.sh: line 63: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local count=0\n    while [ \"$n\" -gt\
    \ 0 ]\n    do\n        count=`expr $count + 1`\n        if [ \"$n\" -lt 10 ];\
    \ then\n            (( n = $n*10 + 1 ))\n        else\n            (( n = $n/10\
    \ ))\n        fi\n    done\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=58 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=67 encoding='utf-8'>
  timestamp: 1660059162
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ $1 -lt 1 ]\n    then\n        return 0\n    fi\n\
    \n    local i j count=0\n    local a\n    while [ $1 -gt 0 ]; do\n        a=$(expr\
    \ $1/10 | bc)\n        if [ \"$(expr \"$a\" + *1)\" == \"$a\" ]\n        then\n\
    \            (( count++ ))\n            (( i=0 ))\n            continue\n    \
    \    fi\n        i=$(( $i+1 ))\n        (( j=$i ))\n        (( count=$(( $count\
    \ + (( $1 mod $j ) == 0) && (( $j + 1 < $1 ) )) ))\n        (( i=0 ))\n    done\n\
    \    echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpufqu9a1n.sh: line 25: syntax error near unexpected token `(''

    /tmp/tmpufqu9a1n.sh: line 25: `        (( i=0 ))''

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n sum\n  for ((n=$1; n>0; n--))\n  do\n    sum=0\n\
    \    for (( i=0; i<n; i++ ))\n    do\n      if (( $(( n+i-i )) ))\n      then\n\
    \        sum=$(( sum + 1 ))\n      fi\n    done\n  done\n  echo $sum\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local digit=$1\n    local numbers=$2\n    local starts_one_ends=$((\
    \ numbers / 10 ))\n    for (( i = 1; i <= numbers; i++ )); do\n        local ends_one=$(\n\
    \            echo '($ends_one_${digit})' |\n            bash <<<$'\n         \
    \       export ends_one_$digit='$(( i % 10 ))'\n            ')\n        if [ $i\
    \ -eq $starts_one_ends ]; then\n            starts_one_ends+=$ends_one\n     \
    \   fi\n    done\n    echo $starts_one_ends\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local -n count=\"$1\"\n  local -n n=\"$2\"\n\n  (( $n >\
    \ 0 )) || return 1\n\n  # This loop is unrolled to loop only once, for speed\n\
    \  for (( i = 0; i < n; i++ )); do\n    (( count[$(expr $i + 1)] )) ||\n     \
    \ (( count[$(expr $i + 1)] = 1 ))\n  done\n\n  echo $n\n}\n\ncandidate() {\n \
    \   starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpnftarc0s.sh: line 7: local: `1'': invalid variable name for name
    reference

    /tmp/tmpnftarc0s.sh: line 8: local: `'': not a valid identifier

    /tmp/tmpnftarc0s.sh: line 10: ((: > 0 : syntax error: operand expected (error
    token is "> 0 ")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local -i start_end count=0\n    while (( start_end <\
    \ ${#1} )); do\n        if [ $(( ${#1} - start_end - 1 )) -eq 1 ]; then\n    \
    \        (( start_end++))\n        else\n            break\n        fi\n    done\n\
    \    if (( start_end == ${#1} )); then\n        echo \"0\"\n    else\n       \
    \ (( start_end++ ))\n        while (( start_end < ${#1} )); do\n            if\
    \ [ ${#1} -ge $start_end ] && [ ${#1} -le $(( $start_end + $2 )) ]; then\n   \
    \             (( start_end++ ))\n            else\n                break\n   \
    \         fi\n        done\n        count=$(echo $(( ${#1} - $start_end )) | bc)\n\
    \    fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n   local n=$1 count=0\n   local z\n\n   if [ \"$n\" = 1 ];\
    \ then\n      echo $n\n   else\n      echo 1\n      while (( n > 0 )); do\n  \
    \       z=$(( n / 10 ))\n         if [ $z -eq 1 ]; then\n            (( count++\
    \ ))\n         fi\n         n=$(( n - z ))\n      done\n   fi\n   echo $count\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local x=\"$1\"\n    local y\n    local z\n    local count\n\
    \    local n\n    local w\n\n    if [[ $n -lt 1 || $n -gt 10 ]]; then\n      \
    \  return 0\n    fi\n\n    if [[ $(( n - 1 )) -eq 0 ]]; then\n        return 1\n\
    \    fi\n\n    if (( x % 10 == 1 )) && (( x % 10 == 0 ))\n    then\n        if\
    \ [[ $(( n - 2 )) -eq 0 ]]; then\n            return 1\n        fi\n        ((\
    \ count++ ))\n    elif [[ $(( n - 2 )) -eq 1 ]]; then\n        (( count++ ))\n\
    \    elif [[ $(( n - 3 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $((\
    \ n - 4 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 5 )) -eq\
    \ 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 6 )) -eq 1 ]]; then\n\
    \        (( count++ ))\n    elif [[ $(( n - 7 )) -eq 1 ]]; then\n        (( count++\
    \ ))\n    elif [[ $(( n - 8 )) -eq 1 ]]; then\n        (( count++ ))\n    elif\
    \ [[ $(( n - 9 )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 10\
    \ )) -eq 1 ]]; then\n        (( count++ ))\n    elif [[ $(( n - 11 )) -eq 1 ]];\
    \ then\n        (( count++ ))\n    elif [[ $(( n - 12 )) -eq 1 ]]; then\n    \
    \    (( count++ ))\n    elif [[ $(( n - 13 )) -eq 1 ]]; then\n        (( count++\
    \ ))\n    elif [[ $(( n - 14 )) -eq 1 ]]; then\n        (( count++ ))\n    elif\
    \ [[ $(( n - 15 )) -eq 1 ]]; then\n        (( count++ ))\n    fi\n\n    while\
    \ (( n >= 100 ))\n    do\n        if [[ $(( n - 100 )) -eq 1 ]]; then\n      \
    \      (( count++ ))\n        fi\n        n=$(( n - 10 ))\n    done\n\n    while\
    \ (( n >= 10 ))\n    do\n        if [[ $(( n - 10 )) -eq 1 ]]; then\n        \
    \    (( count++ ))\n        fi\n        n=$(( n - 1 ))\n    done\n\n    if ((\
    \ n >= 1 ))\n    then\n        (( count++ ))\n    fi\n\n\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [[ $1 != 0 ]]; then\n        return 0\n    fi\n  \
    \  local i j\n    for i in {0..9}; do\n        j=$(expr $i + 1)\n        if [[\
    \ $j -eq $1 ]]; then\n            return $((j - 1))\n        fi\n    done\n  \
    \  return $((10 - 1))\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"\
    2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"\
    4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if (( $# != 1 )); then\n    echo \"Usage: $0 integer\"\
    \ >&2\n    exit 1\n  fi\n\n  local integer n digit count\n  integer=$1\n\n  n=0\n\
    \  while (( $integer > 0 )); do\n    n=$(($n + 1))\n    integer=$(($integer /\
    \ 10))\n  done\n\n  digit=$(($n - 1))\n  count=$(($integer % $digit))\n\n  echo\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp95qcpcqe.sh: line 22: 0 % 0: division by 0 (error token is "0")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local -i count=0\n\n    if [[ $n -lt\
    \ 10 ]]; then\n        return 0\n    fi\n\n    for (( i=1; i<=n; i++ )); do\n\
    \        [[ $(( i % 10 )) -eq 1 ]] && count=$(( count + 1 ))\n        [[ $(( n\
    \ % 10 )) -eq 1 ]] && count=$(( count + 1 ))\n    done\n\n    echo \"$count\"\n\
    }\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n \
    \   [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n\
    \    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    (( $# > 1 ))\n    local num=\"$1\"\n    local n=\"$2\"\
    \n    local zero=\"000000000\"\n    # Count 1s\n    local count=0\n    while [[\
    \ $num -lt 10 ]]; do\n        (( num *= 10 ))\n        (( n-- ))\n        (( num\
    \ *= 10 ))\n        (( n-- ))\n        (( num *= 10 ))\n        (( n-- ))\n  \
    \      (( num *= 10 ))\n        (( n-- ))\n        (( num *= 10 ))\n        ((\
    \ n-- ))\n        count=$(( count + 1 ))\n    done\n    # Count leading zeros\n\
    \    local count=0\n    while [[ ${num:0:1} =~ ^0+$ ]]; do\n        (( n-- ))\n\
    \        (( num *= 10 ))\n        (( count++ ))\n    done\n    # Count trailing\
    \ zeros\n    count=0\n    while [[ ${num:(-1)} =~ ^0+$ ]]; do\n        (( n--\
    \ ))\n        (( num *= 10 ))\n        (( count++ ))\n    done\n    echo $(( $count\
    \ - $(n) ))\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpqujckb1y.sh: line 40: n: command not found

    /tmp/tmpqujckb1y.sh: line 40: 14 -  : syntax error: operand expected (error token
    is "-  ")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    (($# == 0)) && return 0\n\n    local digit=\"$1\"\n \
    \   ((${#digit} < 0)) || return\n\n    local count=0\n    local num=1\n    local\
    \ i=2\n    while ((${#digit} > i)); do\n        [ \"${digit:$i:1}\" == '1' ] &&\
    \ count=$((${count}+1)) && break\n        ((i+=1))\n    done\n\n    ((${#digit}\
    \ > i)) && count=$((${count}+1))\n    ((digit=0))\n\n    echo ${count}\n}\n\n\
    candidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [[ -n $1 ]]; then\n    local n=$1\n    local count=0\n\
    \    while [[ -n ${1#-} ]]; do\n      (( count++ ))\n      shift\n    done\n \
    \   while [[ ${count} -ne 0 ]]; do\n      (( count-- ))\n      [[ \"$1\" == \"\
    $(( n -1))\" ]] && break\n      shift\n    done\n    echo \"$count\"\n  else\n\
    \    echo 0\n  fi\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ $1 -le 0 ] ; then\n        echo \"usage: $0 integer\"\
    \n        return 1\n    fi\n    local n=$1\n    if [ $n -le 0 ] ; then\n     \
    \   echo \"usage: $0 integer\"\n        return 1\n    fi\n    local count=0\n\
    \    for (( i=1; i <= n; i++ )); do\n        (( i == 1 )) && continue\n      \
    \  (( i == n )) && break\n        local j=$(( i - 1 ))\n        (( j == 0 )) &&\
    \ continue\n        (( j == -1 )) && break\n        (( j * 10 + i - 1 == n ))\
    \ && count=$(( count + 1 ))\n    done\n    return $count\n}\n\ncandidate() {\n\
    \    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"\
    3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local x=1\n  local count=0\n  while [ $x\
    \ -le $n ]; do\n    if [ $x -eq $(( n - 1 )) ]; then\n      echo \"$count\"\n\
    \      break\n    fi\n    if [ $x -eq $(( n - 2 )) ]; then\n      if [ $x -eq\
    \ 1 ]; then\n        echo \"$count\"\n      fi\n      break\n    fi\n    count=$((\
    \ count + 1 ))\n    x=$(( x + 1 ))\n  done\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # TODO: This could be improved. A loop starting from 0\
    \ to $1 would\n  # be more efficient.\n  for (( i=1; i<=$1; i++ )); do\n    [[\
    \ \"$i\" -eq 1 ]] || continue\n    [[ \"$i\" -eq $1 ]] && return $(( $(i-1) +\
    \ $(i-2) + ... + $2 ))\n  done\n  return 0\n}\n\ncandidate() {\n    starts_one_ends\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n  \
    \  [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n\
    \    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptrp51nyy.sh: line 11: i-1: command not found

    /tmp/tmptrp51nyy.sh: line 11: i-2: command not found

    /tmp/tmptrp51nyy.sh: line 11: +  + ... +  : syntax error: operand expected (error
    token is "... +  ")

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    if [ \"$#\" -eq \"0\" ]; then\n        echo \"Error:\
    \ starts_one_ends needs one argument.\"\n        exit 1\n    fi\n\n    local integer=\"\
    $1\"\n\n    if [ \"$integer\" -gt 0 ]; then\n        local number\n        local\
    \ count\n        local i\n\n        number=0\n        count=0\n        i=0\n \
    \       while [[ $((i++)) -le \"$integer\" ]]; do\n            if [[ $(echo \"\
    $number % 10\" | bc | tr -d ' ') -eq 1 ]]; then\n                count=$((count+1))\n\
    \            fi\n            number=$(($number+1))\n        done\n        echo\
    \ $count\n    else\n        echo \"Error: negative or zero integer passed for\
    \ start.\"\n        exit 1\n    fi\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  # TODO(mbelshe): this currently counts 1's in the input\
    \ string\n  # TODO(mbelshe): this currently doesn't handle negative numbers\n\
    \  local n=$1\n  local count=0\n  local digits=$((10#$n))\n  local digits_minus_one=$((10#$(n-1)))\n\
    \  for (( i=1; i <= digits_minus_one; i++ )); do\n    (( digits_minus_one -= i\
    \ ))\n    (( digits_minus_one %= 10 ))\n    (( digits -= i ))\n    if (( digits\
    \ < n )); then\n      (( count++ ))\n    fi\n    (( digits /= 10 ))\n  done\n\
    \  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpzmubww13.sh: line 12: n-1: command not found

    '
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  if [[ $1 == \"${1:-}\" ]] || [[ -z $1 ]]; then\n    echo\
    \ \"${2:-No input given}\"\n    return 1\n  fi\n  local n=$1\n  local out\n  local\
    \ i\n  local cnt\n  out=''\n  cnt=0\n  for (( i=1; i<=n; i++ )); do\n    if [[\
    \ ${i} == ${i} ]] ; then\n      (( cnt++ ))\n      if [[ ${i} == 1 ]] ; then\n\
    \        out+=\"1\"\n      else\n        out+=\"${i}\"\n      fi\n    else\n \
    \     (( cnt-- ))\n      out+=\"${i}\"\n    fi\n  done\n  if [[ ${cnt} -gt 0 ]]\
    \ ; then\n    echo \"${out}\"\n  else\n    echo \"0\"\n  fi\n  return 0\n}\n\n\
    candidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local i=$1\n  local n=$2\n  (( n == 1 )) && return 0\n\
    \  (( n > 1 )) && return $(( starts_one_ends ( n-1 ) + 1 ))\n  (( n <= 1 )) &&\
    \ return 1\n  local count=0\n  while (( n % 10 == 1 )); do\n    count=$(($count+1))\n\
    \    n=$(( n/10 ))\n  done\n  (( n % 10 != 1 )) && count=$(($count+1))\n  return\
    \ $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\"\
    \ ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\"\
    \ ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  local i count=0\n  \n  (( $# )) || return\
    \ 1\n  \n  for (( i=1; ( ( i*i )<= n ); i++ )); do\n    if (( n % i == 0 )); then\n\
    \      (( count++ ))\n      if (( n % i == 1 )); then\n        break\n      fi\n\
    \    fi\n  done\n  \n  echo $count\n}\n\ncandidate() {\n    starts_one_ends \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[\
    \ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n   \
    \ [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local n1=${n}\n    local n2=${n}\n  \
    \  local i count\n    local base=1\n    while ((n1 != 1)); do\n        n1=${n1/$base}\n\
    \        count=$((count+1))\n        base=$((base+1))\n    done\n    while ((n2\
    \ != 1)); do\n        n2=${n2/$base}\n        count=$((count+1))\n        base=$((base+1))\n\
    \    done\n    echo $count\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1 starts_one_ends # local variable to ensure local\
    \ scope in function\n  starts_one_ends=\"$(echo \"$1\" | sed -n -e 's/^[0-9]*//'\
    \ -e 's/\\([1-9][0-9]*\\)\\([0-9]\\)/\\2\\1/p')\" # find n digits starting with\
    \ 1\n  printf \"%s\\n\" \"$starts_one_ends\" # return result\n  printf \"%d\\\
    n\" $(echo \"$starts_one_ends\" | wc -l | sed \"s/^ *//\") # print # of digits\
    \ starting with 1\n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate \"2\")\
    \ = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate \"4\"\
    ) = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n  local n=$1\n  # if n is less than one return 0\n  if [\
    \ $n -lt 1 ] ; then\n    echo \"0\"\n    return\n  fi\n  # if n is 1, return n\n\
    \  if [ $n = \"1\" ] ; then\n    echo \"$n\"\n    return\n  fi\n  # if n is 2,\
    \ return 1\n  if [ $n = \"2\" ] ; then\n    echo \"1\"\n    return\n  fi\n  #\
    \ if n is 3, return 0\n  if [ $n = \"3\" ] ; then\n    echo \"0\"\n    return\n\
    \  fi\n  # if n is 4, return 2\n  if [ $n = \"4\" ] ; then\n    echo \"2\"\n \
    \   return\n  fi\n  # if n is 5, return 1\n  if [ $n = \"5\" ] ; then\n    echo\
    \ \"1\"\n    return\n  fi\n  # if n is 6, return 1\n  if [ $n = \"6\" ] ; then\n\
    \    echo \"1\"\n    return\n  fi\n  # if n is 7, return 2\n  if [ $n = \"7\"\
    \ ] ; then\n    echo \"2\"\n    return\n  fi\n  # if n is 8, return 1\n  if [\
    \ $n = \"8\" ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is 9, return\
    \ 1\n  if [ $n = \"9\" ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is\
    \ 10, return 0\n  if [ $n = \"10\" ] ; then\n    echo \"0\"\n    return\n  fi\n\
    \  # if n is 11, return 0\n  if [ $n = \"11\" ] ; then\n    echo \"0\"\n    return\n\
    \  fi\n  # if n is 12, return 0\n  if [ $n = \"12\" ] ; then\n    echo \"0\"\n\
    \    return\n  fi\n  # if n is 13, return 1\n  if [ $n = \"13\" ] ; then\n   \
    \ echo \"1\"\n    return\n  fi\n  # if n is 14, return 1\n  if [ $n = \"14\" ]\
    \ ; then\n    echo \"1\"\n    return\n  fi\n  # if n is 15, return 2\n  if [ $n\
    \ = \"15\" ] ; then\n    echo \"2\"\n    return\n  fi\n  # if n is 16, return\
    \ 1\n  if [ $n = \"16\" ] ; then\n    echo \"1\"\n    return\n  fi\n  # if n is\
    \ 17, return 1\n  if [ $n = \"17\" ] ; then\n    echo \"1\"\n    return\n  fi\n\
    \  # if n is 18, return 2\n  if [ $n = \"18\" ] ; then\n    echo \"2\"\n    return\n\
    \  fi\n  # if n is 19, return 1\n  if [ $n = \"19\" ] ; then\n    echo \"1\"\n\
    \    return\n  fi\n  # if \n}\n\ncandidate() {\n    starts_one_ends \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"1\") = \"1\" ]]\n    [[ $(candidate\
    \ \"2\") = \"18\" ]]\n    [[ $(candidate \"3\") = \"180\" ]]\n    [[ $(candidate\
    \ \"4\") = \"1800\" ]]\n    [[ $(candidate \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n\tif [ $1 -eq 1 ] ; then\n\t\techo \"1\"\n\telse\n\t\techo\
    \ \"$(expr $(echo \"$1\" | sed -e \"s/\\(.*\\)\\(.\\)\\(\\1\\)$/\\1\\2/g\") -\
    \ $(echo \"$1\" | sed -e \"s/\\(.*\\)\\(..\\)$/\\1\\2/g\"))\"\n\tfi\n}\n\ncandidate()\
    \ {\n    starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"1\") = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate\
    \ \"3\") = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate\
    \ \"5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive integer n, return the count of the numbers\
    \ of n-digit\n# positive integers that start or end with 1.\n#\n# $1 is an integer\n\
    starts_one_ends() {\n    local n=$1\n    local result=0\n    local base=1\n  \
    \  while [ $n -gt 1 ]; do\n        (( result+=( $n%base ) ))\n        (( n//=base\
    \ ))\n        base*=10\n    done\n    echo \"$result\"\n}\n\ncandidate() {\n \
    \   starts_one_ends \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"1\"\
    ) = \"1\" ]]\n    [[ $(candidate \"2\") = \"18\" ]]\n    [[ $(candidate \"3\"\
    ) = \"180\" ]]\n    [[ $(candidate \"4\") = \"1800\" ]]\n    [[ $(candidate \"\
    5\") = \"18000\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660059157
