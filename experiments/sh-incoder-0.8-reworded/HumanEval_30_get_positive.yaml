name: HumanEval_30_get_positive
language: sh
prompt: "#!/bin/bash\n# Return only positive numbers in the list.\n# >>> $(get_positive\
  \ \"-1 2 -4 5 6\")\n# ['\"2\"', '\"5\"', '\"6\"']\n# >>> $(get_positive \"5 3 -5\
  \ 2 -3 3 9 0 123 1 -10\")\n# ['\"5\"', '\"3\"', '\"2\"', '\"3\"', '\"9\"', '\"123\"\
  ', '\"1\"']\n#\n# $1 is a space-separated list\nget_positive() {\n"
tests: "}\n\ncandidate() {\n    get_positive \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"-1 -2 4 5 6\") = \"4 5 6\" ]]\n    [[ $(candidate \"5 3 -5\
  \ 2 3 3 9 0 123 1 -10\") = \"5 3 2 3 3 9 123 1\" ]]\n    [[ $(candidate \"-1 -2\"\
  ) = \"\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n}\n\nrun_test"
completions: ["    local list positive\n    IFS=' ' read -r -a list <<<\"$1\"\n  \
    \  for e in \"${list[@]}\"; do\n        [[ $e =~ ^-([0-9]+|inf)$ ]] &&\n     \
    \       positive+=(\"$e\")\n    done\n    echo -n \"[\" ${positive[@]} ']'", " \
    \   local IFS=' '\n    shift\n    local positive=(\"$@\")\n    local j=0\n   \
    \ for element in \"${positive[@]}\"; do\n        [[ $element != *-* ]] && {\n\
    \            positive[j++]=\"$element\"\n        }\n    done\n    echo \"${positive[@]}\"",
  "    echo \"$(echo $1 | awk '{print gsub(/ +/,\"&\\\"\",$0)}')\"", "    local l=$1\n\
    \    local str=\"\"\n    local numbers=()\n    for str in ${l//[[:space:]]}; do\n\
    \        [[ \"${str}\" =~ ^-[0-9]+$ ]] || continue\n        numbers+=(\"${str}\"\
    )\n    done\n    echo \"${numbers[@]}\"", "    local a b c d e\n    for b in $(\
    \ echo $1 ); do\n        if [ \"$b\" -gt 0 ]; then\n            eval c=\\$$b\n\
    \            if [ -z \"$c\" ]; then\n                d=$(echo $b)\n          \
    \  else\n                d=$(echo \"$b $c\")\n            fi\n            eval\
    \ a=\\$$d\n            echo ${a// /$b}\n        fi\n    done", "\tlocal n=$1\n\
    \tshift\n\t\n\t# Split by spaces\n\tlocal a=($(echo $n | sed -e \"s/^ *//g\" -e\
    \ \"s/ *$//g\"))\n\t\n\t# Return only positive numbers\n\techo \"${a[@]}\"", " \
    \ local list=\"$1\"\n  # Strip off non-negative values\n  list=\"$(echo \"$list\"\
    \ | sed 's/^ *//;s/ *$//')\"\n  echo \"$(echo \"$list\" | grep ^-)\"", "    local\
    \ a b c\n    for a; do\n        # -n 'print only non-zero values' is not available\
    \ in dash\n        if [[ $(printf '%s\\n' \"$a\" | grep -E '^[-+]?[0-9]+$' | wc\
    \ -c) != $(echo -n \"$a\" | wc -c) ]]; then\n            echo \"$a\"\n       \
    \     continue\n        fi\n        # dash doesn't support negative numbers in\
    \ regex\n        b=$(echo \"$a\" | sed -r 's/^([-+]?[0-9]+)/\\1\"/' 2>/dev/null)\n\
    \        echo \"$b\"\n    done", "    # $1: space-separated list\n    # $2: minimum\
    \ positive number\n    # $3: minimum negative number\n    # return only positive\
    \ numbers in list\n    local _list _minimum _minimum _output _output_str\n   \
    \ local i j k _is_positive _is_negative _is_positive_found _is_negative_found\
    \ _is_negative_found\n\n    _minimum=${2:-0}\n    _output=$(_normalize_string\
    \ \"$1\")\n\n    for (( i = 0; i < ${#_output[@]}; ++i )); do\n        _is_positive=\"\
    ${_output[$i]}\" == \"+\" || \"$_output[$i]\" == \"-\"\n        _is_positive_found=0\n\
    \        _is_negative_found=0\n\n        for (( j = 0; i < ${#_output[@]}; ++j\
    \ )); do\n            if [[ $_output[$j] == \"-\" ]] && ! _is_positive_found;\
    \ then\n                _is_positive_found=1\n            elif [[ $_output[$j]\
    \ == \"+\" ]] && ! _is_negative_found; then\n                _is_negative_found=1\n\
    \            fi\n        done\n\n        if [[ $_is_positive_found -eq 0 ]] &&\
    \ [[ $_is_negative_found -eq 0 ]]; then\n            if [[ $_minimum -gt 0 &&\
    \ ${_output[$i]} -le $(( ${_minimum} + 1 )) ]]; then\n                _output_str=\"\
    ${_output[$i]}\"\n            fi\n        elif [[ $_is_positive_found -eq 1 ]]\
    \ && [[ $_is_negative_found -eq 1 ]]; then\n            _output_str=\"${_output[$i]}+${_output[$j-1]}\"\
    \n        else\n            _output_str=\"${_output[$i]}-${_output[$j-1]}\"\n\
    \        fi\n\n        _output[$i]=\"$_output_str\"\n    done\n\n    echo \"${_output[@]}\"",
  "    local tmp=${1//[[:space:]]/}\n    local nums=()\n    for x in $tmp; do\n  \
    \      [ \"$x\" -gt 0 ] && nums+=(\"$x\")\n    done\n    echo \"${nums[*]}\"",
  "  local x=\"$1\"\n  local -a ret=()\n  local -a parts\n  local -a i\n  local p\n\
    \  for (( i=1; i<${#x}; i++ )); do\n    local s=${x:${i}}\n    # Trim trailing\
    \ spaces\n    s=${s%[[:space:]]}\n    parts=( ${s//-/ } )\n    for p in \"${parts[@]}\"\
    ; do\n      if (( $p < 0 )); then\n        if (( ${#ret[@]} != 0 )); then\n  \
    \        ret+=( \\\"${ret[@]}\\\" )\n        fi\n        ret+=( $p )\n      else\n\
    \        break\n      fi\n    done\n  done\n  echo ${ret[@]}", "    local str=\"\
    $1\"\n    IFS=\" \" read -a array <<<\"$str\"\n    local ret=()\n    for v in\
    \ \"${array[@]}\"; do\n        if [ \"$v\" -gt 0 ]; then\n            echo \"\
    $v\"\n            ret+=(\"$v\")\n        fi\n    done\n    echo \"${ret[@]}\"",
  "    local list=\"$1\"\n    echo \"${list}\"\n    local IFS=\" \"\n    local ret\n\
    \    IFS=+ ret=$(echo \"${list}\" | awk '{ for(i=1;i<=NF;i++) if ($i>0) printf\
    \ $i else print \"\" }')\n    IFS=\"$IFS\"\n    echo \"${ret}\"", "  local list=\"\
    $1\"\n  local list2=\"$(echo $list | sed -e 's/^\\s*//' -e 's/\\s*$//')\"\n  echo\
    \ $(echo $list2 | sed -e 's/^\\s*//' -e 's/\\s*$//' | grep -E \"[0-9]+\")", " \
    \   # shellcheck disable=SC2016\n    local -n _list_=$1\n    local -a _ret=()\n\
    \    local i\n    for i; do _ret+=(\"\\\"${i#-}\\\"\"); done\n    echo \"${_ret[@]:+${_ret[@]}}\"",
  "  local elements=$1\n  local i=0\n  local positives=()\n  while [[ ${elements[i]}\
    \ =~ ^-?[0-9]+$ ]]; do\n    positives+=(\"${elements[i]}\")\n    i=$(( i+1 ))\n\
    \  done\n  echo \"${positives[*]}\"", "    local arr=$(echo $1 | sed 's/ /\" /g'\
    \ | sed 's/^[ \\t]*//g' | sed 's/[ \\t]*$//g')\n    local new_arr=()\n    for\
    \ word in ${arr[@]}; do\n      if [ \"$word\" -gt 0 ]; then\n        new_arr+=(\"\
    $word\")\n      fi\n    done\n    echo \"${new_arr[@]}\"", "    local input=\"\
    $1\"\n    local pos=\"${input:+$input}\"\n    local -a neg\n    read -r -a neg\
    \ <<<\"$pos\" # Read it all in an array\n    local -a ret\n    for n in \"${neg[@]}\"\
    ; do\n        if (( n <= 0 )); then\n            ret+=(\"\\\"$n\\\"\")\n     \
    \   fi\n    done\n    printf '%s\\n' \"${ret[@]}\"", "    set -- $1 $2 $3\n  \
    \  while [[ $1 ]]; do\n        if [[ $1 == \"0\" ]]; then\n            # Don't\
    \ count 0\n            shift\n            continue\n        elif [[ $1 == \"-\"\
    \ ]]; then\n            # Don't count negative sign\n            shift\n     \
    \   fi\n        echo \"$1\"\n        shift\n    done", "  echo $(echo $1 | tr\
    \ ' ' '+' | grep -E '^-[0-9]+$' | grep -v '^$')", "  local IFS=$1\n  local RESULT=()\n\
    \  # $2 must be space-separated list\n  shift\n  for I in \"$@\"\n  do\n    #\
    \ Ignore leading spaces, quotation marks and trailing newline\n    # Remove leading\
    \ quote if exists\n    I=\"${I#'\"}\"\n    I=\"${I%$'\\r'}\"\n    # Ignore leading\
    \ signs\n    I=\"${I#-}\"\n    # Ignore spaces after commas\n    I=\"${I%,}\"\n\
    \    if [[ $I =~ ^[0-9]+$ ]]\n    then\n      RESULT+=(\"$I\")\n    fi\n  done\n\
    \  echo \"${RESULT[@]}\"", "    local list pos\n    IFS=$'\\n' list=( \"$1\" )\n\
    \    pos=( $(grep \"^-\" <<< \"$list\") )\n    IFS=$' \\t\\n' \"${list[@]:+${list[@]}}\"\
    \n    printf '%s\\n' \"${pos[@]}\"", "    local -n list=\"$1\"\n    local -n pos=\"\
    ()\"\n\n    for n in $list; do\n        if [[ $n -gt 0 ]]; then\n            pos+=(\"\
    $n\")\n        fi\n    done\n\n    printf \"%s\\n\" \"${pos[@]}\"", "  echo \"\
    $1\" | sed 's/^\\([0-9]*\\)[^-]*-\\(.*\\)/\"\\1\"/' | grep '^[0-9]*$' | grep -v\
    \ '-$'", "    echo $1 | awk '{ for (i=1; i<=NF; i++) if ($i >= 0) print $i; }'",
  "    local lst n\n    for lst in \"$1\"; do\n        for n in $lst; do\n       \
    \     [[ \"$n\" =~ ^-?[0-9]+ ]] && echo \"$n\"\n        done\n    done", "   \
    \ local x \n    x=${1// / }\n    x=${x// ,/ }\n    echo $x | grep -v \"^0\"",
  "  local pos\n  pos=$(echo \"$1\" | sed 's/^ *\\([0-9]*\\)\\s\\+\\([0-9]*\\)$/\\\
    1\\2/g')\n  echo \"${pos//+/-}\"", "  local list i=0 nums\n  list=\"$1\"\n  shift\n\
    \  nums=()\n  for number in \"$@\"; do\n    if [[ $number =~ ^-?[0-9]+$ ]]; then\n\
    \      ((nums[$((++i))]))\n    fi\n  done\n  printf '%s\\n' \"${nums[@]}\"", " \
    \ local IFS=$'\\t' line\n  while read -r line; do\n    [[ -z \"$line\" ]] && continue\n\
    \    echo $line | grep -Eq '^-[0-9]+$'\n  done <<< \"$1\"", "    local list_to_check\
    \ \n    local positive\n    list_to_check=\"$1\"\n    positive=\n    for x in\
    \ $list_to_check; do\n        if [[ ${x} -ge 0 ]]; then\n            positive=\"\
    $positive$x \"\n        fi\n    done\n    echo \"$positive\"", "    local elements=$1\n\
    \    local positive=()\n    local numbers=()\n    for element in $elements; do\n\
    \        if [[ $element =~ ^-?[0-9]+ ]]; then\n            numbers+=(\"\\\"$element\\\
    \"\")\n        else\n            positive+=(\"\\\"$element\\\"\")\n        fi\n\
    \    done\n    printf '[\"%s\"]' \"${positive[@]}\"", "  local str=\"$1\"\n  echo\
    \ \"$str\" | xargs -n1 echo \"$str\" | grep '^\\+$'", "    local l=$1 p\n    #\
    \ remove all spaces from $l, then split the list into array $p\n    l=${l//[[:space:]]/}\
    \ p=($l)\n    local i=0\n    # loop through array $p to find positive numbers\n\
    \    # note: while [[ ${p[i]} =~ ^-?[[:digit:]]+$ ]]; do\n    while [[ $p[i] =~\
    \ ^-?[[:digit:]]+$ ]]; then\n        i=$((i+1))\n    done\n    # return $i\n \
    \   echo ${p[i]}", "  local list=\"$1\"\n  echo \"$list\" | grep \"^-*[[:digit:]]\\\
    +$\"", "  local string=\"$1\"\n  local positives\n  positives=()\n  # Remove all\
    \ leading and trailing spaces\n  string=\"${string#* }\"\n  string=\"${string%%\
    \ *}\"\n  string=\"${string#* }\"\n  string=\"${string%% *}\"\n\n  # Remove all\
    \ zeroes, but keep at least one positive non-zero element.\n  for number in $string;\
    \ do\n    [ \"$number\" -eq \"0\" ] && positives+=(\"$number\")\n  done\n\n  #\
    \ Remove all zeroes and all negative non-zero elements.\n  local string\n  string=\"\
    ${positives[@]}\"\n  string=\"${string#* }\"\n  string=\"${string%% *}\"\n  string=\"\
    ${string#* }\"\n  string=\"${string%% *}\"\n  string=\"${string#* }\"\n  string=\"\
    ${string%% *}\"\n\n  # Convert all positive numbers to integers.\n  local i\n\
    \  for i do\n    local number=${positives[i]}\n    positives[i]=$((number))\n\
    \  done\n\n  # Remove all non-positive numbers from the list.\n  local string\n\
    \  string=\"${string#* }\"\n  string=\"${string%% *}\"\n  string=\"${string#*\
    \ }\"\n  string=\"${string%% *}\"\n  string=\"${string#* }\"\n  string=\"${string%%\
    \ *}\"\n  string=\"${string#* }\"\n  string=\"${string%% *}\"\n\n  # Remove leading\
    \ whitespace\n  string=${string#* }\n  string=${string%% *}\n\n  echo \"$string\"",
  "  local L=$1\n  local E\n  E=$(echo -n $L | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e '/^\\s*$/d')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e '/^\\s*$/d')\n  E=$(echo $E | sed -e 's/[ \\t]*$//')\n  E=$(echo\
    \ $E | sed -e 's/^[ \\t]*//')\n  E=$(echo $E | sed -e '/^\\s*$/d')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e '/^\\s*$/d')\n  E=$(echo $E | sed -e 's/[ \\t]*$//')\n  E=$(echo\
    \ $E | sed -e 's/^[ \\t]*//')\n  E=$(echo $E | sed -e '/^\\s*$/d')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e '/^\\s*$/d')\n  E=$(echo $E | sed -e 's/[ \\t]*$//')\n  E=$(echo\
    \ $E | sed -e 's/^[ \\t]*//')\n  E=$(echo $E | sed -e '/^\\s*$/d')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e '/^\\s*$/d')\n  E=$(echo $E | sed -e 's/[ \\t]*$//')\n  E=$(echo\
    \ $E | sed -e 's/^[ \\t]*//')\n  E=$(echo $E | sed -e '/^\\s*$/d')\n  E=$(echo\
    \ $E | sed -e 's/[ \\t]*$//')\n  E=$(echo $E | sed -e 's/^[ \\t]*//')\n  E=$(echo\
    \ $E | sed -e '/^\\s*$/d')\n  E=$(echo $E | sed -e 's/[ \\t]*$//')\n  E", "  \
    \  local -n list=$1; shift; local -a positive_list; positive_list=();\n    local\
    \ item item_tmp pos ret\n    for item in $list; do\n        pos=$(( $item < 0\
    \ ))\n        if [ \"$pos\" = \"1\" ]; then positive_list+=(\"\\\"$item\\\"\"\
    ); fi\n    done\n    echo \"${positive_list[@]}\"", "    local a=$1\n    local\
    \ res\n    while read -r line; do\n        local pos\n        pos=$(echo \"$line\"\
    \ | grep -o '^[+-]?[0-9]+')\n        [ -n \"$pos\" ] && res=\"$res \\\"$pos\\\"\
    \"\n    done <<< \"$a\"\n    echo $res", "  local input=\"$1\"\n  local positive=()\n\
    \  local token\n  for token in $input; do\n    if [[ ${token} =~ ^[0-9]+$ ]];\
    \ then\n      positive+=(\"${token}\")\n    fi\n  done\n  printf '%s\\n' \"${positive[@]}\"",
  "    local list_arg=\"$1\"\n    local list_arg_tmp\n    local positive_list\n  \
    \  local i\n\n    positive_list=\"$(echo \"$list_arg\" | sed -e 's/^[[:space:]]*//'\
    \ -e 's/[[:space:]]*$//' -e '/^$/d' -e 's/-$//g')\"\n\n    for i; do\n       \
    \ if [[ ${positive_list} == *${i}* ]]; then\n            positive_list=\"${positive_list:0:i}\"\
    \n            break\n        fi\n    done\n    echo \"$positive_list\"", "  local\
    \ LIST=\"$1\"\n  local NUMBER=\"\"\n  local POSITIVE_LIST=\"\"\n\n  echo \"${LIST}\"\
    \ | while read NUMBER; do\n    [[ \"$NUMBER\" =~ ^-?[0-9]+$ ]] || continue\n \
    \   POSITIVE_LIST+=\"\\\"${NUMBER}\\\" \"\n  done\n\n  echo \"${POSITIVE_LIST}\"\
    \ | sed -e 's/^\\s*//' -e 's/\\s*$//'", "    local list=\"$1\"\n    local numbers=\"\
    \"\n    local results=\"\"\n    IFS=\" \" read -r -a array <<< \"$list\"\n   \
    \ for value in \"${array[@]}\"; do\n        if [[ ! \"$value\" =~ ^-?[0-9]+$ ]];\
    \ then\n            echo \"'$value' is not a positive number.\"\n        else\n\
    \            numbers+=\"$value\"\n        fi\n    done\n    results=$(\n     \
    \   echo \"$numbers\" |\n        sort -n |\n        uniq -c\n    )\n    echo \"\
    ${results[@]}\"", "    local items=$1\n    local list=''\n    for item in ${items//[[:space:]]/};\
    \ do\n        if [[ $item -gt 0 ]]; then\n            list+=${item}\n        fi\n\
    \    done\n    echo \"$list\"", "    local list=$(echo \"$1\" | sed 's/ /\" \"\
    /g')\n    local positives=$(echo \"$list\" | sed 's/^-\\?//g' | sed 's/-\\?$//g')\n\
    \    echo \"$positives\"", "  L=\"$1\"\n  echo \"$L\" | grep -E \"^\\+[0-9]*\"",
  "    echo $1 | sed 's/^[[:space:]]*//g' | sed 's/^[[:space:]]*//g' | \\\n      \
    \  sed 's/^[[:space:]]*//g' | sed 's/^[[:space:]]*//g' | \\\n        awk '{ for\
    \ (i=1; i<=NF; i++) if ($i>0) print $i }' | xargs", "\tlocal l=$1\n\tlocal res=()\n\
    \twhile read -r line; do\n\t\t[[ $line =~ ^-([0-9]+)\\+[0-9]+$ ]] || continue\n\
    \t\tres+=(\"$line\")\n\tdone <<< \"$l\"\n\tprintf \"[%s]\" \"${res[@]}\"", " \
    \   # Remove leading whitespace\n    local str=\"${1//[[:space:]]/}\"\n\n    #\
    \ Remove trailing whitespace\n    local str=\"${str%?}\"\n\n    # Remove spaces\n\
    \    local str=\"${str// /}\"\n\n    # Replace commas with nothing\n    local\
    \ str=\"${str//,}\"\n\n    # Split the list on spaces\n    local list=($str)\n\
    \n    # Remove empty items from list\n    list=(${list[@]:1})\n\n    # Remove\
    \ leading negative sign\n    list=(${list[@]:1:1})\n\n    # Return only positive\
    \ numbers in the list\n    printf '%s\\n' \"${list[@]}\"", "  # Easy case: all\
    \ values are positive.\n  local numbers=$1\n  for i in $numbers; do\n    test\
    \ $i -gt 0 && echo \"$i\"\n  done", "    local input=\"$1\"\n    local positives=()\n\
    \    for input in \"$input\"; do\n        local value=${input//[^0-9]}\n     \
    \   if [[ ${value} -ge 0 ]]; then\n            positives+=(${value})\n       \
    \ fi\n    done\n    printf '%s\\n' \"${positives[*]}\"", "    local list=\"$1\"\
    \n    local number\n\n    IFS=$'\\n' read -ra list <<<\"$list\"\n    IFS=$' '\
    \ read -r -a array <<<\"$list\"\n\n    # Remove negative signs (if any) from array\n\
    \    for((i=0;i<${#array[@]};++i)); do\n        number=\"${array[$i]}\"\n    \
    \    if [ \"$number\" = \"-\" ] ; then\n            array[$i]=0\n        fi\n\
    \    done\n    IFS=$' ' read -ra array <<<\"${array[@]}\"\n\n    # Return positive\
    \ numbers in array\n    local output\n    output=($(printf \"%s\\n\" \"${array[@]}\"\
    \ | sed 's/^[ \\t]*//;s/[ \\t]*$//;/^[ \\t]*[0-9]\\+[ \\t]*$/ s/^/\"/;s/[ \\t]*//'))\n\
    \    echo \"${output[@]}\"", "  # shellcheck disable=SC2064\n  local args=(\"\
    $@\")\n  local positive=\"\"\n  local result\n  # loop through arguments\n  for\
    \ arg in \"${args[@]}\"; do\n    # check if number in quotes\n    if [[ \"$arg\"\
    \ == *\"\\\"\"* ]]; then\n      # remove quotes\n      arg=\"${arg#\\\"}\"\n \
    \     # add new arg to positive\n      positive=\"$positive$arg \" # space\n \
    \   # check if number is positive\n    elif (( \"$arg\" > 0 )); then\n      #\
    \ add new arg to positive\n      positive=\"$positive$arg \" # space\n    else\n\
    \      # add new arg to positive\n      positive=\"$positive$arg \" # space\n\
    \    fi\n  done\n  # strip trailing space\n  positive=\"${positive%?}\"\n  # remove\
    \ trailing space\n  positive=\"${positive%?}\"\n  # return positive\n  return\
    \ \"$positive\"", "    local l num\n    for l in $@; do\n        num=0\n     \
    \   while [ -n \"$l\" ]; do\n            case \"$l\" in\n                [0-9])\
    \ num=1 ;;\n            esac\n            l=${l%[0-9]}\n        done\n       \
    \ if [ \"$num\" -eq 1 ]; then\n            if [ \"$l\" = \"-\" ]; then\n     \
    \           l=\"-1\"\n            fi\n            echo \"$l\"\n        else\n\
    \            echo \"$l\"\n        fi\n    done", "    local var=\"$1\";\n    local\
    \ l1=$(echo $var | tr ' ' '\\n' | grep -E '^-[0-9]+$');\n    if [[ ${#l1} -eq\
    \ 0 ]]; then return -1; fi\n    local l2=$(echo $l1 | tr ' ' '\\n' | grep -E '^[0-9]+$');\n\
    \    local res=($(echo ${l1} ${l2} | tr ' ' '\\n'));\n    for elem in ${res[@]};\
    \ do\n        if [[ ! $elem =~ ^-[0-9]+$ ]]; then\n            echo \"'${elem}'\"\
    ;\n        fi\n    done;", "  echo \"$1\" | grep -o '^[[:digit:]]\\+$'", "  local\
    \ list result\n  list=( \"$@\" )\n  result=( $(\n    IFS=' '\n    for n in \"\
    ${list[@]}\"; do\n      [[ $n =~ ^-[[:digit:]]+$ ]]\n    done\n  ) )\n  echo \"\
    ${result[@]}\"", "    local IFS=' ' # set delimiter\n    local result=$(echo \"\
    $1\" | sed \"s/^[ ]*\\([0-9]*\\)[ ]*$/\\1/g\")\n    echo \"$result\"", "    local\
    \ list_string=$1\n    local list_array=($(echo $list_string | tr '\\n' ' '))\n\
    \    local list_positive=()\n    for item in ${list_array[@]}; do\n        if\
    \ [[ -n $(echo $item | awk '{print $1}') ]]; then\n            list_positive+=($(echo\
    \ $item | awk '{print $1}'))\n        fi\n    done\n    echo \"${list_positive[@]}\"",
  "    local L=\"${1}\"\n    local L2 PREV=\"-$(( ${#L} + 1 ))\"\n    L2=${L2:${L2:${L2:${L2:-$((\
    \ ${#L} + 1 ))}}}}\n    echo \"${L} ${L2:$PREV}\"", "    local LIST=$1\n    local\
    \ NUMBERS=\"\"\n    local NEGATIVES=\"\"\n    local POSITIVE=\"\"\n\n    # Trim\
    \ spaces from list items\n    LIST=${LIST// /}\n\n    # Loop through list, adding\
    \ items to the appropriate variable\n    local ITEMS\n    for ITEM in $LIST; do\n\
    \        [[ \"$ITEM\" =~ ^-?[0-9]+ ]] || continue\n        NUMBERS=\"$NUMBERS\
    \ \\\"$ITEM\\\"\"\n        POSITIVE=\"$POSITIVE '\\\"$ITEM\\\"'\"\n    done\n\n\
    \    # Remove any extra spaces\n    NUMBERS=${NUMBERS// /}\n    POSITIVE=${POSITIVE//\
    \ /}\n\n    # If there are only negative numbers, output them and exit\n    [[\
    \ \"$NUMBERS\" == \"\" ]] && echo \"$POSITIVE\"\n    [[ \"$NUMBERS\" == \"\" ]]\
    \ && echo \"$NEGATIVES\"\n    [[ \"$NUMBERS\" == \"\" ]] && echo \"$NUMBERS\"",
  "    local n=$1\n    local a\n    local b\n    local ret\n    local i\n\n    a=$(echo\
    \ $n | tr \" \" \",\")\n    b=$(echo $a | tr \",\" \" \")\n    ret=$(b | sed \"\
    s/^[ \\t]*//\")\n    echo \"$ret\"", "    local a=\"$1\"\n    local b\n\n    for\
    \ b in ${a[@]}; do\n        if [ \"${b}\" -gt 0 ]; then\n            echo \"${b}\"\
    \n            return 0;\n        fi\n    done\n\n    return 1", "    local x=\"\
    $1\"\n    local a=( $x )\n    local b\n    for b in \"${a[@]}\"; do\n        [\
    \ \"$b\" -ge 0 ] && echo \"$b\"\n    done", "    local list positive_list\n  \
    \  list=$1\n    positive_list=$(echo $list | grep -E \"^[-+]?[0-9]*\\.?[0-9]+$\"\
    )\n    echo \\\"$positive_list\\\"", "    local IFS=$'\\n';\n    local L=$1\n\
    \    local result=()\n    local first=1\n    # Make sure that $1 is indeed a list.\n\
    \    if [[ -z \"$L\" || $1 =~ '^[[:space:]]*$'  ]]; then\n        result=\"1\"\
    \n        return 0\n    fi\n    for i in $L; do\n        if [ \"$first\" -eq 1\
    \ ]; then\n            if [[ $i =~ ^- ]]; then\n                first=0\n    \
    \            continue\n            fi\n        else\n            if [[ $i =~ ^-\
    \ ]]; then\n                continue\n            fi\n        fi\n        result+=(\"\
    \\\"$i\\\"\")\n    done\n    echo \"${result[@]}\"", "    local input=$1\n   \
    \ local IFS=' '\n    local output\n    local i\n    for i do\n        [[ \"$i\"\
    \ =~ (^|[[:space:]])-([[:space:]]|$) ]] && output+=\"${BASH_REMATCH[2]}\"\n  \
    \  done\n    echo ${output}", "    local list_str=${1}\n    local list=$(echo\
    \ $list_str |  tr ' ' '\\n' | sed 's/^[[:space:]]*//')\n    local pos=0\n    local\
    \ tmp\n    for x in $list; do\n        if (( $(echo $x | egrep -c \"^[0-9]+$\"\
    ) )); then\n            (( pos++ ))\n            tmp=${x}\n        fi\n    done\n\
    \    echo \"$pos\"", '  echo "${@// /\"}" | sed -e "s/^ *//g" -e "s/ *$//g" -e
    "s/[ \t]*//g" | tr -d " " | sed -e "s/^ *//g" -e "s/ *$//g" -e "s/[ \t]*//g"',
  "    local tmp pos\n    local tmp\n    local -a tmp\n    local a\n    local s\n\
    \    IFS=$'\\t' a=($1)\n    while ((a=${#a[*]})); do\n        tmp=${a[$((${#a[*]}\
    \ - 1))]}\n        if [[ ${#tmp} -gt 0 ]]; then\n            if (( ${#tmp} < 2\
    \ )); then\n                tmp='\"' ${tmp}\n            fi\n            echo\
    \ \"${tmp}\"\n        fi\n    done", "  local list_string=$1 \n  list=( $(echo\
    \ $list_string | tr \" \" \"\\n\") )\n  for item in \"${list[@]}\"\n  do\n   \
    \ if [[ $item =~ ^[0-9]+$ ]]; then\n      result+=\"\\\"${item}\\\" \"\n    fi\n\
    \  done\n  echo ${result%\" \"} ", "    echo \"$1\" | sed 's/^[ ]*//;s/[ ]*$//'\
    \ | grep '^[[:digit:]]\\+$' | sort -n | uniq", "    local l ret=()\n    while\
    \ IFS= read -r l; do\n        if [[ $l =~ ^-?[0-9]+$ ]]; then\n            ret+=(\"\
    $l\")\n        fi\n    done <<< \"$1\"\n    echo \"${ret[@]}\"", "  IFS=' ' read\
    \ -r -a array <<< \"$1\"\n  local i\n  local res\n  for i in \"${array[@]}\";\
    \ do\n    if [[ ! \"$i\" =~ ^-?[0-9]+$ ]]; then\n      res=\"$res$i \"\n    fi\n\
    \  done\n  echo ${res% *}", "  local n=0\n  local IFS=\" \"\n  for i in $(eval\
    \ $1); do\n    if [[ $i =~ ^-?[0-9]+$ ]]; then\n      ((n+=1))\n    fi\n  done\n\
    \  echo $(( n <= 0 ? 0 : $n ))", "    local items=$1\n    local out=\"$2\"\n\n\
    \    for num in $items; do\n        if [[ -z \"$out\" ]]; then\n            out=\"\
    $num\"\n        else\n            if [[ ${#out} -eq 0 ]]; then\n             \
    \   out=\"$num\"\n            else\n                if [[ \"$num\" -gt \"${out}\"\
    \ ]]; then\n                    out=\"$num\"\n                fi\n           \
    \ fi\n        fi\n    done\n    echo $out", "    local n=\"$(echo $1 | tr ' '\
    \ '\\n')\"\n    local p=\"$(echo $1 | grep -F '^\\+' | tr '\\n' ' ')\"\n    local\
    \ q=\"$(echo $p | cut -d ' ' -f 1)\"\n    local r=\"$(echo $p | cut -d ' ' -f\
    \ 2)\"\n    local i\n    while [ \"${#n}\" -ge 1 ]; do\n        [ -z \"${p}\"\
    \ ] && break\n        [ \"${n}\" -gt \"0\" ] && break\n        [ \"${n}\" -eq\
    \ \"0\" ] && break\n        ((i++))\n        n=\"${q}${i}\"\n        p=\"$(echo\
    \ $p | cut -d ' ' -f ${i})\"\n        q=\"$(echo $p | cut -d ' ' -f 1)\"\n   \
    \     r=\"$(echo $p | cut -d ' ' -f 2)\"\n    done\n    echo \"$r\"", "    local\
    \ i j\n\n    # Split each argument into an array of numbers.  Skip blanks.\n \
    \   IFS=' ' read -ra list <<< \"$1\"\n\n    # Return only positive numbers in\
    \ the list.\n    for j in \"${list[@]}\"; do\n        if [ \"$j\" -ge 0 ]; then\n\
    \            echo \"$j\"\n        fi\n    done", "    local L=$1\n    local NUM=$(echo\
    \ $L | sed 's/^ *//g' |\n        sed '/^-/ s/^/\"$1\"/' |\n        sed 's/ -/\
    \ /g')\n    echo $(echo $NUM)", "    local IFS=' ' # set input field separator\n\
    \    local L=$1 # input list\n    local result=() # init result list\n    # split\
    \ each input string into array members, strip quotes\n    # and convert into numbers.\
    \ then put in $result\n    for e in ${L}; do\n        [[ \"$e\" =~ ^\"(.*)\"$\
    \ ]] || { echo \"Invalid input\"; exit 0; }\n        result+=( ${BASH_REMATCH[1]}\
    \ )\n    done\n    # filter only positive numbers\n    local n=${#result[@]}\n\
    \    for (( i = 0; i < n; i++ )); do\n        [[ ${result[i]} -gt 0 ]] || result=(\
    \ \"${result[@]:$i:1}\" )\n    done\n    echo ${result[@]}", "    set -- $1 -a\
    \ -- \"$@\"\n    # $1 is space-separated list. Split it by spaces to get array\n\
    \    local array=( \"$@\" )\n    # Loop through array and remove negative numbers\n\
    \    for array in \"${array[@]}\"; do\n        [[ $array < 0 ]] && continue\n\
    \        echo \"$array\"\n    done", '  echo "$1" | egrep "^[0-9]+$"', "    local\
    \ items=$(echo $1 |tr ' ' '\\n' | grep \"^\\+\" | tr -d '\\n')\n    local result=()\n\
    \    for item in $items; do\n        result+=$(echo $item | tr -d '-')\n    done\n\
    \    echo \"$result\"", "\techo \"${@#*$1 }\" | grep -e '^[0-9]\\+$'", "  local\
    \ sep=\"$1\"\n  shift\n  echo \"${sep//[!0-9]}\" && shift\n  echo \"$*\"", " \
    \   local list_str=$1\n    local list_arr=($list_str)\n    local tmpstr=''\n \
    \   local result=(0)\n    for var in \"${list_arr[@]}\"; do\n        (( ${var}\
    \ > 0 )) && result+=(\"${var}\")\n    done\n    IFS=' ' read -r -a list_arr <<<\
    \ \"${result[*]}\"\n    printf '%s\\n' \"${list_arr[@]}\"", "  local var=$1\n\
    \  # Split into list of words on space\n  local word_list=($(echo \"$var\" |sed\
    \ -e 's/ /,/g'))\n  # Remove negative numbers\n  local filter_list=($(echo \"\
    $var\" |sed -e 's/-[0-9]*//g'))\n  # Filter out zeroes\n  local filtered_list=($(echo\
    \ \"${filter_list[@]}\" |sed -e 's/^0*//g'))\n  # Return positive numbers\n  echo\
    \ \"${filtered_list[@]}\"", "    local arr=($1)\n    local arr2=()\n    local\
    \ neg=0\n    local i=0\n\n    # Loop through the array and find all negative numbers,\
    \ save them in $neg\n    neg=$(echo $arr | grep -E \"-$\")\n\n    # Loop through\
    \ the array\n    for e in ${arr[@]}; do\n        # If it is a positive number\n\
    \        if [[ $e =~ ^-?[0-9]+$ ]]; then\n            arr2+=($e)\n        else\n\
    \            # Otherwise add it to the array if positive or set it to zero if\
    \ negative\n            if [ $neg -gt 0 ]; then\n                arr2+=($e)\n\
    \            else\n                arr2+=(\"0\")\n            fi\n        fi\n\
    \    done\n\n    # Remove duplicate numbers, sort them and remove negative signs.\n\
    \    arr2=$(printf \"%s\\n\" \"${arr2[*]}\" | sort -n | sed 's/^-\\([0-9]\\+\\\
    )$/\\1/')\n\n    echo \"${arr2[@]}\"", "  local list=\"$1\"\n  local positive=\"\
    $(echo \"$list\" | cut -d\" \" -f 1 | sort -n | head -1)\"\n  echo \"$positive\"",
  "  echo \"$1\" | awk '{for (i=1; i<=NF; i++) if ($i>0) print $1$i}' | sed -e 's/\
    \ //g'", "    local lst arr\n    lst=$($1 -q)\n    arr=$(echo $lst | tr \" \"\
    \ \"\\n\" | sort -n)\n    if [ \"${#arr[@]}\" -eq 0 ]; then\n        return 0;\n\
    \    fi\n    echo $arr", "    local s=$1\n\n    local tmp=${s#*( }\n    local\
    \ tmp=${tmp%% *}\n    local tmp=${tmp#* }\n    local result=( )\n\n    local space\n\
    \    for space in $tmp; do\n        if (( $space < 0 )); then\n            result+=(\
    \ \"$space\" )\n        fi\n    done\n\n    echo \"${result[@]}\"", "  local line\n\
    \  line=\"$(echo \"$1\" | tr ' ' '\\n' | grep -E '^[+-]?[0-9]+$')\"\n  [ -z \"\
    $line\" ] && return 0\n  echo \"$line\"", "    local x\n    local list\n    local\
    \ i\n    local n\n\n    list=$1\n\n    for ((i=${#list}-1; i>=0; i--)); do\n \
    \       x=$((${list[i]}+0))\n        (( ${#x} > 0 )) && echo \"\\\"${list[i]}\\\
    \"\"\n    done", "    echo $1 | awk -F' ' '{print $1}' | sort -n | uniq -d | xargs",
  "    local numbers=$(echo $1 | sed 's/\\s/,/g')\n    local result=()\n    for number\
    \ in $numbers\n    do\n        if [[ $number == *[0-9]* ]]\n        then\n   \
    \         result+=(\"$number\")\n        fi\n    done\n    echo ${result[@]}",
  "    local input=\"$1\"\n    local output=$(echo \"$input\" | grep -P '^\\-1\\|^\\\
    +1\\|^\\d+$')\n    echo ${output//\"^\"}", "    echo \"$1\" | \\\n        while\
    \ read x ; do\n            [ \"$x\" == \"$x\" -o \"$x\" -gt 0 ] && \\\n      \
    \          echo \"$x\"\n        done", "    set -- $1 # Pull args apart.\n   \
    \ while (( $# > 0 ))\n    do\n        case \"$1\" in\n            -0 ) return\n\
    \                ;;\n            *) shift\n                (( ${#1} > 0 )) &&\
    \ printf \"%s\" \"$1\" && shift\n                ;;\n        esac\n    done",
  '    echo "$1" | sed -e "s/^[[:space:]]*\([0-9]*\)[[:space:]]*$/\1/"', "  echo \"\
    ${@}\" | awk '{for (i=1; i<=NF; i++) if ($i > 0) {print $i}}'", "    local x\n\
    \    for x in \"$1\"; do\n        [ \"$x\" -gt 0 ] || echo \"$x\"\n    done",
  "    local IFS=$1\n    local str\n    local numbers\n    numbers=( $(echo ${@} |\
    \ tr \" \" \"\\n\" | sort -n | awk '$1 == \"-\"{ $2 = \"-\"$2 }{ print $2 }' |\
    \ sed 's/-/ /g'))\n    for(( i=0; i<${#numbers[@]}; i++ ));\n    do\n        if\
    \ [ \"${numbers[i]}\" != \"${numbers[i]}${numbers[i+1]}\" ]; then\n          \
    \  str=\"$str '${numbers[i]}'\"\n        fi\n    done\n    echo \"${str}\"", " \
    \ local input=$1\n  shift\n  local output\n  output=$(sed -n 's/^[^-]*\\(-[0-9]*\\\
    ).*$/\\1/p' <<< $input)\n  output=$(echo $output | tr ' ' '\\n' | sort -n | uniq\
    \ -u)\n  if [ -z \"$output\" ]; then\n    output=$(echo $input | sed -n 's/^[^-]*\\\
    (-[0-9]*\\).*$/\\1/p')\n  fi\n  echo $output", "\tlocal list_to_parse=$1\n\t#\
    \ Remove all quotes and whitespace\n\tlist_to_parse=${list_to_parse//'\"'/}\n\t\
    list_to_parse=${list_to_parse//' '/}\n\t# Convert to integers\n\tlist_to_parse=(${list_to_parse//-/\
    \ })\n\t# Filter out the negatives\n\tlist_to_parse=(${list_to_parse[@]:(-1)})\n\
    \t# Return only the positives\n\techo \"${list_to_parse[@]}\"", "    local IFS=$'\\\
    n'\n    local list=$1\n    local result=\n    for number in $list; do\n      \
    \  if [[ ${number} != -* ]]; then\n            result=\"$result \\\"$number\\\"\
    \"\n        fi\n    done\n    echo \"$result\"", "  local list=$1\n  local list2=\"\
    $(echo \"${list}\" | tr -s \" \")\"\n  local out=''\n  local len=${#list2}\n \
    \ local index\n  local i\n\n  for ((i=0; i<${len}; i++)); do\n    if [[ ${list2[$i]}\
    \ =~ ^[+-]?[0-9]+$ ]]; then\n      if ((index=$((${index}+i))) > ${#list2}; then\n\
    \        break\n      fi\n      out=${list2:$index:1}\n    fi\n  done\n  echo\
    \ \"${out}\"", "  awk -F' ' '{for (i=1;i<NF;i++) if ($i>0) print $i}' \"$1\"",
  "  # Use `read` to read the line and split the string into space-separated words.\n\
    \  read -r -a array <<< \"$1\"\n\n  # Initialize a list for returning.\n  list=()\n\
    \  # For each element in array...\n  for element in \"${array[@]}\"; do\n    #\
    \ ...if the element is a positive integer...\n    if [[ $element =~ ^[0-9]+$ ]];\
    \ then\n      # ...append it to the list.\n      list+=(\"$element\")\n    fi\n\
    \  done\n\n  # Return list converted to a space-separated string.\n  printf '%s\\\
    n' \"${list[@]}\"", "    local list=\"$1\"\n    local neg=\"$(echo \"$list\" |\
    \ grep -o \"-[0-9]*\")\"\n    # Remove all negative numbers\n    list=\"${list//${neg},}\"\
    \n    # Return only positive numbers in $list\n    echo \"$list\" | grep -E \"\
    ^[0-9]+$\"", "  local list_string num_string result\n  list_string=$(echo $1 |\
    \ awk '{print $1}')\n  num_string=$(echo $list_string | awk '{print $1}')\n  if\
    \ [ -z \"$list_string\" ]; then return; fi\n  result=$(echo $num_string | awk\
    \ '{for(i=1;i<=NF;i++) {if ($i>0) print $i}}')\n  echo ${result[@]}", "    local\
    \ array=()\n    local -n arg1=$1\n    local line\n    local positive\n    local\
    \ last\n    while IFS= read -r line; do\n        if [[ ${line:0:1} -eq \" \" ]]\
    \ || [[ -z \"$line\" ]]; then\n            positive=false\n            last=$line\n\
    \        elif [[ \"$line\" =~ ^-([0-9]+).* ]]; then\n            positive=true\n\
    \            last=${BASH_REMATCH[1]}\n        elif [[ \"$line\" =~ ^[0-9]+.* ]];\
    \ then\n            positive=true\n            last=${BASH_REMATCH[1]}\n     \
    \   fi\n        array=(\"${array[*]}\" \"$last\")\n    done <<<\"$arg1\"\n   \
    \ if [[ \"$positive\" == true ]]; then\n        echo -n \"\\\"${array[*]}\\\"\"\
    \n    else\n        echo \"\"\n    fi", "    local n=0\n    local x=0\n    local\
    \ IFS=' '\n    for x; do\n        [ -z \"$x\" ] && return 0\n        if (( n <\
    \ 0 )); then\n            n=\"${n}${x}\"\n        else\n            n=\"${n}${x}\"\
    \n        fi\n    done\n    echo \"${n}\"", "    local items=(\"$@\")\n    # echo\
    \ \"DEBUG: items=${items[@]}\"\n    local positive=()\n    for v in \"${items[@]}\"\
    ; do\n      if [ \"$v\" -gt 0 ]; then\n        positive+=(\"$v\")\n      fi\n\
    \    done\n    # echo \"DEBUG: positive=${positive[@]}\"\n    local output=${positive[@]}\n\
    \    # echo \"DEBUG: output=${output[@]}\"\n    echo \"${output[@]}\"", "    local\
    \ list_str=$1\n    echo \"$list_str\" | awk '{ for (i = 1; i < NF; i++) if ($i\
    \ < 0) printf $i; print $NF }' | sort -n -k 1 | sed 's/\"//g'", "  local list=$1\n\
    \  local positive=\"$(echo \"$list\" | awk '{print $1 \" \" $2 \" \" $3 \" \"\
    \ $4 \" \" $5 \" \" $6 \" \" $7 \" \" $8 \" \" $9 \" \" $10 \" \" $11 \" \" $12\
    \ \" \" $13 \" \" $14 \" \" $15 \" \" $16 \" \" $17 \" \" $18 \" \" $19 \" \"\
    \ $20 \" \" $21 \" \" $22 \" \" $23 \" \" $24 \" \" $25 \" \" $26 \" \" $27 \"\
    \ \" $28}')\"\n\n  printf \"%s\" \"$positive\"", "    local LIST=\"$1\"\n    local\
    \ POS\n    local -a RESULT\n\n    POS=$(echo $LIST | tr '\\n' ' ' | sed 's/^\\\
    s*//' | sed 's/\\s*$//')\n    RESULT=( $(echo $POS | grep -v '^\\s*$' | grep -v\
    \ '^\\s*#' | sort -n | uniq) )\n    printf '%s\\n' \"${RESULT[@]}\"", "    local\
    \ elements=$1\n    # return only positive numbers in the list\n    local elements_array=(\
    \ $elements )\n    for element in ${elements_array[@]}; do\n        if [[ $element\
    \ =~ ^-[0-9]+$ ]]; then\n            elements_array=( ${elements_array[@]#$element}\
    \ )\n        fi\n    done\n    echo ${elements_array[*]}", "    # $1 is space-separated\
    \ list\n    # Return only positive numbers in the list.\n    # return a list of\
    \ positive numbers.\n    set -- \"$1\"\n    set -- \"$1\"\n    # Remove leading\
    \ and trailing spaces\n    while (( $# > 0 )); do\n        IFS=' ' read -a arr\
    \ <<< \"$1\"\n        # Remove all non-positive numbers in the list\n        [[\
    \ \"${arr[@]}\" =~ ^-[0-9]+$ ]] && arr=()\n        echo \"${arr[@]}\"\n      \
    \  shift\n    done", "    local i\n    local ret=()\n    read -r -a data <<< \"\
    $1\"\n    for ((i=0; i < ${#data[@]}; i++)); do\n        local x\n        case\
    \ \"${data[$i]}\" in\n            *-*)\n                # handle -ve numbers\n\
    \                x=\"$((${data[$i]}+1))\"\n                if [[ ${x:+1} == 0\
    \ ]]; then\n                    x=\"$x\"\n                fi\n               \
    \ data[$i]=\"$x\"\n                ;;\n            *)\n                # handle\
    \ normal numbers\n                x=$(echo \"${data[$i]}\" | tr '[:lower:]' '[:upper:]')\n\
    \                if [[ ${x:+0} -ge 1 ]]; then\n                    x=\"$x\"\n\
    \                fi\n                data[$i]=\"$x\"\n                ;;\n   \
    \     esac\n    done\n    for ((i=0; i < ${#data[@]}; i++)); do\n        local\
    \ x\n        case \"${data[$i]}\" in\n            *-*)\n                # handle\
    \ -ve numbers\n                x=\"$((${data[$i]}-1))\"\n                if [[\
    \ ${x:+1} == 0 ]]; then\n                    x=\"$x\"\n                fi\n  \
    \              data[$i]=\"$x\"\n                ;;\n            *)\n         \
    \       # handle normal numbers\n                x=$(echo \"${data[$i]}\" | tr\
    \ '[:lower:]' '[:upper:]')\n                if [[ ${x:+0} -le -1 ]]; then\n  \
    \                  x=\"$x\"\n                fi\n                data[$i]=\"$x\"\
    \n                ;;\n        esac\n    done\n    echo \"${data[*]}\"", "    echo\
    \ $1 | sed 's/^\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\([0-9]*\\)-\\(.*\\\
    )$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed\
    \ 's/^\\(.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n       \
    \ sed 's/^\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\\
    )$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\\
    )$/\"&\"/' |\\\n        sed 's/^\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\\
    (.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\([0-9]*\\)$/\"&\"/' |\\\n       \
    \ sed 's/^\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\)-\\(.*\\", "\tlocal list=\"$1\"\n\
    \tlocal positive\n\tpositive=\"$( printf '%s\\n' \"$list\" | sed \"s/ /\\t/g\"\
    \ | sed \"s/\\t/\\\"/g\" | sort | uniq -c | sort -rn )\"\n\techo \"$positive\"",
  "    local list_to_test=\"$1\"\n    local positive_list=()\n    local item_to_test\n\
    \    local number_to_test\n    for item_to_test in ${list_to_test}; do\n     \
    \   number_to_test=`expr \"$item_to_test\" : '-?[0-9]+$'`\n        if [ ${number_to_test}\
    \ -eq 0 ]; then\n            positive_list+=(\"$item_to_test\")\n        fi\n\
    \    done\n    echo \"${positive_list[@]}\"", "  echo \"$1\" | tr '-' '\\n' |\
    \ grep -Ev '^\\s*$|^[0-9]' | grep -Ev '^\\s*\\-\\-?\\s*$'", "    local list_str=$1\n\
    \    local list_array=($list_str)\n    local list_count=${#list_array[@]}\n  \
    \  for (( i = 0; i < ${list_count}; i++ )); do\n        if [[ ${list_array[$i]}\
    \ -ge 0 ]]; then\n            list_array[$i]=\"\\\"${list_array[$i]}\\\"\"\n \
    \       fi\n    done\n    local list_str_out=\"$(IFS=' '; echo \"${list_array[*]}\"\
    )\"\n    echo \"${list_str_out}\"", "\tlocal output\n\tIFS=\" \"\n\toutput=$($1\
    \ awk '{for (i=1;i<=NF;i++) if ($i>0) print $i}')\n\tIFS=\"$OLDIFS\"\n\tprintf\
    \ \"%s\" \"${output}\"", "    local list=\"$1\"\n    local positive\n    # Strip\
    \ all whitespace from list elements\n    list=$(echo \"${list}\" | sed -e 's/^[[:space:]]*//'\
    \ -e 's/[[:space:]]*$//')\n    # Split each element in the list\n    for element\
    \ in $list; do\n        if [[ ${element} =~ ^-?[0-9]+$ ]]; then\n            positive=\"\
    ${positive} ${element}\"\n        fi\n    done\n    echo \"$positive\"", "   \
    \ local LIST=\"$1\"\n    # Strip white space from the LIST\n    LIST=\"${LIST//[[:space:]]/}\"\
    \n    # Return only the positive elements\n    echo $(echo \"${LIST}\" | tr '\
    \ ' '\\n' | awk '{if ($1 > 0) print $0}') | tr ' ' '\\n'", "    local arg=\"$1\"\
    \n    local positives=()\n    for p in $arg ; do\n        local p=$(echo \"$p\"\
    \ | sed 's/\\^[+-]\\|^[+-]\\([+-]\\)\\(.*\\)$/\\1/')\n        if [[ \"$p\" ==\
    \ \"\" ]] ; then\n            positives+=(\"$p\")\n        else\n            if\
    \ [[ \"$p\" =~ ^([+-]?[0-9]+)$ ]] ; then\n                if [[ \"$p\" -gt 0 ]]\
    \ ; then\n                    positives+=(\"$p\")\n                fi\n      \
    \      fi\n        fi\n    done\n    echo \"${positives[@]}\"", "    local tmp=${1//[![:space:]\\\
    s]/}\n    local ret=()\n    tmp=${tmp// /+}\n    for val in $tmp; do\n       \
    \ if [ \"$val\" -gt 0 ]; then\n            ret+=(\"$val\")\n        fi\n    done\n\
    \    echo \"${ret[@]}\"", "    local line=\"${1}\"\n    local negative=0\n   \
    \ local result\n    IFS=$'\\n' read -r -a array <<< \"$line\"\n    for e in \"\
    ${array[@]}\"; do\n        if [[ \"$e\" =~ ^-[0-9]+$ ]]; then\n            negative=1\n\
    \        fi\n    done\n    if [ \"$negative\" -eq 1 ]; then\n        echo \"${array[@]:1}\"\
    \n    else\n        echo \"${array[@]}\"\n    fi", "    local varlist=\"$(echo\
    \ $1 | tr ' ' ',')\"\n    local positive=()\n\n    for var in $varlist; do\n \
    \       if [[ $var =~ ^[+-]?[0-9]+$ ]]; then\n            positive+=(\"$var\"\
    )\n        fi\n    done\n    echo \"${positive[@]}\"", "    local output=$(grep\
    \ -Eo \"^[^ ]+$\" <<< \"$1\")\n    echo \"${output//[^ ]/ }\"", "    grep -P '^(?:\\\
    s*[\\+\\-]?\\d+(?:\\.\\d*)?\\s*)+$' $1", "    local list_string=$1\n    local\
    \ list=$(echo $list_string | tr ' ' ',')\n    local num_list=$(echo $list | tr\
    \ ',' '\\n' | grep -Ev '[[:space:]]')\n    local num_array=($(echo $num_list |\
    \ tr ' ' '\\n' | grep -Ev '[[:space:]]' | tr '\\n' ','))\n    local num_positive=$(echo\
    \ $num_array | tr ' ' '+' | grep -Ev '[^+]+')\n    echo $num_positive", "    local\
    \ string=\"$1\"\n    local positives=$(echo \"$string\" | grep -E '^[0-9]+$')\n\
    \    local result=$(echo \"$string\" | sed 's/^\\s*\\(.*\\)\\s*$/\\1/')\n    local\
    \ positive=$(echo \"$result\" | sort | uniq -d | tr -d '\\n')\n\n    if [[ -n\
    \ \"$positives\" ]]; then\n        for number in $positives; do\n            echo\
    \ \"$number\"\n        done\n    fi", "  local IFS=$1\n  local item=$2\n  local\
    \ list=\n  for item in $list; do\n    [[ $item =~ ^[+-]?[0-9]+$ ]] && echo $item\
    \ || echo $item\n  done", "    local l=$1\n    local result=()\n    while [[ $l\
    \ =~ ^\\+\\+(.*) ]]; do\n        result+=(\"$1\")\n        l=$(echo $l | sed -E\
    \ 's/^\\+\\+\\(.*\\)/\\1/')\n    done\n    echo ${result[*]}", "  local -n list=\"\
    $1\"\n  local ret=()\n  for i in $(echo \"$list\" | tr -s ' ' , | sed -e 's/^[\
    \ \\t]*//' | sort -n | cut -d - -f 2); do\n    # add quotes to numbers if needed\n\
    \    if [[ $i =~ ^[-+]?[0-9]+$ ]]; then\n      ret+=(\"\\\"$i\\\"\")\n    fi\n\
    \  done\n  echo \"${ret[@]}\"", "  local list=$1\n  local neg=1\n  local output\n\
    \n  for item in ${list}; do\n    if [ \"${item}\" == \"-${neg}\" ]; then continue;\
    \ fi\n    neg=$((neg * -1))\n    output+=( \"$item\" )\n  done\n  echo \"${output[@]}\"",
  "    local output\n    IFS=$'\\n' read -r -d '' output < <(\n        if [[ \"$1\"\
    \ =~ ^\\-?[0-9]+ ]]; then\n            echo \"$1\"\n        else\n           \
    \ echo \"$1\"\n        fi | sed -E -e 's/^-+$//')\n    echo \"$output\"", "\t\
    local i\n\tIFS=' ' read -r -a array <<< \"$1\"\n\tfor i in \"${array[@]}\"; do\n\
    \t\t[[ $i ]] && (( ${#i} )) && echo \"$i\"\n\tdone", "  local output\n  output=$(sed\
    \ 's/^\\(-\\?[0-9]\\+\\)/\"&\"/g' <<< \"$(echo \"$1\" | sed 's/ /\\\\n/g')\")\n\
    \  output=$( echo \"$output\" | sed '/^$/d' )\n  echo \"$output\"", "  local args=$#\n\
    \  shift\n  local string=$1\n  shift\n  local positive\n  local array\n  for positive\
    \ in $string; do\n    array=($positive)\n    if [[ ${#array[@]} = 0 ]]; then\n\
    \      echo \"${positive}\"\n    else\n      echo \"${array[*]}\"\n    fi\n  done\n\
    \  echo \"${positive}\"", "    local x\n    x=\"$1\" | sed 's/ /\\n/g' | grep\
    \ -v -E '^-[0-9]+$'\n    echo -n \"${x}\"", "    local input=\"$1\"\n    local\
    \ positive=\"\"\n\n    for element in $(echo $input | tr \" \" \",\"); do\n  \
    \      if [[ \"$element\" =~ ^-?[0-9]+$ ]]; then\n            positive=\"$positive\
    \ \\\"$element\\\"\"\n        fi\n    done\n\n    echo \"$positive\"", "  local\
    \ elements=$1\n  echo \"${elements//[^[:digit:]]/}\"", "    local -n list=\"$1\"\
    \n    local ret=()\n    local i=0\n    while [[ $i -lt $((${#list[@]})) ]]; do\n\
    \        if [[ ${list[$i]} =~ ^-?[0-9]+$ ]]; then\n            (( i++ ))\n   \
    \     else\n            ret+=(\"${list[$i]}\")\n        fi\n    done\n    return\
    \ \"${ret[@]}\"", "  local IFS=\" \"\n  local L\n  local RESULT\n\n  L=$1\n  RESULT=`echo\
    \ $L | sed -E 's/^\\s*(-[0-9]+(\\.[0-9]+)?)\\s*/\"\\1\"/g'`\n  echo -n $RESULT",
  "    local list=\"$1\"\n    local result=$(printf '[%s]' \"$list\")\n    local num\n\
    \n    while read num; do\n        [[ $num =~ ^-?[0-9]+$ ]] || continue\n     \
    \   result=$(echo \"$result \\\"$num\\\"\" | grep -v '^$')\n    done <<< \"$result\"\
    \n    echo \"$result\"", "    local list=\"$1\"\n    local tmp\n\n    tmp=$(echo\
    \ \"$list\" | grep -v \"^$\" | grep -v \"^[^[:space:]]$\" | grep -v \"^[^-[:space:]]$\"\
    \ | grep \"^[+\\-]\")\n    if [ -z \"$tmp\" ] || [ \"$tmp\" == \"$list\" ]; then\n\
    \        return\n    fi\n    echo $(echo \"$tmp\" | sed 's/^[+\\-]*//')", "  local\
    \ input=$1\n  # $input is space-separated list\n  local positive=()\n  local i\n\
    \  for i do\n    if [[ ${input} == -* ]]; then\n      positive+=(${input:${#input}-1})\n\
    \    else\n      positive+=($i)\n    fi\n  done\n  echo ${positive[@]}", "   \
    \ local list=\"$1\"\n    local positive=()\n\n    for element in $list; do\n \
    \       if (( $(expr match \"$element\" '^[+-]?[0-9]+$') > 0 )) ; then\n     \
    \       positive+=(\"$element\")\n        fi\n    done\n\n    echo \"${positive[@]}\"",
  "    IFS=' ' read -r -a numbers <<< \"$1\"\n    local -a result=()\n    for number\
    \ in \"${numbers[@]}\"; do\n        [[ $(test -z \"$number\" || [[ \"$number\"\
    \ =~ ^-[0-9]+$ ]]) ]] || result+=(\"$number\")\n    done\n    echo \"${result[@]}\"",
  "    echo \"$1\" | awk -F \"[ ,]\" '{for(i=1;i<=NF;i++) if($i>0) print $i}'", " \
    \ local items x xs y\n  IFS=$'\\n' xs=( $1 )\n  printf '%s\\n' \"${xs[@]}\" |\
    \ grep -Ev '^[[:space:]]+|[+]*$' | while read -a x; do\n    for y in \"${x[@]:1}\"\
    ; do\n      if [[ $y =~ ^[+-]?[0-9]+$ ]]; then\n        echo \"$y\"\n        break\
    \ 2\n      fi\n    done\n  done", "  local list_string=\"$1\"\n  local list_string_list=($list_string)\n\
    \  local list_string_list_length=${#list_string_list[@]}\n  local list_string_list_string=${list_string_list[*]}\
    \ \n  local list_string_list_string_split=(${list_string_list_string// / })\n\
    \  local list_string_list_string_split_length=${#list_string_list_string_split[@]}\n\
    \  local list_string_list_string_split_string=${list_string_list_string_split[*]}\
    \ \n  local list_string_list_string_split_string_values=()\n  local list_string_list_string_split_string_values_length=${#list_string_list_string_split_string_values[@]}\n\
    \  local list_string_list_string_split_string_values_string=${list_string_list_string_split_string_values[*]}\
    \ \n  local list_string_list_string_split_string_values_string_split=(${list_string_list_string_split_string_values_string//\
    \ / })\n  local list_string_list_string_split_string_values_string_split_length=${#list_string_list_string_split_string_values_string_split[@]}\n\
    \  local list_string_list_string_split_string_values_string_split_string=${list_string_list_string_split_string_values_string_split[*]}\
    \ \n  local list_string_list_string_split_string_values_string_split_string_values=()\n\
    \  local list_string_list_string_split_string_values_string_split_string_values_length=${#list_string_list_string_split_string_values_string_split_string_values[@]}\n\
    \  local list_string_list_string_split_string_values_string_split_string_values_string=${list_string_list_string_split_string_values_string_split_string_values[*]}\
    \ \n  local list_string_list_string_split_string_values_string_split_string_values_string_split=(${list_string_list_string_split_string_values_string_split_string_values_string//\
    \ / })\n  local list_string_list_string_split_string_values_string_split_string_values_string_split_length=${#list_string_list_string_split_string_values_string_split_string_values_string_split[@]}\n\
    \  local list_string_list_string_split_string_values_string_split_string_values_string_split_string_values=()\n\
    \  local list_string_list_string_split_string_values_string_split_string_values_string_split_string_values_length=${#list_string_list_string_split_string_values_string_split_string_values_string_split_string_values[@]}\n\
    \  local list_string_list_string_split_string_values_string_split_string_values_string_split_string_values_string=${list_string_list_string_split_string_values_string_split_string_values_string_split_string_values[*]}\
    \ \n  ", "    local input=${1// /$1}\n    local numbers=()\n    for number in\
    \ ${input}; do\n        if (( ${number} > 0 )); then\n            numbers+=(\"\
    ${number}\")\n        fi\n    done\n    echo \"${numbers[*]}\"", "  local items=$1\n\
    \  echo \"$items\" | grep -v '^[[:space:]]*#' | grep -v '^$' | sed -e 's/ //g'\
    \ | grep -Ev '^-+$' | grep -Ev '^-\\+$' | tr '\\n' ' ' | grep '^\\+' | sed 's/^\\\
    +\\+ //g'", "    # Assumes first argument is a list\n    local tmp pos \"IFS=\\\
    \\n\" tmpstr=0 max=0\n    for str in $1; do\n        pos=$((pos=$(echo $str |\
    \ grep -o -P \"\\d+\" | wc -l)))\n        if [[ $pos -gt $max ]]; then\n     \
    \       tmp=$str\n            tmpstr=$pos\n            max=$pos\n        fi\n\
    \    done\n    if [[ $tmpstr -ne $max ]]; then\n        echo ''\n    else\n  \
    \      echo \"$tmp\"\n    fi", "    local a b\n    for a in \"${@}\"; do\n   \
    \     b=0\n        for b in \"${a}\"; do\n            [[ \"$b\" == \"-\" || \"\
    $b\" == \"+\" || \"$b\" == \"0\" ]] && continue\n            b=$(( ${b} + 1))\n\
    \        done\n        echo \"$(( ${a}${b} ))\"\n    done", "  local var=$1\n\
    \  local tmp\n  local ret=$(echo \"$var\" | grep -o '^-?[0-9]*$')\n  if [ -z \"\
    $ret\" ]; then\n    echo []\n  else\n    echo \"\"\n    local list=$(echo \"$ret\"\
    \ | tr ' ' ',')\n    while read tmp; do\n      list=\"$list '$tmp'\"\n    done\
    \ < <(echo \"$list\" | sort -n | uniq)\n    echo \"$list\"\n  fi", "  local positive=\n\
    \  local n=$#\n  local i\n  local c\n  for i in $*; do\n    # if the element is\
    \ a number (negative), then add it to positive\n    if [[ $i =~ ^-?[0-9]+ ]];\
    \ then\n      (( n-- ))\n      if [[ \"$n\" -eq 0 ]]; then\n        positive+=\"\
    \ $i\"\n      fi\n    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+ ]]; then\n      (( n--\
    \ ))\n      if [[ \"$n\" -eq 0 ]]; then\n        positive+=\" $i\"\n      fi\n\
    \    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+ ]]; then\n      (( n-- ))\n   \
    \   if [[ \"$n\" -eq 0 ]]; then\n        positive+=\" $i\"\n      fi\n    elif\
    \ [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+ ]]; then\n      (( n-- ))\n  \
    \    if [[ \"$n\" -eq 0 ]]; then\n        positive+=\" $i\"\n      fi\n    elif\
    \ [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+ ]]; then\n      (( n--\
    \ ))\n      if [[ \"$n\" -eq 0 ]]; then\n        positive+=\" $i\"\n      fi\n\
    \    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+ ]];\
    \ then\n      (( n-- ))\n      if [[ \"$n\" -eq 0 ]]; then\n        positive+=\"\
    \ $i\"\n      fi\n    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+ ]]; then\n      (( n-- ))\n      if [[ \"$n\" -eq 0 ]]; then\n\
    \        positive+=\" $i\"\n      fi\n    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+[0-9]+ ]]; then\n      (( n-- ))\n      if [[\
    \ \"$n\" -eq 0 ]]; then\n        positive+=\" $i\"\n      fi\n    elif [[ $i =~\
    \ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+ ]];\
    \ then\n      (( n-- ))\n      if [[ \"$n\" -eq 0 ]]; then\n        positive+=\"\
    \ $i\"\n      fi\n    elif [[ $i =~ ^-?[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+",
  "    local str=$1\n    local list=(${str//[\" \"]/ })\n    for i in ${list[@]};\
    \ do\n        if [[ $i =~ ^-?[0-9]+$ ]]; then\n            list=${list[@]//$i/}\n\
    \        fi\n    done\n    echo \"${list[@]}\"", "  local list_in_quotes=$(eval\
    \ \"echo \\\"$1\\\"\")\n  echo $list_in_quotes | tr \" \" \"\\n\" | grep -E '^-[0-9]+$'",
  "    local list=$1\n    local i positive tmp\n    positive=()\n    for ((i=0; i\
    \ < ${#list[@]}; i++)); do\n        tmp=$(expr $list[$i] \\< 0)\n        if ((\
    \ $tmp )); then\n            positive+=(\"\\\"${list[$i]}\\\"\" )\n        fi\n\
    \    done\n    echo ${positive[@]}", "    local list_in list_out\n    list_in=$1\n\
    \    while IFS= read -r line ; do\n        if [[ $line =~ ^- ]]; then\n      \
    \      list_out=(\"${list_out[@]}\" \"$line\")\n        else\n            list_out=(\"\
    ${list_out[@]}\" \"$line\")\n        fi\n    done <<< \"$list_in\"\n    printf\
    \ '[%s]' \"${list_out[@]}\"", "    local _list\n    _list=\"$1\"\n    local _result=()\n\
    \    local i\n    for (( i = 0; i < ${#_list}; ++i )); do\n        local _item=${_list}${i}\n\
    \        if [[ $_item =~ ^(-[0-9]+)$ ]]; then\n            _result+=(\"$_list\"\
    )\n            _list=${_list:0:i}${_list[i:i+1]}\n            ((i--))\n      \
    \  fi\n    done\n    echo \"${_result[@]}\"", "\techo \"$@\" | grep -P '^\\-?[0-9]+$'",
  "\tlocal _list=\"${1}\"\n\tlocal _positive=()\n\tfor e in $_list; do\n\t\tif [ \"\
    $e\" -gt 0 ]; then\n\t\t\t_positive+=(\"\\\"$e\\\"\")\n\t\tfi\n\tdone\n\techo\
    \ ${_positive[@]}", "    local LIST=\"$1\"\n    local TMP=()\n    local COUNT=0\n\
    \n    # Convert all numbers into strings, so that we can use arithmetic\n    #\
    \ operations on them. Otherwise, we'd have to deal with some \"strings\"\n   \
    \ # like \"-1.23\", \"123a\".\n    for ITEM in ${LIST}; do\n        if [[ \"$ITEM\"\
    \ =~ ^-?[0-9]+$ ]]; then\n            ((COUNT++))\n            TMP+=(\"\\\"$ITEM\\\
    \"\")\n        else\n            # Assume that all entries are numbers\n     \
    \       TMP+=(\"$ITEM\")\n        fi\n    done\n\n    # All entries are now strings,\
    \ sort them and take only positive\n    # numbers, as needed.\n    TMP=(\"${TMP[@]}\"\
    \ | sort -nu | grep -E '^-+')\n    echo \"${TMP[@]}\"", "\tlocal numbers=$1\n\t\
    echo \"${numbers}\"\n\techo \"${numbers//[^[:digit:]]/}\"", "  local list_array=($1)\n\
    \  local positive_list=()\n  for item in ${list_array[@]}; do\n    echo $item\
    \ | grep -q \"^[[:digit:]]\\+$\" && echo ${item}\n  done | sort -n", "  # Split\
    \ on space to generate an array.\n  local my_array=($@)\n  local my_positive\n\
    \  # Find positive numbers, store in my_positive.\n  local counter=0\n  local\
    \ max=0\n  for my_number in \"${my_array[@]}\"; do\n    ((counter++))\n    if\
    \ [[ \"$my_number\" =~ ^-?[0-9]+$ ]]; then\n      my_positive+=($my_number)\n\
    \      max=$((max+$my_number))\n      if [ $counter -eq 1 ]; then\n        echo\
    \ \"$my_positive\"\n        exit 0\n      fi\n    fi\n  done\n  # If all numbers\
    \ zero, print empty list\n  if [[ $counter -eq 0 ]]; then\n    echo \"$my_positive\"\
    \n    exit 0\n  fi\n  # Return only positive numbers\n  echo \"$my_positive\"",
  "    local xs ys zs i\n    for xs in \"$@\"; do\n        [[ $xs == \"-0\" || $xs\
    \ == \"0\" ]] && continue\n        for ys in $xs; do\n            [[ $ys == -*\
    \ ]] || continue\n            for ((i=0;i<ys;i++)); do\n                zs=\"\
    ${zs}1\"\n            done\n            echo \"$zs\"\n        done\n    done",
  "  local list_=\"$1\"\n\n  # Split into individual values.\n  IFS=' ' read -r -a\
    \ values <<< \"$list_\"\n\n  # Return only positive values.\n  echo \"${values[@]}\"",
  "  local list=$1\n  echo $list | awk '{for(i=1;i<=NF;i++) if((i-1)>=0&&($i)<0) print\
    \ $(--$i)}'", "    local i ret=()\n    for i in; do\n        [[ $i =~ ^[+-]?([0-9]+(\\\
    .[0-9]+)?|Infinity)$ ]]\n        if [[ $i =~ ^[+-]?[0-9]+$ ]]; then\n        \
    \    echo \"$i\"\n        fi\n    done", "    local _list _pos\n    _list=\"$1\"\
    \n    _pos=$(echo $_list | grep -P '^\\-*[0-9]+$')\n    echo \"$_list\"\n    echo\
    \ \"$(_pos | tr -d '\"')\"", "  local list=\"$1\"\n  echo \"$(echo \"$list\" |\
    \ sed -n 's/[^ ]\\+\\([0-9]\\+\\)/\"\\1\"/p')\"", "    local numbers=$1 \n   \
    \ local positive_numbers \n    local result=()\n    for number in $numbers; do\n\
    \        [[ \"$number\" =~ ^-([0-9]+) ]] && result+=(\"${BASH_REMATCH[1]}\");\
    \ \n    done\n    printf '%s\\n' \"${result[@]}\"", "  local _list\n  _list=\"\
    $(echo \"$1\" | tr '-' '\\n' | sort --numeric-sort --reverse | tr '\\n' ' ')\"\
    \n  echo \"$_list\"", "    if [[ -n $1 ]] && [[ \"$1\" =~ ^-?[0-9]+$ ]]\n    then\n\
    \        echo \"\\\"$1\\\"\"\n    else\n        echo \"$(get_positive_all \"$1\"\
    )\"\n    fi", "    local list=\"$1\"\n    local positive=()\n    for p in \"${list[@]}\"\
    ; do\n        [ \"$p\" -ge 0 ] || continue\n        positive+=(\"$p\")\n    done\n\
    \    echo \"${positive[@]}\"", "  echo \"$1\" |\n    # Strip leading whitespace\n\
    \    sed -e 's/^[ \\t]*//' -e 's/[ \\t]*$//' |\n    # Remove negative sign\n \
    \   sed -e 's/^-\\(.*\\)/\\1/' |\n    # Strip leading sign\n    sed -e 's/^(\\\
    +\\-?)/\\1/' |\n    # Strip leading zeroes\n    sed -e 's/^0*\\([0-9]\\)/\\1/'\
    \ |\n    # Split on space\n    tr ' ' '\\n' |\n    # Trim whitespace\n    sed\
    \ -e 's/^[[:space:]]*\\([[:digit:]]\\+\\)\\([[:space:]]*\\)/\\1\\2/'", "    local\
    \ IFS=' ' arr=( \"$1\" )\n    local ret=()\n    local i\n    for ((i = 0; i <\
    \ \"${#arr[@]}; i++)); do\n        if (( \"${arr[i]}\" < 0 )); then\n        \
    \    ret+=( \"${arr[i]}\" )\n        fi\n    done\n    echo \"${ret[@]}\"", " \
    \   local list prefix result\n    list=\"${1}\"\n    prefix=$2\n    result=()\n\
    \    for a in ${list}; do\n        if [[ \"$a\" =~ ^-([0-9]+) ]] ; then\n    \
    \        result+=(\"$prefix\\\"${BASH_REMATCH[1]}\")\n        fi\n    done\n \
    \   echo \"${result[@]}\"", "    echo $(echo \"$1\" | sed 's/^\\([-+]\\).*/\"\\\
    1\"/' | sed 's/-\\([1-9]\\)/-\"&\"/' | sed 's/^\"//' | sed 's/\"$//')", "    local\
    \ l\n    for l in $*; do\n        case \"$l\" in\n        [0-9][0-9]* | -*)\n\
    \            printf \"\\\"%s\\\"\" ${l}\n            ;;\n        *)\n        \
    \    printf \"\\\"%s\\\"\" \"\"\n            ;;\n        esac\n    done", "  local\
    \ x i=0 neg\n  x=\"$1\"\n  shift\n  while [[ \" $x \" =~ ^-?[0-9]+ ]]; do\n  \
    \  (( i++ ))\n    neg=\"$neg -$x\"\n    x=\"${x%% -*}\"\n  done\n  if [ -n \"\
    $neg\" ]; then echo \"-$neg\"; fi\n  echo \"$x\"", "    local IFS=\" \"\n    local\
    \ numbers=$(echo $1 | sed -E \"s/(^|[\\s-]).*//g\" | tr -d '[]')\n    local positives=$(echo\
    \ $numbers | awk -F'[ ]+' '{ for (i=NF; i>0; i--) if ($i>0) print $i, \"1\"; else\
    \ print $i, \"0\"; exit }' | paste -s -d ,)\n    echo $positives", "    local\
    \ list=\"$1\"\n    local positive=()\n    local item pos\n    IFS=\" \" read -r\
    \ -a array <<<\"$list\"\n    for item; do\n        pos=$(( $item > 0 ))\n    \
    \    if [[ \"$pos\" != \"$pos\" ]]; then\n            positive+=(\"$item\")\n\
    \        fi\n    done\n    echo \"${positive[@]}\"", "    local numbers=$1\n \
    \   local ret=()\n    while read -r number; do\n        if [[ \"$number\" =~ ^[0-9]+$\
    \ ]]; then\n            local is_positive=false\n            if [[ $(get_absolute\
    \ \"$number\") == \"$number\" ]]; then\n                is_positive=true\n   \
    \         fi\n            if $is_positive; then\n                echo \"$number\"\
    \n                ret+=($number)\n            fi\n        fi\n    done <<< \"\
    $numbers\"\n    echo \"${ret[@]}\"", "  grep -E '^-[0-9]+$' \"$1\" |\n    tr '\\\
    n' ' ' |\n    grep -E '^[+\\-]$'", "    local l=${1}\n    local ret=${l}\n   \
    \ for (( i=0; i<${#l}; i++ )); do\n        [[ ${l[i]} =~ ^- ]] && ret=\"${ret}\
    \ ${l[i]}\"\n    done\n    echo \"${ret}\"", "  local input=\"$1\"\n  # Escape\
    \ the string\n  input=\"${input//\\//\\\\/}\"\n  # Remove negative sign\n  input=\"\
    ${input//-}\"\n  # Re-add quotes\n  input=\"\\\"${input//\\\"/\\\"\\`\\\"\\\"\\\
    \"}\"\n  # Remove leading and trailing quotes\n  input=\"${input#\\\"}\"\n  input=\"\
    ${input%\\\"}\"\n  echo \"$input\"", "  local str\n  local num_arr=()\n  local\
    \ i\n  str=$1\n  for ((i=0; i<${#str[@]}; i++)); do\n    num_arr+=(${str:$i:1})\n\
    \  done\n  echo \"${num_arr[@]}\"", "    local input=\"$1\"\n    local output=$(echo\
    \ \"$input\" | xargs -P$(nproc) -n1 bash -c '[[ \"$1\" =~ ^-[0-9]+$ ]] && echo\
    \ ${1//-/ }'\n                        | sed 's/ //g')\n    echo \"$output\"",
  "   set -- $1 $2 $3 $4 $5 $6 $7 $8 $9\n   [ $# -eq 0 ] && return 0\n   for i in\
    \ `seq 1 9`;\n      do\n         if [ $i -ge 0 ]; then\n            # Append the\
    \ quotation marks and remove all whitespace\n            echo $'\"$(echo \"$i\"\
    \ | sed 's/ //g')\"' >> \"$3\" || return 1\n         else\n            return\
    \ 0\n         fi\n      done", "\tlocal L=${1:?}\n\tlocal IFS=$'\\t'\n\tlocal\
    \ LIST=$(echo \"${L}\" | sed \"s/^ *//\" | sed \"s/ *$//\" | sed 's/[+-]\\+/+/'\
    \ | sed 's/-$//')\n\tlocal TOT=0\n\tfor i in $LIST; do\n\t\tTOT=$(($TOT+$i)) #+$i\
    \ to count only positive numbers\n\tdone\n\techo \"$LIST\"\n\techo \"$TOT\""]
stop_tokens:
- "\n}"
