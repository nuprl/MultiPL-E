name: HumanEval_160_do_algebra
language: sh
prompt: "#!/bin/bash\n# Given two lists operator, and operand. The first list has\
  \ basic algebra operations, and \n# the second list is a list of integers. Use the\
  \ two given lists to build the algebric \n# expression and return the evaluation\
  \ of this expression.\n# The basic algebra operations:\n# Addition ( + ) \n# Subtraction\
  \ ( - ) \n# Multiplication ( * ) \n# Floor division ( // ) \n# Exponentiation (\
  \ ** ) \n# Example:\n# operator['+', '*', '-']\n# array = [2, 3, 4, 5]\n# result\
  \ = 2 + 3 * 4 - 5\n# => result = 9\n# Note:\n# The length of operator list is equal\
  \ to the length of operand list minus one.\n# Operand is a list of of non-negative\
  \ integers.\n# Operator list has at least one operator, and operand list has at\
  \ least two operands.\n#\n# $1 is a space-separated list\n# $2 is a space-separated\
  \ list\ndo_algebra() {\n"
tests: "}\n\ncandidate() {\n    do_algebra \"$@\"\n}\n\nset -e\nrun_test() {\n   \
  \ [[ $(candidate \"** * +\" \"2 3 4 5\") = \"37\" ]]\n    [[ $(candidate \"+ * -\"\
  \ \"2 3 4 5\") = \"9\" ]]\n    [[ $(candidate \"// *\" \"7 3 4\") = \"8\" ]]\n}\n\
  \nrun_test"
completions: ["    declare -a operator\n    declare -a operand\n    # Parse the operator\
    \ list into operator array\n    while read -r operator || [[ -n \"$operator\"\
    \ ]]; do\n        operator+=( \"$operator\" )\n    done < \"$1\"\n    # Parse\
    \ the operand list into operand array\n    while read -r operand || [[ -n \"$operand\"\
    \ ]]; do\n        operand+=( \"$operand\" )\n    done < \"$2\"\n    # Build the\
    \ algebraic expression\n    eval \"result=$( IFS=$'\\n' \"\n        # Loop through\
    \ the operator array\n        for i in \"${!operator[@]}\"; do\n            #\
    \ The i-th operator in the operator array\n            operation=${operator[i]}\n\
    \            # The i-th operand in the operand array\n            operand=${operand[i]}\n\
    \            # The i-th operand in the operand array\n            result=$( eval\
    \ \"\n                # Loop through the operand array\n                for j\
    \ in \"${!operand[@]}\"; do\n                    operand=${operand[j]}\n     \
    \               eval '$operand $operation $operand'\n                done\"\n\
    \            )\n        done\"\n    )\n    echo \"$result\"", "    echo \"$1 $2\"\
    \n    operand=$($1 $2)\n    operator=$($1 $2)\n    echo \"$operand\"\n    echo\
    \ \"$operator\"\n    echo \"$operand\"", "  if [[ ${#1} == 1 ]] || [[ ${#2} ==\
    \ 1 ]] || [[ ${#1} == ${#2} == 1 ]]; then\n    echo \"ERROR: Operator list must\
    \ be a space separated list\"\n    echo \"ERROR: Operand list must be a space\
    \ separated list\"\n    echo \"ERROR: Operator list must be the same length as\
    \ operand list\"\n    echo \"ERROR: Operand list must be the same length as operand\
    \ list\"\n    echo \"ERROR: operator and operand list must contain at least one\
    \ operator\"\n    echo \"ERROR: operator and operand list must contain at least\
    \ one operand\"\n    exit 1\n  else\n    operator=${1}\n    operand=${2}\n   \
    \ echo \"operator=${operator}\"\n    echo \"operand=${operand}\"\n    \n    operator=${operator//[,]*}\n\
    \    operand=${operand//[,]*}\n    \n    case \"${operator}\" in\n      +) \n\
    \        operand=${operand//[+-*/]}\n        echo \"+\" ${operand}\n        \n\
    \        operand=${operand//[+-*/]}\n        result=$(( ${operand} + ${operand}\
    \ ))\n        echo $result\n        ;;\n      -)\n        operand=${operand//[+-*/]}\n\
    \        echo \"-\" ${operand}\n        \n        operand=${operand//[+-*/]}\n\
    \        result=$(( ${operand} - ${operand} ))\n        echo $result\n       \
    \ ;;\n      *)\n        operand=${operand//[+-*/]}\n        echo \"*\" ${operand}\n\
    \        \n        operand=${operand//[+-*/]}\n        result=$(( ${operand} *\
    \ ${operand} ))\n        echo $result\n        ;;\n      /)\n        operand=${operand//[+-*/]}\n\
    \        echo \"//\" ${operand}\n        \n        operand=${operand//[+-*/]}\n\
    \        result=$(( ${operand} / ${operand} ))\n        echo $result\n       \
    \ ;;\n      **)\n        operand=${operand//[+-*/]}\n        echo \"**\" ${operand}\n\
    \        \n        operand=${operand//[+-*/]}\n        result=$(( ${operand} **\
    \ ${operand} ))\n        echo $result\n        ;;\n      *)\n        echo \"ERROR:\
    \ Invalid operator\"\n        exit 1\n        ;;\n    esac\n  fi", "\toperator=${1:-'+'}\n\
    \tarray=${2:-$(echo \"$array\" | sed 's/,/ /g')}\n\tresult=0\n\tfor element in\
    \ \"${array[@]}\"\n\tdo\n\t\tresult=$(( $result + $element ))\n\tdone\n\tresult=$((\
    \ $result ))\n\techo \"$operator\"\n\techo \"$result\"", "\techo \"${array1[$1]}\
    \ ${array2[$1]} ${array3[$1]}\" | bc", "  local op_str result_str\n  local operator\
    \ operand\n  operator=\"$1\"\n  operand=\"$2\"\n  op_str=$(IFS=', '; echo \"$operator\"\
    )\n  result_str=$(IFS=', '; echo \"$operand\")\n  operator=$(echo \"$operator\"\
    \ | tr '[A-Z]' '[a-z]')\n  operand=$(echo \"$operand\" | tr '[A-Z]' '[a-z]')\n\
    \n  case \"$operator\" in\n      *) echo \"ERROR: operator[$operator] is invalid.\"\
    ;;\n      +) echo \"$operand1 + $operand2\";;\n      -) echo \"$operand1 - $operand2\"\
    ;;\n      *) echo \"ERROR: operator[$operator] is invalid.\";;\n  esac", "\toperator=$1\n\
    \toperand=$2\n\toperand2=${operand[1]}\n\toperator2=${operator[1]}\n\toperator2=${operator[2]}\n\
    \toperand2=${operand[2]}\n\tresult=$((${operand2} ${operator2} ${operand}))\n\t\
    echo \"${result}\"", "  # Assumes both lists are same length\n  local OPERATOR\
    \ $1\n  local OP $2\n  local OPR\n  local OPR1\n  local OPR2\n  local OPR_STR\n\
    \  local OPR1_STR\n  local OPR2_STR\n  local OPR1_NUM\n  local OPR2_NUM\n  local\
    \ OPR_NUM\n  local OPR1_STR2\n  local OPR2_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local\
    \ OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n\
    \  local OPR_STR2\n  local OPR_STR2\n  local OPR_STR2\n  local OPR_", "\tlocal\
    \ operator=$1\n\tlocal operand=$2\n\tlocal result=$(( ${operand}${operator}${operand}\
    \ ))\n\techo \"$result\"", "    local operator=$1\n    local operand=$2\n    local\
    \ result=\"?\"\n    local index=1\n    while [[ \"$index\" -lt \"${#operand}\"\
    \ ]]; do\n        case \"${operator}\" in\n            # Addition ( + ) \n   \
    \         -\\+ ) result=${result}${operand:$index}\n                    index=$((\
    \ index + 1 ))\n                    ;;\n            # Subtraction ( - ) \n   \
    \         -\\- ) result=${result}${operand:$index}\n                    index=$((\
    \ index + 1 ))\n                    ;;\n            # Multiplication ( * ) \n\
    \            \\* ) result=${result}${operand:$index}\n                    index=$((\
    \ index + 1 ))\n                    ;;\n            # Floor division ( // ) \n\
    \            \\// ) result=${result}${operand:$index}\n                    index=$((\
    \ index + 1 ))\n                    ;;\n            # Exponentiation ( ** ) \n\
    \            \\** ) result=${result}${operand:$index}\n                    index=$((\
    \ index + 1 ))\n                    ;;\n        esac\n    done\n    local final_result\n\
    \    if [[ \"${result}\" != \"${operand}\" ]]; then\n        final_result=$(echo\
    \ \"${result}${operand}\" | bc)\n    fi\n    echo $final_result", "    \n    local\
    \ OPERATORS=(\"+\")\n    local EXPRESSION=(\"$1\")\n    local ARRAY=(\"$2\")\n\
    \    local LENGTH=${#OPERATORS[@]}\n    local ELEMENT=0\n    local NUM=0 \n  \
    \  local RESULT=0\n    local EXPRESSION_LIST=()\n\n    for (( ELEMENT = 0; ELEMENT\
    \ < LENGTH; ELEMENT++ )); do\n        (( RESULT = ( RESULT + ${ARRAY[ELEMENT]}\
    \ )${OPERATORS[ELEMENT]}))\n    done\n    echo \"RESULT=$RESULT\"\n    echo \"\
    EXPRESSION_LIST=${EXPRESSION_LIST[@]}\"\n    eval \"$RESULT\"", "    operator=$1\n\
    \    operand=$2\n\n    res=$(eval $operator $operand)\n\n    echo \"$res\"", " \
    \ operator=\"$1\"\n  operand=\"$2\"\n  result=0\n  # Get the first operand\n \
    \ op1=$(awk \"$operator\" <<< $operand)\n  # Get the rest of the operands\n  op2=$(awk\
    \ \"$operator\" <<< $((${#operand}-1))); \n  # Do the operation\n  result=$((op1\
    \ + op2))\n  return $result", "  operator=$1\n  array=$2\n  result=0\n  len=${#array[@]}\n\
    \  \n  for ((i=1; i<=len; i++ ))\n    do\n      eval \"result=${array[i-1]} ${operator[i-1]}\
    \ ${array[i]}\"\n    done\n  echo $result", "  local OPERATOR $(cat) $(cat)\n\
    \  local OPERANDS $(cat) $(cat)\n  local RESULT $(cat)\n  OPERATOR=$1\n  OPERANDS=$2\n\
    \  RESULT=0\n  while [[ $OPERANDS ]]; do\n    OPERAND=$(echo ${OPERANDS} | sed\
    \ 's/^ *//;s/ *$//;/^ *$/d')\n    OPERATORS=$(echo $OPERATOR | sed 's/ /\\+/g;s/+/\
    \ /g')\n    RESULT=$($OPERATORS ${OPERAND})\n    OPERANDS=$(echo $OPERANDS | sed\
    \ 's/ //g;s/ *$//')\n  done\n  echo $RESULT", "  local OP=$1\n  local OP2=$2\n\
    \  local RESULT\n  local OPERANDS\n  local RESULT2\n  local OPERANDS2\n  local\
    \ LENGTHOP\n  local LENGTHOP2\n  local i\n  local j\n  local k\n  local l\n  local\
    \ m\n  local n\n  local o\n  local p\n  local q\n  local r\n  local s\n  local\
    \ t\n  local u\n  local v\n  local w\n  local x\n  local y\n  local z\n  local\
    \ A\n  local B\n  local C\n  local D\n  local E\n  local F\n  local G\n  local\
    \ H\n  local I\n  local J\n  local K\n  local L\n  local M\n  local N\n  local\
    \ O\n  local P\n  local Q\n  local R\n  local S\n  local T\n  local U\n  local\
    \ V\n  local W\n  local X\n  local Y\n  local Z\n\n  LENGTHOP=${#OP[*]}\n  LENGTHOP2=${#OP2[*]}\n\
    \n  if [ $LENGTHOP -eq 0 ]\n  then\n    echo No operands given. Terminating.\n\
    \    exit 0\n  fi\n  if [ $LENGTHOP2 -eq 0 ]\n  then\n    echo No operators given.\
    \ Terminating.\n    exit 0\n  fi\n\n  OPERANDS=${OP[*]}\n  OPERANDS2=${OP2[*]}\n\
    \n  if [ $LENGTHOP -gt 1 ]\n  then\n    echo Length of operands list must be 0\
    \ or greater. Terminating.\n    exit 0\n  fi\n\n  if [ $LENGTHOP2 -gt 1 ]\n  then\n\
    \    echo Length of operators list must be 0 or greater. Terminating.\n    exit\
    \ 0\n  fi\n\n  if [ $OPERANDS -eq \"\" ]\n  then\n    echo No operands given.\
    \ Terminating.\n    exit 0\n  fi\n\n  if [ $OPERANDS2 -eq \"\" ]\n  then\n   \
    \ echo No operators given. Terminating.\n    exit 0\n  fi\n\n  RESULT=`expr $OPERANDS\
    \ ${OPERANDS2[0]}`\n  RESULT2=`expr $OPERANDS ${OPERANDS2[1]}`\n\n  for (( i =\
    \ 1; i < ($LENGTHOP - 2); i++ ))\n  do\n    OPERAND", "    operator=$1\n    operand=$2\n\
    \    result=\"\"\n    operator_index=0\n    operand_index=1\n    while [ \"${operand_index}\"\
    \ -lt \"${#operand}\" ]; do\n        if [[ \"${operator_index}\" -eq \"${#operator}\"\
    \ ]]; then\n            operator_index=0\n        fi\n        operator=${operator::${operator_index}}\n\
    \        operand=${operand::${operand_index}}\n        case \"${operator}\" in\n\
    \            *)\n                # We are done here because there is something\
    \ in the operator list\n                break\n                ;;\n        esac\n\
    \        case ${operand} in\n            -* | --)\n                # We are done\
    \ here because there is something in the operand list\n                break\n\
    \                ;;\n            *)\n                # We are done here because\
    \ there is something in the operand list\n                break\n            \
    \    ;;\n        esac\n        case \"${operator}\" in\n            *)\n     \
    \           # We are done here because there is something in the operator list\n\
    \                break\n                ;;\n        esac\n        result=\"${result}${operand}\"\
    \n        ((operand_index+=1))\n        ((operator_index+=1))\n    done\n    echo\
    \ \"${result}\"", "  local operator operand\n  for ((i = 0; i < ${#1}; i++));\
    \ do\n    operator=${1}[i]\n    operand=${2}[i]\n    # Case 1: operand is an empty\
    \ list\n    if [ \"$operand\" == \"[]\" ]; then\n      echo \"[]\"\n      continue\n\
    \    # Case 2: operand is a positive integer\n    elif [ \"$operand\" == \"[!0-9]\"\
    \ ]; then \n      echo ${operand}\n      continue\n    # Case 3: operand is a\
    \ negative integer\n    elif [ \"$operand\" == \"[-0-9]\" ]; then \n      echo\
    \ -${operand}\n      continue\n    # Case 4: operand is a non-negative integer\n\
    \    elif [ \"$operand\" == \"[0-9]\" ]; then \n      echo $((${operand}))\n \
    \     continue\n    # Case 5: operand is a non-negative integer\n    elif [ \"\
    $operand\" == \"[-]\" ]; then \n      echo -${operand}\n      continue\n    #\
    \ Case 6: operand is zero\n    elif [ \"$operand\" == \"[0]\" ]; then \n     \
    \ echo 0\n      continue\n    # Case 7: operand is 1\n    elif [ \"$operand\"\
    \ == \"[1]\" ]; then \n      echo 1\n      continue\n    # Case 8: operand is\
    \ 2\n    elif [ \"$operand\" == \"[2]\" ]; then \n      echo 2\n      continue\n\
    \    # Case 9: operand is 3\n    elif [ \"$operand\" == \"[3]\" ]; then \n   \
    \   echo 3\n      continue\n    # Case 10: operand is 4\n    elif [ \"$operand\"\
    \ == \"[4]\" ]; then \n      echo 4\n      continue\n    # Case 11: operand is\
    \ 5\n    elif [ \"$operand\" == \"[5]\" ]; then \n      echo 5\n      continue\n\
    \    # Case 12: operand is 6\n    elif [ \"$operand\" == \"[6]\" ]; then \n  \
    \    echo 6\n      continue\n    # Case 13: operand is 7\n    elif [ \"$operand\"\
    \ == \"[7]\" ]; then \n      echo 7\n      continue\n    # Case 14: operand is\
    \ 8\n    elif [ \"$operand\" == \"[8]\" ]; then \n      echo 8\n      continue\n\
    \    # Case 15: operand is 9\n    elif [ \"$operand\" == \"[9]\" ]; then \n  \
    \    echo 9\n      continue\n    # Case 16: operand is 10\n    elif [ \"$operand\"\
    \ == \"[10]\" ]; then \n      echo 10\n      continue\n    # Case 17: operand\
    \ is 11\n    elif [ \"$operand\" == \"[11]\" ]; then \n      echo 11\n      continue\n\
    \    # Case 18: operand is 12\n    elif [ \"$operand\" == \"[12]\" ]; then \n\
    \      echo 12\n      continue\n    # Case 19: operand is 13\n", "    operator=\"\
    $1\"\n    operand=\"$2\"\n    len=${#operand}\n    if [[ ${#operand} == 0 || ${#operator}\
    \ == 1 ]] ; then\n        echo \"Incorrect number of operands/operators\"\n  \
    \      exit 1\n    fi\n\n    operators=()\n    operands=()\n    for i in `seq\
    \ 0 $((${#operator}-1))`; do\n        operators[$i]=`echo $operator | cut -d'['\
    \ -f $i`\n        operands[$i]=`echo $operand | cut -d'[' -f $i`\n    done\n\n\
    \    operator=${operators[$((${#operator}-1))]}\n    operand=${operands[$((${#operand}-1))]}\n\
    \n    OPERATOR=$operator\n    OPERAND=$operand\n    EXPRESSION=$((${OPERATOR}+${OPERAND}))\n\
    \n    echo \"$EXPRESSION\"", "    operator=$1\n    operand=$2\n    \n    local\
    \ n=0\n    local op=\"\"\n    local op2=\"\"\n    local operand2=\"\"\n    local\
    \ eval=\"\"\n    \n    for ((n=0; n<$((${#operand} - 1)); n++))\n    do\n    \
    \    op=${operand:$n:1}\n        op2=${operand:$n:2}\n        operand2=${operand:$n:3}\n\
    \        eval=$(( eval + ${!op} ${!op2} ${!operand2} ))\n    done\n\n    eval=${eval:0:1}\n\
    \    echo \"$eval\"", "    # Read the first list for the operators list\n    local\
    \ operator operand\n    operator=$1\n    operand=$2\n    \n    local num1\n  \
    \  local num2\n    local result\n\n    # Parse each operand and operator from\
    \ the list\n    for ((i=1; i<${#operand}; i++)); do\n        # Read the operand\
    \ and store the value\n        num1=$( echo $operand | cut -d' ' -f${i} )\n  \
    \      # Read the operator and store the value\n        num2=$( echo $operator\
    \ | cut -d' ' -f${i} )\n        \n        if [ \"$num1\" -eq \"0\" ] ; then\n\
    \            # If the operand is zero skip this iteration\n            continue\n\
    \        fi\n        \n        case \"$num2\" in\n            +)\n           \
    \     result=$(( num1 + num2 ))\n                ;;\n            -)\n        \
    \        result=$(( num1 - num2 ))\n                ;;\n            *)\n     \
    \           result=$(( num1 * num2 ))\n                ;;\n            /)\n  \
    \              result=$(( num1 / num2 ))\n                ;;\n            *)\n\
    \                result=$(( num1 ** num2 ))\n                ;;\n        esac\n\
    \        \n        operand=$result\n    done\n    \n    # Return result\n    echo\
    \ \"$result\"", "  # Your code here\n  declare -i i\n  declare -A operator\n \
    \ operator=(\n    [+]=\"sum\"\n    [-]=\"diff\"\n    [*]=\"mult\"\n    [//]=\"\
    div\"\n    [**]=\"pow\"\n  )\n  while IFS= read -r line\n  do\n    if [[ $line\
    \ =~ ^-+$|^-+$|^-+$ ]]; then\n      echo \"Invalid operand $line\" >&2\n     \
    \ exit 1\n    elif [[ $line =~ ^[-*+]$|^[-*+]$|^[-*+]$ ]]; then\n      echo \"\
    Invalid operator $line\" >&2\n      exit 1\n    elif [[ $line =~ ^[+-/*]$|^[+-/*]$|^[+-/*]$\
    \ ]]; then\n      echo \"Invalid operator $line\" >&2\n      exit 1\n    elif\
    \ [[ ! ${line} =~ ^-?[0-9]+$ ]]; then\n      echo \"Invalid operand $line\" >&2\n\
    \      exit 1\n    else\n      operand=(${line//-/ })\n      i=1\n      while\
    \ [[ $i -le ${#operand[@]} ]]\n      do\n        eval ${operator[$(( ${#operator[@]}\
    \ - 1 ))]}\n        eval \"operand[$i]=${operand[$i]}\"\n        (( i++ ))\n \
    \     done\n      eval ${operator[$(( ${#operator[@]} - 1 ))]}\n      eval ${operand[$i]}\n\
    \    fi\n  done <<< \"$1 $2\"", "\tlocal OPERATOR OPERAND RESULT\n\tlocal OP='+'\n\
    \tlocal VALUE\n\tlocal COUNT\n\twhile read OPERATOR OPERAND; do\n\t\tif [ \"$OPERATOR\"\
    \ == \"(\" ] && [ \"$OPERAND\" == \"(\" ] || [ \"$OPERATOR\" == \")\" ] && [ \"\
    $OPERAND\" == \")\" ]; then\n\t\t\tbreak\n\t\tfi\n\t\tCOUNT=0\n\t\tVALUE=0\n\t\
    \twhile [ \"$COUNT\" -lt \"$#OPERAND\" ]; do\n\t\t\tVALUE=\"$VALUE$((${OPERAND[$COUNT]}\
    \ $OP ${OPERAND[$COUNT+1]}))\"\n\t\t\t((COUNT++))\n\t\t\tif [ \"$COUNT\" -eq \"\
    $#OPERAND\" ]; then\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tRESULT=\"$VALUE\"\n\
    \tdone\n\techo \"$RESULT\"", "  local op=\"${1:?Usage: do_algebra <op> <operand>\"\
    }\"\n  local oplist=\"( $op \\+ $op \\- \\* $op \\// \\** )\"\n  local operands=(\"\
    $2\" \\+ \"$3\" \\- \"$4\" \\* \"$5\" \\// \\**)\n  # eval means evaluate a mathematical\
    \ expression\n  eval \"result=$((${operands[0]} ${oplist[*]} ${operands[1]}))\"",
  "  # Split each operator and operand into separate lists.\n  operator_lst=($1)\n\
    \  array_operator=${#operator_lst[@]}\n  \n  operand_lst=($2)\n  array_operand=${#operand_lst[@]}\n\
    \  \n  # Make sure we have the right number of operators and operands.\n  if [[\
    \ ${#operator_lst[@]} != ${#operand_lst[@]} ]]; then\n    echo \"Error: Wrong\
    \ number of operands given for operator and operand lists.\"\n    echo \"Operands\
    \ given for operator list: $array_operand\"\n    echo \"Operands given for operand\
    \ list: $array_operator\"\n    exit 1\n  fi\n\n  # If the operator list is empty,\
    \ exit the program.\n  if [[ ${array_operator} = 0 ]]; then\n    echo \"Error:\
    \ No operators given.\"\n    exit 1\n  fi\n  \n  # If the operand list is empty,\
    \ exit the program.\n  if [[ ${array_operand} = 0 ]]; then\n    echo \"Error:\
    \ No operands given.\"\n    exit 1\n  fi\n\n  # If we have only 1 operator, exit.\n\
    \  if [[ ${array_operator} == 1 ]]; then\n    operator=${operator_lst[0]}\n  fi\n\
    \n  # If we have only 2 operands, exit.\n  if [[ ${array_operand} == 2 ]]; then\n\
    \    operand1=${operand_lst[0]}\n    operand2=${operand_lst[1]}\n  fi\n  \n  #\
    \ Check if operand 1 is a number, if not, exit.\n  if [[ ${operand1} =~ ^[0-9]+$\
    \ ]]; then\n    if [[ ${operand2} =~ ^[0-9]+$ ]]; then\n      result=$((operand1\
    \ + operand2))\n    else\n      echo \"Error: Operand 1 is not a number.\"\n \
    \     exit 1\n    fi\n  else\n    echo \"Error: Operand 1 is not a number.\"\n\
    \    exit 1\n  fi\n\n  # Check if operand 2 is a number, if not, exit.\n  if [[\
    \ ${operand2} =~ ^[0-9]+$ ]]; then\n    if [[ ${operand1} =~ ^[0-9]+$ ]]; then\n\
    \      result=$((operand1 - operand2))\n    else\n      echo \"Error: Operand\
    \ 2 is not a number.\"\n      exit 1\n    fi\n  else\n    echo \"Error: Operand\
    \ 2 is not a number.\"\n    exit 1\n  fi\n\n  # Return the result.\n  echo $result",
  "\toperator=$1\n\toperand=$2\n\tresult=0\n\t# for operator\n\tfor o in $operator\n\
    \tdo\n\t\tcase $o in\n\t\t+) result=$(( $result + $operand ));;\n\t\t-) result=$((\
    \ $result - $operand ));;\n\t\t*) result=$(( $result * $operand ));;\n\t\t/) result=$((\
    \ $result // $operand ));;\n\t\t**) result=$(( $result ** $operand ));;\n\t\t\
    esac\n\tdone\n\techo $result", "        local operator=$1\n        local operand=$2\n\
    \        local result=0\n        local operands=()\n\n        while [ \"$operand\"\
    \ != \"\" ]; do\n                case \"${operand}\" in\n                    \
    \    *[!0-9])\n                                operands+=($operand)\n        \
    \                        operand=\n                                ;;\n      \
    \                  *)\n                                operand=$operand\n    \
    \                            operands+=($operand)\n                          \
    \      operand=\n                                ;;\n                        esac\n\
    \        done\n\n        for (( index=0; index<${#operands[*]}; index++ )); do\n\
    \                case \"${operands[index]}\" in \n                        *[!0-9])\n\
    \                                result=$(( ${result} ${operator} ${operands[index]}))\n\
    \                                operands[index]=\n                          \
    \      ;;\n                        *)\n                                result=$((\
    \ ${result} ${operands[index]} ))\n                                operands[index]=\n\
    \                                ;;\n                        esac\n        done\n\
    \        echo \"$result\"", "    local operator operand\n    operator=$(echo \"\
    ${1}\" | sed 's/ *//g' | tr '\\n' ' ')\n    operand=$(echo \"${2}\" | sed 's/\
    \ *//g' | tr '\\n' ' ')\n    local result\n    result=$(echo \"$operand ${operator}\
    \ $operand\" | bc)\n    echo \"${result}\"", "    operator=\"$1\"\n    operand=\"\
    $2\"\n    result=1\n    while (( $# != 0 )); do\n        op=\"$1\"\n        ((\
    \ $# > 0 )) || break\n        operand=\"$2\"\n        (( $# > 1 )) || break\n\
    \        (( result = $result $op )) || break\n        shift 2\n    done\n    echo\
    \ $result", "  declare -a operand=($2)\n  declare -a operator=($1)\n  result=0\n\
    \  shift\n  for ((i = 0; i < ${#operand[@]}; i++)); do\n    case \"${operand[$i]}\"\
    \ in\n      '+'|'-')\n        result=\"${result}${operand[$i]}\"\n        ;;\n\
    \      '*'|'/')\n        result=\"${result}${operand[$i]}\"\n        ;;\n    \
    \  '**')\n        result=\"${result}${operand[$i]}\"\n        ;;\n      *)\n \
    \       result=\"${result}${operand[$i]}\"\n        ;;\n    esac\n  done\n  shift\n\
    \  shift\n  for ((i = 0; i < ${#operator[@]}; i++)); do\n    case \"${operator[$i]}\"\
    \ in\n      '+'|'-')\n        result=\"${result}${operand[$i]}\"\n        ;;\n\
    \      '*'|'/')\n        result=\"${result}${operand[$i]}\"\n        ;;\n    \
    \  '**')\n        result=\"${result}${operand[$i]}\"\n        ;;\n      *)\n \
    \       result=\"${result}${operand[$i]}\"\n        ;;\n    esac\n  done\n  echo\
    \ ${result}", "    operator=$1\n    operand=$2\n    eval $operator\n    eval $operand",
  "  operator=$1\n  operand=$2\n  result=0\n  operator_count=0\n  op_name=\"\"\n\n\
    \  while [ \"$operator_count\" -lt \"$#\" ];do\n    if [ \"$operator\" == \"${op_name}\"\
    \ ]; then\n      operator_count=$(( $operator_count + 1 ))\n      result=$(( result\
    \ + $operand ))\n      break\n    else\n      operator_count=$(( $operator_count\
    \ + 1 ))\n      operator=${operand[$operator_count]}\n      op_name=${operator}\n\
    \      operand=${operand[$(( $operator_count + 1 ))]}\n    fi\n  done\n\n  echo\
    \ $result", "\t# $1 is a space-separated list\n\t# $2 is a space-separated list\n\
    \tlocal operator=$1; shift\n\tlocal operand=$1; shift\n\tlocal result\n\tresult=$(expr\
    \ \"1\" \"2\" \"$operator\" \"'$operand'\" )\n\techo \"$result\"", "    local\
    \ operator operand\n    local result\n\n    operator=$1\n    operand=$2\n\n  \
    \  operator=${operator// / }\n    operand=${operand// / }\n\n    case \"$operator\"\
    \ in\n        # Addition\n        +)\n            eval \"result=$(( $(eval \"\
    $operand\" + $operand) ))\"\n            ;;\n\n        # Subtraction\n       \
    \ -)\n            eval \"result=$(( $(eval \"$operand\" - $operand) ))\"\n   \
    \         ;;\n\n        # Multiplication\n        *)\n            eval \"result=$((\
    \ $(eval \"$operand\" * $operand) ))\"\n            ;;\n\n        # Floor division\n\
    \        // )\n            # eval \"result=$(( $operand // $operand ))\"\n   \
    \         # ;;\n\n        # Exponentiation\n        **)\n            eval \"result=$((\
    \ $(eval \"$operand\" ** $operand) ))\"\n            ;;\n\n        *)\n      \
    \      echo \"Unknown operator: $operator\"\n            ;;\n    esac\n\n    echo\
    \ $result", "    local operator=\"$1\"\n    local operand=\"$2\"\n    local result\n\
    \    \n    if [[ $#operator -eq 0 ]] ; then\n        echo \"Please enter an operator\"\
    \n        return 127\n    fi\n    if [[ $#operand -eq 0 ]] ; then\n        echo\
    \ \"Please enter an operand\"\n        return 127\n    fi\n    \n    for element\
    \ in ${operand}; do\n        if [[ ${element} -eq \"${operand:(-1)}\" ]] ; then\n\
    \            echo \"Invalid operand\"\n            return 127\n        fi\n  \
    \  done\n    \n    for element in ${operator}; do\n        if [[ ${element} -eq\
    \ \"\" || ${element} -eq \"${operator:(-1)}\" ]] ; then\n            echo \"Invalid\
    \ operator\"\n            return 127\n        fi\n    done\n    \n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=$(expr \"${operand:(-1)}\" - 1)\n    element=$(expr\
    \ \"${operand:(-1)}\" - 1)\n    element=", "  local operator operand result\n\
    \  operator=${1:-\"+-/*^\"}\n  operand=${2:-\"2 3 4 5\"}\n\n  # Check inputs\n\
    \  [[ -z $operator ]] && echo \"Invalid operator list \\\"$operator\\\"!\" &&\
    \ exit 1\n  [[ -z $operand ]] && echo \"Invalid operand list \\\"$operand\\\"\
    !\" && exit 1\n\n  # Do the evaluation\n  result=$(eval \"${operator}\" <<< \"\
    $operand\")\n\n  # Print the result\n  echo \"$result\"", "  # Extract the operator\
    \ list from the first line of $1\n  local op=$(cat $1 | cut -d ' ' -f 1)\n  #\
    \ Extract the operand list from the first line of $2\n  local res=$(cat $2 | cut\
    \ -d ' ' -f 1)\n  # Construct the algebraic expression\n  local op1=$(eval echo\
    \ \"$op[1]\")\n  local op2=$(eval echo \"$op[2]\")\n  local op3=$(eval echo \"\
    $op[3]\")\n  local op4=$(eval echo \"$op[4]\")\n  local res1=$(eval echo \"$res[1]\"\
    )\n  local res2=$(eval echo \"$res[2]\")\n  local res3=$(eval echo \"$res[3]\"\
    )\n  local res4=$(eval echo \"$res[4]\")\n  local res5=$(eval echo \"$res[5]\"\
    )\n  local res6=$(eval echo \"$res[6]\")\n  local res7=$(eval echo \"$res[7]\"\
    )\n  local res8=$(eval echo \"$res[8]\")\n  local res9=$(eval echo \"$res[9]\"\
    )\n  local res10=$(eval echo \"$res[10]\")\n  local res11=$(eval echo \"$res[11]\"\
    )\n  local res12=$(eval echo \"$res[12]\")\n  local res13=$(eval echo \"$res[13]\"\
    )\n  local res14=$(eval echo \"$res[14]\")\n  local res15=$(eval echo \"$res[15]\"\
    )\n  local res16=$(eval echo \"$res[16]\")\n  local res17=$(eval echo \"$res[17]\"\
    )\n  local res18=$(eval echo \"$res[18]\")\n  local res19=$(eval echo \"$res[19]\"\
    )\n  local res20=$(eval echo \"$res[20]\")\n  local res21=$(eval echo \"$res[21]\"\
    )\n  local res22=$(eval echo \"$res[22]\")\n  local res23=$(eval echo \"$res[23]\"\
    )\n  local res24=$(eval echo \"$res[24]\")\n  local res25=$(eval echo \"$res[25]\"\
    )\n  local res26=$(eval echo \"$res[26]\")\n  local res27=$(eval echo \"$res[27]\"\
    )\n  local res28=$(eval echo \"$res[28]\")\n  local res29=$(eval echo \"$res[29]\"\
    )\n  local res30=$(eval echo \"$res[30]\")\n  local res31=$(eval echo \"$res[31]\"\
    )\n  local res32=$(eval echo \"$res[", "  while read -r operator; do\n    while\
    \ read -r operand; do\n      algebra=\"$(( $operand $operator $operand ))\"\n\
    \      eval $algebra\n    done < <(echo $operator)\n  done < <(echo $2)", "  \
    \  # Make sure there is at least one operator and at least two operands\n    if\
    \ [ $# -lt 2 ]; then \n        echo \"Usage: do_algebra <operator> <operand>\"\
    \ >&2\n        return 1\n    fi\n    # Initialize the variable\n    result=0\n\
    \    # Process the operands\n    for (( i=1; i<$#; i++ )); do\n        operand=${!i}\n\
    \        # Process the operators\n        for (( j=1; j<$#; j++ )); do\n     \
    \       operator=${!j}\n            # Perform the operation\n            case\
    \ \"$operator\" in\n                '+') result=$(($result + $operand)) ;;\n \
    \               '-') result=$(($result - $operand)) ;;\n                '*') result=$(($result\
    \ * $operand)) ;;\n                '//') result=$(($result // $operand)) ;;\n\
    \                '^') result=$(($result ** $operand)) ;;\n                *) echo\
    \ \"ERROR: Unsupported operator $operator\" ; return 1 ;;\n            esac\n\
    \        done\n    done\n    # Return the result\n    echo \"$result\"", "   \
    \ local operator=$1\n    local operand=$2\n    local result=0\n    local i=0\n\
    \    while (( $i < ${#operator[@]} )) ; do\n        (( ${#operand[@]} > i )) ||\
    \ return 1\n        case \"${operator[$i]}\" in\n            ${OPERATOR_PREFIX}+)\n\
    \                (( ${#operand[$i]} > i )) || return 1\n                let result=$result+${operand[$i]}\n\
    \                let i=$i+1\n                ;;\n            ${OPERATOR_PREFIX}-)\n\
    \                (( ${#operand[$i]} > i )) || return 1\n                let result=$result-${operand[$i]}\n\
    \                let i=$i+1\n                ;;\n            ${OPERATOR_PREFIX}*)\n\
    \                (( ${#operand[$i]} > i )) || return 1\n                let result=$result*${operand[$i]}\n\
    \                let i=$i+1\n                ;;\n            ${OPERATOR_PREFIX}//)\n\
    \                (( ${#operand[$i]} > i )) || return 1\n                let result=$result/$((${operand[$i]}+1))\n\
    \                let i=$i+1\n                ;;\n            ${OPERATOR_PREFIX}**)\n\
    \                (( ${#operand[$i]} > i )) || return 1\n                let result=$result**${operand[$i]}\n\
    \                let i=$i+1\n                ;;\n            *)\n            \
    \    return 1\n                ;;\n        esac\n    done\n    echo $result",
  "    operator=$1\n    operand=$2\n    result=$(do_operation_by_operator_and_operand\
    \ \"$operator\" \"$operand\")\n    echo $result", "    local operator=\"$1\"\n\
    \    local operand=\"$2\"\n    local result=0\n    local count=0\n    local digit=0\n\
    \    local op1\n    local op2\n    while [ $count -le ${#operand} ]; do\n    \
    \    # extract operands one by one into op1 and op2\n        op1=${operand:$count:1}\n\
    \        op2=${operand:$(($count + 1)):1}\n        # convert op1 and op2 into\
    \ mathematical operations\n        case $op1 in '+-*%/') digit=$(($((op1+1)*10\
    \ + op2)/10)) ;;\n        *) digit=$((op1 * op2 / 10)) ;;\n        esac\n    \
    \    # perform the operation and save the result\n        result=$((result + digit))\n\
    \        count=$(($count + 1))\n    done\n    echo \"$result\"", "  local op=\"\
    $1\"\n  local nums=\"$2\"\n  local res\n  if [[ ${#nums} -ne ${#op} ]]; then\n\
    \    echo \"ERROR: invalid operator/operand pair\"\n    return 1\n  fi\n  # The\
    \ length of op is at least 1\n  local i\n  for (( i=0; i<${#op}; i++ )); do\n\
    \    case \"${op}\" in\n      +)\n        (( res+=${nums[i]} ))\n        ;;\n\
    \      -)\n        (( res-=${nums[i]} ))\n        ;;\n      *)\n        (( res*=${nums[i]}\
    \ ))\n        ;;\n      /)\n        (( res=`echo ${nums[i]} | bc -l` ))\n    \
    \    ;;\n      *)\n        (( res=`echo ${nums[i]} | bc -l` ))\n        ;;\n \
    \   esac\n  done\n  echo \"${res}\"\n  return 0", "    local operator operand\
    \ result\n    operator=$(echo $1 | cut -d \" \" -f 1)\n    operand=$(echo $1 |\
    \ cut -d \" \" -f 2)\n    operand=$(echo $operand | sed 's/^-\\([0-9]*\\)\\(.*\\\
    )/\\1/g')\n    operand=$(echo $operand | sed 's/^\\+\\([0-9]*\\)\\(.*\\)/\\1/g')\n\
    \    operand=$(echo $operand | sed 's/^--\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\+\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo $operand\
    \ | sed 's/^\\-\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo $operand | sed\
    \ 's/^\\*\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo $operand | sed 's/^\\\
    /\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo $operand | sed 's/^\\+\\([0-9]*\\\
    )\\(.*\\)/\\1/g')\n    operand=$(echo $operand | sed 's/^\\-\\([0-9]*\\)\\(.*\\\
    )/\\1/g')\n    operand=$(echo $operand | sed 's/^\\*|\\-\\*|///g')\n    operand=$(echo\
    \ $operand | sed 's/\\*$//g')\n    operand=$(echo $operand | sed 's/$//g')\n \
    \   operand=$(echo $operand | sed 's/^\\(.*\\)[0-9]*/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]*\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]*\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $operand | sed 's/^\\(.*\\)[0-9]*\\([0-9]*\\)\\(.*\\)/\\1/g')\n    operand=$(echo\
    \ $", "\tlocal op=$1\n\tlocal arr=$2\n\tlocal len=${#arr[@]}\n\tlocal i\n\tlocal\
    \ result\n\t# if operator length is zero\n\tif [[ ${#op[@]} -eq 0 ]]; then\n\t\
    \techo \"Usage: do_algebra <operator> <operand>\"\n\t\techo \"Usage: Usage: do_algebra\
    \ <operator> <operand>\"\n\t\texit 1;\n\tfi\n\t# if operand length is zero\n\t\
    if [[ ${#arr[@]} -eq 0 ]]; then\n\t\techo \"Usage: do_algebra <operator> <operand>\"\
    \n\t\techo \"Usage: do_algebra <operator> <operand>\"\n\t\texit 1;\n\tfi\n\t#\
    \ if operator is not in operand list\n\tif [[ ! ${arr[@]} | grep -E \"^($op|[^0-9])+\"\
    \ ]]; then\n\t\techo \"Invalid operator: $op\"\n\t\techo \"Usage: do_algebra <operator>\
    \ <operand>\"\n\t\texit 1;\n\tfi\n\tresult=0\n\t# for each element of the operand\
    \ list\n\tfor (( i=0;i<$len-1;i++)); do\n\t\t# if operator is a multiplication\
    \ operator\n\t\tif [[ ${arr[i]} == ${op} ]]; then\n\t\t\t# if operand is a single\
    \ integer\n\t\t\tif [[ ${arr[i+1]} =~ ^[0-9]+$ ]]; then\n\t\t\t\tresult=$(( result\
    \ * ${arr[i+1]} ))\n\t\t\telse\n\t\t\t\techo \"Invalid operand: $arr[i]\"\n\t\t\
    \t\techo \"Usage: do_algebra <operator> <operand>\"\n\t\t\t\texit 1;\n\t\t\tfi\n\
    \t\telse\n\t\t\t# if operator is a constant operator\n\t\t\tif [[ ${arr[i]} ==\
    \ ${op}_ ]]; then\n\t\t\t\t# if operand is single integer\n\t\t\t\tif [[ ${arr[i+1]}\
    \ =~ ^[0-9]+$ ]]; then\n\t\t\t\t\tresult=$(( result + ${arr[i+1]} ))\n\t\t\t\t\
    else\n\t\t\t\t\techo \"Invalid operand: $arr[i]\"\n\t\t\t\t\techo \"Usage: do_algebra\
    \ <operator> <operand>\"\n\t\t\t\t\texit 1;\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\t\
    done\n\techo $result", "    operator=$1\n    operand=$2\n    operators=$( echo\
    \ $1 | tr '[:upper:]' '[:lower:]' )\n    operands=$( echo $2 | tr '[:upper:]'\
    \ '[:lower:]' )\n    while [ ! -z \"$operator\" ] && [ ! -z \"$operand\" ]\n \
    \   do\n        case \"$operator\" in\n            \"+\" )\n                eval\
    \ \"$operands=$operands+$operands\"\n                ;;\n            \"-\" )\n\
    \                eval \"$operands=$operands-$operands\"\n                ;;\n\
    \            \"*\" )\n                eval \"$operands=$operands*$operands\"\n\
    \                ;;\n            \"/\" )\n                eval \"$operands=$operands//$operands\"\
    \n                ;;\n            \"**\" )\n                eval \"$operands=$operands**$operands\"\
    \n                ;;\n            *)\n                echo \"No such operator\"\
    \n                ;;\n        esac\n        operator=$( echo $( echo $operator\
    \ | cut -c2- ) )\n        operand=$( echo $( echo $operand | cut -c2- ) )\n  \
    \  done\n    eval \"$operands=$operands\"", "\toperator ${1//[+ - *]} ${2//[+\
    \ - *]} ", "    local -a operator operand\n    operator=$(cut -d\" \" -f1 <<<\
    \ \"$1\")\n    operand=$(cut -d\" \" -f2- <<< \"$1\")\n    local sum=0\n    local\
    \ count=0\n    for element in \"${operand[@]}\"; do\n        sum=$((sum+element))\n\
    \        count=$((count+1))\n    done\n    if [ \"$count\" -eq 1 ]; then\n   \
    \     echo \"$sum\"\n    else\n        echo $((sum))\n    fi", "    local operator\
    \ operand\n    # split into operator and operand\n    IFS=\" \" read operator\
    \ operand<<<\"$1\"\n    # first operand is constant and second is number\n   \
    \ local result\n    if [[ -z \"$operand\" ]]; then\n        result=$operand\n\
    \    elif [[ \"$operand\" == * ]]; then\n        # first operand is number\n \
    \       local value=$operand\n        # second operand is number\n        operand=$2\n\
    \        # calculate result\n        result=$(eval \"echo \\$$operand \\$$operator\
    \ *\\$$value\")\n    else\n        # first operand is number\n        local value=$operand\n\
    \        # second operand is constant\n        operand=$2\n        # calculate\
    \ result\n        result=$(eval \"echo \\$$operand \\$$operator *\\$$value\")\n\
    \    fi\n    echo \"$result\"", "  local operator operand result\n  operator=${1:-'+'}\n\
    \  operand=${2:-$(seq 0 10)}\n  for ((i=0; i<${#operator[@]}; i++)); do\n    ((result+=${operand[i]}))\n\
    \  done\n  echo ${result}", "    OPERATORS=\"+ * / - ^ // ** \"\n    OPERATORS=`echo\
    \ $OPERATORS|sed \"s/ *//g\"`\n    IFS=' ' read -r -a op <<< \"$1\"\n    IFS='\
    \ ' read -r -a op <<< \"$2\"\n    \n    OCOUNT=0\n    OFIRST=\n    OFIRST=\n \
    \   OSECOND=\n    OFIRSECOND=\n    OSECONDCOUNT=\n    OFIRSTCOUNT=\n    OFIRSTCOUNT=\n\
    \    \n    O=0\n    IFS=','\n    for OP in ${OPERATORS}\n    do\n        OFIRST=\"\
    ${op[$OCOUNT]}\"\n        OFIRST=\"${op[$OCOUNT+1]}\"\n        OSECOND=\"${op[$OCOUNT+2]}\"\
    \n        OFIRSECOND=\"${op[$OCOUNT+3]}\"\n        OSECONDCOUNT=`expr ${#OSECOND}\
    \ - 1`\n        OFIRSTCOUNT=`expr ${#OFIRST} - 1`\n        OFIRSTCOUNT=`expr ${#OFIRST}\
    \ - 1`\n        \n        OCOUNT=$((OCOUNT+4))\n        if [[ ${#OFIRST} -gt 0\
    \ ]]; then\n            OFIRSTCOUNT=$((OFIRSTCOUNT+4))\n        fi\n        if\
    \ [[ ${#OFIRST} -gt 0 ]]; then\n            OFIRSTCOUNT=$((OFIRSTCOUNT+4))\n \
    \       fi\n        if [[ ${#OSECOND} -gt 0 ]]; then\n            OSECONDCOUNT=$((OSECONDCOUNT+4))\n\
    \        fi\n        if [[ ${#OFIRSECOND} -gt 0 ]]; then\n            OFIRSECONDCOUNT=$((OFIRSECONDCOUNT+4))\n\
    \        fi\n    done\n    \n    OCOUNT=0\n    OFIRST=\n    OFIRST=\n    OSECOND=\n\
    \    OFIRSECOND=\n    OSECONDCOUNT=\n    OFIRSTCOUNT=\n    OFIRSTCOUNT=\n    \n\
    \    IFS=','\n    for OP in ${OPERATORS}\n    do\n        OFIRST=\"${op[$OCOUNT]}\"\
    \n        OFIRST=\"${op[$OCOUNT+1]}\"\n        OSECOND=\"${op[$OCOUNT+2]}\"\n\
    \        OFIRSECOND=\"${op[$OCOUNT+3]}\"\n        OSECONDCOUNT=`expr ${#OSECOND}\
    \ - 1`\n        OFIRSTCOUNT=`expr ${#OFIRST} - 1`\n        OFIR", "    operator=$1\n\
    \    operand=$2\n    i=0\n    len=${#operator}\n    result=0\n    for (( i=0;i<${#operand};i++))\n\
    \    do\n        (( result+=${operand[i]} ))\n    done\n    for (( i=0;i<${#operator};i++))\n\
    \    do\n        (( result-=${operator[i]} ))\n    done", "    local OP=$1\n \
    \   local ARG=$2\n    local OPS=\"\"\n    local ARGS=\"\"\n    local OPSCOUNT=$#\n\
    \    local ARGSCOUNT=$#\n    local OPINDEX=0\n    local ARGINDEX=0\n    while\
    \ (( $OPINDEX < $OPSCOUNT )); do\n        if [ $(( $OPINDEX + 1 )) -ne $OPINDEX\
    \ ]; then\n            OPS+=\" \"\n        fi\n        OPS+=$OP\n        OPINDEX=$((\
    \ $OPINDEX + 1 ))\n    done\n    while (( $ARGINDEX < $ARGSCOUNT )); do\n    \
    \    if [ $(( $ARGINDEX + 1 )) -ne $ARGINDEX ]; then\n            ARGS+=\" \"\n\
    \        fi\n        ARGS+=$ARG\n        ARGINDEX=$(( $ARGINDEX + 1 ))\n    done\n\
    \    echo \"$OPS$ARGS\"", "  local -n operator=$1\n  local -n operand=$2\n  local\
    \ result\n  for ((i=0; i<${#operator[@]}; i++)); do\n    case ${operator[i]} in\n\
    \    +)\n      result=$(expr ${operand[0]} + ${operand[1]})\n      ;;\n    -)\n\
    \      result=$(expr ${operand[0]} - ${operand[1]})\n      ;;\n    *)\n      result=$(expr\
    \ ${operand[0]} * ${operand[1]})\n      ;;\n    *)\n      result=$(expr ${operand[0]}\
    \ / ${operand[1]})\n      ;;\n    esac\n    echo ${result}\n  done", "    operator=$1\n\
    \    operand=$2\n\n    operators=$(echo $operator | tr ' ' '\\n' | sort -u)\n\
    \    operands=$(echo $operand | tr ' ' '\\n' | sort -u)\n\n    eval_result=$($operator\
    \ $operands[0])\n    for i in $(seq 1 $((${#operands[@]} - 1)))\n    do\n    \
    \    eval_result=$(eval \"echo $eval_result $operator $operands[i]\")\n    done\n\
    \    eval $eval_result", "  echo \"$1\"\n  echo \"$2\"\n  local operator\n  local\
    \ operand\n  operator=$(cat <<-EOF\n  + \n  - \n  * \n  / \n  ^ \n  !\n  EOF\n\
    \  )\n  operand=$(cat <<-EOF\n  2 \n  3 \n  4 \n  5\n  EOF\n  )\n  echo \"$operator\"\
    \ | while read -r line; do\n    operand=$(cat <<-EOF\n    $line\n    EOF\n   \
    \ )\n    echo \"$operand\"\n    eval \"echo \\\"$operand $line $operand\\\"\"\n\
    \  done", "  local operator=\"$1\"\n  local operand=\"$2\"\n  local result\n \
    \ \n  if [ \"$#\" -lt 3 ]; then\n    echo >&2 \"Usage: $0 operator operand\"\n\
    \    return 1\n  fi\n  \n  case \"$operator\" in\n  add*)\n    local op_add=\"\
    +\"\n  ;;\n  sub*)\n    local op_add=\"-\"\n  ;;\n  mul*)\n    local op_add=\"\
    *\"\n  ;;\n  floordiv)\n    local op_add=\"//\"\n  ;;\n  exp*)\n    local op_add=\"\
    **\"\n  ;;\n  esac\n  \n  if [ \"$#\" -eq 3 ]; then\n    local op_add=\"$3\"\n\
    \  fi\n  \n  local result_temp\n  local operands\n  local op\n  local i\n  local\
    \ count\n  \n  operands=()\n  \n  operand=( ${operand//,/ } )\n  \n  for i in\
    \ \"${!operand[@]}\"\n  do\n    operands+=( \"${operand[$i]}\" )\n  done\n  \n\
    \  if [ \"${#operands[@]}\" -eq 2 ]; then\n    count=\"${operands[@]:1:$(( ${#operands[@]}\
    \ - 1 ))}\"\n    result=\"${operands[@]:0:1}${op_add}${operands[@]:1}\"\n  else\n\
    \    count=\"${operands[@]:0:$(( ${#operands[@]} - 2 ))}\"\n    result=\"${operands[@]:0:1}${op_add}${operands[@]:1}\"\
    \n  fi\n  \n  for i in $(seq 0 $(( ${#operands[@]} - 1 )))\n  do\n    case \"\
    ${operands[$i]}\" in\n    0)\n      result=\"$result\"\n      ;;\n    *)\n   \
    \   result=\"${result}${operands[$i]}\"\n      ;;\n    esac\n  done\n  \n  if\
    \ [ \"${#operands[@]}\" -gt 2 ]; then\n    local operands_final\n    operands_final=()\n\
    \    \n    operands_final=( ${result//-/ } )\n    \n    for i in $(seq 0 $(( ${#operands[@]}\
    \ - 2 )))\n    do\n      operands_final+=( \"${operands_final[$i]}\" )\n    done\n\
    \    \n    result=\"${operands_final[@]:0:1}${op_add}${operands_final[@]:1}\"\n",
  "\tlocal operator=$1\n\tlocal operand=$2\n\tlocal result=0\n\tlocal count=1\n\t\
    local first=1\n\tlocal last=$(($#operand-1))\n\tlocal operatorCount=1\n\tlocal\
    \ operandCount=1\n\tlocal operatorIndex=1\n\tlocal operandIndex=2\n\twhile [[\
    \ $operandIndex -le $last ]]; do\n\t\tcount=$(($count+1))\n\t\twhile [[ $count\
    \ -le $operatorIndex ]]; do\n\t\t\toperatorIndex=$(($operatorIndex+1))\n\t\t\t\
    result=$(($result+$((${operand[operandIndex]} ${operator[operatorIndex]} ${operand[operandIndex]}\
    \ ))))\n\t\t\tcount=$(($count+1))\n\t\tdone\n\t\tcount=$(($count+1))\n\t\twhile\
    \ [[ $count -le $operandIndex ]]; do\n\t\t\toperandIndex=$(($operandIndex+1))\n\
    \t\t\tresult=$(($result+$((${operand[operandIndex]} ${operand[operandIndex]} ${operator[operatorIndex]}\
    \ ))))\n\t\t\tcount=$(($count+1))\n\t\tdone\n\t\tcount=$(($count+1))\n\tdone\n\
    \techo $result", "\toperator=$1\n\toperand=$2\n\tlength=$(( ${#operator} - 1))\n\
    \tarray=${operand:$(( ${#operand} - 1 ))}\n\n\t(( ${#array} < ${#operand} )) &&\
    \ {\n\t\techo \"ERROR: operands list length is less than operator list length.\"\
    \n\t\texit 1\n\t}\n\n\tfor i in \"${!array[@]}\"; do\n\t\tcase \"${array[$i]}\"\
    \ in\n\t\t\t1 ) \n\t\t\t\techo \"ERROR: operand list length is shorter than the\
    \ operator list length.\"\n\t\t\t\texit 1\n\t\t\t;;\n\t\tesac\n\tdone\n\n\tfor\
    \ i in \"${!operator[@]}\"; do\n\t\tcase \"${operator[$i]}\" in\n\t\t\t1 ) \n\t\
    \t\t\techo \"ERROR: operator list length is shorter than the operand list length.\"\
    \n\t\t\t\texit 1\n\t\t\t;;\n\t\tesac\n\tdone\n\t\n\tif [[ \"$operand\" =~ \"[+-]?([0-9]+|[0-9]*\\\
    .[0-9]+)\" ]]; then\n\t\toperand=${BASH_REMATCH[1]}\n\tfi\n\t\n\tcase \"$operator\"\
    \ in\n\t\t+) \n\t\t\tresult=$(echo \"$operand\" | bc | xargs expr $(($length +\
    \ 1)) | bc) \n\t\t\techo -n \"$result\"\n\t\t\t;;\n\t\t-) \n\t\t\tresult=$(echo\
    \ \"$operand\" | bc | xargs expr $(($length + 1)) | bc)\n\t\t\techo -n $((-$result))\n\
    \t\t\t;;\n\t\t*) \n\t\t\tresult=$(echo \"$operand\" | bc | xargs expr $(($length\
    \ + 1))) \n\t\t\techo -n $result\n\t\t\t;;\n\tesac", "\t# $1 is a list of operators,\
    \ for example '+ - x // y ** 2 +'\n\t# $2 is a list of operands, for example '2\
    \ 3 4 5'\n\t# $3 is the name of the variable in which to store the result of the\
    \ expression\n\t\n\t# We first split $2 into operands and operators\n\t# $2 must\
    \ have at least two items\n\toperands=$2\n\toperators=$1\n\tlen=${#operands[@]}\n\
    \tlen1=${#operators[@]}\n\t\n\t# We require that $operators and $operands have\
    \ at least two items\n\t# $operators must have at least one item\n\t# $operands\
    \ must have at least one item\n\t# $len and $len1 are both at least 2\n\t\n\t\
    if [[ $len == 0 ]]; then\n\t\techo \"Error: Operands must be a list of non-negative\
    \ integers\"\n\t\techo \"The operand list must have at least two items\"\n\t\t\
    echo \"The operator list must have at least one item\"\n\t\treturn 1\n\tfi\n\t\
    if [[ $len == 0 ]]; then\n\t\techo \"Error: Operands must be a list of non-negative\
    \ integers\"\n\t\techo \"The operator list must have at least one item\"\n\t\t\
    echo \"The operand list must have at least one item\"\n\t\treturn 1\n\tfi\n\t\
    if [[ $len == 0 ]]; then\n\t\techo \"Error: Operands must be a list of non-negative\
    \ integers\"\n\t\techo \"The operator list must have at least one item\"\n\t\t\
    echo \"The operand list must have at least one item\"\n\t\treturn 1\n\tfi\n\t\
    if [[ $len1 != 0 ]]; then\n\t\techo \"Error: Operands must be a list of non-negative\
    \ integers\"\n\t\techo \"The operator list must have at least one item\"\n\t\t\
    echo \"The operand list must have at least one item\"\n\t\treturn 1\n\tfi\n\t\
    if [[ $len == 0 ]]; then\n\t\techo \"Error: Operands must be a list of non-negative\
    \ integers\"\n\t\techo \"The operand list must have at least one item\"\n\t\t\
    echo \"The operator list must have at least one item\"\n\t\treturn 1\n\tfi\n\t\
    \n\t# We loop over $operands and $operators\n\tfor (( i=0; i < len; i++ ));\n\t\
    do\n\t\t# We first test if there is a mathematical operation to perform\n\t\t\
    if [[ $(( ${operands[$i]} )) ]]; then\n\t\t\t# We test if $operators is at least\
    \ 2 items\n\t\t\tif [[ $(( ${#operators[@]} )) ]]; then\n\t\t\t\t# We test if\
    \ $operands is at least 2 items\n\t\t\t\tif [[ $(( ${#operands[@]} )) ]]; then\n\
    \t\t\t\t\t# We test if $operators and $operands have at least two items\n\t\t\t\
    \t\tif [[ $(( ${#operators[@]} )) -le $(( ${#operands[", "    operator=$1\n  \
    \  operand=$2\n    sum=0\n    for i in $(seq 0 $((${#operator[@]}-1))); do\n \
    \       operator[$i]=\"${operator[$i]} \"\n        operand[$i]=\"${operand[$i]}\
    \ \"\n    done\n    # $1 is a space-separated list\n    # $2 is an integer\n \
    \   sum=$(( ${operand[$((${#operand[@]} - 1))]} * ${operator[$((${#operand[@]}\
    \ - 1))]} ))\n    echo ${sum}", "\t# $1: operator\n\t# $2: operand\n\tlet length=\"\
    ${#operator[@]}\"\n\t# If operand is empty, skip to the next step\n\tif [[ -z\
    \ \"$2\" ]]; then\n\t\treturn\n\tfi\n\tlet length2=\"${#operand[@]}\"\n\t# If\
    \ there's only one operator in the operand list, skip to the next step\n\tif [[\
    \ \"${#operand[@]}\" == \"1\" ]]; then\n\t\treturn\n\tfi\n\t# Initialize result\n\
    \tresult=\"null\"\n\t# Perform the calculations\n\tfor (( i=0; i<\"${length}\"\
    ; i++ )); do\n\t\t# If there's only one operator in the operand list, skip to\
    \ the next step\n\t\tif [[ \"${#operand[@]}\" == \"1\" ]]; then\n\t\t\treturn\n\
    \t\tfi\n\t\tlet count=\"${#operand[@]}\"\n\t\tlet index=$(($i%$count))\n\t\tlet\
    \ op=${operator[$(($index))]}\n\t\tlet operand1=\"${operand[$(($(($index*$count)+$i)))]}\"\
    \n\t\t# If there's only 1 operator in the operand list, skip to the next step\n\
    \t\tif [[ \"${#operand[@]}\" == \"1\" ]]; then\n\t\t\treturn\n\t\tfi\n\t\tlet\
    \ operand2=\"${operand[$(($(($index*$count)+$(($index+1*$count))))-1)]}\"\n\t\t\
    let result=\"${result} ${op}${operand1}${operand2}\"\n\tdone\n\techo \"${result}\"",
  "    operator=${1%,*}\n    operand1=${1#*,}\n    operand2=${2#*,}\n    operator=${operator//,/\
    \ }\n    operand1=${operand1//,/ }\n    operand2=${operand2//,/ }\n    echo $operand1\
    \ $operator $operand2\n    eval $(( $operand1 + $operand2 ))", "  local op=$1\
    \ \n  local operand=$2\n  local result\n  result=0\n  for ((i=0; i < ${#operand};\
    \ i++)); do \n    case \"${operand[i]}\" in\n      0) echo ${operand[i]} ;;\n\
    \      *) echo ${op}${operand[i]} ;;\n    esac\n    result=$(( ${result} + ${operand[i]}\
    \ ))\n  done\n  echo ${result}", "    operator=$1\n    array=$2\n    # check operator\
    \ list\n    if [[ $#operator == 0 ]]; then\n        echo \"$operator\" is not\
    \ given as an operator\"\n        exit 1\n    fi\n    # check operand list\n \
    \   if [[ $#array < 2 ]]; then\n        echo \"$array\" is not given as an operand\"\
    \n        exit 1\n    fi\n    # check length of operator list\n    if [[ $#operator\
    \ != $#array ]]; then\n        echo \"$operator\" is not given as an operator\
    \ with $#operator operands\"\n        exit 1\n    fi\n    # check length of operand\
    \ list\n    if [[ $#array < $#operator ]]; then\n        echo \"$array\" is not\
    \ given as an operand with $#operator operands\"\n        exit 1\n    fi\n   \
    \ if [[ -n \"${array[0]}\" ]]; then\n        operator[0]=\"${array[0]}\"\n   \
    \ fi\n    if [[ -n \"${array[1]}\" ]]; then\n        array[1]=\"${array[1]}\"\n\
    \    fi\n    len=${#array[@]}\n    total=0\n    for ((i=2; i<$len; i++))\n   \
    \ do\n        if [[ -n \"${array[$i]}\" ]]; then\n            total=$((total+${array[$i]}))\n\
    \        fi\n    done\n    if [[ -n \"${operator[1]}\" ]]; then\n        operator[1]=\"\
    ${operator[1]}\"\n    fi\n    if [[ -n \"${array[$len-1]}\" ]]; then\n       \
    \ operand[$len-1]=\"${array[$len-1]}\"\n    fi\n    len=$((len-1))\n    if [[\
    \ -n \"${array[$len]}\" ]]; then\n        operand[$len]=\"${array[$len]}\"\n \
    \   fi\n    operator[$len]=\"${operator[$len]}\"\n    if [[ \"$operator\" == \"\
    +\" ]]; then\n        echo \"$((total+operand[1]))\"\n    elif [[ \"$operator\"\
    \ == \"-\" ]]; then\n        echo \"$((total-operand[1]))\"\n    elif [[ \"$operator\"\
    \ == \"*\" ]]; then\n        echo \"$((total*operand[1]))\"\n    elif [[ \"$operator\"\
    \ == \"//\" ]]; then\n        echo \"$((total//operand[1]))\"\n    elif [[ \"\
    $operator\" == \"**\" ]]; then\n        echo \"$((total**operand[1]))\"\n    else\n\
    \        echo \"$((total+operand[1]-operand[0]))\"\n    fi", "    declare -A operator=(\n\
    \        # Addition ( + )\n        [+]=\"add\"\n        # Subtraction ( - )\n\
    \        [-]=\"sub\"\n        # Multiplication ( * )\n        [*]=\"mul\"\n  \
    \      # Floor division ( // )\n        [/]=\"floordiv\"\n        # Exponentiation\
    \ ( ** )\n        [**]=\"exp\"\n    )\n    declare -A operand=(\n        # 2\n\
    \        [2]=\"2\"\n        # 3\n        [3]=\"3\"\n        # 4\n        [4]=\"\
    4\"\n        # 5\n        [5]=\"5\"\n        # 6\n        [6]=\"6\"\n        #\
    \ 7\n        [7]=\"7\"\n        # 8\n        [8]=\"8\"\n        # 9\n        [9]=\"\
    9\"\n        # 10\n        [10]=\"10\"\n        # 11\n        [11]=\"11\"\n  \
    \      # 12\n        [12]=\"12\"\n        # 13\n        [13]=\"13\"\n        #\
    \ 14\n        [14]=\"14\"\n        # 15\n        [15]=\"15\"\n        # 16\n \
    \       [16]=\"16\"\n        # 17\n        [17]=\"17\"\n        # 18\n       \
    \ [18]=\"18\"\n        # 19\n        [19]=\"19\"\n        # 20\n        [20]=\"\
    20\"\n        # 21\n        [21]=\"21\"\n        # 22\n        [22]=\"22\"\n \
    \       # 23\n        [23]=\"23\"\n        # 24\n        [24]=\"24\"\n       \
    \ # 25\n        [25]=\"25\"\n        # 26\n        [26]=\"26\"\n        # 27\n\
    \        [27]=\"27\"\n        # 28\n        [28]=\"28\"\n        # 29\n      \
    \  [29]=\"29\"\n        # 30\n        [30]=\"30\"\n        # 31\n        [31]=\"\
    31\"\n        # 32\n        [32]=\"32\"\n        # 33\n        [33]=\"33\"\n \
    \       # 34\n        [34]=\"34\"\n        # 35\n        [35]=\"35\"\n       \
    \ # 36\n        [36]=\"36\"\n        # 37\n        [37]=\"37\"\n        # 38\n\
    \        [38]=\"38\"\n        # 39\n        [39]=\"39\"\n        # 40\n      \
    \  [40]=\"40\"\n        # 41\n        [41]=\"41\"\n        # 42\n        [42]=\"\
    42\"\n        # 43\n        [43]=\"43\"\n        # 44\n        [44]=\"44\"\n \
    \       # 45\n        [45]=\"45\"", "    # Parse arguments\n    local OP=$1\n\
    \    local OPLIST=$2\n    local OPNAME\n    local OPVAL\n    local I\n    local\
    \ J\n    local VALUE\n\n    # Make sure both lists are non-empty\n    if [ -z\
    \ \"$OPLIST\" ] || [ -z \"$OP\" ]; then\n        echo \"Usage: do_algebra <operator>\
    \ <operand>\"\n        return\n    fi\n    \n    # Make sure operator is found\n\
    \    OPNAME=\"${OPLIST%% *}\"\n    if ! echo \"$OPLIST\" | egrep -q \"$OPNAME\"\
    ; then\n        echo \"Invalid operator: $OPNAME\"\n        return\n    fi\n\n\
    \    # Make sure operand is found\n    OPVAL=\"${OPLIST#* }\"\n    if [ -z \"\
    $OPVAL\" ]; then\n        echo \"Invalid operand: $OPVAL\"\n        return\n \
    \   fi\n\n    # Find a suitable place for these operands\n    # $OPNAME \n   \
    \ # $OPNAME \n    # ...\n    # $OPNAME \n    # ...\n    # $OPNAME\n    local PLACEMENT\n\
    \    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\
    \n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\
    \n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\
    \n    PLACEMENT=\"$OPNAME\"\n    PLACEMENT=\"$OPNAME\"\n\n    # Replace operands\n\
    \    local COUNT\n    COUNT=1\n    while [ \"${PLACEMENT#$OPVAL}\" != \"$OPNAME\"\
    \ ]; then\n        PLACEMENT=\"$OPNAME $COUNT\"\n        COUNT=$(( COUNT + 1 ))\n\
    \    done\n\n    # Evaluate expression\n    VALUE=0\n    for I in $OPLIST; do\n\
    \        VALUE=$(( VALUE + ${OP[$I]} ))\n    done\n    VALUE=$(( VALUE ))\n\n\
    \    # Print result\n    echo \"Result: $VALUE\"", "  local operator=$1\n  local\
    \ operand=$2\n  local result=0\n  local ops=()\n  local i=0\n  while ((i < ${#operator[@]})\
    \ &&  (i < ${#operand[@]}-1)); do\n    case \"${operator[i]}\" in\n      '+'|'-')\
    \ ops=(${ops[@]} $((operand[i]))) ;;\n      '*'|'/') ops=(${ops[@]} $((operand[i]/$((operand[i-1])))))\
    \ ;;\n      '^'|'**') ops=(${ops[@]} $((operand[i]**((operand[i-1]))))) ;;\n \
    \     *) echo \"Operator '${operator[i]}' not recognized\";;\n    esac\n    i=$((i\
    \ + 1))\n  done\n  case ${#ops[@]} in\n    0) echo \"Operand list too short!\"\
    \ ;;\n    1) result=$((ops[0])) ;;\n  esac\n  echo ${result}", "\tIFS=' '\n\t\
    operator=$1\n\toperand=$2\n\toperator_list=$(cat $OPERATOR_FILE)\n\toperands=$(cat\
    \ $OPERAND_FILE)\n\tresult=$(awk -F '[()]' '{printf \"%d\\n\", $1*$2} {printf\
    \  \"%d\\n\", $1+$2} {printf  \"%d\\n\", $1-$2} {printf  \"%d\\n\", $1*$2} {printf\
    \  \"%d\\n\", $1/$2} {printf  \"%d\\n\", $1%$2} {printf  \"%d\\n\", $1+$2%$3}\
    \ {printf  \"%d\\n\", $1-$2%$3} {printf  \"%d\\n\", $1*$2%$3} {printf  \"%d\\\
    n\", $1/$2%$3} {printf  \"%d\\n\", $1%$2%$3} {printf  \"%d\\n\", $1+$2%$3%$4}\
    \ {printf  \"%d\\n\", $1-$2%$3%$4} {printf  \"%d\\n\", $1*$2%$3%$4} {printf  \"\
    %d\\n\", $1/$2%$3%$4} {printf  \"%d\\n\", $1%$2%$3%$4%$5} {printf  \"%d\\n\",\
    \ $1+$2%$3%$4%$5} {printf  \"%d\\n\", $1-$2%$3%$4%$5} {printf  \"%d\\n\", $1*$2%$3%$4%$5}\
    \ {printf  \"%d\\n\", $1/$2%$3%$4%$5} {printf  \"%d\\n\", $1%$2%$3%$4%$5%$6} {printf\
    \  \"%d\\n\", $1+$2%$3%$4%$5%$6} {printf  \"%d\\n\", $1-$2%$3%$4%$5%$6} {printf\
    \  \"%d\\n\", $1*$2%$3%$4%$5%$6} {printf  \"%d\\n\", $1/$2%$3%$4%$5%$6} {printf\
    \  \"%d\\n\", $1%$2%$3%$4%$5%$6%$7} {printf  \"%d\\n\", $1+$2%$3%$4%$5%$6%$7}\
    \ {printf  \"%d\\n\", $1-$2%$3%$4%", "  # echo $2\n  # echo $1 | awk '{print $NF}'\n\
    \  expr=$2\n  # echo $expr\n  for i in $(seq 0 $((${#expr} - 1))); do\n    expr=${expr:i:1}\n\
    \    case \"$expr\" in\n      \"+\")\n        # echo $expr\n        expr=${expr:i+1}\n\
    \        expr=${expr:-$((${#expr} - 1))}\n        expr=$expr$i$((i + 1))\n   \
    \     # echo $expr\n        echo \"${expr}=$((${expr}+$1))\"\n        ;;\n   \
    \   \"-\")\n        # echo $expr\n        expr=${expr:i+1}\n        expr=${expr:-$((${#expr}\
    \ - 1))}\n        expr=$expr$i$((i + 1))\n        # echo $expr\n        echo \"\
    ${expr}=$((${expr}-$1))\"\n        ;;\n      \"*\")\n        # echo $expr\n  \
    \      expr=${expr:i+1}\n        expr=${expr:-$((${#expr} - 1))}\n        expr=$expr$i$((i\
    \ + 1))\n        # echo $expr\n        echo \"${expr}=$((${expr}*$1))\"\n    \
    \    ;;\n      \"//\")\n        # echo $expr\n        expr=${expr:i+1}\n     \
    \   expr=${expr:-$((${#expr} - 1))}\n        expr=$expr$i$((i + 1))\n        #\
    \ echo $expr\n        echo \"${expr}=$((${expr}//$1))\"\n        ;;\n      \"\
    **\")\n        # echo $expr\n        expr=${expr:i+1}\n        expr=${expr:-$((${#expr}\
    \ - 1))}\n        expr=$expr$i$((i + 1))\n        # echo $expr\n        echo \"\
    ${expr}=$((${expr}**$1))\"\n        ;;\n      *)\n        # echo $expr\n     \
    \   expr=$expr$i$((i + 1))\n        # echo $expr\n        echo \"${expr}\"\n \
    \       ;;\n    esac\n  done", '  echo "$1 $2"', "    local OP=$1\n    local OPLIST=$2\n\
    \    local i=0\n    local RESULT=\"\"\n    for x in $OPLIST\n    do\n        RESULT=\"\
    $RESULT$OP$x\"\n        if [ $i -ne $(( $i - 1 )) ]\n        then\n          \
    \  RESULT=\"$RESULT \"\n        fi\n        i=$(( $i + 1 ))\n    done\n    echo\
    \ \"$RESULT\"", "        echo \"$1\"\n        echo \"$2\"\n        for (( i=0;\
    \ i<${#operator[@]}; i++ )); do\n                case \"$1\" in\n            \
    \            ${operator[$i]}*) \n                                echo \"${operand[$((i+1))]}\"\
    \n                                eval echo \"${operator[$i]}${operand[$((i+1))]}\"\
    \n                        ;;\n                esac\n        done\n        ", "\t\
    # Set variables for algebra\n\twhile IFS= read -r op; do\n\t\twhile IFS= read\
    \ -r num; do\n\t\t\t((result+=num))\n\t\tdone <<< \"$(\"$1\"=\"-\"$op \"${2[@]}\"\
    )\"\n\tdone <<< \"$(\"$1\"=\"-\"$op \"${2[@]}\")\"\n\techo \"$result\"", "\t#\
    \ $1 is operator\n\t# $2 is operand\n\n\t# Parse operator\n\tOPERATOR=`echo $1\
    \ | sed 's/ //g'`\n\tcase $OPERATOR in\n\t\t-* | -/)\n\t\t\tOPERATOR=-\n\t\t;;\n\
    \t\t+*)\n\t\t\tOPERATOR=+\n\t\t;;\n\t\t-*)\n\t\t\tOPERATOR=-\n\t\t;;\n\t\t*)\n\
    \t\t\techo \"error: no matching operator in $1\"\n\t\t\texit 1\n\t\t;;\n\tesac\n\
    \n\t# Parse operand\n\tOPEND=`echo $2 | sed 's/ //g'`\n\tcase $OPEND in\n\t\t\
    -*)\n\t\t\tOPEND=-\n\t\t;;\n\t\t*)\n\t\t\techo \"error: no matching operator in\
    \ $2\"\n\t\t\texit 1\n\t\t;;\n\tesac\n\n\t# Run operation on elements\n\tRESULT=`echo\
    \ $1 | sed -e \"s/$OPERATOR/$OPEND/g\" | bc`\n\n\t# Return result\n\techo $RESULT",
  "\toperator=$1\n\toperand=$2\n\tresult=0\n\ti=0\n\twhile [ ${#operand} -gt 0 ]\n\
    \tdo\n\t\tif [ ${operand:$i:1} == '-' ]; then\n\t\t\tresult=${operand:$i:2}\n\t\
    \telse\n\t\t\tresult=$(( $result + ${operand:$i:1} ))\n\t\tfi\n\t\ti=$(( $i +\
    \ 1 ))\n\tdone\n\twhile [ ${#operator} -gt 0 ]\n\tdo\n\t\tif [[ $result -lt $((\
    \ ${#operator} - 1 )) ]]; then\n\t\t\tresult=$(( $result + $(( ${operator:$i:1}\
    \ )) ))\n\t\telse\n\t\t\tresult=$(( $result + $(( ${operator:$i:1} )) ))\n\t\t\
    \ti=$(( $i + 1 ))\n\t\tfi\n\tdone\n\tresult=$(( $result ))\n\techo $result", " \
    \   local operator=\"$1\"\n    local operand=\"$2\"\n\n    local result\n    for\
    \ (( i = 0; i < ${#operand[@]}; i++ )); do\n        result=\"$(( ${operand[i]}\
    \ ${operator[i]} ${operand[i+1]} ))\"\n    done\n\n    echo \"$result\"", "  \
    \  operator=$1\n    operand=$2\n    len_op=$(echo ${#operator[@]})\n    len_op=${len_op-1}\n\
    \    len_operand=$(echo ${#operand[@]})\n    len_operand=${len_operand-2}\n  \
    \  \n    eval_str=\"\"\n    \n    # handle addition\n    if [[ ${operator[0]}\
    \ == \"+\" ]]; then\n        operator=\"${operator[@]:1}\"\n        len_op=$(echo\
    \ ${#operator[@]})\n        len_op=${len_op-1}\n        for (( i=0; i<${len_operand};\
    \ i++ )); do\n            eval_str+=\"${operand[i]}\"\n        done\n        echo\
    \ \"${eval_str}\"\n    \n    # handle subtraction\n    elif [[ ${operator[0]}\
    \ == \"-\" ]]; then\n        operator=\"${operator[@]:1}\"\n        len_op=$(echo\
    \ ${#operator[@]})\n        len_op=${len_op-1}\n        for (( i=0; i<${len_operand};\
    \ i++ )); do\n            eval_str+=\"${operand[i]}\"\n        done\n        eval_str=\"\
    ${eval_str} * -1\"\n        echo \"${eval_str}\"\n    \n    # handle multiplication\n\
    \    elif [[ ${operator[0]} == \"*\" ]]; then\n        operator=\"${operator[@]:1}\"\
    \n        len_op=$(echo ${#operator[@]})\n        len_op=${len_op-1}\n       \
    \ for (( i=0; i<${len_operand}; i++ )); do\n            eval_str+=\"${operand[i]}\"\
    \n        done\n        eval_str=\"${eval_str} / 1\"\n        echo \"${eval_str}\"\
    \n    \n    # handle floor division\n    elif [[ ${operator[0]} == \"//\" ]];\
    \ then\n        operator=\"${operator[@]:1}\"\n        len_op=$(echo ${#operator[@]})\n\
    \        len_op=${len_op-1}\n        for (( i=0; i<${len_operand}; i++ )); do\n\
    \            eval_str+=\"${operand[i]}\"\n        done\n        eval_str=\"${eval_str}\
    \ / 1\"\n        echo \"${eval_str}\"\n    \n    # handle exponentiation\n   \
    \ elif [[ ${operator[0]} == \"**\" ]]; then\n        operator=\"${operator[@]:1}\"\
    \n        len_op=$(echo ${#operator[@]})\n        len_op=${len_op-1}\n       \
    \ for (( i=0; i<${len_operand}; i++ )); do\n            eval_str+=\"${operand[i]}\"\
    \n        done\n        eval_str=\"${eval_str} ** 1\"\n        echo \"${eval_str}\"\
    \n    \n    # ", "    operator=$1\n    operand=$2\n    len=$((${#operator} - 1))\n\
    \    declare -a op_chars=(\"+\" \".\" \"-\" \"*\" \"/\" \"**\")\n    declare -a\
    \ num_chars=(\"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"0\")\n  \
    \  res=0\n    \n    if [[ ${#operand} -lt 2 ]]; then\n        echo \"Error: need\
    \ at least two operands.\" >&2\n        return 2\n    fi\n    \n    for((i=0;\
    \ i<${len}; i++)); do\n        char=${operand:$i:1}\n        char=${char%?}\n\
    \        if [[ \"${op_chars[${i}]}\" == \"${char}\" ]]; then\n            operand=${operand:0:$i}\n\
    \            operand=${operand%?}\n        fi\n    done\n\n    for((j=1; j<${len};\
    \ j++)); do\n        char=${operand:${len-j}:1}\n        char=${char%?}\n    \
    \    if [[ \"${num_chars[${j}]}\" == \"${char}\" ]]; then\n            operand=${operand:0:${len-j}}\n\
    \            operand=${operand%?}\n        fi\n    done\n\n    for((j=1; j<${len};\
    \ j++)); do\n        char=${operand:${len-j}:1}\n        char=${char%?}\n    \
    \    res=${res}${operand:0:${len-j}}\n        operand=${operand%?}\n    done\n\
    \n    res=${res}${operand}\n    res=${res}\n    echo \"${res}\"", "  local op=$1\n\
    \  local arr=$2\n  local exp=''\n  local result=0\n  local index=0\n\n  if [[\
    \ \"${op}\" == '*' ]]; then\n    exp='*'\n  elif [[ \"${op}\" == '-' ]]; then\n\
    \    exp='-'\n  elif [[ \"${op}\" == '+' ]]; then\n    exp='+'\n  elif [[ \"${op}\"\
    \ == '/' ]]; then\n    exp='/'\n  elif [[ \"${op}\" == '**' ]]; then\n    exp='**'\n\
    \  fi\n\n  for n in ${arr[@]}; do\n    if [[ ${exp} != '**' ]]; then\n      result=$((${result}${exp}${n}))\n\
    \    else\n      if [[ ${n} -gt 0 ]]; then\n        result=$((${result}${n}**${exp}))\n\
    \      else\n        echo Invalid Expression\n      fi\n    fi\n    index=$((index+1))\n\
    \    if [[ ${index} -gt ${#op}-1 ]]; then\n      index=0\n    fi\n  done\n  echo\
    \ ${result}", "    local op=$1\n    local operand=$2\n    local expr\n    local\
    \ result\n    local i\n\n    # Check the number of operands\n    if [[ $#operand-ge\
    \ 1 ]]; then\n        expr=\"${op}( ${operand[0]} )\"\n        for (( i=1; i<$#operand;\
    \ i++ )); do\n            expr=\"${expr}, ${op}( ${operand[$i]} )\"\n        done\n\
    \        result=$(eval \"$expr\")\n    else\n        result=$(( ${operand[0]}\
    \ ))\n    fi\n\n    echo \"$result\"", "    local -a operator=\"$1\"; shift\n\
    \    local -a operand=\"$@\"\n    local result\n    local i\n    local operator_count\n\
    \    local operand_count\n    local operator_index\n    local operand_index\n\
    \    local operator_count\n    local operand_count\n    local first_operand\n\
    \    local second_operand\n    local operator\n    local operand\n    local operator_count\n\
    \    local operand_count\n    \n    operator_count=\"${#operator[@]}\"\n    operand_count=\"\
    ${#operand[@]}\"\n    if [ ${operand_count} -ne ${operator_count} ]; then\n  \
    \      echo \"Invalid number of operands\"\n        return 1\n    fi\n    \n \
    \   operator_index=1\n    operand_index=1\n    while [ \"$operator_index\" -lt\
    \ ${operator_count} ]; do\n        operator=\"${operator[$operator_index]}\"\n\
    \        operand=\"${operand[$operand_index]}\"\n        first_operand=\"${operand%:*}\"\
    \n        second_operand=\"${operand##*:}\"\n        \n        if [ \"$first_operand\"\
    \ -eq \"$second_operand\" ]; then\n            # handle cases like '2 * 5'\n \
    \           result=$(( ${first_operand} ))\n        else\n            # handle\
    \ cases like '2 + 3 * 4 - 5'\n            result=$(( ${first_operand} + ${operator}\
    \ ( ${second_operand} )))\n        fi\n        \n        (( operand_index += 1\
    \ ))\n        if [ \"$operand_index\" -eq \"$operand_count\" ]; then\n       \
    \     break\n        fi\n    done\n    \n    echo \"$result\"", "    operator=$1\n\
    \    operand=$2\n    echo -n \"Enter operator: \"\n    read -r op\n    echo -n\
    \ \"Enter operand: \"\n    read -r num\n    echo -n \"Enter value: \"\n    read\
    \ -r value\n    eval ${op}=\\$\\$value\n    echo -n \"Result: \\$\\$(${op}) \\\
    $\\$ \\$\\$\"", "  operator=$1\n  operand=$2\n  result=1\n  \n  for ((i=0; i <\
    \ $(( ${#operand} -1 )); ++i)); do\n    operator=${operator% *}\n    operand=${operand#*\
    \ }\n    case ${operator} in\n      + )\n        result=$(expr $result + $(( ${operand}\
    \ + 1 )))\n        ;;\n      - )\n        result=$(expr $result - $(( ${operand}\
    \ - 1 )))\n        ;;\n      * )\n        result=$(expr $result * $(( ${operand}\
    \ + 1 )))\n        ;;\n      / )\n        result=$(expr $result / $(( ${operand}\
    \ % 2 == 0 ? ${operand}+1 : ${operand} )))\n        ;;\n      ** )\n        result=$(expr\
    \ $result ** $(( ${operand} % 2 == 0 ? ${operand} : ${operand}-1 )))\n       \
    \ ;;\n    esac\n  done\n  \n  echo ${result}", "\toperands=$1\n\toperators=$2\n\
    \tresult=0\n\tfor i in `seq 0 $((${#operands[@]}-1))`; do\n\t\toperator=${operators[i]}\n\
    \t\toperand=${operands[i]}\n\t\tcase \"$operator\" in\n\t\t\t'+')\n\t\t\t\tresult=$((\
    \ ${result} + ${operand} ))\n\t\t\t\t;;\n\t\t\t'-')\n\t\t\t\tresult=$(( ${result}\
    \ - ${operand} ))\n\t\t\t\t;;\n\t\t\t'*')\n\t\t\t\tresult=$(( ${result} + ${operand}\
    \ ))\n\t\t\t\t;;\n\t\t\t'/')\n\t\t\t\tresult=$(( ${result} + ${operand} ))\n\t\
    \t\t\t;;\n\t\t\t'**')\n\t\t\t\tresult=$(( ${result} * ${operand} ))\n\t\t\t\t\
    ;;\n\t\tesac\n\tdone\n\techo \"$result\"", "  echo \"$1 $2\" | awk '{ for(i =\
    \ 1; i <= NF; ++i) sum += $i; }END{ print sum; }'", "    local operator=${1:-\"\
    +\"}\n    local array=${2:-\"2 3 4 5\"}\n    local result=0\n    local i=0\n \
    \   local j=0\n\n    while [ $i -lt ${#array[@]} ]; do\n        local operator=${operator:+\"\
    +\"}\n        local operator=${operator%+}\n        if [[ -z ${operator} ]]; then\n\
    \            break;\n        fi\n\n        local operand=${array[$i]}\n      \
    \  i=$((i+1))\n        local operand=${operand%+}\n        if [[ -z ${operand}\
    \ ]]; then\n            break;\n        fi\n\n        local operator=${operator%+}\n\
    \        local operand=${operand%+}\n        if [[ -z ${operand} ]]; then\n  \
    \          break;\n        fi\n\n        local operand=${operand}\n\n        case\
    \ \"${operator}\" in\n            /*) result=${result}$(do_algebra \"${operator}\"\
    \ \"${operand}\");;\n            +) result=${result}${operand};;\n           \
    \ -) result=${result}-${operand};;\n            *) echo \"Error: Unkown operator:\
    \ ${operator}\" 1>&2; exit 1;;\n        esac\n    done\n\n    echo \"${result}\"",
  "    local operator operand result\n    operator=$1\n    operand=$2\n    if [[ ${#operator[@]}\
    \ = 0 ]]; then\n        echo \"error: empty operator list passed to do_algebra\"\
    \n        return 1\n    fi\n    if [[ ${#operand[@]} = 0 ]]; then\n        echo\
    \ \"error: empty operand list passed to do_algebra\"\n        return 1\n    fi\n\
    \    \n    result=0\n    if [[ ${#operator[@]} = 1 ]]; then\n        if [[ ${#operand[@]}\
    \ = 1 ]]; then\n            if [[ ${operator[0]} == \"+\" ]]; then\n         \
    \       result=$(( ${operand[0]} + ${operand[1]} ))\n            fi\n        \
    \    if [[ ${operator[0]} == \"-\" ]]; then\n                result=$(( ${operand[0]}\
    \ - ${operand[1]} ))\n            fi\n            if [[ ${operator[0]} == \"*\"\
    \ ]]; then\n                result=$(( ${operand[0]} * ${operand[1]} ))\n    \
    \        fi\n            if [[ ${operator[0]} == \"//\" ]]; then\n           \
    \     result=$(( ${operand[0]} / ${operand[1]} ))\n            fi\n          \
    \  if [[ ${operator[0]} == \"**\" ]]; then\n                result=$(( ${operand[0]}\
    \ ** ${operand[1]} ))\n            fi\n        fi\n    else\n        echo \"error:\
    \ not implemented do_algebra for more than 2 operations\"\n        return 1\n\
    \    fi\n    echo $result", "\t# set operands\n\teval operands=(\"$1\")\n\techo\
    \ \"operands=$operands\"\n\t# set operators\n\teval operators=(\"$2\")\n\techo\
    \ \"operators=$operators\"\n\t# set result to empty\n\tresult=\"\"\n\t# if operand\
    \ list length is less than one or two or two operands, return error\n\t[[ ${#operands[@]}\
    \ -eq 1 ]] || [[ ${#operands[@]} -eq 2 ]] || [[ ${#operands[@]} -eq 3 ]]\n\techo\
    \ \"operands=$operands\"\n\techo \"operators=$operators\"\n\t# for each operator\
    \ in operators\n\tfor operator in \"${operators[@]}\"; do\n\t\t# for each operand\
    \ in operands\n\t\tfor operand in \"${operands[@]}\"; do\n\t\t\t# if the operand\
    \ is less than 0, return error\n\t\t\t[[ \"$operand\" -lt 0 ]] && return 1\n\t\
    \t\t# if the operand is 0, return 0\n\t\t\t[[ \"$operand\" = 0 ]] && return 0\n\
    \t\t\t# if the operand is negative, flip it\n\t\t\t[[ \"$operand\" -gt 0 ]] &&\
    \ operand=-\"$operand\"\n\t\t\t# build the operator\n\t\t\tresult=\"$result${operator}$operand\"\
    \n\t\t\t# echo the result, \n\t\t\techo \"$result\"\n\t\tdone\n\tdone\n\t# echo\
    \ the result\n\techo \"$result\"", "    local operator array\n    local result\
    \ operand\n    local operator operand\n    operator=\"$1\"\n    operand=\"$2\"\
    \n    for (( i = 0; i <= (${#operand}-1); i++ )); do\n        case \"${operator[$i]}\"\
    \ in\n            (*)\n                if (( ${operand[$i]} < 0 )); then\n   \
    \                 echo \"error: operand $i cannot be negative\" >&2\n        \
    \            return 1\n                fi\n                case \"${operator[$i]}\"\
    \ in\n                    (*)\n                        result=$(( result ${operand[$i]}\
    \ ))\n                        ;;\n                    (*)\n                  \
    \      operand[$i]=$(( operand[$i] ))\n                        ;;\n          \
    \      esac\n                ;;\n            (*)\n                case \"${operator[$i]}\"\
    \ in\n                    (*)\n                        result=$(( result ${operand[$i]}\
    \ ))\n                        ;;\n                    (*)\n                  \
    \      operand[$i]=$(( operand[$i] ))\n                        ;;\n          \
    \      esac\n                ;;\n        esac\n    done\n    eval \"result=$((\
    \ $result ))\"", "    operator=$1\n    operand=$2\n    i=3\n    result=0\n   \
    \ while [ $i -le ${#operand} ]; do\n        operation=${operator[$i]}\n      \
    \  operand1=${operand[$(( i - 1 ))]}\n        operand2=${operand[$(( i + 1 ))]}\n\
    \        (( result = result + operation ))\n        (( result = result * operand1\
    \ ))\n        (( result = result - operand2 ))\n        (( result = result //\
    \ operand1 ))\n        (( result = result ** operand1 ))\n        (( i = i + 1\
    \ ))\n    done\n    echo \"${result}\"", "  local operator=$1\n  local operand=$2\n\
    \n  local operator_index=0\n  local operand_index=0\n  local result=0\n\n  while\
    \ [ $(( $operand_index < $(( ${#operand[@]} - 1 )) )) ]\n  do\n    local operation_str=${operand[$operand_index]}\
    \ ${operator[$operator_index]}\n    result=$(( $result ${operation_str} ))\n\n\
    \    operator_index=$(( $operator_index + 1 ))\n    operand_index=$(( $operand_index\
    \ + 1 ))\n  done\n\n  echo $result", "    operator=$1\n    operand=$2\n    \n\
    \    if [ -z $operator ] || [ -z $operand ]\n    then\n        echo \"Invalid\
    \ input\"\n        return\n    fi\n    \n    sum=0\n    for i in `seq 0 $((${#operand}\
    \ - 1))`; do\n        operand=`expr $operand - $i`\n        sum=`expr $sum + $operand`\n\
    \    done\n    echo \"$sum $operator $operand\"", "    local OP=$1\n    local\
    \ OPERAND=$2\n    local OPERAND2=$3\n\n    local OPS=(\"+\" \"+\" \"*\" \"-\"\
    \ \"/\" \"**\")\n    local OPS2=(\"-\" \"/\" \"**\")\n\n    # check if operator\
    \ is correct\n    if [[ ! ${#OPS[@]} =~ \"${OP}\" ]]; then\n        echo \"ERROR:\
    \ Invalid operator.\"\n        exit 1\n    fi\n\n    # check if second operand\
    \ is correct\n    if [[ ! ${#OPERAND2[@]} =~ \"${OPERAND2}\" ]]; then\n      \
    \  echo \"ERROR: Invalid second operand.\"\n        exit 1\n    fi\n\n    # check\
    \ if length of operator list is same as length of operand list minus 1\n    if\
    \ [[ ${#OPS[@]} != ${#OPERAND[@]} ]]; then\n        echo \"ERROR: Operator list\
    \ length must equal operand list length - 1.\"\n        exit 1\n    fi\n\n   \
    \ # check if first operand is correct\n    if [[ ! ${#OPERAND[@]} =~ \"${OPERAND}\"\
    \ ]]; then\n        echo \"ERROR: Invalid first operand.\"\n        exit 1\n \
    \   fi\n\n    # check if first and second operands are non-negative\n    if [[\
    \ \"$OPERAND\" < 0 || \"$OPERAND2\" < 0 ]]; then\n        echo \"ERROR: First\
    \ and second operands must be non-negative.\"\n        exit 1\n    fi\n\n    #\
    \ convert both operands to integers while removing any whitespace\n    local OP_NUMBER1=$(echo\
    \ -e \"${OPERAND}\" | tr -d '[[:space:]]')\n    local OP_NUMBER2=$(echo -e \"\
    ${OPERAND2}\" | tr -d '[[:space:]]')\n\n    # check if first operand is an integer\n\
    \    if [[ ! \"$OP_NUMBER1\" =~ ^[0-9]+$ ]]; then\n        echo \"ERROR: First\
    \ operand must be an integer.\"\n        exit 1\n    fi\n\n    # check if second\
    \ operand is an integer\n    if [[ ! \"$OP_NUMBER2\" =~ ^[0-9]+$ ]]; then\n  \
    \      echo \"ERROR: Second operand must be an integer.\"\n        exit 1\n  \
    \  fi\n\n    # check if second operand is greater than first operand\n    if [\
    \ \"$OP_NUMBER2\" -gt \"$OP_NUMBER1\" ]; then\n        echo \"ERROR: Second operand\
    \ must be greater than the first operand.\"\n        exit 1\n    fi\n\n    # create\
    \ string containing arithmetic expression of first operand and first operator\n\
    \    local OP1=${OPS[0]}\n    # add second operand to string\n    local OP2=${OPS[1]}\n\
    \    # add third operand to string\n    local OP3=${OPS[2]}\n\n    # determine\
    \ operation between first and second operand\n    if [ \"$OP\" == \"+\" ]; then\n\
    \        eval ${OP1}", "    local operator operand\n    operator=$1\n    operand=$2\n\
    \    local index=0\n    local result\n    while [ \"$index\" -lt ${#operator[@]}\
    \ ]\n    do\n        local op=$(echo \"${operator[$index]}\" | tr '[:upper:]'\
    \ '[:lower:]')\n        local op2=$(echo \"${operand[$index]}\" | tr '[:upper:]'\
    \ '[:lower:]')\n        case \"${op}\" in\n            +) result=$((${operand[$index]}\
    \ + ${operand[$index+1]}))\n            ;;\n            -) result=$((${operand[$index]}\
    \ - ${operand[$index+1]}))\n            ;;\n            *) result=$((${operand[$index]}\
    \ * ${operand[$index+1]}))\n            ;;\n            /) result=$((${operand[$index]}\
    \ / ${operand[$index+1]}))\n            ;;\n            %) result=$((${operand[$index]}\
    \ % ${operand[$index+1]}))\n            ;;\n            **) result=$((${operand[$index]}\
    \ ^ ${operand[$index+1]}))\n            ;;\n            *)\n                echo\
    \ \"Error: unknown op: ${operator[$index]}\"\n                exit -1\n      \
    \      ;;\n        esac\n        index=$((index + 1))\n    done\n    echo \"${result}\"",
  "    local operator operand\n    operator=( $1 )\n    operand=( $2 )\n    echo \"\
    operand=${operand[*]}\"\n    echo \"operator=${operator[*]}\"\n    local eval\n\
    \    eval=$(arithmetic_operation \"${operator[@]}\" \"${operand[@]}\")\n    echo\
    \ \"eval=${eval}\"\n    eval=$(arithmetic_operation \"-\" \"${operand[@]}\")\n\
    \    echo \"eval=${eval}\"", "  local op=$1\n  local array=$2\n  local result\n\
    \  local i\n\n  result=0\n  for i in \"${array[@]}\"; do\n    case \"${op}\" in\n\
    \      \"+\") result=$((result+i)) ;;\n      \"-\") result=$((result-i)) ;;\n\
    \      \"*\") result=$((result*i)) ;;\n      \"/\") result=$((result/i)) ;;\n\
    \      \"**\") result=$((result**i)) ;;\n      *) echo \"Please check the input\
    \ array and operator.\"\n    esac\n  done\n  echo ${result}", "  local operator\
    \ operand\n  operator=$1\n  operand=$2\n  \n  local result=0\n  local i=${#operand}\n\
    \  \n  # If only one operant is given, assume it is the result operand.\n  if\
    \ [ \"${#operand}\" -eq \"1\" ]; then\n    result=${operand}\n    operand=()\n\
    \  fi\n  \n  while [[ $i -gt 0 ]]; do\n    # Perform the operation\n    case \"\
    ${operator}\" in\n      \"+\")\n        result=$((result+${operand[i]}))\n   \
    \     ((i--))\n        ;;\n      \"-\")\n        result=$((result-${operand[i]}))\n\
    \        ((i--))\n        ;;\n      \"*\")\n        result=$((result*${operand[i]}))\n\
    \        ((i--))\n        ;;\n      \"/\")\n        result=$((result/${operand[i]}))\n\
    \        ((i--))\n        ;;\n      \"**\")\n        result=$((result**${operand[i]}))\n\
    \        ((i--))\n        ;;\n    esac\n  done\n  \n  return ${result}", "\t#\
    \ The first line is the operator list. The operator list has at least one operator,\
    \ and \n\t# operand list has at least two operands.\n\tIFS=' ' read -r OPERATOR\
    \ OPERAND <<< \"$1\"\n\tOPERATOR=$(tr '[:upper:]' '[:lower:]' <<< \"$OPERATOR\"\
    )\n\tOPERAND=$(tr '[:upper:]' '[:lower:]' <<< \"$OPERAND\")\n\teval \"echo \\\
    ( \\${$OPERATOR} \\${$OPERAND} \\)\"", "  local operator operand\n  local eval\n\
    \  IFS=' ' read -r -a operator <<< \"$1\"\n  IFS=' ' read -r -a operand <<< \"\
    $2\"\n  eval \"echo ${operand[*]} ${operator[*]} ${operand[*]}\"", "    # Convert\
    \ the input arguments into lists\n    operator=$1\n    array=$2\n    length=$((\
    \ ${#operator[@]} - 1 ))\n    \n    if [[ $length -gt 1 ]]; then\n        echo\
    \ \"Error: Operator list should contain at least one operator\"\n        exit\
    \ 1\n    fi\n    \n    if [[ $length -gt 2 ]]; then\n        echo \"Error: Operand\
    \ list should contain at least two operands\"\n        exit 1\n    fi\n    \n\
    \    operands=()\n    for (( i=0; i<${#array[@]}; i++ )); do\n        operands+=(\
    \ ${array[$i]} )\n    done\n    \n    # Make sure that all operands are non-negative\n\
    \    for (( i=0; i<${#operands[@]}; i++ )); do\n        if [[ ${operands[$i]}\
    \ -lt 0 ]]; then\n            echo \"Error: All operands should be non-negative\"\
    \n            exit 1\n        fi\n    done\n    \n    # Make sure that all operators\
    \ are valid\n    operators=( ${operator[@]} )\n    valid_operators=( \"+\" \"\
    \ - \" * \" * \" * \" * \" * \" * ) // \" \" ** \" * \" * \" * \" * \" * \" *\
    \ \" * \" * )\n    \n    length=${#valid_operators[@]}\n    for (( i=0; i<length;\
    \ i++ )); do\n        if [[ ${valid_operators[$i]} != ${operators[$i]} ]]; then\n\
    \            echo \"Error: Invalid operator ${valid_operators[$i]}\"\n       \
    \     exit 1\n        fi\n    done\n    \n    # Make sure that the length of the\
    \ operator list equals the length of the operand list minus one\n    if [[ $length\
    \ -ne $(( $(( ${#operands[@]} - 1 )) )) ]]; then\n        echo \"Error: Operand\
    \ list should have ${#operands[@]} elements but contains ${length} elements\"\n\
    \        exit 1\n    fi\n    \n    # Build the expression\n    expression=$(do_algebra_arithmetic\
    \ ${operands[@]})\n    echo \"${expression}\"", "    local operator=$1\n    local\
    \ operand=$2\n    local result=0\n    local i=0\n    while (( i < ${#operand}\
    \ )) ; do\n\tresult=$(( result ${operator} ( ${operand} [ ${i} ] ) ))\n\t(( i++\
    \ ))\n    done\n    echo \"${result}\"", "\toperator=$1\n\toperand=$2\n\t\n\t\
    result=0\n\t\n\t# Check for empty lists\n\tif [ ${#operator[@]} -eq 0 ]; then\n\
    \t\techo \"Error: missing operator list\"\n\t\treturn 1\n\tfi\n\t\n\tif [ ${#operand[@]}\
    \ -eq 0 ]; then\n\t\techo \"Error: missing operand list\"\n\t\treturn 1\n\tfi\n\
    \t\n\t# Check for duplicate operators\n\tmapfile -t opr < <(echo \"${operator[*]}\"\
    ) && echo \"Error: duplicate operators found\"\n\t\n\t# Check for negative operands\n\
    \tmapfile -t opr < <(echo \"${operand[*]}\") && echo \"Error: negative operands\
    \ found\"\n\n\twhile read opr && read num; do\n\t\tif [[ $opr == '+' ]]; then\n\
    \t\t\tresult=$(( ${result} + ${num} ))\n\t\telif [[ $opr == '-' ]]; then\n\t\t\
    \tresult=$(( ${result} - ${num} ))\n\t\telif [[ $opr == '*' ]]; then\n\t\t\tresult=$((\
    \ ${result} * ${num} ))\n\t\telif [[ $opr == '/' ]]; then\n\t\t\tresult=$(( ${result}\
    \ / ${num} ))\n\t\telif [[ $opr == '**' ]]; then\n\t\t\tresult=$(( ${result} **\
    \ ${num} ))\n\t\telse\n\t\t\techo \"Error: unknown operator encountered\"\n\t\t\
    \treturn 1\n\t\tfi\n\tdone < <(echo \"${operand[*]}\") < <(echo \"${operator[*]}\"\
    ) || return 1\n\t\n\tif [[ ${result} -lt 0 ]]; then\n\t\techo \"Error: negative\
    \ number encountered\"\n\t\treturn 1\n\tfi\n\techo $result", "    local operator=\"\
    $1\"\n    local operand=\"$2\"\n    local result\n\n    # Remove the spaces from\
    \ the lists \n    operator=$(remove_spaces \"$operator\")\n    operand=$(remove_spaces\
    \ \"$operand\")\n\n    # Check the length of the operator and operand lists\n\
    \    if [ -z \"$operator\" ] || [ -z \"$operand\" ]; then\n        echo \"Missing\
    \ parameters. Usage: do_algebra operator operand\"\n        exit 1\n    fi\n\n\
    \    # Make sure the operator list has at least one operator\n    if [ $(list_length\
    \ $operator) -eq 0 ]; then\n        echo \"Error: operator list has zero operands.\
    \ Usage: do_algebra operator operand\"\n        exit 1\n    fi\n\n    # Make sure\
    \ the operand list has two operands\n    if [ $(list_length $operand) -lt 2 ];\
    \ then\n        echo \"Error: operand list has less than two operands. Usage:\
    \ do_algebra operator operand\"\n        exit 1\n    fi\n\n    # Initialize the\
    \ result\n    result=0\n\n    # Loop through the operator list\n    for (( i=1;\
    \ i<${#operator}; i++ )); do\n        # Perform the algebra operation on the first\
    \ operand\n        local operand1=$(echo $operand | cut -d ' ' -f $i)\n      \
    \  local operand2=$(echo $operand | cut -d ' ' -f $(i+1))\n        local operation=$(echo\
    \ $operator | cut -d ' ' -f $i)\n\n        # Perform the algebra operation on\
    \ the second operand\n        local operand3=$(echo $operand | cut -d ' ' -f $(i+1))\n\
    \        local operand4=$(echo $operand | cut -d ' ' -f $(i+2))\n\n        # Perform\
    \ the operation\n        case \"$operation\" in\n            *)\n            \
    \    # Add the operands\n                result=$(( ${result} + ${operand1} ${operation}\
    \ ${operand2} ))\n                # Add the operands\n                result=$((\
    \ ${result} + ${operand3} ${operation} ${operand4} ))\n                ;;\n  \
    \          *)\n                echo \"Error: unknown operator. Usage: do_algebra\
    \ operator operand\"\n                exit 1\n                ;;\n        esac\n\
    \    done\n\n    # Return the result\n    echo \"$result\"", "    \n    # Check\
    \ if at least two operands are given\n    if (( \"$#\" != 2 )); then\n       \
    \ echo \"Usage: $0 [operator] [operand]\"\n        echo \"where [operator] is\
    \ an algebraic operation symbol and [operand] is a list of integers\"\n      \
    \  exit 1\n    fi\n    \n    # Convert operator list to symbols\n    operator=$(echo\
    \ \"$1\" | tr \" \" \"+\")\n    \n    # Convert operand list to integers\n   \
    \ operand=$(echo \"$2\" | tr \" \" \"+\")\n    \n    # Initialize result variable\n\
    \    result=0\n    \n    # Parse operand list into separate variables\n    operand1=${operand[0]}\n\
    \    operand2=${operand[1]}\n    \n    # Parse operator list into separate variables\n\
    \    operator1=${operator[0]}\n    operator2=${operator[1]}\n    \n    # Parse\
    \ result into separate variables\n    result1=${result}\n    result2=${result}\n\
    \    \n    # Parse operand1 into separate variables\n    operand1value=${operand1}\n\
    \    operand1symbol=${operand1//+([0-9])/+($1)}\n    \n    # Parse operand2 into\
    \ separate variables\n    operand2value=${operand2}\n    operand2symbol=${operand2//+([0-9])/+($2)}\n\
    \    \n    # Parse operator1 into separate variables\n    operator1value=${operator1}\n\
    \    operator1symbol=${operator1//+([0-9])/+($1)}\n    \n    # Parse operator2\
    \ into separate variables\n    operator2value=${operator2}\n    operator2symbol=${operator2//+([0-9])/+($2)}\n\
    \    \n    # Parse result into separate variables\n    result1value=${result1}\n\
    \    result2value=${result2}\n    \n    case \"${operator1symbol}\" in\n     \
    \   *)\n            case \"${operator2symbol}\" in\n                *)\n     \
    \               case \"${operand1symbol}\" in\n                        *)\n  \
    \                          case \"${operand2symbol}\" in\n                   \
    \             *)\n                                    result=$(( $operand1value\
    \ $operator1value $operand2value ))\n                                    echo\
    \ \"$result\"\n                                esac\n                        \
    \    esac\n                        esac\n                    esac\n          \
    \      esac\n            esac\n        esac\n        \n        \n    \n    case\
    \ \"${operator2symbol}\" in\n        *)\n            case \"${operator1symbol}\"\
    \ in\n                *)\n                    case \"${operand2symbol}\" in\n\
    \                        *)\n                            case \"${operand1symbol}\"\
    \ in\n                                *)\n                                   \
    \ result=$(( $operand1", "  operator=$1\n  operand=$2\n  result=0\n  for element\
    \ in ${operand[@]}; do\n    if [[ $element -gt 0 ]]; then\n      result=$(( ${result}\
    \ * ${element} ))\n    fi\n  done\n  for element in ${operator[@]}; do\n    if\
    \ [[ $element == \"+\" ]]; then\n      result=$(( ${result} + ${operand} ))\n\
    \    elif [[ $element == \"-\" ]]; then\n      result=$(( ${result} - ${operand}\
    \ ))\n    elif [[ $element == \"*\" ]]; then\n      result=$(( ${result} * ${operand}\
    \ ))\n    elif [[ $element == \"/\" ]]; then\n      result=$(( ${result} / ${operand}\
    \ ))\n    elif [[ $element == \"**\" ]]; then\n      result=$(( ${result} ** ${operand}\
    \ ))\n    fi\n  done\n  echo \"${result}\"", "  if [ $# != 2 ]; then\n    echo\
    \ \"Usage: do_algebra OPERATOR OPERAND\"\n    exit -1\n  fi\n\n  local OP=$1\n\
    \  local OP2=$2\n  local OP2_ARRAY=$2\n\n  local OP2_LENGTH=${#OP2_ARRAY[@]}\n\
    \  local OP_ARRAY=${OP//+/ }\n  local OP_LEN=${#OP_ARRAY[@]}\n  local OP_LENGTH=${#OP_ARRAY[@]}\n\
    \  local OP2_LEN=${#OP2_ARRAY[@]}\n\n  # Check op list for existence\n  if [ ${OP_LENGTH}\
    \ -eq 0 ]; then\n    echo \"ERROR: Operator list is empty\"\n    exit -1\n  fi\n\
    \n  # Check op list for non-alphanumeric characters\n  if [ ${OP_LEN} -eq 0 ];\
    \ then\n    echo \"ERROR: Operator list contains no operators\"\n    exit -1\n\
    \  fi\n\n  # Check op list for existence\n  if [ ${OP2_LEN} -eq 0 ]; then\n  \
    \  echo \"ERROR: Operand list is empty\"\n    exit -1\n  fi\n\n  # Check op list\
    \ for non-alphanumeric characters\n  if [ ${OP2_LENGTH} -eq 0 ]; then\n    echo\
    \ \"ERROR: Operand list contains no operands\"\n    exit -1\n  fi\n\n  # Check\
    \ op list for existence\n  if [ ${OP2_LENGTH} != ${OP_LEN} ]; then\n    echo \"\
    ERROR: Operand list size does not match operator list size\"\n    exit -1\n  fi\n\
    \n  # Check op list for existence\n  if [ ${OP_LENGTH} != ${OP2_LEN} ]; then\n\
    \    echo \"ERROR: Operator list size does not match operand list size\"\n   \
    \ exit -1\n  fi\n\n  # Check op list for alphanumeric characters\n  if [ ${OP_LEN}\
    \ != ${OP2_LEN} ]; then\n    echo \"ERROR: Operator list contains invalid operators\"\
    \n    exit -1\n  fi\n\n  # Check op list for existence\n  if [ ${OP_LEN} != ${OP2_LEN}\
    \ ]; then\n    echo \"ERROR: Operand list contains invalid operands\"\n    exit\
    \ -1\n  fi\n\n  local ARRAY_LENGTH=${#OP2_ARRAY[@]}\n  if [ $ARRAY_LENGTH == 0\
    \ ]; then\n    echo \"ERROR: Operand list is empty\"\n    exit -1\n  fi\n\n  local\
    \ SUM=0\n  local COUNTER=0\n\n  for (( i=0; i<${ARRAY_LENGTH}; i++ )); do\n  \
    \  if [ $i == \"0\" ]; then\n      SUM=`echo \"${OP2_ARRAY[$i]}\" | sed \"s/[^0-9",
  "\t# Parse command line arguments\n\tlocal -r operator=$1\n\tlocal -r operand=$2\n\
    \techo \"$OPERATION ${OPERAND[*]}\"\n\tlocal -r OPERATION=$operator\n\tlocal -r\
    \ OPERAND=(${operand//,/ })\n\n\t# Evaluate and return the result\n\tlocal RESULT=$(eval\
    \ \"(${OPERATION} ${OPERAND[0]} ${OPERAND[1]} ${OPERAND[2]} ${OPERAND[3]} ${OPERAND[4]}\
    \ ${OPERAND[5]} ${OPERAND[6]} ${OPERAND[7]})\")\n\techo \"$RESULT\"", "  # Variables\n\
    \  local oprtr=$1; shift;\n  local opnd=$1; shift;\n\n  # Make sure there are\
    \ at least two operands and operators\n  if [[ ${#oprtr} -lt 1 ]] || [[ ${#opnd}\
    \ -lt 2 ]]; then\n    echo \"Error: missing operator, operand\"\n    exit 1;\n\
    \  fi\n\n  # Make sure all the operators are valid operators\n  local oplist=(${oprtr//[[:space:]]/});\n\
    \  for ((i=0; i<${#oplist[*]}; i++)); do\n    if [[ \"${oplist[$i]}\" != \\* ]];\
    \ then\n      echo \"Error: invalid operator: ${oprtr}\"\n      exit 1;\n    fi\n\
    \  done\n\n  # Make sure all the operands are valid numbers\n  local opnumlist=(${opnd//[[:space:]]/});\n\
    \  for ((i=0; i<${#opnumlist[*]}; i++)); do\n    if [[ ! -z \"$opnumlist[$i]\"\
    \ && $((${#opnumlist[*]} - $i)) == 1 ]]; then\n      echo \"Error: invalid operand:\
    \ ${opnd}\"\n      exit 1;\n    fi\n  done\n\n  # Build expression\n  local exp=\"\
    (${opnumlist[*]}\";\n  for ((i=0; i<${#oplist[*]}; i++)); do\n    if [[ \"${oplist[$i]}\"\
    \ == \"+\" ]]; then\n      exp=${exp}+\"(${opnumlist[$(($i+1))]})\"\n    elif\
    \ [[ \"${oplist[$i]}\" == \"-\" ]]; then\n      exp=${exp}+\"-(${opnumlist[$(($i+1))]})\"\
    \n    elif [[ \"${oplist[$i]}\" == \"*\" ]]; then\n      exp=${exp}+\"*(${opnumlist[$(($i+1))]})\"\
    \n    elif [[ \"${oplist[$i]}\" == \"//\" ]]; then\n      exp=${exp}+\"//(${opnumlist[$(($i+1))]})\"\
    \n    elif [[ \"${oplist[$i]}\" == \"**\" ]]; then\n      exp=${exp}+\"**(${opnumlist[$(($i+1))]})\"\
    \n    else\n      echo \"Error: invalid operator: ${oprtr}\"\n      exit 1;\n\
    \    fi\n  done\n  exp=${exp})\";\n\n  # Evaluate expression\n  echo \"${exp}\"\
    \ | bc -l", "    local op=$1\n    local array=$2\n    local result=0\n\n    #\
    \ Split each operator into its operand (operand)\n    while read operator; do\n\
    \        local operand=$2\n        shift 2\n\n        # Perform the requested\
    \ operation\n        case ${operator} in\n            ${op}*) # Multiply operand\n\
    \                result=$((${result} * ${operand}))\n                ;;\n    \
    \        ${op}+) # Add operand\n                result=$((${result} + ${operand}))\n\
    \                ;;\n            ${op}-) # Subtract operand\n                result=$((${result}\
    \ - ${operand}))\n                ;;\n            ${op}%) # Divide operand\n \
    \               result=$((${result} % ${operand}))\n                ;;\n     \
    \       ${op}//) # Divide operand by operand\n                result=$((${result}\
    \ / ${operand}))\n                ;;\n            ${op}^) # Exponentiate operand\n\
    \                result=$((${result} ** ${operand}))\n                ;;\n   \
    \     esac\n    done\n\n    echo $result", "    local operator operand\n    operator=$1\n\
    \    operand=$2\n    local result tmp\n    # Get the number of operators.\n  \
    \  while [ -n \"$operand\" ]; do\n        (( ++cnt ))\n        operand=$(echo\
    \ $operand | cut -d\" \" -f1)\n    done\n    # Get the number of operands.\n \
    \   while [ -n \"$operator\" ]; do\n        (( ++cnt ))\n        operator=$(echo\
    \ $operator | cut -d\" \" -f1)\n    done\n    if [ $cnt -eq 0 ]; then\n      \
    \  echo \"invalid input\"\n        return 1\n    fi\n    \n    # Check if both\
    \ operand and operator has one operator.\n    if [ $cnt -eq 1 ]; then\n      \
    \  if [ $operator == \"+\" -o $operator == \"-\" -o $operator == \"*\" -o $operator\
    \ == \"/\" -o $operator == \"**\" ]; then\n            result=$operand\n     \
    \   fi\n    else\n        result=$operand\n        echo ${result}\n    fi\n  \
    \  if [ $operator == \"+\" -o $operator == \"-\" ]; then\n        (( result =\
    \ $operand+$operand ))\n    elif [ $operator == \"*\" -o $operator == \"/\" -o\
    \ $operator == \"**\" ]; then\n        (( result = $operand*$operand ))\n    elif\
    \ [ $operator == \"**\" ]; then\n        (( result = $operand**$operand ))\n \
    \   fi\n    echo $result ", "  # convert argument list into array\n  local operator=\"\
    $1\"\n  local operand=\"$2\"\n\n  # check whether the length of the operator list\
    \ matches the length of the operand list\n  if [ ${#operator} -ne ${#operand}\
    \ ]; then\n    echo \"error: invalid input -- invalid number of operands and operators\"\
    \n    return 1\n  fi\n\n  # convert the operator list into an array\n  local operators=(\
    \ ${operator} )\n\n  # loop through each operand and perform the basic arithmetic\
    \ operation\n  for operand in ${operand}; do\n    # initialize expression to 0\n\
    \    local expression=0\n\n    # loop through the operator list\n    for (( i=0;\
    \ i<${#operators[@]}; i++ )); do\n      # check the operator and perform the appropriate\
    \ arithmetic operation\n      if [[ ${operators[$i]} == '+' ]]; then\n       \
    \ expression=$(( expression + operand ))\n      elif [[ ${operators[$i]} == '-'\
    \ ]]; then\n        expression=$(( expression - operand ))\n      elif [[ ${operators[$i]}\
    \ == '*' ]]; then\n        expression=$(( expression * operand ))\n      elif\
    \ [[ ${operators[$i]} == '/' ]]; then\n        expression=$(( expression / operand\
    \ ))\n      elif [[ ${operators[$i]} == '**' ]]; then\n        expression=$((\
    \ expression ** operand ))\n      else\n        echo \"error: invalid operator\
    \ -- invalid operator\"\n        return 1\n      fi\n    done\n\n    echo \"$expression\"\
    \n  done", "  if [[ ${#1} == 0 || ${#2} < 2 ]]; then \n    echo \"Error: Need\
    \ 2 operands in ${1} and ${2}.\" 1>&2\n    exit 1\n  fi\n  \n  # Make sure that\
    \ ${1} and ${2} are both non-empty.\n  check_non_empty\n  # Make sure that $2\
    \ has at least one operand.\n  check_non_empty\n  \n  operator=$1\n  operand=$2\n\
    \  result=\"\"\n  \n  # The first element of operand should always be a number.\n\
    \  check_non_empty\n  \n  for ((i = 0; i < ${#operand}; i++))\n  do\n    if [[\
    \ \"${operand:$i:1}\" != \"\" ]]\n    then\n      result=$(expr \"${result} ${operand:$i:1}\"\
    )\n    fi\n  done\n  \n  # Now that we have evaluated the result, the remaining\
    \ elements of operand should always \n  # be numbers.\n  for ((i = 0; i < ${#operand};\
    \ i++))\n  do\n    if [[ \"${operand:$i:1}\" != \"\" ]]\n    then\n      check_non_empty\n\
    \    fi\n  done\n  \n  if [[ \"${operator}\" == \"-\" ]]\n  then\n    result=$(expr\
    \ \"-${result}\")\n  fi\n  \n  if [[ \"${operator}\" == \"*\" ]]\n  then\n   \
    \ result=$(expr \"${result} * ${operand}\")\n  fi\n  \n  if [[ \"${operator}\"\
    \ == \"/\" ]]\n  then\n    result=$(expr \"${result} / ${operand}\")\n  fi\n \
    \ \n  if [[ \"${operator}\" == \"//\" ]]\n  then\n    result=$(expr \"${result}\
    \ // ${operand}\")\n  fi\n  \n  if [[ \"${operator}\" == \"**\" ]]\n  then\n \
    \   result=$(expr \"${result} ** ${operand}\")\n  fi\n  \n  echo \"${result}\"",
  "    operator=$1\n    operand=$2\n    operators=$(cat operators.txt | grep \"$operator\"\
    )\n    operands=$(cat operands.txt | grep \"$operand\")\n    echo -n \"Calculation\
    \ result: \"\n    while read -r expression; do\n        # echo \"$expression\"\
    \n        result=$(( $expression + $operands[$((${#operands[@]} - 1))] ))\n  \
    \      echo \"$result\"\n    done < <(echo ${expressions[@]} | tr ' ' '\\n' |\
    \ grep '^[+-]$' | cut -d'+' -f1 | paste -s -d + -) ", "    operator=${1%' '} \n\
    \    operands=($(echo \"${2#*<}>\" |sed 's/[ \\t]\\+//g'))\n    operands=($(echo\
    \ \"${operands[@]}\" |sed 's/[ \\t]\\+//g'))\n    shift\n    shift\n    operator=${1%'\
    \ '} \n    operands=($(echo \"${2#*<}>\" |sed 's/[ \\t]\\+//g'))\n    operands=($(echo\
    \ \"${operands[@]}\" |sed 's/[ \\t]\\+//g'))\n    \n    operator=$(echo \"$operator\"\
    \ | tr '[:upper:]' '[:lower:]')\n    operands=($(echo \"${operands[@]}\" |tr '[:upper:]'\
    \ '[:lower:]'))\n    \n    if [[ $operator == -* ]]; then\n        echo \"$operands[0]$operands[1]\"\
    \n    else\n        echo \"$operands[0]$operator$operands[1]\"\n    fi", "   \
    \ operator=$1\n    operand=$2\n    operator=${operator//[,]/}\n    operator=${operator//+/}\n\
    \    operand=${operand//[,]/}\n    operand=${operand//+/}\n    echo \"$operator\"\
    \n    eval \"$operator\" \"$operand\"", "  local operator operand\n  operator=$1\n\
    \  operand=$2\n  local result=$(( ${operand[0]} ${operator[0]} ${operand[1]} ))\n\
    \  while [ $(( $# % 2 )) -ge 1 ]; do\n    operator=$1\n    operand=$2\n    result=$((\
    \ ${operand[0]} ${operator[0]} ${operand[1]} ))\n  done\n  echo \"${result}\"",
  "    local OP=(\"$1\")\n    local OP_N=(\"${#OP[@]}\")\n    local OP_N_M=(\"${OP_N}\"\
    )\n    local OP_N_M_OP=(\"${OP_N_M}\")\n    local OP_N_M_OP_J=(\"${OP_N_M_OP}\"\
    )\n    local OP_N_M_OP_J_T=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T2=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T3=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T4=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T5=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T6=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T7=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T8=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T9=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T10=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T11=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T12=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T13=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T14=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T15=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T16=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T17=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T18=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T19=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T20=(\"\
    ${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J_T21=(\"${OP_N_M_OP_J}\")\n    local OP_N_M_OP_J",
  "    local op=$1\n    local arr=$2\n    local res=$(echo \"${arr[@]} ${op} ${arr[@]}\"\
    )\n    echo \"${res}\"", "  operator=$1\n  operand=$2\n  result=0\n  while read\
    \ -r line ; do\n    if [ \"$line\" = \"+\" ] ; then\n      result=$(( $result\
    \ + $operand ))\n    elif [ \"$line\" = \"-\" ] ; then\n      result=$(( $result\
    \ - $operand ))\n    elif [ \"$line\" = \"*\" ] ; then\n      result=$(( $result\
    \ * $operand ))\n    elif [ \"$line\" = \"//\" ] ; then\n      result=$(( $result\
    \ // $operand ))\n    elif [ \"$line\" = \"**\" ] ; then\n      result=$(( $result\
    \ ** $operand ))\n    elif [ \"$line\" = \"$operator\" ] ; then\n      result=$((\
    \ $result $operator $operand ))\n    elif [ \"$line\" -gt \"0\" ] ; then\n   \
    \   result=$(( $result $operand ))\n    else\n      echo \"Not a valid operator\"\
    \n      exit 1\n    fi\n  done\n  echo \"$result\"", "    operator=$1\n    operand=$2\n\
    \n    op_count=${#operator[@]}\n    op_element=${operator[*]}\n    op_element1=${operator[-1*op_count]}\n\
    \    op_element2=${operator[-1*op_count+1]}\n\n    op_op1=\"${op_element1}${op_element}\"\
    \n    op_op2=\"${op_element2}${op_element}\"\n\n    echo \"$op_count\"\n\n   \
    \ eval_expression=\"${op_op1}${operand}${op_op2}\"\n    echo \"$eval_expression\"",
  "    echo \"$1 $2\"\n    local op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op op op op op op op op\
    \ op op op op op op op op op op op op op op op op op op op ", "    operator=${1//+/\
    \ }\n    operator=${1//-/ }\n    operator=${1//*/  }\n    operator=${1////  }\n\
    \    operator=${1//**/ }\n    operator=${1//% }\n    operand1=${2//+/ }\n    operand2=${2//-/\
    \ }\n    operand2=${2//*/  }\n    operand2=${2////  }\n    operand2=${2//**/ }\n\
    \    operand2=${2//% }\n    evalExpression=\"${operand1}${operator}${operand2}\"\
    \n    evalExpression=${evalExpression//%/ }\n    evalExpression=${evalExpression////\
    \ }\n    evalExpression=${evalExpression//+/ }\n    evalExpression=${evalExpression//-/\
    \ }\n    evalExpression=${evalExpression//*/ }\n    evalExpression=${evalExpression////\
    \  }\n    evalExpression=${evalExpression//**/ }\n    evalExpression=${evalExpression//%\
    \ }\n    evalExpression=${evalExpression/// }\n    evalExpression=${evalExpression////\
    \  }\n    evalExpression=${evalExpression//* }\n    evalExpression=${evalExpression////\
    \ }\n    evalExpression=${evalExpression//% }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//// }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//* }\n    evalExpression=${evalExpression///\
    \ }\n    evalExpression=${evalExpression//** }\n    evalExpression=${evalExpression////\
    \ }\n    evalExpression=${evalExpression//** }\n    evalExpression=${evalExpression//*\
    \ }\n    evalExpression=${evalExpression/// }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//// }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//* }\n    evalExpression=${evalExpression///\
    \ }\n    evalExpression=${evalExpression//** }\n    evalExpression=${evalExpression////\
    \ }\n    evalExpression=${evalExpression//** }\n    evalExpression=${evalExpression//*\
    \ }\n    evalExpression=${evalExpression/// }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//// }\n    evalExpression=${evalExpression//**\
    \ }\n    evalExpression=${evalExpression//* }\n    evalExpression=${evalExpression///\
    \ }\n    evalExpression=${evalExpression", "    local operator operand\n    operator=$1\n\
    \    operand=$2\n    eval expr=$( echo $operator \"( \" $operand \" )\"  )\n \
    \   echo $expr", "    operator=$1\n    operand=$2\n    result=0\n    while ((\
    \ \"$#\" )); do\n        operator=${operator%+*}\n        operand=${operand%+*}\n\
    \        (( result = $result + $operand $operator ))\n    done\n    echo $result",
  "  local operator operand result\n  for (( i=0; i<${#1}; i++ )); do\n    operator=${1}[i]\n\
    \    operand=${2}[i]\n    case \"$operator\" in\n      '+'|'+')\n        result=$((\
    \ ${result} + ${operand} ))\n        ;;\n      '-'|'-')\n        result=$(( ${result}\
    \ - ${operand} ))\n        ;;\n      '*'|'*')\n        result=$(( ${result} *\
    \ ${operand} ))\n        ;;\n      '/'|'/')\n        result=$(( ${result} / ${operand}\
    \ ))\n        ;;\n      '**'|'**')\n        result=$(( ${result} ** ${operand}\
    \ ))\n        ;;\n    esac\n  done\n  echo \"${result}\"", "\tlocal OPERATOR=$1\n\
    \tlocal OPERAND=$2\n\tlocal EXPRESSION=\"\"\n\tlocal OPERATOR_EXPRESSION=\"\"\n\
    \tlocal RESULT_EXPRESSION=\"\"\n\tlocal RESULT=0\n\tlocal PRECISION=0\n\tlocal\
    \ EXIT_CODE=0\n\n\twhile [ $# -gt 1 ]; do\n\t\tif [ \"$1\" == \"--\" ] || [ \"\
    $1\" == \"-\" ]; then\n\t\t\t# We are at the end of this argument\n\t\t\tbreak\n\
    \t\telse\n\t\t\tshift\n\t\tfi\n\tdone\n\t# Strip off the -- flag if present.\n\
    \tif [[ $1 == \"--\" ]]; then\n\t\tshift\n\tfi\n\n\twhile [ -n \"$1\" ]; do\n\t\
    \tcase \"$1\" in\n\t\t\t-)\n\t\t\t\tcase $OPERATOR in\n\t\t\t\t\t+)\n\t\t\t\t\t\
    \tOPERATOR=$OPERATOR\n\t\t\t\t\t\tOPERAND=$(( $OPERAND + ( ${OPERAND:2} )))\n\t\
    \t\t\t\t\t;;\n\t\t\t\t\t-)\n\t\t\t\t\t\tOPERATOR=$OPERATOR\n\t\t\t\t\t\tOPERAND=$((\
    \ $OPERAND - ${OPERAND:2} ))\n\t\t\t\t\t\t;;\n\t\t\t\t\t*)\n\t\t\t\t\t\tOPERATOR=$OPERATOR\n\
    \t\t\t\t\t\tOPERAND=$(( $OPERAND * ${OPERAND:2} ))\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\
    \t\t\t\t;;\n\t\t\t*)\n\t\t\t\t# We are at an operand\n\t\t\t\tcase $OPERATOR in\n\
    \t\t\t\t\t+)\n\t\t\t\t\t\tOPERATOR=$OPERATOR\n\t\t\t\t\t\tOPERAND=$(( $OPERAND\
    \ + ${OPERAND:1} ))\n\t\t\t\t\t\t;;\n\t\t\t\t\t-)\n\t\t\t\t\t\tOPERATOR=$OPERATOR\n\
    \t\t\t\t\t\tOPERAND=$(( $OPERAND ${OPERAND:1} ))\n\t\t\t\t\t\t;;\n\t\t\t\t\t*)\n\
    \t\t\t\t\t\tOPERATOR=$OPERATOR\n\t\t\t\t\t\tOPERAND=$(( $OPERAND * ${OPERAND:1}\
    \ ))\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\t\
    # Strip off trailing operand\n\tOPERAND=$1\n\t\n\tcase ${OPERAND:0:1} in\n\t\t\
    - | +)\n\t\t\tEXPRESSION=\"( $EXPRESSION + ${OPERAND:2} )\";;\n\t\t*)\n\t\t\t\
    EXPRESSION=\"( $EXPRESSION * ${OPERAND:2} )\";;\n\tesac\n\n\twhile [ $# -gt 1\
    \ ]; do\n\t\tif [ \"$1\" == \"--\" ] || [ \"$1\" == \"-\" ]; then\n\t\t\t# We\
    \ are at the end of this argument\n\t\t\tbreak\n\t\telse\n\t\t\tshift\n\t\tfi\n\
    \tdone\n\t# Strip off the -- flag if present.\n\tif [[ $1 == \"--\" ]]; then",
  "  operator=$1\n  operand=$2\n\n  len=$(( ${#operator} - 1 ))\n\n  if [[ ${#operand}\
    \ -le $len ]] ; then\n    for (( i = 1; i <= ${#operand}; i++ )); do\n      result=`eval\
    \ echo \"${operand[i-1]} ${operator[i-1]} ${operand[i]}\"`\n      echo \"$result\"\
    \n    done\n  else\n    echo \"Invalid Arguments: Operand list length is too short.\"\
    \n  fi", "  local operator=$1\n  local operands=$2\n  local result=$(do_eval \"\
    ${operands[*]}\" \"$operator\")\n  echo $result", "\tlocal OPERATOR=$1\n\tlocal\
    \ ARR=$2\n\tlocal RESULT=\"\"\n\tlocal OPT=\"\"\n\n\tif [[ ${#ARR} -eq ${#OPERATOR}\
    \ ]] ; then\n\t\tfor (( i=0; i<${#ARR[@]}; i++ ))\n\t\tdo\n\t\t\tOPT=\"${OPT}\
    \ ${ARR[$i]}\"\n\t\t\tRESULT=$((${ARR[$i]} ${OPERATOR} ${ARR[$((i+1))]}))\n\t\t\
    done\n\t\techo \"${OPT} ${RESULT}\"\n\telse\n\t\techo \"ERROR: Operand and Operator\
    \ are not the same length\"\n\t\texit 1\n\tfi", "  local -n operator=$1\n  local\
    \ -n operand=$2\n  local -n result\n  local -n result2\n  local -n result3\n \
    \ result=$((operand[0]+operand[1]))\n  result2=$((operand[0]*operand[1]))\n  result3=$((operand[0]/operand[1]))\n\
    \  result=$((result+result2+result3))", "  local operator operand\n  operator=$1\n\
    \  operand=$2\n  if [[ $operand == *[!0-9]* ]]; then\n    echo \"Invalid operand.\"\
    \n    return\n  fi\n  if [[ -z ${operator}* ]]; then\n    echo \"Invalid operator.\"\
    \n    return\n  fi\n  result=\n  for i in ${operand}\n  do\n    case $operator\
    \ in\n      \"+\")\n        result=`expr $result + $i`\n        ;;\n      \"-\"\
    )\n        result=`expr $result - $i`\n        ;;\n      \"*\")\n        result=`expr\
    \ $result * $i`\n        ;;\n      \"/\")\n        result=`expr $result // $i`\n\
    \        ;;\n      \"**\")\n        result=`expr $result ** $i`\n        ;;\n\
    \    esac\n  done\n  echo -n \"result = ${result}\"", "  operator=$1\n  operand=$2\n\
    \  # If operator = ['+', '-', '*', '/', '//', '**'], then\n  # result = eval($1)\
    \ + eval($2) * eval($3) * eval($4) / eval($5) ** eval($6)\n  # Otherwise, raise\
    \ error.\n  operator=${operator[@]}\n  if [[ ${#operator[@]} -ne ${#operand[@]}\
    \ ]]; then\n    echo \"Wrong number of arguments.\"\n    exit 1\n  fi\n  for ((i=0;\
    \ i<${#operand[@]}; i++))\n  do\n    case \"${operand[$i]}\" in\n      \"+\")\n\
    \        eval \"result=${result}${operator[$i]}${operand[$(($i + 1))]}\"\n   \
    \     ;;\n      \"-\")\n        eval \"result=${result}${operator[$i]}${operand[$(($i\
    \ - 1))]}\"\n        ;;\n      \"*\")\n        eval \"result=${result}${operator[$i]}${operand[$i]}\"\
    \n        ;;\n      \"/\")\n        eval \"result=${result}${operand[$((i - 1))]}${operator[$i]}${operand[$i]}\"\
    \n        ;;\n      \"//\")\n        eval \"result=${result}${operand[$((i - 1))]}${operator[$i]}${operand[$i]}\"\
    \n        ;;\n      \"**\")\n        eval \"result=${result}${operator[$i]}${operand[$i]}\"\
    \n        ;;\n      *)\n        echo \"Operator must be one of +, -, *, /, //,\
    \ **.\"\n        exit 1\n        ;;\n    esac\n  done", "    # Your code goes\
    \ here\n    operator=$1\n    operand=$2\n    total=0\n    for ((i=0;i<${#operator[@]};++i))\n\
    \    do\n        if [[ ${operator[i]} == \"+\" ]]; then\n            total=$(($total\
    \ + ${operand[i]}))\n        elif [[ ${operator[i]} == \"-\" ]]; then\n      \
    \      total=$(($total - ${operand[i]}))\n        elif [[ ${operator[i]} == \"\
    *\" ]]; then\n            total=$(($total * ${operand[i]}))\n        elif [[ ${operator[i]}\
    \ == \"//\" ]]; then\n            total=$(($total / ${operand[i]}))\n        elif\
    \ [[ ${operator[i]} == \"**\" ]]; then\n            total=$(($total ** ${operand[i]}))\n\
    \        else\n            echo \"Invalid Operator for Algebra Expression\"\n\
    \        fi\n    done\n    echo \"$total\"", "\tlocal operator operand\n\tlocal\
    \ result\n\tlocal i j\n\tlocal OP\n\tlocal operand0\n\tlocal operand1\n\tlocal\
    \ op1\n\tlocal op2\n\t\n\tIFS=$'\\n'\n\toperator=$1\n\toperand=$2\n\n\tlocal OP=(\"\
    $operator\")\n\t\n\ti=${#OP[@]}\n\tj=${#operand[@]}\n\t\n\tif (( i != j )) ; then\n\
    \t\techo \"Invalid operand length for operator $operator\"\n\t\treturn 0\n\tfi\n\
    \t\n\toperand0=${operand[$(( j - 1 ))]}\n\toperand1=${operand[$(( j - 1 ))]}\n\
    \t\n\tresult=0\n\t\n\tfor (( k = 0; k <= i; k++ )) ;do\n\t\t\n\t\tOP=${OP[$k]}\n\
    \t\top1=${OP}\n\t\top2=${OP}\n\t\t\n\t\tif (( k > 0 )) ;then \n\t\t\top1=${OP}${operand[$((\
    \ k - 1 ))]}\n\t\tfi\n\t\t\n\t\tif (( k > 1 )) ;then \n\t\t\top2=${OP}${operand[$((\
    \ k - 2 ))]}\n\t\tfi\n\n\t\t(( result += eval \"$op1\" \"$op2\" ))\n\t\t\n\tdone\n\
    \t\n\techo \"$result\"\n\t\n\treturn $result", "    operator=$1\n    operand=$2\n\
    \    operator_count=$((${#operator[@]} - 1))\n    operand_count=$((${#operand[@]}\
    \ - 1))\n    if [[ \"$operand_count\" -eq \"$operator_count\" ]]\n    then\n \
    \       echo \"ERROR\"\n        echo \"Operand list is too short\"\n        echo\
    \ \"Operand list: $operand_count\"\n        echo \"Operator list: $operator_count\"\
    \n    else\n        eval \"result=${operand[0]} ${operator[0]} ${operand[1]}\"\
    \n        echo \"$result\"\n    fi", "  local operator operand\n\n  operator=$1\n\
    \  operand=$2\n\n  declare -a expression\n\n  # First we must convert the operands\
    \ to expressions\n  for operand in $operand; do\n    expression+=($operand)\n\
    \  done\n  echo ${expression[@]}\n\n  # Then we must convert the operator to algebraic\
    \ expressions\n  expression=(0)\n  while [ ${#expression[@]} -ge 1 ]; do\n   \
    \ if [ ${expression[0]} -eq 0 ]; then\n      expression+=(\"1\")\n    elif [[\
    \ $((${expression[0]} * ${expression[0]})) = ${expression[0]} ]]; then\n     \
    \ expression+=(${expression[0]})\n    else\n      expression+=(${expression[0]}\
    \ ${operator} 0)\n    fi\n  done\n  echo ${expression[@]}", "  local operator=\"\
    $1\"\n  local operand=\"$2\"\n  \n  local result=\"$( eval \"${operator}${operand}\"\
    \ )\"\n  \n  echo \"${result}\"", "\tOPERATOR=$1\n\tOPERAND=$2\n\techo \"$OPERATOR\"\
    \n\techo \"$OPERAND\"\n\t\n\tRESULT=\n\tfor (( i = 1; i <= ${#OPERAND}; i++ ));\
    \ do\n\t\tlet \"RESULT = RESULT + ${OPERAND[$i - 1]}\"\n\tdone\n\n\techo \"$RESULT\"",
  "    local op_expr=\"$1\"\n    local op_nums=\"$2\"\n    local result=0\n    local\
    \ operator\n    local operand\n    local op_num\n    local op\n    local i\n \
    \   local j\n    local k\n    for (( i=0; i<${#op_expr}; i++ )); do\n        operator=${op_expr:$i:1}\n\
    \        operand=${op_nums:$i:1}\n        (( ${#op_expr} == ${#op_nums} )) &&\
    \ break\n        for (( j=0; j<${#op_nums}; j++ )); do\n            (( ${#op_nums}\
    \ == ${#operand} )) && break\n            op_num=${op_nums:$j:1}\n           \
    \ (( ${#op_expr} == ${#operand} )) && break\n            op_num=$(echo ${op_num}*$((\
    \ ${#op_expr} - ${#operand} ))) \n            op_expr=$(echo ${op_expr}${operator}${op_num})\n\
    \        done\n        result=$(( ${result} + $op_num ))\n    done\n    echo $result",
  "  local result=$1\n  local operator=$2\n  local operand=$3\n\n  (( $# >= 3 )) &&\
    \ { echo \"Arguments error\"; return 1; }\n\n  local i=0\n  local j=0\n  local\
    \ len1=$((${#operand} - 1))\n  local len2=$((${#operator} - 1))\n\n  while [ $i\
    \ -lt $len1 ]; do\n    eval \"result=$result${operator[$j]}${operand[$i]}\"\n\
    \    (( i = i + 1 ))\n    (( j = j + 1 ))\n  done\n\n  (( len2 = len2 - 1 ))\n\
    \n  if [ $len1 -gt 1 ] && [ $len2 -eq 0 ]; then\n    (( len1 = len1 - 1 ))\n \
    \ fi\n\n  while [ $j -lt $len2 ]; do\n    eval \"result=$result${operator[$j]}${operand[$len1]}\"\
    \n    (( j = j + 1 ))\n    (( len1 = len1 - 1 ))\n  done\n\n  echo \"$result\"",
  "    local operator operand result\n    operator=$(echo \"$1\" | tr -d '[:space:]')\n\
    \    operand=$(echo \"$2\" | tr -d '[:space:]')\n    result=$(echo \"$operand\"\
    \ | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n\
    \    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo\
    \ \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d\
    \ '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval\
    \ result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\"\
    \ | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n\
    \    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo\
    \ \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d\
    \ '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval\
    \ result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\"\
    \ | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n\
    \    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo\
    \ \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d\
    \ '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval\
    \ result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\"\
    \ | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n\
    \    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval result=$(echo\
    \ \"$result\" | tr -d '[:space:]')\n    eval result=$(echo \"$result\" | tr -d\
    \ '[:space:]')\n    eval result=$(echo \"$result\" | tr -d '[:space:]')\n    eval\
    \ result=$(echo \"$result\" | tr -d '[:space:]')\n", "\tlocal operator=\"$1\"\n\
    \tlocal operand=\"$2\"\n\tlocal eval\n\tlocal result\n\n\t# Check to make sure\
    \ that the operator list has at least one operator, and that \n\t# the operand\
    \ list has at least two operands.\n\tif [ ${#operator[*]} -eq 0 ]; then\n\t\t\
    echo \"No operands found.\" 1>&2\n\t\treturn\n\tfi\n\tif [ ${#operand[*]} -eq\
    \ 0 ]; then\n\t\techo \"No operator found.\" 1>&2\n\t\treturn\n\tfi\n\n\t# Construct\
    \ the list of operations to perform.\n\teval=\"((${#operand[*]} > 1)\"\n\tfor\
    \ ((i = 0; i < ${#operand[*]}; i++)); do\n\t\teval=\"${eval}${operator[$((i%${#operator[*]}))]}\
    \ ${operand[i]}\"\n\t\tif [ $((i%${#operator[*]})) -eq 0 ]; then\n\t\t\teval=\"\
    ${eval})\"\n\t\tfi\n\tdone\n\teval=${eval:0:$((${#operand[*]}-1))}\n\teval=\"\
    $eval\"\n\n\t# Compute the result of the algebraic expression.\n\tresult=$(eval\
    \ \"$eval\")\n\techo \"${result}\"", "    local operation=\"$1\"\n    local operand=\"\
    $2\"\n    local result=\"$(eval \"echo $( $operation $operand )\")\"\n    echo\
    \ \"$result\"", "\tlocal OP=\"${1}\"\n\tlocal OPARG=\"${2}\"\n\tlocal OPARG=\"\
    ${OPARG%,*}\"\n\tlocal OPARG=\"${OPARG#*,}\"\n\tOP=\"${OP%,*}\"\n\tlocal OPARG_ARRAY=(${OPARG//,/\
    \ })\n\tlocal OPARG_ARRAY_SIZE=${#OPARG_ARRAY[@]}\n\tlocal OPARG_LIST=(${OPARG_ARRAY[@]})\n\
    \tlocal OPARG_LIST_SIZE=${#OPARG_LIST[@]}\n\tlocal OPARG_LIST_SEPARATOR=\",\"\n\
    \tlocal OPERATION=\"${OP%,*}\"\n\tlocal OPERATION_ARRAY=(${OPERATION//,/ })\n\t\
    local OPERATION_ARRAY_SIZE=${#OPERATION_ARRAY[@]}\n\tlocal OPERATION_LIST=(${OPERATION_ARRAY[@]})\n\
    \tlocal OPERATION_LIST_SIZE=${#OPERATION_LIST[@]}\n\tlocal OPERATION_LIST_SEPARATOR=\"\
    ,\"\n\tlocal OPERATION_TITLE=\"Arithmetic Operation\"\n\tlocal OPERATION_TITLE_SHORT=\"\
    Arithmetic Operation\"\n\tlocal OPERATION_TITLE_FULL=\"Arithmetic Operation\"\n\
    \tlocal OPERATION_TITLE_COMPLEX=\"Arithmetic Operation\"\n\tlocal OPERATION_RESULT=\"\
    \"\n\tlocal ARG_ARRAY=(${OPARG_LIST_SEPARATOR}\"${OPARG_LIST[@]}\")\n\tlocal ARG_ARRAY_SIZE=${#ARG_ARRAY[@]}\n\
    \tlocal ARG_LIST=(${ARG_ARRAY[@]})\n\tlocal ARG_LIST_SIZE=${#ARG_LIST[@]}\n\t\
    local ARG_LIST_SEPARATOR=\",\"\n\tlocal ARG_LIST_LAST=\"${ARG_LIST[${ARG_LIST_SIZE}-1]}\"\
    \n\tlocal ARG_LIST_ALL=\"${ARG_LIST}\"\n\tlocal OPERATION_OPERAND=\"X\"\n\tlocal\
    \ OPERATION_OPERAND2=\"Y\"\n\tlocal OPERATION_OPERAND3=\"Z\"\n\tlocal OPERATION_CURRENT_OPERAND=\"\
    \"\n\tlocal OPERATION_CURRENT_OPERAND2=\"\"\n\tlocal OPERATION_CURRENT_OPERAND3=\"\
    \"\n\tlocal OPERATION_CURRENT_OPERAND_ARRAY=(${OPERATION_OPERAND//,/ })\n\tlocal\
    \ OPERATION_CURRENT_OPERAND_ARRAY_SIZE=${#OPERATION_CURRENT_OPERAND_ARRAY[@]}\n\
    \tlocal OPERATION_CURRENT_OPERAND_LIST=(${OPERATION", "    local operator=$1\n\
    \    local operand=$2\n    local result=0\n    local op1=\n    local op2=\n  \
    \  local i=1\n    while [ $i -lt ${#operand} ]; do\n        if [ \"${operand[$i]}\"\
    \ == \"-\" ]; then\n            op1=${operand[$(i-1)]}\n            op2=${operand[$i]}\n\
    \            result=$((${result} - ${op1} - ${op2}))\n        fi\n        ((i++))\n\
    \    done\n    if [ \"${operator}\" == \"+\" ]; then\n        result=$((${result}\
    \ + ${operand[0]}))\n    elif [ \"${operator}\" == \"-\" ]; then\n        result=$((${result}\
    \ - ${operand[0]}))\n    elif [ \"${operator}\" == \"*\" ]; then\n        result=$((${result}\
    \ * ${operand[0]}))\n    elif [ \"${operator}\" == \"//\" ]; then\n        result=$((${result}\
    \ / ${operand[0]}))\n    elif [ \"${operator}\" == \"**\" ]; then\n        result=$((${result}\
    \ ** ${operand[0]}))\n    fi\n    echo \"${result}\"", "    local op_list op_count\
    \ result operator operand result\n    IFS=\" \" read -r -a op_list <<< \"$1\"\n\
    \    IFS=\" \" read -r -a operand <<< \"$2\"\n    result=\n    for (( op_count=0;\
    \ op_count < \"${#op_list[@]}\"; op_count++ )); do\n        operator=${op_list[op_count]}\n\
    \        operand=${operand[op_count]}\n        case \"$operator\" in\n       \
    \     \"+\" ) result=$(( ${result} + ${operand} )) ;;\n            \"-\" ) result=$((\
    \ ${result} - ${operand} )) ;;\n            \"*\" ) result=$(( ${result} + ${operand}\
    \ )) ;;\n            \"/\" ) result=$(( ${result} / ${operand} )) ;;\n       \
    \     \"//\" ) result=$(( ${result} / ${operand} )) ;;\n            \"**\" ) result=$((\
    \ ${result} ** ${operand} )) ;;\n        esac\n    done\n    echo ${result}",
  "    local operator=$1\n    local operand=$2\n    local result\n\n    for (( i=0;\
    \ i<${#operator[@]}; i++ )); do\n        case \"${operator[$i]}\" in\n       \
    \     *) result=$(( ${result} + ${operand[$i]} ));;\n        esac\n    done\n\
    \    echo \"$result\"", "    echo \"$1\" \"$2\" | sort | while read op operand;\
    \ do\n        case \"$op\" in\n            \"+\"|\"+\") echo \"$operand + $operand\"\
    \ ;;\n            \"-\"|\"-\") echo \"$operand - $operand\" ;;\n            \"\
    *\"|\"*\") echo \"$operand * $operand\" ;;\n            \"//\"|\"//\") echo \"\
    $operand / $operand\" ;;\n            \"**\"|\"**\") echo \"$operand ** $operand\"\
    \ ;;\n            *) echo \"$op $operand\" ;;\n        esac\n    done", "\tlocal\
    \ operator=$1\n\tlocal operand=$2\n\tlocal result\n\tlocal op\n\tlocal i\n\tlocal\
    \ len\n\t# First we get length of operator list.\n\tlen=${#operator[@]}\n\t# Make\
    \ sure length is greater than zero.\n\tif [ ${#operand[@]} -lt 2 ] || [ \"${operand[1]}\"\
    \ == \"\" ]; then\n\t\techo \"ERROR: operand list has less than two operands.\
    \ Usage: do_algebra operator operand\" >&2\n\t\texit 1\n\tfi\n\t# Make sure length\
    \ of operator list is equal to the length of operand list minus one.\n\tif [ ${#operator[@]}\
    \ -ne ${#operand[@]} ]; then\n\t\techo \"ERROR: length of operator list does not\
    \ equal length of operand list.\" >&2\n\t\texit 1\n\tfi\n\t# Make sure there are\
    \ enough operands.\n\tif [ \"${#operand[@]}\" -lt 2 ]; then\n\t\techo \"ERROR:\
    \ Not enough operands. Usage: do_algebra operator operand\" >&2\n\t\texit 1\n\t\
    fi\n\t# Make sure each operand is non-negative integer.\n\tfor ((i=1;i<${#operand[@]};i++));\
    \ do\n\t\tif [ \"${operand[i]}\" -eq 0 ] || [ \"${operand[i]}\" -gt 0 ]; then\n\
    \t\t\techo \"ERROR: operand is not an integer: ${operand[i]}\" >&2\n\t\t\texit\
    \ 1\n\t\tfi\n\tdone\n\t# Make sure each operator is non-negative integer.\n\t\
    for ((i=1;i<${#operator[@]};i++)); do\n\t\tif [ \"${operator[i]}\" -eq 0 ] ||\
    \ [ \"${operator[i]}\" -gt 0 ]; then\n\t\t\techo \"ERROR: operator is not an integer:\
    \ ${operator[i]}\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\t# Build expression and\
    \ return it.\n\top=\"\"\n\tfor ((i=0;i<${#operator[@]};i++)); do\n\t\top=\"${op}${operator[i]}${operand[i]}\"\
    \n\tdone\n\tresult=$(eval \"$op\")\n\techo \"${result}\"", "    local operator=\"\
    $1\"\n    local operand=\"$2\"\n    # initialize result to zero\n    local result=\"\
    0\"\n    # initialize variable a\n    local a=\"1\"\n    # initialize variable\
    \ b\n    local b=\"1\"\n    while [ $b -le ${#operand} ]; do\n        # if the\
    \ second operand (the one on the right of the operator) is even,\n        # it\
    \ is the operand, so break the loop\n        if [ $(b % 2) -eq 0 ]; then\n   \
    \         break\n        fi\n        # if the second operand (the one on the right\
    \ of the operator) is not even,\n        # and the first operand is not even,\
    \ the second operand is even.\n        # So add it to the result\n        if [\
    \ $(b % 2) -eq 0 ] && [ $(a%2) -ne 0 ]; then\n            result=\"$result${operand[$b]}\"\
    \n        # if the second operand (the one on the right of the operator) is not\
    \ even,\n        # and the first operand is even, the second operand is not even.\n\
    \        # So subtract it from the result\n        elif [ $(b % 2) -eq 0 ] &&\
    \ [ $(a%2) -eq 0 ]; then\n            result=\"$result${operand[$b]}\"\n     \
    \   # if the second operand (the one on the right of the operator) is even,\n\
    \        # and the first operand is even, the second operand is even.\n      \
    \  # So multiply it by the result\n        elif [ $(b % 2) -eq 0 ] && [ $(a%2)\
    \ -eq 0 ]; then\n            result=\"$result${operand[$b]}\"\n        # if the\
    \ second operand (the one on the right of the operator) is even,\n        # and\
    \ the first operand is not even, the second operand is not even.\n        # So\
    \ divide it by the result\n        elif [ $(b % 2) -eq 0 ] && [ $(a%2) -ne 0 ];\
    \ then\n            result=\"$result${operand[$b]}\"\n        # if the second\
    \ operand (the one on the right of the operator) is not even,\n        # and the\
    \ first operand is even, the second operand is even.\n        # So floor divide\
    \ it by the result\n        elif [ $(b % 2) -eq 0 ] && [ $(a%2) -eq 0 ]; then\n\
    \            result=\"$result${operand[$b]}\"\n        # if the second operand\
    \ (the one on the right of the operator) is not even,\n        # and the first\
    \ operand is not even, the second operand is even.\n        # So exponentiate\
    \ it by the result\n        elif [ $(b % 2) -eq 0 ] && [ $(a%2) -ne 0 ]; then\n\
    \            result=\"$result${operand[$b]}\"\n        # if the second operand\
    \ (the one on the right of the operator) is even,\n        # and the first operand\
    \ is not even, the ", "  local operand operator result\n  operand=( ${2//,/ }\
    \ )\n  operator=( ${1//,/ } )\n  if [ \"$#\" -lt \"2\" ]; then\n    echo Usage:\
    \ $0 \"OPLIST1 OPLIST2\" 1>&2\n    exit 1\n  fi\n  case ${#operand[*]} in\n  \
    \  0)\n      echo Usage: $0 \"OPLIST1 OPLIST2\" 1>&2\n      exit 1\n      ;;\n\
    \    1)\n      echo usage: $0 \"OPLIST1 OPLIST2\" 1>&2\n      exit 1\n      ;;\n\
    \    2)\n      result=$((${operand[0]} ${operator[0]}))\n      ;;\n    3)\n  \
    \    result=$((${operand[0]} ${operator[0]} ${operand[1]} ))\n      ;;\n    4)\n\
    \      result=$((${operand[0]} ${operator[0]} ${operand[1]} ${operator[1]}))\n\
    \      ;;\n    5)\n      result=$((${operand[0]} ${operator[0]} ${operand[1]}\
    \ ${operator[1]} ${operand[2]}))\n      ;;\n    *)\n      result=$((${operand[0]}\
    \ ${operator[0]} ${operand[1]} ${operator[1]} ${operand[2]} ${operator[2]} ))\n\
    \      ;;\n  esac\n  echo \"${result}\"", "\tlocal operator operand\n\toperator=\"\
    $1\"\n\toperand=\"$2\"\n\toperator=\"$(echo \"$operator\" | sed -e 's/\\s*,\\\
    s*/+/g' -e 's/^\\s*/-/g' -e 's/\\s*$//g' -e '/^\\+$/d' -e 's/\\+//g')\"\n\toperand=\"\
    $(echo \"$operand\" | sed -e 's/\\s*,\\s*/+/g' -e 's/^\\s*/-/g' -e 's/\\s*$//g'\
    \ -e '/^\\+$/d' -e 's/\\+//g')\"\n\tresult=$(echo $operand | sed -e \"s/$operator/$operator/g\"\
    )\n\techo \"$result\"", "    operator=$1\n    operand=$2\n    result=\"\"\n  \
    \  for (( i=2; i <= ${#operand}; i++ ))\n    do\n        result=$(( ${result}\
    \ * ${operand[i]} ))\n    done\n    for (( i=${#operand}; i >= 2; i-- ))\n   \
    \ do\n        result=$(( ${result} ${operator[i]} ${operand[i-1]} ))\n    done\n\
    \    echo \"$result\"", "    local result=0\n    local i=0\n    local operator=$1\n\
    \    local operands=$2\n\n    for operator in ${operands}; do\n        i=$(( $i\
    \ + 1 ))\n        local operand=${operands:$i:1}\n        local op=${operator:$i:1}\n\
    \n        case \"${op}\" in\n            \"+\")\n                result=$(( ${result}\
    \ + ${operand} ))\n                ;;\n            \"-\")\n                result=$((\
    \ ${result} - ${operand} ))\n                ;;\n            \"*\")\n        \
    \        result=$(( ${result} + ${operand} ))\n                ;;\n          \
    \  \"/\")\n                result=$(( ${result} + ${operand} ))\n            \
    \    ;;\n            \"^\")\n                result=$(( ${result} + ${operand}\
    \ ))\n                ;;\n            \"<\")\n                result=$(( ${result}\
    \ + ${operand} ))\n                ;;\n            \"=\")\n                result=$((\
    \ ${result} + ${operand} ))\n                ;;\n            *)\n            \
    \    result=$(( ${result} + ${operand} ))\n                ;;\n        esac\n\
    \    done\n    echo \"${result}\"", "    local operator operand\n    operator=$1\n\
    \    operand=$2\n\n    # check if first operand is valid and second operand is\
    \ valid before proceeding\n    if [[ \"$operand\" =~ ^[0-9]+$ ]]; then\n     \
    \ operand=${operand#*([+,\\-,*,\\/,//,])}\n      operand=${operand%([+,\\-,*,\\\
    /,//,])}\n      if [ \"$operand\" -gt 0 ]\n      then\n        # check if the\
    \ operator is valid\n        if [[ \"$operator\" =~ ^[-+*/^]$ ]]; then\n     \
    \     operation=$operator\n          result=0\n          for i in $operand; do\n\
    \            # perform the operation\n            result=$((result+i))\n     \
    \     done\n          echo \"$operation $operand = $result\"\n        else\n \
    \         echo \"Operator $operator not recognized. Valid operators are ( + -\
    \ * / // )\";\n          exit 1;\n        fi\n      else\n        echo \"Operand\
    \ $operand is non-positive\";\n        exit 1;\n      fi\n    else\n      echo\
    \ \"Operand $operand is not an integer\";\n      exit 1;\n    fi", "  # Initialize\
    \ result variable\n  result=\"\"\n\n  # Validate input\n  local oplist=$1\n  local\
    \ oplist2=$2\n  local array=$3\n\n  if [ $# -lt 2 ] || [ $# -gt 3 ]; then\n  \
    \  echo \"Usage: do_algebra operator operand\"\n    return 1\n  fi\n  \n  if [\
    \ $(echo \"$oplist\" | wc -w) -eq 0 ]; then\n    echo \"ERROR: Please specify\
    \ an operator list\"\n    return 1\n  fi\n  if [ $(echo \"$oplist2\" | wc -w)\
    \ -eq 0 ]; then\n    echo \"ERROR: Please specify an operand list\"\n    return\
    \ 1\n  fi\n  \n  # Validate the operator\n  if [ $(echo \"$oplist\" | grep -c\
    \ \"+\") -eq 0 ]; then\n    echo \"ERROR: Please specify at least one operator\"\
    \n    return 1\n  fi\n\n  if [ $(echo \"$oplist2\" | grep -c \"+\") -eq 0 ]; then\n\
    \    echo \"ERROR: Please specify at least one operand\"\n    return 1\n  fi\n\
    \n  # Do the calculation\n  for i in $(seq 0 $(echo \"$#\" -2)); do\n    if [\
    \ $i -eq 0 ]; then\n      result=$(echo \"$array\" | bc | tr -d '.')\n    elif\
    \ [ $i -eq 1 ]; then\n      result=$(echo \"$array[$i-1]$oplist2[$i-1]\" | bc\
    \ | tr -d '.')\n    else\n      result=$(echo \"$array[$i-1]$oplist[$i-1]$oplist2[$i-1]\"\
    \ | bc | tr -d '.')\n    fi\n  done\n\n  echo $result", "        local op=$1\n\
    \        local arr=$2\n        local result\n        local i\n        local j\n\
    \        local count\n        local num\n        local op1\n        local op2\n\
    \        local op3\n        local op4\n        local op5\n        local op6\n\
    \        local op7\n        local op8\n        local op9\n\n        # initialize\
    \ result\n        result=0\n        for i in $(seq 0 $((${#arr[@]} - 1))); do\n\
    \                num=$((${arr[$i]}))\n                if [[ $num -gt 0 ]]; then\n\
    \                        count=0\n                        for j in $(seq 0 $((${#op[@]})));\
    \ do\n                                op1=${op[$j]}\n                        \
    \        op2=${arr[$((${#op[@]}) + ${i})]}\n                                if\
    \ [[ \"$op1\" == \"$op2\" ]]; then\n                                        count=$((${count}+1))\n\
    \                                        if [[ $count -eq 1 ]]; then\n       \
    \                                         result=$((${result}+${arr[$i]}))\n \
    \                                       fi\n                                fi\n\
    \                        done\n                fi\n        done\n        echo\
    \ \"$result\"", "    operator=$1\n    operand=$2\n    # Split operator\n    operators=$(echo\
    \ $operator | sed 's/ //g')\n    operands=$(echo $operand | sed 's/ //g')\n  \
    \  # Split operand list\n    operands=$(echo $operands | sed 's/,//g')\n    #\
    \ Determine number of operands\n    operandLength=$(echo $operands | wc -w)\n\
    \    if [[ $operandLength -eq 0 ]]; then\n        operandLength=1\n    fi\n  \
    \  # Determine number of operators\n    operatorLength=$(echo $operators | wc\
    \ -w)\n    if [[ $operatorLength -eq 0 ]]; then\n        operatorLength=1\n  \
    \  fi\n    operandLength=$((operandLength + 1))\n    operatorLength=$((operatorLength\
    \ + 1))\n    \n    operators=$($operators)\n    operands=$($operands)\n    \n\
    \    \n    # Build expression using loop\n    expression=\"\"\n    for ((i = 0;\
    \ i < operandLength; i++)); do\n        expression=$((expression + operands[i]))\n\
    \    done\n    \n    for ((i = 0; i < operatorLength; i++)); do\n        \n  \
    \      case \"$operators[i]\" in\n            +) result=$(($expression + $operands[i+1]))\n\
    \               ;;\n            -) result=$(($expression - $operands[i+1]))\n\
    \               ;;\n            *) result=$(($expression * $operands[i+1]))\n\
    \               ;;\n            /) result=$(($expression / $operands[i+1]))\n\
    \               ;;\n            ^) result=$(($expression ** $operands[i+1]))\n\
    \               ;;\n            *) echo \"Invalid operator\"\n               ;;\n\
    \        esac\n        expression=$((result))\n    done\n    \n    echo \"$expression\"",
  "    local operator=$1\n    local operand=$2\n    local result\n    \n    # Remove\
    \ spaces from the beginning and the end of the lists, and convert operand into\
    \ integer\n    local operators=$operator\n    local operands=$operand\n    local\
    \ operators_split=($operators)\n    local operands_split=($operands)\n    \n \
    \   if [ $# -eq 2 ]\n    then\n        result=0\n    else\n        result=1\n\
    \    fi\n    \n    # Iterate through operator list\n    for ((i=0; i<${#operators_split[@]};\
    \ i++)); do\n        local op=${operators_split[i]}\n        local op_index=$(echo\
    \ $i | cut -d '^' -f 1)\n        \n        if [[ ${operators[$i]} == -* ]]; then\n\
    \            # Multiplication operation is commutative, use the other operand.\n\
    \            local operand1=${operands_split[$op_index]}\n            local operand2=${operands_split[$((op_index+1))]}\n\
    \            local operand1_multiplied_by_operand2=$(echo \"$operand1 * $operand2\"\
    \ | bc)\n            \n            local result=\"${operand1_multiplied_by_operand2}\"\
    \n        else\n            # Other operations are associative, use the result\
    \ of the previous operation.\n            local operand1=${operands_split[$op_index]}\n\
    \            local operand2=${operands_split[$((op_index-1))]}\n            local\
    \ operand1_plus_operand2=$(echo \"$operand1 + $operand2\" | bc)\n            \n\
    \            local operand1_multiplied_by_operand2=$(echo \"$operand1 * $operand2\"\
    \ | bc)\n            local result=\"$((operand1_multiplied_by_operand2+operand1_plus_operand2))\"\
    \n        fi\n        \n        if [[ ${operators[$i]} == + ]]; then\n       \
    \     # Add operation is commutative, use the result of the previous operation.\n\
    \            result=\"${result}+\"\n        elif [[ ${operators[$i]} == - ]];\
    \ then\n            # Subtract operation is commutative, use the result of the\
    \ previous operation.\n            result=\"${result}-\"\n        elif [[ ${operators[$i]}\
    \ == * ]]; then\n            # Multiplication operation is commutative, use the\
    \ other operand.\n            result=\"${result}*${operands_split[$((op_index-1))]}\"\
    \n        elif [[ ${operators[$i]} == // ]]; then\n            # Floor division\
    \ operation is commutative, use the result of the previous operation.\n      \
    \      result=\"${result}/${operands_split[$((op_index-1))]}\"\n        elif [[\
    \ ${operators[$i]} == ** ]]; then\n            # Exponenti", "  local -a operator\
    \ operand\n  operator=( $1 )\n  operand=( $2 )\n\n  local -a result\n  local i\
    \ j\n\n  for ((i=0;i<${#operator[@]};i++)); do\n    if [[ ${operand[i]} -eq 0\
    \ ]]; then\n      result+=( ${operator[i]} )\n    else\n      if (( \"${operator[i]}\"\
    \ == \"+\" )); then\n        result+=( $operand[i] )\n      elif (( \"${operator[i]}\"\
    \ == \"-\" )); then\n        result+=( $(( $operand[i] )) )\n      elif (( \"\
    ${operator[i]}\" == \"*\" )); then\n        result+=( $(( $operand[i] * $operand[i+1]\
    \ )) )\n      elif (( \"${operator[i]}\" == \"//\" )); then\n        result+=(\
    \ $(( $operand[i] // $operand[i+1] )) )\n      else\n        result+=( $(( $operand[i]\
    \ ** $operand[i+1] )) )\n      fi\n    fi\n  done\n\n  echo ${result[@]}", " \
    \ local operator=$1\n  local operand=$2\n  \n  local result=0\n  \n  # loop through\
    \ operands until one is empty\n  for i in ${operand[@]}; do\n    # loop through\
    \ operators until one is empty\n    for j in ${operator[@]}; do\n      case \"\
    $j\" in\n        # Addition ( + ) \n        *)\n          result=$(( ${result}\
    \ + ${i} ))\n          ;;\n        # Subtraction ( - ) \n        -)\n        \
    \  result=$(( ${result} - ${i} ))\n          ;;\n        # Multiplication ( *\
    \ ) \n        *)\n          result=$(( ${result} + ${i} * ${i} ))\n          ;;\n\
    \        # Floor division ( // ) \n        *)\n          result=$(( ${result}\
    \ + ${i} ))\n          ;;\n        # Exponentiation ( ** ) \n        *)\n    \
    \      result=$(( ${result} + ${i} ** ${i} ))\n          ;;\n      esac\n    done\n\
    \  done\n  \n  echo \"$result\"", "  # Make sure lists are formatted correctly\
    \ - convert spaces to commas\n  local OPERATOR OPR1 OPR2 \n  local EXPRESSION\n\
    \  OPR1=$1\n  OPR2=$2\n  OPERATOR=$3\n  EXPRESSION=$(echo $OPR1 | sed 's/ /,/g'\
    \ | sed 's/^/\"$EXPRESSION = \"/' | sed 's/$/\"/')\n  for (( OPR1INDEX = 1; OPR1INDEX\
    \ < ${#OPR1}; OPR1INDEX++ )); do\n    if [ $OPR1INDEX -lt ${#OPR2} ]; then\n \
    \     EXPRESSION=\"$EXPRESSION$OPERATOR${OPR1[$OPR1INDEX]}\"\n    fi\n    OPERATOR=$((OPERATOR\
    \ + 1))\n  done\n  echo $EXPRESSION", "  # Parse operator and operand lists, separated\
    \ by whitespace\n  local operator operand\n  while IFS= read -r -n1 operator;\
    \ do\n    while IFS= read -r -n1 operand; do\n      # If operator and operand\
    \ lists end with the same element, use that element for evaluation\n      if [\
    \ \"$operand\" = \"$operand${operator#+}\" ]; then\n        result=\"$operand${operator#+}\"\
    \n      fi\n    done \n  done < <(printf \"$1\") < <(printf \"$2\")\n  printf\
    \ \"Result = %s\\n\" \"$result\"", "  local OPERATOR=$1\n  local OPER_LIST=$2\n\
    \  local OPER_ELEMENT\n  local OPER_OPERATOR\n  local OPERAND\n  local OPER_OPERAND\n\
    \  local RESULT\n\n  IFS=\" \"\n  OPER_ELEMENT=$( IFS=$'\\n'; echo $OPER_LIST\
    \ )\n  OPER_OPERATOR=$( IFS=$'\\n'; echo $OPERATOR )\n  OPER_OPERAND=$( IFS=$'\\\
    n'; echo $OPER_ELEMENT )\n\n  RESULT=$( IFS=$'\\n'; echo $OPER_OPERAND; echo \"\
    $OPER_OPERATOR\"; echo \"$OPER_OPERAND\" )\n  echo $RESULT", "\techo \"Enter expression\
    \ to be evaluated\"\n\tread expr\n\techo \"Enter two operands\"\n\tread op1 op2\n\
    \toperator=${1%/*}\n\tarray=$(awk '{for (i = 2; i <= NF; i++) printf \"%s \",\
    \ $i}'<<<\"$2\")\n\toperand=$(awk '{for (i = 2; i <= NF; i++) printf \"%s \",\
    \ $i}'<<<\"$1\")\n\toperand=\"${operand%/*}\"\n\tresult=\n\tfor i in $array\n\t\
    do\n\t\tif [ \"$i\" -eq \"$operand\" ]\n\t\tthen\n\t\t\tresult=$i\n\t\t\tbreak\n\
    \t\tfi\n\tdone\n\techo $(( $result ))", "  operator=$1\n  operands=$2\n  # If\
    \ the number of operands given is less than 3 or more than the length of the \n\
    \  # operator list, return an error \n  [[ \"$#\" -lt \"2\" ]] || [[ \"$#\" -gt\
    \ \"${#operator}\" ]] && return 1\n  # If the operand list is empty, return an\
    \ error\n  [[ -z \"$operands\" ]] && return 1\n  # If the operator list is empty,\
    \ return an error\n  [[ -z \"$operator\" ]] && return 1\n  # If the number of\
    \ operands is less than 2 return an error\n  [[ \"$#\" -lt \"3\" ]] && return\
    \ 1\n  # If the number of operands is greater than the number of operators in\
    \ the operator \n  # list, return an error\n  [[ \"$#\" -gt \"${#operator}\" ]]\
    \ && return 1\n  \n  # Initialize result to 0\n  result=0\n  # Loop through the\
    \ operand list, which contains all the operands\n  for i in $(seq 1 \"$#\"); do\n\
    \    # Parse the first operand as an integer\n    first=$(echo \"$operands\" |\
    \ cut -d \" \" -f $i)\n    # Parse the second operand as an integer\n    second=$(echo\
    \ \"$operands\" | cut -d \" \" -f $((i+1)))\n    # Parse the operator as an integer\n\
    \    operator=$(echo \"$operands\" | cut -d \" \" -f $((i+2)))\n    # Perform\
    \ the necessary operations\n    case \"$operator\" in\n      \"+\")\n        result=$((result+$first))\n\
    \        ;;\n      \"-\")\n        result=$((result-$first))\n        ;;\n   \
    \   \"*\")\n        result=$((result*$first))\n        ;;\n      \"/\")\n    \
    \    result=$((result/$first))\n        ;;\n      \"^\")\n        result=$((result**$first))\n\
    \        ;;\n      \"%\")\n        result=$((result%$first))\n        ;;\n   \
    \ esac\n  done\n  # Return the result\n  return $result", "    # Make sure that\
    \ two arguments are given.\n    if [ $# -eq 0 ]; then \n        echo \"No arguments\
    \ given. Usage: $0 operator operand\"; \n        return 1\n    fi\n    \n    #\
    \ Make sure that both parameters are lists of non-negative integers.\n    if [\
    \ ! -z \"$1\" ]; then \n        operator=$1; shift\n    fi\n    if [ ! -z \"$1\"\
    \ ]; then \n        operand=$1; shift\n    fi\n    \n    # Make sure that both\
    \ parameters are lists of non-negative integers.\n    if [ ! -z \"$operator\"\
    \ ] || [ ! -z \"$operand\" ]; then \n        echo \"Incorrect number of arguments.\
    \ Usage: $0 operator operand\"; \n        return 1\n    fi\n    \n    # Make sure\
    \ that at least one parameter is non-empty\n    if [ ! -z \"$operator\" ] && [\
    \ ! -z \"$operand\" ] && [ ! -z \"$operator\" ]; then \n        # Initialize sum\n\
    \        sum=0\n        # Iterate over each operand\n        for i in $operand;\
    \ do\n            # Perform the specified operation\n            case $operator\
    \ in\n                +)\n                    sum=$(($sum + $i));;\n         \
    \       -)\n                    sum=$(($sum - $i));;\n                *)\n   \
    \                 sum=$(($sum * $i));;\n                /)\n                 \
    \   sum=$(($sum / $i));;\n                **)\n                    sum=$(($sum\
    \ ** $i));;\n            esac\n        done\n        echo $sum\n    fi", "   \
    \ declare -a operator\n    operator=$(echo $1 | tr ' ' '\\n' | sort -u)\n    operand=$(echo\
    \ $2 | tr ' ' '\\n' | sort -u)\n    result=$(( ${operand[0]} ${operator[0]} ${operand[1]}\
    \ ))\n    for (( i=1; i < ${#operator[@]}; i++ ))\n    do\n        result=$((\
    \ ${result} ${operator[i]} ${operand[$(( $i - 1 ))]} ))\n    done\n    echo \"\
    ${result}\"", "    local operator=\"$1\"\n    local operand=\"$2\"\n    local\
    \ result=0\n    local j=0\n    while [ \"$j\" -lt \"$#\" ] && [ \"$j\" -ne \"\
    0\" ]; do\n        if [ \"$j\" -eq \"1\" ]; then\n            case \"$operator\"\
    \ in\n                '+'|'+') result=$(expr $result + $operand) ;;\n        \
    \        '-'|'-') result=$(expr $result - $operand) ;;\n                '*'|'*')\
    \ result=$(expr $result * $operand) ;;\n                '//'|'/') result=$(expr\
    \ $result / $operand) ;;\n                '**'|'') result=$(expr $result ** $operand)\
    \ ;;\n                *) echo \"invalid operator '$operator'\" ; exit 1 ;;\n \
    \           esac\n            j=$(( j + 1 ))\n        elif [ \"$j\" -eq \"2\"\
    \ ]; then\n            case \"$operator\" in\n                '+'|'-') operand=$(expr\
    \ $operand + $operand) ;;\n                '*'|'*') operand=$(expr $operand *\
    \ $operand) ;;\n                '//'|'/') operand=$(expr $operand / $operand)\
    \ ;;\n                '**'|'') operand=$(expr $operand ** $operand) ;;\n     \
    \           *) echo \"invalid operator '$operator'\" ; exit 1 ;;\n           \
    \ esac\n            j=$(( j + 1 ))\n        elif [ \"$j\" -eq \"$#\" ]; then\n\
    \            case \"$operator\" in\n                '+'|'+') operand=$(expr $operand\
    \ + $operand) ;;\n                '-'|'-') operand=$(expr $operand - $operand)\
    \ ;;\n                '*'|'*') operand=$(expr $operand * $operand) ;;\n      \
    \          '//'|'/') operand=$(expr $operand / $operand) ;;\n                '**'|'')\
    \ operand=$(expr $operand ** $operand) ;;\n                *) echo \"invalid operator\
    \ '$operator'\" ; exit 1 ;;\n            esac\n            echo $operand\n   \
    \         j=0\n        fi\n    done", "  # declare operator array\n  local operator\
    \ array=(\"${1}\")\n  # declare operand array\n  local operand array=(\"${2}\"\
    )\n  \n  local result=0\n  local operator_index=0\n  # traverse the operator array\n\
    \  while [ \"$operator_index\" -lt \"${#operator[@]}\" ]; do\n    # get the operator\n\
    \    local operator=\"${operator[$operator_index++]}\"\n    # if the next element\
    \ in the operand list is an int, use that as the operand\n    if [[ $operand ==\
    \ *\"$operand\"* ]]; then\n      operand=${operand#\"$operand\"};\n    fi\n  \
    \  # if the operator is a single character, use the corresponding operation\n\
    \    if [[ $operator == *\"$operator\"* ]]; then\n      # if the operator is +,\
    \ use addition\n      if [ \"$operator\" == \"+\" ]; then\n        result=$((result\
    \ + $operand));\n      # if the operator is -, use subtraction\n      elif [ \"\
    $operator\" == \"-\" ]; then\n        result=$((result - $operand));\n      #\
    \ if the operator is *, use multiplication\n      elif [ \"$operator\" == \"*\"\
    \ ]; then\n        result=$((result * $operand));\n      # if the operator is\
    \ /, use floor division\n      elif [ \"$operator\" == \"/\" ]; then\n       \
    \ result=$((result // $operand));\n      # if the operator is **, use exponentiation\n\
    \      elif [ \"$operator\" == \"**\" ]; then\n        result=$((result ** $operand));\n\
    \      fi\n      # if the operator is %, use modulo\n      elif [ \"$operator\"\
    \ == \"%\" ]; then\n        result=$((result % $operand));\n      # if the operator\
    \ is //, use floor division\n      elif [ \"$operator\" == \"//\" ]; then\n  \
    \      result=$((result // $operand));\n      # if the operator is <<, use left\
    \ shift\n      elif [ \"$operator\" == \"<<\" ]; then\n        result=$((result\
    \ << $operand));\n      # if the operator is >>, use right shift\n      elif [\
    \ \"$operator\" == \">>\" ]; then\n        result=$((result >> $operand));\n \
    \     fi\n    fi\n  done\n  echo $result", "  local OPERATOR array\n  local EXPRESSION\n\
    \  local RESULT\n  local TEMP\n  array=$1\n  shift\n  array=$1\n  shift\n  RESULT=0\n\
    \  for (( i = 0; i < ${#array[@]}; i++ )); do\n    TEMP=${array[i]}\n    for ((\
    \ j = 0; j < ${#array[@]}; j++ )); do\n      EXPRESSION=\"${array[i]} ${OPERATOR[j]}\
    \ ${array[j]}\"\n      RESULT=$(echo \"${EXPRESSION}\" | bc)\n      echo ${RESULT}\n\
    \    done\n  done\n  echo ${RESULT}", "\tlocal operator=\"$1\"\n\tlocal operand=\"\
    $2\"\n\tlocal result\n\tlocal operation\n\tlocal i\n\tlocal j\n\tlocal operands\n\
    \tlocal operators\n\tlocal operators_i\n\tlocal operands_i\n\tlocal result\n\n\
    \toperators=()\n\toperands=()\n\toperands_i=0\n\toperators_i=0\n\tresult=0\n\n\
    \toperand=\"\\\"${operands[$operands_i]}\\\"\"\n\toperands_i+=1\n\n\twhile [[\
    \ $operand ]]; do\n\t\toperation=\"\\\"${operators[$operators_i]}\\\"\"\n\t\t\
    operators_i+=1\n\n\t\twhile [[ $operation ]]; do\n\t\t\tif [[ $operands_i == $((\
    \ ${#operands[@]} - 1 )) ]]; then\n\t\t\t\toperators=($(echo \"${operands[@]}\"\
    \ | sed -E 's/.*/'\"$operation\"' /g'))\n\t\t\t\toperands_i=0\n\t\t\telif [[ $operators_i\
    \ == $(( ${#operators[@]} - 1 )) ]]; then\n\t\t\t\toperands=($(echo \"${operands[@]}\"\
    \ | sed -E 's/.*/'\"$operand\"' /g'))\n\t\t\t\toperands_i=0\n\t\t\tfi\n\n\t\t\t\
    result=\"$(( ${result} ${operation} ( ${operands[$(( ${#operands[@]} - 1 ))]}\
    \ ) ))\"\n\n\t\t\toperation=\"\\\"${operators[$(( $(( ${#operators[@]} - 1 ))))]}\\\
    \"\"\n\t\t\toperators_i+=1\n\n\t\tdone\n\t\toperand=\"\\\"${operands[$(( ${#operands[@]}\
    \ - 1 ))]}\\\"\"\n\t\toperands_i+=1\n\tdone\n\techo \"${result}\"", "    operator=$1\n\
    \    operand=$2\n    # Check if two non-empty lists \n    if [ $# -eq 2 ] || [\
    \ $# -eq 3 ]; then\n        echo \"Usage: do_algebra [opr] [operand]\"\n     \
    \   return\n    fi\n    if [[ ! $operator =~ ^(+|-|\\*|/|//)$ ]]; then\n     \
    \   echo \"Illegal operator $operator\"\n        return\n    fi\n    operator_count=$(echo\
    \ $operator | wc -w)\n    operator_element=$(echo $operator | sed 's/./ /g')\n\
    \    \n    operand_count=$(($((${#operand} - ${#operand}+1)) / $operator_count))\n\
    \    operand_element=$(echo $operand | sed 's/./ /g')\n    \n    operation_list=\"\
    \n    ${operator_count}\n    ${operator_element}\n    \"\n    for ((i = 1; i <=\
    \ ${operand_count}; i++)); do\n        operation_list=\"$operation_list ${operand_element}$i\"\
    \n    done\n    \n    echo \"${operation_list}\"", "  if [[ $# -ne 2 ]]; then\n\
    \    echo -e \"Usage:\\n$0 OPERATOR OPERAND\\n$0 OPERATOR OPERAND [OPERATOR OPERAND]\\\
    n$0 OPERATOR OPERAND [OPERATOR OPERAND...]\"\n    exit 0\n  fi\n  local operators=($1)\n\
    \  local operands=($2)\n  local result=0\n  local operand\n  local op1\n  local\
    \ op2\n  local op3\n  local op4\n  local op5\n  local i\n  \n  for ((i=0;i<${#operators[@]};++i));\
    \ do\n    operand=\"${operands[$i]}\"\n    case ${operators[$i]} in\n      +)\n\
    \        op1=$(expr $operand + 1)\n        ;;\n      -)\n        op1=$(expr $operand\
    \ - 1)\n        ;;\n      *)\n        op1=$(expr $operand * 1)\n        ;;\n \
    \     /)\n        op1=$(expr $operand / 1)\n        ;;\n      *)\n        echo\
    \ \"Illegal operator: ${operators[$i]}\"\n        exit 1\n        ;;\n    esac\n\
    \    case ${operands[$i]} in\n      +)\n        op2=$(expr $operand + 1)\n   \
    \     ;;\n      -)\n        op2=$(expr $operand - 1)\n        ;;\n      *)\n \
    \       op2=$(expr $operand * 1)\n        ;;\n      /)\n        op2=$(expr $operand\
    \ / 1)\n        ;;\n      *)\n        echo \"Illegal operand: ${operands[$i]}\"\
    \n        exit 1\n        ;;\n    esac\n    case ${operands[$i]} in\n      +)\n\
    \        op3=$(expr $operand + 1)\n        ;;\n      -)\n        op3=$(expr $operand\
    \ - 1)\n        ;;\n      *)\n        op3=$(expr $operand * 1)\n        ;;\n \
    \     /)\n        op3=$(expr $operand / 1)\n        ;;\n      *)\n        echo\
    \ \"Illegal operand: ${operands[$i]}\"\n        exit 1\n        ;;\n    esac\n\
    \    case ${operands[$i]} in\n      +)\n        op4=$(expr $operand + 1)\n   \
    \     ;;\n      -)\n        op4=$(expr $operand - 1)\n        ;;\n      *)\n \
    \       op4=$(expr $operand * 1)\n        ;;\n      /)\n        op4=$(expr $operand\
    \ / 1)\n        ;;\n      *)\n        echo \"Illegal operand: ${operands[$i]}\"\
    \n        exit 1\n        ;;\n", "    # Your code here\n    operator=$1\n    operand=$2\n\
    \    if [ $# -lt 2 ]\n    then\n        echo \"Usage: do_algebra $operator $operand\"\
    \n        return\n    fi\n    len=${#operator[@]}\n    len=${#operand[@]}\n  \
    \  len=$((len-1))\n    for (( i=0; i < len; i++ ))\n    do\n        operation=${operator[i]}\n\
    \        operand=${operand[i]}\n        operand1=${operand[i+1]}\n        if [\
    \ \"$operation\" = \"-\" ]\n        then\n            operand2=${operand[i]}\n\
    \            result=$(expr $operand - $operand2)\n        elif [ \"$operation\"\
    \ = \"+\" ]\n        then\n            operand2=${operand[i]}\n            result=$(expr\
    \ $operand + $operand2)\n        elif [ \"$operation\" = \"*\" ]\n        then\n\
    \            operand2=${operand[i]}\n            result=$(expr $operand * $operand2)\n\
    \        elif [ \"$operation\" = \"/\" ]\n        then\n            operand2=${operand[i]}\n\
    \            result=$(expr $operand / $operand2)\n        elif [ \"$operation\"\
    \ = \"//\" ]\n        then\n            operand2=${operand[i]}\n            result=$(expr\
    \ $operand $operand $operand2)\n        elif [ \"$operation\" = \"**\" ]\n   \
    \     then\n            operand2=${operand[i]}\n            result=$(expr $operand\
    \ $operand2)\n        else\n            result=$(expr $operand $operand)\n   \
    \     fi\n        echo -n \"The operation $operation is \"\n        echo -n \"\
    $result \"\n        echo \"\"\n    done", "  local operator operand\n  operator=\"\
    $1\"\n  operand=\"$2\"\n  operators=( \"$operator\" )\n  operands=( \"$operand\"\
    \ )\n  echo \"${operators[*]} ${operands[*]}\"", "    operator=$1\n    operand=$2\n\
    \n    for (( i = 0; i < ${#operator[@]}; i++ )); do\n        case \"${operator[i]}\"\
    \ in\n            '+')\n                operation=${operand[i]}\n            \
    \    (( operand_num++ ))\n                ;;\n            '-')\n             \
    \   operation=\"${operand[i]} * -1\"\n                (( operand_num-- ))\n  \
    \              ;;\n            '*')\n                operation=\"${operand[i]}\
    \ / ${operand[i-1]}\"\n                (( operand_num-- ))\n                ((\
    \ operand_num-- ))\n                ;;\n            '//')\n                operation=\"\
    ${operand[i]} / ${operand[i-1]}\"\n                (( operand_num-- ))\n     \
    \           (( operand_num-- ))\n                (( operand_num-- ))\n       \
    \         (( operand_num-- ))\n                ;;\n            '**')\n       \
    \         operation=\"${operand[i]} ^ ${operand[i-1]}\"\n                (( operand_num--\
    \ ))\n                (( operand_num-- ))\n                (( operand_num-- ))\n\
    \                (( operand_num-- ))\n                (( operand_num-- ))\n  \
    \              (( operand_num-- ))\n                (( operand_num-- ))\n    \
    \            (( operand_num-- ))\n                ;;\n            *)\n       \
    \         operation=\"${operand[i]}\"\n                (( operand_num++ ))\n \
    \               ;;\n        esac\n    done\n    echo \"${operation}\"", "  # Convert\
    \ operator and operand into arrays\n  local operator operand\n  operator=$1\n\
    \  operand=$2\n\n  local index\n  # Iterate over each operator\n  for index in\
    \ \"${!operator[@]}\"; do\n    local operator=${operator[$index]} operand=${operand[$index]}\
    \ result\n\n    if [ \"${operator}\" == \"+\" ]; then\n      result=$(( operand+operand\
    \ ))\n    elif [ \"${operator}\" == \"-\" ]; then\n      result=$(( operand-operand\
    \ ))\n    elif [ \"${operator}\" == \"*\" ]; then\n      result=$(( operand*operand\
    \ ))\n    elif [ \"${operator}\" == \"//\" ]; then\n      result=$(( operand/operand\
    \ ))\n    elif [ \"${operator}\" == \"**\" ]; then\n      result=$(( operand**operand\
    \ ))\n    else\n      echo \"Invalid operator in function do_algebra.\" 1>&2\n\
    \      return 1\n    fi\n    echo \"${operator}\\t$result\" 1>&2\n  done\n\n \
    \ # Return result \n  echo \"$result\"\n  return 0", "\t# read both lists\n\t\
    read -r OPERATOR <<< \"$1\"\n\tread -r NUMBERS <<< \"$2\"\n\t\n\t# split operators\
    \ list into operands\n\twhile read -r OPERAND; do\n\t\t# if there are only operators,\
    \ do nothing\n\t\tif [[ -z \"$OPERAND\" ]]; then\n\t\t\tcontinue\n\t\tfi\n\t\t\
    \n\t\t# if there are numbers, store them into array\n\t\tIFS=\" \" read -a NUMBER_ARRAY\
    \ <<< \"$OPERAND\"\n\t\t\n\t\t# if there is a space, split the numbers into individual\
    \ numbers and store into array\n\t\tIFS=\" \" read -a NUMBER_ARRAY <<< \"${NUMBER_ARRAY[0]}\"\
    \n\t\t\n\t\t# loop through operands\n\t\tfor (( INDEX = 1; INDEX <= ${#NUMBER_ARRAY[@]};\
    \ INDEX++ )); do\n\t\t\t# if there is no operator in current operand, break\n\t\
    \t\t[[ -z \"${OPERATOR[$INDEX]}\" ]] && break\n\t\t\t\n\t\t\t# if current operand\
    \ is a space, break\n\t\t\t[[ -z \"${NUMBER_ARRAY[$INDEX]}\" ]] && break\n\t\t\
    \t\n\t\t\t# get operator and number\n\t\t\tOPERATOR_INDEX=\"${OPERATOR[$INDEX]}\"\
    \n\t\t\tNUMBER=\"${NUMBER_ARRAY[$INDEX]}\"\n\t\t\t\n\t\t\t# if the current operand\
    \ is a space or an operator, break\n\t\t\t[[ -z \"${OPERAND[$INDEX]}\" ]] && break\n\
    \t\t\t\n\t\t\t# if the current operand is a number, store it in an array\n\t\t\
    \tIFS=\" \" read -a NUMBER_ARRAY <<< \"${OPERAND[$INDEX]}\"\n\t\t\t\n\t\t\t# loop\
    \ through numbers\n\t\t\tfor (( INDEX2 = 1; INDEX2 <= ${#NUMBER_ARRAY[@]}; INDEX2++\
    \ )); do\n\t\t\t\t\n\t\t\t\tNUMBER_INDEX=\"${NUMBER_ARRAY[$INDEX2]}\"\n\t\t\t\t\
    \n\t\t\t\t# if the current number is an operator\n\t\t\t\tif [[ \"$NUMBER_INDEX\"\
    \ == \"+\" ]]; then\n\t\t\t\t\t\n\t\t\t\t\t# loop through operand array\n\t\t\t\
    \t\tfor (( INDEX3 = 1; INDEX3 <= ${#OPERAND[@]}; INDEX3++ )); do\n\t\t\t\t\t\t\
    OPERAND_INDEX=\"${OPERAND[$INDEX3]}\"\n\t\t\t\t\t\t\n\t\t\t\t\t\t# if the current\
    \ operand is the same as the current number\n\t\t\t\t\t\tif [[ ! \"${OPERAND_INDEX}\"\
    \ == \"$NUMBER_INDEX\" ]]; then\n\t\t\t\t\t\t\t# break the inner loop and break\
    \ the outer loop\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\t\
    \t\n\t\t\t\t\t# if the current operand is the same as the current number\n\t\t\
    \t\t\tif [[ ! \"${OPERAND_INDEX}\" == \"$NUMBER_INDEX\" ]]; then\n\t\t\t\t\t\t\
    break\n\t\t\t\t\tfi\n\t\t\t\t\t\n\t\t\t\t\t# get the next operand and store it\
    \ in another array", "  local operator operand\n  \n  operator=${1:-}\n  operand=${2:-}\n\
    \  \n  if [[ $(( \"${#operator[@]}\" - \"$(( \"${#operand[@]}\" - 1 )\" ))\" !=\
    \ 0 )]]; then\n    exit 1\n  fi\n  \n  local operation\n  local result\n  \n \
    \ local i\n  local j\n  \n  for ((i=0; i<${#operator[@]}; i++)); do\n    operation=${operator[i]}\n\
    \    \n    for ((j=0; j<${#operand[@]}; j++)); do\n      result=${operand[j]}\n\
    \      \n      case $operation in\n      *)\n        operation=\"${operation}${operand[j]}\"\
    \n        break\n      ;;\n      esac\n    done\n    \n    result=$( eval \"$operation\"\
    \ )\n    \n    operand[i]=$result\n  done\n  \n  printf '%s = %s\\n' \"$1\" \"\
    $operand\"", "    operator=$1\n    operand=$2\n    eval \"$(echo $operand | tr\
    \ \" \" \"+\")\"", "  local operator=\"$1\"\n  local operand=\"$2\"\n  local result=\"\
    \"\n\n  for i in ${operand[@]}; do\n    if [ \"$i\" != 0 ]; then\n      result=\"\
    $result ${operator}${i}\"\n    fi\n  done\n\n  echo \"${result}\"", "  local op\n\
    \  local operands\n  local result\n\n  local -n operator=$1\n  local -n operands=$2\n\
    \n  local i\n\n  for (( i=0; i<${#operator[@]}; i++ )); do\n    op=${operator[i]}\n\
    \    operand=${operands[i]}\n\n    case $op in\n      '+'|'+')\n        result=$((\
    \ ${result} + ${operand} ))\n        ;;\n      '-'|'-')\n        result=$(( ${result}\
    \ - ${operand} ))\n        ;;\n      '*'|'*')\n        result=$(( ${result} *\
    \ ${operand} ))\n        ;;\n      '/'|'/') \n        result=$(( ${result} / ${operand}\
    \ ))\n        ;;\n      '**'|'**')\n        result=$(( ${result} ** ${operand}\
    \ ))\n        ;;\n    esac\n  done\n\n  echo $result", "\tlocal operator operand\n\
    \tlocal result\n\tlocal count\n\tlocal i\n\t# Print the initial state of the variables\
    \ before running for loops\n\techo \"operand = $operand\"\n\techo \"operator =\
    \ $operator\"\n\techo \"result = $result\"\n\t# Initialize a count variable and\
    \ run loops\n\tcount=0\n\tfor ((i = 0; i < ${#operand[@]}; i++)); do\n\t\tif [\
    \ ${operand[$i]} -eq 0 ]; then\n\t\t\t((count++))\n\t\t\t((operand[$i])=\"\")\n\
    \t\telse\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo \"operand[$count] = $operand[$count]\"\
    \n\techo \"operator[$count] = $operator[$count]\"\n\techo \"operand[$count] =\
    \ $operand[$count]\"\n\tfor ((i = 0; i <= ${#operand[@]}; i++)); do\n\t\tif [\
    \ ${operator[$i]} == $1 ]; then\n\t\t\tresult=${operand[$i]}\n\t\tfi\n\tdone\n\
    \techo \"result = $result\"\n\treturn $result", "\tlocal operand=$1\n\tlocal operator=$2\n\
    \tlocal result\n\tresult=`echo ${operand}${operator}${operand} | bc`\n\techo ${result}",
  "  local operator=${1:-\"*\"} # first element is the operator\n  local operands=${2:-\"\
    1 2\"} # first element is the operand\n  local output\n  local operator_name\n\
    \n  output=\"$(eval_expr \"${operator}\" \"$operands\")\"\n  if [ -z \"$output\"\
    \ ]; then\n    exit 0\n  else\n    operator_name=$(echo $operator | tr '[:lower:]'\
    \ '[:upper:]')\n    echo $operator_name\n  fi", "\tlocal operator operand\n\t\
    local result\n\tlocal i\n\t\n\tfor ((i = 0; i < ${#OPERATOR[@]}; ++i)); do\n\t\
    \toperator=${OPERATOR[i]}\n\t\toperand=${OPERAND[i]}\n\t\tresult=$($operator $operand\
    \ ${OPERAND[$((i+1))]})\n\t\techo ${RESULT[i]}\n\tdone", "\tdeclare -a op\n\t\
    declare -a res\n\tdeclare -i i\n\tlocal -n result\n\tlocal -n op\n\tlocal -n arg\n\
    \tlocal -n argi\n\tlocal -n argj\n\tlocal -n argk\n\tlocal -n argl\n\tlocal -n\
    \ argm\n\tlocal -n argn\n\tlocal -n argo\n\tlocal -n argp\n\tlocal -n argq\n\t\
    local -n argr\n\tlocal -n args\n\tlocal -n argt\n\tlocal -n argu\n\tlocal -n argv\n\
    \tlocal -n argw\n\tlocal -n argx\n\tlocal -n argy\n\tlocal -n argz\n\tlocal -n\
    \ argAA\n\tlocal -n argAB\n\tlocal -n argAC\n\tlocal -n argAD\n\tlocal -n argAE\n\
    \tlocal -n argAF\n\tlocal -n argAG\n\tlocal -n argAH\n\tlocal -n argAI\n\tlocal\
    \ -n argAJ\n\tlocal -n argAK\n\tlocal -n argAL\n\tlocal -n argAM\n\tlocal -n argAN\n\
    \tlocal -n argAO\n\tlocal -n argAP\n\tlocal -n argAQ\n\tlocal -n argAR\n\tlocal\
    \ -n argAS\n\tlocal -n argAT\n\tlocal -n argAU\n\tlocal -n argAV\n\tlocal -n argAW\n\
    \tlocal -n argAX\n\tlocal -n argAY\n\tlocal -n argAZ\n\tlocal -n argBA\n\tlocal\
    \ -n argBB\n\tlocal -n argBC\n\tlocal -n argBD\n\tlocal -n argBE\n\tlocal -n argBF\n\
    \tlocal -n argBG\n\tlocal -n argBH\n\tlocal -n argBI\n\tlocal -n argBJ\n\tlocal\
    \ -n argBK\n\tlocal -n argBL\n\tlocal -n argBM\n\tlocal -n argBN\n\tlocal -n argBO\n\
    \tlocal -n argBP\n\tlocal -n argBQ\n\tlocal -n argBR\n\tlocal -n argBS\n\tlocal\
    \ -n argBT\n\tlocal -n argBU\n\tlocal -n argBV\n\tlocal -n argBW\n\t", "    local\
    \ operator operand\n    for operator in \"$1\"; do\n        for operand in \"\
    $2\"; do\n            eval \"echo \\$$($operator)\\$($operand)\"\n        done\n\
    \    done", "    local operator operand\n    operator=$1\n    operand=$2\n   \
    \ shift\n    shift\n\n    # First build the algebric expression by iterating through\
    \ each operand and \n    # building up the algebric expression one operand at\
    \ a time.\n    ALGEBRIC=\"\"\n    for operandI in $operand; do\n        for operatorI\
    \ in $operator; do\n            ALGEBRIC=$ALGEBRIC$operandI$operatorI\n      \
    \  done\n    done\n\n    # Now evaluate the expression.\n    eval $ALGEBRIC",
  "   operator=$1\n   operand=$2\n   echo ${operand}\n   for (( i=0; i<${#operand[@]};\
    \ i++ )); do\n      if [ ${operand[$i]} -lt 0 ] ; then\n         echo \"Error:\
    \ operand is non-negative\"\n         exit 1\n      fi\n      temp=${operand[$i]}\n\
    \      while [ $i -le ${#operator[@]} ] ; do\n         op=${operator[$i]}\n  \
    \       case ${op} in\n            /*)\n               temp=${temp} $(( ${temp}\
    \ / ${operand[$(( i + 1 ))]} ))\n               i=$(( i + 1 ))\n             \
    \  break\n             *) \n               temp=${temp} $(( ${temp} / ${operand[$i]}\
    \ ))\n               break\n         esac\n         i=$(( i + 1 ))\n      done\n\
    \      operand[$i]=${temp}\n   done\n   echo \"${operand[@]}\"", "    local operator\
    \ operand\n    operator=$1\n    operand=$2\n    # check whether the operands are\
    \ non-negative\n    for i in `seq 1 $(($#operand - 1))`\n    do\n        if [\
    \ $((operand[i])) -lt 0 ]; then\n            echo \"Input error: operand $i has\
    \ negative value.\"\n            exit 1\n        fi\n    done\n\n    do_expr \"\
    $operator\" \"${operand[@]}\"", "    operator=$1\n    operand=$2\n    operator_count=${#operator}\n\
    \    operand_count=${#operand}\n    stack_count=$((2 * operand_count + 1))\n \
    \   stack=()\n    for (( i=0; i <= stack_count; i++ )) ; do\n        stack[$i]=0\n\
    \    done\n    for (( i=0; i<${#operand}; i++ )) ; do\n        stack[$(( stack_count\
    \ + i ))]=${operand[i]}\n    done\n    for (( i=stack_count; i >= 0; i-- )) ;\
    \ do\n        stack[$i]=$(( stack[$i] - stack[$(( i - 1 ))] ))\n    done\n   \
    \ res=0\n    for (( i=0; i < operator_count; i++ )) ; do\n        (( res = res\
    \ + stack[$(( stack_count + i ))] ))\n    done\n    return ${res}", "    operator=$1\n\
    \    operand=$2\n    array=( $operand )\n    operator += \"*\" # Avoid negative\
    \ exponent cases\n    operator += \"/\" # Avoid division by 0 cases\n    array=(\
    \ $operator )\n    echo $(( $array[0] + $array[1] * $array[2] ))", "    local\
    \ operator=\"$1\"\n    local operand=\"$2\"\n\n    local result\n    local operator_index\n\
    \    local operand_index\n    local operand_char\n    local operand_value\n  \
    \  local operator_index\n\n    # Convert operand to string\n    result=$(echo\
    \ \"${operand}\" | sed \"s/,/' '/g\")\n    \n    operator_index=$(echo \"${operator}\"\
    \ | awk '{print index($1,$0)}')\n    operand_index=$(echo \"${operand}\" | awk\
    \ '{print index($0,$1)}')\n    operand_char=$(echo \"${operand}\" | awk '{print\
    \ substr($0,index($0,$1))}')\n    operand_value=$(echo \"${operand}\" | awk '{print\
    \ substr($0,index($1,$1))}')\n    \n    case \"${operator_index}\" in\n      \
    \  0) echo \"Invalid operator: $operator_index\" >&2\n          exit 1 \n    \
    \    ;;\n        1) case \"${operand_index}\" in\n                0) echo \"Invalid\
    \ operand: $operand_index\" >&2\n                  exit 1 \n              ;;\n\
    \                1) \n                    case \"${operand_char}\" in\n      \
    \                  # Multiplication\n                        '*') \n         \
    \                   result=$(echo \"${result}\" | awk '{print ($1 * $2)}')\n \
    \                       ;;\n                        # Division\n             \
    \           '/') \n                            result=$(echo \"${result}\" | awk\
    \ '{print ($1 / $2)}')\n                        ;;\n                        #\
    \ Addition\n                        '+') \n                            result=$(echo\
    \ \"${result}\" | awk '{print ($1 + $2)}')\n                        ;;\n     \
    \                   # Subtraction\n                        '-') \n           \
    \                 result=$(echo \"${result}\" | awk '{print ($1 - $2)}')\n   \
    \                     ;;\n                        # Exponentiation\n         \
    \               '**') \n                            result=$(echo \"${result}\"\
    \ | awk '{print ($1 ** $2)}')\n                        ;;\n                  \
    \      *) \n                            # Addition\n                         \
    \   result=$(echo \"${result}\" | awk '{print ($1 + $2)}')\n                 \
    \       ;;\n                    esac\n                ;;\n            *) echo\
    \ \"Invalid operand: $operand_index\" >&2\n            exit 1 \n        ;;\n \
    \       *)  \n            case \"${operand_index}\" in\n                # Floor\
    \ division\n                '//') \n                    result=$(echo \"${result}\"\
    \ | awk '{print ($1 / $2)}')\n                ;;\n                # Exponentiation\n\
    \                '**') \n                    result=$(echo \"${result}\" | awk\
    \ '{print ($1 ** $2)}')\n                ;;\n                *) \n           \
    \         # Addition\n                    result", "    local operator operand\n\
    \    operator=${1%% *}\n    operand=${1#* }\n    local result\n    for ((i = 0;\
    \ i <= ${#operand}; i += 1)); do\n        result=0\n        if [[ ${#operator}\
    \ != ${#operand} ]]; then\n            echo \"ERROR: Operator list length is equal\
    \ to operand list length minus one.\"\n            return 1\n        fi\n    \
    \    for ((j = 0; j < ${#operator}; j += 1)); do\n            result=$((result*${operand[j]}${operator[j]}))\n\
    \        done\n        ((result = result%1))\n        echo ${operand[$i]} $operator\
    \ ${operand[$i]} $result\n    done", "  local operator operand\n  read -a operator\
    \ <<< \"$1\"\n  read -a operand <<< \"$2\"\n  local result sum\n  \n  sum=$((\
    \ ${operand[0]} ${operator[0]} ${operand[1]} ))\n  for (( i=2; i<\"${#operand[@]}\"\
    ; i++ )); do\n    sum=$(( sum + ${operand[i]} ))\n  done\n  echo $sum", "   local\
    \ operator\n   local operand\n   local expression\n   operator=$1\n   operand=$2\n\
    \   # Trim the spaces\n   operator=${operator// /}\n   operand=${operand// /}\n\
    \   local i=0\n   local output=\"\"\n   for i in $(seq 0 $((${#operand} - 1)))\n\
    \   do\n      case \"${operand}\" in\n         0)\n            output=$(echo \"\
    ${operand}\" | bc | awk '{print $3}')\n            ;;\n         1)\n         \
    \   output=$(echo \"${operand} * ${operand}\" | bc | awk '{print $3}')\n     \
    \       ;;\n         2)\n            output=$(echo \"${operand} / ${operand}\"\
    \ | bc | awk '{print $3}')\n            ;;\n         3)\n            output=$(echo\
    \ \"${operand} ^ ${operand}\" | bc | awk '{print $3}')\n            ;;\n     \
    \    4)\n            output=$(echo \"${operand} % ${operand}\" | bc | awk '{print\
    \ $3}')\n            ;;\n         5)\n            output=$(echo \"${operand} |\
    \ ${operand}\" | bc | awk '{print $3}')\n            ;;\n         6)\n       \
    \     output=$(echo \"${operand} & ${operand}\" | bc | awk '{print $3}')\n   \
    \         ;;\n         7)\n            output=$(echo \"${operand} < ${operand}\"\
    \ | bc | awk '{print $3}')\n            ;;\n         8)\n            output=$(echo\
    \ \"${operand} > ${operand}\" | bc | awk '{print $3}')\n            ;;\n     \
    \    9)\n            output=$(echo \"${operand} <= ${operand}\" | bc | awk '{print\
    \ $3}')\n            ;;\n        10)\n            output=$(echo \"${operand} >=\
    \ ${operand}\" | bc | awk '{print $3}')\n            ;;\n        11)\n       \
    \     output=$(echo \"${operand} != ${operand}\" | bc | awk '{print $3}')\n  \
    \          ;;\n        12)\n            output=$(echo \"${operand} <= ${operand}\"\
    \ | bc | awk '{print $3}')\n            ;;\n        13)\n            output=$(echo\
    \ \"${operand} >= ${operand}\" | bc | awk '{print $3}')\n            ;;\n    \
    \    14)\n            output=$(echo \"${operand} > ${operand}\" | bc | awk '{print\
    \ $3}')\n            ;;\n        15)\n            output=$(echo \"${operand} <\
    \ ${operand}\" | bc | awk '{print $3}')\n            ;;\n        16)\n       \
    \     output=$(echo \"${operand} ", "  local OPERATOR OPMIX=$1\n  local NUMBER=$2\n\
    \  local OP=\"\"\n  local SUM=\"\"\n  \n  # if operand list has only one operand\
    \ \n  if [[ ${#OPMIX} -lt 2 ]]; then\n    echo $2\n    return 1\n  fi\n  \n  #\
    \ if operand list has two operands\n  if [[ ${#OPMIX} -eq 2 ]]; then\n    OPMIX=\"\
    ${OPMIX[0]} ${OPMIX[1]}\"\n  fi\n  # if operand list has three operands\n  if\
    \ [[ ${#OPMIX} -eq 3 ]]; then\n    OPMIX=\"${OPMIX[0]} ${OPMIX[1]} ${OPMIX[2]}\"\
    \n  fi\n  \n  # get first element from the operand list\n  OP=\"${OPMIX% *}\"\n\
    \  # get second element from the operand list\n  NUMBER=\"${OPMIX#* }\"\n  # get\
    \ the operator\n  OP=\"${OPMIX% *}\"\n  # get second element from the operator\
    \ list\n  OP=\"${OPMIX#* }\"\n  \n  # if operator is empty\n  if [[ -z ${OP} ]];\
    \ then\n    echo $2\n    return 1\n  fi\n  \n  # if operator has a non-positive\
    \ number\n  if [[ \"${OP}\" -lt 1 ]]; then\n    echo $2\n    return 1\n  fi\n\
    \  \n  # if operator has a non-positive number\n  if [[ \"${OP}\" -lt 1 ]]; then\n\
    \    echo $2\n    return 1\n  fi\n  \n  # if operator has a non-positive number\n\
    \  if [[ \"${OP}\" -lt 1 ]]; then\n    echo $2\n    return 1\n  fi\n  \n  # get\
    \ operator and operand from operand list\n  NUMBER=\"${NUMBER% *}\"\n  OP=\"${OP%\
    \ *}\"\n  \n  # calculate sum\n  SUM=\"${NUMBER}${OP} $((${OP}+$2))\"\n  # print\
    \ result\n  echo \"$SUM\""]
stop_tokens:
- "\n}"
