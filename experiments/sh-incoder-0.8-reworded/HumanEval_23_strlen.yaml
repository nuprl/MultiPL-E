name: HumanEval_23_strlen
language: sh
prompt: "#!/bin/bash\n# Return length of given string\n# >>> $(strlen \"\")\n# \"\
  0\"\n# >>> $(strlen \"abc\")\n# \"3\"\n#\n# $1 is a string\nstrlen() {\n"
tests: "}\n\ncandidate() {\n    strlen \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"\") = \"0\" ]]\n    [[ $(candidate \"x\") = \"1\" ]]\n    [[ $(candidate \"\
  asdasnakj\") = \"9\" ]]\n}\n\nrun_test"
completions: ["  # Get the string length\n  local -i len=${#1}\n  # Return the string\
    \ length\n  echo $len", "  [[ $1 ]] || return 0\n  echo $(( ${#1} ))", "    local\
    \ -i n\n    n=0\n    for (( n = 0; $1 < ${1#0}; n++ )); do\n        shift\n  \
    \  done\n    echo \"$n\"", '    echo "${#1}"', "    local __str=\"$1\"\n    local\
    \ __len=0\n    for __pos in \"${!__str}\"; do\n        __len=$((__len+1))\n  \
    \  done\n    echo \"$__len\"", "\techo $((${#1})+1)", '  echo ${#$1} # get length
    of string', "  [[ $1 =~ (.+=) ]] || return 0\n  local -i len\n  len=${#1}\n  [[\
    \ $len -eq 0 ]] && return 0\n  [[ $len -gt 0 ]] && return 0\n  echo \"$(( ${len#??}\
    \ ))\"", "    len=0\n    while [[ ${1:0:1} != ${1:0:1} ]]; do\n        len=$((len\
    \ + 1))\n        shift\n    done\n    echo ${len}", '  echo $1 | wc -c', "   \
    \ local string=$1\n    local length=0\n    if [ \"${#string}\" -ne \"0\" ]; then\n\
    \        length=$((${#string} + 1))\n    fi\n    echo ${length}", "  local -n\
    \ strlen=$1\n  [[ ${#strlen} -eq 0 ]] && echo \"0\" || echo ${#strlen}", "   \
    \ local IFS= #\n    local LENGTH=0\n    # shellcheck disable=SC2086\n    while\
    \ [ -n \"$1\" ]; do\n        [ \"$1\" =~ .* ]\n        local SUBSTRING=$((${#1}\
    \ - ${#1} % ${#1}))\n        LENGTH=$((${LENGTH} + ${SUBSTRING}))\n        shift\n\
    \    done\n    echo \"$LENGTH\"", '    echo $((${1:-0}+0))', '    expr length
    "$1" \* 1', "\techo $1 | awk '{print length}'", '  echo $1 | wc -c', "  local\
    \ str=\"$1\"\n\n  if [[ \"$str\" == \"\" ]]; then\n    echo \"0\"\n    return\n\
    \  fi\n\n  local len=0\n  while [[ $str != \"\" ]]; do\n    ((++len))\n    str=\"\
    ${str%?}\"\n  done\n\n  echo \"$len\"", "    local x=\"${1#*[!0-9]\"}\"\n    local\
    \ len=\"${#x}\"\n    [ \"${x}\" = \"${1}\" ] && [ \"${len}\" = \"0\" ] && return\
    \ 0 || return ${len}", '  echo "${#1}"', "  [[ $1 =~ ^[[:space:]].* ]] && echo\
    \ 0\n  echo ${#1}", "  local i\n  local len\n  for ((i=1;;i++)); do\n    (( len=${#1}\
    \ >= i )) && echo \"${#1}\" || break\n  done", "    length=$1\n    len=0\n   \
    \ while [ \"${length}\" != \"\" ]; do\n        length=\"${length#${1}\"}\"\n \
    \       let \"len++\"\n    done\n    echo \"${len}\"", "    if [ \"$1\" = \"\"\
    \ ]; then\n        echo 0\n    else\n        echo ${#1}\n    fi", "    local str=$1\n\
    \    [[ -z \"$str\" ]] && return 0\n    local -i len=0\n    for (( c=0; c<${#str};\
    \ c++ )); do\n        [[ ${str:$c:1} == '\\0' ]] && break\n        (( len++ ))\n\
    \    done\n    return ${len}", "\t[ \"${1:-}\" ] && [ -n \"${1:-}\" ] && echo\
    \ \"${#1}\"", "\t[ -n \"$1\" ] &&\n\techo ${#$1} | sed \"s/ //g\"", "    [[ \"\
    $1\" != \"\" ]] || return 1\n    [[ \"$1\" =~ ^[[:digit:]]+$ ]] || return 1\n\
    \    echo \"${#1}\"", "    [[ ${#$1} -gt 0 ]] \\\n        && [[ ${#$1} -lt ${#}\
    \ ]] || return 1", '  echo $1 | wc -m', "   local str=\"$1\"\n   [[ -z \"$str\"\
    \ ]] && return 0\n   expr \"$str\" : \"[^ ]\\+$\"", '    echo "${#1}"', '  echo
    $((${#1}))', "  if [ -z \"$1\" ]\n  then\n    return 0\n  else\n    return \"\
    ${#1}\"\n  fi", '  [[ ${#1} -gt 0 ]] && echo ${#1}', "\tlocal i\n\ti=${#1}\n\t\
    while [[ $i -gt 0 ]]; do\n\t\t((i++))\n\tdone\n\techo $i", '    echo "${#1}"',
  "    if [ -z \"$1\" ]; then\n        return 0\n    fi\n    echo \"${#1}\"", "  local\
    \ -i len=0\n  local -i cnt=0\n  local -i strlen=${#1}\n  while [ \"${strlen}\"\
    \ -gt 0 ]; do\n    ((cnt++))\n    ((len+=1))\n    strlen=${strlen%?}\n  done\n\
    \  echo \"${len}\"", "  # shellcheck disable=SC2034\n  local string=${1:-}\n \
    \ (( ${#string} ))", "    len=$(( $# ))\n    echo \"$len\"", "    # Check for\
    \ empty string\n    if [[ -z $1 ]]; then\n        return 0\n    fi\n\n    # Length\
    \ of string\n    length=0\n    for (( i = 0; i < ${#1}; i++ )); do\n        length=$((length+1))\n\
    \    done\n    echo $length", "\techo $1 | awk '{ print length($1) }'", "  [[\
    \ -n \"$1\" ]] || return 0\n  echo \"${#1}\"", "    local length i\n    length=0\n\
    \    for ((i=1;i<=$1;i++)); do\n        length=$((length+1))\n    done\n    echo\
    \ \"$length\"", "    local str=\"$1\"\n    [[ \"${str}\" =~ ^[a-zA-Z0-9]+$ ]]\
    \ || return 1\n    echo ${#str}", "  local len=0\n  local str=$1\n  local strlen\n\
    \  while [ \"$str\" ] ; do\n    strlen=$((strlen+1))\n    str=${str#*[!0-9]}\n\
    \  done\n  echo $strlen", "    local str=$1\n    local len=0\n\n    [ $# -gt 0\
    \ ] || return\n\n    for (( c=0; c<${#str}; c++ )); do\n        let \"len++\"\n\
    \    done\n\n    printf '%s' \"${len}\"", '    echo "${#1}"', "    local str=\"\
    ${1:-}\"\n\n    [ -z \"${str}\" ] && return 0\n\n    [ ${#str} -gt 0 ] && echo\
    \ ${#str}", "  if [ -n \"$1\" ] ; then\n    echo \"${#1}\"\n  else\n    echo \"\
    0\"\n  fi", "    test -z \"$1\" && return 0;\n    echo \"${#1}\"", "    [[ $1\
    \ ]] || return 0\n    [[ $1 ]] && echo \"${#1}\"", "    local -i strlen\n    local\
    \ -i len\n    local line\n\n    strlen=0\n    len=0\n    while read -r line; do\n\
    \        if [[ -n \"$line\" ]]; then\n            len=$(( $len + 1 ))\n      \
    \  fi\n    done <<< \"$1\"\n    echo \"$len\"", '    echo $1 | wc -m', '    echo
    $(( ${#1} ))', "    local STR=$1\n    echo $STR | wc -c", "    local _str=\"${1}\"\
    \n    if [ \"${_str}\" ]; then\n      echo ${#${_str}}\n    fi", '    echo ${#1}',
  "\t[ \"${#1}\" -gt 0 ] && echo \"${#1}\"", "\tlocal arg=\"$1\"\n\tif [[ \"$arg\"\
    \ == \"\" ]]; then\n\t\treturn 0\n\tfi\n\techo \"$arg\" | wc -c", "    local string=\"\
    ${1}\"\n    echo \"${#string}\"", "  # return 0 if empty string\n  [[ \"$1\" ==\
    \ \"\" ]] && return 0\n  # return length of string\n  [[ \"${#1}\" -gt 0 ]] &&\
    \ echo $((${#1})) || return $((${#1}))", '    echo $1 | wc -c', "  local str=\"\
    $1\"\n  [[ -n $str ]] || return 0\n  echo \"${#str}\"", '    echo "${#1}"', " \
    \   local str=\"${1}\"\n    echo ${#str}", '    echo ${#$1} | bc', '    echo ${#$1}
    # echo length of $1 string', "  local str=\"$1\"\n  local len=0\n  local i=0\n\
    \n  while [ $i -lt ${#str} ]\n  do\n    (( ++i ))\n  done\n\n  len=$(( i - 1 ))\n\
    \  return $len", '  echo ${#1} ', "    local L\n    L=\"${#1}\"\n    echo $L",
  "  [[ -z \"$1\" ]] && return 0\n  echo $1 | wc -c", "  local -i len=0\n  # get length\
    \ of given string\n  while [[ \"$1\" ]]; do\n    ((++len))\n    shift\n  done\n\
    \  echo $len", "    if [[ $1 != \"\" ]]; then\n        echo $(expr length \"$1\"\
    )\n    else\n        echo 0\n    fi", '   echo "${#1}"', '    echo "$1" | wc -c',
  "\techo $1 | awk -F '[][()]+' '{print length}'", '  [ ! -z "$1" ] && echo "${#1}"
    || echo "0"', '  echo "${#1}"', '    [[ $1 =~ ^[[:space:]]*$ ]] && echo 0 || echo
    ${#1}', '    echo ${#$1} # echo the length of $1', '    echo ${#$1} ', "    [[\
    \ $1 ]] || return 0\n    echo $(( ${#1} ))", "\tlocal length\n\t[[ -n $1 ]] ||\
    \ return\n\tlength=\"${#1}\"\n\t(( length != 0 )) && return\n\treturn", "    if\
    \ [ x\"${#1}\" == \"x\" -a x\"${#1}\" == \"x${#1}\" ]; then return 0; fi\n   \
    \ local len\n    len=\"${#1}\"\n    len=\"${len//[^0-1]}\"\n    len=\"${#len}\"\
    \n    echo \"${len}\"", '  echo "${#1}"', '    echo "${#1}"', "  if [[ -z \"$1\"\
    \ ]]; then\n    echo 0\n  else\n    echo \"${#1}\"\n  fi", "\techo ${#1}", " \
    \   echo $1 | awk '{ print length($1) }'", "   [[ \"${1:0:1}\" != \"-\" && \"\
    ${1:0:1}\" != \"_\" && \"${1:0:1}\" != \"*\" ]] && return 0 # No leading zero\
    \ and empty string\n   [[ $1 == *[![:space:]]* ]] || return 0 # Only spaces\n\
    \   local len\n   len=\"${1#*([![:space:]]*)}\" # $1 is only spaces or empty string\n\
    \   [[ \"${len}\" == *[![:space:]]* ]] || return 0 # Only spaces\n   len=${#len}\n\
    \   [[ \"${len}\" -gt 2 ]] || return 0\n   len=${len%%.*}\n   [[ -z \"${len}\"\
    \ ]] && return 0\n   [[ \"${len}\" -eq 2 ]] || return 0\n   echo ${len}", "  \
    \  [ $(echo \"${#1}\" = ${#1}) -eq 0 ] && return 0\n    echo $(echo \"${#1}\"\
    \ | bc)", "  local STR=\"$1\"\n\n  # [[ $STR ]] means ${STR:0:-1}, i.e. last character\n\
    \  # ${#STR} means ${#STR}, i.e. length of the string\n  echo \"${#STR}\"", " \
    \   if [ $# -lt 1 ]; then\n        return 0\n    fi\n    echo $((${#1}))", '    echo
    ${#1}', '  echo ${#1} | bc', "   local n=\"$1\"\n   test -n \"$n\" && local len=\"\
    ${#n}\"\n   test -z \"$len\" && len=0\n   echo $len", "    # check if argument\
    \ isn't null\n    test \"${1:?}\" != \"\"\n    # get length of string\n    len=\"\
    ${#1}\"\n    # check if length is positive\n    test -n \"${len}\"\n    # return\
    \ length\n    echo \"${len}\"", '  echo "${#1}"', "  # This command is similar\
    \ to `bash <(echo \"${#1}\")`\n  local strlen=\"${1#*[!A-Za-z0-9_]}\"\n  [ \"\
    ${strlen}\" -ge \"${#1}\" ] && strlen=\"${strlen#1}\"\n  echo $strlen", '  echo
    ${#1}', "\tstr=$(\n\t\techo \"$1\" |\n\t\twc -c\n\t)\n\techo $str", "  local str=$1\n\
    \n  if [ -z \"$str\" ]\n  then\n    return 0\n  fi\n\n  local len=0\n  local i=0\n\
    \  while [ \"$i\" -lt \"$str\" ]\n  do\n    ((++i))\n  done\n\n  ((len=i))\n \
    \ return $len", "    echo -n \"$1\" |\n    sed 's/^[ \\t]*//;s/[ \\t]*$//;s/^[\
    \ \\t]*\\(.*\\)$/\\1/'", "  [ \"$#\" -eq \"1\" ] && return\n\n  local length=0\n\
    \  while [ -n \"$1\" ]; do\n    [[ \"$1\" == [[:space:]] ]] && return\n    [[\
    \ \"$1\" =~ [[:space:]] ]] && return\n    ((length++))\n    shift\n  done\n  echo\
    \ \"$length\"", "    local strlen\n    local str\n    local length\n    strlen=$((${#1}\
    \ + 1))\n    length=${#1}\n    while [ \"${str:$length:1}\" != \"\" ]\n    do\n\
    \        strlen=$((strlen + 1))\n        length=${#str}\n    done\n    echo ${strlen}",
  "\tlocal str\n\tstr=$1\n\techo \"${#str}\"", "    local length=\"${#1}\"\n    echo\
    \ \"${#1}/$length\"", '  echo "${#1}"', "\t[ -z \"$1\" ] && return\n\tlocal len=${#1}\n\
    \t[ $len -gt 0 ] && echo ${#1}", "\techo \"${#1}\"", '    echo "${#1}"', '  [[
    $# -ne 1 ]] && echo "Invalid usage" && exit 1 || return $((${#1} + 0))', "   \
    \ # https://unix.stackexchange.com/a/153018\n    local string=\"$1\"\n    local\
    \ length=${#string}\n    echo \"$length\"", "  local -r n=\"${#1}\"\n  [[ $n -eq\
    \ 0 ]] && return 0 || return $n", '  echo "${#1}"', "  local len=0\n  local i\n\
    \n  while [[ $1 ]]; do\n    len=$(( len + 1 ))\n    shift\n  done\n\n  echo $len",
  "    [ ${#1} -eq 0 ] && return 0\n    echo ${#1}", "  local len=$1 str=\"$2\"\n\
    \  # echo $str\n  local -i cnt=0\n  while [[ \"$str\" != \"\" ]]; do\n    ((cnt++))\n\
    \    str=\"${str#?}\"\n  done\n  echo ${len}", '    local -i strlen=$(echo $1
    | wc -w)', '  expr $1 + 0', "  if [[ \"$1\" == \"\" ]]; then\n    echo \"0\"\n\
    \  else\n    echo \"${#1}\"\n  fi", "\tlocal string=$1\n\t[ \"${string}\" ] &&\
    \ echo \"${#string}\"", "  # Add quotes around variables to protect spaces from\
    \ expansion\n  local quotes=$(echo \"\\\"${1}\\\"\" | sed 's/ /\\\\ /g')\n  #\
    \ Escape double-quotes around spaces and add backslashes before double-quotes\n\
    \  echo $(echo \"\\\"${1}\\\"\" | sed 's/\"/\\\\\"/g' | sed \"s/ /'\\\\\\\\ /g\"\
    \ | sed \"s/'/\\\\\\\\'/g\" | sed \"s/'/\\\\\\\\'/g\" | sed \"s/'/\\\\\\\\'/g\"\
    )", "  strlen $1 \\\n    | cut -c 1-\\\n    | wc -c", "  local str=\"$1\"\n  [[\
    \ \"$str\" = \"$null\" ]] && return 0\n  local count=0\n  local strlen=0\n  while\
    \ [[ $str != \"\" ]]; do\n    strlen=$((strlen+1))\n    str=\"${str#*[[:space:]]}\"\
    \n  done\n  [[ \"$str\" = \"\" ]] && return $strlen", "    local i len\n    local\
    \ str=$1\n    len=0\n    for ((i = 0; i <= ${#str}; i++ ))\n    do\n        len=$((len\
    \ + 1))\n    done\n    echo $len", '  [[ "$1" =~ ^([[:space:]]*)(.*)$ ]] && echo
    "${BASH_REMATCH[2]}" | wc -l || echo "0"', "  # If we have an odd number of characters,\
    \ return the string length\n  [[ \"${#1}\" -eq \"2\" ]] && echo \"${#1}\" || echo\
    \ \"${#1#0}\";", "    local i\n    local len\n    len=0\n    for i in \"${!1}\"\
    ; do\n        let len=$((len + 1))\n    done\n    echo \"$len\"", "    python\
    \ -c \"\nimport sys, os\nprint(len(sys.argv[1]))\n\"", '  [[ ${#1} -gt 0 ]] &&
    echo "${#1}"', "    if [ -z \"$1\" ]\n    then\n        return 0\n    fi\n   \
    \ string=$1\n    if [ \"${#string}\" = \"0\" ]\n    then\n        return 0\n \
    \   fi\n    echo $((${#string} - 1))", '  [[ $1 ]]', '    [[ ${#$1} -gt 0 ]] &&
    echo $((${#$1} + 1))', "  [ \"$#\" -gt \"1\" ] && return 0 # return 0 if no arg\
    \ is given\n  echo $((${#1} ))", "\ttest -n \"$1\" && echo \"${#1}\"", "    local\
    \ len=0\n    for c in $1 \n    do\n        [ \"${c:0:1}\" == '-' ] ||\n      \
    \      [ \"${c:0:1}\" == ' ' ] ||\n            [ \"${c:0:1}\" == '\\t' ] ||\n\
    \            [ \"${c:0:1}\" == '\\n' ] ||\n            [ \"${c:0:1}\" == '\\r'\
    \ ] ||\n            [ \"${c:0:1}\" == '\\f' ] ||\n            [ \"${c:0:1}\" ==\
    \ '\\0' ] ||\n            [ \"${c:0:1}\" == '[' ] ||\n            [ \"${c:0:1}\"\
    \ == '{' ] ||\n            [ \"${c:0:1}\" == '(' ] ||\n            [ \"${c:0:1}\"\
    \ == ']' ] ||\n            [ \"${c:0:1}\" == '}' ] ||\n            [ \"${c:0:1}\"\
    \ == '('] ||\n            [ \"${c:0:1}\" == ')' ] ||\n            [ \"${c:0:1}\"\
    \ == '\\\"' ] ||\n            [ \"${c:0:1}\" == '\\'' ] ||\n            [ \"${c:0:1}\"\
    \ == '`' ] ||\n            (( ${#c} <= 0 )); then\n            ((len++))\n   \
    \     else\n            break\n        fi\n    done\n    echo \"${len}\"", " \
    \ echo $1 | awk -F '\\0' '{print length}' |", "    local strlen=\"$1\"\n    [[\
    \ -z \"$strlen\" ]] && return 0\n    echo \"${#strlen}\"", "    if [ -z \"$1\"\
    \ ]; then\n        return 0\n    fi\n    echo \"$#\" | bc", "  python -c 'import\
    \ sys;print(len($1) % 2)'", "    [ \"${1:0:1}\" == \"-\" ] && return\n    local\
    \ len\n    [ \"${1:0:1}\" == \"$1\" ] && return\n    len=$(expr ${#1})\n    if\
    \ [ \"${1:0:1}\" != \"$1\" ]; then\n        len=0\n    fi\n    echo \"$len\"",
  "  local i num\n  num=\"${#1}\"\n  for i in $(seq 0 \"${num}\"); do\n    [[ \"${1:$i:1}\"\
    \ == \"\\\"\" ]] && return 0\n  done\n  return 1", "    local STR=\"$1\"\n   \
    \ # return 0 if not given\n    [[ -z \"$STR\" ]] && return 0\n    echo \"${#STR}\"\
    \ | bc", '    echo $1 | wc -c', "  local string=$1\n  echo \"${#string}\"", '    echo
    $1 | wc -c', "    local _str=\"$1\"\n    local _len=0\n    for _i in ${_str};\
    \ do\n        _len=$((_${_str}+=${_len}))\n    done\n    echo \"${_len}\"", '  echo
    ${#1} | bc', "    local strlen=\"$1\"\n    local length=0\n    # strlen \"${strlen}\"\
    \n    while [ -n \"${strlen}\" ] ; do\n        length=$((length+1))\n        strlen=\"\
    ${strlen#?}\"\n    done\n    echo \"$length\"", "    [[ $1 ]] || return 0\n  \
    \  echo $((${#1}))", "    local length=0\n    while [  $1 ]; do\n        length=$((length+1))\n\
    \        shift\n    done\n    echo \"$length\"", "\techo \"${#1}\"", "    local\
    \ length\n    local s\n    local i=0\n    for s in \"$@\"; do\n        [[ $s =~\
    \ ^[[:space:]] ]] && continue\n        (( i++ ))\n    done\n    length=${i}\n\
    \    echo \"$length\"", "\tlocal str=$1\n\t[[ \"${str}\" != \"\" ]] && echo ${#str}",
  '    [[ $# -eq 0 ]] && return 1 || return $((${#1}))', '  expr $1 + 1', "\tlocal\
    \ __l=0\n\tlocal __i=1\n\tlocal __string=$1\n\twhile [ $__i -lt ${#__string} ]\n\
    \tdo\n\t\t__l=$((__l+1))\n\t\t__i=$((__i+1))\n\tdone\n\techo $__l", '  echo $1
    | wc -c', "  local n=0\n  local s=''\n  while ((${#1})); do s+=${1}; n=$((${n}+1));\
    \ shift; done\n  echo $n", "\tprintf '%s\\n' \"$@\" | wc -c", "  [[ -z \"$1\"\
    \ ]] && echo \"0\" && return 0\n  local len=0\n  local i # Loop index\n  for i\
    \ in \"$@\"; do # Loop through all arguments\n    (( len+=${#i} ))\n  done\n \
    \ echo \"$len\"", "    length=\"${#1}\"\n    [[ $length -ne 0 ]] && echo ${length}",
  '    echo ${#$1} # returns number of characters in string', "    local IFS='$' #\
    \ Split string on $\n    local length=0\n    for value in \"$@\"; do\n    (( ++length\
    \ ))\n    done\n    echo \"$length\"", '    echo -n "$1" | wc -c', '  echo "${#1}"',
  '    [ -n "$1" ] && echo "${#1}" || echo "0"', "    test -z \"$1\" || return 1\n\
    \    expr \"$1\" : '.*(.)'", '    echo "$1" | wc -c', '    echo $1 | wc -m', '  echo
    -n "${#1}"', '    echo $(echo "$1" | wc -w)', '    expr $(expr length "$1") +
    0', "    local length=\"${1:0:1}\"\n    while [ \"${length}\" -gt 0 ] ; do\n \
    \       length=\"${length%?}\"\n    done\n    echo \"${length}\"", '  echo ${#$1}
    | cut -d " " -f 1', "  local -i len=${#1}\n  [ $len -eq 0 ] && return 1 || return\
    \ $len", "    local length=0\n    for ((i=0; i<=${#1}; i++))\n    do\n       \
    \ let length+=${1:$i:1}\n    done\n    echo \"$length\"", "    local len=\"${#1}\"\
    \n    [ \"${#len}\" -gt 0 ] && echo ${len}", "    local string=\"$1\"\n    if\
    \ [ \"${#string}\" -eq 0 ]; then\n        echo 0\n        return 0\n    else\n\
    \        echo ${#string}\n    }", '    echo "${#1}"', "  local -r string=$1\n\
    \  [[ \"${#string}\" -gt 0 ]] || return 0\n  local len=0\n  for c in ${string//[^[:ascii:]]/};\
    \ do\n    ((++len))\n  done\n  echo $len", "  local result\n  result=\"${#1}\"\
    \n  echo \"$result\"", "  # use awk to remove trailing newlines (glenn didn't\
    \ realize they were needed)\n  # to make it work for strings containing \\0 bytes\n\
    \  awk 'END {print length}' <<< \"$1\"", "    [ -z \"$1\" ] && return 0\n    echo\
    \ -n $(echo -n \"$1\" | sed 's/^ *//g' | awk '{ print length; }')", "  expr \"\
    $#\" : '.* \\+ \\( [0-9]* \\)$'", "  echo \"$1\" | wc -l | tr -d ' '", "  local\
    \ -r string=\"$1\"\n  [[ -n \"${string:0:1}\" ]] && string=\"${string:1}\"\n \
    \ echo \"${#string}\"", "    local str=\"${1}\"\n\n    [[ -n \"$str\" ]] || return\
    \ 1\n    local len=\"${#str}\"\n    [[ $len -gt 0 ]] || return 0\n    echo $len",
  "  [[ \"$1\" =~ ^[a-zA-Z0-9_]+ ]] || return 0\n  printf '%s\\n' \"${#1}\"", "  printf\
    \ '%s' \"$1\" | wc -c", '  echo "$1" |wc -c', "    local string=\"$1\"\n\n   \
    \ local len=\"${#string}\"\n    while [ \"${string}\" ]; do\n        len=\"${len:+1}\"\
    \n        string=\"${string%?}\"\n    done\n\n    echo \"$len\"", "    set --\
    \ $1;\n    local len=0\n    while (( $# > 0 )); do\n        (( ++len )); shift\n\
    \    done\n    echo $len", "  # Check for empty string (returns 0)\n  if [[ -z\
    \ \"$1\" ]]; then\n    echo 0\n    return\n  fi\n  local len=0\n  for (( c=0;\
    \ c<${#1}; c++ )); do\n    ((len++))\n  done\n  echo $len", "    local -r str=$1\n\
    \    local -r len=${#str}\n    [[ $len -gt 0 ]] && echo ${len}", "    local i\
    \ ret=0\n    for ((i=0; i < ${#1}; i++)) ; do\n        ret =${1:$i:1}\n      \
    \  if [ \"$ret\" == \"\" ] ; then ret=0 ; else break ; fi\n    done\n    echo\
    \ \"$ret\"", "  [ $(echo \"$1\" | wc -c) -gt 0 ] || return 0\n  echo $(echo \"\
    $1\" | wc -c)"]
stop_tokens:
- "\n}"
