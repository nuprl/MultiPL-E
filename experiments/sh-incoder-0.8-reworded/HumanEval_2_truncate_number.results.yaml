language: sh
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local num=\"$1\"\n    # remove everything but digits\n    local trimmed=\"\
    ${num//[^0-9.]}\"\n    # keep only digits until decimal point\n    local decomposed_num=\"\
    ${trimmed%.*}\"\n    # trim decimal point\n    local trimmed_decimal=\"${decomposed_num#*.}\"\
    \n    # return result (decimal part)\n    echo \"$trimmed_decimal\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=\"$1\"\n  local dec=\"$2\"\n  local part=\"$3\"\n  local remainder=\"\
    $4\"\n  local decimal=\"$5\"\n\n  local ipart=\"$(( ($number / $dec) + 1 ))\"\n\
    \  local idec=\"$(( ${ipart} * $dec ))\"\n  local i=\"${ipart}\"\n  (( $dec ==\
    \ 0 )) && i=\"$(( $number + 1))\"\n\n  (( idec > dec )) && decimal=0\n  (( idec\
    \ < dec )) && decimal=1\n\n  if [ \"$i\" == \"$number\" ]; then\n    dec=$idec\n\
    \    part=$ipart\n    remainder=$number\n  else\n    (( $dec == 1 )) && decimal=$((\
    \ $dec * $ipart ))\n    (( $decimal == 0 )) && decimal=1\n    (( $part > 1 ))\
    \ && decimal=$(( ${decimal} * $part ))\n  fi\n\n  (( $decimal > 0 )) && decimal=$((\
    \ ${decimal} - 1 ))\n\n  echo \"$decimal\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpypdgksug.sh: line 17: (3.5 / ) + 1 : syntax error: invalid arithmetic
    operator (error token is ".5 / ) + 1 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\techo \"$1\" | awk '{\n\t\tn=$1;\n\t\te=0;\n\t\ts=\"\";\n\t\twhile(n < 10)\
    \ {\n\t\t\tn = n + $1;\n\t\t\ts = sprintf(\"%010d\", n%1)\n\t\t}\n\t\tfor(;;)\
    \ {\n\t\t\tn = 10;\n\t\t\twhile(n <= n) {\n\t\t\t\tn = n * 10;\n\t\t\t\te = e\
    \ + 1;\n\t\t\t}\n\t\t\ts = sprintf(\"%010d\", n%1) + s;\n\t\t\tif (e == 0)\n\t\
    \t\t\tbreak;\n\t\t}\n\t\tprint s;\n\t}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=16 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=14 encoding='utf-8'>
  timestamp: 1660058858
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local varname=$1\n  local number=${!varname}\n  local decimals=${2:-0}\n\
    \  local part\n  local sign\n  local decimal\n  local tmp\n  local i\n  local\
    \ imax\n  local imin\n  local rval\n  \n  if [ $decimals -eq 0 ]; then\n    rval=$number\n\
    \  elif [ $decimals -gt 1 ]; then\n    # Handle rounding towards zero\n    if\
    \ [ $number -eq 0 ]; then\n      decimals=0\n    elif [ $number -gt 0 ]; then\n\
    \      # Handle negative numbers\n      number=$((-number))\n      decimals=0\n\
    \      sign=\"-\"\n    fi\n  \n    # Divide the number into parts of size 10\n\
    \    for ((imax=${#number} - ${decimals}; imax >= 0; imax--)); do\n      part=${number:$imax:${#number}}\n\
    \      ((imax=imax - 1))\n      if [ \"$part\" != \"\" ]; then\n        decimal=$((10#${part}))\n\
    \        break\n      fi\n    done\n    part=${number:0:$imax}\n    decimal=$((10#${part}))\n\
    \    decimals=${decimal}\n  else\n    # Handle rounding to nearest\n    decimal=10#${number:0:${#number}}\n\
    \    decimals=${decimal}\n  fi\n  \n  # Handle rounding up/down\n  if [ $decimals\
    \ -gt $decimal ]; then\n    decimal=$((10#${number:0:${#number}}))\n  fi\n  \n\
    \  # Handle negative numbers\n  if [ $sign != \"-\" ]; then\n    sign=\"+\"\n\
    \  fi\n  \n  tmp=$(truncate_number2 \"$number\" \"$decimal\" \"$decimals\" \"\
    $sign\")\n  rval=$tmp\n  \n  return $rval\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp_e31sv_4.sh: line 12: 3.5: invalid variable name

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local integer_part=$((${number%.*}))\n  local decimal_part=${number#*.}\n\
    \  \n  \n  if (( ${integer_part} > ${number} )); then\n    decimal_part=$((${decimal_part}+1))\n\
    \  fi\n  \n  printf \"%0.*f\" \"${#decimal_part}\" \"$decimal_part\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpflg61srt.sh: line 16: ((: 3 > 3.5 : syntax error: invalid arithmetic
    operator (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal FLOAT=$1\n\tlocal INTEGER\n\tlocal DECIMALS\n\tlocal RESULT\n\tlocal\
    \ POWER\n\n\t# Break it into integer and decimals\n\tINTEGER=$(echo $FLOAT | cut\
    \ -d '.' -f 1)\n\tDECIMALS=$(echo $FLOAT | cut -d '.' -f 2)\n\n\t# Check if there\
    \ should be decimal places\n\tif [ \"$DECIMALS\" != \"0\" ] ; then\n\t\tDECIMALS=\"\
    .${DECIMALS}\"\n\tfi\n\n\t# If there are more than 2 decimals, truncate to integer\n\
    \tif [ \"$DECIMALS\" != \".\" ] && [ \"$DECIMALS\" != \"\" ] ; then\n\t\tRESULT=$FLOAT\n\
    \telse\n\t\t# Round up to the nearest integer\n\t\tRESULT=$(echo \"$INTEGER +\
    \ $DECIMALS\" | bc -l)\n\tfi\n\t\n\t# Re-add decimal places to ensure we have\
    \ only integer\n\tRESULT=$(echo \"$RESULT$DECIMALS\" | bc -l)\n\n\t# Remove excess\
    \ decimals\n\tRESULT=$(echo \"$RESULT\" | cut -d '.' -f 1-$DECIMALS)\n\n\t# Return\
    \ it\n\techo $RESULT\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "(standard_in) 1: syntax error\ncut: invalid field value \u2018.5\u2019\n\
    Try 'cut --help' for more information.\n"
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local integer\n    local decimal\n\n    # First\
    \ we check that the number is integer\n    if [[ $number =~ ^[0-9]+$ ]]; then\n\
    \        integer=$(echo \"$number\" | cut -f 1 -d \".\")\n        decimal=$(echo\
    \ \"$number\" | cut -f 2 -d \".\")\n    elif [[ $number =~ ^[0-9]+\\.[0-9]+$ ]];\
    \ then\n        integer=$(echo \"$number\" | cut -f 1 -d \".\")\n        decimal=$(echo\
    \ \"$number\" | cut -f 2 -d \".\")\n    elif [[ $number =~ ^[0-9]+\\.[0-9]+\\\
    .[0-9]+$ ]]; then\n        integer=$(echo \"$number\" | cut -f 1 -d \".\")\n \
    \       decimal=$(echo \"$number\" | cut -f 2 -d \".\")\n    elif [[ $number =~\
    \ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        integer=$(echo \"$number\"\
    \ | cut -f 1 -d \".\")\n        decimal=$(echo \"$number\" | cut -f 2 -d \".\"\
    )\n    else\n        integer=0\n        decimal=0\n    fi\n\n    # Check if integer\
    \ is bigger than the given number\n    if [[ $integer -gt $1 ]]; then\n      \
    \  integer=$1\n        decimal=0\n    fi\n\n    # Return the decimal part of the\
    \ number\n    echo \"$decimal\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpopwr33h3.sh: line 34: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local input_value\n    local output_value\n\n    input_value=${1}\n\n\
    \    case \"${input_value}\" in\n        [0-9]*)\n            output_value=$(echo\
    \ \"${input_value}\" | awk '{printf \"%.${BASH_REMATCH}f\", $1/10}')\n       \
    \     ;;\n        *)\n            output_value=\"${input_value}\"\n          \
    \  ;;\n    esac\n\n    echo \"${output_value}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: (FILENAME=- FNR=1) fatal: `$'' not permitted after period
    in format

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local number_part=0\n  local decimals=0\n  if [[ \"\
    $number\" =~ ^-?[0-9]+\\.[0-9]*$ ]]; then\n    number_part=`echo \"$number\" |\
    \ awk '{printf \"%.0f\\n\", $1}'`\n    decimals=`echo \"$number\" | awk '{printf\
    \ \".%.0f\\n\", $1}'`\n  else\n    number_part=`echo \"$number\" | awk '{printf\
    \ \"%.0f\\n\", $1}'`\n    decimals=0\n  fi\n\n  local trunc_part\n\n  trunc_part=`echo\
    \ \"$number_part\" | awk '{printf \"%.0f\", $1}'`\n  echo \"${trunc_part:0:$decimals}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_lx8nl1c.sh: line 25: trunc_part: .4: syntax error: operand expected
    (error token is ".4")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\techo \"$(python -c 'import fractions; print fractions.Fraction(\"$1\")')\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n\
    \  File \"/usr/lib/python2.7/fractions.py\", line 125, in __new__\n    numerator)\n\
    ValueError: Invalid literal for Fraction: '$1'\n"
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo $1 | awk -F. '{printf \"%.1f\\n\", $1}'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\t# Assumptions:\n\t# - number has only 2 decimals\n\t# - decimal part always\
    \ smaller than 1\n\n\t# Split number into integer and decimal part\n\tlocal -a\
    \ integer\n\tlocal -a decimal\n\tlocal -a remainder\n\tinteger =( $1 )\n\tdecimal=$((\
    \ ${integer[1]}${integer[2]}${integer[3]}${integer[4]} ))\n\tremainder=$(( ${integer[0]}${integer[1]}${integer[2]}${integer[3]}${integer[4]}\
    \ ))\n\n\t# Return decimal part of the number\n\techo \"${decimal}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "/tmp/tmp_os0d1m_.sh: line 19: syntax error near unexpected token `('\n\
    /tmp/tmp_os0d1m_.sh: line 19: `\tinteger =( $1 )'\n"
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [ -z \"$1\" ]; then\n        return 0;\n    fi\n    local number=\"\
    $1\"\n    local integer=\"$((number * 1000))\"\n    local decimal=\"$((integer\
    \ % 1000))\"\n    local decimal=\"$((decimal > 9 ? decimal - 9 : decimal))\"\n\
    \    echo \"$decimal\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpch5dw8zp.sh: line 15: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=$1\n    local DECIMALS=0\n    local TEMP_DEC=\n    local\
    \ TEMP_DEC_BIG=\n    local TEMP_DEC_SMALL=\n    local TEMP_DEC_BIG_AND_SMALL=\n\
    \    local TEMP_DEC_BIG_AND_SMALL_EQUAL=\n\n    local BIG=1\n    local SMALL=0.1\n\
    \    local BIG_AND_SMALL=1.1\n    local BIG_AND_SMALL_EQUAL=1.2\n\n    local DEC=1\n\
    \    local DEC_BIG=1\n    local DEC_SMALL=0.1\n    local DEC_BIG_AND_SMALL=1.1\n\
    \    local DEC_BIG_AND_SMALL_EQUAL=1.2\n\n    while [ \"$NUMBER\" -gt 0 ]; do\n\
    \        TEMP_DEC=$(( NUMBER % 10 ))\n        TEMP_DEC_SMALL=$(( NUMBER % 100\
    \ ))\n        TEMP_DEC_BIG=$(( NUMBER % 1000000 ))\n\n        TEMP_DEC_BIG_AND_SMALL=$((\
    \ NUMBER % 1000000000 ))\n        TEMP_DEC_BIG_AND_SMALL_EQUAL=$(( NUMBER % 1000000000000\
    \ ))\n\n        TEMP_DEC_SMALL=$(( TEMP_DEC_SMALL * 10 ))\n\n        if [ \"$NUMBER\"\
    \ -gt 10 ]; then\n            DECIMALS=$(( DECIMALS + TEMP_DEC ))\n          \
    \  NUMBER=$(( NUMBER / 10 ))\n        elif [ \"$NUMBER\" -gt 100 ]; then\n   \
    \         DECIMALS=$(( DECIMALS + TEMP_DEC_BIG ))\n            NUMBER=$(( NUMBER\
    \ / 1000000 ))\n        elif [ \"$NUMBER\" -gt 1000000 ]; then\n            DECIMALS=$((\
    \ DECIMALS + TEMP_DEC_BIG_AND_SMALL ))\n            NUMBER=$(( NUMBER / 1000000000\
    \ ))\n        elif [ \"$NUMBER\" -gt 1000000000 ]; then\n            DECIMALS=$((\
    \ DECIMALS + TEMP_DEC_BIG_AND_SMALL_EQUAL ))\n            NUMBER=$(( NUMBER /\
    \ 1000000000000 ))\n        fi\n\n        if [ \"$TEMP_DEC\" -gt \"1\" ]; then\n\
    \            DECIMALS=$(( DECIMALS + TEMP_DEC ))\n            NUMBER=$(( NUMBER\
    \ / 10 ))\n        fi\n    done\n\n    echo \"$DECIMALS\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp9naqt_6m.sh: line 30: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # Parse first argument\n  local x=$1 \n\n  # Parse second argument\n  local\
    \ decimals=$2\n\n  # Extract integer part\n  local int_part=${x:0:${#x}-10}\n\n\
    \  # Extract decimal part\n  local decimal_part=${x:${#x}-${#int_part}}\n\n  #\
    \ If decimal part is 0, return integer part\n  if [[ ${decimal_part} == 0 ]];\
    \ then\n    echo \"${int_part}\"\n  else\n    # Return rounded decimal part\n\
    \    echo \"${decimal_part}\"\n  fi\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpv6kuope7.sh: line 18: ${#x}-10: substring expression < 0

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local decimal_part\n  local integer_part\n  if [[ $(echo\
    \ \"$number\" | bc -l | awk '{ print $1 }') == *\".\"* ]]; then\n    decimal_part=$(echo\
    \ \"$number\" | sed 's/^.*\\.\\([0-9]*\\)$/\\1/')\n    integer_part=$(echo \"\
    $number\" | sed 's/^[^.]*\\.\\([0-9]*\\)$/\\1/')\n  elif [[ $(echo \"$number\"\
    \ | bc -l | awk '{ print $1 }') -le 1 ]]; then\n    decimal_part=1\n    integer_part=$(echo\
    \ \"$number\" | bc)\n  else\n    decimal_part=$(echo \"$number\" | sed 's/^[^.]*\\\
    .\\([0-9]*\\)$/\\1/')\n    integer_part=$(echo \"$number\" | sed 's/^.*\\.\\([0-9]*\\\
    )$/\\1/')\n  fi\n  echo \"$decimal_part\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimal_part=$((number % 1))\n    local truncate_part=$((number\
    \ % 10 ** 9))\n    local truncate_decimal=$((truncate_part % 10))\n    local truncated=${truncate_decimal}${truncate_part}\n\
    \    if [ \"${truncated}\" -gt 1 ]; then\n        truncated=$(echo \"$truncated\"\
    \ | bc)\n    fi\n    truncated #>&2\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpwt6rx2q2.sh: line 12: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=\"$1\"\n    local decimal=\"${number%%.*}\"\n    local decimals=\"\
    $decimal\"\n    local integer=\"${number#*.}\"\n    local integers=\"$integer\"\
    \n\n    # Round decimal part up to the next integer.\n    local decimals=${decimal%.*}\n\
    \    local decimals=$(( ${decimals}+1 ))\n\n    # Round integer part up to the\
    \ next integer.\n    local integers=${integer%.*}\n    local integers=$(( ${integers}+1\
    \ ))\n\n    # Add trailing zeros if necessary\n    local decimals=\"${decimals:1}\"\
    \n    local integers=\"${integers:1}\"\n    decimals=\"${decimals:0:$(( ${#decimals}\
    \ ))}\"\n    integers=\"${integers:0:$(( ${#integers} ))}\"\n    echo \"${decimals}.${integers}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local truncated_number\n    local decomposed_number\n\n    # Extract\
    \ integer part and fractional part\n    truncated_number=$1\n    number_part=${truncated_number%%.*}\n\
    \n    # Extract decimals\n    decomposed_number=$number_part\n    decimals=${number_part#*.}\n\
    \n    # Truncate number\n    echo \"${decomposed_number%.*}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local DECIMAL_SIZE=0 DECIMAL_VAL=0 DECIMAL_PART=0 DECIMAL_ZERO=0\n  \
    \  local NUMBER=\"$1\"\n    local NUMBER_FOUND_LEFT\n\n    echo \"$NUMBER\" |\
    \ awk -F. '{ printf(\"%.1f\", $1); printf(\"%.0d\", $2); }'\n\n    NUMBER_ZERO=$(echo\
    \ $NUMBER | awk '{ printf(\"%.0d\", $0); }')\n    NUMBER_FOUND_LEFT=$(echo $NUMBER\
    \ | awk '{ printf(\"%.0f\", $0); }')\n\n    DECIMAL_SIZE=$((NUMBER_FOUND_LEFT\
    \ % 1))\n    DECIMAL_PART=$(echo \"$NUMBER_FOUND_LEFT\" | bc | sed 's/^0*//')\n\
    \    DECIMAL_VAL=$(echo \"$NUMBER_FOUND_LEFT\" | awk '{ printf(\"%d\", (100*$1));\
    \ }')\n    DECIMAL_ZERO=$(echo \"$NUMBER_FOUND_LEFT\" | awk '{ printf(\"%d\",\
    \ (100*$0)); }')\n\n    echo\n    echo \"Truncated number\"\n    echo \"Decimal\
    \ part: $DECIMAL_PART\"\n    echo \"Decimal value: $DECIMAL_VAL\"\n    echo \"\
    Decimal zero: $DECIMAL_ZERO\"\n    echo \"Decimal size: $DECIMAL_SIZE\"\n\n  \
    \  if [ $DECIMAL_SIZE == 0 ]\n    then\n        # No decimal was found. No reason\
    \ to truncate.\n        exit 0\n    fi\n\n    # Decimal size is larger than zero,\
    \ so we definitely need to truncate.\n    NUMBER_FOUND_LEFT=$(( NUMBER_FOUND_LEFT\
    \ - DECIMAL_SIZE ))\n    echo \"Truncated number\"\n    echo \"Decimal part: $DECIMAL_PART\"\
    \n    echo \"Decimal value: $DECIMAL_VAL\"\n    echo \"Decimal zero: $DECIMAL_ZERO\"\
    \n    echo \"Decimal size: $DECIMAL_SIZE\"\n\n    exit 0\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal x\n\tx=\"$1\"\n\tlocal sign=\"\"\n\tlocal i=0\n\tlocal decimal=\"\
    \"\n\tlocal decimals=0\n\tlocal r=\"\"\n\n\tif [[ \"$x\" =~ (.*)\\.(.*)$ ]]; then\n\
    \t\tdecimal=\"${BASH_REMATCH[2]}\"\n\t\tdecimals=\"${BASH_REMATCH[1]}\"\n\tfi\n\
    \n\tif [ \"${decimal}\" -eq \"\" ]; then\n\t\treturn \"0\"\n\tfi\n\n\tcase \"\
    $x\" in\n\t\t-\\?*)\n\t\techo 1>&2 \"invalid number: $1\"\n\t\texit 1\n\t\t;;\n\
    \tesac\n\t# Decompose x into sign and digits\n\t# If x is an integer, we only\
    \ need the first digit\n\t# otherwise we also need the sign.\n\tif [[ \"$x\" =~\
    \ ^([0-9]+)(.*)$ ]]; then\n\t\tx=\"$BASH_REMATCH[1]\"\n\t\tsign=\"+\"\n\t\tdecimal=\"\
    $BASH_REMATCH[2]\"\n\tfi\n\tif [[ \"$x\" =~ ^(-?[0-9]+)$ ]]; then\n\t\tsign=\"\
    -\"\n\t\tx=\"$BASH_REMATCH[1]\"\n\tfi\n\n\t# If x is negative, we need to subtract\
    \ it before adding the decimal\n\t# part (that cannot be negative)\n\tif [[ \"\
    $sign\" == \"-\" && \"$x\" -gt 0 ]]; then\n\t\tx=\"$((-$x))\"\n\tfi\n\n\ti=\"\
    $((${#x} - 1))\"\n\t# If decimal part is zero, set it to 1\n\tif [ \"$decimal\"\
    \ -eq 0 ]; then\n\t\tdecimal=\"1\"\n\tfi\n\n\twhile [ \"$i\" -gt 0 ]; do\n\t\t\
    r=\"$decimal$r$x$((10#$((${#decimal} * $i))))\"\n\t\t(( i-- ))\n\tdone\n\n\tif\
    \ [ \"$sign\" == \"-\" ]; then\n\t\tr=\"$r-'$x\"\n\tfi\n\n\t# Add back the sign\n\
    \tr=\"$((10#$((${#r} * $i))))$r\"\n\n\t# Reverse the number\n\techo \"$r\"\n\t\
    echo \"${r#-}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpp7qc6z5q.sh: line 24: [: : integer expression expected

    /tmp/tmpp7qc6z5q.sh: line 55: [: 3.5[2]: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local input_num=\"$1\"\n  # Get input number as integer part\n  input_num=\"\
    ${input_num%?}\"\n  # Get decimal part\n  input_num=\"${input_num%.}\"\n  # Now\
    \ we need to check if integer part is greater than\n  # largest possible int (2**31)-1\n\
    \  if [ $input_num -gt 2147483647 -o $input_num -le -2147483648 ]; then\n    echo\
    \ \"$input_num\"\n  else\n    # Return 0 here\n    truncate_number=\"0\"\n  fi\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if [ -z \"$1\" ]; then\n    echo 1\n  else\n    truncate_number=\"${1}\"\
    \n    if [ \"$(echo \"$truncate_number\" | bc)\" -eq 1 ]; then\n      echo \"\
    $truncate_number\"\n    else\n      echo $(echo \"$truncate_number\" | bc -l)\n\
    \    fi\n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp0p8i5oek.sh: line 15: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local integer=$(echo \"$number\" | grep -oP '\\\
    d+' | tail -n1)\n    local decimal=$(echo \"$number\" | grep -oP '\\.\\?\\d+')\n\
    \    if [ -z \"$decimal\" ];\n    then\n        decimal=\"\"\n    else\n     \
    \   decimal=${decimal%?}\n    fi\n    \n    echo \"$integer $decimal\"\n}\n\n\
    candidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # https://askubuntu.com/questions/334277/how-do-i-trim-decimal-part-of-a-number-in-shell\n\
    \  local string=\"$1\"\n  local num=\"${string#*.}\"\n  num=\"${num%.}\"\n  echo\
    \ \"${num}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$(echo \"$1\" | sed 's/^\\([0-9]*\\.[0-9]*\\)\\..*/\\1/')\"\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local trunc_num=\"${1%.*}\"\n  local trunc_num_int=\"${trunc_num#*.}\"\n\
    \  local decimal=\"${trunc_num%%.*}\"\n  local decimal_int=\"${decimal#*.}\"\n\
    \  if [[ ${trunc_num_int} = \"${trunc_num}\" ]]; then\n    trunc_num_int=0\n \
    \   decimal=\".0\"\n  fi\n  if [[ ${decimal_int} = \"${decimal}\" ]]; then\n \
    \   decimal_int=0\n  fi\n  printf \"%d${decimal}%d\" ${trunc_num_int} ${decimal_int}\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local floating_point floating_point_string decimal_number max_int_part\
    \ remaining_part num_truncating\n    floating_point=\"$1\"\n    if ! [[ $floating_point\
    \ =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        echo \"$floating_point is not a valid\
    \ floating point\" >&2\n        return 1\n    fi\n    floating_point_string=\"\
    $floating_point\"\n    decimal_number=\"0\"\n    num_truncating=\"2\"\n    max_int_part=\"\
    $((${#floating_point} - 1))\"\n    remaining_part=\"$floating_point\"\n    while\
    \ [[ $num_truncating -gt 0 ]]; do\n        remaining_part=\"$(remaining_part -\
    \ $decimal_number)\"\n        if [[ $remaining_part -gt \"1\" ]]; then\n     \
    \       decimal_number=\"$decimal_number$decimal_point\"\n        fi\n       \
    \ num_truncating=\"$((num_truncating - 1))\"\n    done\n    decimal_number=\"\
    $decimal_number$decimal_point\"\n    echo \"${decimal_number}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp83i0ad1d.sh: line 23: remaining_part: command not found

    /tmp/tmp83i0ad1d.sh: line 23: remaining_part: command not found

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimals=${2:-0}\n\n    if [[ \"$decimals\"\
    \ -lt 0 ]]; then\n        decimals=0\n    fi\n    local truncate_number\n    local\
    \ num\n    local decimal\n    local int\n\n    # Find a smaller integer\n    if\
    \ [[ \"$number\" =~ ^[0-9]+$ ]]; then\n        int=\"$number\"\n    else\n   \
    \     int=0\n        truncate_number=\"$number\"\n        until [[ \"$number\"\
    \ =~ ^[0-9]+$ ]]; do\n            int=\"$int\"\n            truncate_number=\"\
    $truncate_number\"\n        done\n    fi\n    num=$(echo \"$truncate_number\"\
    \ | sed -e 's/^.//' -e 's/[^0-9]//g')\n    if [[ $num == 0 ]]; then\n        decimal=0\n\
    \    else\n        decimal=$(echo \"$truncate_number\" | sed -e 's/^[^0-9]//'\
    \ -e 's/^.//')\n    fi\n    if [[ $decimal == 0 ]]; then\n        decimals=0\n\
    \    else\n        decimals=$(echo \"$decimal\" -1 | bc)\n    fi\n    echo $(echo\
    \ \"$num * 10^$decimals\" + 1)\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=40 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=15 encoding='utf-8'>
  timestamp: 1660058858
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local float=$1\n    if [[ $float == *[!0-9.]* ]]; then\n        echo\
    \ \"invalid float $float\"\n        exit 1\n    fi\n    local decimals=$(( ${#float}\
    \ - $(decimal_pos $float) + 1 ))\n    local intpart=$(decimal_pos $float)\n  \
    \  if [[ ${decimals} == 0 ]]; then\n        echo \"0\"\n    elif [[ ${decimals}\
    \ == 1 ]]; then\n        echo \"$float\"\n    elif (( decimals > 0 )) && \\\n\
    \        (( decimals < 10 )); then\n        echo \"${float%.*$decimals}.0\"\n\
    \    else\n        echo \"${float%.*$decimals}\"\n    fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp3d0u67jl.sh: line 16: decimal_pos: command not found

    /tmp/tmp3d0u67jl.sh: line 17: decimal_pos: command not found

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal x\n\tlocal num_int\n\tx=\"$1\"\n\tx=\"$(x%1)\"\n\tx=\"$(x%1)\"\n\t\
    num_int=\"$(( (x/10)))\"\n\tnum_int=\"$(( num_int*10 ))\"\n\tnum_int=\"$(( num_int\
    \ + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"$((\
    \ num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_int%1 ))\"\n\tnum_int=\"$(( num_int + num_int%1 ))\"\n\tnum_int=\"\
    $(( num_int + num_\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpu_elo_0e.sh: line 46: unexpected EOF while looking for matching
    `)''

    /tmp/tmpu_elo_0e.sh: line 61: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$1\" | awk '{\n    split($1, a, \"/\")\n    b=a[1]*10 + a[2]\n \
    \   a[1]=b - int(b)\n    a[2]=a[1] - int(a[1])\n    print a[1]\n  }'\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    if [[ $number =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n\
    \        local integer=\"${number%.*}\"\n        local decimal=\"${number#*.}\"\
    \n        if [[ $integer -lt $1 ]]; then\n            local result=\"${integer}\"\
    \n        else\n            local result=\"${decimal}\"\n        fi\n    else\n\
    \        local result=\"\"\n    fi\n    echo $result\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpq6ari30r.sh: line 15: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local NUMBER=\"$1\"\n  local DECIMALS=0\n  local DECIMAL=0\n  local NEXT_POINTING\n\
    \  local NEXT_DECIMAL\n  local NEXT_NUMBER\n\n  NEXT_NUMBER=$(( NUMBER % 1 ))\n\
    \  DECIMALS=$(($NUMBER % 1))\n  if [ -z \"$DECIMALS\" ]; then\n    DECIMAL=1\n\
    \  else\n    DECIMAL=$(($DECIMALS - 1))\n  fi\n  NEXT_POINTING=$(( NUMBER / $DECIMAL\
    \ ))\n  NEXT_DECIMAL=$(($NEXT_POINTING % 1))\n\n  echo \"${NUMBER:0:$DECIMAL}${NEXT_NUMBER:0:1}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpob7rrvjm.sh: line 18: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=\"${1}\"\n    local part=\"${number%%.*}\"\n    local decimal=\"\
    ${number##*.}\"\n    if [[ -z \"$decimal\" ]] ; then\n        decimal=\"0\"\n\
    \    fi\n    echo \"$part $decimal\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local FLOOR\n  FLOOR=$1\n  local STR_VAL\n  STR_VAL=\"$((FLOOR + 0*$1))\"\
    \n  local STR\n  STR=\"${STR_VAL%.*}\"\n  echo \"$STR\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp9c3ko1gw.sh: line 14: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local integer_part=$(echo \"${number}\" | sed -e \"\
    s/^\\([0-9]*\\)\\..*$/\\1/\")\n  local decimals=$(echo \"${number}\" | sed -e\
    \ \"s/^\\([0-9]*\\).*$/\\1/\")\n  if [ \"$decimals\" -gt 0 ]; then\n    echo \"\
    ${decimals}\"\n  else\n    echo \"${integer_part}\"\n  fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local intpart=$2\n  local decimals=$3\n  local decimalpart=$((\
    \ $decimals + 1 ))\n  local newintpart=$(( $intpart - $decimalpart ))\n  if [\
    \ $newintpart -eq $intpart ]; then\n    return $number\n  fi\n  local tmp=\"$decimalpart\"\
    \n  while [ $tmp -lt 10 ]; do\n    (( tmp++ ))\n    decimalpart=$(( $decimalpart\
    \ + 1 ))\n  done\n  decimalpart=$(( $decimalpart + 1 ))\n  local final=\"$number%.$decimalpart\"\
    \n  (( $decimals > 0 )) && local final=\"$final.$decimalpart\"\n  (( $decimals\
    \ > 1 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 2 )) && local\
    \ final=\"$final.$decimalpart\"\n  (( $decimals > 3 )) && local final=\"$final.$decimalpart\"\
    \n  (( $decimals > 4 )) && local final=\"$final.$decimalpart\"\n  (( $decimals\
    \ > 5 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 6 )) && local\
    \ final=\"$final.$decimalpart\"\n  (( $decimals > 7 )) && local final=\"$final.$decimalpart\"\
    \n  (( $decimals > 8 )) && local final=\"$final.$decimalpart\"\n  (( $decimals\
    \ > 9 )) && local final=\"$final.$decimalpart\"\n  (( $decimals > 10 )) && local\
    \ final=\"$final.$decimalpart\"\n  local final2=$(( $final + 1 ))\n  (( $final2\
    \ > 100 )) && local final2=$(( $final2 + 10 ))\n  (( $final2 > 1000 )) && local\
    \ final2=$(( $final2 + 100 ))\n  (( $final2 > 10000 )) && local final2=$(( $final2\
    \ + 1000 ))\n  (( $final2 > 100000 )) && local final2=$(( $final2 + 10000 ))\n\
    \  (( $final2 > 1000000 )) && local final2=$(( $final2 + 100000 ))\n  (( $final2\
    \ > 10000000 )) && local final2=$(( $final2 + 1000000 ))\n  (( $final2 > 100000000\
    \ )) && local final2=$(( $final2 + 10000000 ))\n  (( $final2 > 1000000000 )) &&\
    \ local final2=$(( $final2 + 100000000\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpe2qxqyz6.sh: line 45: unexpected EOF while looking for matching
    `)''

    /tmp/tmpe2qxqyz6.sh: line 60: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    echo \"$1\" | awk '{print $1%1?$1%1:\"0\"}'\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local x=\"$1\"\n  # if input is a valid number\n  if [[ \"${#x}\" -gt 0\
    \ ]]; then\n    # remove trailing zeroes and check if there is decimal part left\n\
    \    x=\"${x%.*}\"\n    local decimal=\"${x##*.}\"\n    if [[ \"${decimal}\" -gt\
    \ 1 ]]; then\n      echo \"${decimal}\"\n    else\n      echo \"0\"\n    fi\n\
    \  else\n    echo \"0\"\n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local value=$1\n  echo \"${value%.*}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local dec\n    local integer\n    local tmp\n\n    integer=$(echo \"\
    $1\" | sed 's/^\\([0-9.]*\\)$/\\1/')\n    if [ -z \"$integer\" ] ; then\n    \
    \    echo 1\n        return 0\n    fi\n    dec=$(echo \"$1\" | sed 's/^[0-9]*\\\
    .\\([0-9]*\\)$/\\1/')\n    if [ -z \"$dec\" ] ; then\n        echo 0\n       \
    \ return 0\n    fi\n    decimals=$(echo \"$1\" | sed 's/^[0-9]*\\.\\([0-9]*\\\
    )$/\\1/')\n    if [ \"$decimals\" -gt 0 ] ; then\n        echo 1\n        return\
    \ 0\n    fi\n\n    integer=$(echo \"$integer\" | bc)\n    dec=$(echo \"$dec\"\
    \ | bc)\n    tmp=$(echo \"$integer $dec\")\n    decimals=$(echo \"$tmp\" | bc)\n\
    \n    echo \"$tmp\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal NUMBER=$1\n\tlocal INTEGER=100000000000\n\tlocal DECIMALS=0\n\tlocal\
    \ DECIMAL_DIGITS=${2:-0}\n\n\tcase \"$NUMBER\" in\n\t\t# no floating point, nothing\
    \ to do\n\t\t[0-9]) ;;\n\t\t# integer part\n\t\t[0-9]*)\n\t\t\tINTEGER=$(($NUMBER\
    \ / $INTEGER))\n\t\t\t# integer part is smaller\n\t\t\tif [ \"$INTEGER\" -gt \"\
    $NUMBER\" ]; then\n\t\t\t\tDECIMALS=$(($DECIMAL_DIGITS - $DECIMALS))\n\t\t\tfi\n\
    \t\t\tDECIMALS=$(($DECIMALS + 0))\n\t\t\t;;\n\t\t# decimal part\n\t\t*.[0-9]*)\n\
    \t\t\tDECIMALS=$(($DECIMAL_DIGITS - $DECIMALS))\n\t\t\t;;\n\t\t# decimal part\
    \ is smaller\n\t\t*.[0-9]*[1-9])\n\t\t\tDECIMALS=$(($DECIMALS + 0))\n\t\t\t;;\n\
    \tesac\n\techo \"${NUMBER%.*$DECIMALS}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpto_lvzh5.sh: line 21: 3.5 / 100000000000: syntax error: invalid
    arithmetic operator (error token is ".5 / 100000000000")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local float=$1\n    if [[ $float == +([[:digit:]]*\\.?[[:digit:]]+([eE][-+]?[[:digit:]]+)?)[[:digit:]]*\
    \ ]]; then\n        local int_part=${float%%.*}\n        local decimal_part=${float#*.}\n\
    \        local decimal_part_len=$(expr length \"$decimal_part\")\n        if [[\
    \ $decimal_part_len == 0 ]]; then\n            return 0\n        elif [[ $decimal_part_len\
    \ > 2 ]]; then\n            echo \"Truncated decimal part has too many digits\
    \ to display\"\n            return 0\n        fi\n        echo \"$int_part.$decimal_part\"\
    \n    else\n        echo \"$float is not a positive floating point number\"\n\
    \    fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal n=\"$1\"\n\tlocal dec=\"$(echo \"$n\" | awk '{print $1}')\"\n\tlocal\
    \ int_part=\"$(echo \"$n\" | awk '{print $2}')\"\n\tlocal leftover_part=\"$(echo\
    \ \"$n\" | awk '{print $3}')\"\n\techo \"$(( $leftover_part / 10 ))\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpp9r_4tr4.sh: line 15: / 10 : syntax error: operand expected (error
    token is "/ 10 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [ \"$1\" = '--help' ]; then\n        echo \"Truncates decimal part\
    \ of a floating point number.\"\n        echo 'Usage: '\n        echo \"$0 <float>\"\
    \n        exit 1\n    fi\n    # $1 is a floating point\n    echo $1 | perl -pe\
    \ 's/^(-?\\d*\\.?\\d*)(\\.\\d+)$/\\1/'\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local NUMBER=\"$1\"\n  local DECIMAL\n  DECIMAL=\"${NUMBER%%.*}\"\n  DECIMAL=\"\
    ${DECIMAL:1}\"\n  NUMBER=\"${NUMBER#$DECIMAL}\"\n  echo \"${NUMBER}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=${1}\n    local decimal=${2-0}\n    if [[ ${decimal} ==\
    \ 0 ]]; then\n        echo \"${number}\"\n        return\n    fi\n    local integer=${number%%.*}\n\
    \    local remainder=${number#*.}\n    echo $(( ${integer} + ${decimal} ))\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local val=$1\n  local tmp\n  local decimals=0\n  tmp=${val}\n  val=`echo\
    \ \"$val\" | awk '{print $1}'`\n  tmp=${tmp}\n  if [[ $val =~ ^-?[0-9]+ ]]; then\n\
    \    decimals=`echo \"$val\" | awk '{print length($1)}'`\n  fi\n  echo ${val:0:$decimals}\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=\"$1\"\n    local decimal_point\n    local decimal_points=\"\
    $2\"\n\n    if [ \"${number}\" == \"-\" ]; then\n        echo \"-\"\n        return\
    \ 0\n    fi\n\n    if [ -z \"$decimal_points\" ]; then\n        decimal_points=\"\
    0\"\n    fi\n\n    decimal_point=$(echo $decimal_points | tr '[:upper:]' '[:lower:]')\n\
    \n    if [ \"$decimal_point\" == \"i\" ]; then\n        decimal_points=\"0\"\n\
    \        ;;\n    *)\n        ;;\n    esac\n\n    local i\n    local digits\n \
    \   local digit_count\n\n    if [ \"${decimal_points}\" == \"0\" ]; then\n   \
    \     echo \"0\"\n        return 0\n    fi\n\n    digits=${#number} # Length of\
    \ the number\n\n    # First determine if we have decimals or not\n    if [ \"\
    $decimal_point\" == \".\" ]; then\n        digits=${#number} # Length of the number\n\
    \        decimal_points=\"${decimal_points}0\"\n    fi\n\n    # Get the first\
    \ digit\n    i=$(( digits - decimal_points ))\n\n    # Split the number into two\
    \ parts, the first part will include\n    # decimals, the second part does not.\n\
    \    # Decimal part will always have lesser number than decimals\n    local j\n\
    \    j=$(( i - decimal_points ))\n\n    # If the first digit is greater than the\
    \ decimals, we can discard\n    # the decimal part as it will not be needed.\n\
    \    if [ \"$i\" -gt \"$j\" ]; then\n        echo \"0\"\n        return 0\n  \
    \  fi\n\n    local decimal_part\n    decimal_part=${number:$j:$j}\n    local int_part\n\
    \    int_part=${number:0:$i}\n    local result\n\n    # If the first digit is\
    \ an integer we only return the decimal part\n    # as it will not include any\
    \ decimals.\n    if [ \"$decimal_point\" == \".\" ]; then\n        echo \"$decimal_part\"\
    \n        return 0\n    fi\n\n    # If the first digit is larger than the decimals,\
    \ we add one to the\n    # decimal part as it will not include any decimals.\n\
    \    if [ \"$i\" -gt \"$decimal_points\" ]; then\n        decimal_part=\"$decimal_part.0\"\
    \n        int_part=\"$int_part.0\"\n    fi\n\n    # If the integer part contains\
    \ no decimals, we discard it\n    if [ \"$int_part\" == \"\" ]; then\n       \
    \ int_part=\"0\"\n    fi\n\n    # If the decimal part contains no decimals, we\
    \ discard it\n    if [ \"$decimal_part\" == \"\" ]; then\n        decimal_part=\"\
    0\"\n    fi\n\n    # Build the result\n    result=\"$int_part.$decimal_part\"\n\
    \n    local digits\n    digits=${#result}\n\n    if [ \"$decimal_\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpkc11w7v_.sh: line 28: syntax error near unexpected token `;;''

    /tmp/tmpkc11w7v_.sh: line 28: `        ;;''

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal trunc_number=$1\n\tlocal trunc_number_in_int=$((trunc_number%1))\n\
    \tlocal trunc_number_in_frac=$((trunc_number_in_int*10))\n\tlocal trunc_number_in_frac_power=$((trunc_number_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_int=$((trunc_number_in_frac_power%1))\n\t\
    local trunc_number_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac*10))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_int=$((trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power%1))\n\
    \tlocal trunc_number_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac_power_in_frac=$((trunc_number_in_frac_\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpwhcnxp7g.sh: line 28: unexpected EOF while looking for matching
    `)''

    /tmp/tmpwhcnxp7g.sh: line 43: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local value=$1\n  local intpart=$(\n    (\n    local intpart\n    local\
    \ decimalpart\n\n    IFS='.' read -r -a decimal <<< \"$value\"\n    for i in \"\
    ${!decimal[@]}\"; do\n      ((decimalpart++))\n    done\n    IFS=+ read -r -a\
    \ intpart <<< \"$value\" <<< \"0.$decimalpart\"\n\n    echo \"${intpart[@]}\"\n\
    \    )\n  )\n  echo \"${intpart}\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local i\n\n    echo $(\n        while [ $1 -gt 0 ]; do\n            i=$((\
    \ ${1/%.*}+1 ))\n            [ $i -eq 0 ] && break\n            echo ${1%.*}\n\
    \            shift\n        done\n    )\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpk70ettdr.sh: line 21: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\ttruncate_number_helper\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpyehhfew4.sh: line 11: truncate_number_helper: command not found

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if ! [[ $1 =~ ^[+-]?[0-9]+\\.[0-9]+$ ]]; then\n    echo \"Truncate failed:\
    \ $1 is not a valid floating number\"\n    exit 1\n  fi\n\n  truncate_number=\"\
    $(echo $1 | awk '{printf \"%.2f\", $1;}')\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=\"${1}\"\n    local INTEGER=\"\"\n    local DECIMAL=\"\"\
    \n    local MAX_INT=0\n    local DECIMALS=0\n    local DECIMAL_DIGITS\n\n    #\
    \ Split number in parts separated by dots\n    local NUMBER_PARTS=(${NUMBER//./\
    \ })\n\n    # Decompose the number\n    for (( index = 0; index < ${#NUMBER_PARTS[@]};\
    \ ++index )); do\n        local NUMBER_PART=\"${NUMBER_PARTS[$index]}\"\n    \
    \    case \"${NUMBER_PART}\" in\n            [0-9]*)\n                # Extract\
    \ decimal portion of number\n                DECIMAL=\"${NUMBER_PART}\"\n    \
    \            DECIMALS=${#DECIMAL}\n                DECIMAL_DIGITS=${#DECIMAL_DIGITS}\n\
    \                ;;\n            *)\n                # Store the integer part\n\
    \                INTEGER=\"${INTEGER}${NUMBER_PART}\"\n                ;;\n  \
    \      esac\n    done\n\n    # Get the maximum integer part\n    if [ \"${MAX_INT}\"\
    \ = \"0\" ]; then\n        MAX_INT=$(echo \"${INTEGER}${DECIMAL}\" >/dev/null\
    \ 2>&1)\n    fi\n\n    # Convert fractional part to integer\n    local FLOAT=\"\
    ${DECIMAL}\"\n    local EXPONENT_FLOAT=\"${DECIMALS}\"\n\n    # Convert decimal\
    \ part to integer\n    while (( EXPONENT_FLOAT > 0 )); do\n        FLOAT=\"$(echo\
    \ \"${FLOAT}0\" >/dev/null 2>&1)\"\n        EXPONENT_FLOAT=\"${EXPONENT_FLOAT}\"\
    \n    done\n    local INTEGER_PART=\"${INTEGER}${FLOAT}\"\n\n    # Return integer\
    \ part\n    echo \"${INTEGER_PART}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=32 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=21 encoding='utf-8'>
  timestamp: 1660058858
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local float_str=\"$1\"\n    local integer decimals\n\n    if [[ \"$float_str\"\
    \ =~ ^[0-9]+\\.[0-9]*$ ]]; then\n        integer=\"$(echo \"$float_str\" | cut\
    \ -d \".\" -f1)\"\n        decimals=\"$(echo \"$float_str\" | cut -d \".\" -f2)\"\
    \n    else\n        integer=\"0\"\n        decimals=\"0\"\n    fi\n\n    if [[\
    \ ${decimals} -lt 1 ]]; then\n        decimals=\"0\"\n    fi\n\n    truncate_result=\"\
    $((integer + $decimals))\"\n    echo \"$truncate_result\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$1\" | awk '{\n    n = $1;\n    t = n;\n    m = 0;\n    while(t\
    \ > 1 && m <= 6) {\n      m = m+1;\n      t = t / 10;\n    }\n    print t;\n \
    \ }'\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if [[ $1 =~ ^[0-9]*\\.[0-9]*$ ]]; then\n    local decimal_part=\"${BASH_REMATCH[1]}\"\
    \n    local trunc_part=\"${truncate_part($decimal_part)}\"\n    local trunc_decimal=\"\
    ${trunc_part}.0\"\n    echo $trunc_decimal\n  else\n    echo \"$1\"\n  fi\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpibpu9bom.sh: line 13: ${truncate_part($decimal_part)}: bad substitution

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal number=\"${1}\"\n\tlocal sign=\"\"\n\tlocal decimals=0\n\tlocal decimal_part=0\n\
    \n\tif [ \"$number\" -ge 0 ]; then\n\t\tdecimals=$(( $( echo \"$number\" | bc\
    \ -l ) )); \n\t\tdecimal_part=$(( $( echo \"$number\" | bc -l ) ))\n\tfi\n\n\t\
    local trunc_number=\"${decimals}.${decimal_part}\"\n\tcase \"$decimal_part\" in\n\
    \t\t1)\n\t\t\tsign=\"-\"\n\t\t\tdecimals=0\n\t\t\t;;\n\t\t2)\n\t\t\tsign=\"\"\n\
    \t\t\tdecimals=0\n\t\t\t;;\n\tesac\n\t\n\techo \"${sign}${trunc_number}\"\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpx7t4mtz6.sh: line 16: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local input=${1}\n    local decimal_point=\n    local integer_part=\n\
    \    local truncated_integer_part=\n    local decimal_part_length=\n    local\
    \ input_integer=\n\n    # remove trailing zeros in decimal part\n    # e.g. 0.123\
    \ => 0.1\n    # e.g. 1.123 => 1.1\n    # e.g. 3.456 => 3.45\n    local truncated_decimal_part=${input%.*}\n\
    \n    # find decimal part\n    decimal_point=`echo \"${truncated_decimal_part}\"\
    \ | awk '{print index($0, \".\")}'`\n\n    # find integer part\n    integer_part=`echo\
    \ \"${truncated_decimal_part}\" | awk '{print index($0, \".\") - 1}'`\n\n    #\
    \ find decimal part length\n    decimal_part_length=`echo \"${truncated_decimal_part}\"\
    \ | awk '{print length($0)}'`\n\n    # split integer part and decimal part in\
    \ two separate variable\n    input_integer=`echo \"${input}\" | awk -v dec=${decimal_part_length}\
    \ '{print substr($0, dec, length($0))}'`\n\n    # remove leading zeros from integer\
    \ part\n    # e.g. 01 => 1\n    # e.g. 02 => 2\n    # e.g. 10 => 10\n    input_integer=${input_integer#0}\n\
    \n    # remove decimal part if input is whole number\n    # e.g. 0 => 0\n    #\
    \ e.g. 1 => 1\n    if [ -z \"$input_integer\" ]; then\n        decimal_part=''\n\
    \        integer_part=${input_integer}\n        truncated_integer_part=''\n  \
    \  else\n        decimal_part=${input%%.*}\n        integer_part=${input_integer}\n\
    \        truncated_integer_part=${input_integer%.*}\n    fi\n\n    # remove trailing\
    \ zeros from decimal part\n    # e.g. 0.1 => 0.1\n    # e.g. 1.1 => 1.1\n    #\
    \ e.g. 3.45 => 3.45\n    decimal_part=${decimal_part%.*}\n\n    if [ \"$decimal_point\"\
    \ -eq \"0\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$decimal_point\" -eq \"1\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$decimal_point\" -eq \"$decimal_part_length\" ]; then\n        truncate_number='${truncated_integer_part}'\n\
    \    elif [ \"$integer_part\" -lt \"$decimal_point\" ]; then\n        truncate_number='${truncated_integer_part}.${truncated_decimal_part}'\n\
    \    elif [ \"$integer_part\" -ge \"$decimal_point\" ]; then\n        truncate_number='${truncated_integer_part}'\n\
    \    else\n        truncate_number='${truncated_integer_part}.'\n    fi\n\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local decimal_part integer_part=$1\n    if [[ $decimal_part -eq 0 ]];\
    \ then\n        return 0\n    fi\n    local i decimals=${decimal_part//+([0-9])}\n\
    \    local j\n    while ((j=${decimals}-1)>0; do\n        decimals=${decimals//[0-9]}\n\
    \    done\n    local k\n    k=$((${decimals}-1))\n    while ((k>=0)); do\n   \
    \     integer_part=$((integer_part*10+$((10^k))))\n        k=$((k-1))\n    done\n\
    \    local k\n    k=0\n    while ((k<${decimals})); do\n        integer_part=$((integer_part*10+$((10^k))))\n\
    \        k=$((k+1))\n    done\n    echo $integer_part\n}\n\ncandidate() {\n  \
    \  truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpp8o8lgvd.sh: line 17: syntax error near unexpected token `do''

    /tmp/tmpp8o8lgvd.sh: line 17: `    while ((j=${decimals}-1)>0; do''

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  # First check, if the floating point number consists\
    \ of a single digit.\n  # This would fail for example with 2.9999999999999997\n\
    \  [[ \"$number\" =~ ^[0-9]+\\.[0-9]+$ ]] || return 1\n  # Now, split the floating\
    \ point number into decimal and integer parts\n  # using the shell parameter expansion.\n\
    \  local integer=\"${number%%%.*}\"\n  local decimal=\"${number#*%.}\"\n  # Now,\
    \ check if the floating point number is a single integer or not.\n  # If it is\
    \ a single integer, we cannot use the integer part for\n  # rounding. Thus, we\
    \ use the integer part and set it to 0.\n  [[ $integer -eq 1 ]] || integer=0\n\
    \  # Now, check if the floating point number is smaller than the precision we\
    \ want.\n  # If it is, we simply return it unchanged.\n  [[ $decimal -le $1 ]]\
    \ || return \"$number\"\n  # If the floating point number is not smaller than\
    \ the precision, we round it\n  # using the integer part and set the decimal part\
    \ to 0.\n  local rounded_number=$(( $decimal+$integer ))\n  local rounded_number=$((\
    \ $rounded_number % $1 ))\n  # Now, add the rounding up if it did not round down\
    \ to 0.\n  rounded_number=$(( $rounded_number + 1 ))\n  # Now, return the rounded\
    \ number.\n  printf \"%0.${decimal}f\" $rounded_number\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpih10z4_u.sh: line 22: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    /tmp/tmpih10z4_u.sh: line 25: [[: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    /tmp/tmpih10z4_u.sh: line 25: return: 3.5: numeric argument required

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal trunc_string=$1\n\t# Cut off trailing zeros. If input is \"2.00\"\
    , cut off \"2\"\n\tlocal trunc_string=$(echo \"${trunc_string}\" | sed 's/^0*\\\
    .\\([0-9]*\\)$/\\1/')\n\tlocal trunc_int=$(echo \"${trunc_string}\" | cut -d.\
    \ -f1)\n\tlocal trunc_dec=$(echo \"${trunc_string}\" | cut -d. -f2)\n\t# Check\
    \ if decimal part is < 1\n\tif [ -z \"${trunc_dec}\" ] || [ \"${trunc_dec}\" -lt\
    \ 1 ]; then\n\t\ttrunc_dec=\"0.000000001\"\n\tfi\n\t# Add \".0\" before decimal\
    \ part\n\ttrunc_dec=$(\"${trunc_dec}\" printf \"%.0f\")\n\t\n\t# Check if decimal\
    \ part is == 0\n\tif [ -z \"${trunc_dec}\" ] || [ \"${trunc_dec}\" = \"${trunc_int}\"\
    \ ]; then\n\t\ttrunc_dec=\"0\"\n\tfi\n\t# Append \".\" to decimal part\n\ttrunc_dec=\"\
    ${trunc_dec}.0\"\n\t\n\techo \"${trunc_int}${trunc_dec}\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpwqzi54l5.sh: line 21: 5: command not found

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # Convert $1 into an integer and truncate to nearest multiple of 10\n \
    \ local x=\"$1\"\n  local y=$(echo \"$x%0.1\" | bc)\n  local i\n  i=$((y%10))\n\
    \  y=$((y/10))\n  i=$((i+x))\n  y=$((y+i))\n  echo \"$y%.01\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbqkr7ovs.sh: line 17: 3.5: syntax error: invalid arithmetic operator
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=$1\n    local MAX_FRACTIONAL_DIGITS=$(echo \"$NUMBER\" |\
    \ jq '.'.\"1\")\n    local MIN_DECIMALS=$(echo \"$NUMBER\" | jq '.'.\"0\")\n \
    \   local MAX_DECIMALS=1\n    local DECIMAL_POINT=$(echo \"$NUMBER\" | jq '.'.\"\
    1\")\n\n    if [[ $MAX_FRACTIONAL_DIGITS == $MIN_DECIMALS ]]; then\n        MAX_DECIMALS=$MAX_FRACTIONAL_DIGITS\n\
    \    elif [[ $MAX_FRACTIONAL_DIGITS > $MIN_DECIMALS ]]; then\n        MAX_DECIMALS=$MIN_DECIMALS\n\
    \    elif [[ $MAX_FRACTIONAL_DIGITS < $MIN_DECIMALS ]]; then\n        MAX_DECIMALS=$MAX_FRACTIONAL_DIGITS\n\
    \    fi\n    local DECIMAL_NUMBER=$(echo \"$DECIMAL_POINT\" | jq \".\".\"$MAX_DECIMALS)\n\
    \n    echo \"$DECIMAL_NUMBER\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmph8nhojm9.sh: line 37: unexpected EOF while looking for matching
    `"''

    /tmp/tmph8nhojm9.sh: line 41: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # echo \"$1\" | awk '{print $1/$2}'\n    # echo \"${1%%.*}\"\n    expr\
    \ \"$1\" : '.*[.]([0-9]*)$'\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=\"$1\"\n  local integer decimal leftover\n  integer=\"${number%.*}\"\
    \n  leftover=\"${number#*.}\"\n  if [ -z \"$leftover\" ]; then\n    decimal=\"\
    $integer\"\n  else\n    decimal=\"$integer$decimal\"\n  fi\n  echo \"$decimal\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo $(echo \"scale=0;$1\" | bc)\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$1\" | awk '{print $1-2}';\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=$1\n    local DECIMAL=`echo \"$NUMBER\" | sed -e 's/\\.//g'`\n\
    \    local NUMBER_INT=`echo \"$DECIMAL\" | awk '{print $1/1}'`\n    if [[ $NUMBER\
    \ == $NUMBER_INT ]]; then\n        DECIMAL=\"1\"\n    fi\n    echo \"$NUMBER_INT$DECIMAL\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=\"${1}\"\n    local PART_OF=\"$(( ${NUMBER} \\% 1 ))\"\n\
    \    local DECIMALS=\"$(( ${NUMBER} * 10 ))\"\n    local DECIMAL_PART=\"${PART_OF}\"\
    \n    if [ \"${PART_OF}\" -ge \"0\" ]; then\n        local DECIMAL_PART=\"${PART_OF}\"\
    \n    else\n        local DECIMAL_PART=\"${DECIMALS}\"\n    fi\n    echo $DECIMAL_PART\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpirxin_4x.sh: line 12: 3.5 \% 1 : syntax error: invalid arithmetic
    operator (error token is ".5 \% 1 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local int_part=$(echo \"$number\" | awk '{ split($0,arr,\"\
    \\.\"); print arr[1]}')\n  local decimal_part=$(echo \"$number\" | awk '{ split($0,arr,\"\
    .\"); print arr[2]}')\n  local final_number=$int_part$decimal_part\n  echo ${final_number%.*}\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'awk: cmd. line:1: warning: escape sequence `\.'' treated as plain `.''

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local n=\"$1\"\n    local d=0\n    local ipart\n\n    while [[ $n -gt\
    \ 1 ]]; do\n        (( n /= 10 ))\n        (( d += 1 ))\n    done\n\n    # Truncate\
    \ decimals\n    (( d -= 1 ))\n\n    # Find the integer part\n    ipart=$(( $n\
    \ / 10 ))\n\n    # Round integer part down\n    (( ipart = $(( ipart * 10 )) ))\n\
    \n    # Adjust the result to fit decimal part with minimal loss\n    # of precision\n\
    \    (( ipart += $d ))\n\n    # Round integer part up\n    (( ipart = $(( ipart\
    \ / 10 )) ))\n\n    # Return truncated number in the given number of decimal places\n\
    \    printf \"%0.*f\" $d \"$ipart\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpppp6_acp.sh: line 15: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    /tmp/tmpppp6_acp.sh: line 24: 3.5 / 10 : syntax error: invalid arithmetic operator
    (error token is ".5 / 10 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local -r number=$1\n\n  # The default decimal place is '0'\n  local -r\
    \ decimal=0\n\n  # If number is already an integer, return as is\n  local -r is_int=0\n\
    \  if [[ \"$number\" =~ ^[0-9]+$ ]]; then\n    is_int=1\n  fi\n\n  # If the number\
    \ is a float, convert it into an integer\n  local -r is_float=0\n  if [[ \"$number\"\
    \ =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    is_float=1\n    number=${number%.*}\n  fi\n\
    \n  # Decompose the number into integer and decimal part\n  local -r intpart=\"\
    ${number%%.*}\"\n  local -r decimalpart=\"${number#$intpart}\"\n\n  # If there\
    \ are no decimals, default to '0'\n  if [[ \"$decimalpart\" = \"\" ]]; then\n\
    \    decimal=\"0\"\n  else\n    decimal=\"${decimalpart#*\\.}\"\n  fi\n\n  # If\
    \ there are no integers, default to '0'\n  if [[ \"$intpart\" = \"\" ]]; then\n\
    \    intpart=\"0\"\n  else\n    intpart=\"${intpart#*\\.}\"\n  fi\n\n  # If there\
    \ are no integers nor decimals, default to '0'\n  if [[ \"$intpart\" = \"\" ||\
    \ \"$decimalpart\" = \"\" ]]; then\n    intpart=\"0\"\n    decimal=\"0\"\n  fi\n\
    \n  # Return formatted string\n  printf -v truncate_number_string \"${decimal}%${intpart}\"\
    \n  if [[ \"$is_int\" -ne 0 ]]; then\n    echo \"$truncate_number_string\"\n \
    \ else\n    echo \"$truncate_number_string\"\n  fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpwmpxdvt4.sh: line 25: is_float: readonly variable

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=\"$1\"\n\n    # convert into integer part\n    local INT=\"\
    ${NUMBER%.*}\"\n    INT=\"${INT#0}\"\n\n    # convert into decimal part\n    local\
    \ DEC=\"${NUMBER#$INT.}\"\n    DEC=\"${DEC%.*}\"\n    DEC=\"${DEC#0}\"\n\n   \
    \ # now we know that we have an integer part and decimal part\n    # we check\
    \ which one is the bigger and truncate it to the other\n    if [ \"${INT}\" -gt\
    \ \"${DEC}\" ]\n    then\n        echo \"${INT}\"\n    else\n        echo \"${DEC}\"\
    \n    fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal NUMBER=$1\n\tlocal DECIMAL=1 # default precision is 1\n\tif [[ \"\
    $NUMBER\" =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n\t\tlocal INTEGER=`echo $NUMBER | sed\
    \ -e 's/^-\\([0-9]*\\)\\..*$/\\1/'`\n\t\tlocal DECIMAL=`echo $NUMBER | sed -e\
    \ 's/^-\\([0-9]*\\)\\..*/\\1/'`\n\t\tlocal FINAL=`echo $NUMBER | sed -e 's/^-\\\
    ([0-9]*\\)\\..*$/\\1/'`\n\t\t# if the number is less than 1, return 0\n\t\tif\
    \ [ \"$FINAL\" -lt 1 ]; then\n\t\t\tFINAL=0\n\t\tfi\n\telse\n\t\techo \"ERROR:\
    \ Cannot convert $NUMBER to integer or decimal part\"\n\t\texit 1\n\tfi\n\n\t\
    # get integer part by truncating decimal part\n\techo \"$FINAL\" | awk '{$1=$1}1'\
    \ | cut -d '.' -f 1\n\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpf3lwsljo.sh: line 18: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # We use $((...)) to force floating-point arithmetic.\n  echo \"$(echo\
    \ \"$1\" | sed -e 's/^.\\([0-9]*\\)..*/\\1/g')\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local truncated number\n    local decimals precision\n\n    number=$1\n\
    \    if [[ $number =~ ([+-]?([0-9]*)\\\\.([0-9]*)) ]]; then\n        precision=${BASH_REMATCH[2]}\n\
    \        decimals=${BASH_REMATCH[1]}\n        truncated=$(echo \"$number\" | bc\
    \ -l <<< \"scale=$precision\"|cut -d \".\" -f1)\n    else\n        truncated=$number\n\
    \    fi\n    echo \"$truncated\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    echo $1 | sed -r 's/([^0-9])([0-9])/\\1 \\2/' | sed -r 's/([^0-9])([0-9])/\\\
    1 \\2/'\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number_string=\"$1\"\n    local decimals=0\n    local decimal\n\
    \    while [[ ${number_string} =~ ^[0-9]+$ ]]; do\n        decimal=$((${number_string%.*}\
    \ / 10 ** ${decimals}))\n        decimals=\"$((${decimals} + 1))\"\n        number_string=${number_string#*${decimal}}\n\
    \    done\n    echo \"$decimal\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal number=$1\n\tlocal num_decimals=0\n\tlocal decimal_part\n\tlocal\
    \ decimal_part2\n\tlocal decimal_part3\n\tlocal decimal_part4\n\tlocal decimal_part5\n\
    \tlocal decimal_part6\n\tlocal decimal_part7\n\tlocal decimal_part8\n\tlocal decimal_part9\n\
    \n\tdecimal_part=$number\n\tdecimal_part2=$(echo \"$decimal_part\" | cut -d'.'\
    \ -f1)\n\tdecimal_part3=$(echo \"$decimal_part2\" | cut -d'.' -f1)\n\tdecimal_part4=$(echo\
    \ \"$decimal_part3\" | cut -d'.' -f1)\n\tdecimal_part5=$(echo \"$decimal_part4\"\
    \ | cut -d'.' -f1)\n\tdecimal_part6=$(echo \"$decimal_part5\" | cut -d'.' -f1)\n\
    \tdecimal_part7=$(echo \"$decimal_part6\" | cut -d'.' -f1)\n\tdecimal_part8=$(echo\
    \ \"$decimal_part7\" | cut -d'.' -f1)\n\tdecimal_part9=$(echo \"$decimal_part8\"\
    \ | cut -d'.' -f1)\n\n\tif [ \"$decimal_part9\" -eq 0 ]; then\n\t\tnum_decimals=$((\
    \ $(echo \"$decimal_part\" | cut -d'.' -f2) - 1 ))\n\telse\n\t\tnum_decimals=$((\
    \ $(echo \"$decimal_part9\" | cut -d'.' -f2) - 1 ))\n\tfi\n\n\techo \"$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part$decimal_part\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimals=0\n    local part1=0\n    local part2=1\n\
    \    while [[ ${number} -gt 1 ]]; do\n        decimals=$(expr ${decimals} + 1\
    \ )\n        part1=$(expr ${number} - ${part2} -1 )\n        part2=$(expr ${number}\
    \ - ${part1} )\n        number=$( expr $part1 + $part2 )\n    done\n    echo $(expr\
    \ $number - $decimals - 1)\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8gh4mn46.sh: line 15: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    expr: non-integer argument

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal a=$1\n\techo \"$((10#$a%1)*10#)/10\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpmzm5j_ee.sh: command substitution: line 12: syntax error near unexpected
    token `*10#''

    /tmp/tmpmzm5j_ee.sh: command substitution: line 12: `(10#$a%1)*10#''

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=$1\n\n    local DECOMPOUND_INTEGER=0\n    local DECOMPOUND_DECIMAL=0\n\
    \    local MAX_INTEGER=0\n    local MAX_DECIMAL=0\n\n    local INTEGER_EXPONENT=0\n\
    \    local DECIMAL_EXPONENT=0\n\n    local MIDPOINT_VALUE=0\n    local MIDPOINT_INDEX=0\n\
    \n    local MIDPOINT_INTEGER=0\n    local MIDPOINT_DECIMAL=0\n    local MIDPOINT_EXPONENT=0\n\
    \n    local INTEGER_DIGITS=0\n    local DECIMAL_DIGITS=0\n\n    local MIDPOINT_DIGITS=0\n\
    \n    local DECIMAL=0\n    local INTEGER=0\n\n    # Get the fractional part by\
    \ splitting it into integer and decimal part.\n    local DECOMPOUND_INTEGER=\"\
    $NUMBER\"\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\n    # Get the decimal\
    \ part by splitting it into integer and decimal part.\n    DECOMPOUND_DECIMAL=${DECOMPOUND_INTEGER}\n\
    \    DECOMPOUND_DECIMAL=${DECOMPOUND_DECIMAL#*.}\n\n    # Get the integer part\
    \ by splitting it into integer and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n\
    \    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\n    local MAX_DECIMAL=$((\
    \ ${DECOMPOUND_DECIMAL} + 1 ))\n\n    # Get the exponent value.\n    # Get the\
    \ number of decimal digits to shift right to get an integer part and decimal part.\n\
    \    local DECIMAL_EXPONENT=$(( ${DECOMPOUND_DECIMAL} + 1 ))\n    local INTEGER_EXPONENT=$((\
    \ ${DECOMPOUND_INTEGER} - 1 ))\n\n    # Get the mantissa index based on the exponent.\n\
    \    # Get the integer part of the mantissa by splitting the number into integer\
    \ and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n\
    \    DECOMPOUND_DECIMAL=${DECOMPOUND_INTEGER}\n    DECOMPOUND_DECIMAL=${DECOMPOUND_DECIMAL#*.}\n\
    \n    local MIDPOINT_INDEX=$(( ${DECOMPOUND_INTEGER} - 1 ))\n\n    # Get the mantissa\
    \ integer part by splitting it into integer and decimal part.\n    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER#*.}\n\
    \    DECOMPOUND_INTEGER=${DECOMPOUND_INTEGER%.*}\n    DECOMPOUND_DECIMAL=${DECOM\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpj9pexcl8.sh: line 82: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal var=$1\n\tlocal int=\"${var%.*}\"\n\tlocal decimal=\"${var#$int}\"\
    \n\n\t# If the decimal part is all zeros we return it anyway.\n\t# Otherwise we\
    \ return the float with trailing zeros.\n\tif [ \"${decimal}\" == 0 ]; then\n\t\
    \techo \"$var\"\n\t\treturn\n\tfi\n\n\tlocal num_part\n\tnum_part=`expr \"$int\"\
    \ : '([^.]*)'`\n\tlocal remainder\n\n\t# We use \"floor division\" because if\
    \ we use \"integer division\"\n\t# and $num_part is zero, we'll get \"1\" as answer.\n\
    \t# Example: 5 - 1 -> 0 -> \"1\" -> \"0.5\"\n\t#\n\t# We know that $int is a positive\
    \ number. Using \"integer division\"\n\t# we get \"0.5\" if $num_part is zero.\n\
    \t# Example: 6 / 1 -> \"2\" -> \"0.5\"\n\t#\n\t# However, using \"floor division\"\
    \ we get \"5\" if $num_part is zero.\n\t# Example: 6 / 0 -> \"5\"\n\tremainder=`expr\
    \ \"$decimal\" - \"$num_part\"`\n\n\techo \"$int$remainder\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'expr: non-integer argument

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n   local x=$1\n   local y=$2\n   local d=0\n   local t=0\n   if (($x <= 0));\
    \ then\n      echo \"negative number not allowed\"\n      return 1\n   fi\n  \
    \ if (($y == 0)); then\n      echo \"negative number not allowed\"\n      return\
    \ 1\n   fi\n   for (( i=0; i<$y; i++ )); do\n      if (( x % 1 == 0 )); then\n\
    \         d=$(( $d + 1 ))\n      fi\n      x=$(( $x / 10 ))\n   done\n   if ((\
    \ $d > 0 )); then\n      t=$(( 10^$d - 1 ))\n   fi\n   echo $(( $t + $x ))\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpfnsff8b9.sh: line 15: ((: 3.5 <= 0: syntax error: invalid arithmetic
    operator (error token is ".5 <= 0")

    /tmp/tmpfnsff8b9.sh: line 19: ((: == 0: syntax error: operand expected (error
    token is "== 0")

    /tmp/tmpfnsff8b9.sh: line 23: ((: i<: syntax error: operand expected (error token
    is "<")

    /tmp/tmpfnsff8b9.sh: line 32: 0 + 3.5 : syntax error: invalid arithmetic operator
    (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    # number must be positive\n    [ -n \"${number}\"\
    \ ] || return 1\n    # we cannot decompose the number above zero\n    [ \"${number}\"\
    \ -gt 0 ] || return 1\n    local trunc_part=0 decimal_part=0\n    # we cannot\
    \ decompose negative numbers, we need a negative number\n    # to decompose it\
    \ into\n    [[ \"${number}\" < 0 ]] && return 1\n    # divide the number by 10\n\
    \    while [[ \"${number}\" > 0 ]]; do\n        local trunc_part=$(( trunc_part\
    \ + 1 ))\n        local decimal_part=$(( decimal_part + 1 ))\n        local number=$(\
    \ echo \"${number}\" / 10 )\n    done\n    echo \"${trunc_part}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpzxiph390.sh: line 15: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local truncate_factor=\"${1}\"\n\n  local number=\"${truncate_factor#*[!.0-9]*}\"\
    \n\n  echo \"${number%.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # Make sure the number is positive\n    if [ \"$1\" -lt 1 ]; then\n \
    \       exit 1\n    fi\n\n    # Decompose the number into integer (largest int)\
    \ and decimals\n    # (remaining decimals)\n    IFS='.' read -r -a array <<< \"\
    $1\"\n    truncate_part=\"${array[1]}\"\n    integer_part=\"${array[0]}\"\n\n\
    \    # Make sure the integer part is smaller than the original number\n    if\
    \ [ \"$integer_part\" -lt \"$1\" ]; then\n        exit 1\n    fi\n\n    echo $truncate_part\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbyipxbnd.sh: line 12: [: 3.5: integer expression expected

    /tmp/tmpbyipxbnd.sh: line 23: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=\"$1\"\n    local DECIMALS=$(echo \"$NUMBER\" | sed -e 's/^\\\
    ([0-9]*\\)\\..*$/\\1/')\n    local LARGEST_NUMBER=$(echo \"$NUMBER\" | sed -e\
    \ 's/^\\(.*\\)\\..*$/\\1/')\n    local INT_PART=$(echo \"$NUMBER\" | sed -e 's/^\\\
    (.*\\)\\..*\\([0-9]*\\)\\..*$/\\1/')\n    local DECIMAL_RESULT=$(echo \"$NUMBER\"\
    \ | sed -e 's/^\\(.*\\)\\..*\\([0-9]*\\)\\..*\\([0-9]*\\)\\..*$/\\1/')\n\n   \
    \ local RESULT_STRING=\"$DECIMALS\"\n\n    if [ -n \"$INT_PART\" ] ; then\n  \
    \      RESULT_STRING+=\".${INT_PART}\"\n    fi\n\n    return \"$RESULT_STRING\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpapxhrcd1.sh: line 23: return: 3.3.5: numeric argument required

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local float=\"$1\"\n    local int=\"${float%%%.*}\"\n    local dec=\"\
    ${float#$int}\"\n    echo \"$dec\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # Decompose the given number into integer and decimals\n    local number=$1\n\
    \    local integer=${number%.*}\n    local decimal=${number#*.}\n    decimal=${decimal%.*}\n\
    \    integer > $1 || return $integer\n    decimal == 0 || (\n        decimal=$decimal-1\n\
    \        decimal=$decimal%1\n    )\n    echo $decimal\n}\n\ncandidate() {\n  \
    \  truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp2cjf2_i_.sh: line 16: integer: command not found

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # Check if the first parameter is an integer\n  if [[ $1 =~ ^[0-9]+$ ]];\
    \ then\n    trunc_no=`echo ${1} | cut -d. -f1`\n    dec_no=`echo ${1} | cut -d.\
    \ -f2`\n    dec_len=${#trunc_no}\n    # Check if the decimal part is smaller than\
    \ 1\n    if [[ $dec_len -gt 1 ]]; then\n      # Truncate the decimal part if it\
    \ is smaller than 1\n      trunc_no=${trunc_no%.*}\n      # If dec_no is still\
    \ smaller than 1, then it is impossible to truncate\n      if [[ $dec_no -lt 1\
    \ ]]; then\n        trunc_no=1\n        dec_len=0\n      fi\n    fi\n    if [[\
    \ $dec_len -gt 0 ]]; then\n      trunc_no=$trunc_no\".\"\n      dec_no=$dec_no\"\
    0\"\n    fi\n    trunc_no=${trunc_no:0:$dec_len}\n  else\n    trunc_no=${1:%.*}\n\
    \    dec_no=`echo ${1} | cut -d. -f2`\n    dec_len=${#trunc_no}\n  fi\n  trunc_no=$trunc_no\n\
    \  if [[ $dec_len -gt 0 ]]; then\n    trunc_no=$trunc_no\".\"\n    dec_no=$dec_no\"\
    0\"\n  fi\n  trunc_no=${trunc_no:0:$dec_len}\n  trunc_no=$(echo $trunc_no | cut\
    \ -d. -f1)\n  trunc_no=${trunc_no:0:$dec_len}\n  dec_no=${dec_no:0:1}\n  dec_no=${dec_no:1}\n\
    \  echo $dec_no\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5ripq5ba.sh: line 32: 1: %.*: syntax error: operand expected (error
    token is "%.*")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=${1}\n  local integer_part=$(printf \"%.*f\" ${#number} |\
    \ sed -e \"s/^0*//\")\n  local decimals=$((${#number} - ${#integer_part}))\n \
    \ if [ \"${decimals}\" -eq 0 ]; then\n    echo \"0\"\n  else\n    echo \"${number%%.*f}${decimals}\"\
    \n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local var=$1\n    local decimals=${#var}\n    local part=$(( ${var} %\
    \ 1 ))\n    local intpart=$(( ${var} / 1 ))\n    if [ ${decimals} -gt 2 ] ; then\n\
    \        decimals=1\n    fi\n    echo \"${decimals}.${part}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5oz5pe_c.sh: line 13: 3.5 % 1 : syntax error: invalid arithmetic
    operator (error token is ".5 % 1 ")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local truncate_to=$1\n  local number=$2\n\n  # Bash has trouble with unary\
    \ operators (-) so we have to\n  # use the bc program\n  # The `<(...)` is needed\
    \ to keep the output of bc as bash\n  # sees it\n  # We also use bc for the arithmetic\
    \ instead of bc (bc does not support\n  # floating points as input)\n  local trunc_part=$(echo\
    \ \"${number}\" | bc -l <<< \"$(\n      echo ${number} < ${truncate_to} && echo\
    \ ${number} - ${truncate_to}\n  )\")\n\n  # If both numbers are 0, the floating\
    \ point is 0 too. So\n  # we must return the integer part as well.\n  if [[ \"\
    ${trunc_part}\" == \"0\" ]]; then\n    local trunc_part=\"\"\n  fi\n\n  # Now\
    \ we must remove all decimal part from the decimal part.\n  # If the decimal part\
    \ has more than one digit, we need to\n  # keep only one digit. So we round the\
    \ number to the next\n  # highest integer part which is one less than the decimal\
    \ part.\n  # The bc program supports rounding toward negative infinity\n  # (to\
    \ nearest neighbor) or round toward zero (away from zero). This\n  # is what the\
    \ `-r` option of bc does.\n  local trunc_part=$(echo \"${trunc_part}\" | bc -l\
    \ <<< \"$(\n      echo ${trunc_part} < ${truncate_to} && echo ${trunc_part} -\
    \ ${truncate_to}\n  )\")\n\n  # Strip trailing zeroes\n  # The `-0` option strips\
    \ trailing zeroes from floating point numbers\n  # We also use `printf` because\
    \ it is more efficient when dealing with strings\n  # than `echo`\n  local trunc_part=$(printf\
    \ \"%.1f\" \"${trunc_part}\")\n\n  # Strip trailing decimal part if greater than\
    \ 1\n  if [[ \"${trunc_part}\" -gt \"${truncate_to}\" ]]; then\n    local trunc_part=\"\
    \"\n  fi\n\n  # Return decimal part\n  echo \"${trunc_part}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp4yjvs2d0.sh: line 23: 3.5: No such file or directory

    /tmp/tmp4yjvs2d0.sh: line 40: 3.5: No such file or directory

    /tmp/tmp4yjvs2d0.sh: line 48: [[: 0.0: syntax error: invalid arithmetic operator
    (error token is ".0")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local float_number=$1\n\n  local integer_part=\"$(echo \"$float_number\"\
    \ | cut -d - -f1)\"\n  local decimal_part=\"$(echo \"$float_number\" | cut -d\
    \ - -f2)\"\n\n  if [[ \"$decimal_part\" -eq 1 ]]; then\n    echo \"0\"\n  else\n\
    \    echo \"$decimal_part\"\n  fi\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpaecorxy7.sh: line 16: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [[ \"${1}\" =~ ^[0-9]+$ ]]; then\n        local int_part=\"${1}\"\n\
    \        local decimal_part=\"${1}\"\n        int_part=\"$(echo \"${int_part}\"\
    \ | sed -e 's/^0*//g' -e 's/\\.//g')\"\n        decimal_part=\"$(echo \"${decimal_part}\"\
    \ | sed -e 's/^0*//g' -e 's/\\.//g')\"\n        echo \"${decimal_part}\"\n   \
    \ else\n        echo \"${1}\"\n    fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [[ \"$1\" =~ ([0-9]+\\.[0-9]+) ]]\n    then\n        truncate_number_by_decimals=${BASH_REMATCH[1]}\n\
    \    else\n        truncate_number_by_decimals=0\n    fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimal_part\n    local decimal_part1\n  \
    \  local decimal_part2\n    local decimal_part3\n    local decimal_part4\n   \
    \ local decimal_part5\n    local decimal_part6\n\n    decimal_part1=$(echo $number\
    \ | cut -d. -f1)\n    decimal_part2=$(echo $number | cut -d. -f2)\n    decimal_part3=$(echo\
    \ $number | cut -d. -f3)\n    decimal_part4=$(echo $number | cut -d. -f4)\n  \
    \  decimal_part5=$(echo $number | cut -d. -f5)\n    decimal_part6=$(echo $number\
    \ | cut -d. -f6)\n    \n    echo $decimal_part5\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local DECIMALS=\"${1}\"\n  local NUMBER=\"${2}\"\n  local TRUNCATED=\"\
    ${3}\"\n  local EXPONENT=\"${4}\"\n\n  if [ \"x${TRUNCATED}\" != \"x\" ] ; then\n\
    \    echo \"${TRUNCATED}\"\n  else\n    TRUNCATED=\"0\"\n  fi\n\n  if [ \"x${NUMBER}\"\
    \ != \"x\" ] ; then\n    local TRUNCATED_NUMBER=\"$(echo \"${NUMBER}\" | cut -d'.'\
    \ -f1-${EXPONENT})\"\n    local TRUNCATED_EXPONENT=\"$(echo \"${NUMBER}\" | cut\
    \ -d'.' -f${EXPONENT})\"\n\n    if [ \"x${TRUNCATED_NUMBER}\" != \"x\" ] ; then\n\
    \      TRUNCATED=\"${TRUNCATED_NUMBER%.}\"\n    fi\n\n    if [ \"x${TRUNCATED_EXPONENT}\"\
    \ != \"x\" ] ; then\n      TRUNCATED=\"${TRUNCATED}e${TRUNCATED_EXPONENT}\"\n\
    \    fi\n\n    echo \"${TRUNCATED}\"\n  else\n    echo \"0\"\n  fi\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=\"$1\"\n  local decimals=\"$(python -c \"import locale; print\
    \ locale.getlocale()[locale.LC_ALL].decimal_point)\"\n  if [ \"$decimals\" ==\
    \ \".\" ]; then\n    echo \"0\"\n  else\n    echo \"$number\" | perl -pe \"s/([^$decimals])$decimals*/$decimals/\"\
    \n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpf2ws8z0y.sh: line 12: unexpected EOF while looking for matching
    `)''

    /tmp/tmpf2ws8z0y.sh: line 32: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local var=$1\n    local part\n    local decimals=0\n\n    while [ \"\
    $var\" -gt 1 ]; do\n        var=$(echo \"$var * 10\" | bc)\n        decimals+=1\n\
    \    done\n\n    part=$(( var * 10 ))\n    part=$(( part / 10 ))\n    echo \"\
    $part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprn9ppqjq.sh: line 15: [: 3.5: integer expression expected

    /tmp/tmprn9ppqjq.sh: line 20: 3.5: syntax error: invalid arithmetic operator (error
    token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=\"$1\"\n    local decimals=\"${number%.*}\"\n    local integer=\"\
    ${number#*.}\"\n    case \"$decimals\" in\n        \"0\") decimals=\"1\"\n   \
    \         ;;\n        \".\")\n            decimals=\"$decimals\"\n           \
    \ ;;\n        \"\") decimals=\"0\"\n            ;;\n    esac\n    case \"$decimals\"\
    \ in\n        \"\") integer_part=\"$integer\"\n            decimals=0\n      \
    \      ;;\n        \"0\") integer_part=\"$integer\"\n            decimals=0\n\
    \            ;;\n        \"1\") integer_part=\"$integer\"\n            decimals=0\n\
    \            ;;\n        *)\n            local remainder\n            # Truncate\
    \ decimal part and get number of remainder\n            decimals=$((10#$decimals))\n\
    \            integer_part=\"$integer\"\n            remainder=\"$((10#$decimal\
    \ - 10#$decimals))\"\n            if [ $remainder -lt 10 ]; then\n           \
    \     integer_part=\"$integer_part.$remainder\"\n            else\n          \
    \      integer_part=\"$integer_part.0\"\n            fi\n    ;;\n    esac\n  \
    \  integer_part=\"$(echo \"$integer_part\" | bc -l)\"\n    echo \"$decimals\"\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local float=\"$1\"\n  local num=\"${float}\"\n  local num_dec=\"${float%%.*}\"\
    \n  local num_int=\"${float#*.}\"\n\n  # If it's integer, then it's whole number\
    \ after decimal point\n  if [ \"$num_int\" -eq \"$num\" -a \"$num_int\" -lt \"\
    $num_dec\" ]; then\n    echo $num_int\n    return\n  fi\n\n  # If fractional part,\
    \ then it's whole number before decimal point\n  if [ \"$num_int\" -eq \"$num\"\
    \ -a \"$num_int\" -ge \"$num_dec\" ]; then\n    echo $num_int\n    return\n  fi\n\
    \n  # If it's integer part is greater, then return fractional part\n  if [ \"\
    $num_int\" -gt \"$num\" -a \"$num_int\" -le \"$num_dec\" ]; then\n    echo \"\
    $num_dec\"\n    return\n  fi\n\n  # If fractional part is greater, then return\
    \ whole number part\n  if [ \"$num_int\" -gt \"$num\" -a \"$num_int\" -lt \"$num_dec\"\
    \ ]; then\n    echo \"$num_int\"\n    return\n  fi\n\n  # Otherwise just return\
    \ the whole number part\n  echo $num_int\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpju7fitv8.sh: line 17: [: 3.5: integer expression expected

    /tmp/tmpju7fitv8.sh: line 23: [: 3.5: integer expression expected

    /tmp/tmpju7fitv8.sh: line 29: [: 3.5: integer expression expected

    /tmp/tmpju7fitv8.sh: line 35: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local x=\"${1}\"\n  local dec=0\n  local d\n  while [ \"${x}\" -gt 0 ];\
    \ do\n    dec=$((${dec}+1))\n    d=\"${x/10}\"\n    x=\"${x%${d}}\"\n  done\n\
    \  echo \"${dec}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpw4obtmb8.sh: line 14: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local IFS=.\n  local a=$1\n  local i=${#a}\n  local decimals=0\n  while\
    \ ((i > 0)); do\n    decimals+=$(echo $i | bc)\n    i=$(echo $i | bc -l)\n  done\n\
    \  echo ${a%%.*}\n  echo ${decimals}\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=24 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=12 encoding='utf-8'>
  timestamp: 1660058858
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    IFS=\".\" read -r n d <<< \"$1\"\n    printf -v n \"%.${#d}s\" \"$n\"\
    \n    printf -v d \"%.${#d}f\" \"$d\"\n    echo \"${d%.*}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimal=$((${number%.*}+1))\n    local integer=$((${number#*.}-1))\n\
    \    local decimal_string=${decimal#0}\n    local integer_string=${integer#0}\n\
    \n    echo \"${decimal_string}.${integer_string}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local decimals=0\n    local integer=\"\"\n    local decimal=\"${1%.}\"\
    \n    case \"${decimal}\" in\n        \"\") decimal=\".0\" ;;\n        *)  decimal=\"\
    ${decimal}.0\" ;;\n    esac\n    if [ $(echo \"${decimal}\" | awk '{print $1+0}\
    \ > ${decimal}\" | bc -l) -eq 0 ]; then\n        integer=\"${1#*\\.}\"\n    else\n\
    \        integer=\"${1}\"\n        decimals=${#integer}\n    fi\n    echo ${integer}${decimal}\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpsuk5i50t.sh: line 18: unexpected EOF while looking for matching
    `''''

    /tmp/tmpsuk5i50t.sh: line 39: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local value=$1\n  local int_part=$(expr \"$value\" : \"\\+([0-9]*)\")\n\
    \  local dec_part=$(expr ${value}  - \"${int_part}\" )\n  echo \"${dec_part}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'expr: non-integer argument

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number_string=\"$1\"\n\n    number_string=\"${number_string%.*}\"\
    \n    local truncate_part=\"${number_string##*.}\"\n\n    while [[ ${truncate_part}\
    \ != 0\\.0\\. ]]; do\n        truncate_part=\"${number_string##*.}\"\n    done\n\
    \n    echo \"${truncate_part}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=9 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=4 encoding='utf-8'>
  timestamp: 1660058858
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local precision=\"${2}\"\n  local digits=$((${precision}-1))\
    \ # get the number of digits before the decimal point to truncate to\n  if [ \"\
    ${number}\" -gt 0 ]; then # check for negative numbers\n    local -a truncated\n\
    \    local max_trunc_digits=$((${precision}-1)) # get the number of digits before\
    \ the decimal point to truncate to\n    local max_trunc_digits_without_decimal=$((${precision}-1))\n\
    \    local max_trunc_digits_without_decimal_trunc_before_decimal=$((${precision}-1))\n\
    \    while [ $max_trunc_digits -gt \"$max_trunc_digits_without_decimal\" ]; do\
    \ # find maximum number of truncated digits without decimal to prevent infinite\
    \ loop\n      local trunc_digits_without_decimal=$((max_trunc_digits-max_trunc_digits_without_decimal_trunc_before_decimal))\n\
    \      truncated=( $(echo \"${number}\" | sed -n \"s/^\\(.\\)\\(${trunc_digits_without_decimal}\\\
    )$/\\1\\2/gp\"))\n      max_trunc_digits_without_decimal_trunc_before_decimal=$((${max_trunc_digits_without_decimal_trunc_before_decimal}-1))\n\
    \      max_trunc_digits_without_decimal=$((max_trunc_digits_without_decimal-1))\n\
    \    done\n    if [ \"${#truncated}\" -gt 1 ]; then # if we have multiple digits\
    \ before the decimal point\n      local trunc_digits=${truncated[1]} # get the\
    \ truncated digits\n    else\n      local trunc_digits=\"0\"\n    fi\n    local\
    \ trunc_digits_without_decimal=${trunc_digits_without_decimal}\n    local trunc_digits_without_decimal_trunc_before_decimal=${trunc_digits_without_decimal_trunc_before_decimal}\n\
    \    local trunc_digits_truncated=$((${trunc_digits}-${trunc_digits_without_decimal}))\
    \ # get the truncated digits without decimal part\n    local trunc_digits_truncated_trunc_before_decimal=$((${trunc_digits_truncated}+${trunc_digits_without_decimal_trunc_before_decimal}))\n\
    \    local decimal_truncated=$(echo \"${number}\" | sed -n \"s/^\\(.\\)\\(${trunc_digits_truncated_trunc_before_decimal}\\\
    )$/\\1/gp\")\n    local trunc_decimals=$(echo \"${decimal_truncated}\" | sed -n\
    \ \"s/^\\(.\\)\\(${trunc_digits_truncated}\\)$\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpop_x8zxc.sh: line 46: unexpected EOF while looking for matching
    `"''

    /tmp/tmpop_x8zxc.sh: line 50: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local decimal_part=0\n  local integer=0\n\n  # Remove\
    \ decimals\n  while [ \"$number\" -gt 0 ]; do\n    local remainder=$(( $number\
    \ % 10 ))\n    number=$(( $number / 10 ))\n    decimal_part=$(( decimal_part +\
    \ remainder ))\n  done\n\n  # Add leading zeros\n  while [ \"$decimal_part\" -lt\
    \ 10 ]; do\n    decimal_part=$(( $decimal_part + 0 ))\n    integer=$(( $integer\
    \ + 1 ))\n  done\n\n  if [ \"$number\" -gt 0 ]; then\n    integer=$(( $integer\
    \ + 1 ))\n  fi\n\n  printf -v truncated_number \"%.0f\" $decimal_part\n  printf\
    \ -v truncated_integer \"%.0f\" $integer\n\n  printf \"$truncated_number\"\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=33 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=5 encoding='utf-8'>
  timestamp: 1660058859
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # Convert to decimal number\n  local number=$1\n  local factor=1\n  local\
    \ decimal=0\n  local decimal_part\n\n  if [[ $1 =~ \"^-?[0-9]+(.[0-9]+)?$\" ]];\
    \ then\n    # Remove leading negative sign\n    number=${1#-}\n  fi\n\n  # Break\
    \ into integer and decimal parts\n  while [[ $number =~ ^[0-9]+$ ]]; do\n    decimal_part=$((factor*$number))\n\
    \    factor=$((factor*10)) # For decimal part we need to multiply by 10\n    decimal=$((decimal+decimal_part))\n\
    \    number=${number#0}\n  done\n  decimal_part=$((factor*$number)) # Remainder\
    \ is the last decimal part\n  decimal=$((decimal+decimal_part))\n  decimal=$((decimal<0?-decimal:decimal))\n\
    \  decimal=${decimal%.*}\n  if [[ -z ${decimal// } ]]; then\n    echo \"0\"\n\
    \  else\n    echo \"${decimal}\"\n  fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpspiazj3o.sh: line 29: factor*3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local a=$1\n  a=${a%.*}\n  a=${a#*.}\n  if [[ ${a} -gt 0 ]]; then\n   \
    \ a=`echo \"${a}\"|awk '{print int($1)}'`\n  fi\n  echo \"${a}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    IFS=\".\" read -r -a array <<< \"$1\"\n    len=${#array[@]}\n    decimal=${array[1]}\n\
    \    integer=${array[0]}\n    if [ \"$decimal\" -lt 1 ]; then\n        echo \"\
    $integer\"\n    else\n        echo \"$integer\"\n    fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local -r number=$1\n  (( ${#number} < 1 )) && return 1\n  local -a parts=()\n\
    \  local -r num_string=$(echo \"${number}\" | sed 's/^\\(-?[0-9]+\\)\\.\\(-?[0-9]+\\\
    )$/\\1\\2/')\n  IFS=. read -ra parts <<< \"$num_string\"\n  (( ${#parts[@]} >\
    \ 1 )) && return 1\n  local decimal_part=${parts[-1]}\n  [ \"${decimal_part}\"\
    \ -gt 1 ] || return 0\n  echo \"${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local NUMBER=\"$1\"\n  # The last char is always a decimal point\n  local\
    \ DECIMAL_POINT=\"${NUMBER%%.*}\"\n  local TRUNCATED_NUMBER=\"${NUMBER#$DECIMAL_POINT}\"\
    \n  # The decimal part is always the largest number smaller than $NUMBER\n  local\
    \ TRUNCATED_DECIMAL=\"${TRUNCATED_NUMBER%.*}\"\n  # If the decimal part is larger\
    \ than 1, the number is too small\n  if [ \"$TRUNCATED_DECIMAL\" -gt 1 ]; then\n\
    \    TRUNCATED_DECIMAL=1\n  fi\n  echo $TRUNCATED_DECIMAL\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpb2hn90iw.sh: line 18: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    truncate_decimal=.0\n    truncate_part=0\n    number=\"$1\"\n    echo\
    \ \"${number}\" | while read -a part; do\n        truncate_part=$((truncate_part\
    \ + ${#part[@]} + 1))\n        truncate_decimal=$((truncate_decimal + ${part[0]}))\n\
    \    done\n    echo \"${truncate_part}${truncate_decimal}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpc88m_zks.sh: line 16: .0: syntax error: operand expected (error
    token is ".0")

    '
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local float_number=\"$1\"\n  local decimal_part=\"$2\"\n\n  # We don't\
    \ care about number of zeros, we just need decimal part\n  if [ \"$decimal_part\"\
    \ == \"0\" ]; then\n    echo \"$decimal_part\"\n  else\n    # We can have negative\
    \ sign at the beginning, so we check it first\n    if [[ \"$decimal_part\" =~\
    \ ^-([0-9]*)\\.?([0-9]*)$ ]]; then\n      decimal_part=\"$BASH_REMATCH[1]\"\n\
    \    fi\n\n    # Remove all decimal parts that are not equal to zero\n    decimal_part=$(echo\
    \ \"$decimal_part\" | tr -cd \".0123456789\")\n\n    if [ \"$decimal_part\" ==\
    \ \"0\" ]; then\n      echo \"0\"\n    else\n      echo \"$decimal_part\"\n  \
    \  fi\n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058853
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [ \"$1\" -eq 0 ]; then\n        return 0\n    fi\n    truncate_float=\"\
    $(echo \"$1\" | sed -e 's/^[0-9]*\\..*$//')\"\n    truncate_int=\"$(echo \"$truncate_float\"\
    \ | sed -e 's/\\..*$//')\"\n    echo \"$truncate_int\"\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpd_3hz51h.sh: line 11: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local FLOOR=${1}\n  local TRUNCATED=${2}\n  local DECIMAL=${3}\n\n  # We\
    \ need bash 3.1 for the -r and -F options\n  # (to support -F0 but not -F0 0)\n\
    \  local IFS='.' read -r -d '' -a NUMBER <<<\"$(echo \"$FLOOR\" | sed -e 's/^0*//')\"\
    \n  local DECIMAL_LEFT=${#NUMBER[@]}\n  if (( DECIMAL_LEFT >= 0 )); then\n   \
    \ TRUNCATED=\n    while (( DECIMAL_LEFT >= 0 )) ; do\n      TRUNCATED=$(( TRUNCATED\
    \ + NUMBER[DECIMAL_LEFT] ))\n      DECIMAL_LEFT=$(( DECIMAL_LEFT - 1 ))\n    done\n\
    \  fi\n  echo \"$TRUNCATED\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp_igi1dqa.sh: line 17: local: `-r'': not a valid identifier

    /tmp/tmp_igi1dqa.sh: line 17: local: `-d'': not a valid identifier

    /tmp/tmp_igi1dqa.sh: line 17: local: `'': not a valid identifier

    /tmp/tmp_igi1dqa.sh: line 17: local: `-a'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local n=\"$1\"\n    shift\n\n    if [[ $n =~ (^[0-9]*\\.[0-9]+$) ]];\
    \ then\n        # n contains fractional part\n        echo \"${n%.*}\"\n    else\n\
    \        echo \"$(( n//1))\"\n    fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local FP=$1\n    # Decompose number\n    if [[ ${FP} == *\"-\"* ]]; then\n\
    \        FP=$(echo \"${FP}\" | awk '{printf(\"%f\", $1 / $2)}')\n    fi\n    if\
    \ [[ ${FP} == *\"+\"* ]]; then\n        FP=$(echo \"${FP}\" | awk '{printf(\"\
    %f\", $1 + $2)}')\n    fi\n    local DECIMALS=1\n    if [[ ${FP} > 1 ]]; then\n\
    \        DECIMALS=$(echo \"${FP}\" | awk '{printf(\"%.0f\", $2 / $1)}')\n    fi\n\
    \    local INT_PART=${FP}\n    local INT_PART=${INT_PART%.*}\n    if [[ ${INT_PART}\
    \ -lt ${FP} ]]; then\n        INT_PART=$(printf \"%.0f\" ${INT_PART})\n    fi\n\
    \    # Return results\n    echo \"${DECIMALS}${INT_PART}\"\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7is43l60.sh: line 25: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local trunc=$1\n    local dec=${trunc:1}\n    local int=$((${trunc:0:1}\
    \ + ${trunc:1} - ${trunc:0:-1}))\n    local result=$((${trunc:0:-1} + ${trunc:1}\
    \ - ${trunc:0:-1}))\n    case \"${trunc:0:1}\" in\n        \"0\") result=${trunc:0:-1}\
    \ ;;\n        \"1\") result=${trunc:1:-1} ;;\n    esac\n    local res=${result}\n\
    \    local i=${#trunc}\n    while [[ $i -gt 0 ]]; do\n        local digit=${trunc:$((i-1))}\n\
    \        case \"${digit}\" in\n            \"0\") res=\"$res.$digit\";;\n    \
    \        \"1\") res=\"$res.$digit.$dec\";;\n        esac\n        let \"i=$i-1\"\
    \n    done\n    echo $res\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpn2zh1sq9.sh: line 13: 3 + .5 - 3.: syntax error: operand expected
    (error token is ".5 - 3.")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUM=\"${1}\"\n    local INT=\"${NUM}\"\n    local DEC=\"\"\n  \
    \  local DEC_PART=\"\"\n\n    while [ \"$INT\" -ne \"0\" ]; do\n        DEC=\"\
    ${DEC}0\"\n        INT=\"${INT}1\"\n    done\n\n    INT=\"${INT%1}\"\n    DEC_PART=\"\
    ${DEC}${INT}\"\n    echo \"${DEC_PART}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpv8sf7mo2.sh: line 16: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # Check if $1 is a floating point number\n    if [[ -z \"$1\" ]]; then\n\
    \        return 1\n    fi\n\n    # Convert $1 to integer\n    truncate_int=$(echo\
    \ \"$1\" | sed \"s/\\..*$//\")\n\n    # Check if truncate_int is an integer\n\
    \    if [[ ${#truncate_int} -ne ${#1} ]]; then\n        return 1\n    fi\n\n \
    \   # Check if the truncated integer is positive\n    if [[ ${truncate_int} -lt\
    \ 0 ]]; then\n        return 1\n    fi\n\n    # Check if truncate_int is smaller\
    \ than $1\n    if [[ ${truncate_int} -gt $1 ]]; then\n        return 1\n    fi\n\
    \n    # Decompose the integer part and decimals\n    truncate_int=$((truncate_int\
    \ - 1))\n    truncate_decimal=$(echo \"$1\" | awk \"{print $truncate_int}\") ||\
    \ exit 1\n\n    # Check if decimals are 0\n    if [[ ${#truncate_decimal} -eq\
    \ 0 ]]; then\n        truncate_decimal=1\n    fi\n\n    # Return truncated number\n\
    \    echo \"${truncate_decimal}\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    truncate_number_string=\"$1\"\n    echo $truncate_number_string\n   \
    \ truncate_number_string=\"$(echo $truncate_number_string | tr -d '\\\\')\"\n\
    \    truncate_number_string=\"$(echo $truncate_number_string | tr '.' '\\\\.')\"\
    \n    truncate_number_string=\"$(echo $truncate_number_string | sed 's/^[0-9]*\\\
    \\\\.//')\"\n    echo \"${truncate_number_string}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [[ $1 =~ ^-?[0-9]+$ ]]; then\n        # integer part\n        trunc_num=\"\
    ${BASH_REMATCH[0]}\"\n        trunc_num_int=\"${trunc_num//[^0-9]/}\"\n      \
    \  trunc_num_int=\"${trunc_num_int:0:1}\"\n        trunc_num_int=\"${trunc_num_int}.0\"\
    \n        trunc_num_int=\"${trunc_num_int}${trunc_num_int:1}\"\n        trunc_num_int=\"\
    ${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int}${trunc_num_int:1}\"\
    \n        trunc_num_int=\"${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int:0:-1}\"\
    \n        trunc_num_int=\"${trunc_num_int:0:-1}\"\n        trunc_num_int=\"${trunc_num_int:0:-1}\"\
    \n        # decimal part\n        trunc_num_dec=\"${trunc_num_int:0:1}\"\n   \
    \     trunc_num_dec=\"${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec//[^0-9]/}\"\
    \n        trunc_num_dec=\"${trunc_num_dec:0:1}\"\n        trunc_num_dec=\"${trunc_num_dec}.0\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"\
    ${trunc_num_dec}${trunc_num_dec:1}\"\n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_dec:1}\"\
    \n        trunc_num_dec=\"${trunc_num_dec}${trunc_num_\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp7wpaesm_.sh: line 53: unexpected EOF while looking for matching
    `"''

    /tmp/tmp7wpaesm_.sh: line 57: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local NUMBER=\"$1\"\n  echo \"${NUMBER%%.*}\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local trunc=0\n  local orig=${1%%.*}\n  local ndec=${orig#*\\.}\n  local\
    \ ddec=${ndec%%.*}\n  local frac=${ndec}\n\n  if [[ $ndec -lt 0 ]]; then\n   \
    \ echo \"Truncation number ${orig} is not a real number.\"\n    return 1\n  fi\n\
    \n  if [[ $ddec -lt 0 ]]; then\n    echo \"Truncation number ${orig} does not\
    \ end in a digit.\"\n    return 1\n  fi\n\n  if [[ $frac -lt 1 ]]; then\n    echo\
    \ \"Truncation number ${orig} does not contain a digit.\"\n    return 1\n  fi\n\
    \n  trunc=\"${ndec%%.*}\"\n  if [[ $ndec -eq 1 ]]; then\n    trunc=\"0\"\n  fi\n\
    \n  echo \"$trunc${ddec}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local decimal=$1\n    local factor=$(( 10#$decimal / 10 ))\n    local\
    \ remainder=$(( 10#$decimal - 10#$factor * 10 ))\n    local truncated=$(( $factor\
    \ ))\n    if [[ -z $truncated ]]; then\n        truncated=0\n    fi\n    echo\
    \ \"$truncated $remainder\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp2ojvqkkx.sh: line 12: 10#3.5 / 10 : syntax error: invalid arithmetic
    operator (error token is ".5 / 10 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local FP DECOMP INTEG DECL EXCL\n    FP=$1\n    FP=`echo \"${FP}\" |\
    \ sed 's/^\\([0-9]*\\)\\.\\([0-9]*\\).*$/\\1/'`\n    DECOMP=`echo \"${FP}\" |\
    \ sed 's/^\\([0-9]*\\)\\.\\([0-9]*\\).*$/\\1/'`\n    EXCL=`echo \"${FP}\" | sed\
    \ 's/^\\([0-9]*\\).*$/\\1/'`\n    INTEG=`echo \"${FP}\" | sed 's/^\\([0-9]*\\\
    ).*$/\\1/'`\n    echo \"${INTEG}\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=\"$1\"\n  # If $number is a float, we can get the decimal\
    \ part\n  local decimal\n  # If $number is an integer, the number will be a zero\n\
    \  local zero\n\n  if [[ -f $1 ]]; then # If the file is a real number\n    #\
    \ Get the decimal part from the last char of the string\n    decimal=\"${number##*.}\"\
    \n    # Get the integer part from the first char of the string\n    number=\"\
    ${number%.*}\"\n    # If the number is non-zero and negative, zero the number\n\
    \    zero=\"$(echo \"$number\" | grep -Eq '^[+-]$')\" && echo \"$zero\" || 0\n\
    \    # Round the number\n    number=\"$(echo \"$number\" | bc | tr -d '\\n')\"\
    \n  else # Otherwise, assume $number is an integer\n    zero=\"$(echo \"$number\"\
    \ | grep -Eq '^[+-]$')\" && echo \"$zero\" || 0\n    decimal=\"$(echo \"$number\"\
    \ | cut -c1-1)\"\n    number=\"$(echo \"$number\" | cut -c2)\"\n  fi\n\n  echo\
    \ \"$decimal $number\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpjs4t7z9a.sh: line 23: 0: command not found

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=$1\n    local DECIMALS=0\n    local DECIMAL_NUM\n\n    IFS=.\
    \ read -r -a DECIMAL_NUM <<< \"$NUMBER\"\n    DECIMALS=${#DECIMAL_NUM[@]}\n\n\
    \    if [ \"$DECIMALS\" -eq 0 ]; then\n        echo \"${DECIMAL_NUM[0]}\"\n  \
    \  else\n        echo \"$(echo \"${DECIMAL_NUM[0]}\" | cut -d. -f1)\"\n    fi\n\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if [ \"$(echo \"$1\" | awk '{print $1}')\" == \"$1\" ]; then\n    echo\
    \ \"$1\"\n  else\n    local number_int=\"$1\"\n    local number_dec=\"$1\"\n \
    \   local number_dec1=\"$(echo \"$number_dec\" | awk '{print $1}')\"\n    local\
    \ number_dec2=\"$(echo \"$number_dec\" | awk '{print $2}')\"\n    local number_dec3=\"\
    $(echo \"$number_dec\" | awk '{print $3}')\"\n\n    if [ -n \"$number_dec1\" ];\
    \ then\n      if [ -n \"$number_dec2\" ]; then\n        if [ -n \"$number_dec3\"\
    \ ]; then\n          echo \"${number_int}${number_dec1}.${number_dec2}.${number_dec3}\"\
    \n        else\n          echo \"${number_int}${number_dec1}.${number_dec2}\"\n\
    \        fi\n      else\n        echo \"${number_int}${number_dec1}\"\n      fi\n\
    \    elif [ -n \"$number_dec2\" ]; then\n      echo \"${number_int}.${number_dec2}\"\
    \n    elif [ -n \"$number_dec3\" ]; then\n      echo \"${number_int}.${number_dec3}\"\
    \n    else\n      echo \"${number_int}\"\n    fi\n  fi\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local x=\"${1%%+(.)}\"\n    local x=\"${x##*.}\"\n    local x=\"${x%+(.)}\"\
    \n    echo \"${x%.}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\ttruncate_number=\"$1\"\n\n\tlocal truncate_number\n\tIFS=\".\"\n\ttruncate_number=\"\
    ${truncate_number%?}\"\n\tlocal truncate_number_part\n\tlocal truncate_number_part_int\n\
    \tlocal truncate_number_part_dec\n\tlocal truncate_number_part_frac\n\n\t# Strip\
    \ off trailing \".0\" or \".00\", if present.\n\tcase \"${truncate_number}\" in\n\
    \t\t*.0)\n\t\ttruncate_number=${truncate_number%.0}\n\t\t;;\n\t\t*.00)\n\t\ttruncate_number=${truncate_number%.00}\n\
    \t\t;;\n\tesac\n\n\t# Test whether truncate_number is empty or zero.\n\t# Test\
    \ whether truncate_number is positive integer. Bail out if not.\n\tif [[ -z \"\
    ${truncate_number}\" ]]; then\n\t\treturn 0\n\telif (( truncate_number+0 != truncate_number\
    \ )); then\n\t\treturn 0\n\telif (( \"${truncate_number}\" < 1 )); then\n\t\t\
    return 0\n\telif (( \"${truncate_number}\" > 10E30 )); then\n\t\treturn 0\n\t\
    fi\n\n\t# If truncate_number is a floating point, extract integer part\n\t# and\
    \ decimal part.\n\ttruncate_number_part=\"$(echo \"${truncate_number}\" | bc)\"\
    \n\n\ttruncate_number_part_int=\"$(echo \"${truncate_number_part}\" | cut -d'('\
    \ -f 1)\"\n\ttruncate_number_part_dec=\"$(echo \"${truncate_number_part}\" | cut\
    \ -d'(' -f 2)\"\n\n\tlocal truncate_number_part_dec_final\n\tcase \"${truncate_number_part_dec}\"\
    \ in\n\t\t*.0)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec%.0}\n\
    \t\t;;\n\t\t*.00)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec%.00}\n\
    \t\t;;\n\t\t*)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec}\n\
    \t\t;;\n\tesac\n\n\t# Strip off trailing \".0\" or \".00\", if present.\n\tcase\
    \ \"${truncate_number_part_dec_final}\" in\n\t\t*.0)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final%.0}\n\
    \t\t;;\n\t\t*.00)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final%.00}\n\
    \t\t;;\n\t\t*)\n\t\ttruncate_number_part_dec_final=${truncate_number_part_dec_final}\n\
    \t\t;;\n\tesac\n\n\tlocal truncate_number_part_int\n\t\n}\n\ncandidate() {\n \
    \   truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local f=\"$1\"\n  local ipart=\"$(( ${f%%.*} + 1 ))\"\n  local decpart=\"\
    $(( ${f#$ipart%.*} ))\"\n  printf \"%.${decpart}f\" $ipart\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpty3ytci7.sh: line 13: 3.5 : syntax error: invalid arithmetic operator
    (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [[ \"$1\" =~ $((\\([^\\)]*\\) - \\([^\\)]*\\))*[^-]*[^0-9]\\([0-9]*\\\
    )$((\\([^\\)]*\\) - \\([^\\)]*\\))*[^-]*[^0-9]\\([0-9]*\\) ]]; then\n        #\
    \ e.g. \"3.5\" -> \"3.50\" -> \"3.499995\" -> \"3.50\"\n        echo \"${BASH_REMATCH[1]%.}\"\
    \n    else\n        echo \"$1\"\n    fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp58g_7tbd.sh: line 11: unexpected EOF while looking for matching
    `)''

    /tmp/tmp58g_7tbd.sh: line 31: unexpected argument to conditional binary operator

    /tmp/tmp58g_7tbd.sh: line 31: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if ! [[ $1 =~ ^[0-9.]+$ ]]; then\n    echo\n    echo \"Bad argument to\
    \ truncate_number: \\\"$1\\\".\"\n    echo\n    exit 1\n  fi\n\n  local trunc=\"\
    $1\"\n  local dec=0\n\n  if [[ $trunc =~ (^[0-9]+\\.[0-9]*)$ ]]; then\n    trunc=\"\
    ${BASH_REMATCH[1]}\"\n    dec-=1\n  fi\n\n  echo \"$trunc$((10#$dec))\"\n}\n\n\
    candidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpf4_gn55k.sh: line 23: dec-=1: command not found

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local num_string=$1\n  local truncated\n  local num_parts\n  local num\n\
    \  local num_dec\n  num_parts=$(echo \"${num_string}\" | perl -nle '/\\./||print\
    \ for/^\\d*$/')\n  num_dec=$(echo \"${num_parts}\" | perl -nle 'print 0+$_;END{exit\
    \ $?}')\n  num=$(echo \"${num_string}\" | perl -nle '/^\\d*$/&&{print 0+$_;END{exit\
    \ $?}}')\n  truncated=$(echo \"${num}\" | bc)\n  if [ ${truncated} -le ${num_dec}\
    \ ]; then\n    echo \"${num_string}\"\n  else\n    echo \"${truncated}\"\n  fi\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'syntax error at -e line 1, near ";END"

    syntax error at -e line 1, near "}}"

    Execution of -e aborted due to compilation errors.

    /tmp/tmpnyr3__9n.sh: line 20: [: -le: unary operator expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local val=\"$1\"\n    local intpart\n    local decimalpart\n    local\
    \ decpart\n    if [[ ${val} =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        local part1=\"\
    ${BASH_REMATCH[1]}\"\n        local part2=\"${BASH_REMATCH[2]}\"\n        local\
    \ part3=\"${BASH_REMATCH[3]}\"\n        if [[ ${part2} -eq 0 ]]; then\n      \
    \      intpart=\"${part1}\"\n            decimalpart=\"${part3}\"\n        else\n\
    \            intpart=\"${part1}.${part2}\"\n            decimalpart=\"${part3}.${part2}\"\
    \n        fi\n    else\n        intpart=\"${val}\"\n        decimalpart=\"0\"\n\
    \    fi\n    if [[ ${decimalpart} == *\".\"* ]]; then\n        decpart=\"${decimalpart%.*}\"\
    \n    else\n        decpart=\"0\"\n    fi\n    echo \"${intpart}.${decpart}\"\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local input=${1+\"$@\"}\n  local output=${input%.*}\n  local int_part\n\
    \  [[ -z \"$int_part\" ]] && int_part=\"$output\"\n  local dec_part\n  [[ -z \"\
    $dec_part\" ]] && dec_part=$output\n  local remain\n  [[ -z \"$remain\" ]] &&\
    \ remain=1\n  echo \"$int_part\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local input=${1:-1.0}\n  # Python doesn't support floating point rounding.\n\
    \  local integer=${input}\n  local decimal=${integer}\n\n  # Make sure we at least\
    \ have one decimal point.\n  [[ \"$decimal\" != \"$input\" ]] || return 0\n\n\
    \  local decimal=${decimal%%.*}\n\n  # If there is enough digits to round the\
    \ number up\n  # to the correct decimal point then rounding is easy.\n  if [[\
    \ \"$decimal\" -ge 1 ]]; then\n    return 0\n  fi\n\n  # We know that there are\
    \ more digits to round the number up\n  # than decimal points. We'll round the\
    \ number up to the next\n  # whole number and then truncate the decimals.\n  local\
    \ next_whole=0\n  local next_decimal=\n  while (( \"$decimal\" > 0 )); do\n  \
    \  (( next_whole++ ))\n    (( decimal = decimal / 10 ))\n  done\n  next_decimal=$((\
    \ $next_whole - 1 ))\n\n  (( next_decimal > 0 )) || return 0\n\n  # We now know\
    \ there are more decimal places to round the number up to.\n  # The number we\
    \ are rounding up is $next_whole.\n  (( next_whole++ ))\n\n  # If the decimal\
    \ part is smaller than 1, we round the number up\n  # to the next whole number.\
    \ Otherwise we just return the decimals.\n  if (( \"$decimal\" < 1 )); then\n\
    \    (( next_whole > 1 )) || return 0\n  else\n    (( next_whole > 0 )) || return\
    \ 0\n  fi\n\n  # Since we know that there are more decimal places,\n  # we'll\
    \ round the number up to the next whole number.\n  (( next_whole++ ))\n\n  # The\
    \ number we are rounding up is $next_whole.\n  (( next_whole > 1 )) || return\
    \ 0\n\n  # Since we know that there are more decimal places,\n  # we'll round\
    \ the number up to the next whole number.\n  (( next_whole++ ))\n\n  # The number\
    \ we are rounding up is $next_whole.\n  (( next_whole > 1 )) || return 0\n\n \
    \ # Now that we've rounded up, we know the number we are rounding\n  # to is always\
    \ greater than or equal to 0.5. We can truncate the\n  # decimal part without\
    \ worrying about truncating the decimals.\n  return $next_whole ${decimal}\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number_to_truncate=\"$1\"\n    # Easy out if number already is\
    \ a multiple of 1\n    if [ \"$number_to_truncate\" = \"$number_to_truncate.0\"\
    \ ]; then\n        echo \"$number_to_truncate\"\n        return 0\n    fi\n  \
    \  number_to_truncate=$($(echo ${number_to_truncate}|sed 's/^0\\+\\([0-9]*\\)\\\
    ..*/\\1/'))\n    # Round down if decimal part is greater than 1\n    if [ \"${number_to_truncate%.*}\"\
    \ -gt 1 ]; then\n        number_to_truncate=$(echo \"$number_to_truncate - 1\"\
    |bc)\n    fi\n    echo \"$number_to_truncate\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpbiro84ke.sh: line 17: 3.5: command not found

    /tmp/tmpbiro84ke.sh: line 19: [: : integer expression expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local fraction\n  local decimal\n  local integer\n \
    \ local sign\n  local decimals\n  local length\n  decimals=0\n  while [ \"${number}\"\
    \ -gt 0 ]; do\n    integer=\"$((10#$((number%1)*10#-1)))\"\n    fraction=\"$((10#(number/${integer})))\"\
    \n    decimal=\"$((10#${fraction}*10#-1))\"\n    if [ \"${integer}\" -lt 1 ] ||\
    \ [ \"${fraction}\" -lt 1 ] || [ \"${decimal}\" -lt 1 ]; then\n      # This can\
    \ happen for negative numbers (i.e. -1.5e-3): fraction is < 1 and\n      # integer\
    \ is less than 1, but decimal part is > 1.\n      break\n    fi\n    decimals=\"\
    $((${decimals} + ${decimal}))\"\n    number=\"${integer}${decimal}\"\n  done\n\
    \  if [ -z \"${number}\" ]; then\n    # This happens for 0, which has integer\
    \ part 0 but decimal part 0\n    return 0\n  fi\n  sign=${number#+}\n  number=${number%+}\n\
    \  length=${#number}\n  if [ ${length} -eq 0 ]; then\n    return 0\n  fi\n  #\
    \ Only keep if length is not even\n  if [ ${length} -eq 2 ]; then\n    number=\"\
    $((${number} + 1))\"\n  fi\n  printf \"%.${decimals}f\" ${number} || printf \"\
    0\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp9uatlxsl.sh: line 19: [: 3.5: integer expression expected

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local trunc_str=\"$(echo \"$1\") # cut away trailing zeros\n    local\
    \ trunc_int=\"$(echo \"$trunc_str\" | sed 's/^\\([0-9]*\\)\\.\\([0-9]*\\)$/\\\
    1\\2/') # convert fractional part to whole part\n    local trunc_dec=\"$(($trunc_str\
    \ - $trunc_int))\" # cut away decimal part\n    if [ \"$trunc_dec\" -lt 1 ]; then\n\
    \        trunc_dec=1\n    fi\n    echo $trunc_dec\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "/tmp/tmpzhmxtlzw.sh: line 13: 3.5 # cut away trailing zeros\n    local\
    \ trunc_int= - : syntax error: invalid arithmetic operator (error token is \"\
    .5 # cut away trailing zeros\n    local trunc_int= - \")\n"
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local IFS='.' read -r -a NUMBER <<<\"$1\"\n  local MAX=\"$(( ${NUMBER[@]:0:1}\
    \ ))\"\n  local MIN=\"$(( ${NUMBER[@]:0:1} ))\"\n  local DEC=\"$(( ${#NUMBER[@]}\
    \ - 1 ))\"\n  local DEC_UPP=\"$(echo \"$DEC\" | bc)\"\n\n  if [ $DEC -lt 0 ];\
    \ then\n    echo \"$MAX\"\n  else\n    echo \"$(( MAX / 10 ))\"\n  fi\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmphlldemaq.sh: line 11: local: `-r'': not a valid identifier

    /tmp/tmphlldemaq.sh: line 11: local: `-a'': not a valid identifier

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local decimals=${1:-10}\n  local integer_part=${number/%.*}\n\
    \  local decimal_part=$(( $number % $decimals ))\n  echo \"$decimal_part\"\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpca9b_gar.sh: line 14: 3.5 % 3.5 : syntax error: invalid arithmetic
    operator (error token is ".5 % 3.5 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUM\n    NUM=\"${1%.*}\"\n    local DECIMAL\n    DECIMAL=\"${NUM%.*}\"\
    \n    local INTEGER\n    INTEGER=\"${NUM#*.}\"\n    local PART\n    PART=\"${DECIMAL}\"\
    \n    DECIMAL=\"0\"\n    while [ \"${DECIMAL}\" -lt 1 ]; do\n        DECIMAL=\"\
    ${DECIMAL}0\"\n        INTEGER=\"${INTEGER}1\"\n    done\n    echo -n \"${PART}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=27 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=23 encoding='utf-8'>
  timestamp: 1660058859
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local decimals=0\n  local number=0\n  local decimal=0\n  local tempnum=0\n\
    \  local decpart\n\n  if [[ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    decimals=$(echo\
    \ $1 | sed 's/\\.//g' | awk '{print length($1)}')\n    number=$1\n  elif [[ $1\
    \ =~ ^[0-9]+$ ]]; then\n    decimals=0\n    number=$1\n  else\n    echo \"Cannot\
    \ determine number of decimals for $1\"\n    return 1\n  fi\n\n  tempnum=$(echo\
    \ \"$number\" | sed 's/\\.//g')\n\n  while [[ $tempnum -ne 0 ]]; do\n    decimal=$((decimal\
    \ + 1))\n    tempnum=$(echo \"$tempnum\" | cut -d. -f1)\n  done\n\n  if [ \"$decimal\"\
    \ -gt \"$decimals\" ]; then\n    echo \"Number of decimals $decimals for $1 greater\
    \ than number of decimals $decimals for $2\"\n    return 1\n  fi\n\n  decpart=$((decimal-decimals))\n\
    \n  echo \"$number\"\n  echo \"${number%.$decpart}\"\n}\n\ncandidate() {\n   \
    \ truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=47 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=45 encoding='utf-8'>
  timestamp: 1660058859
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"${1%.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # $1: Float\n    local n=$1\n    local frac\n    local dec\n    local\
    \ int\n\n    if [[ $n -eq $n ]]; then\n        int=$n\n        frac=0 # integer\
    \ part\n    else\n        frac=$n\n        int=0\n    fi\n    dec=$(( ${#frac}\
    \ % 10 ))\n\n    if [[ \"$dec\" -gt 0 ]]; then\n        echo -n \"0.\"\n    fi\n\
    \    echo ${frac%%.*}\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp_zmy8m01.sh: line 17: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$1\" | cut -d \".\" -f1 | sed 's/^0*//;s/^0*\\.//;s/^0*$//'\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimal_part\n    local decimal_part_num\n\
    \    local fractional_part\n    local whole_part\n    local number_part\n    local\
    \ trunc_result\n\n    decimal_part=$(echo \"$number\" | awk -F. -v x=\"$number\"\
    \ 'BEGIN{print x/10; exit}')\n    decimal_part_num=$(echo \"$decimal_part\" |\
    \ sed -e 's/\\./0/g')\n    fractional_part=$(echo \"$decimal_part\" | sed -e 's/^0*//')\n\
    \    whole_part=$(echo \"$number\" | awk 'BEGIN{print x}')\n    number_part=$(echo\
    \ \"$whole_part*10\" | bc)\n\n    trunc_result=$(echo \"scale=3; $number_part\
    \ * $decimal_part_num / $fractional_part\" | bc)\n\n    # If the number is a non-positive\
    \ integer, the decimal part is returned.\n    case \"$trunc_result\" in\n    \
    \    0)\n            echo \"0\"\n            ;;\n        *)\n            echo\
    \ \"$trunc_result\"\n            ;;\n    esac\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '(standard_in) 1: syntax error

    (standard_in) 1: syntax error

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    # $1\n    truncate_part=$1\n    truncate_part=$(echo \"$truncate_part\"\
    \ | awk '{printf \"%.1f\", $1/1}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.2f\", $1/2}')\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.3f\", $1/3}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.4f\", $1/4}')\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.5f\", $1/5}')\n\
    \    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.6f\", $1/6}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.7f\", $1/7}')\n    # echo \"$truncate_part\"\
    \n    truncate_part=$(echo \"$truncate_part\" | awk '{printf \"%.8f\", $1/8}')\n\
    \    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.9f\", $1/9}')\n    # echo \"$truncate_part\"\n    # echo \"\
    $truncate_part\"\n    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\"\
    \ | awk '{printf \"%.10f\", $1/10}')\n    # echo \"$truncate_part\"\n    # echo\
    \ \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    truncate_part=$(echo \"$truncate_part\" |\
    \ awk '{printf \"%.12f\", $1/12}')\n    # echo \"$truncate_part\"\n    truncate_part=$(echo\
    \ \"$truncate_part\" | awk '{printf \"%.14f\", $1/14}')\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"\
    $truncate_part\"\n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\
    \n    # echo \"$truncate_part\"\n    # echo \"$truncate_part\"\n    truncate_part\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmp528o9gzn.sh: line 51: truncate_part: command not found

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n   local x=\"$1\"\n   if [ \"$x\" = \"--help\" -o \"$x\" = \"-h\" -o \"$x\"\
    \ = \"--h\" -o \"$x\" = \"-?\" -o \"$x\" = \"help\" -o \"$x\" = \"\\?\" ]; then\n\
    \      echo \"Usage: $(basename $0) [floating point number]\"\n      echo \"Displays\
    \ the decimal part of the given floating number.\"\n      exit 0\n   fi\n\n  \
    \ if [[ \"$x\" =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n      local integer=\"$1\"\n \
    \     integer=\"$(echo \"$integer\" | sed 's/^-//')\"\n      local decimal=\"\
    $x\"\n      decimal=\"$(echo \"$decimal\" | sed 's/^.-//')\"\n\n      local integer_part=\"\
    ${integer%.*}\"\n      local decimal_part=\"${x#$integer_part}\"\n\n      if ((\
    \ $decimal_part == 0 )) ; then\n         decimal=\"0\"\n      fi\n\n      echo\
    \ \"$decimal_part\"\n   elif [[ $x =~ ^[0-9]+\\.?[0-9]*$ ]]; then\n      echo\
    \ \"$x\"\n   elif [[ $x =~ ^[0-9]+$ ]]; then\n      echo \"$x\"\n   else\n   \
    \   echo \"$x\"\n   fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmput70269q.sh: line 27: ((: .5 == 0 : syntax error: operand expected
    (error token is ".5 == 0 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal x\n\tx=\"$1\"\n\tshift\n\tlocal d\n\td=\"$(echo \"$x\" | awk '{print\
    \ int('$1', 8)}')\"\n\techo \"${x%.*}\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: 'awk: cmd. line:1: {print int(, 8)}

    awk: cmd. line:1:            ^ syntax error

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    if [[ $1 =~ ^[0-9]+\\.[0-9]+$ ]]; then\n        echo \"$1\"\n       \
    \ echo \"$1\"\n        echo \"$1\"\n        echo \"$1\"\n        echo \"$1\"\n\
    \        echo \"$1\"\n        echo \"$1\"\n    else\n        echo \"0\"\n    fi\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n   local x=\"${1}\"\n   local integer=\"${x%?}\"\n   local decimal=\"${x#$integer}\"\
    \n   echo \"${decimal}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local float=$1\n  local int_part=$(expr floor $float)\n  local frac_part=$(expr\
    \ rem $float $int_part)\n  printf \"%.1f\" $frac_part\n}\n\ncandidate() {\n  \
    \  truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\"\
    ) = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "expr: syntax error: unexpected argument \u20183.5\u2019\nexpr: syntax error:\
    \ unexpected argument \u20183.5\u2019\n"
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal trunc=$1\n\tlocal dec=$(echo \"$trunc\" | bc)\n\techo \"$dec\"\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local input=\"$1\"\n    local IFS=.\n    local dec=0\n    local IFS_backup=\"\
    $IFS\"\n    IFS=$'\\n' dec=$(echo \"$input\" | sed -e 's/^'\"$input\"'//')\n \
    \   IFS=\"$IFS_backup\"\n    echo \"$dec\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local fp dec i\n    fp=${1}\n    IFS=. read -ra dec <<< \"$(echo \"$fp\"\
    \ | sed 's/^\\(-*[0-9]*\\.\\)\\([0-9]*\\).*$/\\1/')\"\n    if [[ -n \"${dec[1]}\"\
    \ ]]; then\n        i=\"${#dec[@]}\"\n        if [[ -n \"${dec[i - 1]}\" ]]; then\n\
    \            if (( ${dec[1]} > ${dec[i - 1]} )) ; then\n                dec[1]=\"\
    ${dec[i - 1]}\"\n            else\n                dec[1]=0\n            fi\n\
    \        else\n            i=0\n        fi\n    fi\n    echo \"${fp%.*}.${dec[1]}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\t# Strip leading 0s from the number or else the result\n\t# is incorrect:\
    \ 0.045 -> 0.4\n\tlocal NUMBER=$1\n\tif [[ $NUMBER == *\".\"* ]]; then\n\t\tNUMBER=\"\
    ${NUMBER%.*}\"\n\tfi\n\tlocal PART_INTEGER\n\tlocal PART_DECIMAL\n\tPART_INTEGER=${NUMBER#0}\n\
    \tPART_DECIMAL=${NUMBER%.*}\n\tif [[ \"$1\" == \"$NUMBER\" ]]; then\n\t\techo\
    \ \"$PART_DECIMAL\"\n\telse\n\t\techo \"$PART_INTEGER\"\n\tfi\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local intpart=$(echo $number | cut -d\"e\" -f1)\n\
    \    local decimals=$(echo $number | cut -d\"e\" -f2)\n    local decimalpart=$(echo\
    \ $number | cut -d\"e\" -f3)\n\n    # Ensure that decimalpart is a positive integer\n\
    \    if (( $decimalpart > 0 )); then\n        echo \"$intpart.$decimalpart\"\n\
    \    else\n        echo \"$intpart\"\n    fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1nn1td9l.sh: line 17: ((: 3.5 > 0 : syntax error: invalid arithmetic
    operator (error token is ".5 > 0 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local x=\"$1\" # Input floating point number\n  local integer=\"$(( (x\
    \ | cut -d '.' -f 1) | cut -d '' -f 1) )\" # Get integer part (ignore decimal\
    \ part)\n  local decimal=\"$(( (x | cut -d '.' -f 2) | cut -d '' -f 1) )\" # Get\
    \ decimal part\n  [ -n \"$decimal\" ] && decimal=\"$(( decimal / 10 ))\" # Scale\
    \ decimal part to 10 (right side is never less than 1)\n  printf \"%.1f\" \"$decimal\"\
    \ # Return decimal part\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpuyp67w3g.sh: line 12: x: command not found

    /tmp/tmpuyp67w3g.sh: line 13: x: command not found

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n\n    echo \"${number%.*}\" | bc -l | sed -e \"s/^\\\
    ..*//\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local int_part\n    local dec\n    int_part=$((\
    \ ${number} % 1 ))\n    dec=$(( ${number} - $int_part ))\n    echo \"${dec}\"\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp3ckmc8cp.sh: line 14: 3.5 % 1 : syntax error: invalid arithmetic
    operator (error token is ".5 % 1 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local var_name=\"$1\"\n  local value=\"$2\"\n  local precision=\"$3\"\n\
    \n  local precision_int precision_dec\n  local int_part dec_part\n  local int_part_len\
    \ dec_part_len\n\n  # Remove leading zeroes if precision is zero\n  if [[ $precision\
    \ == 0 ]]; then\n    precision=8\n  fi\n\n  int_part=\"$(\n    IFS=.\n    echo\
    \ \"$value\"\n  )\"\n  dec_part=\"$(\n    IFS=.\n    echo \"$value\"\n  )\"\n\n\
    \  precision=\"$((${precision}-1))\"\n  int_part_len=\"$(\n    echo $int_part\
    \ |\n    awk -F. '{print length}'\n  )\"\n  dec_part_len=\"$(\n    echo $dec_part\
    \ |\n    awk -F. '{print length}'\n  )\"\n\n  # If precision is too small and\
    \ the integer part contains only one digit,\n  # we round up to the next higher\
    \ integer\n  if [[ $int_part_len == 1 && $dec_part_len > $precision ]]; then\n\
    \    dec_part=\"$dec_part.$((${precision}-1))\"\n  fi\n\n  if [[ ${precision}\
    \ -gt ${int_part_len} ]]; then\n    echo \"$dec_part\"\n  else\n    echo \"$int_part.$dec_part\"\
    \n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=\"$1\"\n  local integer_part=\"$(echo \"$number\" | awk '{print\
    \ int($1)}')\"\n  local decimal_part=\"$(echo \"$number\" | awk '{print int($1\
    \ / $1)}')\"\n  if [ \"$decimal_part\" -eq 0 ]; then\n    echo \"$integer_part\"\
    \n  else\n    echo \"$integer_part$decimal_part\"\n  fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal trunc_num=${1%.*}\n\tlocal trunc_str=\"${trunc_num}\"\n\t# strip\
    \ trailing zeros\n\tlocal trunc_num=${trunc_num%%.*}\n\tlocal trunc_str=\"${trunc_str%%.*}\"\
    \n\tlocal trunc_int=0\n\tlocal trunc_dec=0\n\n\twhile true; do\n\t\tlocal char=${trunc_str:0:1}\n\
    \t\ttrunc_str=\"${trunc_str:1:1}\"\n\t\tcase \"$char\" in\n\t\t\t0)\n\t\t\t\t\
    break\n\t\t\t\t;;\n\t\t\t[!0-9])\n\t\t\t\techo \"Invalid float '$trunc_str'\"\
    \ >&2\n\t\t\t\treturn -1\n\t\t\t\t;;\n\t\tesac\n\t\ttrunc_int=$((trunc_int + $char))\n\
    \t\ttrunc_dec=$((trunc_dec + ${trunc_int:-0}))\n\tdone\n\n\techo \"${trunc_int:-0}.${trunc_dec:-0}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpz_mjy8ep.sh: line 31: trunc_int + : syntax error: operand expected
    (error token is "+ ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local num=$(echo \"$1\" | bc)\n  local intpart=$(echo \"$num\" | sed -r\
    \ \"s/^([0-9]+)\\.*$/\\1/\")\n  local decpart=$(echo \"$num\" | sed -r \"s/^([0-9]+)\\\
    .0+$/\\1/\")\n  if (( intpart != num )); then\n    echo \"$decpart\"\n  else\n\
    \    echo \"$1\"\n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpwmcl6iqr.sh: line 14: ((: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if ! echo \"${1}\" | egrep -E \"^[+-]?[0-9]+\\.?[0-9]*$\" > /dev/null;\
    \ then\n    echo \"FAIL: invalid number: ${1}\" >&2\n    exit -1\n  fi\n  x=$(echo\
    \ \"${1}\" | sed 's/^\\([+-]?[0-9]+\\)\\.\\([0-9]*\\)$/\\1\\2/')\n  echo ${x}\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\t# Truncate a number from its decimal part.\n\t# $1 is number\n\tcase \"\
    $1\" in\n\t\t*)\n\t\t\t[ \"${#1}\" -gt \"2\" ] && echo \"number too long!\" &&\
    \ exit 1;\n\t\t\t[ \"${#1}\" -eq \"1\" ] && echo \"number too short!\" && exit\
    \ 1;\n\t\t\t[ \"${#1}\" -lt \"5\" ] && echo \"number too short!\" && exit 1;\n\
    \t\t\ttruncate_number_parts=$(echo \"$1\" | cut -d. -f1)\n\t\t\tnumber_part=$(echo\
    \ \"$truncate_number_parts\" | cut -d. -f1)\n\t\t\tdecimal_part=$(echo \"$truncate_number_parts\"\
    \ | cut -d. -f2)\n\t\t\techo \"$number_part\"\n\t\t\techo \"$decimal_part\"\n\t\
    \t;;\n\tesac\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal trunc=$1; shift\n\tlocal d=$1; shift\n\techo $(( $d % 1 ))\n\twhile\
    \ (( $d > 1 )); do\n\t\techo 0\n\t\td=$(echo \"$d/10\" | bc)\n\tdone\n\ttrunc=$(($trunc+$d))\
    \ ;\n\techo \"$trunc\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmptsyghd8h.sh: line 13: % 1 : syntax error: operand expected (error
    token is "% 1 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimals=0\n    local integer\n    local remainder\n\
    \n    if [[ $number == * ([^.]*).* ]]; then\n        integer=${BASH_REMATCH[1]}\n\
    \        decimals=${#integer}\n        number=${number#*.*}\n    else\n      \
    \  integer=0\n        decimals=0\n    fi\n\n    # In case integer part is zero\n\
    \    if [[ $integer == 0 ]]; then\n        echo \"$number\"\n        return 0\n\
    \    fi\n\n    remainder=`echo \"$number\" | bc -l`\n    echo $(($remainder%1))\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpwy9aj3rw.sh: line 16: syntax error in conditional expression: unexpected
    token `(''

    /tmp/tmpwy9aj3rw.sh: line 16: syntax error near `([''

    /tmp/tmpwy9aj3rw.sh: line 16: `    if [[ $number == * ([^.]*).* ]]; then''

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimals=0\n    local truncate_decimal\n \
    \   while [[ $number > 1 || $number == 1 ]]; do\n        decimals=$(expr ${decimals}\
    \ + 1)\n        if [[ $number > 1 ]]; then\n            truncate_decimal=$(echo\
    \ \"$number*10\" | bc)\n        else\n            truncate_decimal=$(echo \"$number\"\
    \ | bc)\n        fi\n        number=$($truncate_decimal %)\n    done\n    echo\
    \ \"$decimals\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: '/tmp/tmpt7kgq9vb.sh: line 21: 35.0: command not found

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    trunc_part=${1%.*}\n    trunc_part=$(echo \"$trunc_part\" | bc)\n   \
    \ trunc_part=${trunc_part%.*}\n    trunc_part=${trunc_part:-0}\n    trunc_part=$(echo\
    \ \"$trunc_part\" | bc)\n    echo \"$trunc_part\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local number_in_int=$(( ${number} % 1 ))\n  local decimals=$((\
    \ (${number}%1)*10^(( ${#number}-1 )) ))\n  echo \"${decimals:-0}\"\n}\n\ncandidate()\
    \ {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp33j8365o.sh: line 12: 3.5 % 1 : syntax error: invalid arithmetic
    operator (error token is ".5 % 1 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=$1\n    local decimals=$2\n    local integer_part=$(( ${number%.*}\
    \ ))\n    if [[ ${decimals} -lt 1 ]]; then\n        local decimal_part=0\n   \
    \ else\n        local decimal_part=$(( ${decimals%.*} ))\n    fi\n    echo \"\
    ${integer_part}.${decimal_part}\"\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local num=$1\n  local truncated=$(echo $num | awk -F. -v n=${num%.*} -v\
    \ d=1<<31|bc)\n  [[ $truncated -gt $num ]] && truncated=$(expr ${truncated}+1\
    \ \\* ${d})\n  echo $truncated\n}\n\ncandidate() {\n    truncate_number \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[\
    \ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\"\
    \ ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "/tmp/tmp59adn9pb.sh: line 13: warning: here-document at line 13 delimited\
    \ by end-of-file (wanted `31')\n/tmp/tmp59adn9pb.sh: line 13: warning: here-document\
    \ at line 13 delimited by end-of-file (wanted `31')\n/tmp/tmp59adn9pb.sh: line\
    \ 12: warning: here-document at line 12 delimited by end-of-file (wanted `31')\n\
    Usage: awk [POSIX or GNU style options] -f progfile [--] file ...\nUsage: awk\
    \ [POSIX or GNU style options] [--] 'program' file ...\nPOSIX options:\t\tGNU\
    \ long options: (standard)\n\t-f progfile\t\t--file=progfile\n\t-F fs\t\t\t--field-separator=fs\n\
    \t-v var=val\t\t--assign=var=val\nShort options:\t\tGNU long options: (extensions)\n\
    \t-b\t\t\t--characters-as-bytes\n\t-c\t\t\t--traditional\n\t-C\t\t\t--copyright\n\
    \t-d[file]\t\t--dump-variables[=file]\n\t-D[file]\t\t--debug[=file]\n\t-e 'program-text'\t\
    --source='program-text'\n\t-E file\t\t\t--exec=file\n\t-g\t\t\t--gen-pot\n\t-h\t\
    \t\t--help\n\t-i includefile\t\t--include=includefile\n\t-l library\t\t--load=library\n\
    \t-L[fatal|invalid|no-ext]\t--lint[=fatal|invalid|no-ext]\n\t-M\t\t\t--bignum\n\
    \t-N\t\t\t--use-lc-numeric\n\t-n\t\t\t--non-decimal-data\n\t-o[file]\t\t--pretty-print[=file]\n\
    \t-O\t\t\t--optimize\n\t-p[file]\t\t--profile[=file]\n\t-P\t\t\t--posix\n\t-r\t\
    \t\t--re-interval\n\t-s\t\t\t--no-optimize\n\t-S\t\t\t--sandbox\n\t-t\t\t\t--lint-old\n\
    \t-V\t\t\t--version\n\nTo report bugs, see node `Bugs' in `gawk.info'\nwhich is\
    \ section `Reporting Problems and Bugs' in the\nprinted version.  This same information\
    \ may be found at\nhttps://www.gnu.org/software/gawk/manual/html_node/Bugs.html.\n\
    PLEASE do NOT try to report bugs by posting in comp.lang.awk,\nor by using a web\
    \ forum such as Stack Overflow.\n\ngawk is a pattern scanning and processing language.\n\
    By default it reads standard input and writes standard output.\n\nExamples:\n\t\
    gawk '{ sum += $1 }; END { print sum }' file\n\tgawk -F: '{ print $1 }' /etc/passwd\n\
    /tmp/tmp59adn9pb.sh: line 13: [[: 3.5: syntax error: invalid arithmetic operator\
    \ (error token is \".5\")\n"
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if [[ $1 == 0 ]]; then\n    echo \"0\"\n  else\n    if [[ $1 == \"0\" ]];\
    \ then\n      echo \"0\"\n    else\n      echo $(($1 / 10 + $1 % 10))\n    fi\n\
    \  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpynas947v.sh: line 17: 3.5 / 10 + 3.5 % 10: syntax error: invalid
    arithmetic operator (error token is ".5 / 10 + 3.5 % 10")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  echo \"$1\"\n  if [[ $1 =~ ^-?[0-9]+\\.[0-9]+$ ]]; then\n    echo \"${1%%.*}\"\
    \n  fi\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local integer=0\n  local decimal=0\n  while [ \"$number\"\
    \ != \"\" ]; do\n    decimal=$(( $decimal + 1 ))\n    integer=$(( $integer + 1\
    \ ))\n    number=$(echo \"$number\" | cut -c -$(( $decimal + 1 ))) | tail -n 1\n\
    \  done\n  echo \"$integer\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=52 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=13 encoding='utf-8'>
  timestamp: 1660058859
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local number=$1\n  local trunc_part\n  local decomp\n  trunc_part=${number%.*}\n\
    \  decomp=`echo \"$number\" | bc -l`\n  if [[ $decomp -ge 0 ]]; then\n    echo\
    \ \"$trunc_part\"\n  else\n    echo \"0\"\n  fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbaolqo7k.sh: line 16: [[: 3.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: -1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local v=\"$1\"\n  local d=0\n\n  while [ \"${v:0:1}\" != \".\" ]; do\n\
    \    v=\"${v:0:1}\"\n    d=$(( ${#v} - 1 ))\n  done\n\n  # if the original number\
    \ is smaller than 1 then return it\n  if [ \"${d}\" -lt 1 ]; then\n    echo \"\
    0\"\n    return 0\n  fi\n\n  # find the decimal part length\n  local d=0\n  while\
    \ [ \"${v:0:1}\" == \".\" ]; do\n    v=\"${v:1}\"\n    d=$(( ${d} + 1 ))\n  done\n\
    \n  local i\n\n  # if the original number is smaller than 1 then return it\n \
    \ if [ \"${d}\" -lt 1 ]; then\n    echo \"0\"\n    return 0\n  fi\n\n  # now v\
    \ is of form \"99.99\"\n  local frac\n\n  # if d is odd, then v is 99.99, otherwise\
    \ v is 99.999...\n  if [ \"${d}\" -eq 1 ]; then\n    if [ \"${#v}\" -eq 4 ]; then\n\
    \      v=\"${v:0:3}\"\n    else\n      v=\"${v:0:2}\"\n    fi\n  fi\n\n  # now\
    \ v is 99 if d is odd, or 99.999... if d is even\n  local i\n  for i in {1..d};\
    \ do\n    frac=\"${frac}.${v:0:1}\"\n    v=\"${v:1}\"\n  done\n\n  # we now have\
    \ frac that has the form \"0....\"\n  # now we must check if this frac can be\
    \ represented as an integer\n  local i\n  for i in {0..0}; do\n    local f=\"\
    ${frac}.${i}\"\n    local fint\n    fint=$(python -c \"\n      import re;\n  \
    \    print float(re.sub('0+$', '', re.sub('\\\\.$', '', $f)))\n      \"\n    )\n\
    \    if [ \"${fint}\" == \"${f}\" ]; then\n      break\n    fi\n  done\n  unset\
    \ i\n\n  # we now have the integer part of the frac if possible\n  echo \"${frac}\"\
    \n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Timeout
  stderr: <_io.TextIOWrapper name=64 encoding='utf-8'>
  stdout: <_io.TextIOWrapper name=59 encoding='utf-8'>
  timestamp: 1660058859
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  # Avoid division by zero\n  local IFS\n  IFS=.\n  # $1 is a floating point\n\
    \  local x=$1\n  # Get the integer part and decimal part\n  local y=$(( $1 / $x\
    \ ))\n  # Truncate decimal part\n  local z=$(( $x * $y ))\n  # Return integer\
    \ part and decimal part\n  echo $z\n}\n\ncandidate() {\n    truncate_number \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n  \
    \  [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpdngjobsr.sh: line 17: 3.5 / 3.5 : syntax error: invalid arithmetic
    operator (error token is ".5 / 3.5 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local number=\"${1}\"\n    local trunc=0\n    local intpart\n    local\
    \ decimals\n    while [[ -n \"$number\" ]]; do\n        intpart=\"${number%%.*}\"\
    \n        decimals=\"${number#$intpart}\"\n        trunc=$(( intpart*10 + $decimals\
    \ ))\n        number=\"${number%$decimals}\"\n    done\n    echo $trunc\n}\n\n\
    candidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpvklethxr.sh: line 18: intpart*10 + .5 : syntax error: operand expected
    (error token is ".5 ")

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local x=\"${1}\"\n    local -a parts=($x)\n    local -i dec=${#parts[@]}\n\
    \    local -i factor=${#parts[0]}\n\n    if [ \"$dec\" -ne \"$factor\" ]; then\n\
    \        echo \"Truncating number $x to $dec decimal digits.\"\n        dec=0\n\
    \    fi\n\n    local -i i\n    i=0\n    while [ $((++i)) -lt \"$dec\" ];\n   \
    \ do\n        parts[$i]=$(expr \"$parts[$i]\" + \"1)\"\n    done\n\n    echo \"\
    ${parts[@]%.*}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"\
    1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpm6oshpem.sh: line 25: unexpected EOF while looking for matching
    `)''

    /tmp/tmpm6oshpem.sh: line 43: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  truncate_number_str=$(echo \"$1\" | bc)\n  echo \"${truncate_number_str%%\\\
    .}\"\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") =\
    \ \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local string=\"$1\"\n    local intpart=\"1\"\n    local decimals=\"0\"\
    \n\n    if [[ $string == [+-]?[0-9]([.][0-9]*) ]]; then\n        intpart=$(echo\
    \ \"$string\" | sed -e 's/^[+-]\\?//g')\n        decimals=\"$(echo \"$string\"\
    \ | sed -e 's/^[+-]\\?//g' | sed -e 's/^[+-]\\([0-9]\\)//g' | sed -e 's/^\\([0-9.]\\\
    )//g')\"\n        if [[ $string =~ [+-]?[0-9]([.][0-9]*) ]]; then\n          \
    \  echo \"$intpart$decimals\"\n        else\n            echo \"$decimals\"\n\
    \        fi\n    else\n        echo \"$string\"\n    fi\n}\n\ncandidate() {\n\
    \    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate\
    \ \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp4xu9wred.sh: line 15: syntax error in conditional expression: unexpected
    token `(''

    /tmp/tmp4xu9wred.sh: line 15: syntax error near `[+-]?[0-9]([''

    /tmp/tmp4xu9wred.sh: line 15: `    if [[ $string == [+-]?[0-9]([.][0-9]*) ]];
    then''

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n\tlocal number=\"$1\"\n\tlocal decimals=${1%.*}\n\techo \"${decimals}\"\n\
    }\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\"\
    \ ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local NUMBER=\"$1\"\n    local IFS=.\n    local RESULT\n    local EXITCODE=0\n\
    \n    # Sanitize input\n    # - If no number is given, we set the exit code.\n\
    \    # - If empty string is given, we set the exit code.\n    # - If the number\
    \ is invalid, we set the exit code.\n    if [ -z \"$NUMBER\" ]; then\n       \
    \ echo \"Missing number. Exiting.\"\n        EXITCODE=1\n        exit $EXITCODE\n\
    \    fi\n    if [ \"$NUMBER\" == \"\" ]; then\n        echo \"Invalid number.\
    \ Exiting.\"\n        EXITCODE=1\n        exit $EXITCODE\n    fi\n\n    # Strip\
    \ leading and trailing spaces and dots.\n    NUMBER=$(echo \"$NUMBER\" | sed -e\
    \ 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\n\n    # Strip trailing zeros.\n\
    \    NUMBER=$(echo \"$NUMBER\" | sed -e 's/^0*$//')\n\n    # Remove leading and\
    \ trailing dots.\n    NUMBER=$(echo \"$NUMBER\" | sed -e 's/^\\.*//' -e 's/\\\
    .*$//')\n\n    # Strip extra leading 0s\n    NUMBER=$(echo \"$NUMBER\" | sed -e\
    \ 's/^0*//')\n\n    # Make sure number is positive.\n    if [ \"$NUMBER\" < 0\
    \ ]; then\n        echo \"Invalid number. Exiting.\"\n        EXITCODE=1\n   \
    \     exit $EXITCODE\n    fi\n\n    # If the number has only one digit, there\
    \ is nothing to do.\n    if [ ${#NUMBER} == 1 ]; then\n        echo \"Invalid\
    \ number. Exiting.\"\n        EXITCODE=1\n        exit $EXITCODE\n    fi\n\n \
    \   # Truncate decimal part.\n    RESULT=$(echo \"$NUMBER\" | awk 'BEGIN{a=\"\"\
    ;b=0}')\n    while [ \"$RESULT\" -gt \"0\" ]; do\n        if [ \"$b\" == 0 ];\
    \ then\n            a=\"1\"\n        else\n            a=\"$a\"\n        fi\n\
    \        b=`expr $b - 1`\n        RESULT=$(echo \"$RESULT\" | awk 'BEGIN{a=\"\"\
    ;b=0}')\n    done\n\n    # Return the decimal part or 0.\n    if [ \"$RESULT\"\
    \ -gt \"0\" ]; then\n        echo $a\n    else\n        echo \"0\"\n    fi\n}\n\
    \ncandidate() {\n    truncate_number \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate \"1.25\") = \"0.25\" ]]\n\
    \    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n    local x=\"${1}\"\n    # truncate x to 1 decimal place\n    # x is negative\n\
    \    if [[ $x =~ ([-+])([0-9]+\\.[0-9]+) ]]; then\n        x=${BASH_REMATCH[1]}\n\
    \    fi\n    # x is positive\n    if [[ $x =~ ([0-9]*\\.[0-9]+) ]]; then\n   \
    \     x=${BASH_REMATCH[1]}\n    fi\n    echo \"$x\"\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660058854
- exit_code: 2
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  local float=$1\n  local num=0;\n  local dec=0;\n  local decstr=0;\n  local\
    \ laststr=0;\n\n  # find decimal point\n  for (( i=${#float}-2; i>=0; i-- ));\
    \ do\n    case ${float:$i:1} in\n      [Ee][-+]* )\n        decstr=$i;\n     \
    \   laststr=${float:$i:1}\n        break\n        ;;\n      * ) break\n    esac\n\
    \  done\n  if [[ -z ${decstr} ]]; then\n    echo \"ERROR: input is not in floating\
    \ point format\"\n    return 1\n  fi\n\n  # find integer part\n  while [[ ${#decstr}\
    \ -gt 0 ]] && [[ ${decstr} -le ${#float} ]]; do\n    ((num+=${float:${#float}-1:${#float}-1}*10))\
    \ dec=${decstr}\n    laststr=${float:$((i-1)):1}\n    ((i--))\n  done\n  # if\
    \ there are no digits left in the input string,\n  # the result will be zero.\n\
    \  if [[ -z ${i} ]]; then\n    echo \"ERROR: input string has no digits left in\
    \ the floating point part\"\n    return 1\n  fi\n  ((dec=num%10))\n\n  # if decimal\
    \ is larger than 1, remove it\n  if [[ ${dec} -gt 1 ]]; then\n    echo \"${float:0:${#float}-1}.\"\
    \n  else\n    echo \"${float}\"\n  fi\n}\n\ncandidate() {\n    truncate_number\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n\
    \    [[ $(candidate \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"\
    0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpf34deooo.sh: line 35: syntax error near unexpected token `dec=${decstr}''

    /tmp/tmpf34deooo.sh: line 35: `    ((num+=${float:${#float}-1:${#float}-1}*10))
    dec=${decstr}''

    '
  stdout: ''
  timestamp: 1660058854
- exit_code: 1
  program: "#!/bin/bash\n# Given a positive floating point number, it can be decomposed\
    \ into\n# and integer part (largest integer smaller than given number) and decimals\n\
    # (leftover part always smaller than 1).\n# Return the decimal part of the number.\n\
    # >>> $(truncate_number \"3.5\")\n# \"0.5\"\n#\n# $1 is a floating point\ntruncate_number()\
    \ {\n  if (( $# != 1 )) ; then\n    echo \"Usage: $(basename $0) <number>\"\n\
    \    return 1\n  fi\n  local num=$1\n  local i=$(( ${#num} - 1 ))\n  local frac\n\
    \  local fracstr=\"0.\"\n  while (( $i > 0 )); do\n    frac=`echo ${num:i:1}`\n\
    \    fracstr=\"${fracstr}${frac}\"\n    num=`expr $num \\% 10`\n    ((i--))\n\
    \  done\n  echo $fracstr\n}\n\ncandidate() {\n    truncate_number \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"3.5\") = \"0.5\" ]]\n    [[ $(candidate\
    \ \"1.25\") = \"0.25\" ]]\n    [[ $(candidate \"123.0\") = \"0.0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: "expr: non-integer argument\nexpr: syntax error: unexpected argument \u2018\
    10\u2019\nexpr: non-integer argument\nexpr: syntax error: unexpected argument\
    \ \u201810\u2019\nexpr: syntax error: unexpected argument \u201810\u2019\n"
  stdout: ''
  timestamp: 1660058854
