name: HumanEval_58_common
language: sh
prompt: "#!/bin/bash\n# Return sorted unique common elements for two lists.\n# >>>\
  \ $(common \"1 4 3 34 653 2 5\" \"5 7 1 5 9 653 121\")\n# ['\"1\"', '\"5\"', '\"\
  653\"']\n# >>> $(common \"5 3 2 8\" \"3 2\")\n# ['\"2\"', '\"3\"']\n#\n# $1 is a\
  \ space-separated list\n# $2 is a space-separated list\ncommon() {\n"
tests: "}\n\ncandidate() {\n    common \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"1 4 3 34 653 2 5\" \"5 7 1 5 9 653 121\") = \"1 5 653\" ]]\n    [[ $(candidate\
  \ \"5 3 2 8\" \"3 2\") = \"2 3\" ]]\n    [[ $(candidate \"4 3 2 8\" \"3 2 4\") =\
  \ \"2 3 4\" ]]\n    [[ $(candidate \"4 3 2 8\" \"\") = \"\" ]]\n}\n\nrun_test"
completions: ["  local -n common_list=\"$1\"\n  local -n items=\"$2\"\n  while read\
    \ -r line; do\n    common_list+=(\"$line\")\n  done < <(echo \"$items\" | tr \"\
    \ \" \"\\n\")\n  sort -u <<< \"${common_list[@]}\"", '  sort -u "$1" | sort -u
    "$2"', "\tlocal sorted\n\tsorted=( $(sort -u \"$1\" | sed 's/^/\"/') )\n\tsorted=(\
    \ $(sort -u \"$2\" | sed 's/^/\"/') )\n\tlocal result\n\tresult=()\n\tfor i in\
    \ $(seq 0 $(( ${#sorted[@]} - 1 )) )\n\tdo\n\t\tfound=false\n\t\tfor x in \"${sorted[$i]}\"\
    \n\t\tdo\n\t\t\tif [[ $x != \"${sorted[$(( i + 1 ))]}\" && $x != \"${sorted[$((\
    \ i + 1 ))]}\" ]]\n\t\t\tthen\n\t\t\t\tresult+=(\"$x\")\n\t\t\t\tfound=true\n\t\
    \t\tfi\n\t\tdone\n\t\tif [ ! $found ]\n\t\tthen\n\t\t\tresult+=(\"${sorted[$i]}\"\
    )\n\t\tfi\n\tdone\n\techo \"${result[@]}\"", "    local common_file\n    local\
    \ common_arg\n    local common_flags\n    local common_result\n\n    common_args=()\n\
    \    common_flags=\"\"\n    common_file=\"/dev/null\"\n    common_arg=()\n\n \
    \   for arg; do\n        if [ -z \"$common_file\" ]; then\n            common_file=$arg\n\
    \        elif [ -z \"$common_arg\" ]; then\n            common_arg=($arg)\n  \
    \      else\n            common_args=(\"${common_args[@]}\" \"$arg\")\n      \
    \  fi\n    done\n\n    for flag; do\n        common_flags=\"$common_flags $flag\"\
    \n    done\n\n    common_result=$(comm -12 $common_args <(sort $common_file) <(sort\
    \ $common_file))\n\n    if [ $? -gt 0 ]; then\n        echo \"ERROR: comm -12\
    \ $common_args <(sort $common_file) <(sort $common_file) failed, exit status is\
    \ $?\"\n        exit 1\n    fi\n    for common_line in $common_result; do\n  \
    \      if [ -z \"$common_flags\" ]; then\n            echo \"$common_line\"\n\
    \        else\n            echo \"$common_flags $common_line\"\n        fi\n \
    \   done", "    local list1=\"$1\"\n    local list2=\"$2\"\n    local sorted_list1\n\
    \    local sorted_list2\n    local unique_array\n\n    sorted_list1=$(echo ${list1}\
    \ | sort -u)\n    sorted_list2=$(echo ${list2} | sort -u)\n    unique_array=()\n\
    \    for element in ${sorted_list1[@]}; do\n        element_index=0\n        for\
    \ unique_element in ${sorted_list2[@]}; do\n            [[ $element == $unique_element\
    \ ]] || continue\n            element_index=$((element_index + 1))\n         \
    \   break\n        done\n        unique_array[$element_index]=\"$element\"\n \
    \   done\n    echo ${unique_array[@]}", "  local set unset common\n  set -- $1\
    \ $2\n  unset IFS\n  for i in $*; do\n    common+=( $i )\n  done\n  set -\n  for\
    \ common in \"${common[@]}\"; do\n    unset ${common%$'\\n'} ${common##*$'\\n'}\n\
    \  done\n  IFS=$'\\n' sort -u", "  local list_a list_b\n  list_a=$1\n  list_b=$2\n\
    \  while read line; do\n    test -z \"$list_a\" && list_a=\"$line\"\n    test\
    \ -z \"$list_b\" && list_b=\"$line\"\n  done <<<\"$list_a $list_b\"\n  sort -u\
    \ \"$list_a\" \"$list_b\"", "\tlocal IFS=\"$1\"\n\tlocal OIFS=\"$2\"\n\tlocal\
    \ i\n\n\tsort \"$1\" | sort -u | sed \"s/$IFS//g\" | while read i; do \\\n\t\t\
    echo -n \"${OIFS}${i}\"\n\t\ttest \"$2\" = \"$i\" && echo \"$i\" \\\n\t\t\t&&\
    \ printf \"$IFS\" \"$i\"; \\\n\tdone", "    local a b i j\n    a=$1\n    b=$2\n\
    \    shift 2\n    echo -n \"${a// /|$(rev)|/}\"\n    for (( i=0; i<${#a}; i++\
    \ )); do\n        j=$((i+1))\n        for (( j=0; j<${#b}; j++ )); do\n      \
    \      if [[ $a == *\"|${b[j],,}\"* ]]; then\n                echo -n \"${b[j]//\
    \ /|$(rev)|/}\"\n                break\n            fi\n        done\n    done",
  "  local list1=( \"${1[@]}\" )\n  local list2=( \"${2[@]}\" )\n\n  # Sort the lists\
    \ for comparison.\n  local sortedList1\n  local sortedList2\n  local commonElements\n\
    \  sortedList1=$(IFS=$'\\n'; sort <(printf \"%s\\n\" \"${list1[@]}\") <(printf\
    \ \"%s\\n\" \"${list2[@]}\") | sort -n)\n  sortedList2=$(IFS=$'\\n'; sort <(printf\
    \ \"%s\\n\" \"${list1[@]}\") <(printf \"%s\\n\" \"${list2[@]}\") | sort -n)\n\n\
    \  # Count the number of common elements between the sorted lists.\n  commonElements=$((\
    \ ${#sortedList1[@]} - ${#sortedList2[@]} ))\n  printf \"%s\\n\" \"${sortedList1[@]}\"",
  "  # Assumes GNU sort for uniq (http://www.unix.com/man-page/linux/1/sort)\n  local\
    \ a b i j result\n  a=( \"${1//$2/-}\" )    # Remove common elements from $2 from\
    \ $1\n  b=( \"${2//$1/-}\" )    # Remove common elements from $1 from $2\n  j=\n\
    \  for ((i=0; i<${#a[@]}; i++)); do\n    for ((j=0; j<${#b[@]}; j++)); do\n  \
    \    [[ \"${a[$i]}\" == \"$b[$j]\" ]] && break\n    done\n    [[ -n $j ]] && result+=(\"\
    ${a[$i]}\") || result+=(\"${b[$j]}\")\n  done\n  echo \"${result[@]}\"", "  local\
    \ unique1 unique2 len1=${#1} len2=${#2}\n  if [ \"${len1}\" -eq 0 ]; then\n  \
    \  return 0\n  fi\n  if [ \"${len2}\" -eq 0 ]; then\n    return 1\n  fi\n  local\
    \ i j\n  local prefix1\n  local prefix2\n  prefix1=$( echo -n \"$1\" | awk '{for(i=1;i<=NF;i++){printf\
    \ \"%s \",$i}}' | sort -u )\n  prefix2=$( echo -n \"$2\" | awk '{for(i=1;i<=NF;i++){printf\
    \ \"%s \",$i}}' | sort -u )\n  len1=${#prefix1}\n  len2=${#prefix2}\n  if [ \"\
    ${len1}\" -gt \"${len2}\" ]; then\n    prefix1=$( echo -n \"$1\" | awk '{for(i=1;i<=NF;i++){printf\
    \ \"%s \",$i}}' | sort -n | tail -n +${len2} | head -n ${len1} )\n  else\n   \
    \ prefix2=$( echo -n \"$2\" | awk '{for(i=1;i<=NF;i++){printf \"%s \",$i}}' |\
    \ sort -n | head -n ${len2} | tail -n +${len1} )\n  fi\n  unique1=$( echo -n \"\
    $prefix1\" | awk '{for(i=1;i<=NF;i++){printf \"%s \",$i}}' | sort -u )\n  unique2=$(\
    \ echo -n \"$prefix2\" | awk '{for(i=1;i<=NF;i++){printf \"%s \",$i}}' | sort\
    \ -u )\n  unique1=${#unique1}\n  unique2=${#unique2}\n  for (( j=0; j<${unique1};\
    \ j++ )); do\n    unique1=${unique1:0:j}\n    break\n  done\n  for (( j=0; j<${unique2};\
    \ j++ )); do\n    unique2=${unique2:0:j}\n    break\n  done\n  printf \"%q\" \"\
    ${unique1}\" \"${unique2}\"", "\tlocal sortedlist1=\"$1\"\n\tlocal sortedlist2=\"\
    $2\"\n\n\techo \"$sortedlist1\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '\n\techo\
    \ \"$sortedlist2\" | tr ' ' '\\n' | sort -u | tr '\\n' ' '", "    local list1\
    \ list2\n    IFS=\" \" read -r list1 list2 <<< \"$1\"\n    IFS=\" \" read -r list2\
    \ list1 <<< \"$2\"\n    sort -u -d -u -k1 -z -s \"$list1\" \"$list2\"", "  local\
    \ i j res=()\n  IFS=\" \" read -r -a ia <<< \"$1\"\n  IFS=\" \" read -r -a ja\
    \ <<< \"$2\"\n  for ((i=0; i<${#ia[@]}; i++)); do\n    for ((j=0; j<${#ja[@]};\
    \ j++)); do\n      if ((${ia[$i]} == ${ja[$j]})); then\n        res+=(\"${ia[$i]}\"\
    )\n      fi\n    done\n  done\n  IFS=\",\"\n  echo \"${res[@]}\"", "  local list_1\
    \ list_2\n  list_1=$1\n  list_2=$2\n  while read -r value\n  do\n    if [ -z \"\
    $list_1\" ] || [ -z \"$list_2\" ] || [ \"$value\" != \"${list_1} ${list_2}\" ]\n\
    \    then\n      list_1=$list_2\n      list_2=$value\n      continue\n    fi\n\
    \    list_1=\"${list_1} ${value}\"\n  done <<< \"$list_1 $list_2\"\n  list_1=\"\
    ${list_1#* }\"\n  list_2=\"${list_2#* }\"\n  list_1=$(echo \"$list_1\" | tr '\\\
    n' ' ')\n  list_2=$(echo \"$list_2\" | tr '\\n' ' ')\n  list_1=$(echo \"$list_1\"\
    \ | sed 's/ *$//g')\n  list_2=$(echo \"$list_2\" | sed 's/ *$//g')\n  list_1=$(echo\
    \ \"$list_1\" | tr '[A-Z]' '[a-z]')\n  list_2=$(echo \"$list_2\" | tr '[A-Z]'\
    \ '[a-z]')\n  list_1=$(echo \"$list_1\" | tr 'a-z' '[A-Z]')\n  list_2=$(echo \"\
    $list_2\" | tr 'a-z' '[A-Z]')\n  list_1=$(echo \"$list_1\" | sed 's/^/\"/; s/$/\"\
    /')\n  list_2=$(echo \"$list_2\" | sed 's/^/\"/; s/$/\"/')\n  list_1=$(echo \"\
    $list_1\" | sed 's/ /\\n/')\n  list_2=$(echo \"$list_2\" | sed 's/ /\\n/')\n \
    \ list_1=$(echo \"$list_1\" | sed 's/^ *//')\n  list_2=$(echo \"$list_2\" | sed\
    \ 's/^ *//')\n  list_1=$(echo \"$list_1\" | sed 's/ *$//')\n  list_2=$(echo \"\
    $list_2\" | sed 's/ *$//')\n  list_1=$(echo \"$list_1\" | sed 's/^\"//; s/\"$//')\n\
    \  list_2=$(echo \"$list_2\" | sed 's/^\"//; s/\"$//')\n  list_1=$(echo \"$list_1\"\
    \ | sed 's/^ *//; s/ *$//')\n  list_2=$(echo \"$list_2\" | sed 's/^ *//; s/ *$//')\n\
    \  list_1=$(echo \"$list_1\" | sed 's/^ *//; s/ *$//')\n  list_2=$(echo \"$list_2\"\
    \ | sed 's/", '    sort -u <(echo "$1" | cut -d " " -f 1) <(echo "$2" | cut -d
    " " -f 1)', "    local common_list\n    common_list=\"$(grep -q \"$1 $2\" \"$1\"\
    ) \\\n                $( comm -23 \"$1\" \"${1%/*}/$2\" | cut -c3- | tr ' ' '\\\
    n' | sort -u )\"\n    echo $common_list", "    local l1 l2\n    read -a l1 <<<\
    \ $1\n    read -a l2 <<< $2\n    echo \"${l1[*]}\" | grep -v -E \"^${l2[*]}$\"\
    \ | sort -u", "    local set_1 set_2\n    set_1=\"$(set -- \"$1\")\"\n    set_2=\"\
    $(set -- \"$2\")\"\n    local common count\n    count=0\n    for el in $set_1;\
    \ do\n        if [ -z \"$el\" ]; then continue; fi\n        for el_2 in $set_2;\
    \ do\n            if [ \"$el\" != \"$el_2\" ]; then continue; fi\n           \
    \ common+=($el)\n            count=$((count + 1))\n        done\n    done\n  \
    \  count=$((count + 1))\n    for el in $set_2; do\n        if [ -z \"$el\" ];\
    \ then continue; fi\n        for el_2 in $set_1; do\n            if [ \"$el\"\
    \ != \"$el_2\" ]; then continue; fi\n            common+=($el)\n            count=$((count\
    \ + 1))\n        done\n    done\n    echo ${common[@]}", "    local x\n    local\
    \ y\n    local z\n\n    IFS=$'\\n' read -a x <<<\"$1\"\n    IFS=$'\\n' read -a\
    \ y <<<\"$2\"\n\n    # sort and remove dups\n    local -a sorted\n    local -a\
    \ removed\n\n    sorted=( \"${x[@]}\" )\n    removed=( \"${y[@]}\" )\n\n    for\
    \ i in \"${!sorted[@]}\"; do\n        if [[ \"${sorted[$i]}\" == \"${removed[$i]}\"\
    \ ]]; then\n            removed=( \"${removed[@]:0:i}\" )\n        fi\n    done\n\
    \    sorted=( \"${sorted[@]}\" )\n\n    echo \"${sorted[@]}\"", "    local list_a=\"\
    $1\";\n    local list_b=\"$(echo \"$2\" | sed -e 's/ /, /g')\";\n    sort -u \"\
    $list_a\" \"$list_b\";", "    local common_list=\"$(sort -u $1 $2)\"\n    local\
    \ sorted=\"$(sort $common_list)\"\n    # echo \"$common_list\"\n    # echo \"\
    $sorted\"\n    echo \"$sorted\" | sed 's/ //g'", "  # $1 and $2 are space-separated\
    \ lists, like \"1 2 3 4 5\".\n  # $1 has unique elements.\n  # $2 has duplicate\
    \ elements.\n  # $2 has common elements.\n  # $1 has common elements.\n  local\
    \ -r common=\"${1}\"\n  local -r unused=\"${2}\"\n  local -a result\n\n  local\
    \ IFS=$'\\n'\n  IFS=$' \\t\\n'\n\n  local -r ret=0\n  local -r count=$(echo \"\
    ${common}\" | tr \" \" \"\\n\" | sort | uniq -c | wc -l)\n  result=()\n\n  # ${unused}\
    \ may have duplicate elements.  If it does, ${result}\n  # must be empty.  That\
    \ is because we only want to append unique elements\n  # to ${result}\n  for element\
    \ in ${unused}; do\n    local index=$(echo \"${common}\" | tr \" \" \"\\n\" |\
    \ sort | uniq -c | \\\n      awk -v element=\"${element}\" '$2 ~ element {print\
    \ $1}')\n\n    if [[ ${#index} -gt 0 ]]; then\n      result+=(\"${element}\")\n\
    \    fi\n  done\n\n  # Append uncommon elements.\n  for element in ${unused};\
    \ do\n    local index=$(echo \"${common}\" | tr \" \" \"\\n\" | sort | uniq -c\
    \ | \\\n      awk -v element=\"${element}\" '$2 ~ element {print $1}')\n\n   \
    \ if [[ ${#index} -gt 0 ]]; then\n      result+=(\"${element}\")\n    fi\n  done\n\
    \n  if [[ ${count} -gt 0 ]]; then\n    ret=1\n  fi\n\n  printf \"%s\\n\" \"${result[@]}\"\
    \n  exit ${ret}", "    awk '{\n        for(i=1;i<=NF;i++) arr[$i]++;\n       \
    \ for(i=1;i<=NF;i++) for(j=i+1;j<=NF;j++) \n            if(arr[$i] && arr[$j])\
    \ {\n                delete arr[$i];\n                delete arr[$j];\n      \
    \          break;\n            }\n    }\n    END{ for (key in arr) print key;}'\
    \ \"$1\" \"$2\"", "  local common1 common2 list1 list2\n  list1=( \"${1// }\"\
    \ )\n  list2=( \"${2// }\" )\n  common1=( \"${list1[@]}\" )\n  common2=( \"${list2[@]}\"\
    \ )\n  local j k\n  for j=(${#common1[@]} 1 0); do\n    for k=(${#common2[@]}\
    \ 1 0); do\n      if [[ \"${common1[j]}\" = \"${common2[k]}\" ]]; then\n     \
    \   common1[j]=${common1[@]:0:j}\n        common2[k]=${common2[@]:0:k}\n     \
    \ fi\n    done\n  done\n  echo \"${common1[@]}\"", "\tlocal i elem1 elem2 unique1\
    \ unique2 unique3 unique4 unique5 unique6\n\tlocal count1 count2 count3 count4\
    \ count5 count6 found1 found2 found3 found4 found5 found6\n\n\t# Sort both lists,\
    \ if necessary\n\tlocal IFS=\" \"\n\tsort \"$1\" \"$2\" >&2\n\tIFS=\"$IFS_ORIG\"\
    \n\n\t# Extract unique elements in both lists and sort the lists\n\tunique1=$(comm\
    \ -2 -3 <(sort \"$1\") <(sort \"$2\"))\n\tunique2=$(comm -2 -3 <(sort \"$2\")\
    \ <(sort \"$1\"))\n\tunique3=$(($(echo \"$unique1 $unique2\" | sort | uniq -c\
    \ | sort -nr | head -n1) ))\n\tunique4=$(($(echo \"$unique2 $unique3\" | sort\
    \ | uniq -c | sort -nr | head -n1) ))\n\tunique5=$(($(echo \"$unique3 $unique4\"\
    \ | sort | uniq -c | sort -nr | head -n1) ))\n\tunique6=$(($(echo \"$unique4 $unique5\"\
    \ | sort | uniq -c | sort -nr | head -n1) ))\n\n\t# If only one element remains,\
    \ return it.\n\tif [ -z \"$unique6\" ]\n\tthen\n\t\techo \"$unique1\"\n\telse\n\
    \t\tfound1=0\n\t\tfound2=0\n\t\tfound3=0\n\t\tfound4=0\n\t\tfound5=0\n\t\tfound6=0\n\
    \t\twhile [ \"${found1}\" -lt \"6\" ]\n\t\tdo\n\t\t\tif [[ \"$unique6\" =~ \"\
    $unique${found1}\" ]]\n\t\t\tthen\n\t\t\t\tfound1=$(expr \"$found1 + 1\")\n\t\t\
    \telse\n\t\t\t\tfound1=0\n\t\t\tfi\n\t\tdone\n\t\twhile [ \"${found2}\" -lt \"\
    6\" ]\n\t\tdo\n\t\t\tif [[ \"$unique6\" =~ \"$unique${found2}\" ]]\n\t\t\tthen\n\
    \t\t\t\tfound2=$(expr \"$found2 + 1\")\n\t\t\telse\n\t\t\t\tfound2=0\n\t\t\tfi\n\
    \t\tdone\n\t\twhile [ \"${found3}\" -lt \"6\" ]\n\t\tdo\n\t\t\tif [[ \"$unique6\"\
    \ =~ \"$unique${found3}\" ]]\n\t\t\tthen\n\t\t\t\tfound3=$(expr \"$found3 + 1\"\
    )\n\t\t\telse\n\t\t\t\tfound3=0\n\t\t\tfi\n\t\tdone\n\t\twhile [ \"${found4}\"\
    \ -lt \"6\" ]\n\t\tdo\n\t\t\tif [[ \"$unique", "    local first_list=\"$1\"\n\
    \    local second_list=\"$2\"\n    local result=''\n    local IFS=$' '\n    read\
    \ -r -a first_array <<< \"$first_list\"\n    read -r -a second_array <<< \"$second_list\"\
    \n    local i=0\n    while (( i < ${#first_array[@]} )); do\n        local j=0\n\
    \        while (( j < ${#second_array[@]} && \\\n              ${first_array[$i]}\
    \ == ${second_array[$j]} )); do\n            (( ++j ))\n        done\n       \
    \ result=\"$result ${first_array[$i]}\"\n        (( ++i ))\n    done\n    echo\
    \ \"$result\"", "    local i j x y\n    local IFS=$'\\n'\n    set $1 $2\n    i=0\
    \ j=0 x=\"\"\n    while [ $i -lt ${#a[*]} -o $j -lt ${#b[*]} ]; do\n        if\
    \ [ $i -lt ${#a[*]} ]; then x=${a[i++]}; elif [ $j -lt ${#b[*]} ]; then x=${b[j++]};\
    \ else x=${a[i++]};  fi\n        if [ \"$x\" != \"${b[$j]}\" ]; then echo \"$x\"\
    ; fi\n        (( i++ ))\n        (( j++ ))\n    done", "    local common=\"$1\
    \ $2\"\n    local common_set=\"$( echo $common | tr ' ' ',' | sort -u)\"\n   \
    \ local common_set2=\"$( echo $common | tr ' ' ',' | sort -u)\"\n    local common_set3=\"\
    $( echo $common | tr ' ' ',' | sort -u)\"\n    local common_set4=\"$( echo $common\
    \ | tr ' ' ',' | sort -u)\"\n    echo \"$common_set\"", "    local a=\"$1\"\n\
    \    local b=\"$2\"\n    local l\n    local i\n    local x\n    local e\n    local\
    \ f\n    local l\n\n    # Make sure lists aren't empty\n    test -z \"$a\" &&\
    \ return 1\n    test -z \"$b\" && return 1\n\n    # Make sure there are same number\
    \ of items\n    test \"$#\" -eq \"$2\" || return 1\n\n    l=$(echo \"$a\" | tr\
    \ ' ' '\\n' | sort | uniq | tr ' ' '\\n')\n    shift\n    l=$(echo \"$b\" | tr\
    \ ' ' '\\n' | sort | uniq | tr ' ' '\\n')\n    shift\n\n    x=$(for ((i=0; i <\
    \ ${#l[*]}; i++ )); do\n        e=$(echo \"${l[i]}\" | cut -s -d '\"')\n     \
    \   f=$(echo \"${l[i]}\" | cut -s -d '\"')\n        [ \"$e\" == \"$f\" ]\n   \
    \ done)\n\n    if [ -n \"$x\" ]; then\n        echo \"${x[@]}\"\n    else\n  \
    \      echo \"\"\n    fi", "    local i j\n    local common=\"\"\n    for (( i=$1;\
    \ i--; )); do\n        if [[ -z $2 ]]; then\n            return $common\n    \
    \    fi\n        for (( j=$2; j--; )); do\n            if [[ $i == $j ]]; then\n\
    \                common+=\" $i\"\n            fi\n        done\n    done", " \
    \ local first=$1\n  local second=$2\n  local sorted=\"$(echo \"${first}\" | tr\
    \ \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\"\n  local unique=\"$(echo \"${second}\"\
    \ | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\"\n  echo ${sorted[@]}\n  [[\
    \ ${#unique[@]} -ne ${#sorted[@]} ]] && return\n  echo $(IFS=' '; echo \"${sorted[@]}\"\
    \ | tr \" \" \"\\n\" | grep \"^${unique[@]}$\" | sort -u)", "  local i\n  local\
    \ o1\n  local o2\n  o1=( $1 )\n  o2=( $2 )\n  i=1\n  while [ $i -le ${#o1[*]}\
    \ ]\n  do\n    if [ -z ${o1[i]} ]; then\n      break\n    fi\n    if [ -z ${o2[i]}\
    \ ]; then\n      break\n    fi\n    if [ ${o1[i]} -eq ${o2[i]} ]; then\n     \
    \ o1[i]=`expr ${o1[i]} + 1`\n      o2[i]=`expr ${o2[i]} + 1`\n      i=1\n    fi\n\
    \  done\n  printf '\"%s\"' \"${o1[*]}\"", "    local list_1 list_2\n    list_1=$1\n\
    \    list_2=$2\n    local sorted unique\n    IFS=$'\\n' sorted=$(sort -u <<< \"\
    $list_1\") unique=$(comm -12 <(sort <<< \"$list_2\") <(sort <<< \"$list_1\"))\n\
    \    echo \"$sorted\"", "  local IFS=' '\n  # shellcheck disable=SC2034\n  local\
    \ -n first=${!#$1} # names of the first arguments\n  local -n second=${!#}  #\
    \ names of the second arguments\n  local com=\"\"\n  for ((i=0; i<${#first[@]};\
    \ i++)); do\n    # shellcheck disable=SC2034\n    local first=${!i}\n    local\
    \ second=${!((${i}+1))}\n    com+=\"$first $second\"\n  done\n  com=$(sort -u\
    \ \"$com\")\n  com=(${com//' '/ })\n  com=(${com//'\"'\"'/'})\n  com=(${com//$'\\\
    n'/ })\n  com=(${com//$'\\r'/ })\n  com=(${com//$'\\001'/ })\n  com=(${com//$'\\\
    002'/ })\n  com=(${com//$'\\003'/ })\n  com=(${com//$'\\004'/ })\n  com=(${com//$'\\\
    005'/ })\n  com=(${com//$'\\006'/ })\n  com=(${com//$'\\007'/ })\n  com=(${com//$'\\\
    008'/ })\n  com=(${com//$'\\009'/ })\n  com=(${com//$'\\010'/ })\n  com=(${com//$'\\\
    011'/ })\n  com=(${com//$'\\012'/ })\n  com=(${com//$'\\013'/ })\n  com=(${com//$'\\\
    014'/ })\n  com=(${com//$'\\015'/ })\n  com=(${com//$'\\016'/ })\n  com=(${com//$'\\\
    017'/ })\n  com=(${com//$'\\020'/ })\n  com=(${com//$'\\021'/ })\n  com=(${com//$'\\\
    022'/ })\n  com=(${com//$'\\023'/ })\n  com=(${com//$'\\024'/ })\n  com=(${com//$'\\\
    025'/ })\n  com=(${com//$'\\026'/ })\n  com=(${com//$'\\027'/ })\n  com=(${com//$'\\\
    030'/ })\n  com=(${com//$'\\031'/ })", "    local x1 x2\n    x1=\"$1\" && x2=\"\
    $2\"\n    local IFS\n    IFS=$' '\n    echo \"$(x1 $x2)\"", "  local sorted1 sorted2\n\
    \  IFS=$'\\n' sorted1=( $1 ); sorted2=( $2 )\n  # Sort both the lists\n  sort\
    \ -u <<<\"${sorted1[@]}\"\n  sort -u <<<\"${sorted2[@]}\"\n  # If both the lists\
    \ are not empty, return the unique elements.\n  if [ ${#sorted1[@]} -gt 0 ] &&\
    \ [ ${#sorted2[@]} -gt 0 ]; then\n    # Sort both the common elements\n    sort\
    \ -u <<<\"${sorted1[@]}\" <<<\"${sorted2[@]}\"\n  fi", "    local common\n   \
    \ local common_file\n    local file1\n    local file2\n    local tmp_file\n  \
    \  common_file=$(mktemp)\n    while read -r line1; do\n        while read -r line2;\
    \ do\n            if [[ \"$line1\" == \"$line2\" ]]; then\n                common=\"\
    $common$line1\"\n            fi\n        done < \"$file2\"\n    done < \"$file1\"\
    \n    echo \"$common\"\n    rm \"$common_file\"", "  local sorted_list1\n  local\
    \ sorted_list2\n  local sorted_result\n\n  IFS=$'\\n'\n  sorted_list1=$(sort \"\
    $1\")\n  sorted_list2=$(sort \"$2\")\n  sorted_result=$(sort -u <<<\"$sorted_list1\
    \ $sorted_list2\")\n  IFS=\n  echo ${sorted_result[@]}", "    local _arr1 _arr2\n\
    \    _arr1=($(echo $1 | tr ' ' \"\\n\"))\n    _arr2=($(echo $2 | tr ' ' \"\\n\"\
    ))\n    [[ ${#_arr1[@]} -eq 0 && ${#_arr2[@]} -eq 0 ]] && return 0\n    # echo\
    \ \"${_arr1[@]} ${_arr2[@]}\"\n    local _ret=${_arr1[@]}\n    _arr1=()\n    local\
    \ -n _found\n    for idx in ${!_arr2[@]}; do\n        _found=\"${_ret[@]}\"\n\
    \        for val1 in ${_arr1[@]}; do\n            for val2 in ${_arr2[@]}; do\n\
    \                if [[ \"${val1}\" == \"${val2}\" ]]; then\n                 \
    \   _found=\"${_found[@]} ${val1}\"\n                    break\n             \
    \   fi\n            done\n        done\n        _ret+=(${_found})\n    done\n\
    \    echo \"${_ret[@]}\"", "    local IFS='\n    '\n    local sorted_common\n\
    \    local num_common\n    local common_args\n    local i\n    local j\n    local\
    \ k\n    local comm_array\n    local comm_idx\n\n    # $1 is a space-separated\
    \ list\n    # $2 is a space-separated list\n    sorted_common=($(sort $1))\n \
    \   num_common=$(sort $2 | wc -w)\n    common_args=${#sorted_common[@]}\n    comm_array=()\n\
    \n    if [ $common_args -eq 0 ]; then\n        comm_idx=0\n        comm_array=(${sorted_common[@]:0})\n\
    \    else\n        for (( i=1; i<=$common_args; i++ )); do\n            for ((\
    \ j=0; j<$num_common; j++ )); do\n                if [[ ${sorted_common[$i]} ==\
    \ ${sorted_common[$j]}* ]]; then\n                    if [[ ${sorted_common[$i]}\
    \ != *\" \" ]]; then\n                        comm_array[$comm_idx]=${sorted_common[$i]}\n\
    \                        comm_idx=$(( $comm_idx + 1 ))\n                    fi\n\
    \                    (( num_common-- ))\n                    break\n         \
    \       fi\n            done\n        done\n        if [ $num_common -eq 0 ];\
    \ then\n            comm_idx=0\n            comm_array=(${sorted_common[@]:0})\n\
    \        else\n            for (( k=0; k<$num_common; k++ )); do\n           \
    \     comm_idx=$(( $comm_idx + 1 ))\n                comm_array[$comm_idx]=${sorted_common[$k]}\n\
    \            done\n        fi\n    fi\n\n    ${sorted_common[@]:$comm_idx}", " \
    \ local i ilist jlist common iidx jidx\n  IFS=$'\\n' ilist=$1 jlist=$2\n  unset\
    \ i\n  unset j\n  for (( i=0; i < ${#ilist[*]} && j<${#jlist[*]} && i<j; i++ ));\
    \ do\n    iidx=$(( ${ilist[$i]} + ${jlist[$j]} ))\n    jidx=$(( ${jlist[$j]} +\
    \ ${ilist[$i]} ))\n    common[$i]=${ilist[$iidx]}\n    common[$j]=${jlist[$jidx]}\n\
    \  done\n  unset i\n  unset j\n  unset iidx\n  unset jidx\n  local i j\n  for\
    \ (( i=0; i < ${#common[@]}; i++ )); do\n    for (( j=0; j < ${#common[@]}; j++\
    \ )); do\n      [[ \"${common[$i]}\" == \"${common[$j]}\" && $(( ${i} + 1 )) !=\
    \ $(( ${j} + 1 )) ]] && return 1\n    done\n  done\n  return 0", "    local list1=\"\
    $1\"\n    local list2=\"$2\"\n\n    local sortedList1\n    local sortedList2\n\
    \    local sortedCommon\n    local intersectCount\n    local list2Element\n  \
    \  local list1Element\n    local list1Elements\n    local list2Elements\n    local\
    \ list2ElementCount\n    local commonElements\n\n    sortedList1=$(sort -u <<<\
    \ \"$list1\")\n    sortedList2=$(sort -u <<< \"$list2\")\n    sortedCommon=$(echo\
    \ \"$sortedList1\" | tr ' ' '\\n' | sort -u)\n    intersectCount=$(echo \"$sortedCommon\"\
    \ | grep \"$sortedList2\" | wc -l)\n    if [[ \"$intersectCount\" -gt 0 ]]; then\n\
    \        sortedList1=$(echo \"$sortedCommon\" | awk -F' ' '{print $2}')\n    \
    \    list1Elements=$(echo \"$list1\" | tr ' ' '\\n' | grep -f <(echo \"$sortedList1\"\
    ) | sort -u)\n        list2Elements=$(echo \"$list2\" | tr ' ' '\\n' | grep -f\
    \ <(echo \"$sortedList2\") | sort -u)\n        list1ElementCount=$(echo \"$list1Elements\"\
    \ | wc -l)\n        list2ElementCount=$(echo \"$list2Elements\" | wc -l)\n   \
    \     commonElements=$(echo \"$list1Elements\" | cut -d ' ' -f 1-$((list1ElementCount-1)))\n\
    \        echo \"$commonElements\"\n    else\n        echo \"\"\n    fi", "  local\
    \ list_1 list_2\n  list_1=\"$( echo \"$1\" | sed -e 's/ /\" \" -e \"s/ /\" -e\
    \ \"s/ /\" -e \"s/ /\"/g')\"\n  list_2=\"$( echo \"$2\" | sed -e 's/ /\" \" -e\
    \ \"s/ /\" -e \"s/ /\" -e \"s/ /\" -e \"s/ /\"/g')\"\n\n  comm -12 <(sort \"$list_1\"\
    ) <(sort \"$list_2\") | awk '{ print $1 }'", '  comm -3 <(sort $1) <(sort $2)',
  "  local common_elements element\n  common_elements=()\n  IFS=\" \" read -r -a elements\
    \ <<< \"$1\"\n  IFS=\" \" read -r -a elements2 <<< \"$2\"\n  for element in \"\
    ${elements[@]}\"; do\n    found=\n    for element2 in \"${elements2[@]}\"; do\n\
    \      [[ \" $element \" == \"$element2\" ]] && found=1 || continue\n      common_elements+=(\"\
    $element\")\n    done\n  done\n  echo \"${common_elements[*]}\"", "\tlocal common\n\
    \tlocal list1\n\tlocal list2\n\tlist1=\"$1\"\n\tlist2=\"$2\"\n\twhile read -r;\
    \ do\n\t\tif [ -z \"$common\" ] && [ \"$list1\" != \"$list2\" ]; then\n\t\t\t\
    common=\"$REPLY\"\n\t\tfi\n\tdone < <(echo \"$list1 $list2\" | tr \" \" \"\\n\"\
    )\n\techo \"$common\"", "    local common_list=$1\n    local second_list=$2\n\
    \    local temp\n    IFS=' ' read -r -a first_list <<< \"$common_list\"\n    IFS='\
    \ ' read -r -a second_list <<< \"$second_list\"\n    IFS=' ' read -r -a temp_list\
    \ <<< \"$(comm -12 -3 <<<\"$first_list\" <<<\"$second_list\")\"\n    IFS=' ' read\
    \ -r -a temp_list <<< \"$(comm -12 -3 <<<\"$first_list\" <<<\"$second_list\")\"\
    \n    while read -r line; do\n        if [[ ! \" ${temp_list[*]} \" =~ $line ]];\
    \ then\n            common_list+=(\"$line\")\n        fi\n    done <<< \"${temp_list[@]}\"\
    \n    echo \"${common_list[@]}\"", "  local i result word\n  result=$( echo $1\
    \ | tr -s ' ' '\\n' | sort -r )\n  while IFS=$'\\n' read -r word; do\n    [[ \"\
    \ $1 \" != *\" $word \" ]]\n    [[ -n $word ]] && result+=$word\n  done < <(echo\
    \ $2 | tr -s ' ' '\\n' | sort -r)\n  echo $result", "    awk '\n    { \n     \
    \   delete a;\n        for (i in a) delete b[i];\n        for (i = 1; i <= NF;\
    \ ++i) a[$i] = 1;\n        for (i = 2; i <= NF; ++i) b[$i] = 1;\n    }\n    END\
    \ {\n        for (i in a) printf \"%s%s\", i==NF ? i : OFS, i in b ? b[i] : \"\
    \";\n    }\n    '", "    local common=$(comm -23 <(sort $1) <(sort $2))\n    if\
    \ [ -z \"$common\" ];\n    then\n        common=$(comm -23 <(sort $2) <(sort $1))\n\
    \    fi\n    echo ${common[@]}", "    local -r arg1=\"$1\"\n    local -r arg2=\"\
    $2\"\n    local -r ret=()\n    for arg; do\n        [[ \" ${arg1[*]} \" == *\"\
    \ $arg \" ]] ; let \"ret+=($arg)\" || return 1\n        [[ \" ${arg2[*]} \" ==\
    \ *\" $arg \" ]] ; let \"ret+=($arg)\" || return 1\n    done\n    printf '%s\\\
    n' \"${ret[@]}\"", "    local IFS=$'\\n' a\n    local b\n    local -a res\n\n\
    \    while read -r line1; do\n        ((++i))\n        res[i]=\n        while\
    \ read -r line2; do\n            [[ \"$line2\" =~ ^\"(.*)\"$ ]] && [[ $line1 =~\
    \ $line2 ]] &&\n                res[i]=\"$line2\" || break\n        done <<< \"\
    $line1\"\n    done <<< \"$1\"\n\n    printf '%s\\n' \"${res[@]}\"", "\tlocal i\
    \ j k l m=$1 n=$2 s u\n\t[[ \"$#\" -eq 2 ]] || return 1\n\twhile IFS= read -r\
    \ s && IFS= read -r n; do\n\t\t[[ $s == $n ]] || return 1\n\tdone < <(echo \"\
    $s\"; echo \"$n\")\n\ts=$(n=${n/#/#/})\n\tn=$(n=${n/#/#/})\n\t[[ $s == $n ]] ||\
    \ return 1\n\tfor ((j=m; j<=n; j++)); do\n\t\tu=\n\t\tfor ((i=j-1; i>=0; i--));\
    \ do\n\t\t\tk=\"$m$i\"\n\t\t\tl=\"$n$i\"\n\t\t\tif [[ \"$s\" == \"$k\" || \"$s\"\
    \ == \"$l\" ]]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\tif [[ $u == \"\" ]]; then\n\
    \t\t\t\ts=\"$k\"\n\t\t\t\tu=\"$l\"\n\t\t\telif [[ \"$u\" != \"$k\" || \"$u\" !=\
    \ \"$l\" ]]; then\n\t\t\t\ts=\"$s\"\n\t\t\t\tu=\"$u\"\n\t\t\tfi\n\t\tdone\n\t\
    done\n\techo \"$s\"", "    local list_1 list_2\n    list_1=$1\n    list_2=$2\n\
    \    \n    local unique_list\n    unique_list=$(bc <<< \"$(printf '%s\\n' \"$list_1\"\
    \ \"$list_2\" | sort | uniq -d | wc -l)\" 2>/dev/null)\n    \n    local element\n\
    \    for element in $unique_list; do\n        echo \"$element\"\n    done", " \
    \ local set1 set2\n  IFS=' ' read -r -a set1 <<<\"$1\"\n  IFS=' ' read -r -a set2\
    \ <<<\"$2\"\n  echo \"$(sort -u \"${set1[@]}\" \"${set2[@]}\")\"", "\tlocal common=\"\
    $1\"\n\tshift\n\tlocal elements=\"$1\"\n\tshift\n\tlocal result=()\n\n\twhile\
    \ [[ -n \"$elements\" ]]; do\n\t\twhile [[ -n \"$common\" ]]; do\n\t\t\tlocal\
    \ item=\"$common\"\n\t\t\tcommon=$(echo \"$common\" | tr ' ' \"\\n\" | sort -u)\n\
    \t\t\tif [[ -n $item ]]; then\n\t\t\t\tresult+=(\"$item\")\n\t\t\tfi\n\t\tdone\n\
    \n\t\tcommon=$(echo \"$common\" | tr ' ' \"\\n\" | sort -u)\n\t\telements=\"$elements\"\
    \n\tdone\n\n\techo \"${result[@]}\"", "    local first_list second_list common_element\n\
    \    read -r -a first_list <<< \"$1\"\n    read -r -a second_list <<< \"$2\"\n\
    \    common_element=$(comm -3 <(printf '%s\\0' \"${first_list[@]}\") <(printf\
    \ '%s\\0' \"${second_list[@]}\"))\n    echo \"${common_element}\"", '  comm -23
    <(sort -u <<<"$1") <(sort -u <<<"$2")', "  local i ix iy j=$1 k=$2\n  iy=${#i[*]}\n\
    \  j=${#j[*]}\n  [[ -z \"$i\" || ! -z \"$j\" ]] && return 0\n  [[ -z \"$i\" ]]\
    \ && return 0\n  [[ -z \"$j\" ]] && return 0\n  (( iy>j && k=\"$1\" )) || k=\"\
    $2\"\n  (( iy=j+1 )) || k=\"$1 $2\"\n  (( ix > iy )) && return 0\n  while (( ix-iy\
    \ > 1 )); do\n    (( ix-=1 ))\n    (( iy-=1 ))\n    (( ix-=1 )) && continue\n\
    \    (( iy-=1 )) && continue\n    i=${i[*]}\n    j=${j[*]}\n    [[ -z \"$i\" ||\
    \ ! -z \"$j\" ]] && return 0\n    [[ \"$i\" == \"$j\" ]] && continue\n    (( i\
    \ < j )) && k=\"$i $k\" || k=\"$j $k\"\n  done\n  printf '%s' \"${k% *}\"", " \
    \ local i i1 i2 j\n  i1=0\n  i2=0\n  for i in $(echo $1 | tr ' ' '\\n'); do\n\
    \    j=$(echo $2 | tr ' ' '\\n' | grep -n -F -f <(cat <(echo $2|tr ' ' '\\n')\
    \ | sed \"s/$i//g\"))\n    if [[ -n \"$j\" ]]; then\n      i1=$((i1+1))\n    \
    \  j=$((j-1))\n      echo $i\"-\"$j\n    fi\n  done\n  j=$(echo $2 | tr ' ' '\\\
    n' | grep -n -F -f <(cat <(echo $2|tr ' ' '\\n') | sed \"s/$i//g\"))\n  if [[\
    \ -n \"$j\" ]]; then\n    i2=$((i2+1))\n    j=$((j-1))\n    echo $i\"-\"$j\n \
    \ fi", "    awk -F'[ ]' '$2 ~ /^['\"$1\"']*$/ {print $2}' $3", "  local list1=$1\n\
    \  local list2=$2\n  comm -12 <(printf '%s\\0' \"$list1\" | sort -z) <(printf\
    \ '%s\\0' \"$list2\" | sort -z)", "  local unique\n  local tmp\n  tmp=$(mktemp\
    \ \"${TMPDIR:-/tmp}/common_XXXXXX\")\n  unique=$(mktemp \"${TMPDIR:-/tmp}/common_uniqueXXXXXX\"\
    )\n  echo \"$1\" > \"$tmp\"\n  echo \"$2\" >> \"$tmp\"\n  sort -u \"$tmp\" > \"\
    $unique\"\n  sort \"$unique\" > \"$unique.sorted\"\n  echo \"$unique.sorted\"\
    \ > \"$unique.list\"\n  rm \"$unique\" \"$tmp\" \"$unique.sorted\"", "  local\
    \ a b i\n  local list1=\"${1:-}\"\n  local list2=\"${2:-}\"\n  local sorted1\n\
    \  local sorted2\n  local first\n  local last\n  local diff\n  local count\n \
    \ local lastfound\n  local list1count\n  local list2count\n  local list1word\n\
    \  local list2word\n  local i\n  list1count=$(echo \"$list1\" | wc -c)\n  list2count=$(echo\
    \ \"$list2\" | wc -c)\n  sorted1=$(echo \"$list1\" | tr ' ' \"\\n\" | sort -u\
    \ | tr \"\\n\" \" \")\n  sorted2=$(echo \"$list2\" | tr ' ' \"\\n\" | sort -u\
    \ | tr \"\\n\" \" \")\n  if [[ $list1count -gt $list2count ]]\n  then\n    first=\"\
    ${sorted1[0]}\"\n    last=\"${sorted1[$(($list1count-1))]}\"\n  else\n    first=\"\
    ${sorted2[0]}\"\n    last=\"${sorted2[$(($list2count-1))]}\"\n  fi\n  diff=$(($((${#list1}-${#list2}+1))\
    \ + 1))\n  echo \"$first\"\n  while [[ $diff -gt 0 ]]\n  do\n    lastfound=false\n\
    \    for ((i=$((${#list1}-$diff+1)); i>0; i--))\n    do\n      if [[ ${sorted1}[$i]\
    \ == ${sorted2}[$((i-$diff)) ]]; then\n        list1word=\"${sorted1[i]}\"\n \
    \       list2word=\"${sorted2[$((i-$diff))]}\"\n        if [[ $list1word != \"\
    $list2word\" ]]; then\n          lastfound=true\n        fi\n      fi\n    done\n\
    \    if [[ $lastfound == false ]]; then\n      echo \"$first\"\n      diff=$(($diff\
    \ - 1))\n    else\n      diff=$(($diff - 1))\n      first=\"${sorted1[$(($diff\
    \ - 1))]}\"\n    fi\n  done\n  echo \"$last\"", "    local common_file=\"$1\"\n\
    \    local reference_file=\"$2\"\n\n    # read all the lines from reference_file\
    \ and sort them\n    local reference_file_lines sorting_reference_file\n    IFS=$'\\\
    n' reference_file_lines=$(<\"${reference_file}\")\n    sort <<< ${reference_file_lines}\n\
    \n    # read all the lines from common_file and sort them\n    local common_file_lines\
    \ sorting_common_file\n    IFS=$'\\n' common_file_lines=$(<\"${common_file}\"\
    )\n    sort <<< ${common_file_lines}\n\n    common_lines=$(comm -3 -2 -3 < <(printf\
    \ '%s\\n' \"${reference_file_lines[@]}\" \"${common_file_lines[@]}\") | wc -l)\n\
    \n    # return unique common lines\n    echo \"${reference_file_lines[@]}\"",
  "    local IFS=\\; # shellcheck disable=SC1086\n    local -a list1; local -a list2;\
    \ local -a result\n    local i=0\n    local j=0\n    local len1=$#\n    local\
    \ len2=$((${#list[*]} - len1))\n    while ((i < len1)); do\n        list1[i]=$(eval\
    \ \"echo '$list1[$i]'\")\n        ((i+=1))\n    done\n    while ((j < len2));\
    \ do\n        list2[j]=$(eval \"echo '$list2[$j]'\")\n        ((j+=1))\n    done\n\
    \    for ((i=1; i<${#list1[*]}; i++)); do\n        result=()\n        for ((j=1;\
    \ j<${#list2[*]}; j++)); do\n            if [[ \"${list1[$i]}\" == \"${list2[j]}\"\
    \ ]]; then\n                result+=(\"${list1[$i]}\")\n            fi\n     \
    \   done\n        list1[i]=$(eval \"echo '${result[@]}'\")\n    done\n    echo\
    \ \"${list1[*]}\"", "    local -n arr1=$1; shift\n    local -n arr2=$1; shift\n\
    \    local common=()\n    for i in $(seq 0 ${#arr1[*]})\n    do\n        if [[\
    \ ${arr1[$i]} == ${arr2[$i]} ]]\n        then\n            common+=(\"${arr1[$i]}\"\
    )\n        fi\n    done\n    echo \"${common[@]}\"", "    local i j\n    declare\
    \ -a list1=($(echo \"$1\" | sed 's/ /\" \"/g'))\n    declare -a list2=($(echo\
    \ \"$2\" | sed 's/ /\" \"/g'))\n    declare -a common=($(comm -12 <(printf '%s\\\
    n' \"${list1[@]}\") <(printf '%s\\n' \"${list2[@]}\"))) || return 1\n    echo\
    \ \"${common[@]}\"", "    local common=$1\n    shift\n    local all=$1\n    shift\n\
    \n    # Filter out the common elements\n    common=$(echo ${common} | sed 's/\
    \ /|/g' | sort -u)\n    all=$(echo ${all} | sed 's/ /|/g' | sort -u)\n\n    #\
    \ Strip out common elements that occur in both lists\n    common=$(echo ${common}\
    \ | sed -E -e '/^\\|$/d' -e '/^\\|$/d' | sort -u)\n    all=$(echo ${all} | sed\
    \ -E -e '/^\\|$/d' -e '/^\\|$/d' | sort -u)\n\n    # Return the list\n    echo\
    \ ${all[@]} |grep -Fx \"${common}\"", "  local i j k\n  declare -a a1 a2 d\n \
    \ a1=( $(echo $1 | sed 's/ /\\n/g') )\n  a2=( $(echo $2 | sed 's/ /\\n/g') )\n\
    \  d=( $(echo $1 | sed 's/ /\\n/g' | sort -u | sed 's/ /\\n/g') \\\n      $(echo\
    \ $2 | sed 's/ /\\n/g' | sort -u) )\n  for ((i=0; i<${#d[@]}; ++i)); do\n    for\
    \ ((j=0; j<${#d[@]}; ++j)); do\n      if [ \"${d[${i}]}\" == \"${d[j+1]}\" ];\
    \ then\n        for ((k=0; k<${#a1[@]}; ++k)); do\n          if [ \"${a1[${k}]}\"\
    \ == \"${a2[${j}]}\" ]; then\n            echo \"${d[i]}\"\n            return\n\
    \          fi\n        done\n      fi\n    done\n  done\n  echo \"0\"", "    local\
    \ list_a list_b len a b c\n    list_a=\"$1\";\n    list_b=\"$2\";\n    len=\"\
    ${#list_a}\";\n    for ((i=0;i<$len;i++)); do\n        a=\"${list_a:$i:1}\";\n\
    \        b=\"${list_b:$i:1}\";\n        if [[ \"$a\" == \"$b\" ]];then\n     \
    \       c=\"$(echo \"$a\" | sed 's/^\"//;s/\"$//')\";\n            if [[ $c =\
    \ \"$a\" ]];then\n                list_a=\"${list_a:0:$i};${list_a:$i:1}\";\n\
    \            else\n                list_b=\"${list_b:0:$i};${list_b:$i:1}\";\n\
    \            fi\n        fi\n    done\n    echo \"${list_a}${list_b}\"", "\t#\
    \ $1 is a list of sorted unique elements\n\t# $2 is a list of sorted unique elements\n\
    \tlocal list1\n\tlocal list2\n\tlocal common\n\tlocal result\n\n\tlist1=( $1 )\n\
    \tlist2=( $2 )\n\tcommon=()\n\n\twhile [ ${#list1[@]} -gt 0 ] && [ ${#list2[@]}\
    \ -gt 0 ]; do\n\t\tlocal elem1=${list1[0]}\n\t\tlocal elem2=${list2[0]}\n\n\t\t\
    IFS= read -r elem1 elem2 || break\n\n\t\tcommon+=( \"$elem2\" )\n\t\tlist1=(${list1[@]:1})\n\
    \t\tlist2=(${list2[@]:1})\n\tdone\n\n\tresult=( \"${common[@]}\" )\n\techo \"\
    ${result[@]}\" | sort -u", "\tlocal common\n\tlocal i j\n\tcommon=$(comm -z -2\
    \ $1 $2)\n\tfor (( j=0; j < ${#common}; j++ )); do\n\t\ti=$(echo $common | cut\
    \ -d ' ' -f $j)\n\t\tcommon=$(echo $common | cut -d ' ' -f $((j+1)))\n\t\tcommon=${common/$i/}\n\
    \tdone\n\techo $common", '  sort -u "$1" "$2" | sort -u', "    local arg1=\"${1}\"\
    \n    local arg2=\"${2}\"\n\n    local unique1=($(sort -u <<<\"${arg1}\"))\n \
    \   local unique2=($(sort -u <<<\"${arg2}\"))\n\n    local intersect=($(\n   \
    \     echo \"${unique1}\" |\n        grep -F -v -e \"${unique2}\" |\n        sort\
    \ -u)\n    )\n\n    # Print result\n    echo \"${intersect[@]}\"", "    sort -u\
    \ <(set -- \"$1\" ; echo \"$2\") |\n        sort -u", "    local common\n    IFS='\
    \ ' read -a common <<< \"$1\"\n    IFS=' ' read -a common2 <<< \"$2\"\n    IFS='\
    \ ' read -a common <<< \"$common\"\n    IFS=' ' read -a common2 <<< \"$common2\"\
    \n    local i\n    for i in \"${common[@]}\"; do\n        for j in \"${common2[@]}\"\
    ; do\n            if [[ \"$i\" == \"$j\" ]]; then\n                echo \"$i\"\
    \n            fi\n        done\n    done", "  sort <(tr ' ' '\\n' <<< \"$1\")\
    \ - <(tr ' ' '\\n' <<< \"$2\") | uniq -d", "  local common tmp tmp2 tmp2\n  IFS=\"\
    \ \"; common=$( echo \"$1\" | tr \" \" \"\\n\" | sort -u )\n  IFS=\" \"; tmp=$(\
    \ echo \"$2\" | tr \" \" \"\\n\" | sort -u )\n  IFS=\" \"; tmp2=$( echo \"$common\"\
    \ | tr \" \" \"\\n\" | sort -u )\n  echo \"$tmp2\" | grep -v -f - | grep -v -f\
    \ \"$tmp\"", "    local IFS=\"$1\"\n    shift\n    local -a one\n    local -a\
    \ two\n    local -i last\n    local found=0\n    one=( \"${@}\" )\n    two=( \"\
    ${@}\" )\n    last=-1\n    for (( i=0; i<${#one[@]}; i++ )); do\n        if [\
    \ ${one[i]} == \"${two[$i]}\" ]; then\n            if [ $found -eq 0 ]; then\n\
    \                found=1\n                last=\"${i}\"\n            fi\n    \
    \    fi\n    done\n    IFS=\"$IFS\"\n    declare -n items=\"${one[@]:${last}}\"\
    \n    echo \"${items[*]}\"", "    local sorted1 sorted2\n    sorted1=$(echo $1\
    \ | tr -s ' ' ',' | sort -u)\n    sorted2=$(echo $2 | tr -s ' ' ',' | sort -u)\n\
    \    comm -3 -2 -4 <(echo $sorted1) <(echo $sorted2)", "    local list1=($(echo\
    \ \"${1}\" | tr -s ' '))\n    local list2=($(echo \"${2}\" | tr -s ' '))\n   \
    \ local common\n\n    local i\n    local j\n\n    local list1_sorted\n    local\
    \ list2_sorted\n    for ((i = 0; i < ${#list1[*]}; i++));do\n        list1_sorted=($(echo\
    \ \"${list1[*]}\" | sort -u | tr -s ' '))\n        list2_sorted=($(echo \"${list2[*]}\"\
    \ | sort -u | tr -s ' '))\n        local common\n        for ((j = 0; j < ${#list1_sorted[*]};\
    \ j++));do\n            [[ \"${list1_sorted[j]}\" == \"${list2_sorted[j]}\" ]]\
    \ &&\n                common=\"${common}${list1_sorted[j]}\"\n        done\n \
    \       list1[i]=\"${common}\"\n    done\n    echo ${list1[*]}", "    local list1\
    \ list2\n    list1=($1)\n    list2=($2)\n    local count result\n    local i\n\
    \    local tmp\n    local elem\n    for ((i = 0; i < ${#list1[*]}; ++i)); do\n\
    \        elem=${list1[i]}\n        (( count[$elem]++ ))\n    done\n    \n    for\
    \ ((i = 0; i < ${#list2[*]}; ++i)); do\n        elem=${list2[i]}\n        if ((\
    \ count[$elem] > 0 )); then\n            result+=(\"$elem\")\n        fi\n   \
    \ done\n    \n    IFS=' '\n    for ((i = 0; i < ${#result[@]}; ++i)); do\n   \
    \     eval $tmp=\"'${result[i]}'\"\n        eval $tmp=${tmp//$'\\r'//}\n     \
    \   eval \"$tmp\"\n    done\n    ", "  # Make sure both arguments are lists\n\
    \  [[ \"${#}\" -eq 0 ]] || [[ \"${#}\" -eq 1 ]] || return 1\n  [[ \"${1}\" =~\
    \ \" \" ]]\n  [[ \"${2}\" =~ \" \" ]]\n  # Remove spaces\n  x=$(sed 's/^ //g'\
    \ <<< \"${1}\")\n  y=$(sed 's/^ //g' <<< \"${2}\")\n  # If there is no common\
    \ elements, return empty result\n  [[ \"${x}\" != *\"${y}\"* ]] || return 0\n\
    \  # Remove common elements\n  x=$(echo \"${x}\" | tr ' ' ',')\n  y=$(echo \"\
    ${y}\" | tr ' ' ',')\n  # Get sorted unique common elements\n  comlist=$(comm\
    \ -23G \"$x\" \"$y\" | sort -u)\n  # Remove spaces and quotes\n  comlist=$(echo\
    \ \"${comlist}\" | sed 's/^ //g' | sed 's/ \"//g')\n  # Remove common elements\
    \ from $2\n  [[ \"${2}\" =~ \"(${comlist})\"* ]] || return 1\n  # Return sorted\
    \ unique common elements\n  echo \"${comlist}\"", "    local i\n    local -a a\n\
    \    local -a b\n    local IFS=$'\\t'\n    local -a a\n    local -a b\n    local\
    \ -a c\n\n    shift 2\n\n    for ((i=1; i<=$((${#1})); i++)); do\n        a+=($(echo\
    \ \"$1\" | cut -d$' ' -f \"$i\"))\n    done\n\n    for ((i=1; i<=$((${#2})); i++));\
    \ do\n        b+=($(echo \"$2\" | cut -d$' ' -f \"$i\"))\n    done\n\n    for\
    \ ((i=0; i<${#a[*]}; i++)); do\n        c+=(\"${a[$i]}\" \"${b[$i]}\")\n    done\n\
    \n    local tmp\n    local j\n    for ((i=0; i<${#a[*]}; i++)); do\n        j=0\n\
    \        for ((j=0; j<${#c[*]}; j++)); do\n            if [ \"${c[$j]}\" = \"\
    ${a[$i]}\" ]; then\n                tmp=${c[$j]}\n                break\n    \
    \        fi\n        done\n        if [ \"$j\" -eq \"${#c[*]}\" ]; then\n    \
    \        c+=($tmp)\n        fi\n    done\n    sort -u <<< \"${c[*]}\"", "\tset\
    \ -- \"$1\"; shift\n\tset -- \"$1\"; shift\n\tlocal ret\n\tret=()\n\tfor ((i =\
    \ 0; i < $#; i++))\n\tdo\n\t\tlocal e m\n\t\te=\"$2\"\n\t\tm=\"$2\"\n\t\tif ((\
    \ \"${#e[@]}\" > \"${#m[@]}\" ))\n\t\tthen\n\t\t\twhile (( \"${#e[@]}\" > \"${#m[@]}\"\
    \ ))\n\t\t\tdo\n\t\t\t\tm=\"$m ${e[0]}\"\n\t\t\t\te=(\"${e[@]:1}\")\n\t\t\t\t\
    ret+=(\"$m\")\n\t\t\tdone\n\t\tfi\n\tdone\n\techo \"${ret[@]}\"", "    local IFS=\"\
    \ $1 $2\"\n    sort -u \"$1\" \"$2\"", "    local common_list common_list_tmp\n\
    \    common_list=\"$(sort -u $1)\"\n    common_list_tmp=\"$(sort -u $2)\"\n  \
    \  case \"${#common_list}\" in\n        0 )\n            echo \"${common_list_tmp}\"\
    \n        ;;\n        * )\n            echo \"${common_list}\" | tr ' ' '\\n'\
    \ | sort -u | grep \"^${common_list_tmp}\" | sed 's/^\\(.*\\)\\n\\(.*$\\)/\\1\\\
    2/'\n        ;;\n    esac", "  local list_1 list_2 common_elements\n  list_1=($(echo\
    \ \"$1\" | sed 's/ /\\n/g' | sort -u))\n  list_2=($(echo \"$2\" | sed 's/ /\\\
    n/g' | sort -u))\n  common_elements=($(ls -1 \"$1_$2\" | sort -u))\n  echo $(echo\
    \ \"$common_elements\" | sed 's/ /\\n/g')", "\tlocal l1 l2\n\tl1=$1\n\tl2=$2\n\
    \tl1=(${l1})\n\tl2=(${l2})\n\tunset -v r a b c d\n\tr=$(awk 'BEGIN {\n\t\tdelete\
    \ a\n\t\tdelete b\n\t\tdelete c\n\t\tdelete d\n\t\tfor(i=1;i<=NF;i++)\n\t\t{\n\
    \t\t\ta[i]=$i\n\t\t}\n\t\tfor(i=1;i<=NF;i++)\n\t\t{\n\t\t\tb[i]=$i\n\t\t}\n\t\t\
    for(i=1;i<=NF;i++)\n\t\t{\n\t\t\tc[i]=$i\n\t\t}\n\t\tfor(i=1;i<=NF;i++)\n\t\t\
    {\n\t\t\td[i]=$i\n\t\t}\n\t}\n\tEND\n\t{\n\t\tfor(i=1;i<=NF;i++)\n\t\t{\n\t\t\t\
    if(!($i in a))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\ta[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in b))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\tb[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in c))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\tc[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in d))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\td[$i]=1\n\t\t\t}\n\t\t}\n\t}\n\t\
    END\n\t{\n\t\tfor(i=1;i<=NF;i++)\n\t\t{\n\t\t\tif(!($i in a))\n\t\t\t{\n\t\t\t\
    \tr[++r]=$i\n\t\t\t\ta[$i]=1\n\t\t\t}\n\t\t\tif(!($i in b))\n\t\t\t{\n\t\t\t\t\
    r[++r]=$i\n\t\t\t\tb[$i]=1\n\t\t\t}\n\t\t\tif(!($i in c))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\
    \t\t\t\tc[$i]=1\n\t\t\t}\n\t\t\tif(!($i in d))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\
    \t\t\td[$i]=1\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfor(i=1;i<=NF;i++)\n\t\t{\n\t\t\t\
    if(!($i in a))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\ta[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in b))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\tb[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in c))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\tc[$i]=1\n\t\t\t}\n\t\t\tif(!($i\
    \ in d))\n\t\t\t{\n\t\t\t\tr[++r]=$i\n\t\t\t\td[$i]=1\n\t\t\t}", "  local IFS=\"\
    $1\"\n  local -n sorted=\"$(sort $2)\"\n  local -a intersect\n  intersect=($(IFS=\"\
    $IFS\" printf \"%s\\n\" \"$sorted\" | grep -vFf - <(sort $1) | grep -vFf - <(sort\
    \ $2)))\n  IFS=\"$IFS\"\n  echo \"${intersect[@]}\"", "    awk '{ n=split($1,\
    \ a, \"\\n\"); m=split($2, b, \"\\n\");\n        for (i = 1; i <= n; i++) {\n\
    \            for (j = 1; j <= m; j++) {\n                if (a[i] < b[j])\n  \
    \                  tmp=a[i];\n                else\n                    tmp=b[j];\n\
    \                if (tmp == a[i])\n                    delete a[i]; \n       \
    \         if (tmp == b[j])\n                    delete b[j];\n            } \n\
    \        }\n        for (i = 1; i <= m; i++) {\n            if (i in a)\n    \
    \            a[i]=a[i]\" \"tmp\n            if (i in b)\n                b[i]=b[i]\"\
    \ \"tmp\n        }\n        delete tmp;\n    }\n    { for (j in a)\n        if\
    \ (a[j] > \"\")\n            a[j]=a[j]\" \"j\n    for (j in b)\n        if (b[j]\
    \ > \"\")\n            b[j]=b[j]\" \"j\n    for (i in a)\n        if (a[i] > \"\
    \")\n            a[i]=a[i]\" \"i\n    for (i in b)\n        if (b[i] > \"\")\n\
    \            b[i]=b[i]\" \"i\n    for(i=1;i<=length(a);i++) \n    {\n        if(a[i]!=\"\
    \" && a[i] in b)\n        {\n            a[split(a[i],b,\" \")[1]]=a[split(a[i],b,\"\
    \ \")[1]] \" \" b[i]\n        }\n    }\n    for(i=1;i<=length(b);i++) \n    {\n\
    \        if(b[i]!=\"\" && b[i] in a)\n        {\n            b[split(b[i],a,\"\
    \ \")[1]]=b[split(b[i],a,\" \")[1]] \" \" a[i]\n        }\n    }\n    for(i=1;i<=length(a);i++)\
    \ \n    {\n        if(!(i in b) && a[i]!=\"\") \n        {\n            a[split(a[i],b,\"\
    \ \")[1]]=a[split(a[i],b,\" \")[1]] \" \" b[i]\n        }\n    }\n    for(i=1;i<=length(b);i++)\
    \ \n    {\n        if(!(i in a) && b[i]!=\"\") \n        {\n            b[split(b[i],a,\"\
    \ \")[1]]=b[split(b[i],a,\" \")[1]] \" \" a[i]\n        }\n    }\n    for (i in\
    \ a)\n        print a[i]\n    for (i in b)\n        print b[i]\n    }'", "   \
    \ sort -u -z <<<\"$1 $2\" |\n        cut -d ' ' -f 1 |\n        sort -z -t ' '\
    \ -u |\n        sed 's/^\"\\(.*\\)\"$/\\1/'", "    local list1=\"$1\"\n    local\
    \ list2=\"$2\"\n    local i element seen=()\n    while IFS= read -r element; do\n\
    \        (( ${#seen[@]} )) && [ \"$seen[$element]\" -eq 0 ]\n        seen[$element]=1\n\
    \    done <<< \"$list1\"\n    local list1\n    local list2\n    for element in\
    \ ${!seen[@]}; do\n        [[ \"$list2\" != \"$list1\" ]] && return \"$element\"\
    \n        list2=\"${seen[$element]}\"\n    done", "  # sort both lists, remove\
    \ duplicates\n  local sorted_lists=$(comm -2 <(sort $1) <(sort $2))\n  local unique_sorted_lists=$(sort\
    \ $(printf %s $sorted_lists) | uniq -u)\n\n  # return sorted unique common elements\n\
    \  printf %s\\\\n \"$unique_sorted_lists\"", "  local i\n  local list1=($@)\n\
    \  local list2=(\"$@\")\n  local list3=($(sort <<<\"$list1 $list2\"))\n  unset\
    \ IFS\n  for i in $(echo \"$list3\"); do\n    [[ \"${#list1[*]}\" -gt \"${#list2[*]}\"\
    \ ]] && return 0\n    [[ \"${list1[*]}\" != \"$i\" ]] && return 1\n    [[ \"${list2[*]}\"\
    \ != \"$i\" ]] && return 2\n  done\n  return 0", "  local list1=$1 list2=$2\n\
    \  typeset -a list1_words list2_words\n  local IFS=\" \"\n  list1_words=($(echo\
    \ \"$list1\" | tr ' ' '\\n' | sort -u))\n  list2_words=($(echo \"$list2\" | tr\
    \ ' ' '\\n' | sort -u))\n  local results=()\n  while [ \"${#list1_words[@]}\"\
    \ -gt 0 ] && [ \"${#list2_words[@]}\" -gt 0 ]; do\n    if [ \"${list1_words[0]}\"\
    \ != \"${list2_words[0]}\" ]; then\n      results+=(\"${list1_words[0]}\")\n \
    \     list1_words=(\"${list1_words[@]:1}\")\n    else\n      list2_words=(\"${list2_words[@]:1}\"\
    )\n    fi\n  done\n  echo \"${results[@]}\"", "  sort -u \\\n    $(grep -z \"\
    $1\" $2 | cut -d\\  -f1)", "    local common=$1\n    shift\n    local uncommon=$1\n\
    \    shift\n    local list1=$1\n    shift\n    local list2=$1\n    shift\n   \
    \ local output\n\n    # Split each list on whitespace and get rid of quotes\n\
    \    IFS=$'\\n' read -d '' -r -a list1 < <(tr ' ' ' ' <<< \"$list1\")\n    IFS=$'\\\
    n' read -d '' -r -a list2 < <(tr ' ' ' ' <<< \"$list2\")\n    IFS=$'\\n' read\
    \ -d '' -r -a uncommon < <(tr ' ' ' ' <<< \"$uncommon\")\n\n    # Compare each\
    \ element of the first list with the rest\n    for i in \"${!list1[@]}\"; do\n\
    \        common=\"${common}${list1[i]}\"\n        if [[ -n \"${list2[i]}\" ]];\
    \ then\n            list2[i]=\"${list2[i]}\"\n        else\n            uncommon[i]=\"\
    ${uncommon[i]}\"\n        fi\n    done\n\n    # Output only common elements\n\
    \    IFS=$'\\n' read -d '' -r -a output < <(tr ' ' ' ' <<< \"$common\")\n\n  \
    \  # Filter out uncommon elements\n    for i in \"${!uncommon[@]}\"; do\n    \
    \    if [[ -n \"${uncommon[i]}\" ]]; then\n            list2[i]=\"${uncommon[i]}\"\
    \n        else\n            echo \"$list2[i]\"\n        fi\n    done\n    echo\
    \ \"${output[@]}\"", "    local common_files=$(comm -3 -2 -3 \"$1\" \"$2\");\n\
    \    if [[ -z \"$common_files\" ]]; then\n        echo \"\";\n    else\n     \
    \   echo \"$common_files\";\n    fi", "    comm -12 $1 $2 |\n        sed \"s/\\\
    ([0-9]*\\)$/\\\"\\1\\\"/\" |\n        sed \"s/[, ]/ /g\" |\n        sort -u |\n\
    \        tr \"\\n\" \" \"", "  local sorted1\n  local sorted2\n  local ret\n \
    \ sorted1=$1\n  sorted2=$2\n  ret=$(comm -2 -3 <(sort <<<\"$sorted1\") <(sort\
    \ <<<\"$sorted2\"))\n  printf \"[%s]\" $(printf \" \" $ret)", "    local list1=($(echo\
    \ ${1} | tr \" \" \"\\n\"))\n    local list2=($(echo ${2} | tr \" \" \"\\n\"))\n\
    \    local sortedlist=($(sort -u \"$(join <(printf \"%s\\n\" \"${list1[@]}\")\
    \ <(printf \"%s\\n\" \"${list2[@]}\"))\"))\n    echo $sortedlist", "  local l1\
    \ l2\n  l1=\"$(IFS=; echo \"$1\")\"\n  l2=\"$(IFS=; echo \"$2\")\"\n  # Remove\
    \ common elements\n  l1=$(echo \"${l1}\" | tr '[:space:]' '\\n' | sort -u)\n \
    \ l2=$(echo \"${l2}\" | tr '[:space:]' '\\n' | sort -u)\n  # Remove common elements\
    \ found in both lists\n  l1=\"$(echo \"${l1}\" | grep -vFx \"${l2}\")\"\n  echo\
    \ \"${l1}\"", "    # Special case empty lists to make them easier to deal with.\n\
    \    [[ -z \"$1\" ]] && return 0;\n    [[ -z \"$2\" ]] && return 0;\n    # Convert\
    \ each list to an array so we can loop over each element.\n    IFS=$'\\n' arr1=(\
    \ $1 )\n    IFS=$'\\n' arr2=( $2 )\n    # The first array will contain the unique\
    \ elements\n    # of $1, the second of $2\n    # After each element is seen, the\
    \ counter is incremented.\n    [[ -z \"$arr1\" ]] && return 0;\n    [[ -z \"$arr2\"\
    \ ]] && return 0;\n    # Count the number of unique elements in $1, $2.\n    #\
    \ The result will be stored in $RESULT.\n    RESULT=\"\"\n    for (( i = 0; i\
    \ < ${#arr1[*]}; i++ )); do\n        [[ -z \"$RESULT\" ]] && RESULT=$arr1[$i]\n\
    \        [[ -z \"$RESULT\" ]] && RESULT=$arr2[$i]\n        [[ \"$RESULT\" != \"\
    $arr1[$i]\" ]] && RESULT=\"$(echo -e \"$RESULT\\n$arr1[$i]\" | sort -u | wc -l)\"\
    \n        [[ \"$RESULT\" != \"$arr2[$i]\" ]] && RESULT=\"$(echo -e \"$RESULT\\\
    n$arr2[$i]\" | sort -u | wc -l)\"\n    done\n    # Sort the unique elements in\
    \ $RESULT.\n    RESULT=\"$(echo -e \"$RESULT\\n$RESULT\" | sort -u | wc -l)\"\n\
    \    echo \"$RESULT\"", "    local list_1 list_2\n    list_1=\"${1// /$'\\n'}\"\
    \n    list_2=\"${2// /$'\\n'}\"\n    sort -u --field-separator=$' ' <(printf '%s\\\
    n' \"${list_1}\") <(printf '%s\\n' \"${list_2}\")", "    local list_1 list_2\n\
    \    list_1=$1\n    list_2=$2\n    local i j comm found\n    IFS=\" \" read -a\
    \ list_1 <<< \"$list_1\"\n    IFS=\" \" read -a list_2 <<< \"$list_2\"\n    #\
    \ find common element in the lists\n    comm_l=()\n    for ((i = 0; i < ${#list_1[*]};\
    \ i++)); do\n        for ((j = 0; j < ${#list_2[*]}; j++)); do\n            if\
    \ [[ ${list_1[i]} = ${list_2[j]} ]]; then\n                comm_l+=(\"${list_1[i]}\"\
    )\n            fi\n        done\n    done\n    # find unique common elements\n\
    \    comm_l=($(comm -3 <(printf \"%s\\n\" \"${comm_l[@]}\") <(printf \"%s\\n\"\
    \ \"${list_2[@]}\") | awk '{print $1}'))\n    found=$(echo $comm_l | uniq -d)",
  "    # Make sure both arguments are lists of strings\n    local -i list_a list_b\n\
    \    list_a=${1// / }\n    list_b=${2// / }\n    # Make sure both arguments are\
    \ the same length\n    if [ -z \"${#list_a}\" -o -z \"${#list_b}\" ]; then\n \
    \       return 1\n    fi\n    # Remove leading and trailing whitespace\n    list_a=${list_a//\
    \ /}\n    list_b=${list_b// /}\n    # Remove duplicate entries from $list_a\n\
    \    list_a=\"$(echo \"${list_a}\" | tr \" \" \"\\n\" | sort | uniq | tr \"\\\
    n\" \" \")\"\n    list_b=\"$(echo \"${list_b}\" | tr \" \" \"\\n\" | sort | uniq\
    \ | tr \"\\n\" \" \")\"\n    # Compare $list_a and $list_b\n    sort ${list_a}\
    \ > /tmp/list_a\n    sort ${list_b} > /tmp/list_b\n    comm -12 <(sort /tmp/list_a)\
    \ <(sort /tmp/list_b)", "    local -n l1=$1; shift\n    local -n l2=$1; shift\n\
    \    local sorted=false\n    # Sort first list so we can compare them easier\n\
    \    l1=$(sort <<<\"$1\")\n    l2=$(sort <<<\"$2\")\n    # Compare first and second\
    \ list\n    # Return sorted common elements if they are equal\n    # Otherwise\
    \ return an empty list to indicate no common elements.\n    if [ $(sort <<<\"\
    $l1 $l2\") != \"$l1 $l2\" ]; then\n        sorted=true\n    fi\n    # Return sorted\
    \ unique common elements if they are equal\n    if [ \"$sorted\" = true ]; then\n\
    \        echo \"$l1 $l2\"\n    else\n        echo \"\"\n    fi", "    local list1\n\
    \    local list2\n    list1=$1\n    list2=$2\n    local tmp1 tmp2\n    tmp1=`echo\
    \ $list1 | sed 's/ /\\n/g'`\n    tmp2=`echo $list2 | sed 's/ /\\n/g'`\n    echo\
    \ -n $(comm -13 $tmp1 $tmp2)", "  local sorted1=($( echo \"$1\" | sed 's/ /\\\\\
    \ /g' | sort -u ))\n  local sorted2=($( echo \"$2\" | sed 's/ /\\\\ /g' | sort\
    \ -u ))\n  local intersect\n  intersect=()\n  for i in ${sorted1[@]}; do\n   \
    \ for j in ${sorted2[@]}; do\n      [[ $i == $j ]] && intersect+=(\"$i\")\n  \
    \  done\n  done\n  echo $( IFS=\",\"; echo \"${intersect[@]}\" )", "  local sorted_common=()\n\
    \  local i\n  local first_list\n  local second_list\n  local common_element\n\
    \  local common_element_count\n  local common_element_found\n  local common_element_i\n\
    \  local first_list_index\n  local second_list_index\n  local common_element_count\n\
    \  local first_list_elements\n  local second_list_elements\n  local first_list_element\n\
    \  local second_list_element\n  first_list=$1\n  second_list=$2\n  first_list_elements=$(printf\
    \ \"%s\\n\" \"${first_list[@]}\" | sort -u)\n  second_list_elements=$(printf \"\
    %s\\n\" \"${second_list[@]}\" | sort -u)\n  for ((i=0; i<${#first_list_elements};\
    \ i++))\n  do\n    common_element_found=false\n    for ((j=0; j<${#second_list_elements};\
    \ j++))\n    do\n      common_element=$(printf \"%s\" \"${first_list_elements[i]}\"\
    \ | sort -u)\n      common_element_i=$i\n      common_element_count=$(printf \"\
    %s\\n\" \"${second_list_elements[j]}\" | sort -u | wc -l)\n      if [ \"${common_element_count}\"\
    \ = \"${#common_element}\" ]\n      then\n        if [ \"${common_element_i}\"\
    \ = \"$j\" ]\n        then\n          common_element_found=true\n          break\n\
    \        fi\n      fi\n    done\n    if [ \"${common_element_found}\" = false\
    \ ]\n    then\n      sorted_common+=(\"${first_list_elements[i]}\")\n    fi\n\
    \  done\n  printf \"%s\\n\" \"${sorted_common[@]}\" | sort -u", "\tlocal a b i\
    \ ii j jj res res x\n\ta=${1%% *}\n\tb=${2%% *}\n\tx=$a\n\ty=$b\n\t[[ $a == */*\
    \ ]] && a=\"./$a\"\n\t[[ $b == */* ]] && b=\"./$b\"\n\tres=\"\"\n\tfor (( i=1;\
    \ i<=${#x}; i++ )); do\n\t\t[[ $y == \"\" ]] && break\n\t\tii=$(( ${i}+1 ))\n\t\
    \tj=$(( ${#y}+1 ))\n\t\twhile (( ${j} > 0 )); do\n\t\t\tjj=$(( ${#x}+1 ))\n\t\t\
    \twhile (( ${jj} > 0 )); do\n\t\t\t\t[[ ${x[$i]} != ${y[$j]} ]] && break\n\t\t\
    \t\t(( ${jj}-- ))\n\t\t\tdone\n\t\t\t[[ ${x[$i]} != ${y[$j]} ]] && break\n\t\t\
    \t(( ${j}-- ))\n\t\tdone\n\t\tres=\"${res} ${x[$i]}\"\n\t\t(( ${ii}+1 ))\n\tdone\n\
    \techo ${res::${#res}}", "    local _common_words _common_chars _common_chars2\n\
    \    local _common_words2 _common_chars3 _common_chars4 _common_chars5\n    local\
    \ _common_words3 _common_chars6 _common_chars7\n\n    _common_words=\"$1\" \"\
    $2\" | tr -s '[:space:]' '[:blank:]'\n    _common_chars=\"$1\" \"$2\" | tr -s\
    \ '[:blank:]' '[:space:]'\n\n    _common_words2=\"$(echo \"$_common_words\" |\
    \ sed -e 's/ *[^ ]\\+ \\+[^ ]\\+ \\+/ /g')\"\n    _common_chars2=\"$(echo \"$_common_chars\"\
    \ | sed -e 's/ \\+/ /g')\"\n\n    _common_words3=\"$(echo \"$_common_words2\"\
    \ | sed -e 's/ [^ ]\\+ \\+/ /g' | sort | uniq)\"\n    _common_chars3=\"$(echo\
    \ \"$_common_chars2\" | sed -e 's/ [^ ]\\+ \\+/ /g' | sort | uniq)\"\n\n    _common_words4=\"\
    $(echo \"$_common_words2\" | sed -e 's/ \\+/ /g' | sort | uniq)\"\n    _common_chars4=\"\
    $(echo \"$_common_chars2\" | sed -e 's/ \\+/ /g' | sort | uniq)\"\n\n    _common_words5=\"\
    $(echo \"$_common_words2\" | sed -e 's/ \\+/ /g' | sort | uniq)\"\n    _common_chars5=\"\
    $(echo \"$_common_chars2\" | sed -e 's/ \\+/ /g' | sort | uniq)\"\n\n    _common_words6=\"\
    $(echo \"$_common_words4\" | sed -e 's/ [^ ]\\+ \\+/ /g' | sort | uniq)\"\n  \
    \  _common_chars6=\"$(echo \"$_common_chars4\" | sed -e 's/ [^ ]\\+ \\+/ /g' |\
    \ sort | uniq)\"\n\n    _common_words7=\"$(echo \"$_common_words4\" | sed -e 's/\
    \ \\+/ /g' | sort | uniq)\"\n    _common_chars7=\"$(echo \"$_common_chars4\" |\
    \ sed -e 's/ \\+/ /g' | sort | uniq)\"\n\n    echo -n \"${_common_words%?}\"\n\
    \    echo -n \" \"\n    echo -n \"${_common_words#?}\"\n\n    echo -n \" \"\n\
    \    echo -n \"${_common_words%?}\"\n    echo -n \" \"\n    echo -n \"${_common_words#?}\"\
    \n\n    echo -n \" \"\n    echo ", "  local common_args=\"$1\"\n  shift\n  local\
    \ to_expand=\"$1\"\n  shift\n  local unique=()\n  while read -r elem; do\n   \
    \ unique+=(\"$elem\")\n  done <<< \"$to_expand\"\n  local to_expand=\"$unique\"\
    \n  local unique=()\n  while read -r elem; do\n    unique+=(\"$elem\")\n  done\
    \ <<< \"$to_expand\"\n  local common_args=\"$common_args $unique\"\n  eval \"\
    $COMMON_ARGS\"", "\tlocal common\n\tcommon=$(comm -23g <(sort -n $1) <(sort -n\
    \ $2))\n\techo $(echo $common | tr \"\\n\" \" \")", "    sort -u <(cut -d\" \"\
    \ -f2- <<<\"$1\") \\\n        <(cut -d\" \" -f2- <<<\"$2\" | sort -u)", "  sort\
    \ -u $(cat \"$1\") \\\n    | sort -u $(cat \"$2\")", "  local i i2 j\n  local\
    \ set unset diff\n  unset=true\n  set=false\n  for (( i=0; i<$#; i++ )); do\n\
    \    for (( j=0; j<$#; j++ )); do\n      if [[ \"$i\" -eq \"$j\" && \"$i\" -ge\
    \ 0 ]]; then\n        local k\n        k=\"$(cut -d: -f1 <<< $i)\"\n        local\
    \ l\n        l=\"$(cut -d: -f1 <<< $j)\"\n        if [ \"$k\" = \"$l\" ]; then\n\
    \          set=true\n          unset=false\n        fi\n      fi\n    done\n \
    \ done\n\n  # If set and unset are both false, then set must be true\n  if ((\
    \ $set && $unset )); then\n    set=true\n  fi\n\n  # If set is true, then we found\
    \ at least one shared element between two lists\n  # and unset is false, else\
    \ we found no shared element\n  if (( $set && ! $unset )); then\n    diff=\"$(printf\
    \ '%s\\n' \"$@\" | sort -u)\"\n    local i\n    for (( i=0; i<$#; i++ )); do\n\
    \      if [[ \"$i\" -ge 0 ]]; then\n        if [[ \"$i\" -ne \"$((i+1))\" ]];\
    \ then\n          diff=\"$diff\" \"$(cut -d: -f1 <<< $i)\"\n        fi\n     \
    \ fi\n    done\n    diff=\"$diff $diff\"\n  fi\n\n  echo \"$diff\"", "    local\
    \ set1=\"$(printf '%s' \"$1\") $(printf '%s' \"$2\")\"\n    local sorted1=($(echo\
    \ \"$set1\" | sort | uniq))\n    local set2=\"$(printf '%s' \"$2\") $(printf '%s'\
    \ \"$3\")\"\n    local sorted2=($(echo \"$set2\" | sort | uniq))\n    local common=$(printf\
    \ '%s' \"$sorted1[@]\" | grep -F -x \"$sorted2[@]\")\n    printf '%s\\n' \"$common\"",
  "  local list_1 list_2\n  # $1 is a space-separated list\n  # $2 is a space-separated\
    \ list\n  list_1=$1\n  list_2=$2\n  list_1=($list_1)\n  list_2=($list_2)\n\n \
    \ local i result\n  for (( i=0; i<${#list_1[*]}; i++ )); do\n    local j\n   \
    \ for (( j=0; j<${#list_2[*]}; j++ )); do\n      if [ \"$list_1\"[$i]\" == \"\
    $list_2\"[$j] ]; then\n        result[$i]=\"$list_1\"[$i]\n        break\n   \
    \   fi\n    done\n  done\n  printf \"%s\\n\" \"${result[*]}\"", "  local x\n \
    \ local a\n  local b\n  a=\"$1\"\n  b=\"$2\"\n  while read x || read -r x; do\n\
    \    [[ -z \"$x\" ]] || [[ \"$a\" == \"$x\" ]] || [[ \"$b\" == \"$x\" ]] && echo\
    \ \"$x\"\n  done < <(comm -2 -3 \"$a\" \"$b\")", "    local common1=$1\n    local\
    \ common2=$2\n    local sortedcommon=$(comm -2 -3 <(echo $common1) <(echo $common2))\n\
    \    echo $sortedcommon", "    local a\n    local b\n    local i\n    local j\n\
    \    local k\n    local len1\n    local len2\n    local common\n\n    a=\"${1//\
    \ / }\"\n    b=\"${2// / }\"\n    len1=${#a}\n    len2=${#b}\n    common=()\n\
    \    for i in $(seq $len1); do\n        for j in $(seq $len2); do\n          \
    \  if [[ $i == $j ]]; then\n                common+=(\"$a[$i]\")\n           \
    \     shift\n                shift\n            else\n                common+=(\"\
    $b[$j]\")\n                shift\n                shift\n            fi\n    \
    \    done\n    done\n    [[ -n ${common[@]} ]] || return 0\n    echo \"${common[@]}\"",
  "  local -a list=()\n  local list_c=\"${1#* }\"\n  local list_b=\"${2#* }\"\n  while\
    \ read -r line; do\n    local line_c=\"${line#* }\"\n    if [[ \"${list_c}\" ==\
    \ \"${line_c}\" ]]; then\n      list+=(\"${line}\")\n    fi\n  done <<< \"${list_b}\"\
    \n  local list_a=\"${list[@]}\"\n  printf '%s\\n' \"${list_a[@]}\" | sort -u |\
    \ grep -v -e '^$' | sort -u", "\tlocal array1=\"$1\"\n\tlocal array2=\"$2\"\n\t\
    local diff count\n\tdiff=$(comm -23 <(sort <<<\"$array1\") <(sort <<<\"$array2\"\
    ) | wc -w)\n\tif [ $diff -ne 0 ]\n\tthen\n\t\techo \"Error: $1 does not contain\
    \ all elements of $2\"\n\t\texit 2\n\tfi\n\tcount=$(( diff / 2 ))\n\tif [ $count\
    \ -eq 0 ]\n\tthen\n\t\techo \"$array1 contains all elements of $2\"\n\telse\n\t\
    \techo \"$array1 contains $count and $(( diff % 2 )) other elements of $2\"\n\t\
    fi", "    set -- $1 $2\n    local unique\n    unique=''\n    while [ \"$#\" -gt\
    \ 0 ]\n    do\n        local i\n        local j\n        local k\n        # Loop\
    \ over unique list elements\n        for ((i = 1; i <= ${#unique}; i++)); do\n\
    \            if [ -z \"${unique[$i]}\" ]; then break; fi\n        done\n     \
    \   for ((j = i+1; j <= ${#unique}; j++)); do\n            if [ -z \"${unique[$j]}\"\
    \ ]; then break; fi\n        done\n        for ((k = j+1; k <= ${#unique}; k++));\
    \ do\n            if [[ \"${unique[$i]}\" == \"${unique[$j]}\" && \"${unique[$i]}\"\
    \ == \"${unique[$k]}\" ]]; then\n                unique+=\" ${unique[$k]}\"\n\
    \            fi\n        done\n    done\n    echo $unique", "    local x y z\n\
    \    for x in \"$1\"; do \n        y=()\n        for z in \"$2\"; do\n       \
    \     [[ $z =~ $x ]] && y+=(\"$z\")\n        done\n        echo \"${y[*]}\"\n\
    \    done", "    local a=\"$(echo \"$1\" | sed -e 's/[[:space:]]/ /g' | sort -u)\"\
    \n    local b=\"$(echo \"$2\" | sed -e 's/[[:space:]]/ /g' | sort -u)\"\n    echo\
    \ \"$a $b\"", "  declare -a list1\n  declare -a list2\n  list1=($1)\n  list2=($2)\n\
    \  declare -i i\n  declare -a result\n  result=()\n  for ((i=0; i<${#list1[*]};\
    \ i++)); do\n    while [ ${#list1[$i]} -eq 0 ]; do list1[$i]=\"$(printf '%s' \"\
    ${list1[@]:$i}\")\"; done\n    while [ ${#list2[$i]} -eq 0 ]; do list2[$i]=\"\
    $(printf '%s' \"${list2[@]:$i}\")\"; done\n    case \"${list1[$i]}\" in\n    \
    \  \"${list2[$i]}\" ) result+=(\"${list1[$i]}\") ;;\n      * ) ;;\n    esac\n\
    \  done\n  printf '%s\\n' \"${result[*]}\"", "  IFS=' ' read -a a < <(sort -u\
    \ <<< \"$1\")\n  IFS=' ' read -a b < <(sort -u <<< \"$2\")\n  comm -12 4 \"${a[@]}\"\
    \ \"${b[@]}\" | cut -d ' ' -f 1,2 | sort -u", "\tlocal common=$1; shift; shift;\n\
    \tlocal common2=$1; shift; shift;\n\tcomm -23 <(sort -u $common) <(sort -u $common2)\
    \ > /dev/null;", "\tlocal common=\"\"\n\tlocal common_count=0\n\tlocal x\n\tlocal\
    \ y\n\tlocal z\n\tlocal line\n\tlocal count\n\twhile read line; do\n\t\tcommon_count=$(($common_count\
    \ + 1))\n\t\tx=\"${line%$2}\"\n\t\ty=\"${line#$1}\"\n\t\tz=\"${y#$x}\"\n\t\tif\
    \ [[ $common_count -gt 0 && $common_count -ge $((${#x}+${#y})) ]]; then\n\t\t\t\
    common=\"$common$z\"\n\t\tfi\n\tdone <<< \"$1\"\n\techo \"$common\"", "    # Sort\
    \ lists to make matching easier\n    sort -t ' ' \"$2\" > \"$2\".sorted\n    sort\
    \ -t ' ' \"$1\" > \"$1\".sorted\n\n    comm -23 \"$1.sorted\" \"$2.sorted\" >\
    \ \"$2.sorted\"\n    comm -23 \"$2.sorted\" \"$1.sorted\" > \"$1.sorted\"\n\n\
    \    comm -3 \"$1.sorted\" \"$2.sorted\"", "    local IFS=\"$1\"\n    local SEP=\"\
    $2\"\n\n    # sort both lists\n    local LIST1=\"$1\"\n    local LIST2=\"$2\"\n\
    \    sort -T \"${TEMPDIR}/common\" \"$LIST1\" > \"$TEMPDIR/LIST1\"\n    sort -T\
    \ \"${TEMPDIR}/common\" \"$LIST2\" >> \"$TEMPDIR/LIST2\"\n\n    # remove common\
    \ elements\n    while read A B; do\n        grep -q \"$B\" \"$TEMPDIR/LIST1\"\
    \ || echo \"$A\"\n    done < \"$TEMPDIR/LIST2\"\n\n    # remove duplicates\n \
    \   sort -T \"${TEMPDIR}/common\" \"$LIST1\" | uniq > \"$TEMPDIR/LIST1\"\n   \
    \ sort -T \"${TEMPDIR}/common\" \"$LIST2\" | uniq > \"$TEMPDIR/LIST2\"", "   \
    \ set -a\n    local list_1 list_2 common_elems i\n    list_1=\"${1[*]}\"\n   \
    \ list_2=\"${2[*]}\"\n    common_elems=$(comm -2 -3 <(printf \"%s\\n\" \"$list_1\"\
    ) <(printf \"%s\\n\" \"$list_2\"))\n    set +a\n    echo \"${common_elems[*]}\"",
  "    local set_1 set_2 output re\n    local -r array=( )\n    IFS=$'\\n'\n    array_1=(\
    \ $( echo $1 | sed -e 's/[[:space:]]+/ /g' ) )\n    array_2=( $( echo $2 | sed\
    \ -e 's/[[:space:]]+/ /g' ) )\n    IFS=$' '\n    for set_1 in \"${array_1[@]}\"\
    ; do\n        for set_2 in \"${array_2[@]}\"; do\n            if [[ ${#set_1}\
    \ != ${#set_2} ]]; then\n                continue\n            fi\n          \
    \  for re in $(echo $set_1 $set_2 | sort -u | tr -s '[:blank:]' '\\n'); do\n \
    \               if [[ -z \"${array[$re]}\" ]]; then\n                    array[$re]=$set_1\n\
    \                elif [[ ${array[$re]} != $set_1 ]]; then\n                  \
    \  array[$re]=$set_2\n                fi\n            done\n        done\n   \
    \ done\n    for res in \"${!array[@]}\"; do\n        if [[ -n \"${array[$res]}\"\
    \ ]]; then\n            output+=( ${array[$res]} )\n        fi\n    done\n   \
    \ IFS=$SAVEIFS\n    echo \"${output[@]}\" | sort -u", "    awk '\n        BEGIN\
    \ {\n            for(i=1;i<=NF;i++) {\n                j=1;\n                while($i\
    \ in a[j]) {\n                    j++\n                }\n                a[j]=$i\n\
    \            }\n        }\n        END {\n            for(i=1;i<=NF;i++) {\n \
    \               if($i in a) {\n                    for(j=i+1;j<=NF;j++) {\n  \
    \                      if($j in a && a[j]>i) {\n                            a[j-1]=a[j]\n\
    \                        }\n                    }\n                    delete\
    \ a[i]\n                }\n            }\n            for(i in a) {\n        \
    \        print a[i]\n            }\n        }\n    '", "\tset -- $1 $2\n\tsort\
    \ -u $@ | tr -s ' ' '\\n' | grep '^$'", "  local list1=\"$1\" list2=\"$2\"\n \
    \ local common i=$(( ${#list1} - ${#list2} ))\n  # This loop takes into account\
    \ the tail of list1\n  # The tail of list1 can be less than the length of list2\n\
    \  # So it must be iterated through\n  while (( i < ${#list1} )); do\n    common=(\
    \ ${list1[$i]} ${common[@]} )\n    i=$(( i + 1 ))\n  done\n  echo \"${common[@]}\"",
  "\tlocal list1 list2\n\tlist1=\"${1:-}\"\n\tlist2=\"${2:-}\"\n\t# This awk is much\
    \ more robust than the grep approach below.\n\t# grep \"^$list1 \" <<<\"$list2\"\
    \ | grep -v \" $list1 \" | cut -d\"(\" -f2 | sort -u\n\t# This awk approach is\
    \ less robust than the grep approach below.\n\tawk \"\\$1 ~ /($list1)/ && \\$2\
    \ ~ /($list2)/ { print \\$0 }\" <<<\"$list2\" | sort -u", "    local i j k l m\
    \ n\n    k=$1\n    l=$2\n    IFS=' ' read -a m <<< $k\n    IFS=' ' read -a n <<<\
    \ $l\n    i=0 j=0 k=0\n    while (( i<${#m[@]} || j<${#n[@]} )) && [ ${#m[((k++))]}\
    \ -eq ${#n[((j++))]} ] ; do\n        (( j>=${#n[@]} )) && break\n        if [[\
    \ -z ${m[((k++))]} ]]; then\n            (( i++ ))\n        else\n           \
    \ (( m[k]=${m[((k))]} ))\n        fi\n    done\n    printf '\"%s\"' ${m[*]}",
  "    local common=`comm -12 <(sort -u \"$2\") <(sort -u \"$1\")`\n    sort -u <<<\
    \ \"$common\"", "    # Remove common elements. Order is not important\n    local\
    \ common=`echo ${1} | sed -e \"s/ /\\n/g\" | sort | uniq -u`\n    # Remove common\
    \ elements found in $2\n    local common2=`echo ${2} | sed -e \"s/ /\\n/g\" |\
    \ sort | uniq -u`\n    # Return first set after removing common elements\n   \
    \ echo $common | tr ' ' '\\n' | grep -F -w -f -\n\n    # Return second set after\
    \ removing common elements\n    echo $common2 | tr ' ' '\\n' | grep -F -w -f -",
  "    local IFS=$1\n    shift\n    local IFS2=$2\n    shift\n    set $1 $2\n    local\
    \ output\n    while [ -n \"$1\" ]\n    do\n        local element\n        element=$(echo\
    \ $1 | tr \" \" \"\\n\")\n        while [ -n \"$2\" ]\n        do\n          \
    \  if [ \"$element\" != \"$2\" ]\n            then\n                echo \"$element\"\
    \n            fi\n            element=$(echo $2 | tr \" \" \"\\n\")\n        done\n\
    \        shift\n    done", "  local sorted1\n  local sorted2\n  local output\n\
    \n  sorted1=$(echo $1 | tr ' ' '\\n' | sort -u)\n  sorted2=$(echo $2 | tr ' '\
    \ '\\n' | sort -u)\n  output=$(bc -l <<< \"($sorted1 $sorted2 |sort) |uniq -u\"\
    )\n  echo $(echo $output | tr ' ' '\\n' | sort -u)", '  sort -u $1 | sort -u $2',
  "    local list1 list2 common\n    list1=(\"$1\")\n    list2=(\"$2\")\n    common=()\n\
    \    for element in \"${list1[@]}\"; do\n        if ! [[ \"${list2[@]}\" =~ \"\
    $element\" ]]; then\n            common+=(\"$element\")\n        fi\n    done\n\
    \    echo \"${common[@]}\"", "    local list_1=\"$(IFS=$'\\n' xargs -0 echo \"\
    $1\")\"\n    local list_2=\"$(IFS=$'\\n' xargs -0 echo \"$2\")\"\n    comm -12\
    \ <(sort -u \"$list_1\") <(sort -u \"$list_2\")", "    local IFS=\n    local -n\
    \ list_1=$1; shift\n    local -n list_2=$1; shift\n    list_1=( $list_1 )\n  \
    \  list_2=( $list_2 )\n    local ret=()\n    for (( i=0; i < ${#list_1[*]}; i++\
    \ )); do\n        local e1=${list_1[i]}\n        local e2=${list_2[i]}\n     \
    \   if [[ \"${e1}\" == \"${e2}\"* ]]; then\n            ret+=( $e1 )\n       \
    \ fi\n    done\n    IFS=$SAVEIFS\n    echo \"${ret[@]}\"", "  sort <(echo \"$1\"\
    \ | tr ' ' ',') <(echo \"$2\" | tr ' ' ',') | sort -u | tr '\\n' ' '", "    local\
    \ list1=$1; shift\n    local list2=$1; shift\n    IFS=\" \"\n    local intersect\n\
    \    intersect=( \"${list1[@]}\" \\\n                 \"${list2[@]}\" )\n    local\
    \ sorted_intersect\n    sorted_intersect=( $(\n        IFS=\"$IFS\"\n        sort\
    \ -u <<<\"${intersect[@]}\"\n    ) )\n    echo \"${sorted_intersect[@]}\"", " \
    \  local x1 x2 y1 y2\n   x1=$(echo $1 | sed \"s/ $//g\" | tr -s \" \")\n   x2=$(echo\
    \ $2 | sed \"s/ $//g\" | tr -s \" \")\n   y1=$(echo $y1 | sed \"s/ $//g\" | tr\
    \ -s \" \")\n   y2=$(echo $y2 | sed \"s/ $//g\" | tr -s \" \")\n   x1=$(echo $x1\
    \ | tr -d '\\n')\n   x2=$(echo $x2 | tr -d '\\n')\n   y1=$(echo $y1 | tr -d '\\\
    n')\n   y2=$(echo $y2 | tr -d '\\n')\n   sort | uniq -d | xargs -n 1 -I {} bash\
    \ -c 'if [[ ! $y2 =~ $x1 ]]; then echo {}; fi'", "  local x y xx yy\n  local -i\
    \ index1 index2 len1 len2 len\n  xx=( ${2} )\n  yy=( ${1} )\n  index1=0\n  index2=0\n\
    \  len1=${#xx[@]}\n  len2=${#yy[@]}\n  while [ \"$index1\" -lt \"$len1\" -o \"\
    $index2\" -lt \"$len2\" ]\n  do\n    case \"${xx[$index1]}\" in\n      \"${yy[$index2]}\"\
    \ ) ;;\n        * )\n          if [ \"$index1\" -eq \"$index2\" ]; then\n    \
    \        xx[$index1]=\"${xx[$index1]} ${yy[$index2]}\"\n          else\n     \
    \       xx[$index1]=\"$(xx[$index1]) ${yy[$index2]}\"\n          fi\n        \
    \  index2=$(( index2 + 1 ))\n          ;;\n    esac\n    index1=$(( index1 + 1\
    \ ))\n  done\n  printf '%s\\n' \"${xx[@]}\"", "  local IFS=\"$1\"\n  local x=\"\
    $2\"\n  local sorted1=($(sort $IFS <<< $x))\n  local sorted2=($(sort $IFS <<<\
    \ $y))\n  for i in $(seq 0 $(echo $sorted1 | length) - 1 \\\n         && seq 0\
    \ $(echo $sorted2 | length) - 1)\n  do\n    echo \"$sorted1[$i]\" \"$sorted2[$i]\"\
    \n  done", "\tlocal i ilist common ilist_length\n\tilist=\"$1\"\n\tcommon=\"$2\"\
    \n\tilist_length=${#ilist[@]}\n\tfor ((i=0; i<${ilist_length}; i++)); do\n\t\t\
    [[ \"${common[i]}\" == \"${ilist[i]}\" ]] && continue\n\t\t((i == ilist_length\
    \ - 1)) && echo \"${common[@]}\"\n\tdone", "  local list1=$1\n  local list2=$2\n\
    \  local i i2 tmp\n  for (( i = 0; i<${#list1}; i++ )); do\n    for (( i2 = 0;\
    \ i2<${#list2}; i2++ )); do\n      [[ \"${list1}\" == \"${list2}\" ]] && { tmp=true;\
    \ break; }\n      [[ \"${list1}\" == \"${list2}\" ]]\n      [[ \"${list2}\" ==\
    \ \"${list1}\" ]]\n      [[ \"${list1}\" == \"${list2}\" ]]\n      [[ ${list1}\
    \ = \"${list2}\" ]] && { tmp=true; break; }\n      [[ ${list1} = \"${list2}\"\
    \ ]]\n      [[ ${list2} = \"${list1}\" ]]\n      [[ \"${list1}\" == \"${list2}\"\
    \ ]]\n      [[ ${list2} = \"${list1}\" ]]\n      [[ ${list1} == \"${list2}\" ]]\n\
    \      [[ ${list2} == \"${list1}\" ]]\n      [[ ${list1} == ${list2} ]]\n    \
    \  [[ ${list2} == ${list1} ]]\n      [[ ${list1} == ${list2} ]]\n      [[ ${list2}\
    \ == ${list1} ]]\n    done\n    [[ \"${tmp}\" == \"true\" ]] && return 0\n  done\n\
    \  echo \"${list1}\"", "\tlocal L1 L2\n\tL1=( $1 )\n\tL2=( $2 )\n\tunset IFS\n\
    \tIFS=$'\\n' read -u 3 -a L1 <<< \"${L1[@]}\"\n\tIFS=$'\\n' read -u 4 -a L2 <<<\
    \ \"${L2[@]}\"\n\tunset IFS\n\tsort -u \"${L1[@]}\" \"${L2[@]}\"", "    local\
    \ list1=\"$1\"\n    local list2=\"$2\"\n    local list_1 list_2 common_items items_1\
    \ items_2 i\n    list_1=(${(@s:; :)list1})\n    list_2=(${(@s:; :)list2})\n  \
    \  common_items=()\n    for (( i = 0; i < ${#list_1[@]}; i++ )); do\n        items_1=${list_1[$i]}\n\
    \        items_2=${list_2[$i]}\n        if [[ \"$items_1\" == \"$items_2\" ]];\
    \ then\n            common_items+=(\"$items_1\")\n        fi\n    done\n    echo\
    \ \"${common_items[*]}\"", "    IFS=\" \"\n    set -- $1 $2\n    local common=()\n\
    \    while [[ $1 ]]; do\n        local x\n        for ((x=$2; (($#) > 1); x--));\
    \ do\n            if [[ $1 == ${common[$x]} ]]; then\n                common=(${common[@]/$x})\n\
    \                break\n            fi\n        done\n        common+=(\"$1\"\
    )\n        shift\n    done\n    echo \"${common[@]}\"", "\tlocal common=$1\n\t\
    shift\n\tlocal list2=$*\n\tlocal res=()\n\twhile read elem1; do\n\t\tif ! $(echo\
    \ $list2 | grep -E \"^$elem1$\"); then\n\t\t\tcontinue\n\t\tfi\n\t\tlocal common=$common\"\
    |\"$elem1\n\tdone < <(echo \"$common\")\n\tIFS=\"$IFS|\" read -rd '' -a elements\
    \ <<<\"${common#*\\|}\"\n\tIFS=\"$IFS$IFS\" # restore the previous IFS value\n\
    \tprintf '%s\\n' \"${elements[@]}\"", "  local common\n  local -n l1=()\n  local\
    \ -n l2=()\n  local i\n  read -a l1 <<<\"$1\"\n  read -a l2 <<<\"$2\"\n  unset\
    \ -v common\n  for ((i=0; i<${#l1[*]}; i++)); do\n    [[ -z ${common[*]} ]] \\\
    \n      && [[ \"${l1[$i]}\" != \"${l2[[i]]}\" ]]\n      && common+=(${l1[$i]})\n\
    \  done\n  IFS=$' \\t\\n'\n  echo \"${common[@]}\"", "    local _common=$1\n \
    \   local _list=$2\n    local _out\n    _out=$(_find \"${_list[@]}\" -type f -printf\
    \ \"$(printf '\\n' | sort -u)\" |\n        sort -u |\n        awk 'BEGIN { n=0\
    \ } { if ( !($1 in a) ) a[$1]++ ; if ( !($2 in a) ) a[$2]++ ; n++ }\n        \
    \        END { for (key in a) if ( a[key] == n ) print key }')\n    echo \"$(_quote\
    \ \"$_common\")\"", "  local i j\n  local set1=( $( echo \"$1\" | tr ' ' '\\n'\
    \ ) )\n  local set2=( $( echo \"$2\" | tr ' ' '\\n' ) )\n  local common=()\n \
    \ local count1=${#set1[*]}\n  local count2=${#set2[*]}\n  if [[ ${count1} -gt\
    \ ${count2} ]]; then\n    for ((i=1; i<=${count2}; i++))\n    do\n      common+=(\
    \ ${set1[$i]} )\n    done\n  else\n    for ((i=1; i<=${count1}; i++))\n    do\n\
    \      common+=( ${set2[$i]} )\n    done\n  fi\n  echo \"${common[@]}\"", "  \
    \  local f=$1; shift; shift\n    echo \"$(fgrep -v '^ *\\\"$' $2 | sort -u):$(fgrep\
    \ -v '^ *\\\"$' $1 | sort -u)\" | sed \"s/:$//\"", "  # shellcheck disable=SC2230\n\
    \  local first second result\n  first=\"$1\"\n  second=\"$2\"\n  result=$(\n \
    \   comm -3 <(sort <<<\"$first\") <(sort <<<\"$second\") |\n    awk '\n      BEGIN{\n\
    \        first=1;\n        second=1;\n      }\n      {\n        if (first && second)\
    \ {\n          print \">\";\n          first=second=1;\n        }\n        if\
    \ ($1==$2) {\n          print \"$2\"\n          result=\"\";\n          next\n\
    \        }\n        if (first) {\n          first=1;\n          print \"$1\"\n\
    \        }\n        if (second) {\n          second=1;\n          print \"$2\"\
    \n        }\n      }\n      '\n  )\n  echo \"$result\"", "  comm -3 -2 -3 <(sort\
    \ -u $1) <(sort -u $2) | sort -u | tr '\\n' '|'", "\tlocal list1=($1)\n\tlocal\
    \ list2=($2)\n\tlocal i common\n\tlocal length1\n\tlocal length2\n\tlocal index\n\
    \tlocal list1_index\n\tlocal list2_index\n\n\tindex=0\n\tlist1_index=()\n\tlist2_index=()\n\
    \n\twhile [ \"$index\" -lt \"$#list1\" ]; do\n\t\tlist1_index[${index}]=$i\n\t\
    \ti=$(( i + 1 ))\n\t\tindex=$(( index + 1 ))\n\tdone\n\n\tindex=0\n\twhile [ \"\
    $index\" -lt \"$#list2\" ]; do\n\t\tlist2_index[${index}]=$i\n\t\ti=$(( i + 1\
    \ ))\n\t\tindex=$(( index + 1 ))\n\tdone\n\n\twhile [ \"$index\" -lt \"$#list1\"\
    \ ]; do\n\t\tlist1_index[$index]=\"$list1[$list1_index[$index]]\"\n\t\tindex=$((\
    \ index + 1 ))\n\tdone\n\n\twhile [ \"$index\" -lt \"$#list2\" ]; do\n\t\tlist2_index[$index]=\"\
    $list2[$list2_index[$index]]\"\n\t\tindex=$(( index + 1 ))\n\tdone\n\n\twhile\
    \ true; do\n\t\tif [ \"$index\" -eq \"$#list1\" ]; then\n\t\t\tcommon+=( \"$list1_index[@]\"\
    \ )\n\t\t\tbreak\n\t\tfi\n\t\tif [ \"$index\" -eq \"$#list2\" ]; then\n\t\t\t\
    common+=( \"$list2_index[@]\" )\n\t\t\tbreak\n\t\tfi\n\t\tif [ \"${list1_index[$index]}\"\
    \ -ne \"${list2_index[$index]}\" ]; then\n\t\t\tcommon+=( \"$list1_index[$index]\"\
    \ )\n\t\t\tindex=$(( index + 1 ))\n\t\telse\n\t\t\tindex=$(( index + 1 ))\n\t\t\
    fi\n\tdone", "    sort -u \\\n        <( echo $1 ) <( echo $2 )", "    local -a\
    \ a1 a2 a3 a4 a5 a6\n    local -a b1 b2 b3 b4 b5 b6\n    local i j k\n    local\
    \ ret=()\n\n    # Parse two lists to arrays of integer elements\n    while [ $#\
    \ -gt 0 ]; do\n        case \"$1\" in\n            -*) break;;\n            --)\
    \ shift; break;;\n            *) a1+=( \"$1\" ); shift ;;\n        esac\n    done\n\
    \    while [ $# -gt 0 ]; do\n        case \"$1\" in\n            -*) break;;\n\
    \            --) shift; break;;\n            *) a2+=( \"$1\" ); shift ;;\n   \
    \     esac\n    done\n\n    # Parse two lists to arrays of integer elements\n\
    \    while [ $# -gt 0 ]; do\n        case \"$1\" in\n            -*) break;;\n\
    \            --) shift; break;;\n            *) a3+=( \"$1\" ); shift ;;\n   \
    \     esac\n    done\n    while [ $# -gt 0 ]; do\n        case \"$1\" in\n   \
    \         -*) break;;\n            --) shift; break;;\n            *) a4+=( \"\
    $1\" ); shift ;;\n        esac\n    done\n    while [ $# -gt 0 ]; do\n       \
    \ case \"$1\" in\n            -*) break;;\n            --) shift; break;;\n  \
    \          *) a5+=( \"$1\" ); shift ;;\n        esac\n    done\n    while [ $#\
    \ -gt 0 ]; do\n        case \"$1\" in\n            -*) break;;\n            --)\
    \ shift; break;;\n            *) a6+=( \"$1\" ); shift ;;\n        esac\n    done\n\
    \n    # Sort arrays\n    a1=( \"${a1[@]}\" )\n    a2=( \"${a2[@]}\" )\n    a3=(\
    \ \"${a3[@]}\" )\n    a4=( \"${a4[@]}\" )\n    a5=( \"${a5[@]}\" )\n    a6=( \"\
    ${a6[@]}\" )\n    a1=( \"${a1[@]}\" | sort -u )\n    a2=( \"${a2[@]}\" | sort\
    \ -u )\n    a3=( \"${a3[@]}\" | sort -u )\n    a4=( \"${a4[@]}\" | sort -u )\n\
    \    a5=( \"${a5[@]}\" | sort -u )\n    a6=( \"${a6[@]}\" | sort -u )\n\n    #\
    \ Find the common element", "  local -r array_sorted=( $(sort --unique \"$1\"\
    ) )\n  local -r array_sorted2=( $(sort --unique \"$2\") )\n  local ret=\"\"\n\n\
    \  for i in \"${!array_sorted[@]}\"; do\n    found=0\n    for j in \"${!array_sorted2[@]}\"\
    ; do\n      case \"${array_sorted[i]}\" in\n        \"${array_sorted2[j]}\" )\
    \ found=1;;\n      esac\n    done\n    if ! ((found)) ; then\n      ret=\"${ret}\
    \ ${array_sorted[i]}\"\n    fi\n  done\n\n  echo \"${ret}\"", "    local common=\"\
    $2\"\n\n    local list1=\"$1\"\n    local list2=\"$2\"\n\n    set $list1\n   \
    \ set $list2\n    sort -u -k 1 -o $common\n", "    local list_1 list_2\n\n   \
    \ list_1=$1\n    list_2=$2\n\n    # Filter out empty lines from lists\n    list_1=$(\
    \ echo \"${list_1//$'\\n'/ }\" )\n    list_2=$( echo \"${list_2//$'\\n'/ }\" )\n\
    \n    # Sort lists for easy comparison with uniq\n    list_1=$(echo \"${list_1//\
    \ }\" | sort -u)\n    list_2=$(echo \"${list_2// }\" | sort -u)\n\n    # Strip\
    \ off quotation marks and whitespace\n    list_1=$(echo \"${list_1//\\\"/ }\"\
    \ | tr -d '\\\"')\n    list_2=$(echo \"${list_2//\\\"/ }\" | tr -d '\\\"')\n\n\
    \    # Strip off leading/trailing spaces and duplicates\n    list_1=$(echo \"\
    ${list_1//$'\\ '/ }\" | sort -u)\n    list_2=$(echo \"${list_2//$'\\ '/ }\" |\
    \ sort -u)\n\n    # Strip off leading/trailing whitespace and duplicates\n   \
    \ list_1=$(echo \"${list_1//$'\\n'/ }\" | sort -u)\n    list_2=$(echo \"${list_2//$'\\\
    n'/ }\" | sort -u)\n\n    # Strip off any leading/trailing whitespaces\n    list_1=$(echo\
    \ \"${list_1//$'\\ '/ }\" | sort -u)\n    list_2=$(echo \"${list_2//$'\\ '/ }\"\
    \ | sort -u)\n\n    # Return unique sorted results\n    echo \"${list_1}\"\n \
    \   echo \"${list_2}\"", "    local i j\n    IFS=$'\\n' read -a a <\"$1\" ; IFS=$'\\\
    n' read -a b <\"$2\" ; unset IFS\n    for((i=0; i<${#a[@]}; i++)); do\n      \
    \  for((j=0; j<${#b[@]}; j++)); do\n            [ \"${a[i]}${b[j]}\" ] && break\n\
    \        done\n        [ \"${b[j]}\" ] && break\n        echo -n \"${a[i]}\" ;\
    \ done", "  local common_list\n  common_list=$(cat -n <<< \"$2 $1\" | sort -n\
    \ | uniq -u) \n  echo \"$common_list\"", "    local common_list\n    common_list=\"\
    $1\"\n    for arg2 in \"$2\"; do\n        local arg2_list\n        arg2_list=\"\
    $arg2\"\n        local common_item\n        common_item=\"$(cat \"$common_list\"\
    \ | grep \"^$arg2_list$\" | sort | uniq | wc -l)\"\n        if [ \"$common_item\"\
    \ -eq 0 ]; then\n            # common_list=\"$arg2\\n\"\n            common_list=\"\
    $common_list\\n$arg2\"\n        fi\n    done\n    echo $common_list", "\tlocal\
    \ IFS= read -r -d '' -a list1 && read -r -d '' -a list2\n\tlocal i\n\tlocal j\n\
    \tlocal result\n\n\tsort -u <<<\"${list1[@]}\"\n\tsort -u <<<\"${list2[@]}\"\n\
    \tfor ((i=0; i < ${#list1[@]}; i++ )); do\n\t\tlet j=i+1\n\t\twhile [[ \"${list2[$j]}\"\
    \ != \"${list1[$i]}\" ]] && [[ $j != ${#list1[@]} ]] &&\n\t\tdo\n\t\t\tlist2[$j]=\"\
    ${list2[$j]}${list1[$i]}\"\n\t\t\tlet j+=1\n\t\tdone\n\tdone\n\tresult=( \"${list2[@]}\"\
    \ )\n\tprintf '%s\\n' \"${result[@]}\"", "    local list1=($(printf '%s\\n' \"\
    $@\" | sort -u))\n    local list2=($(printf '%s\\n' \"$@\" | sort -u))\n    printf\
    \ '%s\\n' \"${list1[@]}\" | grep -Fv \"${list2[@]}\"", "    local IFS=$1\n   \
    \ local RET\n    local -a a\n    local -a b\n    local n\n    local j\n    local\
    \ t\n    local k\n    local w\n    local i\n\n    # sort both lists to avoid unnecessary\
    \ comparisons\n    a=($(awk '{for(i=1;i<=NF;i++) a[i]=$i} END {print sort(a)}'\
    \ $2))\n    b=($(awk '{for(i=1;i<=NF;i++) b[i]=$i} END {print sort(b)}' $1))\n\
    \n    # count how many elements there are in both lists\n    n=length(a)\n   \
    \ n=length(b)\n    \n    # loop through both lists, keeping track of common elements\
    \ so\n    # we can build up the return array in one shot\n    RET=()\n    j=0\n\
    \    while [ $j -le $n ]; do\n        k=$(( j + n - 1 ))\n        if [ \"$k\"\
    \ -gt $n ]; then\n            k=$n\n        fi\n        t=$(a[k])\n        \n\
    \        # check if the next element is the same in both lists\n        w=(b[((j+1)-n)])\n\
    \        if [ \"$w\" == $t ]; then\n            # this element is the same in\
    \ both lists, so add it\n            RET+=($t)\n            j=$(( j + 1 ))\n \
    \       else\n            # this element is not in both lists, so skip it\n  \
    \          j=$(( j + 1 ))\n        fi\n    done\n\n    # sort the return array\n\
    \    sort -u -o ${IFS}${RET[0]}", "  local set_1=\"$1\" set_2=\"$2\"\n  local\
    \ list_1=() list_2=()\n  for element in $set_1; do\n    list_1+=($element)\n \
    \ done\n  for element in $set_2; do\n    list_2+=($element)\n  done\n  list_1=$(sort\
    \ <<< $list_1)\n  list_2=$(sort <<< $list_2)\n  echo \"${list_1[@]}\" | uniq -u",
  "  local i i2 i3 i4 i5 i6 i7 i8 i9\n  i2=${1:-\"1 4 3 34 653 2 5\"}\n  i3=${2:-\"\
    5 7 1 5 9 653 121\"}\n  i4=$(awk \"BEGIN{print \"${i2}\" \"${i3}\" | sort}; {print\
    \ $1}\")\n  for ((i5=0; i5<${#i4[@]}; i5++)); do\n    i6=${i4[${i5}]}\n    i7=${i4[${i5}+1]}\n\
    \    i8=$(echo \"${i6} ${i7}\" | tr -s ' ' | sort | uniq -d)\n    if [[ -z ${i8}\
    \ ]]; then\n      echo \"${i6}\"\n    fi\n  done", "    # Sort for stable results\n\
    \    sort -u --field-separator=$1 \"$2\" | sort -u", "\tlocal i ilist ilist1 ilist2\
    \ jlist jlist1 jlist2 tmp\n\tilist1=$1; ilist2=$2\n\tjlist1=$(echo $ilist1 | tr\
    \ -d ' '); jlist2=$(echo $ilist2 | tr -d ' ');\n\tilist1=($(echo $ilist1 | tr\
    \ ' ' '\\n' | sort -u));\n\tilist2=($(echo $ilist2 | tr ' ' '\\n' | sort -u));\n\
    \tfor ((i=0;i<${#ilist1[*]};i++)); do\n\t\t((tmp=${jlist1[i]}; jlist1[i]=${jlist2[i]};\
    \ jlist2[i]=${tmp}))\n\tdone\n\techo ${jlist1[*]}", "    local list_1 list_2\n\
    \    list_1=\"${@}\"\n    list_2=\"${list_1// /\\n}\"\n    list_2=\"${list_2//$'\\\
    n'/ \\n}\"\n    list_2=\"${list_2//$'\\t'/ \\t}\"\n    set -- $list_2\n    local\
    \ sorted_list_2\n    sorted_list_2=\"$(sort -u -- \"$1\")\"\n    echo \"${sorted_list_2//\
    \ /, }\"", "    local common common common_list\n    local i j k\n    local list1\
    \ list2 list3 list4 list5 list6\n    list1=$1; list2=$2\n    common=\"$(sort <<<\"\
    ${list1}\" <<<\"${list2}\" |\n            uniq -c |\n            sort -rn |\n\
    \            cut -d \" \" -f 2 |\n            tr '\\n' ' ')\"\n    common_list=\"\
    $(echo \"${common}\" |\n            sed -e 's/^ *//' -e 's/ *$//')\"\n    list3=\"\
    $(sort <<<\"${common_list}\" |\n            uniq -c |\n            sort -rn |\n\
    \            cut -d \" \" -f 1)\"\n    list4=\"$(echo \"${common_list}\" |\n \
    \           sed -e 's/^ *//' -e 's/ *$//')\"\n    list5=\"$(echo \"${list3}\"\
    \ |\n            sed -e 's/^ *//' -e 's/ *$//')\"\n    list6=\"$(echo \"${list4}\"\
    \ |\n            sed -e 's/^ *//' -e 's/ *$//')\"\n    echo \"${list5}\"\n   \
    \ echo \"${list6}\"", "    local a b i imax\n    read -a a <<< $1\n    read -a\
    \ b <<< $2\n    imax=${#a[@]}\n    for i in $(seq 0 $((imax - 1))); do\n     \
    \   if [ \"${a[i]}\" -eq \"${b[i]}\" ]; then\n            a=${a[@]:0:i}\n    \
    \        b=${b[@]:0:i}\n        fi\n    done\n    echo \"$a\"", "    set -f\n\
    \    local x y u\n    while IFS=\" \" read x y; do\n        [[ $x != $y ]] &&\
    \ [[ $x ]]\n        u+=(\"$x\")\n    done <<< \"$1 $2\"\n    set +f\n    echo\
    \ \"${u[@]}\"", "  local common\n  local i\n  local j\n  local len\n  local list_1\
    \ list_2\n  local common_list\n\n  list_1=\"$1\"\n  list_2=\"$2\"\n  len1=\"${#list_1}\"\
    \n  len2=\"${#list_2}\"\n  common=()\n  for ((i=0; i<len1; i++))\n  do\n    for\
    \ ((j=0; j<len2; j++))\n    do\n      if [ \"${list_1:$i:1}\" == \"${list_2:$j:1}\"\
    \ ]; then\n        common+=( \"${list_1:$i:1}\" )\n      fi\n    done\n  done\n\
    \  common_list=( \"${common[@]}\" )\n  echo \"${common_list[@]}\"", "  local -n\
    \ arr1=(\"$@\")\n  local -n arr2=(\"$@\")\n  IFS=\" \" read -a arr1 <<<\"$1\"\n\
    \  IFS=\" \" read -a arr2 <<<\"$2\"\n  comm -13 <(printf '%s\\n' \"${arr1[@]}\"\
    \ | sort -u) \\\n        <(printf '%s\\n' \"${arr2[@]}\" | sort -u)", "  local\
    \ list1 list2\n  list1=$1\n  list2=$2\n  local i j\n  local list\n  list=\n  for\
    \ ((i=0; i<${#list1}; i++)); do\n    for ((j=0; j<${#list2}; j++)); do\n     \
    \ if [[ \"$list1\" == \"${list2:$j:1}\" ]]; then\n        list=\"$list $list1:$i\"\
    \n        list1=\"${list1:$i:1}\"\n        break\n      fi\n    done\n  done\n\
    \  echo $list", "    local first_list\n    local second_list\n    local common_list\n\
    \    IFS=$'\\n'\n    first_list=$1\n    second_list=$2\n    common_list=\"$(comm\
    \ -2 -3 <(sort <<< \"$first_list\") <(sort <<< \"$second_list\"))\"", "  local\
    \ f1=(\"$@\")\n  local -a f2=(\"$@\")\n  local -a ret=()\n\n  local -a common=()\n\
    \  local -a last=()\n  local -a curr=()\n\n  for ((i=0; i<${#f1[@]}; i++)) ; do\n\
    \    local last=${f1[$i]}\n    local curr=${f2[$i]}\n\n    common=(\"${common[@]/$last/$curr}\"\
    )\n  done\n\n  echo \"${common[@]}\"", "\t# Split each argument on whitespace\n\
    \tlist_1=($($1))\n\tlist_2=($($2))\n\n\t# Sort lists, remove duplicate entries,\
    \ and sort\n\tlist_1=($(sort -u $list_1))\n\tlist_2=($(sort -u $list_2))\n\n\t\
    # Compare and output the differences\n\tfor i in \"${list_1[@]}\"; do\n\t\tif\
    \ [[ \"${list_2[i]}\" != \"${list_1[i]}\" ]]; then\n\t\t\techo \"$i\"\n\t\tfi\n\
    \tdone", "    local common\n    local -a a\n    local -a b\n    local IFS\n  \
    \  IFS=$' \\t\\n'\n\n    local l1=${#${1/*/ }}\n    local l2=${#${2/*/ }}\n\n\
    \    while [ $l1 != $l2 ]; do\n        a=( ${1//$2/$2} )\n        common=( \"\
    ${a[@]}\" )\n        b=( ${2//$2/$2} )\n        IFS=$' '\n        local sorted=(\
    \ \"${a[@]}\" )\n        sorted=( \"${sorted[@]}\" )\n        IFS=$IFS\n     \
    \   sort -u <<<\"$sorted\"\n    done\n\n    printf '%s\\n' \"${a[@]}\"", "   \
    \ comm -12 <(sort \"$1\") <(sort \"$2\") | sed 's/^[ \\t]*//'", "  IFS=\" \" read\
    \ -a LIST1 <<< \"$1\"\n  IFS=\" \" read -a LIST2 <<< \"$2\"\n  \n  # Create array\
    \ to hold unique elements common to both lists\n  declare -A UNION\n  \n  # Add\
    \ all unique elements to UNIQUE array\n  for element in \"${LIST1[@]}\"; do UNION[\"\
    $element\"]=1; done\n  for element in \"${LIST2[@]}\"; do UNION[\"$element\"]=1;\
    \ done\n  \n  # Remove duplicate elements\n  while [[ \"${#UNION[@]}\" > 0 ]];\
    \ do\n    element=\"${UNION[${#UNION[@]}-${1}]}\"\n    UNION[\"$element\"]=1\n\
    \  done\n  \n  # Return sorted unique elements\n  local output\n  for element\
    \ in \"${!UNION[@]}\"; do output+=\"\\\"$element\\\"\"; done\n  echo \"$output\"",
  "    local common=\"$1 $2\"\n    local sorted_common\n    sorted_common=$(sort -u\
    \ <<<\"$common\")\n    local uniqued_common\n    uniqued_common=$(sort <<<\"$sorted_common\"\
    )\n    echo \"$uniqued_common\"", "   set -- $1 $2\n   while [ \"$#\" -gt 0 ];\
    \ do\n      shift\n      if [ \"$1\" -eq \"$1\" ]; then\n         return 1\n \
    \     fi\n   done\n   return 0"]
stop_tokens:
- "\n}"
