name: HumanEval_28_concatenate
language: sh
prompt: "#!/bin/bash\n# Concatenate list of strings into a single string\n# >>> $(concatenate\
  \ \"\")\n# \"\"\n# >>> $(concatenate \"a b c\")\n# \"abc\"\n#\n# $1 is a space-separated\
  \ list\nconcatenate() {\n"
tests: "}\n\ncandidate() {\n    concatenate \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"x y z\") = \"xyz\" ]]\n\
  \    [[ $(candidate \"x y z w k\") = \"xyzwk\" ]]\n}\n\nrun_test"
completions: ["\tlocal res=\"\"\n\tfor i in $*; do\n\t\tres=\"${res} ${i}\"\n\tdone\n\
    \techo $res", "  local sep=\"$1\"; shift\n  printf \"$1\"\n  shift\n  while ((\
    \ \"$#\" )); do\n    printf \"$sep\"\n    printf \"$1\"\n    shift\n  done", '    local
    IFS="$1"; shift; printf "%s" "${@}"; echo', "    local STR=\"$1\"\n    shift\n\
    \    local IFS=\" \"\n    local str\n    str=\"$STR\"\n    while [ -n \"$STR\"\
    \ ]; do\n        str=\"$str${STR}\"\n        STR=\"${STR%\"$IFS\"}\"\n    done\n\
    \    echo \"$str\"", '  echo "${*// /}";', "  local delimiter=$1\n  shift\n  echo\
    \ \"$*\"", "  local IFS=\"$1\"\n  # The return value of this command should be\
    \ a single string. We\n  # use sed to remove all the leading and trailing whitespace.\n\
    \  echo \"$(sed 's/^[[:space:]]*//;s/[[:space:]]*$//' <<< \"$@\")\"", '  echo
    "${@:2}"', "    local sep=\"$1\"\n    shift\n    echo \"$*\" | sed \"s/$sep/,/g\"",
  '    echo "${@:1}"', '    echo "$1" | paste -sd ""', "  local arg=\"$1\"\n  shift\n\
    \  echo \"$arg\" | tr \"\\000\" \"\\n\" | tr -s \" \" | sed \"s/^ //\" | tr -s\
    \ \"\\n\"", "  local sep=$1 string\n  shift\n  local newstring\n  echo \"$string\"\
    \ | while read -r; do\n    string+=\" $REPLY\"\n  done\n  echo $string", "   \
    \ local outstr=\"\"\n    for el in ${1+\"$@\"}; do\n        outstr=\"${outstr}\
    \ $el\"\n    done\n    echo \"$outstr\"", "  local delimiter=\"$1\"\n  shift\n\
    \  echo \"${@,}\"", "  # Make sure that all strings are quoted properly\n  # (otherwise,\
    \ they will not be recognized as such.)\n  echo \"${!1}\" | tr \"\\t\" \"\\002\"",
  "  # The last component will always be empty\n  local lastComponent=\"\"\n  local\
    \ words=(\"${1}\")\n  local output=\"\"\n  local spaces=\"\"\n\n  # Loop over\
    \ the input words\n  for word in \"${words[@]}\"; do\n    # Don't append a space\
    \ to the last component\n    # unless it contains any existing spaces.\n    if\
    \ [ -z \"${lastComponent}\" ]; then\n      spaces=\"${spaces}\" # No spaces yet,\
    \ start a space\n    elif [ \"${lastComponent}\" != \" \" ]; then\n      # Append\
    \ a space if required\n      spaces=\"${spaces} \"\n    fi\n\n    # Add the word\
    \ if we haven't started a space yet\n    if [ -z \"${spaces}\" ]; then\n     \
    \ output=\"${output}${word}\"\n    else\n      output=\"${output}${spaces}${word}\"\
    \n    fi\n\n    lastComponent=\"${word}\"\n  done\n\n  echo \"${output}\"", " \
    \ local IFS=$1\n  shift\n  local S=\n  for var in \"$@\"\n  do\n    S=\"${S} $var\"\
    \n  done\n  echo ${S}", "\tlocal -a stringList=()\n\tlocal string stringResult=\"\
    \"\n\twhile [[ \"$#\" -gt 0 ]]; do\n\t\tstring=\"$1\"\n\t\tshift\n\t\tstringList+=(\
    \ \"$string\" )\n\tdone\n\tstringResult=\"${stringList[*]}\"\n\techo \"$stringResult\"",
  "    local IFS=$1\n    shift\n    echo \"$*\"", "  IFS=\"\n\"\n  echo \"${@:1}\"",
  "  local IFS=$1; shift\n  echo -n \"\" \"$@\" ", '  local IFS="$1"; shift; echo
    "$*"', "    local STRINGIFY=$1\n    shift\n    local CONCAT=$1\n    shift\n  \
    \  local STR=$1\n    shift\n    local IFS=$1\n    shift\n    while [ $# -gt 0\
    \ ]; do\n        STR=\"${CONCAT}${STR} $1\"\n        shift\n    done\n    echo\
    \ $STR", "  local arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12\n\
    \  local arg13\n  arg1=( $( shift; echo \"$@\" ) )\n  arg13=$(echo $arg1 | sed\
    \ -e 's/[ \\t][ \\t]*//g' | sed -e 's/[ \\t]*$//g')\n  arg2=$(echo $arg1 | sed\
    \ -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n  arg3=$(echo $arg1 | sed -e 's/^[ \\\
    t]*//g' -e 's/[ \\t]*$//g')\n  arg4=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[\
    \ \\t]*$//g')\n  arg5=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n\
    \  arg6=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n  arg7=$(echo\
    \ $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n  arg8=$(echo $arg1 | sed\
    \ -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n  arg9=$(echo $arg1 | sed -e 's/^[ \\\
    t]*//g' -e 's/[ \\t]*$//g')\n  arg10=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e\
    \ 's/[ \\t]*$//g')\n  arg11=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n\
    \  arg12=$(echo $arg1 | sed -e 's/^[ \\t]*//g' -e 's/[ \\t]*$//g')\n  echo \"\
    $arg13$arg2$arg3$arg4$arg5$arg6$arg7$arg8$arg9$arg10$arg11$arg12\"", "  local\
    \ IFS=$1\n  shift\n  echo -n \"${*// /}\" | tr \" \" \"${IFS}\"", "    local _args\n\
    \    _args=$(echo $@ | sed 's/ /,/g')\n    echo -n \"${_args[*]}\"", "  local\
    \ arg=\"$1\"\n  shift\n  echo \"$arg\" | sed -e 's/^/\"/' -e 's/$/\"/' -e 's/\
    \ /\\\n/'", "    IFS=$'\\n' read -r -d '' -a \"$@\" <<< \"${1[*]}\" | tr '\\n'\
    \ ' ' |\n    paste -sd ' ' -", "    local IFS=\"$1\"\n    echo \"${@:2}\" | tr\
    \ '\\0' \"$IFS\" | sed -e 's/'$IFS'//g'", "  local delimiter=\"${1}\"\n  shift\n\
    \  echo \"$(IFS=\" \"${delimiter}\" \"${@}\")\"", "    local items=$($(echo \"\
    $1\" | sed 's/ /\" \"$1\" \"/g'))\n    echo \"$items\"", "    local IFS=\"$1\"\
    \n    shift\n    echo \"$*\"", "    local sep=$1\n    shift\n    echo \"$*\"",
  "  local IFS=\"\n\"\n  echo \"${1#*$IFS}\"", "  local sep=\"$1\"\n  shift\n  local\
    \ str\n  str=\"$(printf \"%s\" \"$@\" | sed 's/[[:space:]]/'\"${sep}\"'/g')\"\n\
    \  echo \"$str\"", "    local IFS=\"$1\"\n    shift\n    echo \"$*\"", "  local\
    \ list=\"$1\"\n  shift\n  local result=\"\"\n  for word in $list; do\n    result=\"\
    ${result} $word\"\n  done\n  echo \"$result\"", "    local result=\"${1}\"\n \
    \   for e in \"${@:2}\"; do\n        result+=\" $e\"\n    done\n    echo \"$result\"",
  "\techo $(( $(( $(#${1}) )) ))", "    local newstr=\"\"\n    for i in $(cat $1)\n\
    \    do\n        newstr=$newstr$i\n    done\n    echo \"$newstr\"", "    local\
    \ str=\"$1\"\n    for var in \"$@\"\n    do\n        str=\"${str} ${var}\"\n \
    \   done\n    echo \"${str}\"", '  echo "${*}";', "    local x=\"$1\"\n    local\
    \ y\n    if [ $# -eq 0 ]; then\n        y=''\n    else\n        IFS=$'\\n'\n \
    \       y=\"$(IFS=\"\" echo \"$x\")\"\n    fi\n    echo \"$y\"", "\tlocal delimiter=$1\n\
    \tshift\n\techo -n \"\"\n\tfor var in \"$@\"; do\n\t\techo -n \"$delimiter$var\"\
    \n\tdone\n\techo", "  local item\n  for item in $1; do\n    echo $item\n  done",
  "    local tmp=${TMPDIR-/tmp}/$(basename $$).$$.tmp\n    touch ${tmp}\n    local\
    \ IFS\n    [[ \"${IFS}\" = \" \" ]] && IFS=\" \"\n    echo $(for item in ${@};\
    \ do echo \"${item}\"; done | tr \"\\n\" ${IFS}; echo $?) >&${tmp}\n    read -r\
    \ _ tmp < <(head -1 ${tmp})\n    rm -f ${tmp}", "  local var=\n  local IFS=\"\
    $1\"\n  for var in \"$@\"; do\n    echo \"$var\"\n  done", "  local arg\n  local\
    \ output\n  local IFS=\n  output=$(printf \"%s\\n\" \"${@:1}\")\n  IFS=$'\\n'\n\
    \  echo \"${output}\"", "  local IFS=\"$1\"\n  shift\n  echo \"$*\"", "    local\
    \ -a _out\n    _out+=\"$1\"\n    shift\n    for _item in \"$@\"; do\n        _out+=\"\
    \ $_item\"\n    done\n    eval \"echo \\$_out\"", "    # Remove first element\
    \ from list (if any) and then split\n    # remaining list into array elements\n\
    \    local string=\"${1:-}\"\n    string=\"${string#$1} $(echo \"$string\" | awk\
    \ '{ print $1 }')\"\n    # Return all elements in array\n    echo \"${string%\
    \ *}\"", "    local IFS=$1\n    shift\n    echo \"$*\"", "  local str\n  str=\"\
    \"\n  for str in \"$@\"; do\n    [ -z \"$str\" ] || [[ \"$str\" != \"$str\" ]]\
    \ || { echo \"Invalid input: expected a non-empty string\" >&2; exit 1; }\n  \
    \  str=\"$str\"$'\\n'\"$str\"\n  done\n  echo \"$str\"", "  # $1 can be a list\
    \ of multiple words, concatenate them all into single string\n  # $2 can be a\
    \ single string or nothing\n  cat \"${@:2}\" |\n  {\n    # $3 will hold the output\
    \ string\n    local OUTPUT=$3;\n    # Loop through each element of $1\n    local\
    \ ELEMENT;\n    for ELEMENT; do\n      # Append $ELEMENT onto the output\n   \
    \   OUTPUT=\"${OUTPUT} ${ELEMENT}\";\n    done\n    # Return the output\n    echo\
    \ \"${OUTPUT}\";\n  }", "    string=\"\"\n    for string in $@; do\n        echo\
    \ $string\n    done", '  echo "${*:2}"', "    local IFS=\"$1\"\n    shift\n  \
    \  echo \"$*\"", "  # Split $1 into separate strings\n  IFS=' ' read -r -a array\
    \ <<< \"$1\"\n  # Return joined strings\n  echo \"${array[@]}\"", "\tlocal arg1=$1\n\
    \tshift\n\n\tif [[ $arg1 ]]; then\n\t\tlocal arg1=$(echo \"$arg1\" | sed -e 's/^/\"\
    /' -e 's/$/\"/' -e 's/ /\"/' -e 's/;/\"/')\n\tfi\n\n\tlocal arg1=\"${arg1}\"\n\
    \n\tif [[ $arg1 ]]; then\n\t\techo \"${arg1} \"\n\telse\n\t\techo \"\"\n\tfi",
  "  # Concatenate list of strings into a single string\n  string=$1\n  shift\n  while\
    \ [ -n \"$1\" ]; do\n    string=\"${string} $1\"\n    shift\n  done\n  echo $string",
  "    local IFS=\"$1\"\n    shift\n    local str=\"\"\n    for str in \"$@\"; do\n\
    \        printf \"$str\"\n    done\n    printf \"$str\"", "    local str1=\"${1:-}\"\
    \n    shift\n    echo \"$str1\" \"$*\"", "  echo -n \"$1\"\n  shift\n  for arg;\
    \ do\n    echo \"$arg\"\n  done", "    local var=\"$*\"\n    shift\n    local\
    \ list=\"$*\"\n    shift\n    echo \"$list\"", "  local IFS=\"$1\"\n  shift\n\
    \  echo \"$*\"", "    local output=''\n    for string in \"$@\"\n    do\n    \
    \    output+=\"$string\"\n    done\n    echo \"$output\"", "    local list_var=$1\n\
    \    if [ -z \"$list_var\" ]; then\n        echo \"$list_var\"\n    else\n   \
    \     local list_var_split=$(echo $list_var | sed 's/\\( \\)\\(.*\\)\\(\\) /\\\
    1 /g')\n        local list_var_final_join=$(echo $list_var | sed 's/\\( \\)\\\
    (.*\\)/ \\1/g')\n        echo \"$list_var_final_join\"\n    fi", "    local delimiter=$1;\
    \ shift\n    IFS=$delimiter read -r -d '' -a \"$@\" || return\n    echo \"${a[*]}\"",
  "  local i\n  local list_string=\"$1\"\n  shift\n  local list_items\n  list_items=\"\
    $@\"\n  local list_length=${#list_items[@]}\n  local result=\"\"\n  for i in $(seq\
    \ 0 $(( $list_length - 1 )))\n  do\n    case \"${list_items[i]}\" in\n      \"\
    \") ;;\n      *) result=\"$list_string$result$list_items[i]\" ;;\n    esac\n \
    \ done\n  echo \"$result\"", "    local IFS=\" $1\"\n    echo \"$*\"", "  # We\
    \ use \"$@\" here rather than \"$1\" because we expect to be given a\n  # space-separated\
    \ list rather than a single argument with space-separated\n  # values.\n  local\
    \ str\n  str=\"\"\n  for e in $@; do\n    echo $str\n    str=$str$e\n  done\n\
    \  echo $str", "\tlocal list_separator=$1\n\tshift\n\techo -n \"\" | tr \" \"\
    \ \"${list_separator}\"\n\tfor item; do echo -n \"$item\"; done\n\techo \"\"",
  "    local list=$1\n    shift\n    echo \"$list\" \"$@\"", '  echo "$*"', "  # Check\
    \ for empty list\n  [[ -z \"${1}\" ]] && return\n  # Concatenate\n  local STR=\"\
    \"\n  local LIST=\"${1}\"\n  for STR in \"${LIST}\"; do\n    printf \"%s\" \"\
    ${STR}\"\n  done", "    local list_str=${1:-\"\"}\n    local str\n    str=\"\"\
    \n    while IFS= read -r line; do\n        str+=${line}\n    done <<<\"${list_str}\"\
    \n    echo \"${str}\"", "\tcat \"${@:1}\"", "  local IFS\n  IFS=$2\n  echo \"\
    $1\"", "  # Get rid of the extra spaces if passed a single string\n  test \"$#\"\
    \ -eq 1 && shift\n  local delimiter=$1\n  shift\n  # $@ is a list of strings\n\
    \  echo $(echo $@ | sed \"s/$delimiter/\\ /g\")", "  local _concat_args=\"$1\"\
    \n  # _concat_args=\"$@\" # uncomment this line to allow for variable number of\
    \ arguments\n  local arg\n  for arg in $(_concat_args); do\n    if [[ -z $1 ]];\
    \ then\n      echo \"$arg\"\n    else\n      echo \"$arg $1\"\n    fi\n  done",
  "  # Concatenate the passed list\n  local list=\"$(echo \"$1\" | tr '[:upper:]'\
    \ '[:lower:]')\"\n  # Remove spaces around the list\n  list=\"${list// /}\"\n\
    \  # Replace multiple spaces with single space\n  list=\"${list//+/ }\"\n  # Strip\
    \ leading and trailing space\n  echo \"${list}\" | sed 's/^[ \\t]*//;s/[ \\t]*$//'",
  "\tprintf '%s\\n' \"${1// }\" | paste -sd ' '", "  echo \"$1\"\n  shift\n  if [[\
    \ \"$#\" -eq 0 ]]; then\n    echo \"\"\n  else\n    echo $1 $( concatenate \"\
    $@\" )\n  fi", "  local IFS=\"$1\"\n  shift\n  echo -n \"$*\"", "    local sep\
    \ result\n    sep=$1\n    shift\n    result=$(printf \"%s\" \"${@}\")\n    printf\
    \ \"%s\" \"${result%\"$sep\"}\"$sep", "  local IFS=\"$1\"\n  shift\n  echo \"\
    $*\"", "  local IFS='\n'\n  echo \"${1}\"", "\techo \"${@// /\\\\ }\"", "    local\
    \ IFS=' '\n    local i=1\n    local string=\"\"\n    for string in $(echo $1 |\
    \ sed 's/ /\\n/g'); do\n        echo \"$string\"\n    done", "    # Split $1 into\
    \ multiple strings\n    # Using -0 here as -n 1 might not split $1 into one string\n\
    \    local strings=( -0 \"$1\" )\n\n    # Concatenate all strings in the array\n\
    \    # Piping into tr will remove newlines, and echo will add one\n    # See https://linux.die.net/man/1/tr\
    \ for tr options\n    # | with echo will cause the output to have a trailing newline\n\
    \    # | with tr is more readable\n    # See https://mywiki.wooledge.org/BashFAQ/002\
    \ for bash array manipulation\n    # See https://mywiki.wooledge.org/BashGuide/Arrays\
    \ for bash array tutorial\n    echo \"${strings[*]}\" | tr '\\n' '\\0' | xargs\
    \ -0 echo", "  local list=\"$1\"\n  local out=\"$2\"\n  # If the list is a single\
    \ item, return it as-is\n  if [ \"$list\" == \"$list\" ]; then\n    echo \"$list\"\
    \n    return\n  fi\n  # If the list has more than one item, join them with spaces\
    \ to get a single string\n  # >>> $(concatenate \"a b c\" \"\")\n  # \"a b c\"\
    \n  # >>> $(concatenate \"a b c\" \" d e\")\n  # \"a b c d e\"\n  echo \"$out\"\
    \n  while IFS= read -r item; do\n    echo \"$item $list\"\n  done < <(printf %s\
    \ \"$list\")", "    local -a strings=(\"${@}\")\n    echo \"${strings[*]}\"",
  "    local ret\n    IFS=\" \" read -r -a array <<< \"$1\"\n    shift\n    printf\
    \ \"%s\" \"${array[@]}\"", "    local string\n    string=\"\"\n    string=\"${!1}\"\
    \n    string=\"${string}${!2}\"\n    string=\"${string}${!3}\"\n    string=\"\
    ${string}${!4}\"\n    echo \"${string}\"", "  local result\n  result=''\n  while\
    \ IFS= read -r -n 1 line; do\n    result+=( $line )\n  done\n  printf '%s' \"\
    ${result[@]}\" >&2", "    local arg\n    for arg; do\n        printf \"%s\" \"\
    $arg\"\n    done", "\tlocal args=$(join \" \" \"$@\")\n\techo \"$args\"", "  \
    \  local IFS=\" $1\"\n    shift\n    echo \"$*\"", "  echo $1 | sed -e 's/ /\\\
    n/g' | tr '\\n' ' '", "    local SEPARATOR=$1\n    shift\n    echo $* | sed -e\
    \ \"s/ /$SEPARATOR/g\"", "  local output\n  output=\"${1}\"\n  # concatenate will\
    \ always have a trailing separator\n  # so if there are no strings, return output\
    \ unchanged\n  if [[ \"${output}\" == *\"$1\"* ]]; then\n    output=\"${output}$2\"\
    \n  fi\n  echo \"${output}\"", "    IFS=\" $1\"\n    echo \"$2\"", "  local _list=\"\
    ${1# }\"\n  echo \"$*\"", "  local arg\n  echo \"${*:1}\"", '    echo "$*"', " \
    \ local sep str\n  local ret\n  sep=\"${1:+$1:-}\"\n  str=\"${*:-}\"\n  printf\
    \ \"%s\" \"$sep\"\n  printf \"%s\" \"${str// /$sep}\"\n  printf \"%s\" \"$sep\"",
  "  local IFS=\"$1\"\n  shift\n  echo \"$*\"", "  local list=\"$1\"\n  local line=\"\
    \"\n  while read -r line; do\n    list+=\" $line\"\n  done\n  echo \"${list}\"",
  "    local arg1 arg2 result\n    while [ $# -gt 0 ]; do\n        arg1=$1\n     \
    \   arg2=$2\n        shift 2\n        result=$arg\"$1\"\"$2\"\n        shift\n\
    \        arg1=$arg1\n        arg2=$arg2\n    done\n    echo \"$result\"", "  local\
    \ _ret=0\n  local i\n  for i in $*; do\n    eval _ret=\"'$_i'\"\n  done\n  echo\
    \ $_ret", "    local IFS=$1\n    echo \"$*\"", "    IFS=\" \"\n    local ret=${1:-\"\
    ()\"}\n    echo \"${@:${#ret}}\" # replace with spaces only", "  local IFS=\n\
    \  echo \"$*\" | sed -e \"s/^/${1:-}/\" -e \"s/$/\\$@/\" -e \"s/$/\\n/\" -e \"\
    s/$/\\\\$IFS/\" -e", "  local sep string\n  sep=$1\n  shift\n  string=\n  for\
    \ ((i = 0; i < ${#1}; i++)); do\n    string+=${1}${sep}\n    shift\n  done\n \
    \ echo $string", "    # concatenate $1 with an empty string\n    # return \"\"\
    \ $1\n    local c=$1\n    shift\n    local s=\"\"\n    for arg; do\n        s=\"\
    $s $arg\"\n    done\n    echo $s", "    local -n list=\"$1\" out=\"$2\"\n    shift\
    \ 2\n    for item; do\n        printf \"%s\" \"$out${item// /$'\\n'}\" \n    done",
  "    echo $1 | tr ' ' \"\\n\" | paste -sd '|'", "\tlocal vars=$1\n\tshift\n\techo\
    \ -n \"\"\n\tfor i in $vars\n\tdo\n\t\techo -n \"$i\"\n\tdone\n\techo \"\"", '    echo
    "$*" | xargs', "    local STRING\n    local STR\n    local LIST\n    local STRL\n\
    \    STRING=\"$1\"\n    LIST=\"${STRING//[![:space:]]/ }\"\n    STRL=\"$(echo\
    \ \"${LIST}\" | sed -e 's/ /\\\\ /g')\"\n    echo \"${STRL}\"", "  local arg\n\
    \  local IFS=$1\n\n  arg=\"\"\n  for arg in \"$@\"; do\n    echo $arg\n  done",
  "\tlocal result=\"\"\n\tfor var in \"$@\" ; do\n\t\tresult+=$var\n\tdone\n\techo\
    \ \"$result\"", "    local arg\n    for arg in \"$@\"; do\n        echo \"$arg\"\
    \n    done", "    local tmp=\"\"\n    local tmp2=\"\"\n    for ((i=0; i < $#;\
    \ i++))\n    do\n        tmp=$tmp$(iw* $i)\n        tmp2=$tmp2$(iw* $i)\n    done\n\
    \    echo $tmp2", "  local arg\n  local str=\"$1\"\n  local sep=\"$2\"\n  [[ -z\
    \ \"$str\" ]] && return 0\n  [[ -z \"$sep\" ]] && sep =\n  for arg; do\n    [[\
    \ -z \"$str\" ]] && return 0\n    echo \"$str$sep$arg\"\n    str=\"$arg\"\n  done",
  "  IFS=\" $\"\n  echo \"${*}\"", "  local IFS=\"$1\"\n  shift\n  local str\n  str=$(IFS=\"\
    $IFS\" \"$@\")\n  echo \"$str\"", "    IFS=\" \" read -a args <<< \"$1\"\n   \
    \ echo \"${args[*]}\"", "  string=\"\"\n  while (( $# > 0 )); do\n    string=\"\
    $string $1\"\n    shift\n  done\n  echo $string", "    # Escape the string\n \
    \   echo \"${1//\\\"}\"", "  local str\n  str=$( IFS=\" \"; echo \"$*\" )\n  echo\
    \ \"$str\"", "  local IFS=\" \"\n  local result\n  for item in \"$1\"\n  do\n\
    \    result=\"${result}${item}\"\n  done\n  echo \"$result\"", "    local IFS=\n\
    \    local result=\"\"\n    for var in \"$@\"; do\n        result+=\"$var\"\n\
    \    done\n    echo \"$result\"", "  string=\"$1\"\n  for string in \"$@\"; do\n\
    \    echo \"$string\"\n  done", "    echo \"${*}\" | tr '\\n' '\\0' | tr '\\0'\
    \ ' '", "  local arg\n  local list\n  local argcount\n  list=\"$1\"\n  argcount=$((${#list}\
    \ + 0))\n  while (( $argcount > 0 )); do\n    arg=\"$(basename ${list})\"\n  \
    \  echo \"${list} \"\n    list=\"${list#*$arg}\"\n    list=\"${list%% *}\"\n \
    \   argcount=$((${#list} + 0))\n  done\n  echo \"${list}\"", "    local string=\"\
    $1\"\n    if [ -z \"$string\" ]; then\n        string=\"\"\n    fi\n    local\
    \ string=\"$string\"\n    shift\n    while [ $# -gt 0 ]\n    do\n        string=\"\
    $string $1\"\n        shift\n    done\n    echo \"$string\"", "    local IFS=\"\
    $1\"\n    echo \"$*\"", "    local IFS=\"$1\"\n    echo \"${*:2}\"", '  local
    IFS="$1"; shift; echo "$*"; unset IFS', "    local sep str=\"$1\"\n    local i\
    \ output\n    sep=\"$(printf \" %s\" \"${sep, ,}\")\"\n    for ((i=1;i<$#;i++));\
    \ do\n        output+=\"$(printf \"$sep%s\" \"${!i}\")\"\n    done\n    echo \"\
    $output\"", "  local item\n  echo \"$1\" | sed \"s/^\\(.\\+\\)/\\1 /g\"", "  \
    \  local output=\"\"\n    for element in $1; do\n        output=\"${output} ${element}\"\
    \n    done\n    echo \"${output}\"", "  local IFS=\"$1\"\n  local cmd=\"${@:2}\"\
    \n  echo \"$(IFS=\"$IFS\" printf '%s' \"$cmd\" | paste -s -d' ')\"", "    local\
    \ IFS=\" \"\n    echo ${@:1}", "    # Concatenate the list into one single string\n\
    \    local -r list_name=\"$1\"\n    # Do not use `+=`, it's buggy with `sh`.\n\
    \    eval \"$list_name=\\\"\\${$list_name}\\\"\"\n    echo \"$list_name\"", " \
    \ local x=\"$1\"\n  shift\n  echo \"$x$( IFS=$'\\n'; echo \"$@\" )\"", "  cat\
    \ <<EOF\n${*:1}\nEOF", "  local sep str\n  sep=\"$1\"; shift\n  str=\"$*\"\n \
    \ echo \"$str\" | sed \"s/ $sep /${sep}$sep/g\"", "    local IFS=\"$1\"\n    echo\
    \ \"$*\"", "  local IFS=$1; shift\n  echo \"$*\"", "  local sep x\n  sep=$1\n\
    \  shift\n  x=\"$*\"\n  [[ $x = $sep ]] || return 1\n  echo \"$x\"", '  echo "$*"
    | tr "\n" " "', "    local IFS=\"$1\"\n    # http://stackoverflow.com/a/1933571/1717148\n\
    \    local result\n    for var in \"$@\"; do\n        result=\"$result$var\"\n\
    \    done\n    echo \"$result\"", "    IFS=\" \" read -ra args <<< \"$1\"\n  \
    \  echo \"${args[*]}\"", "  local result=\n  # This loop will terminate when unset\
    \ $1\n  for var in \"$@\" ; do\n    if [[ -n $result ]]; then\n      # Concatenate\
    \ the new string to the existing string\n      result+=\" $var\"\n    else\n \
    \     # If there are no more strings in the list, just assign the list to result\n\
    \      result=\"$var\"\n    fi\n  done\n  echo \"$result\"", "    local result=\"\
    \"\n    for i in $(cat $1 <<< \"$2\"); do\n        if [ $i ]; then result=\"$result$i\"\
    ; fi\n    done\n    echo \"$result\"", "  local IFS=$1\n  shift\n  echo \"${*}\"\
    \ | paste -s -d \"${IFS}\"", "    local result=\"$1\"\n    shift\n    for arg;\
    \ do\n        result=\"${result}${arg}\"\n    done\n    echo \"$result\"", " \
    \ local IFS=$1\n  shift\n  echo -n \"$*\"", "    local IFS=\"$1\"\n    shift\n\
    \    local LIST\n    for LIST; do\n      echo -n \"$LIST\"\n    done", "\tlocal\
    \ string\n\tstring=$(\"${@:2}\")\n\tlocal i space\n\ti=0\n\twhile [ \"$i\" -le\
    \ ${#string} ]; do\n\t\tspace=\"${string:$i:1}\"\n\t\tstring=$(\"${string/$space/\
    \ }\")\n\t\ti=$((i+1))\n\tdone\n\techo \"$string\"", "    local IFS=\"$1\"; shift\n\
    \    echo \"$*\"", "\techo -n \"${@:1}\"\n\tshift\n\tlocal NEWLINE=\"\"\n\tlocal\
    \ CONTENTS=\"\"\n\twhile [ $# -gt 0 ]\n\tdo\n\t\tCONTENTS+=\"$NEWLINE${1}\"\n\t\
    \tNEWLINE=\n\t\tshift\n\tdone\n\techo \"${CONTENTS}\"", "    local LIST=\"$1\"\
    \n    shift\n    echo \"${LIST// /$'\\n'}\"", "    local list=\"${1}\"\n    local\
    \ IFS=\"$IFS\"\n    IFS=\" \"\n    local result=\"$list\"\n    IFS=\"$IFS\"\n\
    \    echo \"$result\"", "  printf '%s' \"${*}\"", "  cat <<EOF\n${1+\"$1\"} #\
    \ $1 exists: $1 is a space-separated list\nEOF", "  local IFS=\" $1\"\n  local\
    \ IFS2=\" $2\"\n  local IFS3=\" $3\"\n\n  # $1 may contain special characters;\
    \ $2, $3 must be quoted\n  local CMD=\"$1\"\n  local CMD2=\"$2\"\n  local CMD3=\"\
    $3\"\n\n  while read LINE\n  do\n    if [ -z \"$IFS\" ]; then IFS=\" \"; fi\n\
    \    if [ -z \"$IFS2\" ]; then IFS2=\" \"; fi\n    if [ -z \"$IFS3\" ]; then IFS3=\"\
    \ \"; fi\n    echo $LINE\n  done <<< \"$CMD$IFS$CMD2$IFS$CMD3\"", "    local sep=${1:-\"\
    \ \"} # use space as default separator\n    shift\n    echo \"$sep\"\n    local\
    \ IFS=\"$sep\" ; for ((i=1 ; i<$#; i+=1)); do echo \"$1\" ; done", "    local\
    \ arg1 arg2 arg3 arg4\n    set $# # number of arguments\n    local concat\n  \
    \  if [[ $# -lt 1 ]]; then\n        concat=\"\"\n    else\n        concat=$(IFS=$'\\\
    n' xargs printf '%s\\n' \"$@\")\n    fi\n    echo \"$concat\"", "    local IFS=\"\
    $1\"\n    shift\n    echo \"$*\"", "    local delimiter=$1\n    shift\n    local\
    \ str=$*\n    echo $str", "    local IFS=\"$1\"\n    shift\n    echo \"$*\"",
  "  local IFS=\"\"\n  local a=\"${1// / }\"\n  echo \"$a\"", "    local result=()\n\
    \    for x in \"$@\"; do\n        result+=(\"$x\")\n    done\n    echo \"${result[@]}\"",
  "\tlocal _list=\"$1\";\n\tlocal _sep \"\";\n\n\tfor item in $_list; do\n\t\t_sep=\"\
    ${_sep} \";\n\tdone;\n\n\techo \"${_sep}\";", "    local IFS=\"$1\"\n    shift\n\
    \    echo \"$*\"", "  local _ret=$(echo $@)\n  local _i=${#_ret}\n  _ret=\"${_ret//\
    \ }\"\n  while [ \"$_i\" -gt 0 ]; do\n    _ret=\"${_ret}${1}\"\n    shift\n  \
    \  _i=$(( $_i - 1 ))\n  done\n  echo ${_ret}", "  local IFS=$1\n  shift\n  local\
    \ result\n  IFS=' '\n  result=$(IFS=+$'\\n'; echo \"$*\" | tr '\\n' ' ')\n  IFS=$IFS_ORIG\n\
    \  return $result", "    local -a strings=()\n    local string\n    for string;\
    \ do\n        strings+=(\"$string\")\n    done\n    echo \"${strings[*]}\"", " \
    \ local line\n  local list=\"$1\"\n  shift\n  echo -n \"$list\" | while read line;\
    \ do\n    echo $line\n  done", "    local string=\"\"\n    local list=\"$1\"\n\
    \    local separator=\"\"\n    for element in $list; do\n        separator=$separator$element\n\
    \    done\n    echo \"$separator\"", "  local IFS=\"$1\"\n  local -a str=( )\n\
    \  echo \"${str[*]}\"", "  local __concatenate=\"$1\"\n  shift 1\n  local __list\n\
    \  if [ -n \"${@:-}\" ]; then\n    __list=\"${@}\"\n  else\n    __list=\"\"\n\
    \  fi\n  # Concatenate each argument in turn\n  while [ -n \"${1-}\" ]; do\n \
    \   __concatenate=\"$__concatenate \\\"${1}\\\" \"\n    shift\n  done\n  # Remove\
    \ trailing whitespace\n  __concatenate=\"${__concatenate// /}\"\n  # Remove leading\
    \ whitespace\n  __concatenate=\"${__concatenate##* }\"\n  # Remove leading & trailing\
    \ whitespace\n  __concatenate=\"${__concatenate% *}\"\n  # Remove trailing separator\n\
    \  __concatenate=\"${__concatenate%\\ *}\"\n  __concatenate=\"${__concatenate#*\
    \ }\"\n  # Remove leading separator\n  __concatenate=\"${__concatenate%% *}\"\n\
    \  # Remove trailing separator\n  __concatenate=\"${__concatenate%%\\ *}\"\n \
    \ __concatenate=\"${__concatenate#\\ *}\"\n  __concatenate=\"${__concatenate%\\\
    }\"\n  __concatenate=\"${__concatenate%\\}\"\n  __concatenate=\"${__concatenate#\\\
    }\"\n  __concatenate=\"${__concatenate%%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate%%}\"\
    \n  __concatenate=\"${__concatenate##}\"\n  __concatenate=\"${__concatenate%}\"\
    \n  __concatenate=\"${__concatenate%%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate=\"${__concatenate##}\"\
    \n  __concatenate=\"${__concatenate%}\"\n  __concatenate", "  local list=\"$1\"\
    \n  shift\n  echo -n \"${list[*]}\" >> $1", "\tIFS=\" $\" # make sure we have\
    \ spaces to separate parameters\n\techo \"$*\" | tr '\\n' ' ' # collapse newlines",
  "  local result=\"\"\n  for i in \"$@\"; do\n    echo $result $i\n    result=$i\n\
    \  done", '  echo "${1}"', "\tlocal list\n\tlist=(\"$@\")\n\techo \"${list[*]}\"",
  "  local arg1=$1\n  shift\n  local arg2\n  arg2=$(echo \"$@\" | sed -e 's/^ *//'\
    \ -e '/^ *$/d' -e 's/ *$//')\n  echo \"$arg1 $arg2\"", "    local sep res\n  \
    \  IFS=\" $1\"\n    sep=$2\n    res=\"\"\n    shift\n    while [ -n \"$1\" ];\
    \ do\n        if [ \"$sep\" == \"\" ]; then\n            res=$res$1/\n       \
    \ else\n            res=$res$sep$1\n        fi\n        shift\n    done\n    IFS=\"\
    $sep\"\n    echo \"$res\"", "    local IFS=$1\n    shift\n    echo \"${*// /$IFS}\"\
    \ | tr -s ' '", "    echo -n \"$1\" | tr ' ' '\\044'", "    local delimiter=$1\n\
    \    shift\n    local result=\"$1\"\n    local IFS=$'\\n'\n    for var in \"$@\"\
    ; do\n        result=$result$delimiter$var\n    done\n    echo \"$result\"", " \
    \ local list_str\n  list_str=$1\n\n  # Turn list_str into an array\n  local list_arr=(${list_str})\n\
    \  # Add double-quotes around every element of list_arr\n  local list_arr2=(${list_arr[@]//\\\
    \"/\\\"\\\"})\n  # Turn list_arr2 into one string\n  list_str=\"${list_arr2[@]}\"\
    \n\n  # Remove the double-quotes we added in the first step\n  list_str=${list_str//\\\
    \"/}\n\n  echo \"$list_str\"", "  local IFS\n  local -a arr\n  IFS=$'\\t' arr=(\"\
    $@\")\n  echo \"${arr[*]}\"", "    local _out\n    _out=\"\"\n    for _item in\
    \ $1; do\n        _out=\"${_out} ${_item}\"\n    done\n    echo \"${_out}\"",
  '    echo "${@:1}"']
stop_tokens:
- "\n}"
