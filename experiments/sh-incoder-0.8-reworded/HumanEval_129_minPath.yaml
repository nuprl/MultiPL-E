name: HumanEval_129_minPath
language: sh
prompt: "#!/bin/bash\n# Given a grid with N rows and N columns (N >= 2) and a positive\
  \ integer k, \n# each cell of the grid contains a value. Every integer in the range\
  \ [1, N * N]\n# inclusive appears exactly once on the cells of the grid.\n# You\
  \ have to find the minimum path of length k in the grid. You can start\n# from any\
  \ cell, and in each step you can move to any of the neighbor cells,\n# in other\
  \ words, you can go to cells which share an edge with you current\n# cell.\n# Please\
  \ note that a path of length k means visiting exactly k cells (not\n# necessarily\
  \ distinct).\n# You CANNOT go off the grid.\n# A path A (of length k) is considered\
  \ less than a path B (of length k) if\n# after making the ordered lists of the values\
  \ on the cells that A and B go\n# through (let's call them lst_A and lst_B), lst_A\
  \ is lexicographically less\n# than lst_B, in other words, there exist an integer\
  \ index i (1 <= i <= k)\n# such that lst_A[i] < lst_B[i] and for any j (1 <= j <\
  \ i) we have\n# lst_A[j] = lst_B[j].\n# It is guaranteed that the answer is unique.\n\
  # Return an ordered list of the values on the cells that the minimum path go through.\n\
  # Examples:    \n# >>> $(minPath \"1 2 3\\n4 5 6\\n7 8 9\" \"3\")\n# ['\"1\"', '\"\
  2\"', '\"1\"']\n# >>> $(minPath \"5 9 3\\n4 1 6\\n7 8 2\" \"1\")\n# ['\"1\"']\n\
  #\n# $1 is a newline-separated, space-separated list\n# $2 is an integer\nminPath()\
  \ {\n"
tests: "}\n\ncandidate() {\n    minPath \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"1 2 3\\n4 5 6\\n7 8 9\" \"3\") = \"1 2 1\" ]]\n    [[ $(candidate\
  \ \"5 9 3\\n4 1 6\\n7 8 2\" \"1\") = \"1\" ]]\n    [[ $(candidate \"1 2 3 4\\n5\
  \ 6 7 8\\n9 10 11 12\\n13 14 15 16\" \"4\") = \"1 2 1 2\" ]]\n    [[ $(candidate\
  \ \"6 4 13 10\\n5 7 12 1\\n3 16 11 15\\n8 14 9 2\" \"7\") = \"1 10 1 10 1 10 1\"\
  \ ]]\n    [[ $(candidate \"8 14 9 2\\n6 4 13 15\\n5 7 1 12\\n3 10 11 16\" \"5\"\
  ) = \"1 7 1 7 1\" ]]\n    [[ $(candidate \"11 8 7 2\\n5 16 14 4\\n9 3 15 6\\n12\
  \ 13 10 1\" \"9\") = \"1 6 1 6 1 6 1 6 1\" ]]\n    [[ $(candidate \"12 13 10 1\\\
  n9 3 15 6\\n5 16 14 4\\n11 8 7 2\" \"12\") = \"1 6 1 6 1 6 1 6 1 6 1 6\" ]]\n  \
  \  [[ $(candidate \"2 7 4\\n3 1 5\\n6 8 9\" \"8\") = \"1 3 1 3 1 3 1 3\" ]]\n  \
  \  [[ $(candidate \"6 1 5\\n3 8 9\\n2 7 4\" \"8\") = \"1 5 1 5 1 5 1 5\" ]]\n  \
  \  [[ $(candidate \"1 2\\n3 4\" \"10\") = \"1 2 1 2 1 2 1 2 1 2\" ]]\n    [[ $(candidate\
  \ \"1 3\\n3 2\" \"10\") = \"1 3 1 3 1 3 1 3 1 3\" ]]\n}\n\nrun_test"
completions: ["\tlocal N=$1\n\tshift\n\tlocal k=$1\n\tshift\n\tlocal arr=( \"${@}\"\
    \ )\n\tlocal j=0\n\tlocal i\n\tlocal lst_A\n\tlocal lst_B\n\tlocal lst_C\n\tlocal\
    \ lst_D\n\tlocal lst_E\n\tlocal lst_F\n\tlocal lst_G\n\tlocal lst_H\n\tlocal lst_I\n\
    \tlocal lst_J\n\tlocal lst_K\n\tlocal lst_L\n\n\tlst_A=()\n\tlst_B=()\n\tlst_C=()\n\
    \tlst_D=()\n\tlst_E=()\n\tlst_F=()\n\tlst_G=()\n\tlst_H=()\n\tlst_I=()\n\tlst_J=()\n\
    \tlst_K=()\n\tlst_L=()\n\n\tlst_A=( ${arr[@]:0:N} ) \n\tlst_B=( ${arr[@]:N:N}\
    \ ) \n\tlst_C=( ${arr[@]:2*N:N} ) \n\tlst_D=( ${arr[@]:3*N:N} ) \n\tlst_E=( ${arr[@]:4*N:N}\
    \ ) \n\tlst_F=( ${arr[@]:5*N:N} ) \n\tlst_G=( ${arr[@]:6*N:N} ) \n\tlst_H=( ${arr[@]:7*N:N}\
    \ ) \n\tlst_I=( ${arr[@]:8*N:N} ) \n\tlst_J=( ${arr[@]:9*N:N} ) \n\tlst_K=( ${arr[@]:10*N:N}\
    \ ) \n\tlst_L=( ${arr[@]:11*N:N} ) \n\t\n\tlocal cnt=${#lst_A[@]}\n\tlocal i\n\
    \t\n\twhile [ $cnt -gt 0 ]; do\n\t\tlet i=$cnt-1\n\t\twhile [ $i -gt 0 ]; do\n\
    \t\t\t[[ ${lst_A[i]} -gt ${lst_B[i]} ]] &&\n\t\t\t\tlst_B[i]=${lst_A[i]}\n\t\t\
    \t[[ ${lst_A[i]} -lt ${lst_B[i]} ]] &&\n\t\t\t\tlst_A[i]=${lst_B[i]}\n\t\t\tlet\
    \ i=", "    local A=$1\n    local B=$2\n    local count=$((${#A} / ${#B}))\n \
    \   local results=( $(sort -n $B $A) $(sort -n $A $B) $(sort -n $A $B | awk -F\"\
    \ \" '{if($1>$3) {print $3} else{ print $3}}'))\n    local i\n    local j\n  \
    \  local tmp\n    \n    for ((i = 0; i < count; i++)); do\n        for ((j = 0;\
    \ j < count; j++)); do\n            tmp=\"${results[$i]}\"\n            results[$i]=\"\
    ${results[$j]}\"\n            results[$j]=\"${tmp}\"\n        done\n    done\n\
    \    \n    results=( $(sort -n \"${results[@]}\" | awk -F\" \" '{if($1==$3) {print\
    \ $2}}') )\n    \n    for ((i = 0; i < count; i++)); do\n        for ((j = 0;\
    \ j < count; j++)); do\n            if (( (results[$i] == \"$B\" && results[$j]\
    \ == \"$A\") || (results[$i] == \"$A\" && results[$j] == \"$B\") )); then\n  \
    \              results[$i]=\"${results[$j]}\"\n                results[$j]=\"\
    ${results[$i]}\"\n            fi\n        done\n    done\n\n    echo ${results[@]}",
  "    local nRows=${1}\n    local nCols=${2}\n    local k=${3}\n    local A\n   \
    \ local B\n    local lst_A\n    local lst_B\n    local i j\n    local res\n  \
    \  \n    if [ ${nRows} -eq 0 -o ${nCols} -eq 0 -o ${k} -eq 0 ]; then\n       \
    \ echo \"Usage: $0 (NRows NCols k)\"\n        exit 1\n    fi\n    \n    for ((i\
    \ = 1; i <= nRows; i++))\n    do\n        A=$A${i}\n    done\n    for ((i = 1;\
    \ i <= nCols; i++))\n    do\n        B=$B${i}\n    done\n    \n    eval lst_A=\\\
    $${A//$'\\n'/$' '}\n    eval lst_B=\\$${B//$'\\n'/$' '}\n    \n    for ((i = 1;\
    \ i <= nRows; i++))\n    do\n        eval res=\\$\\$${lst_A//$'\\n'/$' '}\n  \
    \      for ((j = 1; j <= nCols; j++))\n        do\n            if [ ${lst_A[${j}]}\
    \ -gt ${lst_B[${j}]} ]; then\n                res=\\$\\${${res//$'\\n'/$' '}#${j}}\
    \ ${lst_A[${j}]} ${lst_B[${j}]}\n            fi\n        done\n        eval lst_A=\\\
    $\\$${res//$'\\n'/$' '}\n    done\n    \n    for ((i = 1; i <= nCols; i++))\n\
    \    do\n        eval res=\\$\\$${lst_B//$'\\n'/$' '}\n        for ((j = 1; j\
    \ <= nRows; j++))\n        do\n            if [ ${lst_B[${j}]} -gt ${lst_A[${j}]}\
    \ ]; then\n                res=\\$\\${${res//$'\\n'/$' '}#${j}} ${lst_B[${j}]}\
    \ ${lst_A[${j}]}\n            fi\n        done\n        eval lst_B=\\$\\$${res//$'\\\
    n'/$' '}\n    done\n\n    eval res=\\$\\$${lst_A//$'\\n'/$' '}\n    for ((j =\
    \ 1; j <= nCols; j++))\n    do\n        eval res=\\$\\${res//$'\\n'/$' '}#${j}\
    \ ${lst_A[${j}]} ${", "    local lines=\"${1}\"\n    local num=\"${2}\"\n    if\
    \ [ ${#lines} -le ${#num} ] || [[ ${num} -lt 1 ]]; then\n        echo \"${1}:\
    \ input not valid\"\n        return 1\n    fi\n\n    echo \"${lines}\" | \n  \
    \      awk '{ \n                count[$0]++;\n                lst_A[$1] = $1;\n\
    \                lst_B[$1] = $2;\n                for (j = 2; j < length($1);\
    \ j++) {\n                    lst_A[$j] = lst_A[$j-1];\n                    lst_B[$j]\
    \ = lst_B[$j-1];\n                }\n            } END { \n                for\
    \ (k = 1; k <= ${#count}; k++) {\n                    if (count[$k] > 1) {\n \
    \                       for (j = 1; j <= k; j++) {\n                         \
    \   if (lst_A[lst_A[j]] > lst_B[lst_B[j]]) {\n                               \
    \ lst_B[lst_B[j]] = lst_A[lst_A[j]];\n                                lst_A[lst_A[j]]\
    \ = \"$k\";\n                            }\n                        }\n      \
    \              }\n                }\n                for (j = 1; j <= ${#lst_A};\
    \ j++) {\n                    print lst_A[j];\n                }\n           \
    \ }'", "  local -r grid=$1\n  local -r k=$2\n  [[ -z \"${grid}\" || -z \"${k}\"\
    \ ]] || return 1\n  local -r N=${#grid[@]}\n  [[ -z \"${N}\" ]] || return 1\n\
    \  local -r cnt=0\n  local -r result=()\n  local -r cnts=()\n  local -r lst=()\n\
    \  local -r cnt=0\n  local -r lst=()\n  local -i cnt=0\n  [[ -n \"${k}\" ]] ||\
    \ return 1\n  [[ \"${k}\" -gt \"${N*N}\" ]] || return 1\n  local -i i=0\n  local\
    \ -r j=0\n  local -r res=()\n  local -r cnt=0\n  while [[ $i -le \"${N}\" ]];\
    \ do\n    local -r ii=$(expr ${i} + 1)\n    lst+=(\"$i\")\n    local -r cnt=$(cnt+1)\n\
    \    local -r cnts=$(expr ${cnt} + 1)\n    if [[ -n \"${grid[$i]}\" ]]; then\n\
    \      local -r res=(${grid[$i]})\n      for (( j=1 ; j<${cnt} ; j++ )); do\n\
    \        result+=(\"${res[$j-1]}\")\n        local -r lst=$(expr ${cnt} - j)\n\
    \        local -r lst1=$(expr ${cnt} + ${j} - 1)\n        local -r res=()\n  \
    \      local -r ii=$(expr ${i} + 1)\n        if [[ \"${lst}\" -ge \"${lst1}\"\
    \ ]]; then\n          local -r res=(${lst[@]})\n        fi\n      done\n    fi\n\
    \    i=$(expr ${i} + 1)\n  done\n  printf '%s\\n' \"${result[@]}\"", "  local\
    \ rows=$1\n  local cols=$2\n  local lst_A=$3\n  local lst_B=$4\n  local i j\n\
    \  \n  if [[ \"$rows\" -eq 0 ]] || [[ \"$cols\" -eq 0 ]]; then\n    return 0\n\
    \  fi\n  \n  local sorted_A=$(sort -n <(echo $lst_A | sed 's/ /\\n/g'))\n  local\
    \ sorted_B=$(sort -n <(echo $lst_B | sed 's/ /\\n/g'))\n  \n  local k=$(echo \"\
    $sorted_A $sorted_B\" | awk 'BEGIN{for (i=1;i<=k;i++) print i}')\n  if [[ \"$k\"\
    \ -eq 0 ]]; then\n    return 0\n  fi\n  \n  local min=$((k-1))\n  local res=$min\n\
    \  \n  for ((i=1; i<k; i++));do\n    local max=$((i+1))\n    local min_index=0\n\
    \    \n    local min_lst_A\n    local min_lst_B\n    \n    min_lst_A=$(echo $sorted_A\
    \ | sed \"${max}q;d\" | awk '{print $1}')\n    min_lst_B=$(echo $sorted_B | sed\
    \ \"${max}q;d\" | awk '{print $1}')\n    \n    for ((j=1; j<=max; j++));do\n \
    \     local lst_A_index=$(( j - 1))\n      local lst_B_index=$(( j - 1))\n   \
    \   if [[ \"$lst_A_index\" -eq \"$lst_B_index\" ]] || [[ \"$lst_A_index\" -eq\
    \ 0 ]] || [[ \"$lst_B_index\" -eq 0 ]]; then\n        ((min_index=0))\n      else\n\
    \        if [[ \"$lst_A_index\" -gt \"$lst_B_index\" ]]; then\n          ((min_index=min_index\
    \ + 1))\n        else\n          ((min_index=min_index + 2))\n        fi\n   \
    \   fi\n      \n      if [[ \"$lst_A_index\" -eq \"$min_index\" ]]; then\n   \
    \     if [[ \"$lst_A[$lst_A_index]\" -lt \"$lst_B[$lst_B_index]\" ]]; then\n \
    \         min_index=$((min_index + 2))\n        else\n          min_index=$((min_index\
    \ + 1))\n        fi\n      else\n        min_index=0\n      fi\n      \n    done\n\
    \    \n    if [[ \"$min_index\" -eq \"$min\" ]]; then\n      ((res=$min))\n  \
    \  else\n      ", "    # Write your code here\n    local lines=$(cat);\n    local\
    \ numLines=$(echo \"$lines\" | wc -l);\n    local rows=$((numLines/2));\n    local\
    \ cols=$((numLines-rows));\n    local grid=$(echo \"$lines\" | sed 's/ /\\n/g');\n\
    \    local row=$(echo \"$grid\" | wc -l | awk '{print $1}');\n    local col=$(echo\
    \ \"$grid\" | wc -l | awk '{print $2}');\n    local res=();\n    local startPoint=\"\
    \";\n    local endPoint=\"\";\n    local countRow=0;\n    local countCol=0;\n\
    \    local resRow=0;\n    local resCol=0;\n    local rowVal=0;\n    local colVal=0;\n\
    \    local curPoint=\"\";\n    local points=();\n    local vals=();\n    local\
    \ point=0;\n    local val=0;\n    local i=0;\n    local j=0;\n    local pointCnt=0;\n\
    \    local valCnt=0;\n    local line=0;\n    local lineCnt=0;\n    local flag=0;\n\
    \    local flag1=0;\n    local flag2=0;\n    local flag3=0;\n    local flag4=0;\n\
    \    local flag5=0;\n    local flag6=0;\n    local flag7=0;\n    local flag8=0;\n\
    \    local flag9=0;\n    local flag10=0;\n    local flag11=0;\n    local flag12=0;\n\
    \    local flag13=0;\n    local flag14=0;\n    local flag15=0;\n    local flag16=0;\n\
    \    local flag17=0;\n    local flag18=0;\n    local flag19=0;\n    local flag20=0;\n\
    \    local flag21=0;\n    local flag22=0;\n    local flag23=0;\n    local flag24=0;\n\
    \    local flag25=0;\n    local flag26=0;\n    local flag27=0;\n    local flag28=0;\n\
    \    local flag29=0;\n    local flag30=0;\n    local flag31=0;\n    local flag32=0;\n\
    \    local flag33=0;\n    local flag34=0;\n    local flag35=0;\n    local flag36=0;\n\
    \    local flag37=0;\n    local flag38=0;\n    local flag39=0;\n    local flag40=0;\n\
    \    local flag41=0;\n    local flag42=0;\n    local flag43=0;\n    local flag44=0;\n\
    \    local flag45=0;\n    local flag46=0;", "    # Write your code in Python 3.6\n\
    \n    grid=$1\n    length=$2\n    arr=(`echo \"$grid\" | tr \" \" \"\\n\" | sort\
    \ -n -k 2 | cut -d \" \" -f 1`)\n    count=0\n    arrA=()\n    arrB=()\n    arrC=()\n\
    \    \n    for a in \"${arr[@]}\"; do\n        arrA+=($a)\n    done\n    \n  \
    \  for b in \"${arr[@]}\"; do\n        arrB+=($b)\n    done\n    \n    arrC=()\n\
    \    \n    for c in \"${arr[@]}\"; do\n        arrC+=($c)\n    done\n    \n  \
    \  for ((i=0; i<length; i++)); do\n        ((count++))\n    done\n    \n    i=0\n\
    \    j=0\n    \n    for ((i=0; i<count; i++)); do\n        ((j++))\n    done\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    ", "    [[ $(echo \"$1\"\
    \ | grep -E '^[0-9]+$' > /dev/null 2>&1) ]]\n    if [[ $1 =~ ([0-9]+)\\s+[0-9]+\\\
    s+([0-9]+) ]]; then\n        local N=$((${BASH_REMATCH[1]}+1))\n        local\
    \ M=$((${BASH_REMATCH[2]}+1))\n        local k=$2\n        local lst_A=($(echo\
    \ \"$1\" | tr -s ' ' | cut -d ' ' -f 1-$N))\n        local lst_B=($(echo \"$1\"\
    \ | tr -s ' ' | cut -d ' ' -f $M-1))\n        local lst_C=($(echo \"$1\" | tr\
    \ -s ' ' | cut -d ' ' -f $((M-1))))\n        local lst_D=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-2))+1))\n        local lst_E=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-3))+1))\n        local lst_F=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-4))+1))\n        local lst_G=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-5))+1))\n        local lst_H=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-6))+1))\n        local lst_I=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-7))+1))\n        local lst_J=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-8))+1))\n        local lst_K=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-9))+1))\n        local lst_L=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-10))+1))\n        local lst_M=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-11))+1))\n        local lst_N=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-12))+1))\n        local lst_O=($(echo \"$1\" | tr -s\
    \ ' ' | cut -d ' ' -f $((M-13))+1))\n        local lst_P=($(echo \"$1\" | tr -s\
    \ ' ' | ", "\tlocal lst_A lst_B\n\tlst_A=( $1 )\n\tlst_B=( $1 )\n\tlocal i j\n\
    \t(( ${#lst_A[@]} == ${#lst_B[@]} )) || return 1\n\t(( ${lst_A[0]} > ${lst_B[0]}\
    \ )) && return 1\n\tfor i in $(seq 1 ${#lst_A[@]})\n\tdo\n\t\t(( j == ${#lst_B[@]}\
    \ )) || return 1\n\t\t(( ${lst_B[j]} > ${lst_B[i-1]} )) && return 1\n\t\t(( ${lst_A[i]}\
    \ < ${lst_B[i]} )) && lst_B[j]=$lst_A[i]\n\tdone\n\tlst_A[@]", "    local line\n\
    \    local len\n    local i\n    local j\n    local A\n    local B\n    local\
    \ lst_A\n    local lst_B\n    local ans\n    \n    while read line; do\n     \
    \   len=\"${#line}\"\n        if [ \"${len}\" -eq 0 ]; then\n            echo\
    \ \"${line}\"\n            continue\n        fi\n        for ((i=1; i <= len;\
    \ i++ )); do\n            [[ -z \"${line[i]}\" ]] || line[i]=\"\\\"${line[i]}\\\
    \"\"\n        done\n        lst_A=$(echo \"${line}\" | tr \" \" \"\\n\" | sort\
    \ -u)\n        lst_B=$(echo \"${line}\" | tr \" \" \"\\n\" | sort -n | tail -1\
    \ | tr -d \"\\n\" )\n        \n        if [ \"${#lst_A}\" -eq \"${#lst_B}\" ];\
    \ then\n            ans=$(echo \"${lst_B}\" | sed -e \"s/^/${lst_A}/\" | tr \"\
    \ \" \"\\n\")\n        else\n            A=\"$(echo \"${lst_B}\" | sed -e \"s/^/${lst_A}/\"\
    \ | tr \" \" \"\\n\")\"\n            B=\"$(echo \"${lst_A}\" | sed -e \"s/^/${lst_B}/\"\
    \ | tr \" \" \"\\n\")\"\n            ans=\"$(echo \"${A}\" | sed -e \"s/^/${B}/\"\
    \ | tr \" \" \"\\n\")\"\n        fi\n        echo \"${ans}\"\n    done", "   \
    \ local g=\"$1\"\n    local n=\"$2\"\n\n    if [ -z \"$g\" ] ; then \n       \
    \ echo \"Empty grid!\"\n        return 1\n    fi\n    \n    if [ $n -lt 2 ] ;\
    \ then\n        echo \"Incorrect value of k!\"\n        return 1\n    fi\n   \
    \ \n    # Create a hash table of empty list for each cell\n    # Key is \"(row,\
    \ col)\", value is empty list\n    declare -A map\n    for ((r=1; r<=n; r++));\
    \ do \n        for ((c=1; c<=n; c++)); do \n            map[\"($r,$c)\"]=\"[]\"\
    \n        done\n    done\n    \n    # Now populate the hash table with values\
    \ on the grid\n    local v=\"${g//[$'\\n']}\"\n    for ((i=1;i<=n-1;i++)); do\n\
    \        for ((j=1;j<=n-1;j++)); do \n            map[\"($i,$j)\"]=\"[$v]\"\n\
    \        done\n    done\n    \n    # Iterate over all pairs (i,j) in the grid\n\
    \    # and populate the lst array with the values\n    # on the cells that the\
    \ path goes through\n    local i\n    for ((i=1;i<=n-1;i++)); do\n        for\
    \ ((j=1;j<=n-1;j++)); do \n            local lst\n            lst=(\"${!map[\"\
    ($i,$j)\"]}\")\n            map[\"($i,$j)\"]=\"${lst[@]}\" >/dev/null\n      \
    \  done\n    done\n    \n    # Get the smallest list\n    local key\n    for key\
    \ in \"${!map[@]}\"; do \n        local lst\n        lst=(\"${!map[\"$key\"]}\"\
    )\n        map[\"$key\"]=\"${lst[@]}\"\n    done\n    \n    # Remove empty lists\
    \ from the map hash table\n    local key\n    for key in \"${!map[@]}\"; do \n\
    \        map[\"$key\"]=\"${map[\"$key\"][@]}\"\n        if [[ ${#map[\"$key\"\
    ][@]} -eq 0 ]]; then \n            map[\"$key\"]=()\n        fi\n    done\n  \
    \  \n    # Remove entries with empty lists\n    local key\n    for key in \"${!map[@]}\"\
    ; do \n        map[\"$key\"]=\"${map[\"$key\"][@]}\"\n        if [[ -z \"${map[\"\
    $key\"]}\" ]]; then \n            map[\"$key\"]=\"[]\"\n        fi\n    done\n\
    \    \n    # Get the values on the cells that the ", "    local -n lines=$1\n\
    \    local -i n=$2\n    local -a strs=($(< \"$lines\"))\n    local -i j=0\n  \
    \  local -i k\n    local -a result=()\n    local -a result2=()\n    local -a lst_A\n\
    \    local -a lst_B\n    local -i len=0\n    \n    while (( j < n )); do\n   \
    \     k=0;\n        while (( k < n )); do\n            if (( strs[k] <= strs[j]\
    \ )); then\n                k=0;\n            else\n                k=$(( k +\
    \ 1 ))\n            fi\n        done\n        lst_A=( $(IFS=' '; echo \"${strs[j]:k}\"\
    )  )\n        lst_B=( $(IFS=' '; echo \"${strs[k]:k}\")  )\n        len=$(( $(echo\
    \ \"${#lst_A[@]}\" | bc) + 1 ))\n        if (( $(echo \"${#lst_A[@]}\" | bc) -\
    \ $(echo \"${#lst_B[@]}\" | bc) > 1 )); then\n            result+=( \"${strs[j]:len}\"\
    \ )\n            result+=( \"${strs[k]:len}\" )\n            result2+=( \"${strs[j]:k}\"\
    \ )\n            result2+=( \"${strs[k]:k}\" )\n        fi\n        j=$(( j +\
    \ 1 ))\n    done\n    echo \"${result[@]}\"\n    echo \"${result2[@]}\"", "  \
    \  N=${#${1}/#/}\n    \n    array=( $1 )\n    \n    [[ -z $2 ]] && echo \"Missing\
    \ argument\" && return 1\n    \n    arr=($2)\n\n    [[ -z ${arr[@]} ]] && echo\
    \ \"Missing argument\" && return 1\n\n    while (( ${#array[@]} > 0 )); do\n \
    \       echo \"${array[@]}\"\n        length=${#array[@]}\n        \n        ((\
    \ N > length )) && break\n    done\n\n    echo \"${arr[@]}\"\n\n    local i\n\
    \    local j\n\n    while (( ${#arr[@]} > 0 )); do\n        (( N > ${#arr[@]}\
    \ )) && break\n        (( N == 0 )) && break\n\n        i=${arr[0]}\n        j=${arr[1]}\n\
    \n        echo \"j=$j\"\n        echo \"i=$i\"\n\n        arr=( \"${arr[@]:2:2}\"\
    \ )\n\n        (( j > i )) && break\n        (( j < i )) && break\n\n        arr=(\
    \ \"${arr[@]:2:1}\" )\n    done\n\n    echo \"${arr[@]}\"\n\n    local lst\n \
    \   local cnt\n\n    (( N == 0 )) && return 0\n\n    while (( ${#arr[@]} > 0 ))\
    \ ; do\n        lst=( \"${arr[@]}\" )\n\n        cnt=${#lst[@]}\n        cnt=$((\
    \ N + cnt - 1 ))\n\n        lst=($(sort <<<\"${lst[@]}\" | uniq | head -n${cnt})\
    \ )\n\n        (( N > cnt )) && break\n    done\n\n    echo \"${lst[@]}\"\n\n\
    \    local i\n    local j\n\n    for i in $(seq $N); do\n        for j in $(seq\
    \ $N); do\n            echo \"${lst[@]}\"\n        done\n    done\n\n    echo\
    \ \"${arr[@]}\"\n\n    for i in $(seq $N); do\n        for j in $(seq $N); do\n\
    \            echo \"${arr[@]}\"\n        done\n    done\n\n    echo \"${lst[@]}\"\
    \n\n    local ret\n    for i in $(seq $N); do\n        for j in $(seq $N); do\n\
    \            echo \"${lst[@]}\"\n        done\n    done\n\n    echo \"${arr[@]}\"\
    \n\n    for i in $(seq $N); do\n        for j in $(seq $N); do\n            echo\
    \ \"${arr[@]}\"\n        done\n    done\n\n    echo \"${lst[@]}\"\n\n    return ",
  "    local lst_A=$1\n    local k=$2\n    \n    local lst_B=()\n    lst_B[0]=$1\n\
    \n    local i=0\n    \n    local j=0\n    \n    local arr=()\n\n    local arr_pos=0\n\
    \n    while ((i < k)) do\n        j=0\n        \n        local idx=-1\n      \
    \  \n        local arr_max=-1\n        \n        arr_idx=0\n        arr_pos=0\n\
    \        \n        while ((j < (i - 1)) && (lst_A[j] < lst_B[i])) do\n       \
    \     idx=$((arr_pos + 1))\n            arr[$((arr_idx + 1))]=lst_A[j]\n     \
    \       if ((idx > arr_max)) then\n                arr_max=idx\n            fi\n\
    \            j=$((j + 1))\n        done\n\n        arr_pos=$((arr_pos + 1))\n\n\
    \        if ((arr_max >= i)) then\n            arr[$((arr_max + 1))]=$lst_B[i]\n\
    \        fi\n        \n        lst_B[i]=$lst_B[i]\n        \n        i=$((i +\
    \ 1))\n    done\n\n    local arr_min=$lst_B[$((k - 1))]\n    \n    for ((j = 1;\
    \ j < (k - 1)); j++) do\n        arr_min=$((arr_min < arr[j]) ? arr[j] : arr_min)\n\
    \    done\n    \n    local arr_new=($(echo \"$arr_min\" | sed 's/^\"//;s/\"$//'))\n\
    \    \n    arr_new=($(echo \"$arr_new\" | tr '\\n' '\\001' | sed 's/^\"/\"/'))\n\
    \    \n    arr_new=($(echo \"$arr_new\" | tr '\\001' '\\n'))\n    \n    arr_new=($(echo\
    \ \"$arr_new\" | sed 's/\\001/\\n/g'))\n\n    arr_new=$(echo \"$arr_new\" | tr\
    \ '\"' '/')\n    \n    arr_new=$(echo \"$arr_new\" | tr -s '[[:space:]]' '[[:space:]]\\\
    n' | tr -s ' ' '\\n' | tr -s '\\n' ' ')\n    \n    arr_new=$(echo \"$arr_new\"\
    \ | tr -s '\\n' '\\001' | sed 's/\\001/\\n/g')\n\n    arr_new=$(echo \"$arr_new\"\
    \ | sed 's/^\"/\"/' | sed 's/\"$//')\n\n    return $arr_new", "    local grid=$1\n\
    \    local k=$2\n    local lst_A=$(echo \"$grid\" | tr '\\n' ' ')\n    local lst_B=$(echo\
    \ \"$grid\" | tr ' ' '\\n' | sort -n)\n    local i=0\n    local j=0\n    local\
    \ result=()\n    local answer\n\n    while [ $i -le $k ]\n    do\n        j=$((i\
    \ + 1))\n        if [ $j -le $k ]\n        then\n            if [ $lst_A[$i] -gt\
    \ $lst_B[$j] ]\n            then\n                lst_B[$j+1]=$lst_A[$i]\n   \
    \             i=$j\n            else\n                lst_B[$j+1]=$lst_B[$j]\n\
    \            fi\n        else\n            if [ $lst_A[$j] -gt $lst_B[$i] ]\n\
    \            then\n                lst_B[$i+1]=$lst_A[$j]\n                j=$i\n\
    \            else\n                lst_B[$i+1]=$lst_B[$i]\n            fi\n  \
    \      fi\n    done\n    if [ $i -le $k ]\n    then\n        if [ $lst_A[$i] -gt\
    \ $lst_B[$i] ]\n        then\n            lst_B[$i+1]=$lst_A[$i]\n           \
    \ result+=( \"\\\"$lst_A[$i]\\\"\" ) \n        else\n            lst_B[$i+1]=$lst_B[$i]\n\
    \            result+=( \"\\\"$lst_B[$i]\\\"\" ) \n        fi\n    else\n     \
    \   if [ $lst_A[$j] -gt $lst_B[$j] ]\n        then\n            lst_B[$j+1]=$lst_A[$j]\n\
    \            result+=( \"\\\"$lst_A[$j]\\\"\" ) \n        else\n            lst_B[$j+1]=$lst_B[$j]\n\
    \            result+=( \"\\\"$lst_B[$j]\\\"\" ) \n        fi\n    fi\n    echo\
    \ \"${result[@]}\"", "  local lines=\"$1\"\n  local val=\"$2\"\n  local length=\"\
    ${#lines[@]}\"\n  \n  if [ $length -gt 1 ]; then\n    # we need a line with exactly\
    \ $val values\n    if [[ $lines == *\"$val\"* ]]; then\n      echo \"$lines\"\n\
    \    else\n      # we need a line with exactly $val values\n      echo \"ERROR\"\
    \n    fi\n  else\n    # we need a line with exactly 1 value\n    echo \"ERROR\"\
    \n  fi", "\tlocal -n grid=$1\n\tlocal -n k=$2\n\n\tlocal -A lst_A\n\tlocal -A\
    \ lst_B\n\tlocal i\n\tlocal j\n\tlocal result\n\tlocal index\n\n\tlst_A=($grid)\
    \ # copy\n\n\t# populate lst_B\n\tfor ((i = 0; i < ${#lst_A[@]}; i++)); do\n\t\
    \tlst_B[$i]=$lst_A[i]\n\tdone\n\n\t# populate lst_B with k - 1 values\n\tfor ((i\
    \ = 1; i < ${k}; i++)); do\n\t\tlst_B[$i]=$lst_B[$i-1]\n\tdone\n\n\t# populate\
    \ lst_A with k values\n\tfor ((i = 0; i < ${k}; i++)); do\n\t\tlst_A[$i]=$i\n\t\
    done\n\n\t# find minimum value\n\tlocal i\n\tlocal index\n\tindex=0\n\tfor ((i\
    \ = 0; i < ${#lst_A[@]}; i++)); do\n\t\tif [ ${lst_A[i]} -gt ${lst_B[$index]}\
    \ ]; then\n\t\t\tindex=$i\n\t\tfi\n\tdone\n\tresult=${lst_A[$index]}\n\n\trm -f\
    \ array\n\tprintf \"[\\n\"\n\twhile read line; do\n\t\tprintf \"\\\"%s\\\"\" ${line#?}\n\
    \t\tprintf \",\"\n\tdone < <(printf \"%s\\n\" $result)\n\n\tprintf \"]\\n\"",
  "    local -n lines=$1; shift\n    local -n val=$1; shift\n    local -i N=$1; shift\n\
    \    local -i k=$1; shift\n\n    if [[ $N -lt 2 ]]; then\n        echo \"Usage:\
    \ $(basename $0) <grid> <k>\"\n        exit 1\n    fi\n    \n    local -i j=$((N-1));\n\
    \    local -i c=0;\n    local -i c2;\n    local -i c3;\n    local -i c4;\n   \
    \ local -i c5;\n    local -i c6;\n    local -i i\n    local -a lstA;\n    local\
    \ -a lstB;\n    local -i j2;\n    local -i j3;\n    local -i j4;\n    local -i\
    \ j5;\n    local -i j6;\n    local -i n\n    local j\n    local v\n    local t\n\
    \    local kmax\n    \n    kmax=$((k*k));\n    \n    for ((i=1;i<=k;i++)); do\n\
    \        # kmax is always >= k * k.\n        lstA[$i]=\"\\c\"\n        lstB[$i]=\"\
    \\c\"\n    done\n    \n    # Generate all paths of length k starting from any\
    \ cell and visiting each neighbor cell.\n    # A cell is visited at most once\
    \ (no duplicates).\n    for ((i=1;i<=k;i++)); do\n        # kmax is always >=\
    \ k * k.\n        kmax=$((kmax-1));\n        for ((j=1;j<=k;j++)); do\n      \
    \      if [[ $((${#lines[$c]})) -gt $((i*N + j)) ]]; then\n                continue\n\
    \            fi\n            v=${lines[$c]}\n            case \"${v:0:1}\" in\n\
    \                '\"') v=${v:1}; break;;\n                '\\n') v=${v:1}; break;;\n\
    \                *) echo \"ERROR: $(basename $0) error: Invalid grid entry\";\
    \ exit 1;;\n            esac\n            if [[ -z \"$v\" ]]; then\n         \
    \       continue\n            fi\n            \n            ((j=j-1))\n      \
    \      case \"${v:0:1}\" in\n                '\"') v=${v:1}; break;;\n       \
    \         '\\n') v=${v:1}; break;;\n                *) echo \"ERROR: $(basename\
    \ $0) error: Invalid grid entry\"; exit 1;;\n            esac\n            if\
    \ [[ -z \"$v\" ]]; then\n                continue\n            fi\n\n        \
    \    ((j=j-1))\n            case \"${v:0:1}\" ", "    local lst_A=\"$1\"\n   \
    \ local k=\"$2\"\n    if [[ \"$k\" -gt \"2\" ]]; then\n        echo \"$k must\
    \ be an integer in [1, $(($2 * $2))]\"\n        return 1\n    fi\n    local result=''\n\
    \    local i=0\n    local j=0\n    local max=1\n    while [ \"$i\" -lt \"$k\"\
    \ -o \"$j\" -lt \"$k\" ]\n    do\n        if [ -z \"$lst_A\" ] ; then return 0;\
    \ fi\n        if [ \"$lst_A\" -ge \"$max\" ] \n        then \n            result+=\"\
    '$lst_A'\" \n            return 1\n        fi\n        (( i+=1 ))\n        max=$((\
    \ max+1 ))\n        local tmp=$(echo \"$lst_A\" | sed -n \"2~2p\")\n        lst_A=$(echo\
    \ \"$lst_A\" | sed \"2~2q;d\")\n        if [ \"$lst_A\" -ge \"$max\" ] \n    \
    \    then \n            result+=\"'$lst_A'\" \n            return 1\n        fi\n\
    \        (( j+=1 ))\n        max=$(( max+1 ))\n        lst_A=$tmp\n    done\n\
    \    echo \"$result\"", "  local lst_A=$(echo $1 | tr ' ' \"\\n\" | sort -u |\
    \ sed 's/\"//g')\n  local lst_B=$(echo $1 | tr ' ' \"\\n\" | sort -u | sed 's/\"\
    //g')\n  local i=$2\n  while [[ $i -le ${#lst_A[*]} ]]; do\n    local j=$((i +\
    \ 1))\n    if [[ $j -le ${#lst_A[*]} ]]; then\n      if [[ $lst_A[$j] == $lst_A[$i]\
    \ ]]; then\n        # lst_A[j] < lst_A[i]\n        lst_A[$j]=$(echo $lst_A[$j]\
    \ | sed \"s/$lst_A[$i]/$lst_A[$i]/\" | sed \"s/$lst_A[$j]/$lst_A[$j]/\")\n   \
    \     lst_B[$j]=$lst_B[$j]\n      else\n        # lst_A[i] < lst_A[j]\n      \
    \  lst_A[$i]=$(echo $lst_A[$i] | sed \"s/$lst_A[$j][^$lst_A[$i]]/$lst_A[$i]/\"\
    \ | sed \"s/$lst_A[$i][^$lst_A[$j]]/$lst_A[$i]/\")\n        lst_B[$i]=$(echo $lst_B[$i]\
    \ | sed \"s/$lst_A[$i][^$lst_A[$i]]/$lst_B[$i]/\" | sed \"s/$lst_A[$j][^$lst_A[$j]]/$lst_B[$i]/\"\
    )\n      fi\n    fi\n    i=$((i + 1))\n  done\n  echo $lst_A\n  echo $lst_B\n\
    \  local lst_A=$(echo $lst_A | tr ' ' \"\\n\" | sort -u | sed 's/\"//g')\n  local\
    \ lst_B=$(echo $lst_B | tr ' ' \"\\n\" | sort -u | sed 's/\"//g')\n  echo $(echo\
    \ $lst_A | tr ' ' \"\\n\" | sed 's/^/\"/' | tr ' ' \"\\n\" | sed 's/$/\"/')\n\
    \  echo $(echo $lst_B | tr ' ' \"\\n\" | sed 's/^/\"/' | tr ' ' \"\\n\" | sed\
    \ 's/$/\"/')", "    local lst_A lst_B k\n    lst_A=$1\n    k=$2\n    lst_B=$(cat\
    \ <<<\"$lst_A\" | cut -d \" \" -f - | sort | uniq -u  | sort -n)\n    while ((\
    \ ${#lst_B} > k ))\n    do\n        lst_B=$(cat <<<\"$lst_B\" | cut -d \" \" -f\
    \ - | sort | uniq -u  | sort -n)\n    done\n    echo ${lst_B[@]}", "    # Convert\
    \ $1 and $2 to sets and sort\n    lst_A=($(echo \"$1\" | tr '\\n' ' ' | sort -u\
    \ | sed 's/ //g'))\n    lst_B=($(echo \"$2\" | tr '\\n' ' ' | sort -u | sed 's/\
    \ //g'))\n    [[ -z \"${lst_A[*]}\" ]] && echo \"No values found in $1\"\n   \
    \ [[ -z \"${lst_B[*]}\" ]] && echo \"No values found in $2\"\n    # Initialize\
    \ min and max value\n    min=\"${lst_B[*]}\"\n    max=\"${lst_A[*]}\"\n    # Iterate\
    \ over the grid until either min or max are maxed\n    for ((i = 1; i < ${#lst_A[*]};\
    \ i++)); do\n        if [[ \"${min}\" > \"${lst_A[$i]}\" ]]; then\n          \
    \  # Update min to current cell and reset max to current cell\n            min=\"\
    ${lst_A[$i]}\"\n            max=\"${lst_A[$i]}\"\n        elif [[ \"${max}\" <\
    \ \"${lst_A[$i]}\" ]]; then\n            # Update max to current cell and reset\
    \ min to current cell\n            max=\"${lst_A[$i]}\"\n            min=\"${lst_A[$i]}\"\
    \n        fi\n    done\n    # Check if min and max are equal\n    [[ \"${min}\"\
    \ == \"${max}\" ]] && return 0\n    echo \"${min}\" \"${max}\" \"${#lst_A[*]}\"\
    \ \"${#lst_B[*]}\"", "  local lines=$1\n  local k=$2\n\n  echo $lines | grep $k\
    \ | sort | uniq | grep -v -E '^\"[0-9]+\"' | grep -v '^\"[0-9]+\"$' | head -n\
    \ 1", "    local nlines=$1\n    local n=$2\n    local path\n    local -i i=0\n\
    \    local listA listB j\n    local -a path\n    local tmp\n\n    # Initialize\
    \ lists\n    path=()\n    listA=()\n    listB=()\n\n    # Iterate over each line\
    \ and append values to lists\n    while [ $i -lt $nlines ]; do\n        # Skip\
    \ comments and empty lines\n        [[ -z \"$line[$i]\" ]]; \n        if [[ \"\
    $line[$i]\" =~ ^# ]] \n        then\n            i=$((i+1))\n        else\n  \
    \          listA+=($line[$i])\n            listB+=($line[$i])\n        fi\n  \
    \      i=$((i+1))\n    done\n\n    # Build path list\n    while [ ${#listA[@]}\
    \ -gt $i ]; do\n        path=(\"${path[@]}\" \"$listA[$i]\")\n        i=$((i+1))\n\
    \    done\n    path=(\"${path[@]}\" \"$listA[$i]\")\n\n    # Sort lists lexicographically\n\
    \    local -n list=\n    list=\n    i=0\n    while [ $i -lt $((${#list[@]}-1))\
    \ ]; do\n        if [[ ${list[$i]} > ${list[$((i+1))]} ]]; then\n            list=$listA\n\
    \        else\n            list=$listB\n        fi\n        i=$((i+1))\n    done\n\
    \    list=(\"${list[@]}\" \"$listA[$i]\")\n\n    # Remove duplicates\n    list=($(sort\
    \ -u ${list[@]}))\n\n    # Remove leading 0s\n    list=($(sed 's/^0//g' <<< ${list[@]}))\n\
    \n    # Sort list lexicographically\n    list=\n    i=0\n    while [ $i -lt $((${#list[@]}-1))\
    \ ]; do\n        list=$listA\n        if [[ ${list[$i]} > ${list[$((i+1))]} ]];\
    \ then\n            list=$listB\n        else\n            list=$listA\n     \
    \   fi\n        i=$((i+1))\n    done\n    list=(\"${list[@]}\" \"$listA[$i]\"\
    )\n\n    # Remove duplicates\n    list=($(sort -u ${list[@]}))\n\n    # Remove\
    \ leading \"\n    list=($(sed 's/\"//g' <<< ${list[@]}))\n\n    # Remove trailing\
    \ \"", "  if [[ $1 =~ '^[0-9]+$' ]]; then\n    echo \"$1\" | sort | uniq | grep\
    \ -c \"$2\"\n  else\n    echo \"$1\" | sort | uniq | grep -c \"$2\"\n  fi", " \
    \ local lines=\"$1\"\n  local val=\"$2\"\n  \n  local result\n  local x\n  local\
    \ y\n  local d\n  local lst_a\n  local lst_b\n\n  IFS=$'\\n' read -d '' -a lst_a\
    \ <<< \"$lines\"\n  \n  for ((i=1; i<\"${#lst_a[@]}\"; i++)); do\n    for ((j=1;\
    \ j<=\"${#lst_b[@]}\"; j++)); do\n      \n      if [[ $i -eq 1 && $j -eq 1 ]];\
    \ then\n        ((d=$lst_a[1]>$lst_b[1]))\n      elif [[ $j -eq 1 && $i -eq 1\
    \ ]]; then\n        ((d=$lst_a[1]>$lst_b[1]))\n      elif [[ $i -eq 1 && $j -eq\
    \ ${#lst_b[@]} ]]; then\n        ((d=$lst_a[1]>$lst_b[1]))\n      elif [[ $j -eq\
    \ ${#lst_b[@]} && $i -eq 1 ]]; then\n        ((d=$lst_a[1]>$lst_b[1]))\n     \
    \ elif [[ \"${lst_a[$i]}\" == \"$lst_b[$j]\" && ${#lst_b[@]} -gt 2 ]]; then\n\
    \        ((d=$lst_a[1]>$lst_b[1]))\n      fi\n      \n      if [[ -n $d ]]; then\n\
    \        lst_a[i+1]=$lst_b[$j]\n        lst_b[$j+1]=$lst_a[$i]\n      fi\n   \
    \ done\n  done\n  \n  IFS=$' \\t\\n' read -d '' -a lst_b <<< \"$lst_b\"\n  \n\
    \  lst_a=$(IFS='\\n' echo \"${lst_a[@]}\")\n  lst_b=$(IFS='\\n' echo \"${lst_b[@]}\"\
    )\n\n  result=$(IFS='\\n' echo \"${lst_a}\")\n  \n  echo \"$result\"", "    local\
    \ lst_A=()\n    local lst_B=()\n    local res=()\n    while IFS=$' \\t' read -r\
    \ -a line; do\n        lst_A+=(${line[0]})\n        lst_B+=(${line[1]})\n    done\
    \ < <(echo \"$1\")\n\n    for ((i=0; i < ${#lst_A[@]}; i++)); do\n        local\
    \ j=1\n        while (( j < (${#lst_A[@]})) && \\\n              ( lst_A[i] >\
    \ lst_B[j] || lst_A[i] == lst_B[j] )); do\n            j=$(( j + 1 ))\n      \
    \  done\n        if [[ ${j} -eq ${#lst_A[@]} ]]; then\n            res+=( ${lst_A[i]}\
    \ )\n        fi\n    done\n    echo $(sort -g <<<\"${res[@]}\")", "  declare -a\
    \ arr=()\n  declare -i i\n  read -r _ _ n _ < <(head -n 1 \"$1\") && return\n\
    \  read -r _ _ n _ < <(tail -n +2 \"$1\") && return\n  \n  for ((i = 1; i <= n;\
    \ i++) { arr+=(\"\\\"$i\\\"\") }); \n  arr=(${arr[@]:1}); \n  arr=(${arr[@]:1});\
    \ \n  \n  for ((i = 0; i <= k; i++) { \n     arr=(\"${arr[@]:0:i}\" \"${arr[@]:i:k}\"\
    \ \"${arr[@]:((i+1)*k):((i+1)*k+k)}\"); \n  }\n  \n  echo \"${arr[@]}\"", "  \
    \  local -i N k\n    local -i i j result lst_A lst_B\n\n    N=\"${#${1// /}}\"\
    \n    k=\"${2}\"\n\n    IFS=$'\\n' read -r -a lst_A <<< \"$1\"\n    IFS=$' ' read\
    \ -r -a lst_B <<< \"$1\"\n\n    # Initialize the first cell\n    i=1;\n\n    #\
    \ Now we search for the cell where we can go (without visiting it yet)\n    while\
    \ [[ ${#lst_A[i]} -gt k || ${#lst_B[i]} -gt k ]]; do\n        ((i++))\n    done\n\
    \n    # Now we build the result\n    while [[ ${#lst_A[i]} -gt 0 ]]; do\n    \
    \    # Add the current cell's value to the result\n        result+=(\"${lst_A[i]}\"\
    )\n        ((i++))\n\n        # Now we search for other cells where we can go\n\
    \        ((j=i))\n        while [[ ${#lst_A[j]} -gt k || ${#lst_B[j]} -gt k ]];\
    \ do\n            ((j++))\n        done\n\n        # Add the new cells to the\
    \ result\n        result+=(\"${lst_A[j]}\")\n        while [[ ${#lst_B[j]} -gt\
    \ k ]]; do\n            result+=(\"${lst_B[j]}\")\n            ((j++))\n     \
    \   done\n    done\n    # Return the result\n    echo \"${result[@]}\"", "   \
    \ local arr=($1)\n    local num=$(echo $2 | sed 's/\\..*$//')\n    local arr2=($1)\n\
    \    local count=1\n    local count2=1\n    local count3=1\n    local count4=1\n\
    \    local count5=1\n    local count6=1\n    local count7=1\n    local count8=1\n\
    \    local count9=1\n    local count10=1\n    local count11=1\n    local count12=1\n\
    \    local count13=1\n    local count14=1\n    local count15=1\n    local count16=1\n\
    \    local count17=1\n    local count18=1\n    local count19=1\n    local count20=1\n\
    \    local count21=1\n    local count22=1\n    local count23=1\n    local count24=1\n\
    \    local count25=1\n    local count26=1\n    local count27=1\n    local count28=1\n\
    \    local count29=1\n    local count30=1\n    local count31=1\n    local count32=1\n\
    \    local count33=1\n    local count34=1\n    local count35=1\n    local count36=1\n\
    \    local count37=1\n    local count38=1\n    local count39=1\n    local count40=1\n\
    \    local count41=1\n    local count42=1\n    local count43=1\n    local count44=1\n\
    \    local count45=1\n    local count46=1\n    local count47=1\n    local count48=1\n\
    \    local count49=1\n    local count50=1\n    local count51=1\n    local count52=1\n\
    \    local count53=1\n    local count54=1\n    local count55=1\n    local count56=1\n\
    \    local count57=1\n    local count58=1\n    local count59=1\n    local count60=1\n\
    \    local count61=1\n    local count62=1\n    local count63=1\n    local count64=1\n\
    \    local count65=1\n    local count66=1\n    local count67=1\n    local count68=1\n\
    \    local count69=1\n    local count70=1\n    local count71=1\n    local count72=1\n\
    \    local count73=1\n    local count74=1\n    local count75=1\n    local count76=1\n\
    \    local count77=1\n    local count78=1\n    local count79=1\n    local count80=1\n\
    \    ", "    local arr\n    local -n lst_A\n    local -n lst_B\n    local -r num_rows=${2:-}\n\
    \    local -r num_columns=${3:-}\n    arr=($1)\n    num_rows=${#arr[@]}\n    num_columns=${#arr[0]}\n\
    \    lst_A=()\n    lst_B=()\n    for ((i = 1; i <= num_columns; i++) {\n     \
    \   lst_B+=(${arr[i]})\n        lst_A+=(${arr[i]})\n    }\n    local index=0\n\
    \    for ((i = 1; i <= num_rows; i++)) {\n        for ((j = 1; j <= num_columns;\
    \ j++) {\n            if ((index > num_rows)) {\n                break\n     \
    \       }\n            local value=${arr[j]}\n            if ([[ \"${arr[j]}\"\
    \ < \"${arr[index + j]}\" ]]; then\n                value=${arr[index + j]}\n\
    \                lst_A+=(${arr[j]})\n                lst_B+=(${arr[index + j]})\n\
    \                index=$((index + 1))\n            fi\n            arr[index]=${value}\n\
    \        }\n    }\n    arr=(\"${arr[@]}\")\n    for ((i = 1; i <= num_columns;\
    \ i++) {\n        lst_B+=(${arr[i]})\n        lst_A+=(${arr[i]})\n    }\n    arr=(\"\
    ${arr[@]}\")", "    local lines=$1\n    local N=$2\n    local k=$((N * N))\n \
    \   local lst_A\n    local lst_B\n    local i\n    local j\n    local jt\n   \
    \ local cnt\n    local lst\n    local lstcnt\n    local ret\n\n    if [[ $N <\
    \ 2 ]]; then\n        ret=()\n        echo \"$lines\" | while read -r line; do\
    \ ret+=($line); done\n        return\n    fi\n    \n    lst_A=($(sort <<<\"$lines\"\
    ))\n    \n    while [[ ${#lst_A[@]} -gt 0 ]]; do\n        lst_B=($(sort <<<\"\
    ${lst_A[*]:#1}/\\${lst_A[@]}\"))\n        \n        for ((i=0; i<$((k-1)); i++));\
    \ do\n            for ((j=0; j<$((k-1)); j++)); do\n                if [[ $i -eq\
    \ 0 ]]; then\n                    jt=$j\n                elif [[ $i -eq $((N-1))\
    \ ]]; then\n                    jt=$j+$((N-1))\n                else\n       \
    \             jt=$j+$i\n                fi\n                if [[ $j -eq 0 ]];\
    \ then\n                    cnt=$((k-1))\n                elif [[ $j -eq $((N-1))\
    \ ]]; then\n                    cnt=$((k-1))\n                else\n         \
    \           cnt=$j\n                fi\n                if ((cnt > 0)); then\n\
    \                    lstcnt=$((cnt - (lst_A[jt] < lst_B[jt])))\n             \
    \   fi\n            done\n            \n            for ((j=0; j<$((k-1)); j++));\
    \ do\n                if ((jt > 0)); then\n                    lstcnt=$((jt -\
    \ lst_A[jt] < lst_B[jt]))\n                fi\n            done\n            \n\
    \            if [[ $lstcnt -eq 0 ]]; then\n                ret+=(${lst_A[@]})\n\
    \            fi\n        done\n        lst_A=(\"${lst_A[@]:0:${#lst_A[@]} - 1}\"\
    )\n    done\n    \n    echo \"${ret[@]}\"", '  echo "$(minPath2 "$1" "$2" "$3")"
    # bash hacker', "  local input=\"$1\"\n  local k=\"$2\"\n  \n  while [[ \"$input\"\
    \ =~ \" $k \" ]]; do\n    input=\"${input/\"$k\"/\"$((k-1))\"}\"\n    k=$((k-1))\n\
    \  done\n  \n  local input=\"${input/$k}\"\n  \n  input=\"${input/$((k-1))}\"\n\
    \  input=\"${input/$((k-1))}\"\n  \n  input=\"${input/$((k-1))}\"\n  input=\"\
    ${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"\
    ${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\n  input=\"${input/$((k-1))}\"\
    \n  input", "    local line\n    local lineNum\n    local lineNum1\n    local\
    \ lineNum2\n    local lineNum3\n    local lineNum4\n    local minPath_var\n  \
    \  local minPath_var2\n    local minPath_var3\n    local minPath_var4\n    local\
    \ minPath_var5\n    local minPath_var6\n    local minPath_var7\n    local minPath_var8\n\
    \    local minPath_var9\n    local minPath_var10\n    local minPath_var11\n  \
    \  local minPath_var12\n    local minPath_var13\n    local minPath_var14\n   \
    \ local minPath_var15\n    local minPath_var16\n    local minPath_var17\n    local\
    \ minPath_var18\n    local minPath_var19\n    local minPath_var20\n    local minPath_var21\n\
    \    local minPath_var22\n    local minPath_var23\n    local minPath_var24\n \
    \   local minPath_var25\n    local minPath_var26\n    local minPath_var27\n  \
    \  local minPath_var28\n    local minPath_var29\n    local minPath_var30\n   \
    \ local minPath_var31\n    local minPath_var32\n    local minPath_var33\n    local\
    \ minPath_var34\n    local minPath_var35\n    local minPath_var36\n    local minPath_var37\n\
    \    local minPath_var38\n    local minPath_var39\n    local minPath_var40\n \
    \   local minPath_var41\n    local minPath_var42\n    local minPath_var43\n  \
    \  local minPath_var44\n    local minPath_var45\n    local minPath_var46\n   \
    \ local minPath_var47\n    local minPath_var48\n    local minPath_var49\n    local\
    \ minPath_var50\n    local minPath_var51\n    local minPath_var52\n    local minPath_var53\n\
    \    local minPath_var54\n    local minPath_var55\n    local minPath_var56\n \
    \   local minPath_var57\n    local minPath_var58\n    local minPath_var59\n  \
    \  local minPath_var60\n", "  local lst_A\n  local lst_B\n  local i\n  local j\n\
    \  local result\n\n  if [[ $1 =~ \"^[0-9]+$\" ]]; then\n    lst_A=$1\n    lst_B=$(cat\
    \ <<EOF\n$lst_A\nEOF\n)\n  elif [[ $1 =~ \"^[0-9]+\\\\n[0-9]+\\\\n[0-9]+$\" ]];\
    \ then\n    lst_A=$(cat <<EOF\n$1\nEOF\n)\n    lst_B=$2\n  else\n    echo \"Expected\
    \ 2 arguments: $1 <newline-separated, space-separated list> $2\"\n    return 1\n\
    \  fi\n\n  # Convert lst_A into lst_A's values\n  while read -d ' ' lst_A; do\n\
    \    # Convert lst_B into lst_B's values\n    while read -d ' ' lst_B; do\n  \
    \    i=1\n      while [[ $i -le $2 ]]; do\n        ((i++))\n      done\n     \
    \ result=$( \n        echo \"$lst_A\"\n        echo \"$lst_B\"\n        | sort\
    \ -u | paste -d '\\n' -s)\n    done\n  done\n\n  echo \"$result\" | tr '\\n' '\
    \ '", "    local i j k lst_A lst_B\n    local lst_sorted\n    local result\n \
    \   [[ -z $2 ]] && echo \"Usage: $(basename $0) <grid> <k>\" && return 1\n   \
    \ [[ -z $(echo $(tr \" \" \"\\n\" <<< $1) | sort -u | wc -l) ]] || \\\n      \
    \  echo \"Usage: $(basename $0) <grid> <k>\" && return 1\n    [[ -z $(echo $1\
    \ | tr \" \" \"\\n\" | wc -l) ]] || \\\n        echo \"Usage: $(basename $0) <grid>\
    \ <k>\" && return 1\n    lst_B=$(echo $1 | tr \" \" \"\\n\")\n    i=$(($(echo\
    \ $1 | tr \" \" \"\\n\" | wc -l) - 1))\n    k=$2\n    [[ -z $3 ]] && [[ -z $i\
    \ ]] && echo \"Usage: $(basename $0) <grid> <k>\" && return 1\n    if [[ ${k}\
    \ -gt $i ]]; then\n        echo \"$0: k > N*N\" && return 1\n    fi\n    lst_sorted=$(echo\
    \ $1 | tr \" \" \"\\n\" | sort)\n    for j in $(seq 1 $i); do\n        lst_sorted=$(echo\
    \ $lst_sorted | tr \" \" \"\\n\" | sort)\n        lst_A=$(echo $lst_sorted | tr\
    \ \" \" \"\\n\" | tr \"$j\" \"\")\n        lst_B=$(echo $lst_B | tr \" \" \"\\\
    n\" | tr \"$j\" \"\")\n    done\n    # result=$(\n    lst_A=$(echo $lst_sorted\
    \ | tr \" \" \"\\n\" | tr \"1\" \"2\" | sort -u)\n    lst_B=$(echo $lst_B | tr\
    \ \" \" \"\\n\" | tr \"1\" \"2\" | sort -u)\n    lst_A=$lst_A\" \"\" \"\n    lst_B=$lst_B\"\
    \ \"\" \"\n    lst_A=$(echo $lst_A | tr \" \" \"\\n\" | sort -u)\n    lst_B=$(echo\
    \ $lst_B | tr \" \" \"\\n\" | sort -u)\n    [[ -z $lst_A ]] && lst_A=\"1 2 3\"\
    \n    [[ -z $lst_B ]] && lst_B=\"4 5 6\"\n    [[ -z $lst_A ]] && echo \"$0: lst_A\
    \ empty\" && return 1\n    [[ -z $lst_B ]] && echo \"$0: lst_B empty\" && return\
    \ 1\n    \n    echo $lst_A > minPath_output.txt\n    echo $", "    local line=\"\
    $1\"\n    local k=\"$2\"\n    [[ \"$k\" -lt 1 ]] && k=1\n    local arr\n    arr=(\
    \ $(echo \"$line\" | tr '\\n' ' ') )\n    local i j lst_A lst_B\n    local res\n\
    \    for ((i=0; i<${#arr[@]}-1; i++)); do\n        lst_A=( $(echo $arr[$i] | awk\
    \ '{print $1}') )\n        lst_B=( $(echo $arr[$i+1] | awk '{print $1}') )\n \
    \       if (( ${#lst_A} > 0 )); then\n            for ((j=1; j<${#lst_A}; j++));\
    \ do\n                res+=( $(echo \"$lst_A[j] == $lst_B[j]\" |\n           \
    \                 awk '{print \"\\\"\"$1\"\\\"\" }') )\n            done\n   \
    \     fi\n    done\n    echo ${res[*]}", "    local vals=$(echo $1 | tr '\\n'\
    \ ' ')\n    local k=$2\n    local lst_A=$(echo $vals | sed \"s/ /' '/g\" | sort\
    \ | uniq -u)\n    local lst_B=$(echo $vals | sed \"s/ /' '/g\" | sort | uniq -u)\n\
    \    local lst_C=$lst_A\n    local lst_D=$(echo $lst_A | sed \"s/$lst_A\\?//g\"\
    \ | sort | uniq -u)\n    local idx=$k\n    local res=()\n    local i\n\n    while\
    \ [ \"$idx\" -gt 0 ]; do\n        ((idx-=1))\n        ((idx-=1))\n        ((idx-=1))\n\
    \        res=($lst_D[$idx])\n        lst_D=$lst_C\n        lst_C=$(echo $lst_B\
    \ | sed \"s/$res\\?//g\" | sort | uniq -u)\n    done\n    echo $res", "\tlocal\
    \ lines=$1\n\tlocal lineNum=$2\n\tlocal lineNumArr=()\n\tlocal lineStr=()\n\t\
    local currentLineNum=$3\n\tlocal currentLineStr=()\n\tlocal k=$4\n\tlocal i=$5\n\
    \tlocal j=$6\n\tlocal minPath=()\n\n\t# Convert line to array\n\twhile read line;\
    \ do\n\t\tlineStr+=($line)\n\tdone <<< \"$lines\"\n\n\t# Create 2D array from\
    \ line str\n\twhile [ ${#lineStr[@]} -gt 0 ]; do\n\t\tlineNumArr=()\n\t\tcurrentLineStr=()\n\
    \t\tcurrentLineNum=$lineNum\n\t\tcurrentLineStr+=(${lineStr[0]})\n\t\tlineStr=()\n\
    \t\n\t\t# Iterate through line and create 2D array\n\t\twhile read line; do\n\t\
    \t\tlineNumArr+=($line)\n\t\tdone <<< \"$lineStr\"\n\t\t\n\t\t# Iterate through\
    \ line and create 2D array\n\t\twhile [ ${#lineNumArr[@]} -gt 0 ]; do\n\t\t\t\
    lineNum=$lineNumArr[$((${#lineNumArr[@]} - 1))]\n\t\t\tj=$((${lineNum} - 1))\n\
    \t\t\tlineStr+=(\"${lineNumArr[$((${#lineNumArr[@]} - 1))]}\")\n\t\t\tlineNumArr=()\n\
    \t\tdone <<< \"$lineStr\"\n\tdone\n\n\t# Sort the array\n\tlineNumArr=(\"${lineNumArr[@]}\"\
    )\n\tfor i in \"${!lineNumArr[@]}\"; do\n\t\tlineNumArr=(\"${lineNumArr[@]:0:$((i+1))}\"\
    \ \"${lineNumArr[@]:$((i+1))}\")\n\tdone\n\tlineNumArr=(\"${lineNumArr[@]}\")\n\
    \n\t# Iterate through the array\n\tfor i in \"${!lineNumArr[@]}\"; do\n\t\tif\
    \ [ ${#lineNumArr[@]} -eq 1 ]; then\n\t\t\tminPath+=(\"$lineNumArr[$((${i} - 1))]\"\
    )\n\t\telse\n\t\t\tcurrentLineNum=${lineNumArr[$((${i} - 1))]}\n\t\t\tcurrentLineStr+=(${lineNumArr[$((${i}\
    \ - 1))]})\n\t\tfi\n\tdone\n\n\tminPath=(\"${minPath[@]}\")\n\techo \"$minPath\"",
  "  local lst_A\n  local lst_B\n  local i\n  local j\n  local result\n  local cnt\n\
    \n  cnt=0\n  lst_A=$(echo $1 | sed \"s/ /\\\"/g\" | tr '\\n' '\\0')\n  lst_B=$(echo\
    \ $2 | sed \"s/ /\\\"/g\" | tr '\\n' '\\0')\n\n  # first make lst_A and lst_B\
    \ in the correct order and count the number of\n  # cells visited so far\n  for\
    \ i in $(seq 0 $(( ${#lst_A}-1 )) ); do\n    cnt=$(( cnt + ${#lst_A}[$i] ))\n\
    \  done\n  # now sort them and put them in a new array\n  for i in $(seq 0 $((\
    \ ${#lst_A}-1 )) ); do\n    for j in $(seq 0 $(( ${#lst_B}-1 )) ); do\n      if\
    \ [[ ${lst_A[$i]} = \"${lst_B[$j]}\" ]]; then\n        lst_A[$i]=${lst_A[$i]%?}\n\
    \        lst_B[$j]=${lst_B[$j]%?}\n      fi\n    done\n  done\n  # now the problem\
    \ is that we can only visit k cells at the same time,\n  # otherwise we cant visit\
    \ any more, even if we dont visit the same cell\n  # twice, so we just leave it\
    \ for now.\n  if [[ ${#lst_A[@]} -eq ${#lst_B[@]} ]]; then\n    for i in $(seq\
    \ 0 $(( ${#lst_A}-1 )) ); do\n      if [[ ${lst_A[$i]} = \"${lst_B[$i]}\" ]];\
    \ then\n        lst_A[$i]=${lst_A[$i]%?}\n        lst_B[$i]=${lst_B[$i]%?}\n \
    \     fi\n    done\n  fi\n\n  # now we are done with the sorting stuff, we can\
    \ start searching\n  while [[ ${#lst_A[@]} -ge 1 ]]; do\n    cnt=$(( cnt + 1 ))\n\
    \    for i in $(seq 0 $(( ${#lst_A}-1 )) ); do\n      if [[ ${lst_A[$i]} = \"\
    ${lst_B[$i]}\" ]]; then\n        lst_A[$i]=${lst_A[$i]%?}\n        lst_B[$i]=${lst_B[$i]%?}\n\
    \      fi\n    done\n    if [", "    local lst_A=( $(echo $1 | tr \" \" \"\\n\"\
    \ | sed \"s/[[:digit:]]//g\") )\n    local lst_B=( $(echo $1 | tr \" \" \"\\n\"\
    \ | sed \"s/[[:digit:]]//g\") )\n    local j=0\n    for i in $(seq 0 $[$#lst_B]);\
    \ do\n        if [[ $lst_A[$i] -lt $lst_B[$i] ]]; then\n            lst_B[$i]=$lst_A[$i]\n\
    \            lst_A[$i]=$lst_A[$j]\n            lst_B[$j]=$lst_B[$i]\n        \
    \    lst_A[$j]=$lst_A[$i]\n        fi\n        j=$(($j+1))\n    done\n    printf\
    \ \"$lst_B\"", "    # Split input\n    local lst_A=\"`echo $1 | tr '\\n' ','`\"\
    \n    local lst_B=\"`echo $1 | tr '\\n' ','`\"\n    local val=$2\n    # Build\
    \ hash table for cell values\n    local hash=$lst_A\n    for i in $lst_B; do\n\
    \        if [ $hash[$i] ]; then hash[$i]=; else hash[$i]=\"$i\"; fi\n    done\n\
    \    # Build result\n    local res=\"\"\n    local i\n    local j\n    local k\n\
    \    for ((i = 0; i < $val; i++)); do\n        j=0\n        k=0\n        while\
    \ [ $hash[$k] ]; do\n            j=$k\n            k=$((k+1))\n        done\n\
    \        res=\"$res$lst_B[$j]$lst_A[$i]\"\n    done\n    echo \"$res\"", "  echo\
    \ \"$1\" |\n  awk -v n=$2 '{\n      arr=split($0, arr)\n      n=n-1\n      next\n\
    \    }\n    { \n      for(i=1; i<=n; i++) {\n        for(j=1; j<=n; j++) {\n \
    \         if(arr[i] == arr[j] && i != j) {\n            arr[i] = \"\\\"\\\"\"\n\
    \          }\n        }\n      }\n      for(i=1; i<=n; i++) {\n        for(j=1;\
    \ j<=n; j++) {\n          if(arr[i] != arr[j] && j != i) {\n            print\
    \ arr[i]\n          }\n        }\n      }\n    }' ", "    local data=($(echo $1\
    \ |sed \"s/ //g\"))\n    local size=${#data}\n    local max=$2\n    local min=$(($size*($size-1)/2))\n\
    \    local path=($(eval echo \"{${data[*]:$min:$max}\"}\"))\n    local answer\n\
    \    local count=0\n    for (( i=0; i<$size; i++ )); do\n        if [[ ${path[$i]}\
    \ =~ [0-9]$ ]]; then\n            if (( count++ )) && [[ $(echo \"${path[$i]}\"\
    \ | sort -V | head -1) -ne $(echo \"${path[$i - 1]}\" | sort -V | head -1) ]];\
    \ then\n                answer=\"$(echo \"${path[$i]}\" | sort -V | head -1)\"\
    \n                break\n            else\n                answer=\"$(echo \"\
    ${path[$i]}\" | sort -V | head -1)\"\n            fi\n        else\n         \
    \   answer=\"$(echo \"${path[$i]}\" | sort -V | head -1)\"\n            break\n\
    \        fi\n    done\n    echo \"${answer}\"", "  local -n arr=mapfile -t input\
    \ < <(printf \"$1\\n\" \"$2\" | sort -u)\n  echo \"$input[@]\" |\n  sort -u |\n\
    \  awk '\n    BEGIN {\n      a[k+1]=-1;\n      for(i=1;i<=k;i++) a[i]=a[i-1]+1;\n\
    \      max=a[1];\n      for(i=1;i<=k;i++) max=max>a[i]?max:a[i];\n      next\n\
    \    }\n    { for(i=1;i<=k;i++) if($1==a[i]) {\n        if(i>max) max=$1;\n  \
    \    } else if(i>max) {\n          max=$1;\n          a[i]=a[i];\n      }\n  \
    \  }\n    END {\n      for(i=1;i<=k;i++) {\n        s=s==\"\"?\"\":\" \";\n  \
    \      s=s>max?s:\"\\\"$max\\\"\";\n        print s==\"\"?i:s;\n      }\n    }\n\
    \  '", "  local -r grid=$1\n  local -r k=$2\n  local -r lines=$(echo $grid | tr\
    \ ' ' '\\n' | sort -n | uniq -d)\n  local -r rows=$(( ${#lines[@]} / $k ))\n \
    \ local -r cols=$(( ${#lines[@]} % $k ))\n\n  local -r line_index=0\n  local -r\
    \ line_contents=()\n  while [ $line_index -lt $rows ]; do\n    local -r line=$((\
    \ ${lines[$line_index]} * $k + $cols ))\n    line_contents[$line_index]=${lines[$line_index]}\n\
    \    local line_index=$(( $line_index + 1 ))\n  done\n\n  local -r index=0\n \
    \ local -r contents=()\n  while [ $index -lt $line_index ]; do\n    local -r content=$line_contents[$index]\n\
    \    local -r index_next=$(( $index + 1 ))\n    while [ $index_next -lt $line_index\
    \ ]; do\n      local -r next_content=$line_contents[$index_next]\n      if [ \"\
    $content\" == \"$next_content\" ]; then # found a loop\n        break\n      else\n\
    \        local -r next_line=$(( $index_next + 1 ))\n        if [ \"$content\"\
    \ > \"$next_content\" ]; then # found a larger number\n          local -r index_next=$((\
    \ $next_line ))\n        else\n          local -r index_next=$(( $line_index ))\n\
    \        fi\n      fi\n    done\n    index=$(expr $index_next + 1)\n    contents+=(\"\
    $content\")\n  done\n\n  local -r result=$(echo $contents | sort -n)\n  echo $result",
  "  local -n arr=mapfile -t < <(paste -d' ' <(echo \"$1\" | sed 's/ /\\n/g') \"$2\"\
    \ | sort -n | cut -d ' ' -f 1-$2)\n  local -n arr2=mapfile -t < <(paste -d' '\
    \ <(echo \"$1\" | sed 's/ /\\n/g') \"$2\" | sort -n | cut -d ' ' -f $2-1 | sed\
    \ 's/.$//')\n  for idx in \"${!arr[@]}\"; do\n    local -n lst_A=mapfile -t <\
    \ <(echo \"${arr2[$idx]:0:${#arr2[$idx]}-1}\")\n    local -n lst_B=mapfile -t\
    \ < <(echo \"${arr2[$idx]:1:${#arr2[$idx]}-1}\")\n    local -n lst_C=mapfile -t\
    \ < <(echo \"${arr2[$idx]:2:${#arr2[$idx]}-1}\")\n    if [[ \"$idx\" -eq \"0\"\
    \ ]]; then\n      arr2[$idx]=(\"${arr2[$idx]}\" \"${arr2[$idx]:0:${#arr2[$idx]}-1}\"\
    \ \"$idx\")\n    elif [[ \"$idx\" -gt \"0\" ]]; then\n      arr2[$idx]=(\"${arr2[$idx]}\"\
    \ \"${arr2[$idx]:1:${#arr2[$idx]}-1}\" \"$idx\")\n    elif [[ \"$idx\" -lt \"\
    0\" ]]; then\n      arr2[$idx]=(\"${arr2[$idx]}\" \"${arr2[$idx]:2:${#arr2[$idx]}-1}\"\
    \ \"$idx\")\n    fi\n    arr2[$idx]=(\"${arr2[$idx]}\" \"${arr2[$idx]:0:${#arr2[$idx]}-1}\"\
    \ \"${arr2[$idx]:1:${#arr2[$idx]}-1}\" \"${arr2[$idx]:2:${#arr2[$idx]}-1}\")\n\
    \  done\n  echo \"${arr2[@]}\"", "    local grid=$1 k=${2:-3}\n    local lst_A\n\
    \    local lst_B\n    local i\n    local j\n    \n    set -- $grid\n    local\
    \ n=$1\n    shift\n    local m=$1\n    shift\n    local cells\n    \n    local\
    \ answer\n    \n    if [ ! -z \"$grid\" ] && [ ! -z \"$k\" ]; then\n        echo\
    \ \"$grid\" | tr ' ' '\\n' | sort -n | head -n $k > \"$tmp\"\n        lst_A=$(cat\
    \ \"$tmp\")\n        sort -n \"$grid\" | head -n $k > \"$tmp\"\n        lst_B=$(cat\
    \ \"$tmp\")\n        sort -n \"$grid\" | tail -n $k > \"$tmp\"\n        i=$(echo\
    \ $lst_A | wc -l | bc)\n        j=$(echo $lst_B | wc -l | bc)\n        answer=$(echo\
    \ $lst_A | head -n $i | tail -n $j)\n        if [ $i != $j ]; then\n         \
    \   answer=$(echo $answer | tr -d '\\n')\n        fi\n        echo \"$answer\"\
    \ | tr ' ' '\\n' > \"$answer\"\n    fi", "    set -- \"$1\"\n    local lst_A lst_B\n\
    \    local i\n    local j\n    local length\n    length=$(echo $2 | sed -e 's/\\\
    ./\\^&/' -e 's/^\\./\\^&/g')\n    echo \"$2 -> $(eval echo \"\\${!2}\")\"\n  \
    \  for ((i=1; i<=$((2*length-1)); i++)); do\n        if [ \"$i\" -lt \"$length\"\
    \ ]; then\n            ((j=i-1))\n            lst_B=($(echo ${!2} | sed -n -e\
    \ \"s/^\\($i\\).*/'\\1'/p\"))\n            lst_A=($(eval echo \"\\${!2} - $j\"\
    ))\n        else\n            ((j=i-2))\n            lst_A=($(echo ${!2} | sed\
    \ -n -e \"s/^\\($i\\).*/'\\1'/p\"))\n            lst_B=($(eval echo \"\\${!2}\
    \ - $j\"))\n        fi\n        if [ $(echo ${!2}  | wc -c) -gt 1 ] ; then\n \
    \           echo \"$lst_A -> $lst_B\"\n        fi\n    done", "\tlocal -n arr=\"\
    $1\"\n\tlocal -i len=\"${2:-1}\"\n\n\tlocal i\n\tlocal j\n\tlocal str\n\tlocal\
    \ temp\n\tlocal min_list\n\n\tlocal lst_A \n\tlocal lst_B\n\tlocal index\n\n\t\
    while ((len > 0)); do\n\t\tindex=1\n\t\tfor ((i = 0; i < len; i++)); do\n\t\t\t\
    lst_A=\"${arr[index]}\"\n\t\t\tlst_B=\"${arr[index-1]}\"\n\t\t\tstr=\"${lst_A}\"\
    \n\t\t\ttemp=\"${lst_B}\"\n\t\t\tlst_A=\"${lst_A% *}\"\n\t\t\tlst_B=\"${lst_B%\
    \ *}\"\n\t\t\tif [[ \"${str}\" == \"${temp}\" ]]; then\n\t\t\t\tstr=\"${str#*\
    \ }\"\n\t\t\t\ttemp=\"${temp#* }\"\n\t\t\t\tif [[ $lst_A -lt $lst_B ]]; then\n\
    \t\t\t\t\tindex=$(( index + 1 ))\n\t\t\t\telse\n\t\t\t\t\tindex=$(( index - 1\
    \ ))\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tindex=$(( index + 1 ))\n\t\t\tfi\n\t\tdone\n\
    \t\tmin_list=\"$min_list \\\"${arr[index]}\\\"\"\n\t\tlen=$(( len - 1 ))\n\tdone\n\
    \techo \"$min_list\"", "    local line=\"$1\"\n    local N=$2\n    local lineN=`echo\
    \ $line | wc -l`\n    local res=()\n    local j=0\n    local i=0\n    while [\
    \ $i -lt $lineN ]\n    do\n        local v=$($line | cut -d ' ' -f $i)\n     \
    \   local j=0\n        local resTmp=()\n        local k=0 # keep track how many\
    \ times the value v appears\n        local resTmp2=()\n        while [ $j -lt\
    \ $N ]\n        do\n            local line2=`echo $line | cut -d ' ' -f $j`\n\
    \            local j=0\n            local resTmp3=()\n            local k=0\n\
    \            while [ $k -lt $lineN ]\n            do\n                local v2=`echo\
    \ $line2 | cut -d ' ' -f $k`\n                if [ \"$v2\" == \"$v\" ]\n     \
    \           then\n                    resTmp+=($v)\n                    k=$((k+1))\n\
    \                else\n                    resTmp2+=($v)\n                   \
    \ k=$((k+1))\n                fi\n                j=$((j+1))\n            done\n\
    \            resTmp+=($v)\n            j=$((j+1))\n        done\n        res+=(\"\
    ${resTmp[@]}\")\n        i=$((i+1))\n    done\n    echo \"${res[@]}\"", "  local\
    \ lines=$1\n  local len=$2\n  [[ \"$len\" =~ ^[0-9]+$ ]] || { echo \"ERROR: Invalid\
    \ len: $len\" ; exit 1; }\n  [[ \"${#lines[@]}\" =~ ^[0-9]+$ ]] || { echo \"ERROR:\
    \ Invalid lines: $lines\" ; exit 1; }\n  local min_lst_A=\"1\"\n  local min_lst_B=\"\
    1\"\n  local i_min_A=\"1\"\n  local i_min_B=\"1\"\n  local i_max=\"1\"\n  local\
    \ i\n\n  for i in $(seq 1 \"$len\"); do\n    local lst_A=$(echo $min_lst_A | sed\
    \ -n -e \"s/^${i}=\\(.*\\)/\\1/p\")\n    local lst_B=$(echo $min_lst_B | sed -n\
    \ -e \"s/^${i}=\\(.*\\)/\\1/p\")\n    [[ \"$lst_A\" =~ ^[0-9]*$ ]] || { echo \"\
    ERROR: Invalid lst_A: $lst_A\" ; exit 1; }\n    [[ \"$lst_B\" =~ ^[0-9]*$ ]] ||\
    \ { echo \"ERROR: Invalid lst_B: $lst_B\" ; exit 1; }\n    [[ \"${#lst_A[@]}\"\
    \ -eq 0 ]] || [[ \"${#lst_B[@]}\" -eq 0 ]] || { echo \"ERROR: Invalid empty list!\"\
    \ ; exit 1; }\n    [[ \"$lst_A\" -gt \"$lst_B\" ]] || { echo \"ERROR: Invalid\
    \ lst_A > lst_B\" ; exit 1; }\n    [[ \"$lst_B\" -gt \"$lst_A\" ]] || { echo \"\
    ERROR: Invalid lst_B > lst_A\" ; exit 1; }\n    [[ \"${lst_A[0]}\" -gt \"${lst_B[0]}\"\
    \ ]] || { echo \"ERROR: Invalid lexicographic order!\" ; exit 1; }\n    [[ \"\
    ${lst_A[0]}\" -eq 0 ]] || [[ \"${lst_B[0]}\" -eq 0 ]] || { echo \"ERROR: Invalid\
    \ zero list!\" ; exit 1; }\n    [[ \"$lst_A[0]\" -lt \"$lst_B[0]\" ]] || { echo\
    \ \"ERROR: Invalid lexicographic order!\" ; exit 1; }\n    [[ \"$lst_A[0]\" -eq\
    \ \"$lst_B[0]\" ]] || { echo \"ERROR: Invalid equal list!\" ; exit 1; }\n\n  \
    \  min_lst_A=\"$lst_A\"\n    min_lst_B=\"$lst_B\"\n    i_min_A=\"$i\"\n    i_min_",
  "    local array\n    local arr1 arr2 arr3 arr4 arr5 arr6 arr7 arr8 arr9 arr10\n\
    \    local i j k\n    local array2\n    array=$1\n    arr1=${array:0:1}\n    arr2=${array:1:1}\n\
    \    arr3=${array:2:1}\n    arr4=${array:3:1}\n    arr5=${array:4:1}\n    arr6=${array:5:1}\n\
    \    arr7=${array:6:1}\n    arr8=${array:7:1}\n    arr9=${array:8:1}\n    arr10=${array:9:1}\n\
    \    i=$2\n    k=${#arr2}\n    while [[ -z ${array2:-} && $i -lt $k ]]; do\n \
    \       k=$(( ${#arr2} - 1 ))\n    done\n    array2=$arr2\n    while [[ -z ${array2:-}\
    \ && $i -ge $k ]]; do\n        array2=${array2:0:$i}\n        i=$(( ${i} - 1 ))\n\
    \    done\n    array2=$arr2\n    while [[ $i -le $k ]]; do\n        array2=${array2:0:$i}\n\
    \        arr3=$arr3$arr2\n        i=$(( ${i} + 1 ))\n    done\n    while [[ $i\
    \ -ge $k ]]; do\n        array2=${array2:0:$i}\n        arr4=$arr4$arr2\n    \
    \    i=$(( ${i} + 1 ))\n    done\n    while [[ $i -le $k ]]; do\n        array2=${array2:0:$i}\n\
    \        arr5=$arr5$arr2\n        i=$(( ${i} + 1 ))\n    done\n    while [[ $i\
    \ -ge $k ]]; do\n        array2=${array2:0:$i}\n        arr6=$arr6$arr2\n    \
    \    i=$(( ${i} + 1 ))\n    done\n    while [[ $i -le $k ]]; do\n        array2=${array2:0:$i}\n\
    \        arr7=$arr7$arr2\n        i=$(( ${i} + 1 ))\n    done\n    while [[ $i\
    \ -ge $k ]]; do\n        array2=${array2:0:$i}\n        arr8=$arr8$arr2\n    \
    \    ", "    # Split grid into rows and cols\n    local rows=$(( ${#1} / $2 ))\n\
    \    local cols=$(( ${#1} % $2 ))\n\n    # Create a sorted list of all cells (rows\
    \ * cols integers), where every integer\n    # appears only once and in lexicographical\
    \ order\n    # Each integer is on a separate line\n    local cells=$(cat -n ${1}\
    \ | sort -k 1 -n)\n\n    # Create a list in which every line contains two values\
    \ -- each of the\n    # cells covered on the current line\n    # Each line is\
    \ enclosed in quotes\n    local lst=$(cat -n ${cells} | sed -n \"s/^/\\\"&\\\"\
    /g\" | paste -sd ' ')\n\n    # Find index i such that lst_A[i] < lst_B[i]\n  \
    \  # This is because lst_A goes first\n    local i=0\n    local i=1\n    local\
    \ j=$(( ${#lst} - 1 ))\n    while [ ${#lst} -gt 0 ]; do\n        local tst_A=$(echo\
    \ $lst | awk -v i=\"${i}\" 'BEGIN{ while ($i < '${i}') print lst_A[$i++] }')\n\
    \        local tst_B=$(echo $lst | awk -v j=\"${j}\" 'BEGIN{ while ($j < '${j}')\
    \ print lst_B[$j--] }')\n        if [[ ${#tst_A} -lt ${#tst_B} ]]; then\n    \
    \        (( i=${j} ))\n        fi\n        if [[ ${#tst_A} -ge ${#tst_B} ]]; then\n\
    \            (( j=${i} ))\n        fi\n    done\n\n    # Append the two lists\
    \ together and sort them\n    # Remove quotes from both lists\n    lst=$( echo\
    \ $lst | sed 's/\"//g' | sort | paste -sd ' ')\n\n    # Return sorted list\n \
    \   echo \"${lst//$'\\n'/;}\" ", "  local rows=\"$1\"\n  local N=\"$2\"\n  local\
    \ i j vals paths\n  vals=()\n  paths=()\n  read -a vals <<< \"$rows\"\n  i=0\n\
    \  j=N-1\n  while [ $i -lt $N ] && [ $j -lt $N ]\n  do\n    paths[$i]=\"\\\"${vals[$i]}\\\
    \"\"\n    i=$(($i+1))\n    j=$(($j-1))\n  done\n  sort -u \"${paths[*]}\"", " \
    \ local i j lst_A lst_B k\n  lst_A=( $(echo \"$1\" | tr -d \"\\n\") )\n  lst_B=(\
    \ $(echo \"$1\" | tr -d \"\\n\") )\n  (( k = ${#lst_B[@]}+1 ))\n  for (( i = 1;\
    \ i <= ${#lst_A[@]}; i++ )); do\n    for (( j = 1; j <= k; j++ )); do\n      [[\
    \ \"${lst_A[i]}${lst_B[j]}\" -gt \"${lst_A[i-1]}${lst_B[j-1]}\" ]] || break\n\
    \    done\n    if (( j == k )); then\n      echo -n ${lst_A[i-1]}\n      return\n\
    \    fi\n  done", "  local -r grid=$1\n  local -r k=$2\n  local -r N=${#grid[@]}\n\
    \  local -i cnt\n  local -r cur\n  local -r cnt2\n  local -r lst_A\n  local -r\
    \ lst_B\n  local -i j\n\n  for ((i = 1; i <= N; i++))\n  do\n    cnt=0\n    for\
    \ ((j = 1; j <= i; j++))\n    do\n      cnt2=$((cnt+1))\n      if [[ ${grid[$((j\
    \ - 1))]} < ${grid[$((j - 1))]} > ${grid[$j]} ]]\n      then\n        lst_A[$cnt2]=${grid[$((j\
    \ - 1))]}\n        lst_B[$cnt2]=${grid[$((j - 1))]}\n      else\n        lst_A[$cnt2]=${grid[$((j\
    \ - 1))]}\n        lst_B[$cnt2]=${grid[$((j - 1))]}\n      fi\n      cnt=$((cnt2+1))\n\
    \    done\n    cnt=0\n    for ((j = 1; j <= i; j++))\n    do\n      if [[ ${grid[$((j\
    \ - 1))]} > ${grid[$((j - 1))]} < ${grid[$j]} ]]\n      then\n        lst_A[$cnt]=${grid[$((j\
    \ - 1))]}\n        lst_B[$cnt]=${grid[$((j - 1))]}\n      else\n        lst_A[$cnt]=${grid[$((j\
    \ - 1))]}\n        lst_B[$cnt]=${grid[$((j - 1))]}\n      fi\n      cnt=$((cnt+1))\n\
    \    done\n    for ((j = 1; j <= i; j++))\n    do\n      cur=${grid[$((j - 1))]}\n\
    \      if [[ ${lst_A[$cnt]} > ${cur} ]]\n      then\n        grid[$((j - 1))]=${lst_A[$cnt]}\n\
    \      fi\n      if [[ ${lst_B[$cnt]} > ${cur} ]]\n      then\n        grid[$((j\
    \ - 1))]=${lst_B[$cnt]}\n      fi\n      cnt=$((cnt+1))\n    done\n  done\n  echo\
    \ ${grid[@]}", "    local -r lines=$1\n    local -r k=$2\n    local -r arr=($(cat\
    \ <<<\"$lines\"))\n\n    local -r lst_A\n    local -r lst_B\n\n    local -i i\n\
    \    local j\n    local result\n\n    # First pass: find all the cells that can\
    \ go to \"k\"\n    for i in $(seq \"${#arr[@]}\" -1 -1 -1 ); do\n        if ((\
    \ i < k )); then\n            lst_A+=(${arr[i]})\n        fi\n    done\n\n   \
    \ # Second pass: find the indices of the cells that can go to \"k\"\n    lst_B=($(for\
    \ i in $(seq \"${#lst_A[@]}\" -1 -1 -1 ); do echo \"${lst_A[$i]}\"; done))\n\n\
    \    # Third pass: sort the lists\n    lst_B=($(sort <<<\"${lst_B[@]}\"))\n\n\
    \    # Fourth pass: add the indices to the beginning of the sorted list\n    local\
    \ j k1 k2 k3 k4 k5 k6 k7 k8 k9 k10\n    k1=0\n    for i in $(seq \"${#arr[@]}\"\
    \ -1 -1 -1 ); do\n        if (( i < k )); then\n            ((j+=$i))\n      \
    \      lst_B+=(\"${lst_A[$j]}\")\n        fi\n    done\n\n    for ((i=1;i<10;i++));\
    \ do\n        for ((j=1;j<10;j++)); do\n            if (( ${arr[lst_B[k1]]} >\
    \ ${arr[lst_B[k2]]} ));then\n                k1=$((k1+1))\n                k2=$((k2+1))\n\
    \            elif (( ${arr[lst_B[k1]]} < ${arr[lst_B[k2]]} ));then\n         \
    \       k2=$((k2+1))\n            fi\n        done\n        k3=0\n        for\
    \ ((j=1;j<10;j++)); do\n            if (( ${arr[lst_B[k3]]} > ${arr[lst_B[k4]]}\
    \ ));then\n                k3=$((k3+1))\n                k4=$((k4+1))\n      \
    \      elif (( ${arr[lst_B[k3]]} < ${arr[lst_B[k4]]} ));then\n               \
    \ k4=$((k4+1))\n            fi\n        done\n        k5=0\n        for ((j=1;j<10;j++));\
    \ do\n            if (( ${arr[lst_B[k5]]} > ${arr[lst_B[k", "    local lines=$1\n\
    \    local k=$2\n    local arr=()\n    local arr2=()\n    local lst_A=()\n   \
    \ local lst_B=()\n    local i=\n    local j=\n    while read line; do\n      \
    \  arr2+=($line)\n    done < $lines\n    arr=(\"${arr2[*]}\" )\n    for (( i=0;\
    \ i<${#arr[@]}; i++ )); do\n        local val=${arr[i]}\n        lst_A+=($val)\n\
    \    done\n    for (( j=0; j<${#arr[@]}; j++ )); do\n        local val=${arr[j]}\n\
    \        lst_B+=($val)\n    done\n    echo ${lst_A[@]}\n    echo ${lst_B[@]}\n\
    \    lst_A=(${lst_A[@]} \"<EOF>\" \"<EOF>\" )\n    lst_B=(${lst_B[@]} \"<EOF>\"\
    \ \"<EOF>\" )\n    for (( i=0; i<${#arr[@]}; i++ )); do\n        local val=${arr[i]}\n\
    \        local indx=${#lst_A[@]} - ${#lst_B[@]}\n        local indx1=${indx}\n\
    \        for (( j=0; j<${#lst_B[@]}; j++ )); do\n            if [ ${lst_A[$indx+$j]}\
    \ = \"<EOF>\" ]; then\n                ((indx1))\n            fi\n        done\n\
    \        if [ ${lst_A[$indx+$j]} = \"<EOF>\" ]; then\n            ((indx1))\n\
    \        fi\n    done\n    echo ${arr[@]}\n    arr2=()\n    lst_A=()\n    lst_B=()\n\
    \    for (( i=0; i<${#arr[@]}; i++ )); do\n        arr2+=(${arr[$i]})\n    done\n\
    \    lst_A=(${arr2[@]})\n    lst_B=(${arr2[@]})\n    lst_A=(${lst_A[@]} \"<EOF>\"\
    \ \"<EOF>\" )\n    lst_B=(${lst_B[@]} \"<EOF>\" \"<EOF>\" )\n    echo ${lst_A[@]}\n\
    \    echo ${lst_B[@]}\n    return ${arr[@]}", "    local lst_A=\"$1\"\n    local\
    \ k=\"$2\"\n    local lst_B=()\n    for i in $(seq 1 $((k+1))); do\n        local\
    \ lst_B+=(\"$lst_A$i\")\n    done\n    echo \"${lst_B[@]}\"", "    local i j\n\
    \    local lst_A lst_B\n    local lst_temp\n    local lst_temp2\n    local i\n\
    \    local lst_temp3\n    local lst_temp4\n    local j\n    local lst_temp5\n\
    \    local lst_temp6\n    local j\n    local count\n    local temp\n    local\
    \ temp_1\n    local temp_2\n    local temp_3\n    local temp_4\n    local temp_5\n\
    \    local temp_6\n    local temp_7\n    local temp_8\n    local temp_9\n    local\
    \ temp_10\n    local temp_11\n    local temp_12\n    local temp_13\n    local\
    \ temp_14\n    local temp_15\n    local temp_16\n    local temp_17\n    local\
    \ temp_18\n    local temp_19\n    local temp_20\n    local temp_21\n    local\
    \ temp_22\n    local temp_23\n    local temp_24\n    local temp_25\n    local\
    \ temp_26\n    local temp_27\n    local temp_28\n    local temp_29\n    local\
    \ temp_30\n    local temp_31\n    local temp_32\n    local temp_33\n    local\
    \ temp_34\n    local temp_35\n    local temp_36\n    local temp_37\n    local\
    \ temp_38\n    local temp_39\n    local temp_40\n    local temp_41\n    local\
    \ temp_42\n    local temp_43\n    local temp_44\n    local temp_45\n    local\
    \ temp_46\n    local temp_47\n    local temp_48\n    local temp_49\n    local\
    \ temp_50\n    local temp_51\n    local temp_52\n    local temp_53\n    local\
    \ temp_54\n    local temp_55\n    local temp_56\n    local temp_57\n    local\
    \ temp_58\n    local temp_59\n    local temp_60\n    local temp_61\n    local\
    \ temp_62\n    local temp_63\n    local temp_64\n    local temp_65\n    local\
    \ temp_66\n    local temp_67\n    local temp_68\n    local temp_69\n    local\
    \ temp_70\n    local temp_71\n    local temp_72\n    local temp_73\n    local\
    \ temp_74\n    local temp_75\n    local temp_76\n    local temp_77\n    local\
    \ temp_78\n    local temp_79\n    local temp_80\n    local temp_81\n    local\
    \ temp_82\n    local temp_83\n    local temp_84\n    local temp_85\n    local\
    \ temp_86\n    local temp_87\n    local ", "    local grid=$1\n    local len=$2\n\
    \    local lst_A\n    local lst_B\n    local ret\n\n    # Convert the given grid\
    \ into a string with newline-separated lines\n    # in the form of 'row column\
    \ value'\n    grid=$(echo \"$grid\" | sed -e 's/^[ \\t]*//' -e 's/[ \\t]*$//')\n\
    \n    # Convert each line into an array\n    lst_A=$(echo \"$grid\" | sed -e 's/^\\\
    ([0-9]*\\) *\\([0-9]*\\) *$/\\1 \\2/')\n    lst_B=$(echo \"$grid\" | sed -e 's/^\
    \ *\\([0-9]*\\) *\\([0-9]*\\) *$/\\1 \\2/')\n\n    # Sort both lists (lst_A and\
    \ lst_B) and get their lexicographical\n    # order\n    lst_A=$(sort -k 1 \"\
    ${lst_A}\")\n    lst_B=$(sort -k 1 \"${lst_B}\")\n\n    # If the number of elements\
    \ is smaller than or equal to the given\n    # length, then return an empty list\n\
    \    len=$((${#lst_A} <= ${#lst_B} || ${#lst_A} <= ${len}))\n    if [[ ${len}\
    \ -eq 0 ]]; then\n        return 0\n    fi\n\n    # Get the index to start at\
    \ (i.e. the first element of the first list\n    # that is lexicographically less\
    \ than the element of lst_B)\n    i=0\n    while [[ ${lst_B[i]} -gt ${grid} ]];\
    \ do\n        i=$((i + 1))\n    done\n    # Increment the index by 1, since we\
    \ want to start at the\n    # second element of the first list that is lexicographically\
    \ less\n    # than the element of lst_B\n    i=$((i + 1))\n\n    # Traverse the\
    \ elements of the first list that are lexicographically\n    # less than the element\
    \ of lst_B\n    while  ((${#lst_A} > 0)); do\n        # If the current cell is\
    \ not one of the current cells,\n        # then add it to the list of current\
    \ cells\n        if [[ \"${grid}\" != \"${lst_A[i]}\" ]]; then\n            lst+=(\"\
    ${grid}\")\n        fi\n\n        # Move to the next element in the first list\
    \ that is lexicographically\n        # less than the current element of lst_A\n\
    \        i=$((i + 1))\n    done\n\n    # Add all the elements of the first list\
    \ that are lexicographically\n    # less than the element of lst_B to the list\
    \ of current cells\n    lst+=(\"${lst_A[i]}\")\n\n    # Traverse the ", "    echo\
    \ \"$1\"\n    local -n grid=$1\n    local -n vals=$2\n\n    local -n arr_A=$grid\n\
    \    local -n arr_B=$(echo $grid|sed 's/^\"//;s/\"$//;s/ /\\n/g')\n    local -n\
    \ lst_A\n    local -n lst_B\n    local -i i\n    local j\n\n    for (( i=1; i\
    \ <= vals; i++ )); do\n        lst_A=()\n        lst_B=()\n        for (( j=1;\
    \ j <= i; j++ )); do\n            if [ ${grid[$j]:?} != \"N\" ]; then\n      \
    \          lst_A+=(${grid[$j]:?})\n            fi\n        done\n        for ((\
    \ j=1; j <= i; j++ )); do\n            if [ ${grid[$j]:?} != \"N\" ]; then\n \
    \               lst_B+=(${grid[$j]:?})\n            fi\n        done\n       \
    \ lst_A+=( $(sort -n \"${lst_A[*]}\" | head -n ${i-1}) )\n        lst_B+=( $(sort\
    \ -n \"${lst_B[*]}\" | head -n ${i-1}) )\n    done\n    lst_A+=( $(sort -n \"\
    ${arr_A[*]}\" | head -n ${i-1}) )\n    lst_B+=( $(sort -n \"${arr_B[*]}\" | head\
    \ -n ${i-1}) )\n    echo $(printf \"${arr_A[*]}\" \"$lst_A\" | head -n ${i})\n\
    \    echo $(printf \"${arr_B[*]}\" \"$lst_B\" | head -n ${i})", "    local -n\
    \ g=\"$1\" num=\"$2\";\n    local -a lst=() i\n    for ((i=0; i<num; i++)); do\n\
    \        lst=( \"${lst[@]}\" \"$( cut -d ' ' -f \"$i\" <<< \"${g}\" )\" )\n  \
    \  done\n    for ((i=0; i<num; i++)); do\n        if [ \"${lst[i]}\" = \"$( cut\
    \ -d ' ' -f \"$i\" <<< \"${g}\" )\" ]; then\n            echo \"$( cut -d ' '\
    \ -f \"$i\" <<< \"${g}\" )\"\n        fi\n    done", "  local lst_A\n  local lst_B\n\
    \  local lst_C\n  local lst_D\n  local i j k k min_A min_B min_C\n  local lst_S\n\
    \  local lst_T\n  lst_A=$(echo $1 | awk '{gsub(/[[:space:]]+/, \"\"); print $1}'\
    \ | tr '\\n' ' ')\n  lst_B=$(echo $1 | awk '{gsub(/[[:space:]]+/, \"\"); print\
    \ $2}' | tr '\\n' ' ')\n  k=${2:-1}\n  lst_C=$(echo $lst_A | awk -F'\\n' '{print\
    \ $1}')\n  lst_D=$(echo $lst_A | awk -F'\\n' '{print $2}')\n  lst_S=$(echo $lst_A\
    \ | awk -F'\\n' '{print $1}')\n  lst_T=$(echo $lst_B | awk -F'\\n' '{print $1}')\n\
    \  min_A=$lst_A[0]\n  min_B=$lst_B[0]\n  min_C=$lst_C[0]\n  min_D=$lst_D[0]\n\
    \  while [ \"$k\" -le \"$k\" ]; then\n    if [[ ${#lst_S} -eq \"$k\" ]]; then\n\
    \      lst_S=${lst_S} ${lst_T}\n    fi\n    i=${lst_A[${k}]}\n    j=${lst_B[${k}]}\n\
    \    lst_C=$lst_C${lst_D[${k}]}\n    if [[ \"$j\" < \"$i\" ]]; then\n      lst_S=${lst_S}\
    \ ${lst_C}\n      lst_T=$lst_T${lst_A[${k}]}\n      lst_D=$lst_D${lst_B[${k}]}\n\
    \      lst_A=$lst_A${lst_B[${k}]}\n      lst_B=$lst_B${lst_A[${k}]}\n      lst_C=$lst_C${lst_A[${k}]}\n\
    \      lst_D=$lst_D${lst_B[${k}]}\n      k=${k-1}\n      continue\n    fi\n  \
    \  if [[ \"$i\" < \"$j\" ]]; then\n      lst_A=${lst_A} ${lst_C}\n      lst_B=${lst_B}\
    \ ${lst_D}\n      lst_", "\tlocal lst_A lst_B k\n\twhile read lst_A && read k;\
    \ do\n\t\tlst_A+=\" ${lst_A}\"\n\t\tlst_B+=\" ${lst_B}\"\n\tdone < <(sort \"$1\"\
    \ | sed \"s/ /\\n/g\" | sort -k1 -k2 -k3 )\n\tlocal -i i\n\tlocal arr\n\tlst_A=(\
    \ \"${lst_A}\" )\n\tlst_B=( \"${lst_B}\" )\n\ti=$(( $k - 1 ))\n\tarr=( \"${lst_A[i]}\"\
    \ \"${lst_B[i]}\" )\n\tj=$(( ${#arr[@]} -1 ))\n\twhile [[ ${#arr[@]} -eq 0 ]];\
    \ do\n\t\tj=$(( j - 1 ))\n\t\tarr=( \"${lst_A[$j]}\" \"${lst_B[$j]}\" )\n\tdone\n\
    \techo ${arr[@]}", "  local line=$1 k=$2\n  [ $# -lt 2 ] || return 0\n  local\
    \ -n arr=$line\n  local -a nums\n  read -r -a nums <<< \"$line\"\n  local i j\
    \ num\n  local min_path\n  min_path=$nums[0]\n  num=${min_path}\n  j=1\n  for\
    \ ((i=0; i < k; i++)); do\n    while (( ${nums[$i]} > num )) && [[ $j -gt 0 ]];\
    \ do\n      (( j-- ))\n    done\n    arr[$j]=$num\n    (( num-- ))\n    (( nums[$((i-1))]--\
    \ ))\n    (( nums[$((i-1))]++ ))\n    (( nums[$((i+1))]-- ))\n    (( nums[$((i+1))]++\
    \ ))\n  done\n  arr[$((j-1))]=$num\n  arr=(${arr[@]:1:((k-2)+2)})\n  echo -n ${arr[@]}",
  "    local arr=($1)\n    local num=$2\n    local str=\"${arr[*]}\"\n\n    local\
    \ len=$((${#arr[@]}-1))\n    for (( i = 1; i <= num; i++ ))\n    do\n        for\
    \ (( j = 1; j <= len; j++ ))\n        do\n            if [ $(( ${str:$j:1} ==\
    \ '\"' )) -eq 0 ]\n            then\n                break\n            fi\n \
    \       done\n        arr[$j+1]=$(echo $str | sed -n \"s/.\\\"$j\\\"/\\1/p\")\n\
    \    done\n\n    echo ${arr[@]}", "\tlocal lines=$1;\n\tlocal k=$2;\n\tlocal index=$((k\
    \ - 1));\n\tlocal count=0;\n\tlocal temp;\n\tlocal output;\n\tlocal c;\n\tlocal\
    \ i;\n\tlocal j;\n\tlocal x;\n\tlocal y;\n\tlocal z;\n\tlocal lst_A;\n\tlocal\
    \ lst_B;\n\t\n\tlst_A=$(echo $lines | tr \" \" \"\\n\" | sort | uniq)\n\tlst_B=$(echo\
    \ $lines | tr \" \" \"\\n\" | sort | uniq)\n\t\n\twhile [ $index -lt $k ]; do\n\
    \t\ttemp=\"\"\n\t\t\n\t\tc=$(echo $lst_A[index] | awk '{print $1}')\n\t\t\n\t\t\
    x=$(echo $lst_A[index] | awk '{print $2}')\n\t\t\n\t\ty=$(echo $lst_A[index] |\
    \ awk '{print $3}')\n\t\t\n\t\ti=$((c - 1))\n\t\tj=$((x + 1))\n\t\t\n\t\t\n\t\t\
    while [ $i -le $k ]; do\n\t\t\ttemp=$temp$c\n\t\t\ti=$((i + 1))\n\t\tdone\n\t\t\
    \n\t\twhile [ $j -le $k ]; do\n\t\t\ttemp=$temp$x\n\t\t\tj=$((j + 1))\n\t\tdone\n\
    \t\t\n\t\twhile [ $i -le $k ]; do\n\t\t\ttemp=$temp$y\n\t\t\ti=$((i + 1))\n\t\t\
    done\n\t\t\n\t\twhile [ $j -le $k ]; do\n\t\t\ttemp=$temp$j\n\t\t\tj=$((j + 1))\n\
    \t\tdone\n\t\t\n\t\ttemp=\"$temp\"\n\t\t\n\t\ttemp=$(echo $temp | tr -d '\\n')\n\
    \t\t\n\t\toutput=$output$temp\n\t\t\n\t\tindex=$((index + 1))\n\tdone\n\t\n\t\
    while [ $index -lt $k ]; do\n\t\ttemp=\"\"\n\t\t\n\t\tc=$(echo $lst_B[index] |\
    \ awk '{print $1}')\n\t\t\n\t\tx=$(echo $lst_B[index] | awk '{print $2}')\n\t\t\
    \n\t\ty=$(echo $lst_B[index] | awk '{print $3}')\n\t\t\n\t\ti=$((c + 1))\n\t\t\
    j=$((x + 1))\n\t\t\n\t\t\n\t\twhile [ $i -le $k ]; do\n\t\t\ttemp=$temp$c\n\t\t\
    \ti=$((i + 1))\n\t\tdone\n\t\t\n\t\twhile [ $j -le $k ]; do\n", "  declare -i\
    \ N=\"${#}\"\n  [[ -z \"${N}\" ]] && echo \"Input N should be a positive integer.\"\
    \ && exit 1\n  [[ -z \"${1}\" ]] && echo \"Input first argument should be non-empty\
    \ string.\" && exit 1\n  [[ -z \"${2}\" ]] && echo \"Input second argument should\
    \ be integer.\" && exit 1\n  [[ \"${N}\" -gt \"2\" ]] && echo \"Input N should\
    \ be greater than 2.\" && exit 1\n  [[ \"${N}\" -lt \"2\" ]] && echo \"Input N\
    \ should be less than 2.\" && exit 1\n  [[ \"${2}\" -lt \"1\" ]] && echo \"Input\
    \ second argument should be greater than 1.\" && exit 1\n  [[ \"${2}\" -gt \"\
    N\" ]] && echo \"Input second argument should be less than N.\" && exit 1\n  declare\
    \ -i c=\"${1}\"\n  declare -i k=\"${2}\"\n  [[ -z \"${k}\" ]] && echo \"Input\
    \ k should be a positive integer.\" && exit 1\n  [[ -z \"${c}\" ]] && echo \"\
    Input c should be a non-empty string.\" && exit 1\n  [[ \"${c}\" == \"${1}\" ]]\
    \ && echo \"Input c should be a different string from input 1.\" && exit 1\n \
    \ [[ \"${c}\" != \"${2}\" ]] && echo \"Input c should be a different string from\
    \ input 2.\" && exit 1\n  declare -i g=\"${N}\"\n  [[ -z \"${g}\" ]] && echo \"\
    Input N should be a positive integer.\" && exit 1\n  declare -i r=\"${N}\"\n \
    \ [[ -z \"${r}\" ]] && echo \"Input N should be a positive integer.\" && exit\
    \ 1\n  \n  declare -i d\n  declare -i j\n  \n  [[ -z \"${c}\" ]] && echo \"Input\
    \ c should be a non-empty string.\" && exit 1\n  \n  declare -i lst_A\n  lst_A=()\n\
    \  \n  while true; do\n    lst_B=()\n    lst_C=()\n    lst_D=()\n    \n    while\
    \ true; do\n      [[ -z \"${c}\" ]] && break\n      echo \"${c}\"\n      \n  \
    \    \n      [[ \"${c}\" == \"${1}\" ]] && break \n      \n      [[ \"${c}\" ==\
    \ \"${2}\" ]] && break \n      \n      \n      [[ -z \"${c}\" ]] && break\n  \
    \    echo \"${c}\"\n      \n      \n      [[ -z \"${c}\" ]] && break\n      echo\
    \ \"${c}\"\n      \n      \n      \n      \n      \n      [[ \"${c}\" == \"${1}\"\
    \ ]] && break \n      \n      \n      [[ \"${c}\" == \"${2}\" ]] && break \n \
    \     \n      \n      [[ -z \"${c}\" ]] && ", "  local lst_A=\"$1\"\n  local k=\"\
    $2\"\n  local i j str\n  str=\"$(echo \"${lst_A}\" | tr '\\n' ' ')\"\n  for ((i\
    \ = 1; i <= k; i++)); do\n    for ((j = 1; j <= i; j++)); do\n      [[ \"$str\"\
    \ == \"$str\" | grep -q \" $j\" ]] && [[ $str =~ $( echo \"${lst_A}\" | sed \"\
    s/ ${j} / ${j} / \" ) ]] && return\n    done\n  done\n  echo \"$lst_A\"", "  \
    \  [[ $# != 2 ]] && { echo \"Usage: $(basename $0) <grid> <k>\" ; exit 1; }\n\
    \    local grid=$1\n    local k=$2\n    local arr=()\n    local i=0\n    local\
    \ j=0\n    local cur=$(echo \"$grid\" | tr ' ' '\\n' | sort -n)\n    local grid=\"\
    \"\n    for x in \"${arr[@]}\"; do\n        grid=\"$grid \\\"$x\\\"\"\n    done\n\
    \    while [ $i -lt $k ]; do\n        arr=($(echo \"$cur\" | tr ' ' '\\n' | sort\
    \ -n))\n        for j in $(seq 0 $(( ${#arr[@]} - 1 ))); do\n            [[ ${arr[$j]}\
    \ -gt ${arr[$((j + 1))]} ]] && break\n        done\n        cur=\"${arr[$j]}\"\
    \n        i=$(( i + 1 ))\n    done\n    arr=($(echo \"$cur\" | tr ' ' '\\n' |\
    \ sort -n))\n    for j in $(seq 0 $(( ${#arr[@]} - 1 ))); do\n        [[ ${arr[$j]}\
    \ -gt ${arr[$((j + 1))]} ]] && break\n    done\n    echo -n \"${arr[@]:1:$(( ${#arr[@]}\
    \ - 1 ))}\"", "  local g=\"$1\"\n  local k=\"$2\"\n\n  local -a lst_A\n  local\
    \ -a lst_B\n  local i j\n\n  local j1 j2\n  local mn mn1 mn2\n  local p1 p2\n\n\
    \  local line\n  local x\n\n  IFS=$'\\n' read -d '' -a lst_A <<<\"$g\"\n  IFS=$'\
    \ ' read -d '' -a lst_B <<<\"$g\"\n\n  lst_B[${#lst_B[@]}-1]=\n  lst_A[${#lst_A[@]}-1]=\n\
    \n  while [ \"$k\" -gt 0 ]; do\n    j1=${#lst_A[@]}-1\n    j2=${#lst_B[@]}-1\n\
    \    if [ -z \"${lst_A[$j1]}\" ]; then\n      ((j1--))\n      lst_A[${#lst_A[@]}-1]=\n\
    \    fi\n    if [ -z \"${lst_B[$j2]}\" ]; then\n      ((j2--))\n      lst_B[${#lst_B[@]}-1]=\n\
    \    fi\n    ((j1--))\n    ((j2--))\n\n    p1=\"${lst_A[$j1]}\"\n    p2=\"${lst_B[$j2]}\"\
    \n\n    if [ \"$p1\" = \"$p2\" ]; then\n      ((k--))\n      ((j1--))\n      ((j2--))\n\
    \      ((j1--))\n      ((j2--))\n      break\n    elif [ \"$p1\" -lt \"$p2\" ];\
    \ then\n      ((k--))\n      ((j1--))\n      ((j2--))\n      ((j1--))\n      ((j2--))\n\
    \      lst_B[${#lst_B[@]}-1]=\"${lst_A[$j1]}\"\n      lst_A[${#lst_A[@]}-1]=\"\
    ${lst_B[$j2]}\"\n      break\n    elif [ \"$p1\" -gt \"$p2\" ]; then\n      ((k--))\n\
    \      ((j1--))\n      ((j2--))\n      ((j1--))\n      ((j2--))\n      lst_A[${#lst_A[@]}-1]=\"\
    ${lst_A[$j1]}\"\n      lst_B[${#lst_B[@]}-1]=\"${lst_B[$j2]}\"\n      break\n\
    \    elif [ \"$p1\" = \"$p1\" ", "  read -a lst <<< \"$1\"\n  local k=\"$2\"\n\
    \  \n  local i j path_arr len\n  local path_arr_tmp\n  local min_path_arr\n  \n\
    \  local cur_i\n  local cur_j\n  \n  path_arr=()\n  min_path_arr=()\n  \n  path_arr_tmp=0\n\
    \  \n  for ((i=0; i<${#lst[@]}; i++)); do\n    path_arr+=(\"\\\"${lst[i]}\\\"\"\
    )\n  done\n  \n  for ((i=0; i<${#path_arr[@]}; i++)); do\n    path_arr_tmp=$((path_arr_tmp\
    \ + ${#path_arr[i]}))\n  done\n  \n  for ((i=0; i<${#path_arr[@]}; i++)); do\n\
    \    len=$((${path_arr[i]:${path_arr_tmp}}))\n    \n    for ((j=0; j<${#path_arr[@]};\
    \ j++)); do\n      if [[ $((path_arr[j]:$((path_arr[j]-len)))) < $((path_arr[j]):$((path_arr[j]+len)))\
    \ ]]; then\n        path_arr_tmp=$((path_arr[j]))\n        break\n      fi\n \
    \   done\n  done\n  \n  cur_i=1\n  cur_j=path_arr_tmp\n  \n  path_arr=()\n  \n\
    \  for ((i=0; (i<${#lst[@]}) && (path_arr[@]<k); i++)); do\n    path_arr+=(\"\\\
    \"${lst[i]}\\\"\")\n  done\n  \n  while (( ${#path_arr[@]} > k )); do\n    path_arr=(${path_arr[@]:1:k})\n\
    \    (( k-- ))\n  done\n  \n  while (( ${#path_arr[@]} > 0 )); do\n    path_arr=(${path_arr[@]:1:${#path_arr[@]}})\n\
    \  done\n  \n  min_path_arr=()\n  \n  for ((i=0; i<${#path_arr[@]}; i++)); do\n\
    \    min_path_arr+=(\"\\\"${path_arr[i]}\\\"\")\n  done\n  \n  echo \"${min_path_arr[@]}\"",
  "    local n=$2\n    local lst=\"$(echo \"$1\" | sed 's/ /\" \"/g')\"\n    local\
    \ len=$(( $(echo \"$lst\" | wc -w) - 1 ))\n    local lstA=\"$(echo \"$lst\" |\
    \ sort -n)\"\n    local lstB=\"$(echo \"$lst\" | sort -n)\"\n    local i\n   \
    \ local j\n    local result=\"\"\n    for (( i = 1; i <= n; i++ )); do\n     \
    \   for (( j = 1; j <= n; j++ )); do\n            if [[ \"$lstA[$i]\" == \"$lstB[$j]\"\
    \ ]]; then\n                result+=\"\\\"$lstA[$i]\\\"\\n\" \n              \
    \  (( j++ ))\n            fi\n        done\n    done\n    echo \"$result\"", " \
    \ [[ $2 =~ (^[0-9]*$)|(^-?[0-9]+$)$ ]]\n  \n  local i; local j; local list; local\
    \ list1; local list2;\n  \n  list=$1; list1=${list//$'\\n'/ }; list2=${list1//$'\\\
    n'/ }; list3=${list2//$'\\n'/ }; \n  \n  for i in $(seq 0 $((${#list3} -1 )));\
    \ do\n    for j in $(seq 0 $((${#list3} -1 ))); do\n      local cnt=$(echo \"\
    ${list3[i]}${list3[j]}\" | wc -w);\n      if [[ ${cnt} == 0 ]]; then\n       \
    \ list1[$i]=$j\n      fi\n    done\n  done\n  \n  echo \"${list1[$2]}\"", "  local\
    \ GRID_STR=$1\n  local GRID_N=$2\n  local k tmp tmp2 tmp3 tmp4\n  local LIST LIST2\
    \ LIST3 LIST4 LIST5 LIST6 LIST7 LIST8 LIST9 LIST10\n  local N\n  local GRID_N1\n\
    \  local GRID_N2\n  local i j k1 k2 i2 j2 len\n\n  # Make sure that $GRID_STR\
    \ contains only space-separated integers.\n  tmp=$(echo $GRID_STR | sed 's/ /\\\
    n/g')\n  tmp2=$(echo $tmp | sed 's/^ *//g')\n  tmp3=$(echo $tmp2 | sed 's/ *$//g')\n\
    \  \n  # Make sure that $GRID_N contains only integers.\n  tmp4=$(echo $GRID_N\
    \ | sed 's/ /\\n/g')\n  tmp5=$(echo $tmp4 | sed 's/^ *//g')\n  tmp6=$(echo $tmp5\
    \ | sed 's/ *$//g')\n\n  # Initialize variables.\n  LIST=$(echo $GRID_STR | sed\
    \ 's/ /\\n/g' | sed 's/^ *//g' | sed 's/ *$//g')\n  LIST2=$(echo $LIST | sed 's/^\
    \ *//g')\n  LIST3=$(echo $LIST2 | sed 's/ *$//g')\n  LIST4=$(echo $LIST3 | sed\
    \ 's/ /\\n/g' | sed 's/^ *//g' | sed 's/ *$//g')\n  LIST5=$(echo $LIST4 | sed\
    \ 's/^ *//g')\n  LIST6=$(echo $LIST5 | sed 's/ *$//g')\n  LIST7=$(echo $LIST6\
    \ | sed 's/ /\\n/g' | sed 's/^ *//g' | sed 's/ *$//g')\n  LIST8=$(echo $LIST7\
    \ | sed 's/^ *//g')\n  LIST9=$(echo $LIST8 | sed 's/ *$//g')\n  LIST10=$(echo\
    \ $LIST9 | sed 's/ /\\n/g' | sed 's/^ *//g' | sed 's/ *$//g')\n\n  # Count number\
    \ of lines in $GRID_STR.\n  N=$(awk '{ print NF }'<<< \"$tmp3\" | awk '{ print\
    \ $1 }')\n\n  # Count number of lines in $GRID_N.\n  N=$(awk '{ print NF }'<<<\
    \ \"$tmp6", "    local N=$1\n    local k=$2\n    local cells=$(cat $N | sed 's/^\
    \ *//' | sed 's/ *$//' | sed 's/^/\"/' | sort | uniq | sed 's/^/\"/g' | sed 's/$/\"\
    /g')\n    local cell=$(echo $cells | sed 's/^/'$k'/' | sed 's/$/\"'$k'/')\n  \
    \  local cellList=$(echo $cells | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/')\n\
    \    local cellList2=$(echo $cells | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/'\
    \ | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"\
    '$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed\
    \ 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/'\
    \ | sed 's/$/\"'$cell'/' | sed 's/^/'$cell'/' | sed ", "\tlocal n=$1\n\tshift\n\
    \tlocal k=$1\n\tshift\n\tlocal res=()\n\tlocal lst_A=$(echo -n \"${1:-}\") | tr\
    \ ' ' '\\n'\n\tlocal lst_B=()\n\tlocal i j\n\tfor((i = 1; i <= n; i++))\n\tdo\n\
    \t\tlst_B+=(${1:-})\n\tdone\n\tfor((i = 1; i <= n; i++))\n\tdo\n\t\tlst_A=(${lst_A:-})\n\
    \t\tlocal j\n\t\tfor((j = 1; j <= k; j++))\n\t\tdo\n\t\t\tlst_B=(${lst_B:-})\n\
    \t\tdone\n\t\tlocal n1=${#lst_A[@]}\n\t\tlocal n2=${#lst_B[@]}\n\t\tlocal ret\n\
    \t\tret=0\n\t\tfor((i = 1; i <= n1; i++))\n\t\tdo\n\t\t\tret=$((ret+lst_A[i]))\n\
    \t\t\tlst_B[i]=lst_A[i]\n\t\tdone\n\t\tret=$((ret+lst_B[n1]))\n\t\tfor((i = 1;\
    \ i <= n2; i++))\n\t\tdo\n\t\t\tret=$((ret+lst_A[i]))\n\t\t\tlst_B[i]=lst_A[i]\n\
    \t\tdone\n\t\tret=$((ret+lst_B[n2]))\n\t\tfor((i = 1; i <= n; i++))\n\t\tdo\n\t\
    \t\tfor((j = 1; j <= k; j++))\n\t\t\tdo\n\t\t\t\tlocal lst_A[${i}+1]\n\t\t\t\t\
    local lst_B[${i}+1]\n\t\t\t\tlst_A[i]=${lst_A[i]:-0}\n\t\t\t\tlst_B[i]=${lst_B[i]:-0}\n\
    \t\t\tdone\n\t\t\tlocal lst_A[${i}+1]\n\t\t\tlocal lst_B[${i}+1]\n\t\t\tlst_A[i]=${lst_A[i]:-0}\n\
    \t\t\tlst_B[i]=${lst_B[i]:-0}\n\t\tdone\n\t\tlocal lst_A[${i}+1]\n\t\tlocal lst_B[${i}+1]\n\
    \t\tlst_A[i]=${lst_A[i]:-0}\n\t\tlst_B[i]=${lst_B[i]:-0}\n\t\tlocal ret\n\t\t\
    ret=$((ret))\n\t\tres+=(${ret:-0})\n\tdone\n\techo \"${res[@]}\"", "    declare\
    \ -a arr\n    arr=($1)\n    size=${#arr[@]}\n    if [ \"$size\" -gt \"2\" ] ;\
    \ then\n        echo \"Error: too few arguments\" >&2\n        echo \"Usage: $(basename\
    \ $0) N > output.txt\"\n        return 1\n    fi\n    if [[ $size -eq \"0\" ]];\
    \ then\n        echo \"Error: empty array\" >&2\n        echo \"Usage: $(basename\
    \ $0) N > output.txt\"\n        return 1\n    fi\n    arr=($1)\n    size=${#arr[@]}\n\
    \    if [[ ${#arr[@]} -eq 0 ]]; then\n        echo \"Error: empty array\" >&2\n\
    \        echo \"Usage: $(basename $0) N > output.txt\"\n        return 1\n   \
    \ fi\n    arr=($1)\n    size=${#arr[@]}\n    if [[ ${#arr[@]} -eq 0 ]]; then\n\
    \        echo \"Error: empty array\" >&2\n        echo \"Usage: $(basename $0)\
    \ N > output.txt\"\n        return 1\n    fi\n    if [[ -z ${arr[0]} ]]; then\n\
    \        echo \"Error: empty array\" >&2\n        echo \"Usage: $(basename $0)\
    \ N > output.txt\"\n        return 1\n    fi\n    arr=($1)\n    size=${#arr[@]}\n\
    \    if [[ ${#arr[@]} -eq 0 ]]; then\n        echo \"Error: empty array\" >&2\n\
    \        echo \"Usage: $(basename $0) N > output.txt\"\n        return 1\n   \
    \ fi\n    arr=($1)\n    size=${#arr[@]}\n    if [[ ${#arr[@]} -eq 0 ]]; then\n\
    \        echo \"Error: empty array\" >&2\n        echo \"Usage: $(basename $0)\
    \ N > output.txt\"\n        return 1\n    fi\n    arr=($1)\n    size=${#arr[@]}\n\
    \    if [[ ${#arr[@]} -eq 0 ]]; then\n        echo \"Error: empty array\" >&2\n\
    \        echo \"Usage: $(basename $0) N > output.txt\"\n        return 1\n   \
    \ fi\n    arr=($1)\n    size=${#arr[@]}\n    if [[ ${#arr[@]} -eq 0 ]]; then\n\
    \        echo \"Error: empty array\" >&2\n        echo \"Usage: $(basename $0)\
    \ N > output.txt\"\n        return 1\n    fi\n    arr=($1)\n    size=${#arr[@]}\n\
    \    if [[ ${#arr[@]} -eq 0 ]]; then\n        echo \"Error: empty ", "  local\
    \ -n lines=$1\n  local -n num=${2:?Must specify an integer as the second argument}\n\
    \  local -n min=$((${#lines[@]} * num))\n  local -i i\n  local i line\n  local\
    \ j\n  local path lst_A lst_B\n  local -i min_len\n  \n  for ((i = 0; i < ${#lines[@]};\
    \ i++))\n  do\n    lst_A=(${lines[$i]}) #create lst_A from current line\n    lst_B=()\n\
    \    for ((j = i; j < ${#lines[@]}; j++)); do\n      lst_B+=(${lines[j]}) #append\
    \ current line to lst_B\n    done\n    path=()\n    for ((j = i; j < num; j++));\
    \ do\n      path+=($((i*num+j))) #add current index to path\n    done\n    [[\
    \ \"${path[${#path[@]}-1]}\" -eq ${num} ]] && min_len=${#path[@]} #set min_len\
    \ to the length of the path\n  done\n  printf '%s\\n' \"${lines[$((min_len-1)):$min_len]}\"",
  "  local line\n  local length\n  read -a line\n  length=${#line[@]}\n  if [ $length\
    \ -ne $2 ]; then\n    return 0\n  fi\n  echo \"${line[*]}\"\n  local j=0\n  local\
    \ k\n  local count\n  local j2\n  local j3\n  local min\n  local min2\n  local\
    \ min3\n  local count2\n  local count3\n  local count4\n  local min2\n  local\
    \ min3\n  local min4\n  local min3\n  read -a min\n  count=$((${#min[@]} / 2))\n\
    \  for i in $(seq $count); do\n    if [ $((i + 2)) -ge $count ]; then\n      k=$((i\
    \ + 2))\n    else\n      k=$((i + 1))\n    fi\n    count2=0\n    count3=0\n  \
    \  min2=$min[j2]\n    min3=$min[j3]\n    count4=$((k - 1))\n    for j in $(seq\
    \ $count4); do\n      j2=$((j * 2))\n      if [[ ${min2[@]} != *\"${min[$j2]}\"\
    * ]]; then\n        count2=$((count2 + 1))\n      fi\n      j3=$((j * 2 + 1))\n\
    \      if [[ ${min3[@]} != *\"${min[$j3]}\"* ]]; then\n        count3=$((count3\
    \ + 1))\n      fi\n    done\n    min2=$min[$j2]\n    min3=$min[$j3]\n    if [[\
    \ ${count2} -eq 0 ]]; then\n      min4=$min2\n    elif [[ ${count3} -eq 0 ]];\
    \ then\n      min4=$min3\n    elif [[ ${count2} -ge ${count3} ]]; then\n     \
    \ min4=$min2\n    else\n      min4=$min3\n    fi\n    count3=$((k - 1))\n    for\
    \ j in $(seq $count3); do\n      j2=$((j * 2))\n      if [[ ${min2[@]} != *\"\
    ${min[$j2]}\"* ]]; then\n        count2=$((count2 + 1))\n      fi\n      j3=$((j\
    \ * 2 + 1))\n      if [[ ${min3[@]} != *\"${min[$j3]}\"* ]]; then\n        count3=$((count3\
    \ + 1))\n      fi\n    done\n    count3=$((k - 1))\n    for j in $(seq $count2);\
    \ do\n      j2=$((", "  local lines=$1 num=${2:-0}\n  \n  local grid=\"$(getGrid\
    \ lines)\"\n  local maxlen=0\n  local maxpos=\"$(getPos grid)\"\n  local gridPos=\"\
    $(getGridPos grid)\"\n  local answer\n  \n  for ((i=0; i < ${#grid[@]}; i++));\
    \ do\n    local pos=\"${gridPos[i]}\"\n    local val=\"${grid[i]}\"\n    \n  \
    \  local lst_A\n    local lst_B\n    \n    if [[ \"${gridPos[pos+1]}\" == ${pos}\
    \ ]]; then\n      lst_A=( $(seq 1 ${num}) )\n      lst_B=( $(seq 1 ${num}) )\n\
    \      \n    elif [[ \"${gridPos[pos-1]}\" == ${pos} ]]; then\n      lst_A=( $(seq\
    \ 1 ${num}) )\n      lst_B=( $(seq 1 ${num}) )\n      \n    elif [[ \"${gridPos[pos+1]}\"\
    \ > ${pos} ]]; then\n      lst_A=( $(seq 1 ${num}) )\n      lst_B=( $(seq 1 ${num})\
    \ )\n      \n    elif [[ \"${gridPos[pos-1]}\" > ${pos} ]]; then\n      lst_A=(\
    \ $(seq 1 ${num}) )\n      lst_B=( $(seq 1 ${num}) )\n      \n    elif [[ \"${gridPos[pos+1]}\"\
    \ < ${pos} ]]; then\n      lst_A=( $(seq 1 ${num}) )\n      lst_B=( $(seq 1 ${num})\
    \ )\n      \n    elif [[ \"${gridPos[pos-1]}\" < ${pos} ]]; then\n      lst_A=(\
    \ $(seq 1 ${num}) )\n      lst_B=( $(seq 1 ${num}) )\n      \n    elif [[ \"${gridPos[pos+1]}\"\
    \ > ${pos} && \"${gridPos[pos-1]}\" < ${pos} ]]; then\n      lst_A=( $(seq 1 ${num})\
    \ )\n      lst_B=( $(seq 1 ${num}) )\n      \n    elif [[ \"${gridPos[pos-1]}\"\
    \ > ${pos} && \"${gridPos[pos+1]}\" < ${pos} ]]; then\n      lst_A=( $(seq 1 ${num})\
    \ )\n      lst_B=( $(seq 1 ${num}) )\n      \n    else\n      echo \"Error: Invalid\
    \ grid\" >&2\n      exit 1\n    fi", "  local lst_A=$(echo $1 | tr -s \" \" )\n\
    \  local k=$(echo $2 | tr -cd \"0-9\")\n  local lst_B\n  local i j min\n  local\
    \ result\n  ((k > 0))\n  ((k--))\n  ((k--))\n  ((k++))\n  ((k++))\n  ((k--))\n\
    \  while [[ $(echo $lst_A | sort -n | uniq | wc -l | tr -d \" \") -gt $(echo $lst_B\
    \ | sort -n | uniq | wc -l | tr -d \" \") ]] ; do\n    ((k++))\n  done\n  ((k--))\n\
    \  lst_B=$(echo $lst_A | sort -n | uniq | sed -n ${k}p | sed \"s/.$//g\")\n  i=0\n\
    \  while [[ $(echo $lst_A | sort -n | uniq | wc -l | tr -d \" \") -gt $(echo $lst_B\
    \ | sort -n | uniq | wc -l | tr -d \" \") ]] ; do\n    ((i++))\n    ((k--))\n\
    \    ((k--))\n    ((k++))\n    ((k++))\n  done\n  lst_A=$(echo $lst_A | sort -n\
    \ | uniq | sed -n ${i}p | sed \"s/.$//g\")\n  min=${i}\n  j=0\n  result=()\n \
    \ while [[ $j -ge ${min} ]] ; do\n    ((j++))\n    result+=(\"${lst_A[$j]}\")\n\
    \    ((k--))\n    ((k--))\n    ((k++))\n    ((k++))\n  done\n  echo \"${result[@]}\"",
  "    local -i g=\"$1\"\n    local -i k=\"$2\"\n\n    local -a arr \n    local -a\
    \ min \n\n    arr=($g)\n    min=(0)\n    while [ $# -gt 0 ]; do\n        local\
    \ -i i\n        local -i j \n        local -i k \n        local -i l \n\n    \
    \    l=0\n        k=\"${#arr[@]}\"\n        while [ \"$k\" -gt \"$l\" ]; do\n\
    \            k=$((k-1))\n            l=$((l+1))\n        done\n\n        ((k--))\n\
    \n        local -i m \n\n        k=\"${#arr[@]}\"\n        for (( i=1; i<k; i++\
    \ )); do\n            k=$((k-1))\n            ((k--))\n            local -i k\
    \ \n\n            arr=($g)\n            m=$(( l - i - 1 ))\n            min+=(\
    \ \"${min[@]}\" )\n\n            while [ \"${arr[@]:$m:1}\" != \"${arr[@]:$m:1}\"\
    \ ]; then\n                arr=( ${arr[@]:0:$m}${arr[@]:$m:1} )\n            \
    \    (( m += 1 ))\n            done\n        done\n    done\n\n    echo \"${min[@]}\"",
  "    local grid=$1 k=$2\n    \n    local lst_A lst_B\n    \n    for k in $(seq 1\
    \ $(( $(expr length $grid) - 1 )))\n    do\n        local c=0\n        local i\
    \ j c\n        for j in $(seq 1 $(( $(expr length $grid) - 1 )))\n        do\n\
    \            i=$(echo $grid|awk -F \" \" '{ print $j }')\n            if [[ $i\
    \ -gt $k ]]\n            then\n                let c++\n            fi\n     \
    \   done\n        if [ $c -eq $k ]\n        then\n            echo $grid\n   \
    \     fi\n    done", "  local lines=\"$1\"\n  local num=\"$(echo \"$lines\" |\
    \ wc -l)\"\n  if [[ $num -eq 0 ]]; then\n    return -1\n  fi\n  local k=\"$2\"\
    \n  if [[ $num -lt 2 ]]; then\n    return -1\n  fi\n  # $3: lst_A\n  # $4: lst_B\n\
    \  # $5: k\n  local lst_A=\"$(echo \"$lines\" | sed \"s/[^ ]*//g\" | sed \"s/\
    \ //g\")\"\n  local lst_B=\"$(echo \"$lines\" | sed \"s/[^ ]*//g\" | sed \"s/\
    \ //g\" | sort | uniq)\"\n  if [[ $(echo \"$lst_A\" > \"$lst_B\" 2> /dev/null\
    \ | wc -l) -eq 0 ]]; then\n    return -1\n  fi\n  # $6: res\n  # $7: i\n  local\
    \ res=\"\"\n  local i=1\n  while [[ ${#lst_A} > $i ]]; do\n    local j=$(( i +\
    \ 1 ))\n    if [[ $(( $num - $j )) -eq 0 ]]; then\n      res=\"$res $lst_A[$i]\"\
    \n      break\n    fi\n    if [[ $(echo \"$lst_A[$j]\" > \"$lst_B[$j]\" 2> /dev/null\
    \ | wc -l) -eq 0 ]]; then\n      res=\"$res $lst_A[$i]\"\n      break\n    fi\n\
    \    if [[ $(( $lst_A[$j] )) -gt $(echo \"$lst_B[$j]\" 2> /dev/null | wc -l) ]];\
    \ then\n      res=\"$res $lst_A[$i]\"\n      break\n    fi\n    i=$j\n  done\n\
    \  local res", "  local -n arr=\n  local -n lines=\n  local -n arrCmp=\n  local\
    \ -n res=\n  local -n lineCmp=\n  local -i cnt=1\n  local -i nRows=0\n  local\
    \ -i nCols=0\n  local -i nRowsSum=0\n  local -i nColsSum=0\n  local -i k=0\n \
    \ local -i val\n  while IFS='' read -r line; do\n    arr=($line)\n    nRows=${#arr[*]}\n\
    \    nCols=${#arr[@]}\n    lineCmp=$(cmp -s \"$line\" \"$lines\")\n    if [ !\
    \ -z $lineCmp ]; then\n      lineCmp=${#lineCmp}\n    fi\n    if [ \"$lineCmp\"\
    \ -gt \"$k\" ]; then\n      lines=$line\n      k=$lineCmp\n    fi\n    ((nRowsSum+=nRows))\n\
    \    ((nColsSum+=nCols))\n    ((cnt++))\n  done < <(echo \"$1\")\n  arrCmp=$(cmp\
    \ -s \"$lines\" \"$line\")\n  if [ ! -z $arrCmp ]; then\n    arrCmp=${#arrCmp}\n\
    \  fi\n  arrCmp=${#arr[@]}\n  if [ \"$arrCmp\" -gt \"$k\" ]; then\n    echo \"\
    $1\"\n    return\n  fi\n  res=()\n  cnt=1\n  for (( i=1; i<=k; i++ )); do\n  \
    \  for (( j=1; j<i; j++ )); do\n      val=${arr[$((cnt-1))]}\n      val=${val:0:1}\n\
    \      val=`printf \"\\\"$val\\\"\"`\n      if [ \"$val\" == \"\\\" \" ]; then\n\
    \        val=\"\\\"\\\"\"\n      else\n        val=${val:1}\n      fi\n      res+=$val\n\
    \    done\n    res+=\"\\n\"\n  done\n  echo \"${res}\"", "    # https://discuss.leetcode.com/topic/27797/java-solution-with-best-time-2nlogn-in-all-cases\n\
    \    # https://github.com/dzhang/minPath\n\n    # remove trailing newline\n  \
    \  while [[ ${1:(-1)} == '\\n' ]]; do \n        echo ${1:(-1)}\n        shift\n\
    \    done\n\n    # remove trailing space\n    while [[ ${1:(-1)} == ' ' ]]; do\
    \ \n        echo ${1:(-1)}\n        shift\n    done\n\n    # trim whitespace\n\
    \    while [[ ${1:(-1)} =~ ^[[:space:]]*$ ]]; do \n        echo ${1:(-1)}\n  \
    \      shift\n    done\n\n    # split to array\n    arr=(${1//' '/ })\n    len=${#arr[@]}\n\
    \n    local i\n    local max=0\n    local lenMax=0\n    local maxPos=-1\n    #\
    \ iterate over array\n    for (( i=1; i<len; i++ )); do\n        # find max length\n\
    \        if [[ \"$arr[$i]\" -gt \"$max\" ]]; then\n            max=$arr[$i]\n\
    \            lenMax=$i\n        fi\n        # find max position\n        if [[\
    \ \"$arr[$i]\" -gt \"$arr[$maxPos]\" ]]; then\n            maxPos=$i\n       \
    \ fi\n    done\n\n    # return result\n    echo $(echo ${arr[@]:0:(lenMax-1)})",
  "    local -i N=${1:-2}\n    local -i k=${2:-1000}\n    local -i x=0;\n    local\
    \ -a grid;\n    local -i idx=0;\n\n    grid=( \"$1\" )\n    for ((i=0; i < ${#grid[@]};\
    \ i++)); do\n        for ((j=0; j < ${#grid[@]}; j++)); do\n            if [[\
    \ ${grid[${i}]} == ${grid[${j}]} ]]; then\n                ((idx++))\n       \
    \     fi\n        done\n        grid[${i}]=${grid[idx]}\n    done\n\n    # Count\
    \ cells with value\n    local -a count\n    count=( $(echo \"${grid[*]}\" | tr\
    \ \" \" \"\\n\" | sort | uniq | wc -l) )\n    \n    local -a path\n    path=(\
    \ $(echo \"${grid[*]}\" | tr \" \" \"\\n\" | sort | uniq | xargs -n 1 -I '{}'\
    \ echo \"'${grid[@]}'\" | grep -Eo '^\\s*'\"${grid[@]}\"'\\s*$') )\n    \n   \
    \ # Count unique cells\n    local -a unique\n    unique=( $(echo \"${path[*]}\"\
    \ | tr \" \" \"\\n\" | sort | uniq | wc -l) )\n\n    # Build path\n    local -i\
    \ k=0\n    while (( k < ${#unique[@]} )); do\n        # Search for next cell to\
    \ visit\n        local -i next_idx=0\n        while (( next_idx < ${#count[@]}\
    \ )); do\n            if [[ \"${path[$next_idx]}\" == \"${grid[${next_idx}]}\"\
    \ ]]; then\n                ((next_idx++))\n            fi\n        done\n   \
    \     \n        # Increment k\n        ((k++))\n\n        # Append current cell\
    \ and all its neighbors\n        path[$k]=\"${path[$k]}${grid[${next_idx}]}\"\n\
    \        \n        # Append all neighbors\n        for ((j=1; j <= ${#unique[@]}\
    \ && ${k} < ${#path[@]}; j++)); do\n            if [[ \"${path[$k-1]}\" == \"\
    ${unique[j]}\" ]]; then\n                path[$k]=\"${path[$k]}'${unique[j]}'\"\
    \n            fi\n        done\n    done\n\n    echo -n \"${path[@]}\" | sed -re\
    \ 's/^\"//;s/\"$//;s/\\s{2,}/\\n/g' | sed -re 's/^\\s+|\\s+$//g' | sort -u", " \
    \ local lines=$1\n  local num=$2\n  local vals\n  vals=$(echo $lines | sed -n\
    \ 's/.* \\(.*\\)/\\1/p' | sort -u)\n  local curIdx=0\n  local nextIdx=0\n  local\
    \ minIdx=0\n  local tmpIdx\n  local tmpVal\n  while (( curIdx <= num * num - 1\
    \ )); do\n    nextIdx=((num * num) * curIdx + 1)\n    tmpIdx=$((num * num - 1))\n\
    \    echo $vals | while (( tmpIdx <= nextIdx )); do\n      tmpVal=$vals[$tmpIdx]\n\
    \      vals[$tmpIdx]=$(echo $vals | cut -d\" \" -f $curIdx)\n      vals[$curIdx]=$tmpVal\n\
    \      tmpIdx=$((curIdx + 1))\n      curIdx=$((num * num - 1))\n    done\n   \
    \ minIdx=$((num * num - 1))\n    while (( minIdx <= num * num - 1 )); do\n   \
    \   tmpIdx=$((minIdx))\n      tmpVal=$vals[$tmpIdx]\n      vals[$tmpIdx]=$(echo\
    \ $vals | cut -d\" \" -f $curIdx)\n      vals[$curIdx]=$tmpVal\n      minIdx=$((minIdx\
    \ + 1))\n      curIdx=$((num * num - 1))\n    done\n  done\n  echo $vals", " \
    \ local g=\"$1\"\n  local k=\"$2\"\n  local lst_A\n  local lst_B\n  local i\n\
    \  local j\n  local result\n\n  lst_A=( $(echo $g|grep '^[0-9]*$'|sed 's/ //g')\
    \ )\n  lst_B=( $(echo $g|grep '^[0-9]*$'|sed 's/ //g') )\n  for ((i=0;i<${#lst_A[@]};i++));\
    \ do\n    for ((j=0;j<${#lst_B[@]};j++)); do\n      if [[ \"$lst_A\"[$i] -gt \"\
    $lst_B\"[$j] ]]; then\n        lst_B[$j]=$(expr $lst_B[$j] \\* ${lst_A[$i]})\n\
    \      fi\n    done\n  done\n  result=$(IFS=' '; echo \"${lst_B[@]}\")\n  echo\
    \ \"${result}\"", "    local lst_A lst_B\n    local i j\n    local N=${#$1} val\n\
    \    local count=0\n    lst_A=()\n    lst_B=()\n    for ((i=0; i<N; i++)); do\
    \ \n        lst_A+=($(echo $1 | cut -d \" \" -f $i))\n    done\n    for ((i=0;\
    \ i<N; i++)); do \n        lst_B+=($(echo $1 | cut -d \" \" -f $i))\n    done\n\
    \    for ((i=0; i<N; i++)); do\n        for ((j=0; j<i; j++)); do\n          \
    \  if [[ $(echo ${lst_A[i]} ${lst_B[j]} | sort | uniq) ]]; then\n            \
    \    if (( ${lst_A[j]} < ${lst_B[j]} && ${i} < ${j} )); then\n               \
    \     lst_B[j]=\"${lst_A[j]}\"\n                fi\n            fi\n        done\n\
    \        ((count++))\n    done\n    if [ $count -eq 1 ]; then\n        echo \"\
    $lst_A\"\n    else\n        echo \"$lst_B\"\n    fi", "    local g=\"$1\"\n  \
    \  local k=\"$2\"\n    \n    local g1\n    local g2\n    local g3\n    local g4\n\
    \    local lst_A\n    local lst_B\n    local g5\n    local g6\n    local g7\n\
    \    local g8\n    local g9\n    local i\n    local j\n    local result\n    local\
    \ cnt\n    local val\n    local g1i\n    local g2i\n    local g3i\n    local g4i\n\
    \    local g5i\n    local g6i\n    local g7i\n    local g8i\n    local g9i\n \
    \   local vali\n    \n    g1=$(echo \"$g\" | tr '\\n' ' ' | sed 's/ //g')\n  \
    \  g2=$(echo \"$g\" | tr '\\n' ' ' | sed 's/ //g')\n    g3=$(echo \"$g\" | tr\
    \ '\\n' ' ' | sed 's/ //g')\n    g4=$(echo \"$g\" | tr '\\n' ' ' | sed 's/ //g')\n\
    \    lst_A=$(echo \"$g1\" | tr '\\n' ' ')\n    lst_B=$(echo \"$g1\" | tr '\\n'\
    \ ' ')\n    g5=$(echo \"$g2\" | tr '\\n' ' ')\n    g6=$(echo \"$g2\" | tr '\\\
    n' ' ')\n    g7=$(echo \"$g3\" | tr '\\n' ' ')\n    g8=$(echo \"$g3\" | tr '\\\
    n' ' ')\n    g9=$(echo \"$g4\" | tr '\\n' ' ')\n    \n    cnt=$(echo \"$g1\" |\
    \ wc -l)\n    \n    for i in $(seq 1 \"$k\"); do\n        cnt1=0\n        g1i=($(echo\
    \ \"$g1\" | sed 's/ //g'))\n        g2i=($(echo \"$g2\" | sed 's/ //g'))\n   \
    \     g3i=($(echo \"$g3\" | sed 's/ //g'))\n        g4i=($(echo \"$g4\" | sed\
    \ 's/ //g'))\n        g5i=($(echo \"$g5\" | sed 's/ //g'))\n        g6i=($(echo\
    \ \"$g6\" | sed 's/ //g'))\n        g7i=($(echo \"$g7\" | sed 's/ //g'))\n   \
    \     g8i=($(echo \"$g8\" | sed 's/ //g'))\n        g9i=($(echo \"", "    local\
    \ N=$1\n    local k=$2\n    local -a grid\n    local -a lst\n    local -i indx\n\
    \    local -a lst1\n    local -a lst2\n    while IFS= read -r line; do\n     \
    \   grid+=(\"$line\")\n    done < \"$1\"\n    indx=1\n    while ((indx < N));\
    \ do\n        if ((indx % 2 != 0)); then\n            lst+=(\"\\\"${grid[$indx]}\\\
    \"\")\n            indx++\n            continue\n        fi\n        lst1=(\"\
    $grid[$indx]\" \"${grid[$indx-1]}\")\n        lst2=(\"$grid[$indx]\" \"${grid[$indx+1]}\"\
    )\n        if ((k == 1)); then\n            for ((i=1; i<=indx; i++)); do\n  \
    \              lst1+=(\"\\\"${grid[i]}\\\"\")\n            done\n            lst2+=(\"\
    \\\"${grid[$indx]}\\\"\")\n        elif ((k > 1)); then\n            if ((! $(comp\
    \ \"${lst1[*]}\" \"$lst2[*]\")); then\n                lst1+=(\"\\\"${grid[$indx]}\\\
    \"\")\n                lst2+=(\"\\\"${grid[$indx-1]}\\\"\")\n                lst2+=(\"\
    \\\"${grid[$indx+1]}\\\"\")\n            else\n                lst1+=(\"\\\"${grid[$indx]}\\\
    \"\")\n                lst2+=(\"\\\"${grid[$indx-1]}\\\"\")\n            fi\n\
    \        else\n            lst1+=(\"\\\"${grid[$indx]}\\\"\")\n        fi\n  \
    \      lst+=(\"\\\"${lst1[*]}\\\"\" )\n        lst+=(\"\\\"${lst2[*]}\\\"\")\n\
    \        ((indx++))\n    done\n    local -a ret\n    local -i ind\n    while ((ind\
    \ < N*N)); do\n        if ((ind%2 != 0)); then\n            lst+=(\"\\\"${grid[ind]}\\\
    \"\")\n        fi\n        ret+=(${lst[*]})\n        ((ind++))\n    done\n   \
    \ echo ${ret[*]}", "    local array=\"$1\"\n    local num=\"$2\"\n    local x\n\
    \    local min\n    local max\n    local value\n    local i\n    local j\n   \
    \ local arrayLength\n    local listA\n    local listB\n\n    # Find out how many\
    \ items are in the array.\n    arrayLength=$((${#array} + 1))\n\n    # Initialize\
    \ array and list variables.\n    array+=(\"\")\n    listA=(\"\")\n    listB=(\"\
    \")\n\n    # Loop through all numbers in the range [1, N * N]. \n    for i in\
    \ $(seq 1 ${arrayLength}); do\n        num=$(cut -d' ' -f$i <<< $array) | cut\
    \ -d'\"' -f${num}\n        value=$(eval echo \"${num}\")\n        x=\"$value\"\
    \n\n        # Store this value on the current cell.\n        array+=($x)\n\n \
    \       # Add the value to the array list.\n        listA+=($value)\n        listB+=($value)\n\
    \n        # Find the minimum between this value and all values in the array list.\n\
    \        min=$(eval echo \"${min:-1000}\")\n        max=$(eval echo \"${max:-1000}\"\
    )\n        for x in ${listA[@]}; do\n            if [ $((x - min)) -le 0 ]; then\n\
    \                min=$((x - min))\n            fi\n        done\n        for x\
    \ in ${listB[@]}; do\n            if [ $((x - min)) -ge 0 ]; then\n          \
    \      max=$((max - x))\n            fi\n        done\n\n        # If this value\
    \ is the minimum, remove it from both lists.\n        if [ \"$min\" = \"$value\"\
    \ ]; then\n            listA=( \"${listA[@]/$value}\" )\n            listB=( \"\
    ${listB[@]/$value}\" )\n        fi\n    done\n\n    # Return an array with all\
    \ values on the cells that the minimum path go through.\n    # Note that a path\
    \ of length k is considered less than a path of length k+1 \n    # because a path\
    \ of length k means the number of cells between the start \n    # and the cell\
    \ is exactly k, not less than k, for example:\n    # >>> $(minPath \"1 2 3\\n4\
    \ 5 6\\n7 8 9\" \"3\") \n    # ['\"1\"', '\"2\"', '\"3\"']\n    # >>> $(minPath\
    \ \"5 9 3\\n4 1 6\\n7 8 2\" \"1\") \n    # ['\"1\"']\n    echo \"${array[@]}\"",
  "  local -r lines=$1\n  local -r k=${2:-1000}\n  local -r output=\"\"\n  local line\n\
    \  local j\n  local i\n  for line in $(echo $lines | sed -e 's/^[[:blank:]]*//'\
    \ -e 's/[[:blank:]]*$//'); do\n    i=$(echo $line | cut -d \" \" -f 1)\n    j=$(echo\
    \ $line | cut -d \" \" -f 2)\n    local tmp_output\n    if ((i==j)); then\n  \
    \    tmp_output=\"\\\"$i\\\"\"\n    elif ((i>j)); then\n      tmp_output=\"\\\"\
    $j\\\"\"\n    else\n      tmp_output=\"\\\"$i\\\" and \\\"$j\\\"\"\n    fi\n \
    \   tmp_output=\"$tmp_output,\\\"$i\\\"\"\n    output=\"$output$tmp_output\"\n\
    \  done\n  output=\"${output%,*}\"\n  output=\"${output##*,}\"\n  output=\"${output%?}\"\
    \n  echo \"$output\"", "    local grid_lines=$(echo $1 | tr ' ' '\\n' | sort --numeric-sort);\
    \ \n    local grid_length=${#grid_lines[@]};\n    local start=0; local result=();\
    \ local i; local j;\n    for (( i=1; i<=grid_length; i++ )); do\n        # print\
    \ the current line\n        echo \"${grid_lines[$((start+i-1))]}\"; \n       \
    \ # start a path from previous position\n        result+=($(minPath \"${grid_lines[$((start+i-1))]}\"\
    \ \"$2\"));\n    done;\n    echo \"${result[@]}\" | tr ' ' '\\n';", "\tlocal grid_lines=$1\n\
    \tlocal grid=$2\n\tlocal num_lines=${#grid_lines} \n\tlocal num_cols=${#grid}\
    \ \n\tlocal rows=$(expr num_lines / num_cols)\n\tlocal cols=$(expr num_cols /\
    \ rows)\n\tlocal result=\"\"\n\t\n\tlocal row_idx=1\n\tlocal col_idx=1\n\tlocal\
    \ row_tmp=$grid\n\tlocal col_tmp=$grid\n\t\n\tlocal row_arr=()\n\tlocal col_arr=()\n\
    \t\n\twhile [[ \"${row_idx}\" -le \"${rows}\" ]] || [[ \"${col_idx}\" -le \"${cols}\"\
    \ ]]; do\n\t\tif [[ \"${row_idx}\" -le \"${rows}\" ]]; then\n\t\t\trow_arr=(${row_tmp})\n\
    \t\t\trow_idx=$((row_idx + 1))\n\t\telse\n\t\t\trow_arr+=(${row_tmp})\n\t\t\t\
    row_idx=$((row_idx + 1))\n\t\tfi\n\t\t\n\t\tif [[ \"${col_idx}\" -le \"${cols}\"\
    \ ]]; then\n\t\t\tcol_tmp=${col_tmp//$'\\n'/$'\\n'}\n\t\t\tcol_tmp=${col_tmp//$'\\\
    t'/$'\\t'}\n\t\t\tcol_arr+=(${col_tmp})\n\t\t\tcol_idx=$((col_idx + 1))\n\t\t\
    else\n\t\t\tcol_tmp=${col_tmp//$'\\n'/$'\\n'}\n\t\t\tcol_tmp=${col_tmp//$'\\t'/$'\\\
    t'}\n\t\t\tcol_arr+=(${col_tmp})\n\t\t\tcol_idx=$((col_idx + 1))\n\t\tfi\n\tdone\n\
    \n\tfor ((i=0;i<${#col_arr[@]};++i)); do\n\t\tlocal j=${i}\n\t\twhile [[ \"${j}\"\
    \ -le \"${#col_arr[@]}\" ]]; do\n\t\t\tlocal k=1\n\t\t\twhile [[ \"${k}\" -le\
    \ \"${#row_arr[@]}\" ]] || [[ \"${col_arr[$j]}\" -gt \"${row_arr[$((k - 1))]}\"\
    \ ]] || [[ \"${col_arr[$j]}\" -lt \"${row_arr[$((k - 1))]}\" ]]; do\n\t\t\t\t\
    if [[ \"${col_arr[$j]}\" -gt \"${row_arr[$((k - 1))]}\" ]]; then\n\t\t\t\t\t((k=k+1))\n\
    \t\t\t\telse\n\t\t\t\t\t((k=k-1))\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tresult+=${col_arr[$j]//$'\\\
    t'/$'\\n'}\n\t\t\tj=$((j + 1))\n\t\tdone\n\tdone\n\techo ${result//$'\\n'/$'\\\
    n'}", "    \n    # Initialize all arrays with size (N + 1)\n    lst_A=()\n   \
    \ lst_B=()\n    lst_C=()\n    \n    # Populate arrays with all permutations of\
    \ $1 as values\n    for var in $1; do\n        lst_A+=($(echo $var | tr ' ' '\\\
    n' | sort | uniq))\n    done\n    \n    # Populate arrays with all permutations\
    \ of $2 as values\n    for var in $2; do\n        lst_B+=($(echo $var | tr ' '\
    \ '\\n' | sort | uniq))\n    done\n    \n    # Initialize min value with smallest\
    \ possible value\n    min=${lst_A[0]}\n    \n    # Iterate over all elements on\
    \ $1 that are not included in $2\n    for var in ${lst_A[@]}; do\n        if [[\
    \ -z \"$2\" ]]; then\n            break\n        fi\n    \n        # Iterate over\
    \ all elements on $2 that are not included in $1\n        for var in ${lst_B[@]};\
    \ do\n            if [[ -z \"$1\" ]]; then\n                break\n          \
    \  fi\n            \n            if [[ \"$var\" == \"$var\" ]]; then\n       \
    \         lst_C+=($var)\n            fi\n        done\n        \n        if [[\
    \ \"$var\" < \"$min\" ]]; then\n            min=$var\n        fi\n    done\n \
    \   \n    echo \"$min\"", "  local line_1=$1\n  local line_2=$2\n  local line_1_size=$((${#line_1}))\n\
    \  local line_2_size=$((${#line_2}))\n  local i j k lst_A lst_B min_path\n  \n\
    \  if [[ \"${line_1_size}\" -eq \"${line_2_size}\" ]]; then\n    lst_A=( $(echo\
    \ $line_1 | tr ' ' '\\n' ) ) \n    lst_B=( $(echo $line_2 | tr ' ' '\\n' ) )\n\
    \    min_path=$( printf \"%s\" \"$line_1\" | tr ' ' '\\n' | sort | head -n 1 )\n\
    \    k=$line_2\n  else\n    k=$(( (${line_1_size} * ${line_2_size}) - line_1_size\
    \ * line_2_size ))\n    lst_A=( $(echo $line_1 | tr ' ' '\\n' ) )\n    lst_B=(\
    \ $(echo $line_2 | tr ' ' '\\n' ) )\n    min_path=$( printf \"%s\" \"$line_1\"\
    \ | tr ' ' '\\n' | sort | head -n ${line_1_size} )\n  fi\n  \n  j=0\n  while [[\
    \ $j -lt $k ]]; do\n    k=$(( j + 1 ))\n    while [[ $k -lt $k ]]; do\n      i=$((\
    \ ((${#lst_A[@]} * ${#lst_B[@]}) - ${#lst_A[@]} * ${#lst_B[@]})/2 ))\n      lst_A=(\
    \ $(echo $line_1 | tr ' ' '\\n' ) )\n      lst_B=( $(echo $line_2 | tr ' ' '\\\
    n' ) )\n      if [[ $lst_A[$i] -gt $lst_B[$i] ]]; then\n        lst_B=( $(echo\
    \ $line_2 | tr ' ' '\\n' ) )\n      fi\n      min_path=$( printf \"%s\" \"$min_path\"\
    \ | sed -e \"s/${line_1_size}-${line_1_size}/${line_1_size}-${line_2_size}/${line_1_size}-${line_2_size}\"\
    \ -e \"s/${line_1_size}/$i/g\" -e \"s/${line_2_size}/$k/g\" )\n      j=$(( j +\
    \ 1 ))\n    done\n  done\n  \n  echo \"$min_path\"", "  \n  local -i N=$2 \n \
    \ local -I N2=${#1}\n\n  local -i i j k lenA lenB\n  local -a lst_A lst_B\n  \n\
    \  lst_A=()\n  lst_B=()\n  \n  # Scan the grid and record the visited cells\n\
    \  for (( i=1; i<=N; i++ )); do\n    if [[ ${lst_A[i]} ]] || [[ ${lst_B[i]} ]];\
    \ then \n      lst_A[i]=\"${lst_A[i]} $i\"\n      lst_B[i]=\"${lst_B[i]} $i\"\n\
    \    else\n      lst_A[i]=\"$i\"\n      lst_B[i]=\"$i\"\n    fi\n  done\n  \n\
    \  # Traverse the cells and record the visited cells \n  for (( i=1; i<=N; i++\
    \ )); do\n    for (( j=1; j<=N; j++ )); do\n      # If both A and B already visited,\
    \ then we cannot go\n      # through the same cell twice.\n      if [[ ${lst_A[${i}]}\
    \ == ${lst_B[${j}]} ]]; then\n        echo \"Error: $(i) $(j) already visited\"\
    \n        return 1\n      fi\n      # If A visited, then move to B, otherwise,\
    \ move to A\n      if [[ ${lst_A[${j}]} ]]; then\n        lenB=$(( ${#lst_A[${j}]}\
    \ + 1 ))\n      else\n        lenA=$(( ${#lst_B[${i}]} + 1 ))\n      fi\n    \
    \  # If A has enough length to visit all cells in the grid,\n      # then do it\n\
    \      if (( ${#lst_A[${i}]} >= k )); then\n        (( lenA++ ))\n        lst_B[${i}]=\"\
    ${lst_B[${i}]} ${lst_A[${i}]}\"\n      else\n        (( lenB++ ))\n        lst_A[${i}]=\"\
    ${lst_A[${i}]} ${lst_B[${i}]}\"\n      fi\n    done\n  done\n\n  # Construct an\
    \ ordered list of the values on the cells that the\n  # minimum path go through\n\
    \  echo ${lst_A[@]}", "    \n    local lines=$1\n    local num=$2\n    local num=$(echo\
    \ $num | sed 's/,/ /g')\n    local lst=()\n    local max=0\n    local tmp\n  \
    \  \n    for i in $(seq 1 $num); do\n        tmp=()\n        for j in $(seq 1\
    \ $num); do\n            if (( $j > $i )); then\n                tmp+=$(echo $lines\
    \  | cut -d \" \" -f $i)\n            fi\n        done\n        lst+=$(echo ${tmp[@]}\
    \ | sort | uniq)\n        max=$(echo $max $max $((${#lst[@]}-1)))\n    done\n\
    \    echo ${lst[@]} | sort | uniq -u", '  echo $(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($(($',
  "  local grid_str=$1\n  local k=$2\n  local grid=($(echo $grid_str | tr ' ' '\\\
    n' | sort -n | head -n $k))\n  local answers=()\n  local count=0\n  local idx=1\n\
    \  local num=0\n  local i=0\n  local prev=\"\"\n  local next=\"\"\n  local curr=\"\
    \"\n  local gridline=\"\"\n  local startLine=0\n  local endLine=0\n  while [ $idx\
    \ -lt ${#grid[*]} ]; do\n    curr=$(echo $grid[$idx])\n    if [[ \"$prev\" !=\
    \ \"$curr\" ]]; then\n      answers[$count]=\"$curr\"\n      ((count=count+1))\n\
    \    fi\n    ((idx=idx+1))\n    prev=$curr\n    gridline=$gridline$curr\n    if\
    \ [[ \"$startLine\" -ne \"$endLine\" ]]; then\n      endLine=$((idx-1))\n    fi\n\
    \    ((num=num+1))\n    ((idx=idx+1))\n  done\n  if [[ $num -lt $k ]]; then\n\
    \    answers[$count]=\"$prev\"\n    ((count=count+1))\n  fi\n  echo $answers |\
    \ tr ' ' '\\n'", "    local lst_A=$1\n    local k=$2\n    local i=$(( (k - 1)\
    \ * (k - 1) ))\n    while (( i <= k )); do\n        local j=$(( (i - 1) * (i -\
    \ 1) ))\n        if (( j > k )); then\n            (( j = k ))\n        fi\n \
    \       local v=${lst_A[$i]}\n        lst_A[$i]=${lst_A[$j]}\n        lst_A[$j]=$v\n\
    \        (( i += 1 ))\n        (( j += 1 ))\n    done\n    echo $( echo $lst_A\
    \ | tr ' ' \",\" )", "    \n    \n    local lst_A=();\n    local lst_B=();\n \
    \   local k num=0;\n    local i j;\n    local lst_str=\"\";\n    local lst_str_1=\"\
    \";\n    \n    while (( $#1 > 0 )); do\n        lst_str=$1;\n        for ((i=0;\
    \ i < ${#lst_str}; i++)); do\n            ((num=num*10+${lst_str[i]} - 1));\n\
    \            lst_A[$i]=$num;\n        done\n        lst_str=$1;\n        ((k=num/${lst_str[1]}\
    \ - 1));\n        num=0;\n        for ((i=0; i < ${#lst_str}; i++)); do\n    \
    \        ((num=num*10+${lst_str[i]} - 1));\n            lst_B[$i]=$num;\n    \
    \    done\n        lst_str=$1;\n    done\n    for ((i=0; i < ${#lst_A[@]}; i++));\
    \ do\n        lst_str_1=\"\";\n        for ((j=0; j < ${#lst_A[@]}; j++)); do\n\
    \            if ((lst_A[i] < lst_B[j])); then\n                lst_str_1=\"${lst_str_1}${lst_A[i]}\
    \ \";\n            else\n                lst_str_1=\"${lst_str_1}${lst_B[j]} \"\
    ;\n            fi;\n        done\n        lst_A[$i]=${lst_str_1};\n    done\n\
    \    \n    echo \"${lst_A[@]}\"", "  local n=\"${1}\"\n  local k=\"${2}\"\n\n\
    \  local ret=0\n  local -i i=0\n  while [ $i -lt $n ]; do\n    local vals=\"$(echo\
    \ \"${1:$i:2}\"| sort -n | uniq | sed \"s/ /\\n/g\")\"\n    local lst=\"${vals}\"\
    \n    local j=0\n    while [ $j -lt $k ]; do\n      lst=( $(echo \"${lst[@]}\"\
    \ | grep -v \"${lst[$j]}\" | sort -n) )\n      local j=$((j+1))\n    done\n  \
    \  for j in \"${lst[@]}\"; do\n      ret=$((ret+1))\n      echo -n \"${lst[$j]}\"\
    \n    done\n    i=$((i+1))\n  done\n  echo -n \"${lst[$k]}\"\n  echo \"${ret}\"",
  "    local A=$1\n    local K=$2\n    local K0=0\n    local A0 \n\n    while [[ ${K}\
    \ -ne 0 ]]; do\n        echo ${A} > /tmp/a.txt\n        A0=$(sort -u /tmp/a.txt)\n\
    \        K0=$K\n        A=$(sed -n '1s/.*\\(.*\\)/\"\\1\"/p' <<< ${A})\n     \
    \   K=$(sed -n '1s/.*\\(.*\\)/\"\\1\"/p' <<< ${A})\n        echo ${A} > /tmp/a.txt\n\
    \    done\n    A0=$(sort -u /tmp/a.txt)\n    echo ${A0}", "  local lst_A=\"${1//\
    \ /\\n}\"\n  local k=\"${2}\"\n  local i j x y a b c d e f g h i j k\n  local\
    \ lst_B\n  [[ \"${#lst_A}\" -lt \"${k}\" ]] && return 1\n  lst_B=()\n  x=y=0\n\
    \  while (( x < k )); do\n    [[ \"$lst_A\" = \"${lst_B}\" ]] && return 0\n  \
    \  (( x++ ))\n    (( y++ ))\n    (( x >= k )) && return 1\n    i=0;\n    for ((\
    \ j=0 ; j < y ; j++ )); do\n      for (( a=0 ; a < x ; a++ )); do\n        c=\"\
    ${lst_A[${a}]}\"\n        d=\"${lst_A[${x}+${a}]}\"\n        e=\"${lst_A[${x}+${y}]}\"\
    \n        f=\"${lst_A[${y}+${x}]}\"\n        g=\"${lst_A[${y}+${y}]}\"\n     \
    \   h=\"${lst_A[${y}+${x+1}]}\"\n        i=\"${lst_A[${y}+${y+1}]}\"\n       \
    \ j=\"${lst_A[${x+1}+${y}]}\"\n        k=\"${lst_A[${x+1}+${y}+${x}]}\"\n    \
    \    lst_B+=(\"$c\")\n        lst_B+=(\"$d\")\n        lst_B+=(\"$e\")\n     \
    \   lst_B+=(\"$f\")\n        lst_B+=(\"$g\")\n        lst_B+=(\"$h\")\n      \
    \  lst_B+=(\"$i\")\n        lst_B+=(\"$j\")\n        lst_B+=(\"$k\")\n      done\n\
    \    done\n  done\n  [[ \"${#lst_B}\" -lt \"${k}\" ]] && return 1\n  sort -u <<<\
    \ \"${lst_B[@]}\"", "    local lines=$1\n    local size=$2\n    local k=$(echo\
    \ $lines | wc -l | awk '{print $1}')\n    local lines=$(echo $lines | sed 's/^\\\
    s*//' | sed 's/\\s*$//')\n    local A=()\n    local B=()\n    local C=()\n   \
    \ local i\n    local j\n    local temp\n\n    for ((i=1; i<=k; i++)); do\n   \
    \     for ((j=0; j<i; j++)); do\n            C[${j}]=${C[${j}]:0:i-1}\n      \
    \  done\n        A[i]=( $(echo $lines | sed -n -e \"s/^ *${i} *$/\\1/p\"))\n \
    \       i=$(echo $i | awk '{print $1}')\n    done\n    local t\n    local cnt\n\
    \    local ind\n    local min\n    local m\n    local mval\n    local i\n    local\
    \ j\n    local mval\n    local j\n    local k\n    local i\n    local mval\n \
    \   local mval\n\n    for ((i=1; i<=k; i++)); do\n        for ((j=0; j<i; j++));\
    \ do\n            cnt=0\n            temp=\n            for ((k=0; k<i; k++));\
    \ do\n                ind=$((${i}+k))\n                if [[ \"$A[$ind]\" =~ \"\
    $A[$j]\" ]]; then\n                    cnt=$((cnt+1))\n                    temp=\"\
    ${temp}${A[$ind]}\"\n                fi\n            done\n            if (( cnt\
    \ < i )); then\n                B[$i]=${B[$i]:0:j-1}\n                j=$((j+1))\n\
    \            else\n                B[$i]=${B[$i]:0:j-1}\n                A[$i]=${A[$i]:0:j-1}\n\
    \            fi\n        done\n        i=$(echo $i | awk '{print $1}')\n    done\n\
    \    m=$(( $k ))\n    mval=$(($size))\n    min=$(($size))\n    i=0\n    for ((j=0;\
    \ j<m; j++)); do\n        for ((k=0; k<m; k++)); do\n            if [[ \"$B[$i]\"\
    \ =~ \"$B[$k]\" ]]; then\n                cnt=$((cnt+1))\n                if [[\
    \ \"$cnt\" -gt \"$mval\" ]]; then\n                    min=$(( $i ))\n       \
    \             mval=$(( $cnt ))", "  local N=${#$1-1}\n  local N=$((N % 2))\n\n\
    \  local lstA=${#$1} | sort -n -k 1\n  local lstB=$1\n  local lstC=$2\n  local\
    \ i=0\n  local result\n\n  while [[ \"$lstA[$i]\" -lt \"$lstC\" ]]; do\n    i=$((i+2))\n\
    \  done\n  result=$( printf \"%q\\n\" \"${lstB[@]}\" | sort -n -k 1 )\n  \n  local\
    \ j=0\n  while [[ \"$j\" -lt \"$i\" ]]; do\n    lstB[$j]=\"$lstA[$j]\"\n    i=$((i+2))\n\
    \    lstC=$( printf \"%q\\n\" \"${lstB[@]}\" | sort -n -k 1 )\n  done\n\n  while\
    \ [[ \"$lstC\" != \"${lstB[$i]}\" ]]; do\n    i=$((i+2))\n  done\n\n  while [[\
    \ \"$j\" -lt \"$i\" ]]; do\n    lstB[$j]=\"$lstA[$j]\"\n    i=$((i+2))\n    lstC=$(\
    \ printf \"%q\\n\" \"${lstB[@]}\" | sort -n -k 1 )\n  done\n  printf \"%s\\n\"\
    \ \"${lstB[@]}\"", "  local lst_A=\"${1#*$'\\n'}\"\n  local lst_B=\"${2#*$'\\\
    n'}\"\n  local len=\"${#lst_A[@]}\"\n  if [ $len -eq 0 ]; then\n    echo \"\"\n\
    \    return 0\n  fi\n  if [ $len -eq 1 ]; then\n    local i\n    local j\n   \
    \ for ((i=1; i <= $1; i++)); do\n      local c=\"${lst_A[i - 1]}\"\n      ((j=1))\n\
    \      while [ $((j-1)) <= $len ] && [ \"$lst_A[$j]\" == \"$c\" ]; do\n      \
    \  ((j++))\n      done\n      echo \"$c\"\n    done\n  else\n    local i\n   \
    \ local j\n    local k\n    for ((i=1; i <= $1; i++)); do\n      local c=\"${lst_A[i\
    \ - 1]}\"\n      ((j=1))\n      while [ $((j-1)) <= $len ] && [ \"$lst_A[$j]\"\
    \ == \"$c\" ]; do\n        ((j++))\n      done\n      local c=\"${lst_B[i - 1]}\"\
    \n      ((k=1))\n      while [ $((k-1)) <= $len ] && [ \"$lst_B[$k]\" == \"$c\"\
    \ ]; do\n        ((k++))\n      done\n      echo \"$c\"\n    done\n  fi", "  local\
    \ lst_A=$(echo $1 | tr -d \"\\n\\r\")\n  local lst_B=$(echo $1 | tr -d \"\\n\\\
    r\")\n  local n=$2\n  local i j\n  local path_A=()\n  local path_B=()\n  local\
    \ tmp\n  \n  i=0; \n  j=0; \n  while [ $i -lt $n ]; do\n    path_A+=(\"$lst_A[$j]\"\
    )\n    path_B+=(\"$lst_B[$j]\")\n    (( i++ ))\n    (( j++ ))\n  done\n\n  for\
    \ j in $(seq 0 $((n - 1)) ); do\n    for i in $(seq 0 $((n - 1)); do\n      if\
    \ [[ $i -lt $j ]]; then\n        tmp=${path_A[$i]} ${path_B[$j]}\n        if [[\
    \ $(echo $tmp | sort | uniq | wc -l ) -eq 1 ]]; then\n          path_A[i]=\"${path_A[i]}\
    \ ${path_B[j]}\"\n          path_B[j]=\"${path_B[j]} ${path_A[i]}\"\n        \
    \  break\n        fi\n      fi\n    done\n  done\n  \n  echo $(echo $path_A |\
    \ sed -e \"s/^\\\"//\" -e \"s/\\\"$//\" | tr \" \" \"\\n\")", "  [[ $# != 2 ]]\
    \ && echo \"Wrong number of arguments\" && return 1\n  \n  # parse input\n  mapfile\
    \ -t lst_A < <(echo \"$1\" | tr ' ' '\\n')\n  mapfile -t lst_B < <(echo \"$2\"\
    \ | tr ' ' '\\n')\n  mapfile -t lst_A < <(echo \"$3\" | tr ' ' '\\n')\n  mapfile\
    \ -t lst_B < <(echo \"$4\" | tr ' ' '\\n')\n\n  [[ \"${#lst_A[@]}\" == \"${#lst_B[@]}\"\
    \ ]] && return 1\n\n  local k i\n  local min_value path\n  local new_lst_A new_lst_B\n\
    \  local sorted_lst_A sorted_lst_B\n\n  # calculate sorted list\n  i=1\n  k=\"\
    $((${#lst_A[@]} + 1))\"\n  while [ $i -le $k ]; do\n    [[ ${lst_A[$i]} -gt ${lst_B[$i]}\
    \ ]] && break\n    sorted_lst_A+=(\"$lst_A[$i]\")\n    i=$(( $i + 1 ))\n  done\n\
    \  [[ $i -eq $k ]] && return 1\n\n  i=$(( $i - 1 ))\n  while [ $i -le $k ]; do\n\
    \    [[ ${lst_A[$i]} < ${lst_B[$i]} ]] && break\n    sorted_lst_B+=(\"$lst_B[$i]\"\
    )\n    i=$(( $i + 1 ))\n  done\n\n  # return answer with index\n  path=\"\"\n\
    \  i=0\n  while [ $i -le $k ]; do\n    [[ -z $path ]] && path=\"$sorted_lst_A[$i]\"\
    \ || path=\"$path \\\"$sorted_lst_A[$i]\\\"\"\n    [[ -z $path ]] && path=\"$sorted_lst_B[$i]\"\
    \ || path=\"$path \\\"$sorted_lst_B[$i]\\\"\"\n    i=$(( $i + 1 ))\n  done\n \
    \ echo \"$path\"", "\tlocal -i N=\"${#1}\"\n\tlocal -i K=\"${2:-}\"\n\tlocal -i\
    \ i\n\tlocal -i k\n\tlocal -i j\n\tlocal j\n\tlocal val\n\tlocal lst_A\n\tlocal\
    \ lst_B\n\tlocal i\n\tlocal j\n\tlocal lst\n\tlocal res\n\t\n\tlst_A=($(echo $1\
    \ | sed 's/^ *//g' | sed 's/ *$//g' | sed 's/ /\\n/g'))\n\tlst_B=($(echo $1 |\
    \ sed 's/^ *//g' | sed 's/ *$//g' | sed 's/ /\\n/g' | sort -n | head -n))\n\t\
    i=1\n\twhile [[ $i -le $K ]]; do\n\t\tj=1\n\t\twhile [[ $j -le $K ]]; do\n\t\t\
    \tif [[ $j -eq 1 ]]; then\n\t\t\t\tval=${lst_A[$i]}\n\t\t\telif [[ $j -gt 1 ]];\
    \ then\n\t\t\t\tval=${lst_B[$j]}\n\t\t\tfi\n\t\t\tlst+=(\"$val\")\n\t\t\t((j++))\n\
    \t\tdone\n\t\t((i++))\n\tdone\n\tres=()\n\tfor j in $(seq 1 $K); do\n\t\t(( k=$j-1\
    \ ))\n\t\twhile [[ $k -lt $K ]]; do\n\t\t\t(( k--))\n\t\t\tlst[$k]=\"${lst[$k]}\"\
    \n\t\tdone\n\t\t(( k=$j+1 ))\n\t\twhile [[ $k -lt $K ]]; do\n\t\t\t(( k++))\n\t\
    \t\tlst[$k]=\"${lst[$k]}\"\n\t\tdone\n\t\tres+=(\"${lst[*]}\")\n\tdone\n\techo\
    \ \"${res[@]}\"", "  # Get grid dimensions (rows and cols)\n  nRows=$((${1:0:${#2}}-1))\n\
    \  nCols=$((${1:${#2}}-1))\n  # Store initial grid\n  grid=$(cat <<EOF\n$nRows\n\
    $nCols\nEOF\n)\n  # Process grid\n  while read -r line\n  do\n    # Store values\
    \ in list\n    set -- $line\n    # Extract integer values\n    int_array=( $@\
    \ )\n    # Store values in 2d array\n    declare -A arr\n    for ((i=0; i<${#int_array[@]};\
    \ ++i)); do\n      arr[$int_array[i]]=\"${arr[$int_array[i]]}\"\n    done\n  \
    \  # Store array in memory\n    declare -n arr=( $arr )\n    grid+=$'\\n'\"${arr[@]}\"\
    \n  done <<< $grid\n  # Process grid and sort\n  sort -u | sed \"s/^ *//\"", " \
    \   local grid=$1\n    local k=$(echo $2 | tr '\\n' ' ')\n    local n=$(awk '{\
    \ print NF }'<<< $grid)\n\n    local cells_all\n    cells_all=$(echo \"$grid\"\
    \ | tr '\\n' ' ')\n\n    local cells=$cells_all\n    local cells_sorted\n\n  \
    \  local cells_length\n    cells_length=$(echo $cells_all | tr '\\n' ' ' | tr\
    \ ' ' '\\n' | sort | uniq | wc -l)\n\n    local cells_index\n    cells_index=$(echo\
    \ $(echo $cells_all | tr '\\n' ' ' | tr ' ' '\\n' | sort | uniq | awk '{ print\
    \ NR }') - 1 |bc)\n\n    local cells_index_sorted\n    cells_index_sorted=$(echo\
    \ $cells_index | tr '\\n' ' ' | tr ' ' '\\n' | sort | uniq)\n\n    local cells_index_sorted1\n\
    \    cells_index_sorted1=$(echo $cells_index_sorted | tr ' ' '\\n' | sort | uniq)\n\
    \n    local cells_index_sorted2\n    cells_index_sorted2=$(echo $cells_index_sorted\
    \ | tr '\\n' '\\t' | sort | uniq)\n\n    local cells_index_sorted3\n    cells_index_sorted3=$(echo\
    \ $cells_index_sorted | tr '\\t' '\\n' | sort | uniq)\n\n    local cells_index_sorted4\n\
    \    cells_index_sorted4=$(echo $cells_index_sorted | tr '\\n' ' ' | tr ' ' '\\\
    t' | sort | uniq)\n\n    local cells_index_sorted5\n    cells_index_sorted5=$(echo\
    \ $cells_index_sorted | tr '\\t' '\\n' | sort | uniq)\n\n    local cells_index_sorted6\n\
    \    cells_index_sorted6=$(echo $cells_index_sorted | tr '\\n' ' ' | tr ' ' '\\\
    t' | sort | uniq)\n\n    local cells_index_sorted7\n    cells_index_sorted7=$(echo\
    \ $cells_index_sorted | tr '\\t' '\\n' | sort | uniq)\n\n    local cells_index_sorted8\n\
    \    cells_index_sorted8=$(echo $cells_index_sorted | tr '\\n' ' ' | tr ' ' '\\\
    t' | sort | uniq)\n\n    local cells_index_sorted9\n    cells_index_sorted9=$(echo\
    \ $cells_index_sorted | tr '\\t' '\\n' | sort | uniq)\n\n    local cells_index_sorted10\n\
    \    cells_index_sorted10=$(echo $cells_index_sorted | ", "    local -n arr=$1\n\
    \    local -n len=$2\n    local i j k\n    local -a lst len_lst path_lst\n   \
    \ local -a arr2\n    local -a path_arr\n    local -a path_arr2\n    local -a lst_arr\
    \ lst_arr2\n    local ret\n    local -a str_arr\n    local arr_size\n    arr_size=$#\n\
    \    arr2=($arr)\n    for (( i = 0; i < ${arr_size}; i++ )); do\n        arr2+=(\
    \ ${arr2[$i]} \"$i\" )\n    done\n    # get the array size\n    len=$#\n    len_lst=($len)\n\
    \    # loop through all the cells\n    for (( i = 0; i < ${arr_size}; i++ ));\
    \ do\n        arr2+=( ${arr2[$i]} )\n        path_arr2=($path_arr)\n        #\
    \ loop through all the neighboring cells\n        for (( j = 0; j < ${len_lst};\
    \ j++ )); do\n            path_arr2+=( ${path_arr2[$j]} )\n        done\n    \
    \    # sort each array\n        path_arr2=( $(compgen -G -- ${path_arr2[*]}) )\n\
    \        # sort all the arrays\n        arr2=( $(compgen -G -- ${arr2[*]}) )\n\
    \        # compare them and add them to the list\n        for (( k = 0; k < ${len};\
    \ k++ )); do\n            if [ ${arr2[$k]} -eq ${path_arr2[$k]} ]; then\n    \
    \            lst=$lst$arr2[$k]\n            fi\n        done\n        lst_arr=($lst)\n\
    \    fi\n    # sort the list\n    lst_arr=( $(compgen -G -- ${lst_arr[*]}) )\n\
    \    # put them back into arr\n    for (( i = 0; i < ${arr_size}; i++ )); do\n\
    \        arr2+=( ${lst_arr[$i]} )\n    done\n    # get the string of the arr\n\
    \    for (( i = 0; i < ${arr_size}; i++ )); do\n        arr2+=( ${arr2[$i]} )\n\
    \        str_arr+=( ${arr2[$i]} )\n    done\n    # trim extra quotes\n    str_arr=(\
    \ $( echo \"${str_arr[@]}\" | sed 's/\"//g' ) )\n    # remove duplicates\n   \
    \ str_arr=( $( echo \"${str_arr[@]}\" | sort -u ) )\n", "\tlocal lines=$1\n\t\
    local k=$2\n\tlocal min=$k\n\tlocal index=1\n\tlocal lst_A \n\tlocal lst_B\n\t\
    lst_A=$(echo $lines | tr \" \" \"\\n\")\n\tlst_B=$(echo $lines | tr \" \" \"\\\
    n\")\n\twhile [ $index -lt $k ]; do\n\t\tlocal new_min=$((${#lst_A[@]} - 1))\n\
    \t\twhile [ $new_min -lt $min ]; do\n\t\t\tnew_min=$((new_min + 1))\n\t\tdone\n\
    \t\tlocal tmp_min=$min\n\t\tlocal tmp_lst_A \n\t\tlocal tmp_lst_B\n\t\ttmp_lst_A=$(echo\
    \ $lst_A | awk -v n=$tmp_min '{print $n}')\n\t\ttmp_lst_B=$(echo $lst_B | awk\
    \ -v n=$tmp_min '{print $n}')\n\t\tlocal tmp_new_min=$new_min\n\t\tlocal tmp_index=1\n\
    \t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\twhile [ $tmp_index -le $tmp_new_min\
    \ ]; do\n\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\twhile [\
    \ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\twhile [ $tmp_index -le $tmp_new_min\
    \ ]; do\n\t\t\t\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\
    \t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\twhile [ $tmp_index\
    \ -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\twhile [ $tmp_index -le $tmp_new_min\
    \ ]; do\n\t\t\t\t\t\t\t\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\
    \t\t\t\t\t\t\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\
    \t\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile\
    \ [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile [\
    \ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile [\
    \ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile\
    \ [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    while [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\twhile [ $tmp_index -le $tmp_new_min ]; do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t", "    local lst_A\n    local lst_B\n    local i\n\n    lst_A=$(echo\
    \ $1 | tr -s ' ' $'\\n')\n    lst_B=$(echo $2 | tr -d '\"')\n    for i in $(seq\
    \ 1 $((${#lst_A}-1)))\n    do\n        local j\n        for j in $(seq 1 $((${#lst_B}-1)))\n\
    \        do\n            if [ ${lst_A[i]} == ${lst_B[j]} ]\n            then\n\
    \                echo \"$lst_A[$i] $lst_B[$j]\"\n                break\n     \
    \       fi\n        done\n    done", "    local g=\"$1\"\n    local k=\"$2\"\n\
    \    local out=\"\"\n    for ((i=1; i<k; i++)); do\n        out+=\"$(minPath \"\
    $g\" \"$((k - i))\")\"\n    done\n    \n    echo \"${out}\"", "    local arr=$1\n\
    \    local k=$2\n    local a\n    local b\n    local lst_a\n    local lst_b\n\
    \    local i\n    local j\n    local answer\n    arr=($arr) #Convert to array\n\
    \    for a in ${arr[@]} #Iterate through array\n    do\n        a=`echo $a | tr\
    \ \" \" \"\\n\"` #Trim spaces \n        lst_a=(\"${!a}\") #Convert to array\n\
    \        lst_b=(\"${!arr[@]}\") #Convert to array\n        b=${lst_a[0]} #Set\
    \ b to first element of lst_a\n        i=1\n        while [[ $i -le $k ]]\n  \
    \      do\n            b=${lst_a[$i]} #Set b to next element of lst_a\n      \
    \      i=$((i+1)) #Increment i\n        done\n        b=${lst_b[$i]} #Set b to\
    \ next element of lst_b\n        i=1\n        while [[ $i -le $k ]]\n        do\n\
    \            answer[$i]=\"\\\"$a\\\" \"\n            answer[$i]=\"${answer[$i]}\\\
    \"$b\\\" \"\n            i=$((i+1)) #Increment i\n        done\n    done\n   \
    \ answer=(${answer[@]}) #Convert back to array\n    echo ${answer[@]} | tr \"\
    \ \" \"\\n\" #Print array", "\t[[ \"$#\" -ne 2 ]] && printf 'Wrong number of arguments,\
    \ exiting...\\n' && exit 1\n\t\n\tlocal i n v rn rv\n\tn=$(echo $1 | cut -d'\\\
    n' -f1)\n\tv=$(echo $1 | cut -d'\\n' -f2)\n\t\n\t# make a list of n strings\n\t\
    local l\n\tlocal j\n\tfor (( i=0; i<$n; i++ )); do\n\t\tl+=\"\\\"$v\\\",\"\n\t\
    done\n\n\t# remove the last comma and space\n\tl=${l%,}\n\tl=${l%,}\n\t\n\twhile\
    \ [ $(echo $1 | grep $rv |wc -l) -ne 1 ]; do\n\t\trm $rv\n\t\trv=$rv$v\n\t\t\n\
    \t\t(( i+=1 ))\n\t\t\n\t\t# remove the last comma and space\n\t\tl=${l%,}\n\t\t\
    l=${l%,}\n\tdone\n\t\n\tlocal k\n\tfor (( i=0; i<$n; i++ )); do\n\t\tk=$((i+1))\n\
    \t\tlocal l\n\t\tfor (( j=$i+1; j<$n; j++ )); do\n\t\t\tl=$l$l\n\t\tdone\n\t\t\
    l=$l$l\n\t\t\n\t\t# remove the last comma and space\n\t\tl=${l%,}\n\t\tl=${l%,}\n\
    \t\t\n\t\tlocal lst_A\n\t\tlocal lst_B\n\t\t\n\t\tread -a lst_A <<< \"$l\"\n\t\
    \tread -a lst_B <<< \"$l\"\n\t\n\t\t# remove the last comma and space\n\t\tl=${l%,}\n\
    \t\tl=${l%,}\n\t\t\n\t\tlst_B=$lst_B$l\n\t\n\t\t# remove the last comma and space\n\
    \t\tl=${l%,}\n\t\tl=${l%,}\n\t\t\n\t\tlst_A=$lst_A$l\n\t\t\n\t\t# remove the last\
    \ comma and space\n\t\tl=${l%,}\n\t\tl=${l%,}\n\t\t\n\t\tlst_A=$lst_A$l\n\t\t\n\
    \t\t# remove the last comma and space\n\t\tl=${l%,}\n\t\tl=${l%,}\n\t\t\n\t\t\
    lst_A=$lst_A$l\n\t\t\n\t\tlst_A=$(echo $lst_A | sed 's/,$//g')\n\t\tlst_B=$(echo\
    \ $lst_B | sed 's/", "    local GRID=\"$1\"\n    local k=\"$2\"\n    local lst_A\n\
    \    local lst_B\n    local i\n    local j\n    local a\n    local b\n    local\
    \ l\n    local c\n    local output\n    local p\n\n    [[ \"$k\" -le \"$((N *\
    \ N))\" ]]\n    \n    lst_A=$(echo \"$GRID\" | awk '{for (i=1; i <= k; i++) printf\
    \ \"%s\" \"\\\"$1\\\"\\n\"}')\n    lst_B=$(echo \"$GRID\" | awk '{for (i=1; i\
    \ <= k; i++) printf \"%s\" \"\\\"$i\\\"\\n\"}')\n    \n    lst_A=(${lst_A// /\
    \ })\n    lst_B=(${lst_B// / })\n\n    for i in $(seq 0 \"$k\")\n    do\n    \
    \    ((c=$i))\n        a=\"${c}\"\n        b=\"${c+1}\"\n        l=($a)\n    \
    \    l=(${l// / })\n        lst_A=(${lst_A// / })\n        lst_B=(${lst_B// /\
    \ })\n        lst_A[$i]=\"\\\"${lst_A[$i]}\\\"\"\n        lst_B[$i]=\"\\\"${lst_B[$i]}\\\
    \"\"\n    done\n    \n    for i in $(seq 0 \"$k\")\n    do\n        ((c=$i))\n\
    \        a=\"${c}\"\n        b=\"${c-1}\"\n        l=($a)\n        l=(${l// /\
    \ })\n        lst_A=(${lst_A// / })\n        lst_B=(${lst_B// / })\n        lst_A[$i]=\"\
    \\\"${lst_A[$i]}\\\"\"\n        lst_B[$i]=\"\\\"${lst_B[$i]}\\\"\"\n    done\n\
    \n    for i in $(seq 0 \"$k\")\n    do\n        ((c=$i))\n        a=\"${c}\"\n\
    \        b=\"${c+1}\"\n        lst_A[$i]=\"\\\"${lst_A[$i]}\\\"\"\n        lst_B[$i]=\"\
    \\\"${lst_B[$i]}\\\"\"\n    done\n    \n    for i in $(seq 0 \"$k\")\n    do\n\
    \        ((c=$i))\n        a=\"${c}\"\n        b=\"${c-1}\"\n        lst_A[$i]=\"\
    \\\"${lst_A[$i]}\\\"\"\n        lst_B[$i]=\"\\\"${lst_B[$i]}\\\"\"\n    done\n\
    \    \n    for i in $(seq 0 \"$k\")\n    do\n        ((c=$i))\n        a=\"${c}\"\
    \n        b=\"${c", "    local lst_A lst_B i j k answer tmp count\n    lst_A=$1\n\
    \    lst_B=$2\n    k=${#lst_B}\n    count=$((k + 1))\n    answer=($(eval echo\
    \ \"{${lst_A[@]}}\"${lst_B[@]}))\n    for ((i = 1; i <= k; i++)); do\n       \
    \ lst_A[$i]=$(eval echo \"{${answer[@]}}${lst_A[$i]}\")\n    done\n    for ((j\
    \ = 1; j <= k; j++)); do\n        lst_B[$j]=$(eval echo \"{${lst_B[@]}}${lst_B[$j]}\"\
    )\n    done\n    answer=($(eval echo \"{${answer[@]}}\"${lst_A[@]}))\n    for\
    \ ((i = 1; i <= k; i++)); do\n        tmp=$(eval echo \"{${answer[@]}}${lst_B[$i]}\"\
    )\n        lst_A[$i]=$(eval echo \"${tmp}\"${lst_A[$i]}\")\n    done\n    for\
    \ ((j = 1; j <= k; j++)); do\n        tmp=$(eval echo \"${lst_A[$j]}\"${lst_B[$j]}\"\
    )\n        lst_B[$j]=$(eval echo \"${lst_B[$j]}\"${tmp})\n    done\n    answer=($(eval\
    \ echo \"{${answer[@]}}\"${lst_A[@]}))\n    for ((i = 1; i <= k; i++)); do\n \
    \       tmp=$(eval echo \"{${answer[@]}}${lst_B[$i]}\")\n        lst_A[$i]=$(eval\
    \ echo \"${tmp}\"${lst_A[$i]}\")\n    done\n    for ((j = 1; j <= k; j++)); do\n\
    \        tmp=$(eval echo \"${lst_A[$j]}\"${lst_B[$j]}\")\n        lst_B[$j]=$(eval\
    \ echo \"${lst_B[$j]}\"${tmp})\n    done\n    answer=($(eval echo \"{${answer[@]}}\"\
    ${lst_A[@]}))\n    for ((i = 1; i <= k; i++)); do\n        tmp=$(eval echo \"\
    {${answer[@]}}${lst_B[$i]}\")\n        lst_A[$i]=$(eval echo \"${tmp}\"${lst_A[$i]}\"\
    )\n    done\n    for ((j = 1; j <= k; j++)); do\n        tmp=$(eval echo \"${lst_A[$j]}\"\
    ${lst_B[$j]}\")\n        lst_B[$j]=$(eval echo \"${lst_B[$j]}\"${tmp})\n    done\n\
    \    answer=($(eval echo \"", "    [[ \"$#\" -lt \"2\" ]] && echo \"Wrong number\
    \ of parameters\" && exit 1;\n    local lst_A; local lst_B; local i; local j;\n\
    \    [[ \"$2\" =~ ^[+-]?[0-9]+$ ]] && { echo \"Wrong input format\"; exit 1; };\n\
    \    lst_A=$(echo $1 | tr \" \" \",\");\n    lst_B=$(echo $2 | tr \" \" \",\"\
    );\n    [[ \"$#\" -eq 2 ]] && { echo \"Wrong input format\"; exit 1; };\n    for\
    \ ((i=0; i < ${#lst_A}; i++)); do\n        for ((j=0; j < ${#lst_B}; j++)); do\n\
    \            [[ ${lst_A[$i]} -eq ${lst_B[$j]} ]] && {\n                local temp_A;\
    \ local temp_B; local temp_lst_A; local temp_lst_B;\n                [[ \"$i\"\
    \ -ge 1 ]] && { temp_A=$lst_A[${i}-1]; temp_B=$lst_B[${j}-1]; temp_lst_A=$lst_A;\
    \ temp_lst_B=$lst_B; }\n                [[ \"$i\" -eq ${#lst_A} ]] && {\n    \
    \                temp_A=$lst_A[${i}-1];\n                    temp_B=$lst_B[${j}-1];\n\
    \                    temp_lst_A=$lst_A;\n                    temp_lst_B=$lst_B;\n\
    \                };\n                [[ \"$j\" -ge 1 ]] && {\n               \
    \     temp_A=$temp_A;\n                    temp_B=$temp_B;\n                 \
    \   temp_lst_A=$temp_lst_A;\n                    temp_lst_B=$temp_lst_B;\n   \
    \             };\n                [[ \"$j\" -eq ${#lst_B} ]] && {\n          \
    \          temp_A=$temp_A;\n                    temp_B=$temp_B;\n            \
    \        temp_lst_A=$temp_lst_A;\n                    temp_lst_B=$temp_lst_B;\n\
    \                };\n                if [[ \"$temp_A\" -gt \"${temp_B}\" ]]; then\
    \ \n                    [[ \"$temp_lst_A\" -eq \"${temp_lst_B}\" ]] && {\n   \
    \                     temp_A=${temp_lst_A};\n                        temp_B=${temp_lst_B};\n\
    \                        lst_A=\"${lst_A}/${temp_A}\";\n                     \
    \   lst_B=\"${lst_B}/${temp_B}\";\n                    }\n                elif\
    \ [[ \"$temp_A\" -lt \"$temp_B\" ", "    echo \"$1\" | awk -F\" \" '{\n      \
    \  for (i = 1; i <= NF; i++) {\n            for (j = 1; j <= NF; j++) {\n    \
    \            arr[i][j] = $(cut -d',' -f$i)\n            }\n        }\n       \
    \ \n        for (i = 1; i <= NF; i++) {\n            cnt[i]++\n        }\n   \
    \     \n        for (i = 1; i <= NF; i++) {\n            for (j = 1; j <= NF;\
    \ j++) {\n                if (cnt[i - 1] > 0 && arr[i][j] == arr[i][j - 1])\n\
    \                    cnt[i]--\n                if (cnt[i] > 0 && arr[i][j] ==\
    \ arr[i + 1][j])\n                    cnt[i]--\n                if (cnt[i] > 0\
    \ && arr[i][j] == arr[i][j + 1])\n                    cnt[i]--\n            }\n\
    \        }\n        \n        if (NF > 0) {\n            minPathLength += NF\n\
    \            arr[0][NF - 1] = 1\n        } else {\n            minPathLength +=\
    \ 1\n        }\n        \n        for (i = 1; i <= NF; i++) {\n            ind[i]\
    \ = 0\n            for (j = 1; j <= NF; j++) {\n                if (arr[i][j]\
    \ == arr[i][j - 1])\n                    ind[i]++\n                if (arr[i][j]\
    \ == arr[i + 1][j])\n                    ind[i]++\n                if (arr[i][j]\
    \ == arr[i][j + 1])\n                    ind[i]++\n            }\n        }\n\
    \        \n        delete arr[NF]\n        delete arr\n        delete cnt\n  \
    \      \n        for (i = 1; i <= NF; i++) {\n            arr[i][i] = 0\n    \
    \    }\n        \n        for (i = 1; i <= NF; i++) {\n            cnt[i] = 0\n\
    \        }\n        \n        for (i = 1; i <= NF; i++) {\n            for (j\
    \ = 1; j <= NF; j++) {\n                if (ind[i] > 0) {\n                  \
    \  arr[i][j] = arr[i][j - 1]\n                    ind[i]--\n                }\n\
    \                if (ind[i] > 0) {\n                    arr[i][j] = arr[i + 1][j]\n\
    \                    ind[i]--\n                }\n                if (ind[i] >\
    \ 0) {\n                    arr[i][j] = arr[i][j + 1]\n                    ind[i]--\n\
    \                }\n            }\n        }\n        \n        for (i = 1; i\
    \ <= NF; i++) {\n            if (arr[i][i] != 0) {\n                minPathLength\
    \ += 1\n                break\n            }\n        }\n        \n        for\
    \ (i = 1; i <= NF; i++) {\n            arr[i][i] = 0\n        }\n        \n  \
    \      for (i = 1; i <= NF; i++) {\n            cnt[i] = 0\n        }\n      \
    \  \n        for (i = 1; i <= NF; i++) {\n            for (j = 1; j <= NF; j++)\
    \ {\n                if (ind[i] > 0) {\n                    arr[i][j] = arr[i][j\
    \ - 1]\n                    ind[i]--\n                }\n                if (ind[i]\
    \ > 0) {\n                    arr[i][j] = arr[i + 1][j]\n                    ind[i]--\n\
    \                }\n                if (ind[i] > 0) {\n                    arr[i][j]\
    \ = arr[i][j + 1]\n                    ind[i]--\n                }\n         \
    \   }\n        }\n        \n        for (i = 1; i <= NF; i++) {\n            if\
    \ (arr[i][i] != 0) {", "    local lines=$1\n    local maxN=$2\n    local n=0\n\
    \    local d=\"1 2 3\\n4 5 6\\n7 8 9\"\n    local i=$((${#lines[@]} / maxN))\n\
    \    local j=$((${#lines[@]} % maxN))\n    while [ $n -lt $i ]\n    do\n     \
    \   local s=${lines[$((n*maxN+j))]}\n        local p=$((n*maxN+j))\n        ((j--))\n\
    \        local m=$((j/maxN))\n        local x=$((j*maxN))\n        local c=$((m*maxN))\n\
    \        local b=$((maxN))\n        local e=$((c+m*maxN))\n        local u\n \
    \       for ((j=1;j<=$((maxN));j++))\n        do\n            u=$((x+j))\n   \
    \         echo $u\n            echo $s\n            echo $p\n            echo\
    \ $c\n            echo $x\n            echo $m\n            echo $j\n        \
    \    echo $s\n            echo $e\n            echo $b\n            echo $m\n\
    \            echo $p\n            echo $u\n            echo -n $s\n        done\n\
    \    done", "  local g=\"$1\"\n  local k=\"$2\"\n  local lst_A=$(gawk -v k=\"\
    $k\" '{\n    split($1, a, \" \");\n    split($2, b, \" \");\n    for (i = 1; i\
    \ <= k; i++) {\n      lst_A[i] += a[i] < b[i] ? i : i - 1;\n    }\n  }' <<< \"\
    $g\")\n  echo \"$lst_A\"", "\tlocal list=\"$1\"\n\tlocal x=\"$2\"\n\tlocal k\n\
    \t\n\techo \"$list\" | cut -d' ' -f1 | sort -u\n\t\n\tk=$(echo $list | cut -d'\
    \ ' -f1 | sort -u)\n\t\n\tfor ((i=1; i<=$x; i++))\n\tdo\n\t\techo \"$k\" | cut\
    \ -d' ' -f1 | sort -u | grep -i \"$i\"\n\tdone", "  local string=$1\n  local num=$2\n\
    \  local list1=()\n  local list2=()\n  local list3=()\n  local i\n  local j\n\
    \  local k\n\n  for i in $string; do\n    list1+=(\"$i\")\n  done\n  list1=$(sort\
    \ -u <<< \"$list1\")\n  for j in $list1; do\n    list2+=(\"$j\")\n  done\n  list2=$(sort\
    \ -u <<< \"$list2\")\n  for k in $list2; do\n    list3+=(\"$k\")\n  done\n  list3=$(sort\
    \ -u <<< \"$list3\")\n  for i in $list3; do\n    if [[ $i -eq $num ]]; then\n\
    \      echo \"$list1[0]\"\n      break\n    fi\n  done", "    local N\n    local\
    \ lst_A\n    local lst_B\n    local i j\n    \n    N=\"${#${1}}\"\n    if [[ $N\
    \ -eq 0 ]]; then\n        echo \"Empty grid\"\n        return 1\n    elif [[ $N\
    \ -gt 1 ]]; then\n        echo \"Invalid grid\"\n        return 1\n    elif [[\
    \ ! -z \"$2\" ]]; then\n        echo \"Invalid number of steps\"\n        return\
    \ 1\n    fi\n\n    lst_A=($(echo \"${1}\" | tr ' ' \"\\n\"))\n    lst_B=($(echo\
    \ \"${1}\" | tr ' ' \"\\n\"))\n\n    for (( i = 1; i <= N; i++ )); do\n      \
    \  for (( j = 1; j <= N; j++ )); do\n            lst_A[$i]=$(($lst_A[$i]))\n \
    \           lst_B[$j]=$(($lst_B[$j]))\n        done\n    done\n\n    local minIndex\n\
    \    local minLength\n    local temp\n\n    temp=$((N-1))\n    while (( temp >0\
    \ )); do\n        minLength=$((temp-1))\n        for (( i = 1; i <= minLength;\
    \ i++ )); do\n            for (( j = 1; j <= minLength; j++ )); do\n         \
    \       local a\n                local b\n                a=$lst_A[$i]\n     \
    \           b=$lst_B[$j]\n                if [[ $a -gt $b ]]; then\n         \
    \           minIndex=$i\n                else\n                    minIndex=$j\n\
    \                fi\n            done\n        done\n        for (( i = minIndex;\
    \ i <= N; i++ )); do\n            lst_A[$i]=$(($lst_A[$i]))\n        done\n  \
    \      for (( j = minIndex; j <= N; j++ )); do\n            lst_B[$j]=$(($lst_B[$j]))\n\
    \        done\n        temp=$((N-1))\n    done\n\n    local vals\n    local out\n\
    \n    vals=($(lrange \"${lst_A[@]}\" 1 ${#lst_A[@]}))\n    out=()\n\n    for ((\
    \ i = 1; i <= $2; i++ )); do\n        out+=(\"$vals[$((i-1))]\")\n        vals=($(lrange\
    \ \"${lst_B[@]}\" 1 ${#lst_B[@]}))\n    done\n\n    echo \"${out[@]}\"", "   \
    \ [[ ! -z \"$2\" ]] && [ \"$2\" -gt 0 ] && return 1\n    for (( i = 0; i < ${#1};\
    \ i++ )); do\n        lst_A=\"\"\n        for (( j=0; j < ${#1}; j++ )); do\n\
    \            echo \"${lst_A}${1}\"\n            lst_B=\"\"\n            for ((\
    \ j=0; j < ${#1}; j++ )); do\n                [[ \"${#lst_A}\" = ${#lst_B} ]]\
    \ && break\n                lst_B+=\"${1}\"\n            done\n            lst_A+=\"\
    \\\"${lst_B}\\\"\"\n        done\n    done\n    lst_A=( \"${lst_A}\" )\n    lst_A=${lst_A[@]##[\\\
    \"}\n    lst_A=${lst_A%\\\"]}\n    echo ${lst_A}", "    local A=\"$1\"\n    local\
    \ B=\"$2\"\n    local N=\"${#A}\"\n    local K=\"$N*$N\"\n    local i\n    local\
    \ j\n    local lst_A\n    local lst_B\n    \n    for i in $(seq 1 $N); do\n  \
    \      lst_A[$i]=\"\\\"${A//$'\\n'/}\\\"\"\n    done\n    for j in $(seq 1 $N);\
    \ do\n        lst_B[$j]=\"\\\"${B//$'\\n'/}\\\"\"\n    done\n    \n    for i in\
    \ $(seq 0 $((N-1)) -1 ); do\n        # print \"\"\n        \n        for j in\
    \ $(seq 0 $((N-1)) -1 ); do\n            if [ $(sort -n <<<\"${lst_A[i]}\" <<<\"\
    ${lst_B[j]}\") -ge $(sort -n <<<\"${lst_B[i]}\" <<<\"${lst_A[j]}\") ]; then\n\
    \                # print \"\"\n                echo \"${lst_A[i]}\"\n        \
    \        break\n            elif [ $(sort -n <<<\"${lst_B[i]}\" <<<\"${lst_A[j]}\"\
    ) -ge $(sort -n <<<\"${lst_A[i]}\" <<<\"${lst_B[j]}\") ]; then\n             \
    \   # print \"\"\n                echo \"${lst_B[j]}\"\n                break\n\
    \            elif [ \"${lst_A[i]}\" == \"${lst_A[j]}\" ] && [ \"${lst_B[i]}\"\
    \ == \"${lst_B[j]}\" ]; then\n                # print \"\"\n                echo\
    \ \"${lst_A[i]}\"\n                break\n            elif [ \"${lst_A[i]}\" ==\
    \ \"${lst_B[j]}\" ] && [ \"${lst_B[i]}\" == \"${lst_A[j]}\" ]; then\n        \
    \        # print \"\"\n                echo \"${lst_B[j]}\"\n                break\n\
    \            elif [ \"${lst_A[i]}\" == \"${lst_A[j]}\" ] && [ \"${lst_B[i]}\"\
    \ == \"${lst_B[j]}\" ]; then\n                # print \"\"\n                echo\
    \ \"${lst_A[i]}\"\n                break\n            elif [ \"${lst_A[i]}\" ==\
    \ \"${lst_B[j]}\" ] && [ \"${lst_A[i]}\" != \"${lst_B[j]}\" ]; then\n        \
    \        # print \"\"\n                echo \"${lst_B[j]}\"\n                break\n\
    \            elif [ \"${lst_A[i]}\" == \"${lst_B[j]}\" ] && [ \"${lst_A[i]}\"\
    \ != \"${lst_B[j]}\" ]; then\n                # print \"\"\n                echo\
    \ \"${lst_A[i]}\"\n                break\n            elif [ \"${lst_A[i]", " \
    \ local lines=\"$1\"\n  local num=\"$2\"\n  local res=$(echo \"$lines\" | tr \"\
    \ \" \"\\n\" | sort --key=2 | uniq --count | sort --reverse --key=2 --stable --numeric-sort\
    \ | head --lines=\"$num\")\n  echo $(echo \"$res\" | tr \"\\n\" \" \")", "  local\
    \ -n arr=( $1 )\n  local n=\"$2\"\n  local -a lst \n  \n  \n  for i in \"${!arr[@]}\"\
    ; do\n    local val=\"${arr[i]}\"\n    # create a newline-separated array consisting\
    \ only of the values \n    # on the current cell\n    arr+=($(cut -d' ' -f1 <<<\
    \ \"$val\"))\n    # get the value of the current cell\n    local val=\"${arr[i]}\"\
    \n    # populate an empty array\n    lst=()\n    # traverse the grid\n    for\
    \ (( i=0; i < n ; i++ )); do\n      # for each possible position in the grid\n\
    \      for (( j=0; j < n; j++ )); do\n        # store the value of the current\
    \ cell at each step of the loop\n        lst+=(\"$val\")\n      done\n    done\n\
    \    # sort the list\n    lst_array=$(sort <<< \"${lst[@]}\")\n    # get the index\n\
    \    local i\n    for (( i=0; i < k ; i++ )); do\n      # for each possible position\
    \ in the grid\n      for (( j=0; j < k ; j++ )); do\n        # if the position\
    \ is at the i-th position in the list\n        if [ \"${lst_array[i]}\" == \"\
    ${lst_array[j]}\" ]; then\n          # store the value\n          local val=\"\
    ${arr[j]}\"\n          # reset the grid cell\n          arr=($( awk '{print \"\
    '\"$val\"'\"} {print $0}' <<< \"${arr[@]}\" ))\n          # break the loop\n \
    \         break\n        fi\n      done\n    done\n  done\n  # sort and return\
    \ the list\n  echo $(sort <<< \"${arr[@]}\")", "    local lst_A\n    local lst_B\n\
    \    local i\n    local j\n    local temp\n    \n    lst_A=$(echo $1 | tr ' '\
    \ $'\\n')\n    lst_B=$(echo $1 | tr ' ' $'\\n')\n    \n    for ((i=1; i<=$2; i++));\
    \ do\n        for ((j=1; j<=$2; j++)); do\n            if  [[ \"$j\" == \"$i\"\
    \ ]] && [[ $(( ${lst_B[$j-1]} - ${lst_A[$i-1]} )) -eq $j ]]; then\n          \
    \      temp=`echo $lst_B[$j-1]`\n                lst_B[$j-1]=`echo $lst_A[$i-1]`\n\
    \                lst_A[$i-1]=$temp\n            fi\n        done\n    done\n \
    \   echo $lst_A", "  [[ $1 =~ ^[0-9]+$ ]] || return\n  [[ $2 =~ ^[0-9]+$ ]] ||\
    \ return\n  \n  declare -A lst \n  \n  lst=()\n  \n  local row\n  local col\n\
    \  local val\n  \n  while read -r row col val; do\n    ((row--))\n    ((col--))\n\
    \    lst_A=(\"$row\" \"${lst[@]:row:row}\")\n    lst_B=(\"$col\" \"${lst[@]:col:col}\"\
    )\n    ((lst_A[${#lst_A[@]}-1]=$row))\n    ((lst_B[${#lst_B[@]}-1]=$col))\n  \
    \  lst=(\"${lst[@]:row:row}\" \"${lst[@]:col:col}\")\n  done <<< \"$1\"\n  \n\
    \  echo \"${lst[@]:${#lst_A[@]}-1:${#lst_A[@]}}\"", "    declare -i rows=$1\n\
    \    declare -i cols=$2\n    declare -i i=0 j=0 \n    declare -a values=() \n\
    \    declare -a paths=() \n    while [[ $(( ++i )) -ge $rows ]]; do \n       \
    \ values=(\"$values\" \"$(cat -n $2 | head -n$i)\") \n    done \n    for (( j=0;\
    \ $j < $rows; j++ )); do \n        paths=(\"$paths\" \"$(cat -n $2 | sed -ne 's/.*\
    \ \\([0-9]\\).*/\"&\"&\"&\"&\"&\"&\"/p' | head -n$j)\"; done) \n    for (( j=0;\
    \ $j < $rows; j++ )); do \n        paths=(\"$paths\" \"$(cat -n $2 | sed -ne 's/.*\
    \ \\([0-9]\\).*/\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"/p' | head\
    \ -n$j)\"; done) \n    for (( j=0; $j < $rows; j++ )); do \n        paths=(\"\
    $paths\" \"$(cat -n $2 | sed -ne 's/.* \\([0-9]\\).*/\"&\"&\"&\"&\"&\"&\"&\"&\"\
    &\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"/p' | head -n$j)\"; done) \n    for\
    \ (( j=0; $j < $rows; j++ )); do \n        paths=(\"$paths\" \"$(cat -n $2 | sed\
    \ -ne 's/.* \\([0-9]\\).*/\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"\
    &\"&\"&\"&\"&\"&\"&\"/p' | head -n$j)\"; done) \n    for (( j=0; $j < $rows; j++\
    \ )); do \n        paths=(\"$paths\" \"$(cat -n $2 | sed -ne 's/.* \\([0-9]\\\
    ).*/\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"&\"", "    arr=$1\n    count=$2\n\
    \    arr=($(echo $arr | sed -e 's/ /\\n/g' -e 's/^/\\\"/g' -e 's/$/\\\"/g'))\n\
    \    arr=( $arr )\n    for i in $(seq 0 $(( ${#arr[@]} - 1 )) )\n    do\n    \
    \    if [ ${arr[i]} = $(( ${arr[i]} + 1 )) ]\n        then\n            arr[i]=$((\
    \ ${arr[i]} + 1 ))\n        else\n            break\n        fi\n    done\n  \
    \  arr=( $arr )\n    echo \"${arr[@]}\" | sed -e 's/ /\\n/g' -e 's/^/\\\"/g' -e\
    \ 's/$/\\\"/g' | sort -n | uniq", "    local lines=$1 N=${2:--2} k=$((N*N)) tmp\
    \ count\n    read -rd '' tmp <<<\"$lines\"\n    local lst_A lst_B i j\n    declare\
    \ -A tmpA\n    for ((i=0; i < k; i++)) do\n        lst_A[i]=\n        lst_B[i]=\n\
    \        tmp=\n        count=0\n        for ((j=1; j <= N; j++)) do\n        \
    \    if [[ \"${tmp}\" == \"$j\" ]]; then\n                count+=1\n         \
    \       tmpA[$j]=\n            else\n                ((tmpA[$j]+=count)) && lst_A[$j]=\"\
    ${tmpA[$j]} $j\"\n            fi\n        done\n    done\n    for ((j=1; j <=\
    \ N; j++)) do\n        if [[ -z \"${lst_A[$j]}\" ]]; then\n            lst_B[j]=\"\
    ${j}\"\n        else\n            ((k=\"${lst_A[$j]% *}\")) && lst_B[j]=\"${k}\
    \ ${j}\"\n        fi\n    done\n    for ((j=N-1; j >= 1; j--)) do\n        if\
    \ [[ -z \"${lst_A[$j]}\" ]]; then\n            lst_B[j]=\"${j}\"\n        else\n\
    \            ((k=\"${lst_A[$j]% *}\")) && lst_B[j]=\"${k} ${j}\"\n        fi\n\
    \    done\n    tr -d \"\\n\" <(printf '%s\\n' \"${lst_A[@]}\" | sort -n)", " \
    \ local -n arr1=$1 str=$2 i\n  local -a arr2=()\n  local -a temp=()\n  local lst_A=(\
    \ $(echo \"$str\" | tr \"\\n\" \" \") )\n  local lst_B=( $(echo \"$str\" | tr\
    \ \"\\n\" \" \") )\n  local i\n  \n  for (( i=0; i < $#; i++ )); do\n    temp+=(\
    \ $( echo \"${arr1[*]}\" | awk -v lst_A=\"$lst_A\" -v lst_B=\"$lst_B\" -F'\\n'\
    \ -v OFS=\"\\\" '{for (i=1;i<=NF;i++) {if ($i < lst_A && $i > lst_B) print $i}}')\
    \ )\n    arr2+=( $(echo \"${temp[*]}\" | sort -n) )\n    arr1=( $(echo \"${arr1[*]}\"\
    \ | awk -v lst_A=\"$lst_A\" -v lst_B=\"$lst_B\" -F'\\n' -v OFS=\"\\\" '{for (i=1;i<=NF;i++)\
    \ {if ($i < lst_A && $i > lst_B) print $i}}') )\n    temp=()\n  done\n  \n  return\
    \ \"$( echo \"${arr2[*]}\" | sed 's/ /\\\\ /g' | sort -n )\"", "  local lines=$1\n\
    \  local line=$2\n  local len=${#lines[@]}\n  local idx=0\n  local list\n  list=($line)\n\
    \  while [ $idx -lt $len ]; do\n    local i=$(($idx+1))\n    local j=$(($idx+2))\n\
    \    local list1\n    list1=()\n    local list2\n    list2=()\n    while [ $i\
    \ -lt $len ]; do\n      local tmp=${list[$i]}\n      list1+=($tmp)\n      if [\
    \ \"$i\" -eq $len ]; then\n        list2+=($tmp)\n      fi\n      i=$(($i+1))\n\
    \    done\n    list2=($(sort <<< \"${list2[*]}\" | uniq))\n    if [ \"$list1\"\
    \ -ne \"$list2\" ]; then\n      list=(\"${list[@]}\" \"$list1\" \"$list2\")\n\
    \    fi\n    idx=$(($idx+3))\n  done\n  list=($(sort <<< \"${list[*]}\" | uniq))\n\
    \  echo \"${list[*]}\"", "  local lst_A=\"$1\"\n  local k=\"$2\"\n  # find an\
    \ index that is less than or equal to k\n  local i j\n  local result\n  for ((i=1;\
    \ i <= k; i++)); do\n    # we start from 1, because we cannot visit 0th cell\n\
    \    for ((j=1; j<=i; j++)); do\n      lst_A[j]=\"${lst_A[j-1]}${lst_A[j]}\"\n\
    \    done\n    # sort lexicographically\n    IFS=' ' read -r -a lst_A <<< \"$(sort\
    \ <<<\"$lst_A\")\"\n    result=()\n    for ((j=1; j<=i; j++)); do\n      if [\
    \ -n \"${lst_A[j]}\" ]; then\n        result+=(\"${lst_A[j]}\")\n      fi\n  \
    \  done\n    # sort lexicographically\n    IFS=' ' read -r -a lst_A <<< \"$(sort\
    \ <<<\"$result\")\"\n  done\n  echo \"${lst_A[@]}\"", "  if [ $# -ne 2 ]; then\n\
    \    echo \"Illegal number of parameters\"\n    exit 1\n  fi\n\n  # get first\
    \ line\n  vals=$($1 <<<$2)\n  len=$[${#vals}-2]\n  \n  # create ordered list for\
    \ each line\n  lst_A=()\n  for i in $(seq 1 $len); do\n    if [ -z \"$lst_A\"\
    \ ]; then\n      lst_A+=($vals[$i])\n    else\n      lst_A+=($(echo \"$vals[$i]\"\
    |sort -n))\n    fi\n  done\n  \n  # sort lists to get lexicographical order\n\
    \  lst_B=()\n  for i in $(seq 1 $len); do\n    lst_B+=($(echo \"$lst_A[$i]\"|sort\
    \ -n))\n  done\n  \n  # check if list is lexicographically less than list B\n\
    \  for i in $(seq 1 $len); do\n    if [[ ${lst_B[$i]} != ${lst_A[$i]} ]]; then\n\
    \      return 0\n    fi\n  done\n  return 1", "  read -r line1 <<< $1;\n  read\
    \ -r line2 <<< $2;\n  line1=$(echo $line1 | tr -cd '[:digit:]');\n  line2=$(echo\
    \ $line2 | tr -cd '[:digit:]');\n  line1=$(echo $line1 | sort -r);\n  line2=$(echo\
    \ $line2 | sort -r);\n  line3=$(printf \"%s\" ${line1}); # remove \\n\n  line4=$(printf\
    \ \"%s\" ${line2}); # remove \\n\n  line5=$(printf \"%s\" ${line3}); # remove\
    \ \\n\n  line6=$(printf \"%s\" ${line4}); # remove \\n\n  line7=$(printf \"%s\"\
    \ ${line5}); # remove \\n\n  line8=$(printf \"%s\" ${line6}); # remove \\n\n \
    \ line9=$(printf \"%s\" ${line7}); # remove \\n\n  line10=$(printf \"%s\" ${line8});\
    \ # remove \\n\n  line11=$(printf \"%s\" ${line9}); # remove \\n\n  line12=$(printf\
    \ \"%s\" ${line10}); # remove \\n\n  line13=$(printf \"%s\" ${line11}); # remove\
    \ \\n\n  line14=$(printf \"%s\" ${line12}); # remove \\n\n  line15=$(printf \"\
    %s\" ${line13}); # remove \\n\n  line16=$(printf \"%s\" ${line14}); # remove \\\
    n\n  line17=$(printf \"%s\" ${line15}); # remove \\n\n  line18=$(printf \"%s\"\
    \ ${line16}); # remove \\n\n  line19=$(printf \"%s\" ${line17}); # remove \\n\n\
    \  line20=$(printf \"%s\" ${line18}); # remove \\n\n  line21=$(printf \"%s\" ${line19});\
    \ # remove \\n\n  line22=$(printf \"%s\" ${line20}); # remove \\n\n  line23=$(printf\
    \ \"%s\" ${line21}); # remove \\n\n  line24=$(printf \"%s\" ${line22}); # remove\
    \ \\n\n  line25=$(printf \"%s\" ${line23}); # remove \\n\n  line26=$(printf \"\
    %s\" ${line24}); # remove \\n\n  line27=$(printf \"%s\" ${line25}); # remove \\\
    n\n  line28=$(printf \"%s\" ${line26}); # remove \\n\n  line29=$(printf \"%s\"\
    \ ${line27}); # remove \\n\n  line30=$(printf \"%s\" ${", "    [[ $# != 2 ]] &&\
    \ echo \"Please provide exactly 2 arguments: <grid>, <k>\"\n    [[ -z \"$2\" ]]\
    \ && echo \"Please provide the <k> argument\"\n    \n    local i; local j; local\
    \ grid; local lst_A; local lst_B; local path; local k\n    \n    IFS=$'\\n' read\
    \ -r -a grid <<< \"$1\"\n    lst_A=()\n    lst_B=()\n    for i in \"${!grid[@]}\"\
    ; do \n        # Read a row and split into list of values\n        local vals=\"\
    $(echo $grid[i])\"\n        # Convert string to an array\n        local valArray=\"\
    (${vals//,/ })\" || return 1\n        # Convert values to an indexed array\n \
    \       local indexedValArray=(${valArray//[$((k=$2))]})\n        \n        #\
    \ Add the indexed values to the lists and sort the lists\n        lst_A+=(\"${indexedValArray[@]}\"\
    )\n        lst_B+=(\"${indexedValArray[@]}\")\n    done\n    \n    # Sort lists\
    \ of values in lexicographically order\n    [[ ${#lst_A[@]} -ne ${#lst_B[@]} ]]\
    \ && return 1 || echo \"${lst_A[@]} and ${lst_B[@]}\"\n    lst_A=(${lst_A[@]})\n\
    \    lst_B=(${lst_B[@]})\n    \n    # Generate list of all indexes of values appearing\
    \ in each list\n    for i in $(seq 0 $((${#lst_A[@]} - 1)); do\n        local\
    \ idx=((${lst_B[i]} - ${lst_A[i]}))\n        [[ -z $idx ]] && idx=0\n        \n\
    \        local val=${lst_A[i]}\n        for ((j=i; j<${#lst_B[@]}; j++)); do\n\
    \            # Add 1 to idx as we iterate to each list in sequence\n         \
    \   val=${val}\" \"${lst_B[j]}\n            # Skip this iteration if current lists\
    \ differ in size\n            [[ ${#val} -ne ${#lst_B[@]} ]] && break\n      \
    \  done\n        lst_A[i]=\"$val\"\n    done\n    \n    # Remove duplicates from\
    \ list of values\n    lst_A=(${lst_A[@]})\n    # Trim lists by deleting trailing\
    \ null entries\n    local idx\n    for idx in $(seq 0 $((${#lst_A[@]} - ", " \
    \   local lines=$1\n    local k=$2\n    local line\n    local lineN\n    local\
    \ cell\n    local cellN\n    local lst_A lst_B i j j1\n    local ans\n    local\
    \ str\n    local tmp\n\n    lst_A=()\n    lst_B=()\n    while read -r line; do\n\
    \        lineN=$(expr index \"$line\" \" \") + 1\n        cellN=$(expr index \"\
    $line\" \" \" $lineN) + 1\n        cell=$(expr index \"$line\" \" \" $lineN +\
    \ $cellN)\n        lst_A[$cellN]=$(expr $cellN - 1)\n        lst_B[$cellN]=$(expr\
    \ $cell)\n    done <<< \"$lines\"\n\n    # sort the list with lowest cell on the\
    \ left and the highest on the right\n    # so that lst_A is sorted in a way where\
    \ every cell is visited once\n    # and lst_B is sorted in such a way that every\
    \ cell is visited once and \n    # lexicographically less than it\n    sort -n\
    \ -k ${lst_A[0]} -k ${lst_B[0]}\n\n    # keep track of the cells visited so far\n\
    \    ans=()\n    # go through the cells in order starting from the cell that has\
    \ the smallest value\n    for ((j1=1; j1<=k; j1++)); do\n        \n        # go\
    \ through each possible path\n        for ((i=1; i<=j1; i++)); do\n          \
    \  # go through the cells\n            for ((j=0; j<i; j++)); do\n           \
    \     # append the values to the answer list\n                ans=(\"${ans[@]}\"\
    \ \"$line\"\n                        # make sure that the current cell is visited\
    \ only once and\n                        # that all neighbors cells are visited\
    \ at least once (and\n                        # in the right order)\n        \
    \                $(expr index \"${lst_A[$i]}\" \"${lst_B[$j]}\" +1 ))\n      \
    \          done\n            done\n        done\n\n        # if the current cell\
    \ has a lower value in the next step, append the current line to the answer list\n\
    \        if (( ${lst_A[j1]} < ${lst_B[j1]} )) ; then\n            ans=(\"${ans[@]}\"\
    \ \"$line\"\n                $(expr index \"${lst_A[j1]}\" \"${lst_B[j1]}\" +1\
    \ ))\n        fi\n    done\n\n    # remove the quotes from the answer list\n \
    \   for str in \"${ans[@]}\"; do\n        echo \"$str\"|tr -d '\"'", "  local\
    \ input=\"$1\" k=\"$2\"\n  \n  if [ \"$k\" -gt \"$input\" ] || [ \"$k\" -lt \"\
    1\" ]; then\n    echo -e \"Invalid k\"\n    return 0\n  fi\n\n  # The code below\
    \ is used to prevent integer overflow in python:\n  # \"OverflowError: Python\
    \ int too large to convert to C long\"\n  # The largest number that can be represented\
    \ in python is 2**63 - 1 (2147483647)\n  # We use \"bc\" to work with integers\
    \ and \"bc\" has its own max value \n  # (9999999999, actually)\n  local max=\"\
    9999999999\"\n  local tmp=\"$(echo \"$max\" | bc)\"\n  local tmp2=\"$(( k * k\
    \ ))\"\n  \n  # Get a list of all the possible combinations:\n  # for example,\
    \ \"3 5\" means a combination \"3 4 5\", \n  # \"4 5\" and \"5 4\"\n  local tmp3=\"\
    $(python -c \"for n in range($tmp2+1): print(n*\\\"$k\\\"+\\\"$k\\\" if n > $tmp\
    \ else n*\\\"$k\\\")\" )\"\n  local list=\"$tmp3[@]\"\n  \n  # Remove duplicates\
    \ from the list:\n  # for example, \"3 4 5\" has 3 cells, \"3 5 4\" has 3, and\
    \ so on\n  local tmp4=\"$(echo \"$list\" | tr \",\" \"\\n\" | sort -n | uniq |\
    \ tr \"\\n\" \" \")\"\n  \n  # Remove duplicates from the list:\n  # for example,\
    \ \"3 4 5\" has 3 cells, \"4 5\" and \"5 4\"\n  local tmp5=\"$(echo \"$tmp4\"\
    \ | sort -n | uniq | tr \"\\n\" \" \")\"\n  \n  # Remove duplicates from the list:\n\
    \  # for example, \"3 4 5\" has 3 cells, \"4 5\" and \"5 4\"\n  local tmp6=\"\
    $(echo \"$tmp5\" | sort -n | uniq | tr \"\\n\" \" \")\"\n  \n  # Return an empty\
    \ list if there are no valid paths:\n  # for example, \"3 5\" means a combination\
    \ \"3 4 5\", \n  # \"4 5\" and \"5 4\" but there are no valid paths\n  if [ \"\
    $tmp6\" == \"\" ]; then\n    return 1\n  fi\n\n  # Create a list with the values\
    \ on the cells:\n  # for example, \"3 4 5\" means a combination \"3 4 5\", \n\
    \  # \"4 5\" and \"5 4\" but there are no valid paths\n  local output=\"$(echo\
    \ \"$tmp6\" | tr \",\" \"\\n\")\"\n  return \"$output\"", "  [[ -z \"$1\" ]] ||\
    \ [[ -z \"$2\" ]] || \n    echo \"Wrong Arguments.\" 1>&2\n    return 1\n\n  N=${#1}\
    \ \n  [[ -z \"$N\" ]] || \n    echo \"Wrong Grid Size.\" 1>&2\n    return 1\n\
    \  \n  k=$2\n  [[ -z \"$k\" ]] || \n    echo \"Wrong Grid Size.\" 1>&2\n    return\
    \ 1\n\n  for i in $(seq 1 $((N-1)) )\n  do\n    for j in $(seq 1 $((N-1)) )\n\
    \    do\n      A=\"$(sed -n \"1p\" <<< \"$1\")\"\n      B=\"$(sed -n \"1p\" <<<\
    \ \"$1\")\"\n      [[ \"$A\" =~ [0-9] ]] && [[ \"$B\" =~ [0-9] ]] && \n      \
    \  [[ \"$A\" != \"$B\" ]] && \n        [[ \"$B\" != \"$A\" ]] && \n        [[\
    \ \"$A\" -ge 0 ]] && [[ \"$B\" -ge 0 ]] && \n        [[ \"$A\" -le $N ]] && [[\
    \ \"$B\" -le $N ]] &&\n        (( ${#A} <= ${#B} )) && \n        (( $A <= $B ))\
    \ && \n        (( ${#A} > k )) && \n        (( $A > $B )) && \n        (( ${#A}\
    \ != ${#B} )) && \n        (( $(echo \"${A}\"|sort -t_ -k 1,1 -k 2,2 | head -n\
    \ $k - | tail -n 1) < $(echo \"${B}\"|sort -t_ -k 1,1 -k 2,2 | head -n $k - |\
    \ tail -n 1) )) &&\n        (( $(echo \"${A}\"|sort -t_ -k 1,1 -k 2,2 | head -n\
    \ $k - | tail -n 1) > $(echo \"${B}\"|sort -t_ -k 1,1 -k 2,2 | head -n $k - |\
    \ tail -n 1) )) &&\n        (( $(echo \"${A}\"|sort -t_ -k 1,1 -k 2,2 | head -n\
    \ $k - | tail -n 1) != $(echo \"${B}\"|sort -t_ -k 1,1 -k 2,2 | head -n $k - |\
    \ tail -n 1) )) &&\n        (( $(echo \"${A}\"|sort -t_ -k 1,1 -k 2,2 | head -n ",
  "    local grid=$1\n    local k=$2\n    \n    local glen=(${#grid})\n    if [[ ${glen}\
    \ -ne ${k} ]]; then\n        echo \"The grid should have ${k} rows and ${k} columns.\"\
    \n        echo \"$grid\"\n        return\n    fi\n\n    local lstA\n    local\
    \ lstB\n    \n    local row\n    local col\n    local val\n    local inx\n   \
    \ local j\n    local cnt\n    local ret\n    local min\n\n    for (( row = 0;\
    \ row < ${k}; row++ )); do\n        lstA=()\n        lstB=()\n\n        cnt=0\n\
    \        for (( col = 0; col < ${k}; col++ )); do\n            val=${grid[$row][$col]}\n\
    \            if [[ ${val} =~ ^[0-9]+$ ]]; then\n                lstA+=(\"\\\"\
    ${val}\\\"\")\n            else\n                lstA+=(\"\\\"\\\"\")\n      \
    \      fi\n            lstB+=(\"\\\"\\\")\n            cnt=$((cnt + 1))\n    \
    \    done\n\n        lstA=${lstA[@]:1}\n        lstB=${lstB[@]:1}\n\n        min=$((\
    \ ${k} + 1 ))\n        if [[ ${lstA} =~ ^([0-9]+)\\([0-9]+\\)$ ]]; then\n    \
    \        inx=${BASH_REMATCH[1]}\n            j=${BASH_REMATCH[2]}\n          \
    \  cnt=`expr $cnt - ${j}`\n\n            if [[ ${cnt} -lt 0 ]]; then\n       \
    \         ret=()\n                while [[ ${#ret[@]} -lt ${min} ]]; do\n    \
    \                ret+=(\"\\\"\\\")\n                done\n                ret+=(${lstA})\n\
    \                ret+=(${lstB})\n                return ${ret[@]}\n          \
    \  else\n                while [[ ${#ret[@]} -lt ${min} ]]; do\n             \
    \       ret+=(\"\\\"\\\")\n                done\n                ret+=(${lstA})\n\
    \                ret+=(${lstB})\n                min=$(( ${min} - ${cnt} ))\n\
    \            fi\n        fi\n    done", '  # TODO: implement the function', " \
    \  declare -a arr=() \n   declare -i i k j\n   declare -a lst_A=() \n   declare\
    \ -a lst_B=()\n   for ((i=0; i<$1; ++i)); do arr+=(\"$i\"); done\n   for ((i=0;\
    \ i<$2; ++i)); do lst_B+=(\"$((${arr[i]}+1))\"); done\n   if (($1 == $2)); then\
    \ \n      for ((i=0; i<$2; ++i)); do lst_A+=(\"$((${arr[i]}+1))\"); done\n   elif\
    \ (($1 < $2)); then\n      for ((i=0; i<$1; ++i)); do lst_A+=(\"$((${arr[i]}+1))\"\
    ); done\n      for ((i=0; i<$2; ++i)); do lst_B+=(\"$((${arr[i]}+1))\"); done\n\
    \   else\n      echo \"invalid input\"\n      exit 1\n   fi\n   declare -i cnt=0\n\
    \   for ((i=0; i<$2; ++i)); do \n      cnt=0\n      while [[ $(cnt<${#lst_A[*]})\
    \ ]]; do\n         if ((lst_A[${cnt}]<lst_B[${cnt}]); then\n            ((++cnt))\n\
    \         else\n            ((cnt=cnt-1))\n         fi\n      done\n      arr+=(\"\
    $((${arr[i]}+1))\")\n   done\n   for ((i=0; i<$1; ++i)); do printf -v v \"%q\"\
    \ ${arr[i]}; printf -v v1 \"%q\" ${arr[i]}; printf -v v2 \"%q\" ${arr[i]}; printf\
    \ -v v3 \"%q\" ${arr[i]}; printf -v v4 '%q' ${arr[i]}; done\n   declare -i cnt=0\n\
    \   for ((i=0; i<$2; ++i)); do \n      cnt=0\n      while [[ $(cnt<${#lst_A[*]})\
    \ ]]; do\n         if ((lst_A[${cnt}]<lst_B[${cnt}]); then\n            ((++cnt))\n\
    \         else\n            ((cnt=cnt-1))\n         fi\n      done\n      arr+=(\"\
    $((${arr[i]}+1))\")\n   done\n   for ((i=0; i<$2; ++i)); do printf -v v \"%q\"\
    \ ${arr[i]}; printf -v v1 \"%q\" ${arr[i]}; printf -v v2 \"%q\" ${arr[i]}; printf\
    \ -v v3 ", "  local N=\"$1\"\n  local k=\"$2\"\n  \n  # Initialize an empty list\
    \ of candidates\n  local candidates=()\n  local candidate\n\n  # Scan the grid\
    \ and add candidates as they are found\n  for x in $(seq 1 \"$N\"); do\n    for\
    \ y in $(seq 1 \"$N\"); do\n      candidate=\"$(x),$y\"\n      while read -r;\
    \ do\n        candidates=(\"${candidates[@]}\" \"'$REPLY'\")\n      done < <(printf\
    \ \"$(echo $candidate | sed 's/ /\\n/g')\")\n    done\n  done\n\n  # Sort candidates\
    \ and find the k-shortest one\n  local -n candidatesLen=\"${#candidates[@]}\"\n\
    \  for i in $(seq 1 \"$k\"); do\n    local -n candidate=\"${candidates[$((i *\
    \ candidatesLen))]}\"\n    local j\n    for j in $(seq 1 \"$k\"); do\n      if\
    \ [[ \"$candidate\" = \"${candidates[$((j * candidatesLen))]}\" ]]; then\n   \
    \     # Found a path of length $k starting from $i cell, use that one\n      \
    \  candidates=\"${candidates[@]:$((j * candidatesLen))}\"\n        break\n   \
    \   fi\n    done\n  done\n\n  # Return the values on the cells visited\n  echo\
    \ \"${candidates[@]}\"", "    set -- $2 $3\n    local k=$1\n    local str=$1\n\
    \    local lstA=()\n    local lstB=()\n    while [ ${#} -gt 0 ]; do\n        local\
    \ cell=(\"${str:0:1})\n        lstA+=(\"$cell\")\n        local val=${str:1}\n\
    \        shift\n        lstB+=(\"$val\")\n        shift\n        set -- \"$@\"\
    \n    done\n    local j=0\n    for i in $(seq 1 $k); do\n        local val=${lstA[$i]}\n\
    \        lstA[$i]=${lstB[$j]}\n        lstB[$j]=$val\n        ((j++))\n    done\n\
    \    local res=()\n    for ((i=1; i<$((k-1)); i++)); do\n        local cell=${lstA[$i]}\n\
    \        res+=(\"$cell\")\n    done\n    echo \"${res[*]}\"", "    local arr=$1\
    \ lst i j result\n    for ((i=0; i<${#arr}; i++)); do\n        lst=()\n      \
    \  j=0\n        for ((j=0; j<${#arr}; j++)); do\n            [[ \"$i\" == \"$j\"\
    \ ]] && continue\n            lst+=(\"${arr[$j]:$i:1}\")\n        done\n     \
    \   lst=($(sort <<<\"${lst[*]}\" | uniq))\n        lst_A=($(sort <<<\"${lst[*]}\"\
    \ | uniq))\n        lst_B=($(sort <<<\"${lst[*]}\" | uniq))\n        [[ \"${#lst_A[@]}\"\
    \ == \"${#lst_B[@]}\" ]] && result=(\"${lst[*]}\")\n    done\n    [[ \"${#result[@]}\"\
    \ -eq 0 ]] && return 1\n    [[ \"${#result[@]}\" -gt 0 ]] && return 0\n    echo\
    \ \"${result[@]}\"", "  local -i rows=\"${1:-`expr ${#} / 2`}\"\n  local -i cols=\"\
    ${2:-`expr ${#} / 2`}\"\n  local -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i\
    \ -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i -i ", "    local lst_A lst_B\n\
    \    local i j\n    local k\n    local lst_str m\n    local output\n    lst_A=$1\n\
    \    lst_B=$2\n    k=${#lst_A[@]}\n    if [ \"$k\" -eq \"0\" ]; then\n       \
    \ echo \"0\"\n        return\n    fi\n    lst_str=$( echo \"${lst_A[@]}\" | sed\
    \ -n '/^\\s*$/p' )\n    lst_str=$( echo \"${lst_str[@]}\" | sed 's/ //g' )\n \
    \   m=$( echo \"${lst_str[@]}\" | sort -n )\n    for i in $(seq $(( ${#lst_str[@]}\
    \ - 1 ))); do\n        [[ \"$lst_str\" =~ \"^${m[i]}$\" ]]\n        if [ $? -eq\
    \ 0 ]; then\n            lst_A=${lst_A//\"$m[i]\"/\"$lst_str\"}\n            lst_B=${lst_B//\"\
    $m[i]\"/\"$lst_str\"}\n            lst_str=${lst_str//\"$m[i]\"/\"$lst_str\"}\n\
    \            lst_str=${lst_str//\"$i\"/\"$lst_str\"}\n            lst_str=${lst_str//\"\
    $(( ${#lst_str} - 1 ))\"/\"$lst_str\"}\n            lst_str=${lst_str//\"$(( ${#lst_str}\
    \ - 2 ))\"/\"$lst_str\"}\n            break\n        fi\n    done\n    lst_str=$(\
    \ echo \"${lst_str[@]}\" | sed 's/^\\s*//' )\n    lst_str=$( echo \"${lst_str[@]}\"\
    \ | sed 's/\\s*$//' )\n    for i in $(seq $(( ${#lst_A[@]} - 1 ))); do\n     \
    \   [[ \"$lst_A\" =~ \"^${m[i]}$\" ]]\n        if [ $? -eq 0 ]; then\n       \
    \     lst_A=${lst_A//\"$m[i]\"/\"$lst_str\"}\n            lst_B=${lst_B//\"$m[i]\"\
    /\"$lst_str\"}\n            lst_str=${lst_str//\"$m[i]\"/\"$lst_str\"}\n     \
    \       lst_str=${lst_str//\"$i\"/\"$lst_str\"}\n            lst_str=${lst_str//\"\
    $(( ${#lst_str} - 1 ))\"/\"$lst_str\"}\n            lst_str=${lst_str//\"$(( ${#lst_str}\
    \ - 2 ))\"/\"$", "  local arr=( $1 )\n  local num=$2\n  local i\n  local j\n \
    \ local lst_A\n  local lst_B\n  local numOfValues\n\n  local found\n\n  numOfValues=${#arr[@]}\n\
    \n  for (( i=1; i <= numOfValues; ++i )); do\n    found=false\n    lst_A=( ${arr[@]:${#arr[@]}-1:i}\
    \ )\n    lst_B=( ${arr[@]:0:i} )\n\n    while (( ${#lst_A[@]} > 0 ));do\n    \
    \  [[ \"${lst_A[${#lst_A[@]} - 1]}\" < \"${lst_B[${#lst_B[@]} - 1]}\" ]] ||\n\
    \        lst_B+=( ${lst_A[@]:0:${#lst_A[@]}-1} )\n      lst_A=( ${lst_A[@]:${#lst_A[@]}-1:}\
    \ )\n    done\n\n    lst_B[@]=( ${lst_B[@]:0:i} )\n\n    [[ \"$lst_A[@]\" < \"\
    $lst_B[@]\" ]] || break\n  done\n\n  arr=( \"${arr[@]}\" )\n\n  for (( i=1; i\
    \ <= numOfValues; ++i )); do\n    if [[ \"$i\" != \"$num\" ]]; then\n      arr+=(\
    \  \"${arr[i]}\" )\n    fi\n  done\n\n  printf '%s\\n' \"${arr[@]}\"", "\tlocal\
    \ lst_A=\"$1\"\n\tlocal len=\"${#lst_A}\"\n\tlocal lst_B=\"\"\n\tlocal i j\n\t\
    local result\n\t\n\tif [ \"${len}\" -ne \"2\" ]; then\n\t\techo \"Usage: $(basename\
    \ \"$0\") list len\" >&2\n\t\texit 1\n\tfi\n\n\tfor ((i=0;i<${len};i++)); do\n\
    \t\tif [ \"${lst_A[i]}\" -lt \"${lst_A[i+1]}\" ]; then\n\t\t\tlst_B=\"${lst_B}${lst_A[i]}\
    \ \"\n\t\telse\n\t\t\tlst_B=\"${lst_B}${lst_A[i+1]} \"\n\t\tfi\n\tdone\n\tlst_B=\"\
    ${lst_B}${lst_A[${len}-1]}\"\n\tlocal i\n\t\n\tlocal len_B=\"${#lst_B}\"\n\t((\
    \ len_B > len )) || echo \"Wrong list length\"\n\t(( len_B <= len )) || echo \"\
    Wrong list length\"\n\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal l\n\tlocal k\n\
    \tlocal i\n\tlocal j\n\tlocal j\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\
    \tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal\
    \ j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\t\
    local val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\
    \tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal\
    \ i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\t\
    local j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\
    \tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal\
    \ val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\t\
    local i\n\tlocal j\n\tlocal val\n\tlocal i\n\tlocal j\n\tlocal val\n\tlocal i\n\
    \tlocal j\n\tlocal val\n\tlocal i\n\tlocal j", "  local -n arr=$$1\n  local -i\
    \ k=$2\n  local -i n=$((${#arr[@]}-1)) \n  local -i j\n\n  local lst_A\n  local\
    \ lst_B\n  local i\n\n  # First sort the array\n  for i in $(seq 0 $((n-1)))\n\
    \  do\n    lst_A[${#lst_A[@]}]=${arr[$((i-1))]}\n  done\n  ((n--))\n  for j in\
    \ $(seq 1 $((n-1)))\n  do\n    lst_B[${#lst_B[@]}]=${arr[$((j-1))]}\n  done\n\
    \  ((n--))\n\n  # Now use k as the length of the array\n  lst_A[${#lst_A[@]}]=\"\
    \\\"$k\\\"\"\n  ((k--))\n  lst_B[${#lst_B[@]}]=\"\\\"$k\\\"\"\n\n  local tst\n\
    \  local tmp\n\n  while (( k ))\n  do\n    if (( k ))\n    then\n      ((k--))\n\
    \      lst_B[${#lst_B[@]}]=\"\\\"$k\\\"\"\n    fi\n    # Get the cell that first\
    \ appears in lst_A \n    tmp=${lst_A[0]}\n    # Move down in the array\n    for\
    \ i in $(seq 1 $((n-1)))\n    do\n      if [[ \"${arr[$i]}\" != \"${tmp}\" ]]\n\
    \      then\n        lst_B[${#lst_B[@]}]=${arr[$i]}\n        ((k--))\n       \
    \ break\n      fi\n    done\n    # Add tmp to lst_A\n    lst_A[${#lst_A[@]}]=${tmp}\n\
    \    # Add tmp to lst_B\n    lst_B[${#lst_B[@]}]=${tmp}\n  done\n\n  printf \"\
    %s\\n\" \"${lst_A[@]}\" ", "    local lines=$(cat);\n    local numRows=$((${#lines}/2));\n\
    \    local numCols=$((${#lines[@]}/2));\n    local vals=$(echo \"${lines[@]}\"\
    \ | tr ' ' '\\n' | sort | uniq);\n    local rows=(${vals[*]});\n    local cols=(${lines[0]}\
    \ ${rows[0]});\n    local i=${#vals[*]};\n    local j=${#rows[*]};\n    local\
    \ ret=();\n    while (( i < $2 )); do\n        j=$(( j - 1 ));\n        (( i--\
    \ ));\n        if (( j >= numCols )) then\n            j=$(( numRows - 1 ));\n\
    \        fi\n        if (( j < numRows )) then\n            ret[$(( i / 2 ))]=${rows[$j]};\n\
    \        fi\n    done\n    echo ${ret[@]};", "    local data=\"${1:-}\"\n    local\
    \ k=\"${2:-1}\"\n    local lst_A\n    local lst_B\n    local i j\n    local result\
    \ str\n\n    # convert data to array of numbers, e.g. '1 2 3' -> [1 2 3]\n   \
    \ IFS=$'\\n' read -a data <<< \"$data\"\n\n    # sort and convert to string list\
    \ for easier comparison\n    lst_A=( \"${data[@]}\" )\n    lst_A=($(sort <<<\"\
    ${lst_A[@]}\" | sed 's/^\\(.\\)*$/\\1/'))\n    lst_A=($(printf '%s\\n' \"${lst_A[@]}\"\
    \ | sort -n))\n\n    # for each value in lst_A, create an array where index is\
    \ the cell and\n    # value is value of that cell and sort it by value\n    lst_B=(\
    \ $(for ((i=0;i<${#lst_A[@]};++i)); do\n        local cell=\"${lst_A[i]}\"\n \
    \       local val=\"${data[$i]}\"\n        echo \"${cell}:${val}\"\n        local\
    \ arr\n        arr=( $(printf '%s\\n' \"${data[@]:$i}\" | sort -n) )\n       \
    \ arr=($(printf '%s\\n' \"${arr[@]}\" | sort -n))\n        arr=($(printf '%s\\\
    n' \"${arr[@]}\" | sort -n))\n        printf '%s\\n' \"${arr[@]}\"\n    done))\n\
    \n    # initialize result array\n    result=()\n\n    # for each index in lst_B,\
    \ append index value to result array\n    for ((i=0;i<${#lst_B[@]};++i)); do\n\
    \        result+=(\"${lst_B[i]}\")\n    done\n\n    # sort result array by value\n\
    \    local i\n    local k\n    for ((i=0;i<${#result[@]};++i)); do\n        k=\"\
    ${result[i]}\"\n        if [[ ${#k} -gt ${k} ]]; then\n            result=(\"\
    ${result[@]:$i}\")\n        fi\n    done\n\n    # return result array\n    printf\
    \ '%s\\n' \"${result[@]}\"", "    local -a lst_A\n    local -a lst_B\n    local\
    \ i j k lst_A lst_B i\n    for ((k=0; k<=$2; ++k)) ; do\n        lst_A=(); lst_B=()\n\
    \        for ((i=0; i<$1; ++i)); do\n            read a b <<< $(ip route get $(ip\
    \ route get $i | cut -d'/' -f1) | awk '{ print $3 }')\n            [[ \"$a\" !=\
    \ \"$b\" ]] && lst_A+=($a)\n            [[ \"$b\" != \"$a\" ]] && lst_B+=($b)\n\
    \        done\n        lst_A=($(sort <<<\"${lst_A[*]}\"))\n        lst_B=($(sort\
    \ <<<\"${lst_B[*]}\"))\n        for ((i=0; i<$2; ++i)); do\n            [[ -n\
    \ \"$lst_A[i]\" ]] && lst_A[i]=$(expr substr $lst_A[i] 1 $i)\n            [[ -n\
    \ \"$lst_B[i]\" ]] && lst_B[i]=$(expr substr $lst_B[i] 1 $i)\n        done\n \
    \       for ((i=0; i<$2; ++i)); do\n            [[ \"$lst_A\" == \"$lst_B\" ]]\
    \ && return\n            [[ -z \"$lst_A[i]\" ]] && return\n            [[ -z \"\
    $lst_B[i]\" ]] && return\n            if [[ \"$lst_A\" <  \"$lst_B\" ]] && [[\
    \ \"$lst_A\" = \"${lst_B/#/\\\"}${lst_A/#/\\\"}\"]]; then\n                lst_B[i]=\"\
    $lst_A[i]\"\n                lst_A[i]=\"\"\n            else\n               \
    \ lst_A[i]=\"$lst_B[i]\"\n                lst_B[i]=\"\"\n            fi\n    \
    \    done\n    done", "  local lst_A lst_B N\n  N=${#$1} lst_A=($(echo \"$1\"\
    \ | tr ' ' '\\n' | sort -n))\n  lst_B=()\n  local -i k\n  for (( k = 0; k < N;\
    \ k++ )); do\n    if (( k != N - 1 )); then\n      ((k++))\n      local -i j\n\
    \      for (( j = 0; j < k; j++ )); do\n        ((j++))\n        lst_B+=($(echo\
    \ \"$1\" | tr ' ' '\\n' | sort -n))\n      done\n      lst_A=($(echo \"$lst_A\"\
    \ | tr ' ' '\\n' | sort -n | sed \"s/${lst_A[k]}/${lst_B[j]}/\"))\n    else\n\
    \      lst_A=($(echo \"$lst_A\" | tr ' ' '\\n' | sort -n))\n    fi\n  done\n \
    \ echo \"$lst_A\"", "    mapfile -t array < <(grep -Eo '[0-9]+' <<< \"$1\")\n\
    \    local n=\"${#array[@]}\"\n    local k=\"$2\"\n\n    for ((i=1; i<=k; i++));\
    \ do\n        local lst_A=\"$(sort -u <<<\"${array[@]}\")\"\n        local lst_B=\"\
    $(sort -u <<<\"${array[*]}\")\"\n        local index=0\n        while ((index<k));\
    \ do\n            (( index+=1 ))\n            local j=$((index-1))\n         \
    \   if [[ \"$lst_A\" -ge \"$lst_B\" ]]; then\n                lst_B=\"$(sort -u\
    \ <<<\"${array[@]}\")\"\n                let \"j+=$n\"\n                let \"\
    n-=$n\"\n            else\n                lst_A=\"$(sort -u <<<\"${array[@]}\"\
    )\"\n                let \"n-=$n\"\n                let \"j-=$n\"\n          \
    \  fi\n        done\n        echo \"${array[*]}\"\n    done", "  local array=\"\
    $1\"\n  local max=$2\n  local count=0\n  local lst\n  local min\n  while IFS=''\
    \ read -r line || [[ -n \"$line\" ]]; do\n    lst=($(echo \"$line\" | sed 's/\\\
    \ //g'))\n    count=$((count+1))\n    min=$((min+1))\n    if [ \"$min\" -eq \"\
    $max\" ]; then\n      echo \"$line\"\n      exit 0\n    fi\n    for ((i=0; i<$max;\
    \ i++)); do\n      if [ \"$lst\" == \"$min\" ]; then\n        break\n      fi\n\
    \      if [ \"$i\" == \"$count\" ]; then\n        if [ \"$lst\" -ge \"$i\" ];\
    \ then\n          lst=($min $lst)\n        else\n          lst=$lst\n        fi\n\
    \        break\n      fi\n      if [ \"$lst\" -ge \"$i\" ]; then\n        lst=($lst)\n\
    \      fi\n    done\n  done <<<\"$array\"", "    local -r lines=$1\n    local\
    \ -r k=$2\n    local -r path=\"\"\n    local -r tmp=\"\"\n\n    local -r grid=$(\"\
    ${lines}\"'split(\"\\n\")'\"${IFS}\")\n    local -r rows=$((${#grid[@]} - 1))\n\
    \    local -r cols=$((${#grid[@]} / rows))\n\n    local -r count=0\n    local\
    \ -r row=0\n    local -r col=0\n\n    for (( i=0; i < ${#grid[@]}; i++ )); do\n\
    \        local -r value=${grid[$i]}\n        local -r value_string=\"${value}\"\
    \n\n        if [ ${#value} -gt 0 ]; then\n            local -r rowValue=$(( row\
    \ * cols + col))\n            local -r colValue=$(( col * rows + row))\n     \
    \       \n            if [[ \"${value}\" = \"${grid[rowValue]}\" ]]; then\n  \
    \              path=\"${path}${value}\"\n            elif [[ \"${value}\" = \"\
    ${grid[colValue]}\" ]]; then\n                path=\"${path}\\\"${value}\\\"\"\
    \n            else\n                path=\"${path}\\\"${value_string}\\\"\"\n\
    \            fi\n            (( count++ ))\n        fi\n    done\n\n    # Find\
    \ minimum path\n    for (( i=0; i<${k}; i++ )); do\n        for (( j=0; j<${rows};\
    \ j++ )); do\n            if [ ${count} -eq 0 ]; then\n                path=\"\
    ${path}${grid[j]}\"\n            elif [ ${count} -eq ${k} ]; then\n          \
    \      path=\"${path}\\\"${grid[j]}\"\n            else\n                if [\
    \ \"$path\" = \"${path}\" \"${grid[j]}\" ]; then\n                    path=\"\
    ${path}\\\"${grid[j]}\"\n                    (( count-- ))\n                else\n\
    \                    path=\"${path}${grid[j]}\"\n                fi\n        \
    \    fi\n        done\n    done\n\n    # Remove extra quotes\n    local -r path=\"\
    ${path//\\\"/}\"\n    \n    # Convert path into array\n    local -r pathArray=(${path})\n\
    \    \n    # Sort array in lexicographically ascending order\n    local -r sortedPathArray=()\n\
    \    local -r i\n    for (( i=0; i<${#pathArray[@]}; i++ )); do\n        local\
    \ -r value=${pathArray[$i]}\n        local -r value_string=\"${value}\"\n    \
    \    sortedPathArray+=(\"${value_string}\")\n    done\n    \n    # Return sorted\
    \ array \n    echo \"${sorted", "\tlocal lst_A=$(echo -e \"$1\" | sed \"s/ //g\"\
    \ | awk -F ' ' '{print $1}')\n\tlocal lst_B=$(echo -e \"$1\" | sed \"s/ //g\"\
    \ | awk -F ' ' '{print $2}')\n\tlocal i\n\tlocal j\n\tlocal k\n\tlocal lst\n\t\
    lst=()\n\tfor((i=1; i<=NF; i++))\n\tdo\n\t\tlst+=(\"$i\")\n\tdone\n\tlocal count\n\
    \tlocal count_A\n\tlocal count_B\n\tlocal j\n\tlocal m\n\tlocal l\n\tlocal n\n\
    \tlocal o\n\tlocal p\n\tlocal q\n\tlocal r\n\tlocal s\n\tlocal t\n\tlocal u\n\t\
    local v\n\tlocal w\n\tlocal x\n\tlocal y\n\tlocal z\n\tlocal count0\n\tlocal count1\n\
    \tlocal count2\n\tlocal count3\n\tlocal count4\n\tlocal count5\n\tlocal count6\n\
    \tlocal count7\n\tlocal count8\n\tlocal count9\n\tlocal count10\n\tlocal count11\n\
    \tlocal count12\n\tlocal count13\n\tlocal count14\n\tlocal count15\n\tlocal count16\n\
    \tlocal count17\n\tlocal count18\n\tlocal count19\n\tlocal count20\n\tlocal count21\n\
    \tlocal count22\n\tlocal count23\n\tlocal count24\n\tlocal count25\n\tlocal count26\n\
    \tlocal count27\n\tlocal count28\n\tlocal count29\n\tlocal count30\n\tlocal count31\n\
    \tlocal count32\n\tlocal count33\n\tlocal count34\n\tlocal count35\n\tlocal count36\n\
    \tlocal count37\n\tlocal count38\n\tlocal count39\n\tlocal count40\n\tlocal count41\n\
    \tlocal count42\n\tlocal count43\n\tlocal count44\n\tlocal count45\n\tlocal count46\n\
    \tlocal count47\n\tlocal count48\n\tlocal count49\n\tlocal count50\n\tlocal count51\n\
    \tlocal count52\n\tlocal count53\n\tlocal count54\n\tlocal count55\n\tlocal count56\n\
    \tlocal count57\n\tlocal count58\n\tlocal count59\n\tlocal count60\n\tlocal count61\n\
    \tlocal count62\n\tlocal count63\n\tlocal count64\n\tlocal count65\n\tlocal count66\n\
    \t", "  echo \"$1\" | cut -d' ' -f 1 | sort -n | head -n \"$2\"", "    local -n\
    \ arr1=arr=( \"$1\" )\n    local -n arr2=arr\n    local -i len=$2\n    local i\
    \ j k len2 arr arr2\n    local str str str str str str str str\n    local -a arr\n\
    \    local -a arr2\n    \n    arr=( $arr1 )\n    for (( i = 1; i <= len; i++ ));\
    \ do\n        arr2=( $arr )\n        for (( j = 1; j <= len; j++ )); do\n    \
    \        arr2=( $arr2 )\n            for (( k = 0; k < i; k++ )); do\n       \
    \         arr2=( $arr2 )\n            done\n        done\n        arr=( $arr2\
    \ )\n    done\n    \n    arr=( \"${arr[@]}\" )\n    echo -n \"\\\"\"\n    for\
    \ (( i = 0; i < len; i++ )); do\n        arr2=( $arr )\n        for (( j = 0;\
    \ j < len; j++ )); do\n            arr2=( $arr2 )\n            for (( k = 0; k\
    \ < len; k++ )); do\n                arr2=( $arr2 )\n            done\n      \
    \  done\n        arr=( $arr2 )\n        echo -n \"${arr[i]}\"\n        echo -n\
    \ \"\\\"\"\n    done\n    echo -n \"\\\" \"", "    \n    local grid\n    local\
    \ N\n    local k\n    local i\n    local j\n    local k\n    local lst_A\n   \
    \ local lst_B\n    \n    # parse arguments\n    grid=$1\n    shift\n    N=$1\n\
    \    shift\n    k=$1\n    shift\n    \n    if [[ \"$N\" -lt 2 ]]; then\n     \
    \   echo \"Invalid input: N must be positive\"\n        return 1\n    fi\n\n \
    \   if [[ \"$k\" -lt 1 ]]; then\n        echo \"Invalid input: k must be positive\"\
    \n        return 1\n    fi\n    \n    # parse grid lines into an array\n    grid=($grid)\n\
    \    \n    # find out the number of cells\n    cells=$((N*N))\n    \n    # parse\
    \ each grid line into an array\n    for ((i=0; i<N; i++)); do\n        for ((j=0;\
    \ j<N; j++)); do\n            cell=$(echo $grid[$((i*N+j))] | cut -d ' ' -f 1)\n\
    \            if [[ -z $cell ]]; then\n                continue\n            fi\n\
    \            cells[$cell]=$cell\n        done\n    done\n    \n    # sort the\
    \ array\n    sort -n -k 1 <<< \"${cells[@]}\"\n    \n    # add 1 to count the\
    \ grid lines (N-1)\n    count=$((N-1))\n    \n    # parse the numbers into an\
    \ array\n    declare -a lst_A\n    declare -a lst_B\n    while read -r line; do\n\
    \        for n in $line; do\n            lst_A+=(\"$((k-1))\")\n            lst_B+=(\"\
    $((n-1))\")\n        done\n    done <<< \"$cells\"\n    \n    # find the minimum\
    \ path length\n    minLen=0\n    for i in \"${lst_A[@]}\"; do\n        len=$((${#lst_B[@]}\
    \ - i))\n        if ((len > minLen)); then\n            minLen=$len\n        fi\n\
    \    done\n    \n    # find the answer array\n    declare -a answer\n    for i\
    \ in \"${lst_A[@]}\"; do\n        answer+=(${lst_B[@]:$i:$minLen})\n    done\n\
    \    \n    # print output\n    declare -p answer \n    ", "    echo \"${1:-No\
    \ input} ${2:-No integer}\"\n    \n    local lst_A\n    local lst_B\n    local\
    \ i j\n    local lst_len\n    local ans\n    \n    # Read input\n    while read\
    \ -r line || [[ -n \"$line\" ]]; do\n        lst_A+=(\"${line//$'\\n'/ }\")\n\
    \    done < <(echo \"$1\" | sed -e 's/ /\\n/g')\n    \n    # Read integer\n  \
    \  while read -r line || [[ -n \"$line\" ]]; do\n        ans+=\"\\\"${line//$'\\\
    n'/ }\\\"\"\n    done < <(echo \"$2\" | sed -e 's/ /\\n/g')\n\n    # Sort the\
    \ lists to make it lexicographically sorted\n    lst_A=(\"${lst_A[@]}\" | sort\
    \ -n)\n    lst_B=(\"${lst_B[@]}\" | sort -n)\n    \n    # Iterate through all\
    \ possible \"paths\"\n    for ((i = 0; i < ${#lst_A[@]}; i++)); do\n        lst_len=\"\
    ${#lst_A[@]}\"\n        ((j = 0))\n        while [[ $((j + i)) -lt ${#lst_B[@]}\
    \ ]] && [[ $lst_len -gt 0 ]]; then\n            [[ ${lst_A[$j+i]} -gt ${lst_B[$j]}\
    \ ]] || break\n            lst_len=$((lst_len-1))\n            j=$((j+i))\n  \
    \      done\n        \n        # Print the answer if it's not empty\n        if\
    \ [[ ${lst_len} -gt 0 ]]; then\n            printf '\"%s\"\\n' \"${ans[@]:0:lst_len}\"\
    \n        fi\n    done", "  mapfile -t -n \"${1:-$(tput lines)}\" lst_A < \"$1\"\
    \n  mapfile -t -n \"${2:-$(tput lines)}\" lst_B < \"$2\"\n\n  local k i\n\n  k=0\n\
    \  i=${#lst_A[@]}\n  while [ ${i} -gt 0 ]\n  do\n    [[ ${i} == 0 ]] && break\n\
    \    \n    (( ${lst_A[$i]} > ${lst_B[$i]} )) && k=$((k+1))\n    (( ${i} -= 1 ))\n\
    \  done\n  \n  echo \"${lst_A[@]:0:k}\"", "  read lst_A <<<\"$1\"\n  read k\n\
    \  read lst_B <<<\"$2\"\n  local lst_tmp\n  lst_tmp=$(sort --unique \"${lst_A[@]}\"\
    )\n  echo \"${lst_tmp[@]:1:$k}\"", "    local -n lst_A=$1; shift\n    local -n\
    \ lst_B=$1; shift\n    local -i index=0\n    local -n values=() \n    for (( i=0;\
    \ i<${#lst_A[@]}; i++ )) ; do\n        values+=( \"${lst_A[$i]}\" )\n    done\n\
    \    while [[ ${#values[@]} -gt 0 ]] ; do\n        (( index++ ))\n        local\
    \ values=()\n        for (( i=0; i<${#lst_B[@]}; i++ )) ; do\n            local\
    \ -a current=( ${values[@]:(-i)} )\n            values+=( ${lst_B[$i]} ) \n  \
    \          local -a next=( ${lst_A[@]:(-i)} )\n            for (( j=0; j<${#current[@]};\
    \ j++ )) ; do\n                if [[ -z ${next[j]} ]] ; then\n               \
    \     next+=(${current[j]})\n                    current=( ${current[@]:(-j)}\
    \ )\n                    break\n                fi\n            done\n       \
    \ done\n        (( index-- ))\n        values+=( ${lst_A[$index]} )\n    done\n\
    \    local -n res=$1\n    for (( i=0; i<${#res[@]}; i++ )) ; do\n        res[$i]=\"\
    ${res[$i]// /}\"\n    done", "  local lst_str=$1\n  local val=$2\n  local lst_A=()\n\
    \  local lst_B=()\n  local i\n  local j\n  local j_tmp\n  local j_tmp_tmp\n  local\
    \ val_tmp\n  local val_tmp_tmp\n  local path_str\n  local path_str_tmp\n  local\
    \ val_tmp_tmp_tmp\n  local idx\n\n  if [[ \"${lst_str}\" == \"\" ]]; then\n  \
    \  printf \"The provided string \\\"%s\\\" is empty.\\n\" \"${lst_str}\"\n   \
    \ return\n  fi\n  if [[ \"${val}\" -lt 1 ]] || [[ \"${val}\" -gt \"${#lst_str}\"\
    \ ]]; then\n    printf \"The value \\\"%s\\\" is outside of the allowed range.\\\
    n\" \"${val}\"\n    return\n  fi\n  idx=0\n  while read -r line; do\n    idx=$((idx+1))\n\
    \    if [[ $((idx%2)) == 1 ]]; then\n      lst_A+=(\"${line}\")\n    else\n  \
    \    lst_B+=(\"${line}\")\n    fi\n  done < <(echo \"${lst_str}\")\n\n  if [[\
    \ ${#lst_A} -eq 0 ]]; then\n    printf \"The provided string \\\"%s\\\" is empty.\\\
    n\" \"${lst_str}\"\n    return\n  fi\n\n  if [[ ${#lst_B} -eq 0 ]]; then\n   \
    \ printf \"The provided string \\\"%s\\\" is empty.\\n\" \"${lst_str}\"\n    return\n\
    \  fi\n\n  # If lst_A or lst_B are empty there is no path between them\n  if [[\
    \ ${#lst_A} -eq 0 ]] || [[ ${#lst_B} -eq 0 ]]; then\n    printf \"The provided\
    \ string \\\"%s\\\" is empty.\\n\" \"${lst_str}\"\n    return\n  fi\n\n  # If\
    \ lst_A and lst_B are both not empty, we need to find the k'th number\n  # in\
    \ lst_B in order to find the k'th number in lst_A to make the lexicographical\n\
    \  # ordering work\n  j_tmp=$(grep -E '^[[:digit:]]+$' <<< \"${lst_B}\" | tail\
    \ -n 1)\n  if [[ ${j_tmp} == \"\" ]]; then\n    printf \"The provided string \\\
    \"%s\\\" is empty.\\n\" \"${lst_str}\"\n    return\n  fi\n  val_tmp=$(grep -E\
    \ '^[[:digit:]]+$' <<< \"${", "    local lines=$1\n    local k=$2\n    local lst_A\
    \ lst_B\n    local i j\n    lst_A=()\n    lst_B=()\n    local val\n    for ((i\
    \ = 0; i < $#lines;++i)); do\n        echo $lines[i]\n        val=`echo $lines[i]\
    \ | awk '{print $1}'`\n        lst_A+=( \"$val\" )\n    done\n    for ((i = 0;\
    \ i < $#lst_A;++i)); do\n        lst_B+=( \"$lst_A[$i]\" )\n    done\n    for\
    \ ((i = $#lst_A; --i;)); do\n        for ((j = i; --j;)); do\n            if [[\
    \ ${lst_B[$j]} -gt ${lst_B[$i]} ]]; then\n                val=`echo $lst_B[$j]\
    \ | awk '{print $1}'`\n                val1=`echo $lst_B[$i] | awk '{print $1}'`\n\
    \                lst_B[$i]=${val}\n                lst_B[$j]=${val1}\n       \
    \     fi\n        done\n    done\n    val=`echo $lst_B[$#lst_B] | awk '{print\
    \ $1}'`\n    echo $val", "\tlet N=\"${#${1}}\"\n\tlet K=\"${#2}\"\n\tlet k=\"\
    ${2}\"\n\tlet grid=\"${1//$N/}\"\n\tlet indices=\"${grid//[0-9]/}\"\n\tlet indices=\"\
    ${indices//[$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//[$N*$N]/ }\"\n\tlet indices=\"\
    ${indices//[$K*$K]/ }\"\n\tlet indices=\"${indices//", "    local lst_A=\"$1\"\
    \n    local lst_B=\"$2\"\n    local k len\n    [[ \"$lst_A\" =~ '^[0-9]*$' ]]\
    \ && {\n        echo \"error: first argument should be a sequence of positive\
    \ integers\" >&2\n        return 1\n    }\n    [[ \"$lst_B\" =~ '^[0-9]*$' ]]\
    \ && {\n        echo \"error: second argument should be a positive integer\" >&2\n\
    \        return 1\n    }\n    [[ \"$lst_A\" =~ '^[0-9]+$' ]] && {\n        echo\
    \ \"error: first argument should be space-separated integers\" >&2\n        return\
    \ 1\n    }\n    [[ \"$lst_B\" =~ '^[0-9]+$' ]] && {\n        echo \"error: second\
    \ argument should be space-separated integers\" >&2\n        return 1\n    }\n\
    \    [[ \"$lst_A\" =~ '^[0-9]+\\.[0-9]+$' ]] && {\n        echo \"error: first\
    \ argument should be space-separated integers\" >&2\n        return 1\n    }\n\
    \    [[ \"$lst_B\" =~ '^[0-9]+\\.[0-9]+$' ]] && {\n        echo \"error: second\
    \ argument should be space-separated integers\" >&2\n        return 1\n    }\n\
    \    [[ \"$lst_A\" =~ '^[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\\n[0-9]+\\.[0-9]+\\\
    \\n[0-9]+\\.[0-9]+\\\\n", "    local N=\"$1\"\n    local k=\"$2\"\n    local lst_A=\"\
    \"; local lst_B=\"\";\n    for ((i=0; i<N; i++)); do\n        lst_A+=\"$(i)\"\n\
    \        lst_B+=\"$(i)\"\n    done\n    for ((i=0; i<k; i++)); do\n        lst_A+=\"\
    1\"\n        lst_B+=\"1\"\n    done\n    lst_B+=\"$(echo \"${lst_A}\" | sort |\
    \ uniq)\" # lexicographically ordered\n    lst_A=\"$(echo \"${lst_B}\" | sort\
    \ | uniq)\" # lexicographically ordered\n    lst_A=\"$(echo \"${lst_A}\" | sed\
    \ -e \"s/$/ \\\"${lst_A}\\\"\" )\"\n    lst_B=\"$(echo \"${lst_B}\" | sed -e \"\
    s/$/ \\\"${lst_B}\\\"\" )\"\n    echo $lst_A", "\t[[ $1 =~ ^\\#.*$ ]] && echo\
    \ \"$1\" && return 0;\n\tlocal lines=\"$1\"\n\tshift\n\tlocal k=\"$1\"\n\tshift\n\
    \tlocal grid=\"\"\n\tlocal listA=\n\tlocal listB=\n\tlocal i\n\tlocal j\n\tlocal\
    \ k\n\tlocal lst_A\n\tlocal lst_B\n\tlocal j\n\tlocal val\n\n\tlocal max=\"$(tr\
    \ -d '[:space:]' <<< \"$k\" | wc -c)\"\n\tlet max=$max-1\n\n\twhile read -r line\n\
    \tdo\n\t\tgrid=\"${grid} $line\"\n\tdone <<< \"$lines\"\n\n\tlst_A=(\"${grid//$'\\\
    n'/ }\" )\n\tlst_B=(\"${grid//$'\\n'/ }\" )\n\n\t[[ \"$grid\" =~ ^$ ]] && return\
    \ 0;\n\n\tfor (( i=0; i < max; i++ ))\n\tdo\n\t\tlst_A=( \"${lst_A[@]}\" )\n\t\
    done\n\n\tfor (( i=0; i < max; i++ ))\n\tdo\n\t\tlst_B=( \"${lst_B[@]}\" )\n\t\
    done\n\n\tfor (( i=0; i < max; i++ ))\n\tdo\n\t\t[[ \"$i\" -lt \"$max\" ]] &&\
    \ break\n\tdone\n\n\tval=\"$(\n\t\tfor (( i=0; i < max; i++ ))\n\t\tdo\n\t\t\t\
    [[ \"$i\" -lt \"$max\" ]] && break;\n\t\t\t[[ -z \"${lst_A[$i]}\" ]] && continue\n\
    \t\t\t[[ -z \"${lst_B[$i]}\" ]] && continue\n\t\t\tval=\"${val} \\\"${lst_A[$i]}\\\
    \"\"\n\t\t\t[[ \"$k\" -eq \"${lst_A[$i]}\" ]] && lst_A=( \"${lst_A[@]:0:i}\" )\n\
    \t\t\t[[ \"$k\" -eq \"${lst_B[$i]}\" ]] && lst_B=( \"${lst_B[@]:0:i}\" )\n\t\t\
    done\n\t)\"\n\n\t[[ -z \"$val\" ]] && return 0\n\t[[ \"$k\" -eq \"$val\" ]] &&\
    \ return 0\n\n\tfor i in $(seq \"$k\")\n\tdo\n\t\tlst_A=( \"${lst_A[@]}\" )\n\t\
    done\n\n\tfor i in $(seq \"$k\")\n\tdo\n\t\tlst_B=( \"${lst_B[@]}\" )\n\tdone\n\
    \n\tval=\"$(\n\t\tfor ((", "    local g=\"$1\";\n    local k=\"$2\";\n    local\
    \ A=\"()\";\n    local B=\"()\";\n    local min=\"()\";\n    local i=\"()\";\n\
    \    local j=\"()\";\n    local lst_A=\"()\";\n    local lst_B=\"()\";\n    local\
    \ tmp;\n    \n    g=${g//$'\\n'/ };\n    g=${g//\"/ };\n    lst_A=($g);\n    lst_B=();\n\
    \n    for((i=0;i<${#lst_A[@]};i++)); do\n        tmp=${lst_A[i]};\n        for((j=0;j<${#lst_A[@]};j++));\
    \ do\n            [[ \"${lst_A[j]}\" == \"${tmp}\" ]] && lst_B+=(${lst_A[j]})\
    \ && lst_B+=(${lst_B[j]});\n        done\n        ((i==${#lst_A[@]})) && break;\n\
    \    done\n    for((i=0;i<${#lst_B[@]};i++)); do\n        tmp=${lst_B[i]};\n \
    \       for((j=0;j<${#lst_B[@]};j++)); do\n            [[ \"${lst_B[j]}\" == \"\
    ${tmp}\" ]] && lst_A+=(${lst_B[j]}) && lst_A+=(${lst_A[j]});\n        done\n \
    \       ((i==${#lst_B[@]})) && break;\n    done\n    \n    lst_A=(\"${lst_A[@]/#/\\\
    \"\\\"\");\n    lst_B=(\"${lst_B[@]/#/\\\"\\\"\");\n    \n    min=($(sort <<<\
    \ \"${lst_A[@]}\" | sort -n | head -n \"${k}\"));\n    for((i=0;i<${#min[@]};i++));\
    \ do\n        [[ \"${min[i]}\" == \"${lst_B[${i}]}\" ]] && min[i]=\"\\\"${min[i]}\\\
    \"\" || min[i]=\"\\\"${min[i]}\\\" \\$\\$\";\n    done\n    \n    min=($(sort\
    \ <<< \"${min[@]}\"));\n    for((i=0;i<${#min[@]};i++)); do\n        [[ \"${min[i]}\"\
    \ == \"${lst_A[${i}]}\" ]] && min[i]=\"\\\"${min[i]}\\\"\" || min[i]=\"\\\"${min[i]}\\\
    \" \\$\\$\";\n", "    local inputLines\n    local numLines\n    local inputLine\n\
    \    local minPaths\n    local minPath\n    local index\n    local cell\n    local\
    \ cellValue\n    local cellValueIndex\n    local currentPath\n    local currentPathIndex\n\
    \    local currentPathValue\n    local currentPathValueIndex\n    local currentCellValue\n\
    \    local currentCellValueIndex\n    local currentCellValueIndexes\n    local\
    \ tempPaths\n    local tempPath\n    local tempCellValue\n    local tempCellValueIndex\n\
    \    local tempCellValueIndexes\n    local tempCellValueIndexesCounter\n    local\
    \ tempCellValueIndexesCounterValue\n    local cellValueIndexesCounter\n    local\
    \ cellValueIndexesCounterValue\n    local minPathsCounter\n    local minPathsCounterValue\n\
    \    local currentPathsCounter\n    local currentPathsCounterValue\n    local\
    \ tempPathsCounter\n    local tempPathsCounterValue\n    local tempCellValueIndexesCounter\n\
    \    local tempCellValueIndexesCounterValue\n    local currentPaths\n    local\
    \ currentPathValue\n    local currentPathValueIndex\n    local minPaths\n    local\
    \ minPathValue\n    local minPathValueIndex\n    local minPathValueIndexes\n \
    \   local minPathValueIndexesIndex\n    local currentMinPathsCounter\n    local\
    \ currentMinPathsCounterValue\n    local tempCellValueIndexes\n    local tempCellValueIndex\n\
    \    local tempCellValueIndexesIndex\n    local minPathIndexes\n    local minPathIndex\n\
    \    local tempCellValueIndexesIndexesIndexesIndex\n    local currentMinPaths\n\
    \    local currentMinPathValue\n    local minPathsCounterIndexesIndexesIndexesIndexesIndexesIndex\n\
    \    local currentMinPathsCounterValue\n\n    inputLines=$@\n    numLines=$(echo\
    \ \"$inputLines\" | wc -l)\n    if [[ \"$numLines\" -lt 2 ]]; then\n        echo\
    \ \"Input too short!\"\n        return -1\n    fi\n    if [[ \"$numLines\" -gt\
    \ 10 ]]; then\n        echo \"Too many lines!\"\n        return -1\n    fi\n \
    \   if [[ \"$numLines\" -eq 0 ]]; then\n        echo \"Input is empty!\"\n   \
    \     return -1\n    fi\n    \n    # Split inputLines on newlines\n    inputLines=$(\
    \ IFS=$'\\n' echo \"$inputLines\" )\n    \n    # Set up paths for ", "    local\
    \ g\n    local N=$2\n    local k=$3\n    read -r -a g <<< \"$1\"\n    g=( \"${g[@]}\"\
    \ )\n    # Sort by value, start at lowest value, to not visit same cell twice.\n\
    \    local -a gsorted\n    local val\n    for val in \"${g[@]}\"; do\n       \
    \ local i\n        gsorted+=( \"$val\" )\n    done\n    # Sort by value, then\
    \ by index to have lexicographically low index values.\n    local -a gsorted+=(\"\
    \")\n    local i\n    for val in \"${gsorted[@]}\"; do\n        local j\n    \
    \    for ((j=0; j<k; j++)); do\n            i=$(( j + 1 ))\n            # In case\
    \ we don't have enough neighbors left (k was reached \n            # already),\
    \ add one to i\n            if [[ ${#gsorted[@]} -eq ${#gsorted[@]} - $i ]]; then\n\
    \                i=$(( i + 1 ))\n            fi\n            # Check if gsorted[j+i]\
    \ >= val\n            if [[ \"${gsorted[j+$i]}\" -gt \"$val\" ]]; then\n     \
    \           gsorted[j+i]=\"$val\"\n                break\n            fi\n   \
    \     done\n    done\n    echo ${gsorted[@]}", "    local lines=$(echo $1 | tr\
    \ '\\n' ' ')\n    local k=$(echo $2 | tr ' ' '\\n' | awk '{print $1}')\n\n   \
    \ local cells\n    cells=()\n    while read -r line\n    do\n        cells+=(\"\
    $line\")\n    done < <(echo \"$lines\")\n\n    local lst_cells\n    lst_cells=()\n\
    \    for cell in \"${cells[@]}\"\n    do\n        local lst_value\n        lst_value=()\n\
    \        for value in $cell\n        do\n            local index\n           \
    \ index=$(echo $value | cut -c1 | sed 's/ /-/g')\n            lst_value+=(\"$index\"\
    )\n        done\n        lst_cells+=(\"${lst_value[@]}\")\n    done\n\n    local\
    \ lst_index\n    lst_index=()\n    while read -r line\n    do\n        lst_index+=(\"\
    $(echo $line | awk '{print $1}')\")\n    done < <(echo \"${lst_cells[@]}\")\n\n\
    \    local lst_sorted\n    lst_sorted=()\n    for index in \"${lst_index[@]}\"\
    \n    do\n        local value\n        value=\"${cells[$index]}\"\n        lst_sorted+=(\"\
    $value\")\n    done\n\n    local lst_sorted2\n    lst_sorted2=()\n    for value\
    \ in \"${lst_sorted[@]}\"\n    do\n        local index\n        index=$(echo $value\
    \ | cut -c1 | sed 's/-/ /g')\n        lst_sorted2+=(\"$index\")\n    done\n\n\
    \    local lst_result\n    lst_result=()\n    for index in \"${lst_sorted2[@]}\"\
    \n    do\n        local value\n        value=\"${cells[$index]}\"\n        lst_result+=(\"\
    $value\")\n    done\n\n    echo ${lst_result[@]}", "\t[[ $1 =~ $\"(^| )$2 $\"\
    (\\s|$)\" ]]\n\tlocal arr=($1)\n\tlocal len=${#arr[@]}\n\tlocal min=1\n\tlocal\
    \ k=0\n\tlocal lst_A=()\n\tlocal lst_B=()\n\n\twhile (( $len > 0 )); do\n\t\t\
    let \"k++\"\n\t\tlet \"len--\"\n\t\tlst_A+=($(( $k - 1 )))\n\t\tlst_B+=($k)\n\t\
    done\n\n\tfor i in $(seq 1 $k); do\n\t\tlocal j=0\n\t\twhile (( $j < $k )); do\n\
    \t\t\t[[ $lst_A[$i] -gt $lst_B[$j] ]] && break\n\t\t\tlet \"j++\"\n\t\tdone\n\t\
    \tlocal elem=$(( $i + $j ))\n\t\tlst_B[$elem]=$lst_A[$elem]\n\tdone\n\techo ${lst_B[@]}",
  "    local line_N=$1\n    local line_k=$2\n    local line\n    local i\n    local\
    \ j\n    local list1\n    local list2\n    local result\n    \n    for (( i=1;\
    \ i<${#line_N}; i++ ))\n    do\n        line=$(echo $line_N | sed -n $i | sed\
    \ 's/^ *//g;s/ //g')\n        list1=($(echo $line | tr \" \" \"\\n\"))\n    done\n\
    \n    list2=()\n    for (( j=0; j<${#list1[@]}; j++ ))\n    do\n        list2=(\"\
    ${list2}\" \"${list1[$j]}\")\n    done\n\n    list2=(${list2[@]})\n\n    for ((\
    \ i=0; i<${#list2[@]}; i++ ))\n    do\n        result=$(echo $list2 | sort -n\
    \ | sed 's/^ *//g;s/ //g')\n        if [[ $result > $line_k ]]\n        then\n\
    \            result=$(echo $list2 | sort -n | sed 's/^ *//g;s/ //g;s/^/'\"$line_k\"\
    '/g')\n        fi\n        list2=(${list2[@]:0:$i+1})\n        list2=(${list2[@]}\
    \ \"$result\")\n    done\n\n    echo ${list2[@]}", "    local -r grid=\"$1\"\n\
    \    local -r num=\"$2\"\n\n    # N is the number of rows and columns in the grid\n\
    \    local -r N=\"${#grid[@]}\"\n    local -r lst_grid\n    local -r lst_num\n\
    \n    # Create a ordered list of the numbers contained on the grid.\n    # For\
    \ example, if grid='1 2 3' and num=2 then lst_grid=['1', '2', '3']\n    #\n  \
    \  # Iterate through each row in the grid\n    for (( i=0; i<N; i++ )); do\n \
    \       # Iterate through each column in the row\n        for (( j=0; j<N; j++\
    \ )); do\n            # Add the number in the grid to lst_grid\n            #\
    \ Note: lst_num is an array and not a scalar\n            local -r tmp_num=\"\
    ${grid[$(( i * N + j ))]}\"\n            local -r tmp_num+=\" \"\n           \
    \ lst_num+=(\"$tmp_num\")\n        done\n    done\n    # Sort the list\n    sort\
    \ -u \"${lst_num[@]}\"\n\n    # Return an array of the values on the grid that\
    \ the minimum path go through.\n    # Each number in the array is surrounded by\
    \ double quotes, i.e.\n    # ['\"1\"', '\"2\"', '\"3\"']\n    local -r res=()\n\
    \    for (( j=0; j<N; j++ )); do\n        # Iterate through each element of the\
    \ list\n        local -r num=\"${lst_grid[j]}\"\n        for (( i=j; i<num; i++\
    \ )); do\n            # Add the number to the list\n            local -r tmp_num=\"\
    ${lst_grid[i]}\"\n            local -r tmp_num+=\" \"\n            lst_grid[i]=\"\
    $tmp_num\"\n        done\n        lst_grid=\"${lst_grid[@]}\"\n        local -r\
    \ tmp_res\n        if [ \"$num\" -eq \"$num\" ]; then\n            # Set the value\
    \ of the variable tmp_res\n            tmp_res=\"\\\"$num\\\"\"\n        else\n\
    \            # Add the number to the res\n            tmp_res=\"$num\"\n     \
    \   fi\n        local -r res+=(\"$tmp_res\")\n    done\n    # Sort the list\n\
    \    sort -u \"${res[@]}\"", "    local lines=$1\n    local line\n    local lines\n\
    \    local result\n    local index\n    local indexA\n    local indexB\n    local\
    \ value\n    local valA\n    local valB\n    local lst_A\n    local lst_B\n  \
    \  local i\n    local j\n    local result\n    local tmp\n    local val\n    local\
    \ tmpA\n    local tmpB\n    local tmpC\n    local lst_C\n    local lst_Tmp\n \
    \   local lst_TmpA\n    local lst_TmpB\n    local lst_TmpC\n    local lst_TmpD\n\
    \    local lst_TmpE\n    local lst_TmpF\n    local lst_TmpG\n    local lst_TmpH\n\
    \    local lst_TmpI\n    local lst_TmpJ\n    local lst_TmpK\n    local lst_TmpL\n\
    \    local lst_TmpM\n    local lst_TmpN\n    local lst_TmpO\n    local lst_TmpP\n\
    \    local lst_TmpQ\n    local lst_TmpR\n    local lst_TmpS\n    local lst_TmpT\n\
    \    local lst_TmpU\n    local lst_TmpV\n    local lst_TmpW\n    local lst_TmpX\n\
    \    local lst_TmpY\n    local lst_TmpZ\n    local lst_TmpA\n    local lst_TmpB\n\
    \    local lst_TmpC\n    local lst_TmpD\n    local lst_TmpE\n    local lst_TmpF\n\
    \    local lst_TmpG\n    local lst_TmpH\n    local lst_TmpI\n    local lst_TmpJ\n\
    \    local lst_TmpK\n    local lst_TmpL\n    local lst_TmpM\n    local lst_TmpN\n\
    \    local lst_TmpO\n    local lst_TmpP\n    local lst_TmpQ\n    local lst_TmpR\n\
    \    local lst_TmpS\n    local lst_TmpT\n    local lst_TmpU\n    local lst_TmpV\n\
    \    local lst_TmpW\n    local lst_TmpX\n    local lst_Tmp", "    local line_string\
    \ line_array line_count line_string line_string i j k value value_count\n    local\
    \ line_count line_count line_string line_string line_string line_string line_string\
    \ line_string line_index\n    local line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string\
    \ line_string line_string line_string line_string line_string line_string line_string ",
  "  local lines=$1\n  local k=$2\n  [[ -z $lines ]] && echo \"Invalid input\" &&\
    \ return 1\n  [[ -z $k ]] && echo \"Invalid input\" && return 1\n  local sorted_lst_A=()\n\
    \  local sorted_lst_B=()\n  local i\n  \n  # Remove newlines, split into lines\n\
    \  lines=${lines//$'\\n'/ }\n  lines=($lines)\n  \n  # Convert lines to sorted\
    \ lists\n  for i in \"${lines[@]}\"; do\n    sorted_lst_A+=(\"$i\")\n  done\n\
    \  for i in \"${lines[@]}\"; do\n    sorted_lst_B+=(\"$i\")\n  done\n  \n  # Find\
    \ the minimum path of length k \n  local j=0\n  local path_length=0\n  local minimum_path=\"\
    \"\n  \n  for ((i=1; i <= k; i++)); do\n    # Check if i equals to k\n    if [[\
    \ \"$i\" == \"$k\" ]]; then\n      # Add i to the minimum path\n      minimum_path+=\"\
    $i\"\n      path_length=$i\n      break\n    fi\n  \n    # Check if j equals to\
    \ k\n    if [[ \"$j\" == \"$k\" ]]; then\n      # Add j to the minimum path\n\
    \      minimum_path+=\"$j\"\n      break\n    fi\n    \n    # Find the minimum\
    \ value\n    local minimum_value=${sorted_lst_A[$((j+1))]}\n    local minimum_index=0\n\
    \    \n    # Iterate through all indices to find the minimum\n    for ((j=1; j\
    \ <= i; j++)); do\n      # Check if the value at index\n      if [[ ${sorted_lst_A[$((j+1))]}\
    \ == $minimum_value ]]; then\n        minimum_index=$j\n        break\n      fi\n\
    \    done\n    \n    # If j is less than k, then we found the minimum value j\
    \ at index\n    if [[ $minimum_index < $j ]]; then\n      # Add j to the minimum\
    \ path\n      minimum_path+=\"$j\"\n      path_length=$i\n      break\n    fi\n\
    \  done\n  \n  # Check if minimum path found\n  if [[ -z $minimum_path ]]; then\n\
    \    echo \"Minimum path not found\" && return 1\n  else\n    echo \"Minimum path:\
    \ $minimum_path\"\n  fi", "  local -n arr=$1\n  local str=$2\n  local -n arr2=()\n\
    \  local -n i=0 i2 j2 k min max min2 min2str max2 max2str\n  # First we sort out\
    \ the array of numbers (we ignore the \\n and space)\n  while ((i < ${#arr[@]}));\
    \ do\n    arr2[$i]=(\"${arr[$i]}\")\n    i=$((i+1))\n  done\n  # Then we count\
    \ the duplicates (we ignore the duplicates)\n  local -n j=0\n  local -n k=0\n\
    \  local strarr=()\n  local strarr2=()\n  for ((i = 1; i <= ${#arr2[@]}; i++));\
    \ do\n    k=$((${#arr2[$i]}+1))\n    strarr+=(${arr2[$i]})\n    for ((j=1; j <=\
    \ ${#arr2[$i]}; j++)); do\n      if [[ ${arr2[$i][j]} != ${arr2[$i][j-1]} ]];\
    \ then\n        k=$((k+1))\n      fi\n    done\n    arr2[$i]=(\"$k\")\n    strarr2+=(${arr2[$i]})\n\
    \  done\n  # Now we sort the array again (we ignore the duplicates)\n  for ((i=1;\
    \ i <= ${#arr2[@]}; i++)); do\n    for ((j=1; j <= ${#arr2[$i]}; j++)); do\n \
    \     min2=\"${arr2[$i][$j]}\"\n      min2str=\"${arr2[$i][$j]}\"\n      max2=\"\
    ${arr2[$i][$((${#arr2[$i]}-1))]}\"\n      max2str=\"${arr2[$i][$((${#arr2[$i]}-1))]}\"\
    \n      if [[ $((${#min2str})) == ${#max2str} ]]; then\n        ((min2<max2))\
    \ && arr2[$i]=\"${arr2[$i]}${min2str}\"\n      else\n        ((min2<max2<${#min2str}))\
    \ && arr2[$i]=\"${arr2[$i]}${min2str}${max2str}\"\n      fi\n    done\n  done\n\
    \  # Then we sort the array again (we ignore the duplicates)\n  for ((i=1; i <=\
    \ ${#arr2[@]}; i++)); do\n    for ((j=1; j <= ${#arr2[$i]", "  local g=\"$1\"\n\
    \  local k=\"$2\"\n  local lst_A\n  local lst_B\n  local i j\n  local ret\n  \n\
    \  [[ \"$g\" =~ ^[0-9]+(\\n[0-9]+){0,1} [a-z]+ [0-9]+(\\n[0-9]+){0,1} $([0-9]+)\
    \ ]]\n  [[ \"$k\" =~ ^[0-9]+$ ]]\n  \n  if [[ \"$k\" -gt 2 ]]; then\n    echo\
    \ \"Only k of length 2 is allowed\"\n    return 1\n  fi\n  \n  lst_A=($(sed 's/\
    \ /\" \" /g' <<< \"${g#*\\n}\"))\n  lst_B=($(sed 's/ /\" \" /g' <<< \"${g% *}\"\
    ))\n  \n  # Sort the two lists\n  [[ \"$lst_A\" =~ ^[0-9]+$ ]]\n  [[ \"$lst_B\"\
    \ =~ ^[0-9]+$ ]]\n  \n  i=$(( ${lst_A[@]} | sed -n 's/^\\([0-9]*\\)$/\"\\1\"/p'\
    \ | sort -n -k 1 | head -1 | cut -d '\"' -f 1))\n  j=$(( ${lst_B[@]} | sed -n\
    \ 's/^\\([0-9]*\\)$/\"\\1\"/p' | sort -n -k 1 | head -1 | cut -d '\"' -f 1))\n\
    \  \n  ret=($(sed -n \"${i};${j};p\" \"${g% *}\")) # Remove lines from $g\n  \n\
    \  [[ \"$ret\" =~ ^[0-9]+$ ]]\n  [[ \"$ret\" =~ ^[0-9]*\" \"$k\" ]]\n  \n  [[\
    \ \"$ret\" =~ ^[0-9]*\" \"$k\" ]]\n  \n  echo \"${ret[@]}\"\n  return 0", "  \
    \  local -n lines=$1\n    local -i N=$2\n    local -i k=$3\n\n    local i j lst_A\
    \ lst_B\n    lst_A=()\n    lst_B=()\n\n    [[ -z \"$lines\" ]] && return 1\n \
    \   [[ -z \"$N\" ]] && return 1\n    [[ -z \"$k\" ]] && return 1\n\n    while\
    \ read -r line; do\n        i=$(echo \"$line\" | sed -n 's/^[^0-9]*\\([0-9]*\\\
    )[^0-9]*$/\\1/p' | sort)\n        j=$(echo \"$line\" | sed -n 's/^[^0-9]*\\([0-9]*\\\
    )[^0-9]*$/\\1/p' | sort)\n        lst_A+=(\"$i\")\n        lst_B+=(\"$j\")\n \
    \   done < <(tr -s '\\n' ' ' <<<\"$lines\")\n\n    for ((i=1; i <= k; i++)); do\n\
    \        lst_A+=($(echo \"${lst_A[*]}\" | sort | sed \"s/.*/\\\"\\$1\\\"/\"))\n\
    \    done\n\n    [[ \"${#lst_A[@]}\" -le $k ]] && return 1\n\n    for ((i=1; i\
    \ <= k; i++)); do\n        lst_B+=($(echo \"${lst_B[*]}\" | sort | sed \"s/.*/\\\
    \"\\$1\\\"/\"))\n    done\n\n    lst_A+=($(echo \"${lst_A[*]}\" | sort | sed \"\
    s/.*/\\\"\\$1\\\"/\"))\n    lst_B+=($(echo \"${lst_B[*]}\" | sort | sed \"s/.*/\\\
    \"\\$1\\\"/\"))\n\n    [[ \"${#lst_A[@]}\" -eq 0 ]] && return 1\n\n    for ((i=k;\
    \ i>1; i--)); do\n        if [[ \"${lst_A[((i-1))]}\" -gt \"${lst_A[i]}\" ]];\
    \ then\n            lst_A=($(echo \"${lst_A[@]}\" | sed -n \"s/^\\\"\\([0-9]*\\\
    )\\\"/\\\"\\$1\\\"/p\"))\n        elif [[ \"${lst_A[((i-1))]}\" -lt \"${lst_A[i]}\"\
    \ ]]; then\n            lst_B=($(echo \"${lst_B[@]}\" | sed -n \"s/^\\\"\\([0-9]*\\\
    )\\\"/\\\"\\$1\\\"/p\"))\n        fi\n    done\n\n    [[ \"${#lst_A[@]}\" -eq",
  "    declare -a arr\n    declare -a list\n    declare -a map\n    map=()\n    arr=($1)\n\
    \    map=$((${arr[0]}+1))\n    for i in \"${arr[@]:1}\" ; do \n        map=$((${map}+${map}))\n\
    \    done\n    while [ ${#map[@]} -ge $2 ]; do\n        for i in \"${!map[@]}\"\
    \ ; do\n            list+=(${map[$i]})\n        done\n        for i in \"${!map[@]}\"\
    \ ; do\n            if [ ${map[$i]} -eq ${map[$((${#list[@]} - 1))]} ]; then\n\
    \                map=$((${map} - ${map[$i]}))\n                break\n       \
    \     fi\n        done\n    done\n    echo ${list[@]} | sort", "  local lines=\"\
    $1\"\n  local line=\"${lines[@]}\"\n  local length=\"${line#*}\"\n  local length=\"\
    ${length% *}\"\n  local lineNumber\n  local path\n  local lstA\n  local lstB\n\
    \  local i\n  local j\n  local l\n  local count\n\n  if [[ \"${length}\" -eq 0\
    \ ]]; then\n    return \"\"\n  fi\n\n  if [[ \"${length}\" -gt \"${MAX_LENGTH}\"\
    \ ]]; then\n    return \"\"\n  fi\n\n  lineNumber=0\n  path=()\n  lstA=()\n  lstB=()\n\
    \  i=-1\n  j=-1\n  count=0\n  while ((++i <= length)) || [[ ${lines[$lineNumber]}\
    \ ]]; then\n    path+=(\"${lines[$lineNumber]}\")\n    lstA+=(\"${lines[$lineNumber]}\"\
    )\n    lstB+=(\"${lines[$lineNumber]}\")\n    ((lineNumber++))\n  done\n\n  for\
    \ ((l=${#path[@]}-1; l>=0; l--)); do\n    count=$((count+1))\n    count=$((count+1))\n\
    \  done\n\n  l=0\n  for ((l=${#path[@]}-1; l>=0; l--)); do\n    lstA[$l]=\"${lstA[$l]#*[}\"\
    \n    lstB[$l]=\"${lstB[$l]#*[}\"\n  done\n\n  sortArray() {\n    local arrayName=\"\
    $1\"\n    local sortType=\"$2\"\n    local length=\"$3\"\n    local arrayElement\n\
    \    local i\n    local sortValue\n    local sortKey\n    local sortValueLen\n\
    \    local sortKeyLen\n    local sortedArray\n    local sortedArrayName\n    local\
    \ sortKeyIsNumber\n\n    sortKeyIsNumber=false\n\n    sortedArrayName=$(getArrayName\
    \ \"${arrayName}\")\n    if [ -z ${!sortedArrayName} ]; then\n      echo \"${arrayName}\
    \ not defined.\"\n      return\n    fi\n\n    if [ \"${sortType}\" == \"asc\"\
    \ ]; then\n      sortedArray=\"${!sortedArrayName}\"\n      sortValueLen=${#sortedArray[@]}\n\
    \      sortKeyLen=${#sortArray[@]}\n      for ((i=0;i < $((${#sortedArray[@]})-1);++i));\
    \ do\n        arrayElement=\"${sortedArray[$i]}\"\n        if [ \"${arrayElement}\"\
    \ == \"${sortedArray[$((i-1))]}\" "]
stop_tokens:
- "\n}"
