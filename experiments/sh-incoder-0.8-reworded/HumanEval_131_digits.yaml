name: HumanEval_131_digits
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the product of the odd\
  \ digits.\n# Return 0 if all digits are even.\n# For example:\n# >>> $(digits \"\
  1\")\n# \"1\"\n# >>> $(digits \"4\")\n# \"0\"\n# >>> $(digits \"235\")\n# \"15\"\
  \n#\n# $1 is an integer\ndigits() {\n"
tests: "}\n\ncandidate() {\n    digits \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"5\") = \"5\" ]]\n    [[ $(candidate \"54\") = \"5\" ]]\n    [[ $(candidate \"\
  120\") = \"1\" ]]\n    [[ $(candidate \"5014\") = \"5\" ]]\n    [[ $(candidate \"\
  98765\") = \"315\" ]]\n    [[ $(candidate \"5576543\") = \"2625\" ]]\n    [[ $(candidate\
  \ \"2468\") = \"0\" ]]\n}\n\nrun_test"
completions: ["  local d\n  d=$1\n  local i=0\n  while (( $i <= $(( $# - 1 )) ))\n\
    \  do\n    d=$(( $d*( $(( $(( ${#d} % 2 )) )) ))\n    i=$(( i + 1 ))\n  done\n\
    \  echo $d", "    local n=$1\n\n    local num\n    while (( n )); do\n       \
    \ (( num = n % 10 ))\n        (( n = n / 10 ))\n        (( n %= 10 ))\n      \
    \  if (( num % 2 )); then\n            (( num *= 2 ))\n        fi\n    done\n\
    \    return $num", "  local n product\n  n=$1\n  product=1\n  while [[ n -gt 0\
    \ ]]; do\n    product=$(($product * $((n % 2))));\n    n=$(($n/2));\n  done;\n\
    \  echo $product;", "  local n=\"$1\"\n  # Convert n to string\n  local nstr=\"\
    $n\"\n  # Removing leading zero digits\n  nstr=${nstr#0}\n  nstr=${nstr#0}\n \
    \ local sum=0\n  local ndigits=${#nstr}\n  local digit\n  for i in $(seq 0 $((ndigits\
    \ - 1))); do\n    digit=\"${nstr$i}\"\n    sum=\"$((sum + ${digit:0:1} * 2 + ${digit:1:1}\
    \ * 1))\"\n  done\n  # Convert sum to string\n  sum=$((sum))\n  echo $sum", " \
    \   local digits=$1\n    local i=0\n    local product=1\n\n    while [ $i -lt\
    \ ${#digits} ]; do\n        product=$(($product * ${digits#0}))\n        i=$((i+1))\n\
    \    done\n    echo $product", "  local n=\"$1\"\n  local s=$(echo \"$n\" | sed\
    \ -e 's/^.//' -e 's/.$//')\n  local b=\"$(echo \"$s\" | sed -e 's/./ 2 /g' | tr\
    \ -d ' ')\"\n  echo \"$s\" | tr -d \" \" | sed -e 's/\\([^ ]*\\) \\(.*\\)/\\1\
    \ * \\2/'", "    local n=\"$1\"\n    local ret=\"$(echo \"$n\" | sed 's/\\([0-9]*\\\
    )\\([0-9]*\\)/\\2\\1/')\"\n    if [ \"$ret\" -eq \"$n\" ]; then\n        echo\
    \ \"0\"\n    fi\n    echo \"$ret\"", "  local string=$1\n  local prod=1\n  if\
    \ [[ $string =~ ^[0-9]+$ ]]; then\n    local digits=${string//+([0-9])/}\n   \
    \ for digit in ${digits}; do\n      if [[ $(( ${digit} % 2 )) == 0 ]]; then\n\
    \        (( prod *= ${digit} ))\n      fi\n    done\n  else\n    echo \"Error:\
    \ digits expects an integer\"\n  fi\n  echo $prod", "    local n=$1\n    echo\
    \ \"$n\" | tr [:lower:] [:upper:] | tr -d [:upper:] | grep -E '^[0-9]+$' | head\
    \ -n 1 2>/dev/null", "    local n digit\n    for n in \"$1\"; do\n        if [[\
    \ \"$n\" =~ ^[0-9]+$ ]]; then\n            break\n        fi\n        digit=$((n\
    \ % 10))\n        echo $((digit * $((10#$digit)))).${digit:+}\n    done\n    echo\
    \ 0", "  local digits=$1\n  local count=0\n  local factor=1\n  local product=0\n\
    \  local digit\n\n  if [ $digits -lt 10 ]; then\n    echo \"Usage: digits <n>\"\
    \n    exit 1\n  fi\n\n  for digit in $(( 10#$digits )) ; do\n    product=`echo\
    \ $(( $product * $factor ))`\n    if [[ $(( $factor % 2 )) -ne 0 ]]; then\n  \
    \    count=$(( $count + 1 ))\n    else\n      factor=$(( $factor / 2 ))\n    fi\n\
    \  done\n\n  if [ $count -eq 0 ]; then\n    echo \"0\"\n  else\n    echo \"$product\"\
    \n  fi", "  local n=\"$1\"\n  [[ \"$n\" =~ ^[0-9]+$ ]] && {\n    echo \"$n\" >\
    \ /dev/stderr\n    return 1\n  } || {\n    local d=0\n    local s\n    local c\n\
    \    local i\n    local p\n    for ((i=0; i<${#n}; i+=2)); do\n      s=${n:i:2}\n\
    \      c=$(printf '%s' \"${s//$'\\n'/}\")\n      ((p=$((p*10#${c}))));\n    done\n\
    \    echo \"$p\"\n  }", "    local digits=$1\n    if [ $digits -eq 1 ]; then\n\
    \        return 0\n    fi\n    if [ $digits -eq 0 ]; then\n        return 1\n\
    \    fi\n\n    # Multiply out the first digit and divide the result by the second\n\
    \    # digit and so on. After multiplying by the second digit,\n    # divide by\
    \ the third digit.\n    for ((i=2 ; i<$digits ; i=i+2)); do\n        digits=$((\
    \ $digits * $(( $(( $digits / $i )) % 2 )) ))\n    done", "  if (( $# < 1 ));\
    \ then\n    echo \"error: argument to $1 must be numeric\" >&2\n    return 1\n\
    \  fi\n  local i\n  for i in $(seq 1 $1) ; do\n    local n\n    for n in $(seq\
    \ 1 $i); do\n      if (( $(echo $(( $n % 2 )) | bc) == 0 )); then\n        echo\
    \ $(( $(echo $(( $n / 2 )) | bc ) * 2 ))\n        return 0\n      fi\n    done\n\
    \  done\n  echo $(( $i % 2 ))", "  # Pad with a leading zero for numbers less\
    \ than 10.\n  local number=$1\n  if [[ ${number} -lt 10 ]]; then\n    number=0$number\n\
    \  fi\n\n  # Strip leading zeros.\n  local digits=${number//+([0-9])/}\n\n  #\
    \ If there are an odd number of digits, return 0.\n  if [[ ${#digits} -eq 1 ]];\
    \ then\n    return 0\n  fi\n\n  # Recursively call this function on the digits.\n\
    \  local even\n  for (( even=0; even<${#digits}; even+=2 )); do\n    digits=$(digits\
    \ ${digits:${even}:2})\n  done\n\n  # Return product of odd digits.\n  echo \"\
    $digits\"", "    local IFS=\\\n    \\\n    if [ \"$1\" = \"--\" ] || [ \"$1\"\
    \ = \"-\" ]; then\n        echo \"Usage: $0 [number]\"\n        exit 2\n    fi\n\
    \n    local -r digits=''\n    local -r num_digits=\"$(expr \"$1\" : '\\([0-9]*\\\
    )')\"\n\n    for i in $(seq 0 $num_digits);\n    do\n        if [ \"$i\" -ge \"\
    9\" ]; then\n            digits=\"${digits}\"$i\n        elif [ \"$i\" -ge \"\
    5\" ];\n        then\n            digits=\"${digits}\"$(expr \"$i\" : '.\\([0-9]*\\\
    )')\n        else\n            digits=\"${digits}\"$(( ${digits} \\* 2 ))\n  \
    \      fi\n    done\n\n    echo -n \"${digits}\"", "  if [ \"${1:0:1}\" -eq \"\
    ${1:0:1}\" -a \"${1:0:1}\" -eq \"$1\" ]; then\n    echo \"${1:0:1}\"\n  else\n\
    \    local d=0\n    while (( ${1:0:1} > 9 )); do\n      ((d++))\n      (( ${1:0:1}\
    \ -= 10 ))\n    done\n    echo ${d//\\//}\n  fi", "    local n=$1\n    if [[ $n\
    \ =~ ^[0-9]+$ ]]; then\n        local nstr=$(printf %o \"$n\")\n        local\
    \ digits=$(\n            awk '{\n                for (i=1; i<=NF; i++) {\n   \
    \                 printf(\"%o\", $i);\n                }\n            }' <<< \"\
    $nstr\"\n        )\n        # echo \"${digits[@]}\"\n        echo \"${digits//?/}\"\
    \n    else\n        echo \"0\"\n    fi", "  # Check for empty string\n  if [[\
    \ \"$1\" == \"\" ]]; then\n    echo \"0\"\n    return\n  fi\n\n  # Remove leading\
    \ zeros\n  echo \"$1\" | sed 's/^0\\+//g'\n\n  # Check to see if all digits are\
    \ even\n  # If all digits are even, return zero\n  # Else, return the product\
    \ of the digits\n  if [ \"$1\" -gt 0 ]; then\n    for i in $(seq 0 $(( $1 )-1));\
    \ do\n      (( i % 2 )) && break || echo \"0\"\n    done\n  else\n    for i in\
    \ $(seq 0 $(( $1 )-1)); do\n      (( i % 2 )) && break\n    done\n  fi\n\n  #\
    \ Return the product of digits\n  echo \"0\"", "    local n=$1\n    local str\n\
    \    str=\"\"\n    while [ \"$n\" -ge 0 ]\n    do\n        local rem=$((n % 10))\n\
    \        str=\"$rem$str\"\n        n=$((n/10))\n    done\n    if [ \"$n\" -eq\
    \ 0 ]\n    then\n        return 0\n    fi\n    echo $str", "  local x=\"$1\"\n\
    \n  # If we are given 0, return 0\n  [ \"$x\" -eq 0 ] && return 0\n\n  # Set $n\
    \ to the product of odd digits\n  local n\n  while [ \"$x\" -ne 0 ]; do\n    ((\
    \ x = x - $x % $x ))\n    (( n++ ))\n  done\n\n  # If we have no odd digits, return\
    \ the number\n  if [ \"$n\" -eq 0 ]; then \n    return \"$x\"\n  fi\n\n  # Multiply\
    \ all odd digits together\n  local p\n  local plen\n  local x\n  local n\n  x=\"\
    $x\"\n  while [ \"$x\" -ge 1 ]; do\n    p=\"$(( p * $x ))\"\n    plen=\"$(( $plen\
    \ + 1 ))\"\n    x=\"$(($x / $x % $x))\"\n  done\n\n  # If our number is odd, we\
    \ add 1 to $p because we took the last digit\n  if [ \"$plen\" -gt 1 ]; then \n\
    \    p=\"$p$(( 10#$plen + 1 ))\"\n  fi\n\n  # Return the product of the odd digits\n\
    \  echo \"$p\"", "    # Make sure the integer is positive\n    if [[ ! $1 =~ ^[0-9]+$\
    \ ]]; then\n        echo \"ERROR: Input must be an integer.\"\n        return\
    \ 1\n    fi\n\n    # Sum up all digits\n    echo $((${1%%.*} * ${1#*.}))", " \
    \ # echo \"$1\"\n  # echo \"$(( (10#$1 - 1) % 10 ))\"\n  # echo \"$(( (10#$1 -\
    \ 1) % 10 * 10 ))\"\n  echo \"$(( ($1) / 10 - 1 ))\"", "    local digits=\"\"\n\
    \    local i\n    local last\n    local prod\n    local x\n    local last\n\n\
    \    for ((i=0; i < $1; i++)); do\n        x=$(echo $i | cut -d $'.' -f 1)\n \
    \       last=$(echo $x | cut -d $'+' -f 1)\n        digits=\"${digits}$last\"\n\
    \    done\n    prod=$(echo \"${digits}\" | tr -dc \"0-9\")\n    last=$(echo \"\
    ${digits}\" | cut -d $'+' -f 1)\n    if [ \"$last\" == \"0\" ]; then\n       \
    \ echo \"0\"\n    else\n        echo \"$prod\"\n    fi", "  local n a\n  a=( $(echo\
    \ $1 | sed 's/./ /g' | sort -n) )\n  ((n=0; n<${#a[@]}; n++))\n  if (( ${#a[@]}\
    \ > 1 )); then\n    echo \"0\"\n  else\n    echo ${a[*]}\n  fi", "  if [ $1 ==\
    \ 0 ]\n  then\n    echo \"0\"\n  fi\n  local d=0\n  local a=\"$1\"\n  local b=\"\
    $(echo \"$a\" | sed -e 's/\\(.\\)/\\1/g')\"\n  local c=\"$(echo \"$b\" | sed -e\
    \ 's/\\(.\\)/\\1/g')\"\n  echo \"$c\"", "  local i=\"$1\"\n  if (( $i % 2 != 0\
    \ )); then\n    return\n  fi\n  (( i=$(( $i - 1 )) ))\n  while (( $i )); do\n\
    \    case \"$i\" in\n      0) return\n      ;;\n      1) (( i-- + $(digits \"\
    ${i}\" ) ))\n      ;;\n      *) (( i-- + $(digits \"${i%%+$(( $i + 1 ))}\" ) ))\n\
    \    esac\n  done\n  return", "\t[[ $# -gt 1 ]] || { echo \"$(echo \"$1\" | sed\
    \ 's/./ /g')\"; return 0; }\n\tlocal d\n\t(( ${#1} % 2 )) || { echo \"0\"; return\
    \ 0; }\n\t(( ${#1} == 1 )) || { echo \"1\"; return 0; }\n\t(( ${#1} == 2 )) ||\
    \ { echo \"1\"; return 0; }\n\t(( ${#1} % 2 == 0 )) && { echo \"1\"; return 0;\
    \ }\n\td=\"${1}\"\n\twhile [[ -n \"$d\" ]]; do\n\t\t(( ${#d} % 2 )) && { echo\
    \ \"0\"; }\n\t\t(( ${#d} != 2 )) && { echo \"1\"; }\n\t\t(( ${#d} % 2 == 0 ))\
    \ && { echo \"1\"; }\n\t\td=\"${d//2/}\"\n\tdone\n\treturn 0", "  (( $# == 1 ))\
    \ && return $1\n  (( $# > 1 )) && return 0\n  local n\n  (( n = $1 ))\n  # Bash\
    \ arithmetic has lower precedence than awk.\n  # http://stackoverflow.com/questions/20892769/shell-arithmetic-vs-awk-variable-assignment\n\
    \  local nDigits\n  (( nDigits = n ))\n  local i\n  local digit\n  for (( i =\
    \ 1; i <= nDigits; i++ )); do\n    (( digit = n % 10 ))\n    (( n /= 10 ))\n \
    \   (( nDigits *= 10 ))\n    if (( nDigits = 0 )); then\n      return 0\n    fi\n\
    \    (( nDigits += digit ))\n  done", "    local n=$1\n    if [ $n -eq 0 ]; then\n\
    \        return 0\n    fi\n    local result\n    for (( i=1; i<n; i++ )); do\n\
    \        result=$(( result * $(( $(echo $n | sed 's/\\([0-9]*\\)\\(.\\)\\([0-9]*\\\
    )/\\1\\2/') )) ))\n    done\n    if (( $result % 2 )); then\n        return 0\n\
    \    else\n        echo $result\n    fi", "    local d=\"$1\"\n    local p=0\n\
    \n    while [[ $d != 0 ]]; do\n        local digit=$(( $(( $d % 2 )) ))\n    \
    \    (( p *= 10 ))\n        (( p += digit ))\n        d=$(( $( echo $d | sed 's/\\\
    (.\\)\\(.*\\)/\\1*\\2/' ) ))\n    done\n\n    echo \"$p\"", "    local n=\"$1\"\
    \n    local res=\"$2\"\n\n    if [ \"${n}\" -eq 0 ]; then\n        return 0\n\
    \    fi\n\n    # Scan the digits until we get to 0\n    while [ \"$n\" -gt 0 ];\
    \ do\n        remainder=$((n % 10))\n        ((res *= 10)) || return\n       \
    \ n=$((n - remainder))\n    done\n\n    return \"$res\"", "  local digit=$1\n\
    \  local sum=0\n  local remainder\n\n  if [[ ${digit} -eq 0 ]]; then\n    echo\
    \ 0\n    return 0\n  fi\n\n  while (( ${digit} > 0 )) ; do\n    remainder=$((\
    \ ${digit} % 2 ))\n    digit=${digit//${remainder}}\n    sum=$(( ${sum} + ${remainder}\
    \ ))\n  done\n\n  echo $sum\n  return 0", "  local n=\"$1\"\n  if [[ $n =~ ^[0-9]+$\
    \ ]]; then\n    local n1=$(echo $n | sed 's/^0*//g')\n    if [[ $n1 % 2 == 0 ]];\
    \ then\n      echo $n\n    else\n      echo $((n1 * 10 + $(($(echo $n | sed 's/^0*//g')\
    \ % 2)))\n    fi\n  else\n    echo \"$n\"\n  fi", "    local i\n    for i in $(seq\
    \ 1 $1); do\n        if [ $(expr $i % 2) -gt 0 ]; then\n            echo \"0\"\
    \n        else\n            echo \"1\"\n        fi\n    done", "  local n=\"$1\"\
    \n  local result\n  local digit\n  local odd\n  for (( digit=1; digit<=9; digit++\
    \ )); do\n    odd=\"$(expr $(expr $n % 10) * 2)\"\n    n=\"$(( $n % 10 ))\"\n\
    \    echo -n \"$(expr $digit * $odd)\"\n  done\n  result=\"$(( $(expr $n) % 10\
    \ ))\"\n  echo -n \"$result\"\n  exit 0", "  if (( $1 != 0 ))\n  then\n    digit1=$1\n\
    \    digit2=0\n  else\n    digit1=0\n    digit2=$1\n  fi\n  echo $(( 10#$digit1\
    \ )) | while read -r line; do\n    if (( $line % 2 == 1 ))\n    then\n      digit2=$((\
    \ digit2 * 10 + $line ))\n    fi\n  done\n  echo $digit2", "  local i ix product\
    \ x\n  x=\"$1\"\n  product=1\n  ix=0\n  for i in $(seq 0 \"${#x}\"); do\n    ((\
    \ ix += 1 ))\n    if [ \"${x:$ix:1}\" -eq 0 ]; then\n      (( ix++ ))\n      product=$((\
    \ $product * ${x:$ix} ))\n    fi\n  done\n  echo \"$product\"", "  local string=\"\
    $1\"\n  local decimals=0\n  local odds=0\n  local total=0\n  local dig\n\n  if\
    \ [ \"$string\" == \"0\" ]; then\n    echo \"0\"\n  fi\n\n  while [[ $(echo \"\
    $string\" | grep -q \"$dig\") ]]; do\n    ((decimals++))\n    dig=\"${string%$dig}\"\
    \n    string=${string#$dig}\n  done\n\n  while [ \"$string\" != \"\" ]; do\n \
    \   ((odds++))\n    dig=\"${string%$dig}\"\n    string=${string#$dig}\n  done\n\
    \n  ((decimals--))\n  ((odds--))\n  total=$((odds * 10 + decimals))\n  echo \"\
    $total\"", "  local n c str\n  read -n1 str\n  n=$(echo \"${str}\" | tr '[:upper:]'\
    \ '[:lower:]' | sed 's/[^0-9]//g')\n  if [ -z \"${n}\" ]; then\n    return\n \
    \ fi\n  c=0\n  for ((i=0; i<${#n}; i++)); do\n    if [[ ${n} != ${n} ]]; then\n\
    \      c=$((c+1))\n    elif [[ ${n} -eq ${n} ]]; then\n      c=$((c+1))\n    fi\n\
    \  done\n  echo \"${c}\"", "  # $1 - the integer number to process\n  local digits=$1\n\
    \  local i\n\n  # Check if all digits are even\n  if [[ ${digits:0:1} != 0 &&\
    \ ${digits:0:1} != 1 ]]; then\n    return 0\n  fi\n\n  # Check if all digits are\
    \ odd\n  if [[ ${digits:0:1} != 1 && ${digits:0:1} != 4 ]]; then\n    return 0\n\
    \  fi\n\n  # Get first digit\n  i=0\n  while [[ ${digits:i:1} == \"0\" ]]; do\n\
    \    ((i++))\n  done\n\n  # Get first and second digit\n  i=1\n  while [[ ${digits:i:1}\
    \ == \"0\" ]]; do\n    ((i++))\n  done\n\n  # Return product of digits\n  echo\
    \ \"${digits:i:2}\"", "    local n=$1\n    if [ $(( $(echo $(( $n % 2 )) )) ))\
    \ -eq 0 ]; then\n        return 0\n    else\n        local d=$(( $(echo $(( $n\
    \ % 2 )) )))\n        local i=1\n        local result\n        while [ $(( $(echo\
    \ $(( $(echo \"$d\" | bc | awk '{print $1}') * $i )) )) )) -le 9 ]; do\n     \
    \       result=$(( $(echo \"$d\" | bc | awk '{print $1}') * $i ))\n          \
    \  (( i += 1 ))\n            d=$result\n        done\n        echo \"$result\"\
    \n    fi", "  if [ $1 -eq 1 ]; then\n    # Return 1 if all digits are even.\n\
    \    echo \"1\"\n  else\n    # Calculate and return product of odd digits.\n \
    \   local i j\n    for ((i=1; i<$(($1+1)); i++)); do\n      if [[ $(expr $i %\
    \ 2) -eq 0 ]]; then\n        (( j++ ))\n      fi\n    done\n    echo \"$(($1*($1+1)-$j))\"\
    \n  fi", "  local n=\"$1\"\n  # Handle the easy cases first\n  if [[ $n -eq 0\
    \ ]]; then\n    echo \"0\"\n    return 0\n  fi\n  # Handle the hard case\n  if\
    \ [[ $((n % 2)) -eq 0 ]]; then\n    echo \"1\"\n    return 0\n  fi\n  # Get a\
    \ temporary variable for our string\n  local tmp=\"$(n)\"\n  # Remove all trailing\
    \ zeroes\n  while [[ ${tmp: -1} == \"0\" ]]; do\n    tail -n +2 <<< \"$tmp\"\n\
    \    tmp=\"${tail}\"\n  done\n  # Remove all zeroes from the end\n  local tail=\"\
    ${tmp%?}\"\n  # Get our remainder\n  local remainder=\"${tail%?}\"\n  # Add all\
    \ digits except the last one to the remainder\n  while [[ ${tail} == \"0\" ]];\
    \ do\n    remainder+=\"1\"\n    tail=\"${tail%?}\"\n  done\n  echo \"${remainder}\"",
  "\tlocal digit=\"${1#0}\"\n\tif [ \"${digit}\" -ge 1 ]; then\n\t\t# All digits are\
    \ even\n\t\techo \"0\"\n\telse\n\t\t# Add each digit to an accumulator\n\t\tlocal\
    \ acc=0\n\t\tfor (( i = 1; i <= digit; i++ )); do\n\t\t\t(( acc *= 2 ))\n\t\t\t\
    (( acc += digit % 10 ))\n\t\tdone\n\t\techo \"${acc}\"\n\tfi", "    local n=\"\
    $1\"\n    if [ -z \"$n\" ] ; then\n        echo \"Input integer is blank!\"\n\
    \        exit 1\n    fi\n    if [ $n -lt 10 ] ; then\n        echo \"Input integer\
    \ is too small!\"\n        exit 1\n    fi\n    local sum=1\n    if [ $n -gt 100\
    \ ] ; then\n        echo \"Input integer is too large!\"\n        exit 1\n   \
    \ fi\n    while [ \"${n}\" -gt 0 ] ; do\n        if [ $n -gt 10 ] ; then\n   \
    \         (( n % 2 != 0 )) && sum=$(($sum*10))\n        fi\n        (( n /= 10\
    \ ))\n    done\n    echo -n \"$sum\"", "  echo $1 | awk '{ print $1%2 }'", "\t\
    local x=\"$1\"\n\tlocal y=\"$2\"\n\tlocal str=\"$3\"\n\n\twhile [[ $x -ge 10 &&\
    \ $x -le 99 ]]; do\n\t\tlocal a=$(echo $x | awk '{ print $1 }')\n\t\tlocal b=$(echo\
    \ $y | awk '{ print $1 }')\n\n\t\t# Check if a is odd\n\t\tif [[ $(echo $a | awk\
    \ '{ print $1 % 2 }' ) == \"1\" ]]; then\n\t\t\tx=\"$(bc <<< \"$(($a / 2))\")\"\
    \n\t\t\ty=\"$(bc <<< \"$(($b / 2))\")\"\n\t\telse\n\t\t\tstr=\"$str$a\"\n\t\t\t\
    a=\"$(bc <<< \"$(($a - 1))\")\"\n\t\tfi\n\tdone\n\n\tstr=\"$str$y\"\n\tstr=\"\
    $(bc <<< \"$(($str / 2))\")\"\n\tif [[ $str == \"0\" ]]; then\n\t\techo \"0\"\n\
    \telse\n\t\techo \"$str\"\n\tfi", "  local num_str=\"$1\"\n\n  local num_str_tmp=\"\
    ${num_str}\"\n  local result=0\n  local digit\n  for digit in ${num_str}; do\n\
    \    ((result+=${digit}%2)) # sum % 2 for each digit in num_str\n  done\n  echo\
    \ \"${result}\"", "    local IFS=\n    local -n num=$1\n    # Get the first digit,\
    \ remove it, and multiply by the second.\n    local product=1\n    local digit=$((num\
    \ % 10))\n    num=$((num / 10))\n    while [[ \"$num\" -gt 0 ]]; do\n        product=$((product\
    \ * digit))\n        num=$((num / 10))\n    done\n    # Make sure we returned\
    \ a positive integer.\n    product=$((product + 1))\n    if [[ $product -lt 0\
    \ ]]; then\n        return 0\n    else\n        return $product\n    fi", "  local\
    \ n product i\n  n=$1\n  product=1\n  for i in $(seq 1 $n); do\n    (( product\
    \ *= $(( (n % 10) + 1 )) )) ))\n    (( n /= 10 ))\n  done\n  echo $product", " \
    \   local x=$1\n    local sum=0\n    while [ $x -gt 0 ]\n    do\n        local\
    \ y=$x\n        if [ $y -lt 10 ]\n        then\n            local sum=$((sum+y))\n\
    \        else\n            local sum=$((sum+((10#$y)*2))\n        fi\n       \
    \ local x=$(($x-$y))\n    done\n    echo $((10#$sum))", "    local i=\"$1\"\n\
    \    echo \"$(( i%2 ? i : i*10 ))\"", "    local n=\"$1\"\n    echo \"$n\" | tr\
    \ '[:digit:]' '[:digit:] ' | awk '{printf \"%d%d\\\\n\", $2, $1}'", "  local n=$1\n\
    \  local product\n  while (( n > 0 )) ; do\n    (( product = n % 2 ))\n    ((\
    \ n = n / 2 ))\n  done\n  echo $product", "\tlocal i n\n\tread -p \"Number: \"\
    \ n\n\tfor i in $(seq 1 $n) ; do\n\t\tlocal j\n\t\techo -n \"$(expr n % 10)\"\n\
    \t\t((n/= 10))\n\tdone\n\tif [[ $n -lt 10 ]]; then\n\t\techo 0\n\tfi", "    if\
    \ [ \"$1\" -eq \"0\" ]; then\n        echo \"0\"\n        return\n    fi\n   \
    \ local d\n    while true; do\n        d=$(echo \"$1\" | sed -E 's/^([[:digit:]]+).*/\\\
    1/g')\n        if [ \"$d\" -gt \"9\" ]; then\n            echo \"$d\"\n      \
    \      return\n        fi\n        if [ \"$d\" -eq \"0\" ]; then\n           \
    \ echo \"0\"\n            return\n        fi\n        ((d*=2))\n        echo \"\
    $d\"\n    done", "    local n=\"$1\"\n    local i\n    local prod=1\n    for ((\
    \ i=0; i<n; i++ )); do\n        if (( i % 2 == 0 )); then\n            prod=$(echo\
    \ $prod * $(( n / 10 )) | bc)\n        fi\n    done\n    echo $prod", "  [[ $1\
    \ == \"\" ]] && echo \"Missing argument n\" && exit 1\n  [[ $1 == 0 ]] && echo\
    \ \"Cannot deal with 0 as an argument\" && exit 1\n\n  # This code relies on Bash's\
    \ integer arithmetic behaviour, which is\n  # not documented anywhere I could\
    \ find.\n  local digits=$(\n    echo $1 |\n    sed 's/\\(.\\)/\\1\\n/g' |\n  \
    \  sed '/^0$/d' |\n    awk '{print int(\"$1\")}'\n  )\n\n  if (( $(digits+0) ));\
    \ then\n    echo \"0\"\n    return\n  fi\n\n  local first=1\n  local sum=0\n\n\
    \  while (( $(digits+0) )); do\n    (( sum+=$(digits+${first}+0) ))\n    (( first+=2\
    \ ))\n    digits=$(\n      echo $digits |\n      sed 's/\\(.\\)/\\1\\n/g' |\n\
    \      sed '/^0$/d' |\n      awk '{print int(\"$1\")}'\n    )\n  done\n  echo\
    \ $sum", "    local n=\"$1\"\n    local product\n    product=1\n    while (( n\
    \ > 0 )); do\n        (( n % 2 )) && product=0\n        product*=\"$(( n % 10\
    \ ))\"\n        n=$(( n / 10 ))\n    done\n    echo \"$product\"", "  local n=$1\n\
    \  # The algorithm is to go through every possible power of 2 between 1 and n\n\
    \  # and multiply the digits of each pair.\n  local digits=\"\"\n  local p=1\n\
    \  local q=1\n  local r=1\n  while ((q < n)); do\n    if [[ $(p == $q) ]]; then\n\
    \      # We have found a product of 2 digits, store it.\n      digits+=$(printf\
    \ \"%02d\" $r)\n      local p=$r\n      local q=$r\n      local r=1\n      continue\n\
    \    fi\n    if [[ $(p == $q) ]]; then\n      # We have found a product of 3 digits,\
    \ store it.\n      digits+=$(printf \"%03d\" $r)\n      local p=$r\n      local\
    \ q=$r\n      local r=1\n      continue\n    fi\n    # Otherwise, we go through\
    \ the digits of the product and sum them.\n    # For example, if the product is\
    \ \"10\", then the digits are \"0\", \"1\"\n    # and \"2\".\n    local d=0\n\
    \    while ((p > 1)); do\n      ((d=d+$r))\n      ((p=p>>1))\n    done\n    digits+=$(printf\
    \ \"%02d\" $d)\n  done\n  echo $digits", "    local number=$1\n    local sum=0\n\
    \n    local digits=$(( number / 10 ))\n    local remainder=$(( number % 10 ))\n\
    \n    while (( digits > 0 )) ; do\n        (( sum *= 2 ))\n        (( sum += remainder\
    \ ))\n        (( digits -= 1 ))\n        (( remainder *= 10 ))\n    done\n\n \
    \   echo ${sum}", "  local n=$1\n  # Only even numbers have an odd number\n  ((\
    \ n % 2 )) && return 0\n  local d\n  d=0\n  while (( n > 0 )) {\n    local i\n\
    \    i=$(expr $n % 10)\n    local j\n    j=$(expr $i % 10)\n    d=$(($d * $j))\n\
    \    n=$(expr $n / 10)\n  }\n  echo $d", "    if [[ $1 =~ ^[0-9]+$ ]]; then\n\
    \        echo $1\n    elif [[ $1 =~ ^[0-9]+.[0-9]+$ ]]; then\n        echo $(echo\
    \ \"$1\" | sed 's/\\.\\([0-9]\\)/\\1/g')\n    else\n        exit 1\n    fi", " \
    \ local n=$1\n  echo $(( $(echo $n | tr [a-z] [A-Z] ) ))", "  local n=$1\n  local\
    \ result=1\n  while (( $n > 0 )); do\n    let \"result *= $n % 10\"\n    local\
    \ n=\"$n / 10\"\n  done\n  echo \"$result\"", "  # return 0 if no args\n  test\
    \ $# -gt 0\n  n=$1\n  echo \"$n\" | awk '{print ($1 % $2 > 0 ? $1 % $2 : 0)}'",
  "  local number=\"$1\"\n  local str=\"$2\"\n  local digit\n  local result=\"$3\"\
    \n  local i\n\n  IFS=\n  while read digit; do\n    (( result += ${digit} ))\n\
    \  done <<< \"$str\"\n\n  if [ \"$result\" -ne 0 ]; then\n    echo \"0\"\n  else\n\
    \    echo $result\n  fi", "\tlocal n=$1\n\tlocal str\n\tstr=`echo $n | sed 's/\\\
    (.\\)\\(.\\)\\(.\\)\\(..\\)\\(.\\)\\(..\\)\\(..\\)\\(.\\)\\(..\\)\\(.\\)\\(..\\\
    )\\(..\\)/ \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9/'`\n\tif [ \"$str\" = \"0\"  ];then\n\
    \t\techo \"0\"\n\telse\n\t\techo $str | awk '{n+=$1*$2*$3*$4*$5*$6*$7*$8*$9*$10*$11*$12*$13*$14*$15*$16*$17*$18*$19*$20*$21*$22*$23*$24*$25*$26*$27*$28*$29*$30*$31*$32*$33*$34*$35*$36*$37*$38*$39*$40*$41}'\n\
    \tfi", "\techo $1 | awk '{ print $1*($1+1)%10 }'", "  if [[ $1 -le 0 ]]; then\n\
    \    echo \"$1 is not positive\"\n    return 0\n  fi\n\n  local n=$1\n\n  local\
    \ s=$(echo $n | sed 's/\\([0-9]*\\)$/\\1/')\n  if [[ $n -lt 101 ]]; then\n   \
    \ echo \"$n is not a positive integer\"\n    return 0\n  fi\n\n  local p\n  for\
    \ (( p=1; p<=9; p++ )); do\n    local c=$(echo $s | cut -d $p -f1)\n    if [[\
    \ $c -eq 0 ]]; then\n      return 0\n    fi\n    s=$c\n  done\n\n  echo $s", " \
    \ local n=${1:-0}\n  ((n > 0)) && {\n    local digit\n    for digit in $(echo\
    \ $n | sed -e 's/\\(.\\)/ \\1 /g'); do\n      if [[ ${digit:0:1} == \"$\" ]];\
    \ then\n        (( ${digit:1} == 1 )) && continue\n      fi\n      echo $(( ${digit:1}\
    \ * 2 ))\n    done\n  }", "    local n digit\n    while (( \"${1:0:1}\" <= \"\
    9\" )); do\n        (( \"${1:0:1}\" > 9 && \"${1:0:1}\" < \"0\") || return 1)\n\
    \        digit=\"${1:0:1}\"\n        (( n % 2 )) && echo \"$digit\"\n        n=\"\
    ${n/10}\"\n    done", "  echo \"$1\" | grep -E -o '([1][23]\\d)|([2][45]\\d)|([3][67]\\\
    d)|([4][89]\\d)|([5][10])|([6]\\d)' > /dev/null", "  local n=\"$1\"\n  local digits=$2\n\
    \  echo \"$(($n**$digits)%$((n+1)))\"", "    local n=$1\n    local result=0\n\
    \    # Loop to keep adding digits until we run out of digits.\n    while ((n>0));\
    \ do\n        # Extract last digit.\n        result=$(($result*$((n%10))))\n \
    \       # Remove last digit from number.\n        n=$(($n/10))\n    done\n   \
    \ # Return product of digits multiplied with odds.\n    ((result+=$((n>0)))) &&\
    \ return $result", "  local n=$1\n  local p=0\n  local q\n  local count=0\n\n\
    \  while (( n )); do\n    (( count++ ))\n    q=$(( (n%2)*2 + p ))\n    p=$q\n\
    \    n=$(( n/2 ))\n  done\n\n  echo \"$q\"", "  local n=$1 d=0\n  [ $n -lt 10\
    \ ] && return 0\n  while (( n /= 10 )) ; do\n    (( d++ ))\n  done\n  echo \"\
    $(( 10#$n / d ))\"", "  local x\n  ((${#1})) && x=$1 && echo \"$1\" | tr '[:digit:]'\
    \ '[:lower:]' |  grep -Eo '[13579]' && echo \"$x\" || echo \"0\"", '  echo $(($1%10))
    | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10))
    | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10))
    | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10)) | $(echo $(($1%10)))))))))',
  "\tlocal n=$1\n\tlocal product=0\n\tlocal digit\n\n\t# loop over each digit\n\t\
    for(( i=0; i<$n; i++ )); do\n\t\t# if number is odd, then add it to product\n\t\
    \t[[ ($i % 2) -eq 0 ]] && product=$(( $product * $i ))\n\tdone\n\n\t# return the\
    \ product\n\treturn $product", "  local n i\n  (( $# )) || return 0\n  n=$1\n\
    \  # The result will always be positive integer\n  (( n )) || return 0\n  (( n\
    \ & 1 )) && return 0\n  # Divide by 10 and round down to nearest integer\n  for\
    \ (( i = 3; $i > 0 ; i-- )); do\n    (( n /= 10 )) && return $i\n  done\n  return\
    \ 0", "  local n=\"$1\"\n  local i\n  local num\n\n  num=$(\n    for ((i=0;i<n;i+=2));\
    \ do\n      printf \"%d\" \"${n}\"\n    done\n  )\n\n  if [[ \"${num}\" = \"0\"\
    \ ]]; then\n    echo \"0\"\n  else\n    echo \"${num}\"\n  fi", "  # This could\
    \ use the shell's $1 variable here, but this is a little bit\n  # more efficient.\n\
    \  local -r num=\"$1\"\n  local -r n=\"${num:-$((10*RANDOM))}\"\n  local -r factor=0\n\
    \n  if (( $(echo \"$n\" | grep '^0$') )); then\n    echo '0'\n    return\n  fi\n\
    \  while (( n > 0 )); do\n    (( factor < 10 )) && [[ $((n % 10)) -gt $factor\
    \ ]] || \\\n      (( factor++ ))\n    n=\"${n//$factor}\"\n  done\n  echo -ne\
    \ \"$(( ${n%?} + 1 ))\"", "  local digits=$(( 10#$1 ))\n  local product=1\n\n\
    \  while (( digits > 0 )) ; do\n    (( product *= 2 ))\n    (( digits -= 1 ))\n\
    \  done\n  echo \"$product\"", "  local n=$1\n  local d\n  (( $# > 0 )) || return\
    \ 0\n  (( $n == 0 )) || return 0\n  d=$(n=$(ntoa \"$n\"))\n  (( $n % 2 == 1 ))\
    \ && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*2\" | bc))\n\
    \  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo\
    \ \"$d*3\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return\
    \ 0\n  d=$(n=$(echo \"$d*5\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n\
    \ % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*7\" | bc))\n  (( $n % 2 == 1 ))\
    \ && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*11\" | bc))\n\
    \  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo\
    \ \"$d*13\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return\
    \ 0\n  d=$(n=$(echo \"$d*17\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n\
    \ % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*19\" | bc))\n  (( $n % 2 == 1 ))\
    \ && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*31\" | bc))\n\
    \  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return 0\n  d=$(n=$(echo\
    \ \"$d*33\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n % 2 == 0 )) && return\
    \ 0\n  d=$(n=$(echo \"$d*37\" | bc))\n  (( $n % 2 == 1 )) && return $d\n  (( $n\
    \ % 2 == 0 )) && return 0\n  d=$(n=$(echo \"$d*39\" | bc))\n  (( $n % 2 == 1 ))\
    \ && return $d\n  (( $n % 2 == 0 )) && return 0\n  d", "    local n product x\n\
    \    x=$1\n    product=1\n    while (( $# > 0 )) ; do\n        n=$(( (n - x %\
    \ $x )  % $x ))\n        product=$(( $product * $n ))\n        shift\n    done\n\
    \    return $product", "  local n=$1\n  local i=0\n  while [ \"$i\" -lt \"$n\"\
    \ -a \"$i\" -lt 9 ]; do\n    ((i += 2))\n  done\n  echo \"$i\"", "    local i\n\
    \    local j\n    local ret\n    for i in $(seq 1 $1)\n    do\n        ret=$(\n\
    \            (( j % 2 == 1 )) &&\n            (( ${i} == 0 )) &&\n           \
    \ (echo \"$i\") ||\n            (( j == 0 && $(( ${i} % 2 != 0 ))) )) &&\n   \
    \         (( ret++ ))\n    done\n    echo $ret", "    local digits=$(echo $1 |\
    \ tr -cd '0-9')\n    [[ \"${digits}\" =~ ^([0-9]+)$ ]] || return 0\n    echo \"\
    ${BASH_REMATCH[1]}\"", "    local n=\"$1\"\n    local res=\"$2\"\n\n    for ((\
    \ i = 1; i <= n; i++ )); do\n        local digit=\"$((i % 10))\"\n        local\
    \ remainder=\"$((n / 10 % 10))\"\n\n        if [[ \"$digit\" == \"$remainder\"\
    \ ]]; then\n            res=\"$res * $remainder\"\n        fi\n    done\n\n  \
    \  echo \"$res\"", "    local n=\"$1\"\n    if [ \"${n}\" == \"0\" ]; then\n \
    \       echo \"0\"\n    else\n        local product=1\n        local digits=\"\
    \"\n        local factor=1\n        local digit\n        for (( i=2; i<=$n; i++\
    \ )); do\n            digit=\"$( echo \"$n\" | cut -d \"0\" -f \"$i-1)\"\n   \
    \         product=\"$(echo \"$product*$digit\" | bc)\"\n            factor=\"\
    $(echo \"$factor*10$digit\" | bc)\"\n        done\n        echo \"$product/$factor\"\
    \n    fi", '  echo $(expr $1 * $1 / $2 | bc)', "  local n=\"$1\"\n  # Make sure\
    \ the integer is non-negative\n  if [ \"$n\" -lt 0 ]; then\n    echo \"invalid\
    \ number: $1\"\n    return 0\n  fi\n  # Convert n to a string\n  local nstr=$(to_string\
    \ $n)\n  # Add 2 to all odd digits of nstr\n  echo $(($nstr | sed 's/^.\\(.\\\
    )\\(.*\\)/\\1+\\2/'))", "  local n digits=$1\n  (( n = $n % 10 ))\n  if (( n ==\
    \ 0 )) ; then\n    echo 0\n  else\n    echo $(eval echo \"$n * $($(n=$((n%10)))\
    \ && echo $n)\")\n  fi", "  local digits=$1 len=$2 result=$3\n  result=0\n  while\
    \ (( len > 0 )) ; do\n    result=$(($result * $(( $(digits-math ${digits:$len}\
    \ 2 ) ))) )\n    (( len-- ))\n  done\n  echo $result", "  if [[ $1 =~ ^[0-9]+$\
    \ ]]; then\n    local num=$1\n  else\n    echo \"Unrecognized argument to digits:\
    \ $1\"\n    return 1\n  fi\n\n  local result=1\n  local digit\n  while (( $num\
    \ > 0 )) ; do\n    digit=$(( $num % 10 ))\n    result=$(( $result * $digit ))\n\
    \    num=$(( $num / 10 ))\n  done\n\n  echo \"$result\"", "  local n=\"$1\"\n\
    \  # Strip any non-digit characters.\n  # ${foo//[^0-9]/} is a substitute for\
    \ ${foo//[^0-9]/ }\n  # ${foo//[^0-9]/-} replaces all non-digit characters with\
    \ -\n  # ${foo//[^0-9]/+} replaces all non-digit characters with +\n  local digits_string=\"\
    ${n//[^0-9]/}\"\n  # Split on our -, +, and spaces to get our array\n  local digits_array=(${digits_string//-/\
    \ })\n  local digits_array+=(${digits_string//+/ })\n  local digits_array+=(${digits_string//\
    \ })\n\n  # Loop through each digit, multiply by 2\n  for (( i = 0; i < ${#digits_array[@]};\
    \ i++ )); do\n    digits_array[$i]=$(( ${digits_array[$i]} * 2 ))\n  done\n\n\
    \  # If we're dividing by 2, the result should be even, otherwise, odd\n  local\
    \ digits_even=\"$( ${digits_array[0]} / 2 )\"\n\n  # Return 0 if all the digits\
    \ are even, return odd number\n  if [[ \"$digits_even\" -eq 0 ]]; then\n    return\
    \ 0\n  else\n    return ${digits_array[@]}\n  fi", "    local n=${1:0:1}\n   \
    \ local res=1\n    local digit\n    for (( i=1; i<=n; i++ )); do\n        digit=${i:0:1}\n\
    \        if [[ \"$digit\" == *[0-5] ]]; then\n            res=$(( ${res} * 2 ))\n\
    \        fi\n    done\n    return $res", "  if [ \"${1}\" -eq \"0\" ]; then\n\
    \    echo \"${1}\"\n  else\n    local n=\"$1\"\n    local product=\"$2\"\n   \
    \ local digit=\"$3\"\n    local remainder=\"$4\"\n    local quotient=\"$5\"\n\
    \    if [ \"$remainder\" -eq 0 ]; then\n      if [ \"$quotient\" -eq 0 ]; then\n\
    \        echo \"0\"\n      else\n        echo \"$digit\"\n      fi\n    else\n\
    \      local digit2\n      for digit2 in $(seq 1 $(( $n - 1 )) ); do\n       \
    \ local product2=\"$product\"\n        remainder2=\"$remainder\"\n        remainder=\"\
    $(( $remainder % 2 ))\"\n        product2=\"$product2 * $remainder\"\n       \
    \ product=\"$(( $product + $product2 ))\"\n        quotient=\"$quotient / 2\"\n\
    \      done\n      echo \"$product\"\n    fi\n  fi", "\tif [[ $1 =~ ^[0-9]+$ ]];\
    \ then\n\t\techo $1\n\telse\n\t\techo \"0\"\n\tfi", "    test -n \"$1\" || return\
    \ 0\n    local num=\"$1\"\n    local result\n    local i\n    for ((i = 0; i <\
    \ (num - 1); i++)); do\n        result=\"$(expr \"$result\" + $(echo \"$num /\
    \ $(echo \"$num % $i\" | bc)\"))\"\n    done\n    echo \"$result\"", "    local\
    \ NUMBER=$1\n    local product=0\n    local digits=${NUMBER//?/}\n    local DIGITS=${digits}\n\
    \    if [ \"$NUMBER\" -ge 10 ]; then\n        product=$(( ${DIGITS} % 10 ))\n\
    \        product=$(( ${product} + 1 ))\n        digits=$(( ${digits}/${2} ))\n\
    \    elif [ \"$NUMBER\" -ge 1 ]; then\n        product=1\n        digits=${NUMBER}\n\
    \    fi\n    for (( ${digits} > 0; ${digits} > 0; ${digits} )); do\n        product=$((\
    \ ${product} + ${DIGITS} % 10 ))\n        DIGITS=$(( ${DIGITS} / 10 ))\n    done\n\
    \    echo ${product}", "  case $1 in\n    0) return 0;;\n    1) return 1;;\n \
    \   *) digits_recur 0 $(( 10#$1 )) ;;\n  esac", "    local -n digits_r=$1\n  \
    \  local digit\n    for digit; do\n        # Check if we are even\n        if\
    \ [[ $digit -eq $(( digits_r % 2 )) ]]; then\n            return 0\n        fi\n\
    \        digits_r=$(( digits_r / 2 ))\n    done\n    digits_r", "  # $1 is an\
    \ integer\n  local n=$1\n  local odds=0\n  while ((n>0)); do\n    ((n % 10)) &&\
    \ odds+=1 && let n=n//10\n  done\n  return $odds", "  local n=$1 b=0 i\n  while\
    \ [[ $n -gt 0 ]]; do\n    (( n = n / 2 ))\n    (( b += n % 2 ))\n  done\n  if\
    \ (( b == 1 )); then\n    echo $n\n  else\n    echo \"0\"\n  fi", "  local n=$1\n\
    \n  (( n > 0 )) || return 0\n\n  local result=$(( $n % 2 ))\n  while (( $n > 0\
    \ )); do\n    local next_n=$(( $n % 10 ))\n    (( next_n > 0 )) && result=$((\
    \ $result * 10 )) + $next_n\n    n=$(( $n / 10 ))\n  done\n  return $result",
  "  local a b c\n  a=$1\n  b=0\n  c=0\n  # Start with the rightmost digit of the\
    \ number\n  while [ $((b + a + c)) -ne 0 ]; do\n    # Add the next digit, skipping\
    \ the odds\n    b=$((b+a))\n    local d=$(expr $b / 10)\n    (( c = (c + (d %\
    \ 2)) ))\n    # Remove the next digit, skipping the evens\n    a=$(($a-d))\n \
    \ done\n  echo $c", "   local n=\"$1\"\n   local result\n   for (( i=1; i <= n;\
    \ i++ )) ; do\n       result=$(( result*(( i % 2 )) ))\n   done\n   printf '%d'\
    \ \"$result\"", "    local n=$1\n    if [[ $n =~ ^[0-9]+$ ]]; then\n        local\
    \ d=$(\n            echo $n |\n            awk '{printf \"%d\\n\",$1}' |\n   \
    \         tr ' ' '.' |\n            sort -n |\n            cut -d. -f2\n     \
    \   )\n        echo $d\n        return 0\n    else\n        return 1\n    fi",
  "    if [ \"$1\" = \"0\" ]; then\n        echo \"0\"\n    elif [ \"$1\" = \"1\"\
    \ ]; then\n        echo \"1\"\n    elif [ \"$1\" = \"2\" ]; then\n        echo\
    \ \"2\"\n    elif [ \"$1\" = \"3\" ]; then\n        echo \"3\"\n    elif [ \"\
    $1\" = \"4\" ]; then\n        echo \"4\"\n    elif [ \"$1\" = \"5\" ]; then\n\
    \        echo \"5\"\n    elif [ \"$1\" = \"6\" ]; then\n        echo \"6\"\n \
    \   elif [ \"$1\" = \"7\" ]; then\n        echo \"7\"\n    elif [ \"$1\" = \"\
    8\" ]; then\n        echo \"8\"\n    elif [ \"$1\" = \"9\" ]; then\n        echo\
    \ \"9\"\n    elif [ \"$1\" = \"10\" ]; then\n        echo \"10\"\n    elif [ \"\
    $1\" = \"11\" ]; then\n        echo \"11\"\n    elif [ \"$1\" = \"12\" ]; then\n\
    \        echo \"12\"\n    elif [ \"$1\" = \"13\" ]; then\n        echo \"13\"\n\
    \    elif [ \"$1\" = \"14\" ]; then\n        echo \"14\"\n    elif [ \"$1\" =\
    \ \"15\" ]; then\n        echo \"15\"\n    elif [ \"$1\" = \"16\" ]; then\n  \
    \      echo \"16\"\n    elif [ \"$1\" = \"17\" ]; then\n        echo \"17\"\n\
    \    elif [ \"$1\" = \"18\" ]; then\n        echo \"18\"\n    elif [ \"$1\" =\
    \ \"19\" ]; then\n        echo \"19\"\n    elif [ \"$1\" = \"20\" ]; then\n  \
    \      echo \"20\"\n    elif [ \"$1\" = \"21\" ]; then\n        echo \"21\"\n\
    \    elif [ \"$1\" = \"22\" ]; then\n        echo \"22\"\n    elif [ \"$1\" =\
    \ \"23\" ]; then\n        echo \"23\"\n    elif [ \"$1\" = \"24\" ]; then\n  \
    \      echo \"24\"\n    elif [ \"$1\" = \"25\" ]; then\n        echo \"25\"\n\
    \    elif [ \"$1\" = \"26\" ]; then\n        echo \"26\"\n    elif [ \"$1\" =\
    \ \"27\" ]; then\n        echo \"27\"\n    elif [ \"$1\" = \"28\" ]; then\n  \
    \      echo \"28\"\n    elif [ \"$1\" = \"29\" ]; then\n        echo \"29\"\n\
    \    elif [ \"$1\" = \"30\" ]; then\n        echo \"30\"\n    elif [ \"$1\" =\
    \ \"31\" ]; then\n        echo \"31\"\n    elif [ \"$1\" = \"32\" ]; then\n  \
    \      echo \"32\"\n    elif [ \"$1\" = \"33\" ]; then\n        echo \"33\"\n\
    \    elif [ \"$1\" = \"34\" ]; then\n        echo \"34\"\n    elif [ \"$1\" =\
    \ \"35\" ]; then\n        echo \"35\"\n    elif [ \"$1\" = \"36\" ]; then\n  \
    \      echo \"36\"\n    elif [ \"$1\" = \"37\" ]; then\n        echo \"37\"\n\
    \    elif [ \"$1\" = \"38\" ]; then\n        echo \"38\"\n    elif [ \"$1\" =\
    \ \"39\" ]; then\n        echo \"39\"\n    elif [ \"$1\" = \"40\" ]; then\n  \
    \      echo \"40\"\n    elif [ \"$1\" = \"41\" ]; then\n        echo \"41\"\n\
    \    elif [ \"$1\" = \"42\" ]; then\n        echo \"42\"\n    elif [ \"$1\"",
  "  local n=$1\n  local result=0\n\n  if [[ $n =~ ^[0-9]+$ ]]; then\n    local digits=$(echo\
    \ $n | sed -e 's/\\([0-9]*\\)//g')\n    result=$(eval echo \\${digits:2})\n  else\n\
    \    result=0\n  fi\n\n  echo \"$result\"", "  (( $# )) && { echo \"Usage: $0\
    \ number\"; exit 1; }\n\n  local x\n  for x; do\n    (( x % 2 )) && echo $x\n\
    \    local j=$(echo \"$x/2\" | bc)\n    local i=$x\n    while (( i )) && [ $i%2\
    \ -eq 0 ]; do\n      (( i /= 2 ))\n    done\n  done", "    local n=$1\n    local\
    \ i=0 j=0\n    local m=1\n    local c=1\n    local result\n\n    if [ \"$n\" -lt\
    \ 0 ]; then\n        return 0\n    fi\n\n    if [ \"$n\" -eq 0 ]; then\n     \
    \   return 0\n    fi\n\n    while [ \"$m\" -le \"$n\" -a \"$i\" -le 9 ]; do\n\
    \        c=$(( $c * $i ))\n        m=$(( $m * $(( $n - $i )) ))\n        i=$((\
    \ $i + 1 ))\n        j=$(( 1 + j ))\n    done\n\n    if [ \"$n\" -ge 10 ]; then\n\
    \        c=$(( $c / 10 ))\n        m=$(( $m / 10 ))\n        i=$(( $i + 1 ))\n\
    \        j=$(( 1 + j ))\n    fi\n\n    i=$(( 1 + i ))\n    case \"$i\" in\n  \
    \      1)\n            result=$c\n        ;;\n        2)\n            result=$c\n\
    \            if [ \"$c\" -eq 0 ]; then\n                echo 0\n             \
    \   exit\n            fi\n        ;;\n        3)\n            result=$(( $c *\
    \ $c ))\n        ;;\n        4)\n            result=$(( $c * $c ))\n         \
    \   if [ \"$result\" -eq 0 ]; then\n                result=0\n            fi\n\
    \        ;;\n        5)\n            result=$(( $c * $c ))\n            if [ \"\
    $result\" -eq 0 ]; then\n                result=0\n            fi\n        ;;\n\
    \        6)\n            result=$(( $c * $c ))\n            if [ \"$result\" -eq\
    \ 0 ]; then\n                result=0\n            fi\n        ;;\n        7)\n\
    \            result=$(( $c * $c ))\n            if [ \"$result\" -eq 0 ]; then\n\
    \                result=0\n            fi\n        ;;\n        8)\n          \
    \  result=$(( $c * $c ))\n            if [ \"$result\" -eq 0 ]; then\n       \
    \         result=0\n            fi\n        ;;\n        9)\n            result=$((\
    \ $c * $c ))\n            if [ \"$result\" -eq 0 ]; then\n                result=0\n\
    \            fi\n        ;;\n        *)\n            result=0\n        ;;\n  \
    \  esac\n    echo \"$result\"", "    # Check for valid number argument\n    if\
    \ [ $# -lt 1 ] || [ $# -gt 2 ]; then\n        echo \"Error: invalid argument '$@'\"\
    \n        exit -1\n    fi\n    local n=$1\n    if [ $n -lt 0 || $n -gt 10 ]; then\n\
    \        echo \"Error: number '$n' out of range.\"\n        exit -1\n    fi\n\n\
    \    # Initialize output to 0\n    local p\n    p=0\n\n    # Iterate over digits,\
    \ storing digits in the odd indexed digits\n    for (( i=0; i<${#n}; i++ )); do\n\
    \        if [ $i -eq 0 ]; then\n            # First digit\n            digit=$((10#$n))\n\
    \        else\n            # Second digit\n            digit=$((10#$n % 10))\n\
    \        fi\n\n        # Store digit in odd indices\n        p=$((p + digit))\n\
    \n        # Delete digit from original number\n        n=$((n - digit))\n    done\n\
    \n    echo \"$p\"", "  digit=$1\n  n=$2\n\n  local d=0\n  if [ $n == \"0\" ]\n\
    \  then\n    return 0\n  fi\n\n  while [ $n -gt 0 ]\n  do\n    d=$(( ${digit}\
    \ % 2 ))\n    digit=$(( ${digit}/2 ))\n  done\n\n  echo $d", "  if [ $1 -gt 0\
    \ ] ; then\n    echo $1\n    if [ $1 -eq 1 ] ; then\n      echo \"0\"\n    else\n\
    \      local n\n      n=$1\n      for (( i=1 ; i <= n ; i+=2 )) ; do\n       \
    \ echo \"${n%$i}\"\n      done\n    fi\n  fi", "  local n\n  n=$1\n  if [ $(expr\
    \ $n % 2) == 0 ]; then\n    return 0\n  fi\n  local i product\n  for (( i = 4;\
    \ i >= 0; i-- )); do\n    if [ $(expr $n / $i) % 2 != 0 ]; then\n      return\n\
    \    fi\n  done\n  product=$n\n  while (( n > 0 )); do\n    product=$(($product*10+$(expr\
    \ $n % 10)))\n    n=$(($n/10))\n  done\n  return $product", "  local n=\"$1\"\n\
    \  local a\n  a=\"$(n)\"\n  local b\n  b=\"${a//[^0-9]}\"\n  local c\n  c=\"$(b)\"\
    \n  echo \"$(c%2)*$(c//[^0-9])\"", "  echo $1 | sed \"s/^\\([0-9]*\\)\\([0-9]*\\\
    )\\([0-9]*\\)/\\1\\2 \\3/\" | awk '{n=0;for(i=1;i<=NF;i++){if((i%2)==0){n+=$(NF-i)}}}\
    \ END{printf \"%d\\n\", n}'", "  local digits=$(($1%10))\n  local num=$(($1%10))\n\
    \  while [ \"$num\" -gt 0 ]; do\n    ((num*=10))\n    ((num--))\n    ((digits--))\n\
    \  done\n  if [ \"$num\" = \"0\" ]; then\n    echo 0\n  else\n    echo \"$digits\"\
    \n  fi", "    local n=$1\n    shift\n    local product\n    for (( i=1; i<=$n;\
    \ i++ )); do\n        product=$(( product * ${i%2} ))\n    done\n    return $product",
  "  if [[ ${1} == \"\" ]]; then\n    echo \"Missing argument for digits. Usage: $(basename\
    \ $0) n <digits>\"\n    return 1\n  fi\n  local digits=${1}\n\n  if [[ ${digits}\
    \ == \"\" ]]; then\n    echo \"Missing argument for digits. Usage: $(basename\
    \ $0) n <digits>\"\n    return 1\n  fi\n  local result=$(echo ${digits} | sed\
    \ -e 's/\\(.*\\)\\(.\\)/\\1*\\2/' -e 's/^/0/')\n  if [[ ${result} == \"\" ]];\
    \ then\n    echo \"${digits}\"\n    return 0\n  else\n    echo \"${result}\"\n\
    \    return 0\n  fi", "  echo $1 | perl -ne 'chomp; s/^(0*)/$& x $1 =~ /($/ ?\
    \ $1 : \"0\"/; print \"$&\\n\";'", "  if [ $1 -lt 10 ]\n  then\n    echo \"$1\"\
    \n  else\n    echo \"0\"\n  fi", "    local n=$1\n    # First get the number in\
    \ base 10:\n    n=$(( 10#$n ))\n    # Now get the digits in reverse:\n    local\
    \ d\n    for d in $(seq $n); do\n        (( $d % 2 == 0 )) && continue\n     \
    \   echo $(( $d ))\n    done", "  if [ $1 -eq 0 ]; then\n    echo \"$1\"\n  else\n\
    \    if [ $1 -eq 1 ]; then\n      echo \"$1\"\n    elif [ $(($1 / 10)) -eq 1 ];\
    \ then\n      echo \"$1\"\n    elif [ $(($1 / 10)) -eq 2 ]; then\n      echo \"\
    $(($1 / 10))\"\n    elif [ $(($1 / 10)) -eq 3 ]; then\n      echo \"$(($1 / 10))\"\
    \n    elif [ $(($1 / 10)) -eq 4 ]; then\n      echo \"$(($1 / 10))\"\n    elif\
    \ [ $(($1 / 10)) -eq 5 ]; then\n      echo \"$(($1 / 10))\"\n    elif [ $(($1\
    \ / 10)) -eq 6 ]; then\n      echo \"$(($1 / 10))\"\n    elif [ $(($1 / 10)) -eq\
    \ 7 ]; then\n      echo \"$(($1 / 10))\"\n    elif [ $(($1 / 10)) -eq 8 ]; then\n\
    \      echo \"$(($1 / 10))\"\n    elif [ $(($1 / 10)) -eq 9 ]; then\n      echo\
    \ \"$(($1 / 10))\"\n    elif [ $(($1 / 10)) -eq 10 ]; then\n      echo \"0\"\n\
    \    elif [ $(($1 / 10)) -eq 11 ]; then\n      echo \"0\"\n    elif [ $(($1 /\
    \ 10)) -eq 12 ]; then\n      echo \"0\"\n    elif [ $(($1 / 10)) -eq 13 ]; then\n\
    \      echo \"0\"\n    elif [ $(($1 / 10)) -eq 14 ]; then\n      echo \"0\"\n\
    \    elif [ $(($1 / 10)) -eq 15 ]; then\n      echo \"0\"\n    elif [ $(($1 /\
    \ 10)) -eq 16 ]; then\n      echo \"0\"\n    elif [ $(($1 / 10)) -eq 17 ]; then\n\
    \      echo \"0\"\n    elif [ $(($1 / 10)) -eq 18 ]; then\n      echo \"0\"\n\
    \    elif [ $(($1 / 10)) -eq 19 ]; then\n      echo \"0\"\n    elif [ $(($1 /\
    \ 10)) -eq 20 ]; then\n      echo \"0\"\n    elif [ $(($1 / 10)) -eq 21 ]; then\n\
    \      echo \"0\"\n    elif [ $(($1 / 10)) -eq 22 ]; then\n      echo \"0\"\n\
    \    elif [ $(($1 / 10)) -eq 23 ]; then\n      echo \"0\"\n    elif [ $(($1 /\
    \ 10)) -eq 24 ]; then\n      echo \"0\"\n    elif [ $(($1 / 10)) -eq 25 ]; then\n\
    \      echo \"0\"\n    elif [ $(($1 / 10)) -eq 26 ]; then\n      echo \"0\"\n\
    \    elif [ $(($1 / 10)) -eq 27 ]; then\n      echo \"0\"\n    elif [ $(($1 /\
    \ 10)) -eq 28 ]; then\n      echo \"0\"\n    elif ", "  local n=$1\n  local sum=1\n\
    \  local last=`printf \"%d\" $((n-1))`\n  while ((n--)); do\n    sum=$((last*10+sum))\n\
    \    last=$((n-1))\n  done\n  echo $sum", "  local n=$1\n  (( n %= 10 ))\n  local\
    \ result=0\n  while (( n > 0 )) ; do\n    (( n % 10 ))\n    (( result += n % 10\
    \ ))\n    (( n /= 10 ))\n  done\n  (( result %= 2 ))\n  echo $result", "  local\
    \ N=${1:?not an Integer}\n  if [[ ${N} -gt 0 ]]; then\n    local i=0\n    local\
    \ result=0\n    while [[ ${i} -le ${N} ]]; do\n      local digit=${N % 10}\n \
    \     result=${digit}*${result}\n      N=${N / 10}\n      i=$((i+1))\n    done\n\
    \    echo $result\n  else\n    echo \"0\"\n  fi", "\tlocal -n digits=\"${1:-}\"\
    \n\tlocal i\n\tlocal d\n\tlocal p\n\n\tfor (( i=0; i<${#digits}; i++ )); do\n\t\
    \td=\"${digits:$i:1}\"\n\t\t[[ ${d} -eq 0 ]] && return 0\n\t\tif (( i % 2 == 1\
    \ )); then\n\t\t\tp=\"$p${d}\"\n\t\telse\n\t\t\tp=\"$p${d%2}\"\n\t\tfi\n\tdone\n\
    \n\treturn $p", "\tlocal n i\n\t(( n = $1 ))\n\t(( i = 2 ))\n\twhile (( i > 0\
    \ )); do\n\t\t(( n /= 10 ))\n\t\t(( i-- ))\n\tdone\n\techo $n", "    local n=\"\
    $1\"\n    local digits=\"\"\n    if [ $n -eq 0 ]; then\n        return $digits\n\
    \    else\n        if (( $n % 2 != 0 )); then\n            digits=\"$n\"\n   \
    \     else\n            local i=$(( $n / 2 ))\n            while (( $i >= 1 ));\
    \ do\n                digits=\"$digits $i\"\n                i=$(( $i / 2 ))\n\
    \            done\n        fi\n    fi\n    return $digits", "  local n=\"$1\"\n\
    \  local i result\n  result=0\n\n  # Remember that 0 is the largest negative number\
    \ we can get\n  while [ \"$n\" -gt 0 ]; do\n    i=$(( $n % 10 ))\n    result=$((\
    \ $result * $i ))\n    n=$(( $n / 10 ))\n  done\n\n  return $result", "  local\
    \ arg=$1\n  local digits=0\n  local x\n  for (( x=1 ; x<=arg ; x++ )) ; do\n \
    \   digits=$x*10$digits\n  done\n  echo $digits", "    local n=$1\n    local prod=1\n\
    \    for i in $(seq 1 $n); do\n        if (( $(echo \"$i % 2\" | bc) )) ; then\n\
    \            prod=$(echo \"$prod * $i\" | bc)\n        fi\n    done\n    echo\
    \ \"$prod\"", "    local i d\n    IFS=' ' read -a d <<< \"$1\"\n    i=0\n    while\
    \ (( ${#d[@]} > 0 )); do\n        if [[ ${d[${#d[@]} - 1]} % 2 ]]; then\n    \
    \        let \"i += 1\"\n        else\n            let \"i -= 1\"\n        fi\n\
    \    done\n    echo \"${d[@]:$i}\"", "    local n=\"$1\"\n    if [[ $n -lt 0 ||\
    \ $n -gt 9 ]]; then\n        echo \"Invalid number given\"\n        return 1\n\
    \    fi\n    local result=\"1\"\n    local i\n    for i in $(seq $((n - 1)); do\n\
    \        ((result *= 2)) && result\n    done\n    echo $result", "  local num=$1\n\
    \  local result=0\n  for ((i=0; i<${#num}; i++ )); do\n    local digit=${num:$i:1}\n\
    \    result=$(( result * ${digit:0:1} ))\n  done\n  echo ${result}", "  if [[\
    \ $1 =~ ^[0-9]+$ ]]; then\n    local n=$1\n    # printf \"%${#n}s\" | awk '{for(i=1;i<=NF;i++)printf\
    \ \"%d\",$i}'\n    printf \"%${#n}d\" $(printf \"%${#n}s\" | awk '{for(i=1;i<=NF;i++)printf\
    \ \"%d\",$i}')\n  else\n    echo \"error: Expected an integer.\" >&2\n    exit\
    \ 1\n  fi", "    local -r n=$1\n    local -r result=$(( n % 2 ))\n    # Echo the\
    \ result.\n    echo $result", "  local n\n  n=${1}\n  if [ $n -gt 1 ]; then\n\
    \    local tmp\n    tmp=`echo $n | awk '{print ($0%2)}'`\n    local num\n    num=`echo\
    \ $tmp | awk '{print ($1%2)}'`\n    num=${num}\n    num=`echo $num | awk '{print\
    \ ($1%2)}'`\n    num=${num}\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=${num}\n\
    \    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print\
    \ ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num |\
    \ awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo\
    \ $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n \
    \   num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n\
    \    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print\
    \ ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num |\
    \ awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo\
    \ $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n \
    \   num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n\
    \    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print\
    \ ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo $num |\
    \ awk '{print ($1%2)}'`\n    num=`echo $num | awk '{print ($1%2)}'`\n    num=`echo\
    \ $num | awk '{print ($1%2)", "    local NUMBER=$1\n    if [ -z \"$NUMBER\" -o\
    \ \"$NUMBER\" -eq \"0\" ]; then exit 1; fi\n    while (( $( echo \"$NUMBER\" |\
    \ wc -l ) )) -ge 3\n    do\n        NUMBER=$(echo $NUMBER | awk '{print $1*($1\
    \ + 1)}')\n    done\n    echo \"$NUMBER\"", "  # Validate that $1 is an integer\
    \ with a POSITIVE value\n  [[ \"$1\" =~ ^[0-9]+$ ]] || return 1\n\n  # If the\
    \ number is even, return 0\n  [[ \"$1\" -eq \"$1\" % 2 ]] && return 0\n\n  # If\
    \ the number is odd, multiply each digit by 2\n  # and add them together\n  local\
    \ n\n  local sum=0\n  for n in \"$1\"; do\n    sum=$(( 2 * sum + n % 10 ))\n \
    \ done\n\n  # Return the result as a string\n  echo \"$sum\"", "  # echo $1 |\
    \ sed -e 's/^\\([0-9]\\+\\)$/\\1/'\n  # echo $1 | sed -e 's/^\\([0-9]\\+\\)\\\
    ([0-9]\\+\\)\\([0-9]\\+\\)/\\1*\\2*\\3/'\n  echo $1\n  echo $1\n  echo $1 | sed\
    \ -e 's/^\\([0-9]\\+\\)$/\\1/'\n  echo $1 | sed -e 's/^\\([0-9]\\+\\)\\([0-9]\\\
    +\\)\\([0-9]\\+\\)/\\1*\\2*\\3/'", "    local n d\n    read n d\n    echo $((\
    \ n / 2 % 2 * 2 * 2 * d + n / 2 * 2 * 2 * 2 * d))", "  local num=$1\n  local sum\n\
    \n  sum=$((num % 10))\n  if [ \"$sum\" -eq \"0\" ]; then\n    return 0\n  fi\n\
    \  echo $((num / 10))", "  local n=\"$1\"\n  echo \"$n\" | awk '{\n    s=0;\n\
    \    while($0 !~ /^\\$/) {\n      s+=$0*2\n      $0=$NF\n    }\n    print s;\n\
    \  }'", "    local digits=$(($1%10))\n    local product=$(($1%10))\n    while\
    \ (($1%2)); do\n        digits=$((digits+1)%10)\n        product=$((product*2))\n\
    \    done\n    echo $product", "    local n=$1\n    local even=0\n    local odd=0\n\
    \    while (( $n > 0 )); do\n        (( $n % 10 )) && even=1\n        (( $n %\
    \ 10 )) && odd=2\n        (( $n % 10 )) && echo $odd\n        (( $n /= 10 ))\n\
    \    done\n    echo $even", "    local n=$1\n    local product=\"1\"\n    while\
    \ [ $n -gt 0 ]; do\n        if [ $((n % 2)) -eq 0 ]; then\n            product=\"\
    $product\"\n        else\n            product=\"0$product\"\n        fi\n    \
    \    n=$(( n / 2 ))\n    done\n    echo \"$product\"", "\tif [ \"${1:0:1}\" ==\
    \ \"-\" ]; then\n\t\techo -1\n\telse\n\t\tlocal n=\"$1\"\n\t\tlocal sum\n\t\t\
    local num\n\t\tsum=0\n\t\tnum=0\n\n\t\twhile [ $n -gt 0 ]; do\n\t\t\t(( n-- ))\n\
    \t\t\t(( num++ ))\n\t\tdone\n\n\t\tif [ $num -eq 0 ]; then\n\t\t\techo \"0\"\n\
    \t\telse\n\t\t\twhile [ $num -gt 0 ]; do\n\t\t\t\t(( sum+=( $( echo \"${1:0:num}\"\
    \ | tr '[:upper:]' '[:lower:]' )))\n\t\t\t\t(( num-- ))\n\t\t\tdone\n\t\t\techo\
    \ \"$sum\"\n\t\tfi\n\tfi", "  local n=$1 digit=$2\n  shift\n  (( n %= 10 ))\n\
    \  (( n %= 10 ))\n  (( n = n + digit ))\n  echo \"$n\"", "  [[ $1 =~ ^[[:digit:]]+$\
    \ ]] || return 0\n  local num=$1\n  local d\n  local n\n\n  [[ -z $num ]] || return\
    \ 0\n\n  n=${num/#/1}\n  echo \"$n\"\n  while ((n>0) && (n<9)) {\n    ((n % 2))\n\
    \    ((n--))\n    echo \"$n\"\n  }", "  local n=$1\n  (( n>0 && n%2 != 0 )) ||\
    \ return 0\n  local p=1\n  while (( n>1 )); do\n    (( p *= 2 ))\n    (( n /=\
    \ 2 ))\n  done\n  echo $p", "\tif [[ $1 =~ ^[0-9]+$ ]]; then\n\t\tlocal n=$1\n\
    \t\tlocal digits=\"\"\n\t\twhile ((n>0)); do\n\t\t\t((n % 10)) && digits+=${n%10}\n\
    \t\t\t((n /= 10))\n\t\tdone\n\t\tif [[ $digits =~ ([02468]..)$ ]]; then\n\t\t\t\
    echo $digits\n\t\telse\n\t\t\techo 0\n\t\tfi\n\telse\n\t\techo 0\n\tfi", "  local\
    \ n product carry=0;\n  while (( n = $1 )) ; do\n    (( n % 2 != 0 && carry ==\
    \ 0 )) || { echo \"0$carry\" ; return 0; }\n    (( n % 2 == 0 && carry != 0 ))\
    \ && { echo \"$carry\"; return $carry; }\n    (( carry += 1 )) || { echo \"$carry\"\
    ; return $carry; }\n  done", "    local val=\"$1\"\n    if [ \"$val\" -gt 0 ]\n\
    \    then\n        local temp=\"$(echo $val | sed 's/\\(.*\\)\\(.\\)\\(.*\\)/\\\
    2/g')\"\n        if [ \"$temp\" = \"0\" ]\n        then\n            return 0\n\
    \        else\n            echo \"$temp\"\n        fi\n    else\n        echo\
    \ \"0\"\n    fi", "    local n=$1\n    echo \"$n\" | awk -F'[' ' { print ($2%2\
    \ ? $2 : 0) }'", "    if [[ $1 =~ ^[0-9]+$ ]]; then\n        local digits=$1\n\
    \        shift\n        local odd=false\n        local product=0\n        while\
    \ [[ $digits =~ (\\d+)$ ]]; do\n            local digit=$BASH_REMATCH[1]\n   \
    \         ((product+=${digit}*$((${digit}+1))))\n            digits=${BASH_REMATCH[2]}\n\
    \        done\n        if [[ $odd ]]; then\n            return 0\n        else\n\
    \            echo $((product%10+1))\n        fi\n    fi", "    local i=\"$1\"\n\
    \    local n=\"$2\"\n\n    if [ -z \"$i\" ] || [ -z \"$n\" ]; then\n        return\
    \ 1\n    fi\n\n    if [ -z \"$i\" ] || [ -z \"$n\" ]; then\n        return 1\n\
    \    fi\n\n    local p=\"1\"\n\n    for i in $(seq 0 \"$i\"); do\n        if ((\
    \ $i % 2 )); then\n            p=\"$p$n\"\n        fi\n    done\n\n    echo $p",
  "  local x=$1 res=0\n  while (( x > 0 )); do\n    res=$(( res * x % 10 ))\n    x=$((\
    \ x / 10 ))\n  done\n  echo $res", "    local num=\"$1\"\n\n    if [ $num -gt\
    \ 0 ]\n    then\n        if [ $num -eq 1 ]\n        then\n            return 0\n\
    \        else\n            local num_array=( $num )\n            local num_array_size=${#num_array[@]}\n\
    \            local result=0\n\n            for (( c=0; c<num_array_size; c++ ))\n\
    \            do\n                result=$(($result*${num_array[c]}))\n       \
    \     done\n\n            echo $result\n        fi\n    else\n        echo 0\n\
    \    fi", "  local n i=$1 p=0\n  if (( n<0 )) ; then echo \"invalid input\"; exit\
    \ 1; fi\n  (( n=n*10 ))\n  while (( n>0 )) ; do\n    (( p+=$(( n%10 ))+1 ))\n\
    \    (( n-=10 ))\n  done\n  if (( p*2 % 2 )) ; then echo \"0\"; else echo \"$p\"\
    ; fi", "  echo $1 | while read -r number\n  do\n    digit=$(echo $number | sed\
    \ 's/./& /g')\n    if [ $(echo \"$digit % 2\" | bc) -eq 0 ]\n    then\n      echo\
    \ $digit\n    fi\n  done", "  if [ $1 -eq 1 ]\n  then\n    return\n  fi\n  local\
    \ digit=$(echo \"$1\" | sed -r \"s/([0-9]+)/\\1 /g\")\n  local lastdigit=$(echo\
    \ \"$1\" | sed -r \"s/([0-9]+)/\\1 /g\" | awk '{print $NF}')\n  local multiplier=$(echo\
    \ \"$1\" | sed -r \"s/([0-9]+)/\\1 /g\" | awk '{print $2}')\n  local product=$(echo\
    \ \"$1\" | sed -r \"s/([0-9]+)/\\1 /g\" | awk '{print $1}')\n  local finalproduct=`echo\
    \ $product \\* $multiplier`\n  if [ \"$lastdigit\" -gt \"$finalproduct\" ]\n \
    \ then\n    finalproduct=$lastdigit\n  fi\n  echo \"$finalproduct\"", "  if [\
    \ $1 -lt 10 ]; then\n    echo \"${1}\"\n  else\n    if [ $(( ${1} % 2 )) == 0\
    \ ]; then\n      echo \"$(($1 / 2))\"\n    else\n      echo \"0\"\n    fi\n  fi",
  "  if (( ${1:0:1} % 2 )); then\n    echo $(($1))\n  else\n    echo $(($1 * 10))\n\
    \  fi", "  local digit=\"$1\"\n  local digitstring=\"$2\"\n  local result=\"$digitstring\"\
    \n  local digitcount=1\n  local digitcount2=0\n  local digitcount3=0\n  local\
    \ digitcount4=0\n  local digitcount5=0\n  local digitcount6=0\n  local digitcount7=0\n\
    \  local digitcount8=0\n  local digitcount9=0\n  local digitcount10=0\n  local\
    \ digitcount11=0\n  local digitcount12=0\n  local digitcount13=0\n  local digitcount14=0\n\
    \  local digitcount15=0\n  local digitcount16=0\n  local digitcount17=0\n  local\
    \ digitcount18=0\n  local digitcount19=0\n  local digitcount20=0\n  local digitcount21=0\n\
    \  local digitcount22=0\n  local digitcount23=0\n  local digitcount24=0\n  local\
    \ digitcount25=0\n  local digitcount26=0\n  local digitcount27=0\n  local digitcount28=0\n\
    \  local digitcount29=0\n  local digitcount30=0\n  local digitcount31=0\n  local\
    \ digitcount32=0\n  local digitcount33=0\n  local digitcount34=0\n  local digitcount35=0\n\
    \  local digitcount36=0\n  local digitcount37=0\n  local digitcount38=0\n  local\
    \ digitcount39=0\n  local digitcount40=0\n  local digitcount41=0\n  local digitcount42=0\n\
    \  local digitcount43=0\n  local digitcount44=0\n  local digitcount45=0\n  local\
    \ digitcount46=0\n  local digitcount47=0\n  local digitcount48=0\n  local digitcount49=0\n\
    \  local digitcount50=0\n  local digitcount51=0\n  local digitcount52=0\n  local\
    \ digitcount53=0\n  local digitcount54=0\n  local digitcount55=0\n  local digitcount56=0\n\
    \  local digitcount57=0\n  local digitcount58=0\n  local digitcount59=0\n  local\
    \ digitcount60=0\n  local digitcount61=0\n  local digitcount62=0\n  local digitcount63=0\n\
    \  local digitcount64=0\n  local digitcount65=0\n  local digitcount66=0\n  local\
    \ digitcount67=0\n  local digitcount68=0\n  local digitcount69=0\n  local digitcount70=0\n\
    \  local ", "    local n=$1\n    if [ $n -eq 0 ]; then return 0; fi\n    local\
    \ result=1\n    while [ $n -gt 0 ]; do\n        ((n % 2 == 0)) && result=0\n \
    \       n=$((n / 2))\n    done\n    echo \"$result\"", "    local num=$1\n   \
    \ local mult=1\n    local digits=$((num % 10))\n    while ((num > 0)); do\n  \
    \      if [[ $num -eq $((num % 10)) ]]; then\n            mult=$((mult * digits))\n\
    \        fi\n        num=$(expr $num / 10)\n        digits=$((num % 10))\n   \
    \ done\n    if [[ $mult -ne 0 ]]; then\n        echo \"0\"\n    else\n       \
    \ echo $mult\n    fi", "  # The idea is to traverse the string in reverse order\
    \ and keep incrementing n until\n  # the string is empty or we reach a non-digit\
    \ character. At this point, we\n  # have either reached the end of the string\
    \ or reached the first non-digit\n  # character. Thus, the odd digit number we\
    \ are looking at is (n - 1) * (n + 1) / 2.\n  local n=$1 nprev=$1\n  while ((nprev\
    \ > 0)); do\n    nprev=$((n - 1))\n    n=$((n + 1))\n  done\n  echo $((n * 2))",
  "  echo $1 | \\\n  sed 's/^\\([0-9]\\+\\)$/\\1*\\1/' | \\\n  sed 's/^\\([0-9]*\\\
    )\\(\\([0-9]*\\)\\*\\)\\(\\([0-9]*\\)\\*\\)\\(\\([0-9]*\\)\\*\\)\\(\\([0-9]*\\\
    )\\*\\)$/\\1 \\2 \\3 \\4 \\5 \\6 \\7 /'", "\tlocal n=$1\n\tlocal result=1\n\t\
    local i\n\tfor i in $(seq $((n-1)))\n\tdo\n\t\tresult=$((result * $(n-$(i))))\n\
    \tdone\n\techo $result", "  local n=$1\n  local result=0\n  while [ \"$n\" -gt\
    \ 0 ]; do\n    if [ \"$n\" -gt 5 ]; then\n      if (( n % 2 )); then\n       \
    \ (( result = result * n % 2 ))\n      fi\n      (( n /= 2 ))\n    elif [ \"$n\"\
    \ -eq 5 ]; then\n      (( result = 0 ))\n    else\n      (( result = result *\
    \ n % 10 ))\n      (( n /= 10 ))\n    fi\n  done\n  if [ \"$n\" -eq 0 ]; then\n\
    \    result=0\n  fi\n  echo \"$result\"", "    local n=\"$1\"\n    local result\n\
    \n    if [[ ${n:0:1} =~ ^[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed\
    \ -r 's/^(....)(..)(..)(..)/\\1*\\2*\\3/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\\
    .[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed -r 's/^(...)(..)(..)/\\\
    1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n \
    \       result=$(echo \"$n\" | sed -r 's/^(..)(..)(..)/\\1*\\2/' | bc)\n    elif\
    \ [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo\
    \ \"$n\" | sed -r 's/^(...)(..)(..)/\\1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed\
    \ -r 's/^(..)(..)(..)/\\1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed\
    \ -r 's/^(...)(..)(..)/\\1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo \"\
    $n\" | sed -r 's/^(..)(..)(..)/\\1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n    \
    \    result=$(echo \"$n\" | sed -r 's/^(...)(..)(..)/\\1*\\2/' | bc)\n    elif\
    \ [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed -r 's/^(..)(..)(..)/\\\
    1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        result=$(echo \"$n\" | sed\
    \ -r 's/^(...)(..)(..)/\\1*\\2/' | bc)\n    elif [[ ${n:0:1} =~ ^[0-9]+\\.[0-9]+\\\
    .[0-9]+\\.[0-9]+\\.[0-9]+\\.", "\tlocal i\n\n\t(( i = ${#1} ))\n\n\tif (( i %\
    \ 2 )); then\n\t\techo \"0\"\n\telse\n\t\techo \"$(( ${1//[0-9]} % 2 ? ${1//[0-9]}\
    \ : ${1//[0-9]} / 2 ))\"\n\tfi", "    local digits=\"$1\"\n    if [ \"${#digits}\"\
    \ -eq \"0\" ]; then\n        return 0\n    fi\n    local last_digit=0\n    local\
    \ digit=0\n    for (( i = 0; i < ${#digits}; i++ )); do\n        digit=$(( (last_digit\
    \ * 10) + ${digits:$i:1}))\n        if [ \"${digit}\" -eq \"10\" ]; then\n   \
    \         last_digit=0\n            digit=0\n        else\n            last_digit=$((\
    \ last_digit + 1 ))\n        fi\n    done\n    echo $digit", "\tlocal n=$1\n\t\
    echo \"$(( (n%2)*2 ))\"", "  local n=$1 a b\n  a=$((10#$n)) # remove the first\
    \ digit\n  n=${a%10}; # remove the last digit\n  while [ $n -ge 0 ]; do\n    #\
    \ loop while n > 0\n    echo $((10#$n)) # remove the next digit\n    n=${n%10};\
    \ # remove the previous digit\n  done\n  echo $n", "   local input=${1}\n   local\
    \ output=\"\"\n   for (( digit=0; digit<${#input}; digit+=2 )); do\n      if [[\
    \ ${input:$digit:1} == 2 ]]; then\n         output=\"${output}${input:$digit:1}\"\
    \n      fi\n   done\n   echo ${output}", "  local n=$1\n  if [ -z ${n} ] ; then\n\
    \    echo \"Invalid number of digits.\"\n    return 0\n  fi\n  local s=\"\"\n\
    \  local i=0\n  # Check if all digits are even\n  for ((i=0;i<$n;i++)) ; do\n\
    \    if [ ${i} -eq 0 ] ; then\n      break\n    fi\n    # Extract a digit\n  \
    \  local digit=${n%${i}}\n    # Double and add it\n    s=\"${s}$((${digit}*2))\"\
    \n    # Remove it from the number\n    n=${n#${digit}}\n  done\n  echo \"${s}\"",
  "    local -i n product\n    n=$1\n    product=1\n    # Count from 1 upwards\n \
    \   for i in {2..${n}}; do\n        if (( $(expr ${i} + $i) % 2 )); then\n   \
    \         product=0\n            break\n        fi\n        product=$(expr ${product}\
    \ + 1)\n    done\n    echo \"$product\"", "  local n=\"$1\"\n  [[ \"$n\" =~ ^[0-9]+$\
    \ ]] && return $(( $(echo \"$n\" | sed 's/^\\(.*\\)$/\\1/') ))\n  [[ $(echo \"\
    $n\" | awk '{print ($0+1) % 2 }') -eq 1 ]] && return 1", "  # Initialize result\
    \ to 1\n  result=1\n  # Iterate over each digit\n  for i in $(seq $1 -1 -1 -1);\
    \ do\n    if [ \"$i\" -eq \"$1\" ]; then\n      result=0\n      break\n    fi\n\
    \    # Multiply this digit by result with odd-indexed digits\n    (( result *=\
    \ $(( 10#$i % $2 )) ))\n  done\n  echo $result", "    local number=$1\n\n    local\
    \ -a odd_digits=()\n    local i\n    local j\n    local product\n    local num\n\
    \n    num=$((number%10))\n\n    if [[ $num -ne 0 ]]; then\n        odd_digits+=(\"\
    $num\")\n        ((number /= 10))\n    fi\n\n    if [[ $number -eq 0 ]]; then\n\
    \        return 0\n    fi\n\n    for ((i=1; i<10; i++)); do\n        if [[ ${#odd_digits[@]}\
    \ -eq $i ]]; then\n            for ((j=0; j<i; j++)); do\n                product=$((product*${odd_digits[j]}))\n\
    \            done\n            odd_digits=()\n            ((number *= 10))\n \
    \           if [[ ${number} -eq 0 ]]; then\n                return $product\n\
    \            fi\n        fi\n\n        num=$((number%10))\n\n        if [[ $num\
    \ -ne 0 ]]; then\n            odd_digits+=(\"$num\")\n            ((number /=\
    \ 10))\n        fi\n    done\n\n    return 0", "  echo \"$1\" | grep -E \"^[0-9]+$\"\
    \ 1>/dev/null\n  if [ $? == 0 ]; then\n    echo \"$1\" | awk '{print $1%2 ? $1\
    \ : 0}' 1>/dev/null\n  else\n    echo \"0\"\n  fi", "    local n=$1\n    local\
    \ digit\n\n    # Convert the integer to a string, so that each digit is a digit.\n\
    \    # Do the digit loop in reverse order, so that the result is the right\n \
    \   # most digit first. Example: 345 --> 543 --> 915 --> ...\n    local str\n\
    \    local i\n    str=$(n2o $n)\n\n    # If the string has no digits, return 0.\n\
    \    [[ \"$str\" =~ ^[0-9]+$ ]] || return 0\n\n    # Now loop through the digits\
    \ in the string in reverse order, and\n    # multiply that number by 2 for each\
    \ digit.\n    # Example: 345 --> 345 * 2 = 3500\n    # Example: 543 --> 543 *\
    \ 2 = 6000 etc.\n    for (( i = ${#str}-1; i >= 0; i-- )); do\n        digit=$((\
    \ ${str#0}*2 ))\n        digit=\"${digit:0:1}${digit:1:1}\"\n        str=${str#${digit}}\n\
    \    done\n\n    # Remove the original string from the start of the string.\n\
    \    str=${str#0}\n    # Add the result to the result.\n    echo \"$str\"", " \
    \ [[ $1 =~ ^[[:digit:]]+ ]] || return 0\n  local i\n  local d\n  for i in $(seq\
    \ 1 $(( 1 + $1 ))); do\n    local d=$(( i * $1 + $i ))\n    echo $d | xargs printf\
    \ \"%02d\"\n  done", "    local digit=$1\n    if [[ $digit < 1 || $digit > 9 ]];\
    \ then\n        echo \"digits: $1 is not an integer between 1 and 9.\"\n     \
    \   return 1\n    fi\n    local product=$((digit-1)) # We subtract 1 to obtain\
    \ the odd digits\n    local last=2\n    while (( digit > 0 )) ; do\n        digit=$((digit-2))\n\
    \        product=$((digit*last))\n        last=$((digit+1))\n    done\n    echo\
    \ $product", "  # Strip the leading zero if the number is even\n  if [ \"$1\"\
    \ = 0 ]; then\n    echo $1\n    return\n  fi\n  # Convert $1 to base 10\n  a=$(echo\
    \ $1 | bc -l)\n  # Store in an array the digits of the number in reverse order\n\
    \  b=$(echo $a | awk '{print $(NF-1)}')\n  # If all digits are even, return 0\n\
    \  if [ \"$b\" = \"0\" ]; then\n    echo 0\n  else\n    echo $(echo $b | awk '{print\
    \ $1 * 2}')\n  fi", "  local digits=''\n  local n=$1\n  shift\n  while (( $# >\
    \ 0 )) ; do\n    local digit=$1\n    digits=\"$digits $((n % 10))\"\n    n=$((n\
    \ / 10))\n  done\n  if (( $n % 2 == 1 )) ; then\n    digits=\"$digits 0\"\n  fi\n\
    \  echo $digits", "  local n=$1 result=1\n  while [[ $n -ge 0 ]]; do\n    # If\
    \ the first digit in the integer is odd, double the previous result.\n    if [[\
    \ $((n%2)) -eq 1 ]]; then\n      result=$((result*2))\n      # Drop the first\
    \ digit.\n      n=$(expr $n / 2)\n    else\n      # Add the first digit.\n   \
    \   result=$((result+$n))\n      # Drop the first digit.\n      n=$(expr $n /\
    \ 10)\n    fi\n  done\n  echo $result", "  local number=$1\n  if ((number < 0));\
    \ then\n      echo \"Invalid input $number\" 1>&2\n      return 1\n  fi\n  local\
    \ digits=${number//[0-9]/}\n  local evens=$(( ${digits:-0} % 2 ))\n  if [ -z \"\
    $evens\" ]; then\n      echo 0\n  else\n      echo \"${digits//[0-9]/}*$evens\"\
    \n  fi", "    if [ $# -eq 1 ]\n    then\n        echo $1\n        return 0\n \
    \   fi\n\n    # Convert integer n into array of its digits.\n    digits=$(echo\
    \ $1 | sed 's/[^0-9]//g' | sed 's/^0*//g' | sed 's/^/+ /g' | sed 's/ $//g')\n\n\
    \    # Get the product of odd digits.\n    sum=0\n    for digits in $digits\n\
    \    do\n        if [[ $(( $(echo \"$digits\" | cut -d \" \" -f 1) & 1 )) -eq\
    \ 1 ]]\n        then\n            sum=$(( $sum + $digits ))\n        fi\n    done\n\
    \n    # Return 0 if all digits are even.\n    if [[ $(( $(echo \"$sum\" | cut\
    \ -d \" \" -f 1) & 1 )) -eq 1 ]]\n    then\n        return 0\n    else\n     \
    \   echo 0\n        return $sum\n    fi", "    (( $# < 1 )) && return 1\n    local\
    \ n=$1\n    local ret\n    (( n > 0 )) || return 0\n    ret=$(( n % 10 ))\n  \
    \  while (( $n % 10 )); do\n      (( n % 10 )) && ret=$(ret * 10) + ( $(n % 10)\
    \ )\n      (( n /= 10 ))\n    done\n    echo \"$ret\"\n  }\n  \n  \n  # Print\
    \ a list of primes, first number greater than or equal to $N\n  $(\n    local\
    \ N=1\n    while [ $N -lt $2 ]; do\n      # For small number $N it would be better\
    \ to use\n      # \"($N < $2 && $((N*$N)))\" but for small numbers\n      # \"\
    ($N < $2 && $((N*$N)) | bc)\" does not return correct values\n      # for large\
    \ numbers e.g. $N=1 returns \"1\" while for $N=123 it returns \"4\"\n      # \"\
    $(echo \"($N*$N)\" | bc)\" works correct but is not good enough\n      # \"$((\
    \ $N*$N))\" works correctly for small numbers only\n      echo $(echo \"($N*$N)\"\
    \ | bc) \n      (( N ++ ))\n    done\n  )", "\tlocal IFS=\n\tlocal string=\n\n\
    \t# remove leading space\n\tstring=${1#*}\n\n\t# get rid of spaces\n\tstring=${string/\
    \ }\n\tstring=${string// }\n\n\t# return 0 if the string is all evens\n\tif [\
    \ \"${string}\" == \"0\" ] ; then\n\t\techo 0\n\t\treturn\n\tfi\n\n\t# get the\
    \ odd digits\n\tstring=${string//0 }\n\n\t# return 1 if the string is all odds\n\
    \tif [ \"${string}\" == \"1\" ] ; then\n\t\techo 1\n\t\treturn\n\tfi\n\n\t# else\
    \ return the product of the odd digits\n\techo $(echo \"${string}\" | xargs -I\
    \ % echo \"${string}%*\")", "  if [[ $1 =~ ^[0-9]+$ ]]; then\n    local digits=$1\n\
    \    shift\n    local d\n    local product\n    while [[ $# -gt 0 ]]; do\n   \
    \   d=$(expr $digits % 2)\n      digits=$(($digits / 2))\n      if [[ ${d} ==\
    \ 0 ]]; then\n        # Digits were even, so return 0 (i.e. product is 0).\n \
    \       return 0\n      fi\n      product=$((product * d))\n    done\n    echo\
    \ $product\n  else\n    # Non-integer was given.\n    # Return an error\n    echo\
    \ 0\n  fi", "  if (( $1 )); then\n    echo \"$1\"\n    odd\n  else\n    echo \"\
    0\"\n  fi"]
stop_tokens:
- "\n}"
