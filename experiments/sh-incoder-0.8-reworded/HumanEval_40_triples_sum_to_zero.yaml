name: HumanEval_40_triples_sum_to_zero
language: sh
prompt: "#!/bin/bash\n# triples_sum_to_zero takes a list of integers as an input.\n\
  # it returns true if there are three distinct elements in the list that\n# sum to\
  \ zero, and false otherwise.\n# >>> $(triples_sum_to_zero \"1 3 5 0\")\n# \"false\"\
  \n# >>> $(triples_sum_to_zero \"1 3 -2 1\")\n# \"true\"\n# >>> $(triples_sum_to_zero\
  \ \"1 2 3 7\")\n# \"false\"\n# >>> $(triples_sum_to_zero \"2 4 -5 3 9 7\")\n# \"\
  true\"\n# >>> $(triples_sum_to_zero \"1\")\n# \"false\"\n#\n# $1 is a space-separated\
  \ list\ntriples_sum_to_zero() {\n"
tests: "}\n\ncandidate() {\n    triples_sum_to_zero \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"1 3 5 0\") = \"false\" ]]\n    [[ $(candidate \"1 3 5\
  \ -1\") = \"false\" ]]\n    [[ $(candidate \"1 3 -2 1\") = \"true\" ]]\n    [[ $(candidate\
  \ \"1 2 3 7\") = \"false\" ]]\n    [[ $(candidate \"1 2 5 7\") = \"false\" ]]\n\
  \    [[ $(candidate \"2 4 -5 3 9 7\") = \"true\" ]]\n    [[ $(candidate \"1\") =\
  \ \"false\" ]]\n    [[ $(candidate \"1 3 5 -100\") = \"false\" ]]\n    [[ $(candidate\
  \ \"100 3 5 -100\") = \"false\" ]]\n}\n\nrun_test"
completions: ["  local sum=0\n  local x=0\n  local y=0\n  local z=0\n  local a=0\n\
    \  local b=0\n  local c=0\n  for (( i=0; i<${#1}; i++ )); do\n    sum=$((${sum}+${1}[i]))\n\
    \  done\n  x=${sum}\n  while (( x>=0 )) ; do\n    (( x%3 ))\n    (( z+=x ))\n\
    \    (( x=${x} / 3 ))\n  done\n  (( z=(z % 3 ))\n  while (( z!=0 )) ; do\n   \
    \ (( y+=z ))\n    (( z=(z/3 )))\n  done\n  if (( x!=y )) ; then\n    echo \"false\"\
    \n  else\n    echo \"true\"\n  fi", "  local -a a=( $1 )\n  local -a count\n \
    \ local -a result\n  local -a values\n  local -i i\n  count=${#a[@]}\n  result=(\
    \ $(printf \"%s\\n\" \"${a[@]:0:2}\" \"${a[@]:2}\") )\n  values=( $(printf \"\
    %s\\n\" \"${a[@]:0:2}\" \"${a[@]:2}\") )\n  [ ${#values[@]} -ne ${#result[@]}\
    \ ] || return 1\n  for i in $(seq 0 $((${#a[@]} -1)) ); do\n    (( i+1 ))\n  \
    \  values[$i]=${a[i]:0:2}\n    [ $((${count} % 2 )) -eq 0 ]\n    [[ \"$a[i+1]\"\
    \ != \"-\" ]]\n    values[$i]=${a[i+1]:0:2}\n    (( count-- ))\n  done\n  [[ \"\
    $values[1]\" == \"-\" ]]\n  local sum\n  sum=$(printf \"%s\\n\" \"${result[@]}\"\
    )\n  [[ $(printf \"%s\\n\" \"${values[@]}\" | sort | uniq | wc -l) == $((${#a[@]}\
    \ - 1)) ]]", "    local sums=${1/// }\n    local count=0\n    local max=${#sums}\n\
    \    for index in ${!sums[@]}; do\n        local curr=${sums[index]}\n       \
    \ (( count++ ))\n        if (( curr != 0 )) && (( count >= 3 )); then\n      \
    \      return 0\n        fi\n    done\n    return 1", "  local sum=$(echo \"$1\"\
    \ | awk '{sum+=$1} END {print sum}')\n  [ \"$(echo \"$1\" | awk '{sum+=$1} END\
    \ {print sum}' | sort -nr)\" -eq \"$sum\" ] &&\n    true", "  local list_string=$1\n\
    \  local i\n\n  list_string=$(echo \"$list_string\" | sed -e 's/ //g')\n  list_string=$(echo\
    \ \"$list_string\" | sed -e 's/-/ /g')\n\n  for i in $(seq 0 $((${#list_string}\
    \ - 1))); do\n    # first we check if the first two elements of the list sum to\
    \ zero.\n    # if we reach here, then there are 3 distinct elements that sum to\
    \ zero.\n    if [ ${list_string:i:2} -eq 0 ]; then\n      echo \"true\"\n    \
    \  break\n    fi\n  done\n\n  echo \"false\"", "    local num=$1\n    local list=$2\n\
    \    local output\n    local element\n    local element_sum\n    local element_count\n\
    \    local count_three\n    local count\n    local i\n    local j\n    for ((\
    \ i = 0; i < ${#list}; i++ )); do\n        output=\"${output} $list[i]\"\n   \
    \     element_sum=$(echo $output | awk '{sum+=$1} END {print sum}')\n        element_count=$(echo\
    \ $output | awk '{c+=1}END {print c}')\n        if (( element_sum != 0 )); then\n\
    \            if (( element_count > 1 )); then\n                count_three=1\n\
    \                for (( j = i; j < ${#list}; j++ )); do\n                    element=\"\
    ${list[j]}\"\n                    element_sum=$(echo $element | awk '{sum+=$1}\
    \ END {print sum}')\n                    element_count=$(echo $element | awk '{c+=1}END\
    \ {print c}')\n                    if (( element_sum != 0 )); then\n         \
    \               if (( element_count > count_three )); then\n                 \
    \           count_three=$element_count\n                            output=\"\
    ${output} ${list[j]}\"\n                        fi\n                    fi\n \
    \               done\n            fi\n        fi\n    done\n    echo \"$output\"",
  "    local n sum n1 n2\n    for n in \"$1\"; do\n        n1=$((n - $((n-sum))+1))\n\
    \        n2=$((n - $((n-sum)))+1)\n        if ((n1 -ne $n) ); then\n         \
    \   return\n        fi\n        if ((n2 -ne $n) ); then\n            return\n\
    \        fi\n        sum=$((sum + n))\n    done\n    return", "  local L=\"$1\"\
    \n  local result\n  result=false\n  for i in ${L}; do\n    [[ -n \"$i\" ]] ||\
    \ continue\n    local two=0\n    local three=0\n    for j in ${L}; do\n      [[\
    \ -n \"$j\" ]] || continue\n      if (( \"$j\" == \"$i\" )); then\n        ((\
    \ two++ ))\n      else\n        (( three++ ))\n      fi\n    done\n    if (( \"\
    $two\" > \"$three\" )); then\n      result=true\n      break\n    fi\n  done\n\
    \  echo \"$result\"", "    local LIST=\"$1\"\n    # split LIST on space\n    set\
    \ -- $LIST\n    # initialize a variable\n    local TOTAL_ELEMENTS=0\n    # iterate\
    \ through LIST\n    while [ $# -gt 0 ]\n    do\n        local ELEMENT=$1\n   \
    \     # count the total number of elements\n        ((TOTAL_ELEMENTS+=$ELEMENT))\n\
    \        # remove the first element from the list\n        shift\n    done\n \
    \   # check if there are three distinct elements in the list that\n    # sum to\
    \ zero\n    if [ $((TOTAL_ELEMENTS%3)) -eq 0 ]\n    then\n        # three distinct\
    \ elements sum to zero\n        return 0\n    else\n        # at least one element\
    \ sums to zero\n        return 1\n    fi", "    declare -a list\n    IFS=$' \\\
    t\\n' read -r -a list <<< \"$1\"\n    local n sum result\n    for n in \"${list[@]}\"\
    ; do\n        sum=0\n        for ((i = 0; i < ${#list[@]}; ++i)); do\n       \
    \     ((sum += ${list[i]}))\n        done\n        if (( sum == 0 )); then\n \
    \           result=true\n            break\n        fi\n    done\n    echo \"\
    $result\"", "    local lst_1=$1\n    local lst_2=$2\n    local lst_3=$3\n\n  \
    \  local triples_sum_to_zero_1=$(echo $lst_1 | tr ' ' '+' | grep '+')\n    local\
    \ triples_sum_to_zero_2=$(echo $lst_2 | tr ' ' '+' | grep '+')\n    local triples_sum_to_zero_3=$(echo\
    \ $lst_3 | tr ' ' '+' | grep '+')\n\n    if [[ -z \"${triples_sum_to_zero_1}\"\
    \ ]];\n    then\n        local triples_sum_to_zero=\"false\"\n    elif [[ -z \"\
    ${triples_sum_to_zero_2}\" ]];\n    then\n        local triples_sum_to_zero=\"\
    true\"\n    elif [[ -z \"${triples_sum_to_zero_3}\" ]];\n    then\n        local\
    \ triples_sum_to_zero=\"false\"\n    else\n        local triples_sum_to_zero=\"\
    false\"\n    fi\n\n    echo $triples_sum_to_zero", "    local numbers=\"${1}\"\
    \n    local triples=\n    for number in $numbers; do\n        triples=\"$triples\
    \ $(( (number + 0) * (number + 0) + 0 ))\"\n    done\n    triples_sum=$(( $triples\
    \ + 0 ))\n    echo $triples_sum == 0 &>/dev/null", "   local a b c d e f\n   a=$1\n\
    \   b=$2\n   c=$3\n   d=$(echo $a $b $c | sort -n | tail -n 1)\n   e=$(echo $a\
    \ $b $c | sort -n | head -n 1)\n   f=$(echo $a $b $c | sort -n | cut -d \" \"\
    \ -f 2)\n   if [ \"$d\" = \"$e\" ] && [ \"$e\" = \"$f\" ] ; then\n      return\
    \ 0\n   else\n      return 1\n   fi", "    local -i n sum\n    n=${#1}\n    sum=0\n\
    \    for (( i=0; i<${#1}; i++ )); do\n        sum=$(( $sum + ${1:$i:1} ))\n  \
    \  done\n    test -z \"$sum\" || return 1\n    test \"$(( (sum % 3 == 0) ))\"\
    \ -eq 0 && return 0\n    return 1", "    # initialize return value\n    sum=$((\
    \ ${1:-0} + 0 ))\n    triples=false\n\n    # loop until all numbers have been\
    \ checked\n    while [ $sum -gt 0 ]; do\n        # set variable $3 equal to $1\
    \ minus current number\n        (( triples )) && set -- $(( $1 - $sum ))\n\n \
    \       # if the current number equals zero, increment $sum and return true\n\
    \        if [ $triples = true ]; then\n            (( sum++ ))\n            triples=false\n\
    \            return\n        fi\n    done\n\n    # return true if the loop completes\
    \ no numbers equaling zero\n    echo true", "  local sum=0\n  local i\n  local\
    \ list=\"$1\"\n  for i in $(echo \"$list\" | tr \" \" \"\\n\"); do\n    ((sum+=i))\n\
    \  done\n  echo \"${list} has ${sum} distinct elements\"\n  echo \"$((${sum}==0))\"",
  "    local sum=0\n    for i in $*; do\n\t((sum+=i))\n    done\n    # $sum is now\
    \ a sum of all the elements in the list\n    # $2 will be false if the list contains\
    \ three distinct elements that sum to zero\n    # $2 will be true if there are\
    \ three distinct elements in the list that\n    # sum to zero.\n    if [ $sum\
    \ == 0 ]; then\n\techo $2\n    else\n\techo $3\n    fi", "  local list=\"$1\"\n\
    \  local result count sum\n  for count in $(seq 1 \"${#list}\"); do\n    sum=0\n\
    \    for element in $(seq 1 \"${count}\"); do\n      ((sum+=${list[element]}))\n\
    \    done\n    case \"${sum}\" in\n      0) result=false ;;\n      *) result=true\
    \ ;;\n    esac\n    if [ \"$result\" = \"true\" ]; then\n      break\n    fi\n\
    \  done\n  echo \"$result\"", "    local sum\n    # convert $1 to a list\n   \
    \ IFS=' ' read -r -a arr <<< \"$1\"\n    for sum in \"${arr[@]}\"; do\n      \
    \  if (( $(echo \"$sum * $sum\" | bc -l) == 0)); then\n            echo \"true\"\
    \n            return 0\n        fi\n    done\n    echo \"false\"\n    return 1",
  "  local l=\"$1\"\n  local sum=0\n  local llen=${#l}\n  local n3=0\n  local i\n\
    \  for (( i=0; i<${llen}; i++ )); do\n    ((sum += ${l:$i:1})) && n3=$((n3+1))\n\
    \  done\n  [[ -z \"$n3\" ]] && return 0\n  for (( i=0; i<${llen}; i++ )); do\n\
    \    (( sum += ${l:$i:1})) && n3=$((n3+1))\n  done\n  [[ $n3 -eq 3 ]] && return\
    \ 1\n  return 0", "    local -n arr=$1\n    local sum=0\n    for e in \"${arr[@]}\"\
    ; do\n        sum=$(($sum + $e))\n    done\n    [ $(($sum % 3)) -eq 0 ]", "  local\
    \ sum=0\n  local arr=( \"$@\" )\n  for i in \"${arr[@]}\"; do\n    (( sum += i\
    \ ))\n  done\n  (( sum == 0 )) && return 1 || return 0", "    local list=\"$1\"\
    \n\n    local list2=\"$(cat ${list})\"\n    local sum=$(echo $list2 | tr ' ' '\\\
    n' | awk '{print $1+$2+$3+0}')\n\n    if [ $sum -eq 0 ]; then\n        echo \"\
    false\"\n    else\n        echo \"true\"\n    fi", "\tlocal sum=0\n\tlocal count=0\n\
    \tlocal elements=()\n\tlocal list=\"$1\"\n\tlocal element\n\tread -a elements\
    \ <<< \"$list\"\n\tfor element in \"${elements[@]}\"; do\n\t\tsum=$(expr \"$sum\"\
    \ + \"$element\")\n\t\t(( count++ ))\n\tdone\n\tif [ \"$count\" -eq 3 ]; then\n\
    \t\techo \"true\"\n\telse\n\t\techo \"false\"\n\tfi", "  local list_line\n  local\
    \ elements\n  local elements_cnt\n  local element_0\n  local element_1\n  local\
    \ element_2\n  local elements_cnt_0\n  local elements_cnt_1\n  local elements_cnt_2\n\
    \  element_0=`echo $1 | awk '{print $1}'`\n  element_1=`echo $1 | awk '{print\
    \ $2}'`\n  element_2=`echo $1 | awk '{print $3}'`\n  elements=`echo $1 | awk '{print\
    \ $4}'`\n  elements_cnt=`echo $elements | wc -w`\n  if [ $elements_cnt -eq 0 ]\n\
    \  then\n    echo \"false\"\n    return 0\n  fi\n  if [ $elements_cnt -gt 2 ]\n\
    \  then\n    echo \"true\"\n    return 0\n  fi\n  elements_cnt_0=`echo $elements_cnt\
    \ | awk '{print $1}'`\n  elements_cnt_1=`echo $elements_cnt | awk '{print $2}'`\n\
    \  elements_cnt_2=`echo $elements_cnt | awk '{print $3}'`\n  if [ $elements_cnt_0\
    \ -eq $elements_cnt_1 ]\n  then\n    echo \"false\"\n    return 0\n  fi\n  if\
    \ [ $elements_cnt_1 -eq $elements_cnt_2 ]\n  then\n    echo \"true\"\n    return\
    \ 0\n  fi\n  echo \"false\"\n  return 1", "  local input_list=\"$1\"\n  local\
    \ list_length=\"$(echo \"$input_list\" | wc -w)\"\n  local number_list=\"$(echo\
    \ \"$input_list\" | tr -d ' ')\"\n  local result_list=\"$(echo \"$number_list\"\
    \ | sort -n | uniq -d)\"\n  echo \"${#result_list[@]}\" | grep -q 3", "   if [[\
    \ $1 =~ ^[0-9]+$ ]]; then\n      local num1=$(echo \"$1\" | cut -d \" \" -f1)\n\
    \      local num2=$(echo \"$1\" | cut -d \" \" -f2)\n      local num3=$(echo \"\
    $1\" | cut -d \" \" -f3)\n      (( num1=\"${num1}+num2\"))\n      (( num3=\"${num3}+num1\"\
    ))\n      (( num2=\"${num2}+num3\"))\n      if [[ $num1 == \"$num3\" && $num2\
    \ == \"$num3\" ]]; then\n         echo \"true\"\n      else\n         echo \"\
    false\"\n      fi\n   fi", "        local num=$1; shift\n        for ((i=1; i<$#;\
    \ i++)); do\n                num=\"${num} ${#num} ${num[i]}\"\n        done\n\
    \        echo ${num} | tr ' ' '+' | sort | uniq -c | grep -q '^ *3 ' && return\
    \ 0\n        echo ${num} | tr ' ' '+' | sort | uniq -c | grep -q '^ *2 ' && return\
    \ 0\n        echo ${num} | tr ' ' '+' | sort | uniq -c | grep -q '^ *1 ' && return\
    \ 0\n        echo \"false\"", "  local sum=0\n  local sum2=0\n  local found=0\n\
    \  local element\n  shift\n  for element in $@; do\n    sum=$(( sum + element\
    \ ))\n    sum2=$(( sum2 + element ))\n    if [ $sum -eq 0 ]; then\n      found=1\n\
    \    elif [ $sum -eq $sum2 ]; then\n      found=0\n    else\n      found=1\n \
    \   fi\n  done\n  echo \"$found\"", "    local num_list=\"$1\"\n    for num in\
    \ $num_list; do\n        # set flag if there are 3 distinct elements that sum\
    \ to zero\n        local count_three=0\n        if [[ $num_list == *$num* ]];\
    \ then\n            for num2 in $num_list; do\n                if [[ $num2 ==\
    \ *$num* ]]; then\n                    count_three=true\n                    break\n\
    \                fi\n            done\n        fi\n        if [[ $count_three\
    \ -eq 1 ]]; then\n            return 1\n        fi\n    done\n    return 0", " \
    \   local i sum\n    sum=0\n    for i; do\n        sum=$((sum + ${i}))\n    done\n\
    \    for i; do\n        sum=$((sum - ${i}))\n    done\n    echo \"${sum}\"", " \
    \   local sum=0\n    local sum_to_zero=0\n    for element in $1; do\n        sum=$((${sum}+$element))\n\
    \    done\n    for element in $1; do\n        sum_to_zero=$((${sum_to_zero}+${element}\
    \ == 0))\n    done\n    if [ \"${sum_to_zero}\" -eq \"3\" ]; then\n        return\n\
    \    else\n        echo true\n        return\n    fi", "    local list=$1\n  \
    \  local zeroes=$(echo \"$list\" | tr ' ' ',' | sed 's/,$//')\n    local zero_count=$(echo\
    \ \"$zeroes\" | wc -w)\n    local zeros=$(echo \"$list\" | tr ' ' ',' | sort -n\
    \ | sed 's/,$//')\n    local distinct_zeros=$(echo \"$list\" | tr ' ' ',' | sort\
    \ -n | sed 's/^0*\\(.*\\)$/\\1/')\n    local sum=0\n    for element in $list;\
    \ do\n      sum=$((sum + element))\n    done\n    if [ $zeros == $zero_count ]\
    \ && [[ $distinct_zeros != \"\" ]]; then\n      return 1\n    elif [ $zeros !=\
    \ $zero_count ] && [[ $distinct_zeros == \"\" ]]; then\n      return 0\n    else\n\
    \      return 1\n    fi", "  # sort puts the non-zero values at the beginning\
    \ of the array\n  # the unset -v says \"delete variable $VARNAME from the environment\
    \ before\n  #           executing the following command\"\n  # $3 is our list\
    \ of numbers\n  local array=( $( sort -n -k 1 <<<\"$1\" ) ); shift\n  local var=$1;\
    \ shift\n  local sum=$1; shift\n  local result=\"$1\"\n  # looping through list\
    \ elements\n  for i in \"${array[@]}\"; do\n    # adding each element to sum\n\
    \    sum=$(( ${sum}+$i ))\n    # if the sum is three distinct numbers, exit with\
    \ true\n    if [ $(( $sum % 3 )) -eq 0 ]; then\n      result=\"true\"\n      #\
    \ exit the loop\n      break\n    fi\n  done\n  # exit with result\n  echo $result",
  "  local list=$(echo $1 | tr ' ' ',')\n  local sum\n  for sum in $list; do\n   \
    \ if [[ $sum == *-* ]]; then\n      return 0\n    fi\n  done\n  return 1", " \
    \ local i i2 sum x1 x2 x3 x4 x5 x6\n  sum=0\n  for i in $1 do\n    sum=$(( sum\
    \ + i ))\n  done\n  x1=$1\n  x2=$(echo \"$1 $sum\" | sort -nr -k)\n  x3=$(echo\
    \ \"$1 $sum\" | sort -nr -k | tail -n 1)\n  x4=$(echo \"$1 $sum\" | sort -nr -k\
    \ | head -n 1)\n  x5=$1\n  x6=$(echo \"$1 $sum\" | sort -nr -k | tail -n 1)\n\
    \  for i in $(x1 $x2 $x3 $x4 $x5 $x6) do\n    if (( $i != $sum )); then\n    \
    \  return 0\n    fi\n  done\n  return 1", "    local list=\"$1\"\n    local sum\n\
    \    local count\n    local first\n    local last\n    sum=0\n    count=1\n  \
    \  first=1\n    last=\"${#list}\"\n    while [ $last -gt 0 ]; do\n        sum=$((\
    \ $sum + $list[$first] ))\n        count=$(( $count + 1 ))\n        first=$((\
    \ $first + 1 ))\n        last=$(( $last - 1 ))\n    done\n    if [ $count -eq\
    \ 3 ] && [ \"$sum\" -eq 0 ]; then\n        echo \"true\"\n    else\n        echo\
    \ \"false\"\n    fi", "    local IFS=$'\\n' list=\"$1\" triples_sum_to_zero=\"\
    false\"\n    while read list; do\n        declare -A listhash\n        for i in\
    \ \"${!list[@]}\"; do\n            listhash[\"$list[i]\"]=1\n        done\n  \
    \      if [ ${#listhash[@]} -eq 3 ]; then\n            triples_sum_to_zero=\"\
    true\"\n        fi\n    done <<<\"$list\"\n    echo \"$triples_sum_to_zero\"",
  "\t# Count how many distinct elements there are in $1 that sum up to zero.\n\t#\
    \ The result will be stored in $COUNT, or 0 if all elements of $1 sum up to zero.\n\
    \tlocal COUNT=0\n\tfor i in $@; do\n\t\t((COUNT++))\n\t\tif (( $COUNT > 2 ));\
    \ then\n\t\t\techo \"$COUNT elements sum to zero\"\n\t\t\treturn 0\n\t\tfi\n\t\
    done\n\techo \"$COUNT elements do not sum up to zero\"\n\treturn 1", "    declare\
    \ -i n\n    declare -i count=0\n\n    for (( n=1; n<=$1; n++ ))\n    do\n    \
    \    (( count++ ))\n    done\n\n    if [ $n -gt 3 ] && [ $n -le $1 ]\n    then\n\
    \        echo \"true\"\n    else\n        echo \"false\"\n    fi", "    local\
    \ list=\"$1\"\n    local sum=0\n    for element in $list; do\n        ((sum+=$(expr\
    \ \"$element\" +  0)))\n    done\n    [[ \"$sum\" -eq 0 ]]", "  local numbers=\"\
    $1\"\n  shift\n  echo \"${numbers}\"\n  for num in $numbers\n  do\n    echo \"\
    ${num} ${num} 0\"\n    if [ $num -gt 0 ]\n    then\n      echo \"${num} ${num}\
    \ ${num}\"\n      echo \"${num} ${num} ${num} ${num}\"\n      echo \"${num} ${num}\
    \ ${num} 0\"\n      echo \"${num} ${num} ${num} 0\"\n    fi\n  done", "  local\
    \ tmp=\"${1#* }\"\n  local tmp2\n  tmp2=$(echo \"$tmp\" | sort -u)\n  echo \"\
    $tmp2\" | grep -w \"0 \" | grep -qw \"0 $tmp2\"", "    local numlist=$1\n    local\
    \ sum=0\n    for num in $numlist; do\n        let sum+=${num}\n    done\n    if\
    \ [ $(($sum%3)) = 0 ]; then\n        return \"false\"\n    else\n        return\
    \ \"true\"\n    fi", "    local -n array=( \"$@\" )\n    local sum\n    local\
    \ i\n    local j\n    local k\n    local l\n\n    # Initialize sum array\n   \
    \ for i in \"${!array[@]}\"; do\n      sum=( 0 0 0 0 )\n      sum[$i]=1\n    done\n\
    \    for j in \"${!sum[@]}\"; do\n      i=${j}\n      while (( i > 0 )) ; do\n\
    \        (( ${sum[i]}++ ))\n        (( i-- ))\n      done\n    done\n    for k\
    \ in \"${!sum[@]}\"; do\n      if [[ ${sum[k]} -eq 0 ]]; then\n        echo \"\
    false\"\n        return 1\n      fi\n    done\n    echo \"true\"\n    return 0",
  "  local IFS=$1\n  local LIST=$2\n  local SUM=0\n\n  LIST=${LIST// /}\n  for ELEMENT\
    \ in $LIST; do\n    (( SUM += $ELEMENT))\n  done\n\n  [[ \"$SUM\" -eq 0 ]]", " \
    \   local tmp=\"${1//[!0-9.]/ }\"\n    local output=$(echo \"$tmp\" | sort -rV\
    \ | uniq -u -d | wc -l)\n    echo \"$output\"", "  local IFS=$1\n  local N=0\n\
    \  local O=0\n  local Q=$1\n  local A=()\n  local I=0\n  local T=$Q\n  while [\
    \ $T -gt 0 ]; do\n    A[$I]=$T\n    I=$((I + 1))\n    T=$(($T-1))\n  done\n  A[$I]=$T\n\
    \  I=$((I+1))\n  Q=$1\n  while [ $Q -gt 0 ]; do\n    T=`expr $A[$I] + $Q`\n  \
    \  if [ $T -gt 0 ]; then\n      O=`expr $O + 1`\n    fi\n    Q=$((`expr $Q - 1`))\n\
    \    I=$((I - 1))\n  done\n  echo $O", "    local tmp\n    local out\n    local\
    \ count\n\n    IFS=$' \\t\\n' read -ra T <<< \"$1\"\n    count=\"${#T[@]}\"\n\n\
    \    if [ \"$count\" -eq \"0\" ]; then\n        out=\"true\"\n        return\n\
    \    fi\n\n    for (( i = 0; i < count; i++ )); do\n        tmp=\"${T[i]}+${T[i+1]}\"\
    \n        if [ \"$tmp\" -eq \"0\" ]; then\n            out=\"true\"\n        \
    \    break\n        fi\n    done\n    out=$( echo \"$out\" | tr '\\n' '|' )\n\
    \    out=\"${out%|}\"\n    echo \"$out\"", "    local sum\n    sum=0\n    for\
    \ i in $1 do\n        [[ $i =~ ^[0-9]+$ ]] && sum=$((sum+$i)) || return\n    done\n\
    \    [[ $sum -eq 0 ]] && return 1 || return 0", "\tset -- $1 # set $1 to the first\
    \ parameter\n\n\tlocal triple\n\ttriple=true\n\n\twhile (( \"$#\" )); do\n\t\t\
    local element\n\t\telement=$(expr $2 + $3) # add $2 and $3\n\t\tif [ $element\
    \ -eq 0 ]; then\n\t\t\tif [ \"x$triple\" == \"xx\" ]; then\n\t\t\t\ttriple=false\n\
    \t\t\telse\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\tif [ \"$element\" != \"\
    x$triple\" ]; then # if $3 != $triple\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\t\
    shift\n\t\tshift\n\tdone\n\treturn $triple", "  local list=\"$1\"\n\n  # The function\
    \ will return false for lists of size 1, 0 or\n  # negative or just one element\n\
    \  local size=\"$(echo \"${list}\" | wc -l)\"\n  if [ \"${size}\" -eq 0 ] || [\
    \ \"${size}\" -gt 1 ]; then\n    return 0\n  fi\n\n  # We use an associative array\
    \ to keep track of the elements that\n  # have sums to zero\n  local sums=()\n\
    \n  # Keep looping over all the elements in the list\n  local element\n  for element\
    \ in $list; do\n    # If the current element is less than or equal to zero, then\n\
    \    # ignore it, otherwise add it to the sums array\n    if [ \"${element}\"\
    \ -le 0 ]; then\n      continue\n    else\n      local sum=\"$(( element + 0 ))\"\
    \n      if [ \"${sum}\" -le 0 ]; then\n        sum=\"-1\"\n      fi\n      local\
    \ found=0\n      for sum in \"${sums[@]}\"; do\n        # Add the current sum\
    \ to our sum array\n        if [ \"$sum\" == \"$sum\" ]; then\n          found=1\n\
    \          break\n        fi\n      done\n      if [ \"$found\" -eq 0 ]; then\n\
    \        sums[${#sums[*]}]=\"$sum\"\n      fi\n    fi\n  done\n\n  # At this point\
    \ we know that the list contains either zero or three\n  # distinct elements that\
    \ sum to zero.\n  # Since we only care about whether the list has three distinct\n\
    \  # elements, we can return true if there are three distinct elements\n  # in\
    \ the list that sum to zero.\n  # If there are two distinct elements in the list\
    \ that sum to zero, then\n  # we return false\n  # If there are only one distinct\
    \ element in the list that sums to zero,\n  # we return false\n  if [ \"${#sums[*]}\"\
    \ -eq 3 ]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi", "  local\
    \ result\n  for element in $*; do\n    local sum=0\n    for rest in $*; do\n \
    \     sum=$(($sum + $rest))\n    done\n    [ $sum -eq 0 ] && result=false || result=true\n\
    \  done\n  echo $result", "  local sum\n  sum=$(awk '{ for (i=1; i<=NF; ++i) {\
    \ sum += $i } print $sum }')\n  echo \"${sum}\"\n  (( sum == 0 )) && return 0",
  "    local x=\"$1\"\n    local -n x\n    local y\n    local z\n    local -n sum\n\
    \n    if [ \"$x\" = \"\" ]; then\n        echo \"$0: empty list\" >&2\n      \
    \  return 1\n    fi\n\n    local -n xs=\"${!x}\"\n    local i=0\n    local z=0\n\
    \    local sum\n    local num\n    local -n first=\"$(echo \"$x\" | awk '{print\
    \ $1}')\"\n    local -n second=\"$(echo \"$x\" | awk '{print $2}')\"\n    local\
    \ -n third=\"$(echo \"$x\" | awk '{print $3}')\"\n    local -n first2\n    local\
    \ -n second2\n    local -n third2\n    local -n final\n    local -n count\n\n\
    \    if [ \"$first\" == \"$second\" ] || [ \"$third\" == \"$first\" ]; then\n\
    \        echo \"$0: same first two elements\" >&2\n        return 1\n    fi\n\n\
    \    for y in \"$xs\"; do\n        if [ \"$y\" = \"$first\" ]; then\n        \
    \    count=$(( count + 1 ))\n            first2=\"$second\"\n            second2=\"\
    $third\"\n        elif [ \"$y\" = \"$second\" ]; then\n            count=$(( count\
    \ + 1 ))\n            first2=\"$first\"\n            second2=\"$third\"\n    \
    \    elif [ \"$y\" = \"$third\" ]; then\n            count=$(( count + 1 ))\n\
    \            first2=\"$first\"\n            second2=\"$second\"\n        fi\n\n\
    \        if [ $(( count % 3 )) -eq 0 ]; then\n            z=$(( z + 1 ))\n   \
    \     fi\n    done\n\n    sum=$(( z + 1 ))\n    num=$(( num + sum ))\n\n    for\
    \ y in \"$xs\"; do\n        if [ \"$y\" = \"$first2\" ] || [ \"$y\" = \"$second2\"\
    \ ] || [ \"$y\" = \"$third2\" ]; then\n            sum=$(( sum + 1 ))\n      \
    \      num=$(( num + sum ))\n        fi\n    done\n\n    if [ $num -eq $(( 3 *\
    \ sum )) ]; then\n        final=\"true\"\n    else\n        final=\"false\"\n\
    \    fi\n\n    echo \"$final\"", "    local sum=0\n    local elements=$(echo $1\
    \ | sed 's/ /\\n/g')\n    for element in $elements; do\n\t((sum+=$(echo $element\
    \ | cut -d ' ' -f 1)))\n    done\n    ((sum>2))", "  local i sum zero=0 triples_sum_to_zero=0\
    \ is_sum_to_zero=false;\n  sum=$(echo $1 | sed 's/ /+/g');\n  zero=$(echo $1 |\
    \ sed 's/-/+0/g');\n  triples_sum_to_zero=0;\n  for i in $1 do\n    [[ $i == $sum\
    \ ]] && triples_sum_to_zero=1 || triples_sum_to_zero=0;\n  done\n  is_sum_to_zero=$((triples_sum_to_zero\
    \ == 0));\n  echo $is_sum_to_zero", "    local arr=($1)\n    local sum=0\n   \
    \ for i in \"${arr[@]}\"; do\n        (( sum += i ))\n    done\n    echo $(( sum\
    \ == 0 ))", "\tlocal lines=$(cat $1 | tr \"\\n\" \" \")\n\tlocal num=0\n\tlocal\
    \ n=0\n\tlocal sum=0\n\tlocal sum2=0\n\tlocal found=0\n\tfor line in $lines; do\n\
    \t\tnum=$((num + $line))\n\tdone\n\tfor line in $lines; do\n\t\tsum=$((num - sum))\n\
    \t\tif (( $sum == 0 )); then\n\t\t\tfound=1\n\t\tfi\n\tdone\n\tfor line in $lines;\
    \ do\n\t\tsum2=$((num - sum))\n\t\tif (( $sum2 != 0 )); then\n\t\t\tfound=1\n\t\
    \tfi\n\tdone\n\tif (( $found == 0 )); then\n\t\treturn 1\n\telse\n\t\treturn 0\n\
    \tfi", "    local -n array=( )\n    for i in $*; do array+=( $i ); done\n    local\
    \ -n result=( )\n    local -n nums=( )\n    for i in \"${array[@]}\"; do\n   \
    \     if (( i % 3 )); then\n            results+=( $i )\n        else\n      \
    \      nums+=( $i )\n        fi\n    done\n    if (( ${#results[@]} != 3 )) ;\
    \ then\n        return 0\n    else\n        for (( c=0; c<3; c++ )); do\n    \
    \        if (( ${nums[c]} != 0 )); then\n                return 0\n          \
    \  fi\n        done\n        return 1\n    fi", "  # echo \"$1\"\n  # echo \"\
    ${1//[[:space:]]/}\"\n  local ret=\"false\"\n  local sum=0\n  local elements=\"\
    ${1//[[:space:]]/}\"\n  echo \"${elements}\"\n  IFS=' ' read -ra array <<< \"\
    $elements\"\n  for element in \"${array[@]}\"; do\n    ((sum=sum+$element))\n\
    \  done\n  if (( (sum == 0) && (${#array[@]} > 2) )); then\n    ret=\"true\"\n\
    \  else\n    ret=\"false\"\n  fi\n  echo \"$ret\"", "\tlocal i\n\tlocal -a list\n\
    \tlist=\"$1\"\n\tlocal -a sums\n\tsums=()\n\tfor ((i=0; i<${#list}; i++))\n\t\
    do\n\t\tsums[${#sums[*]}]=0\n\tdone\n\tsum=${sums[0]}\n\tfor ((i=0; i<${#list};\
    \ i++))\n\tdo\n\t\t((sum+=${list[i]}))\n\t\t((sums[${#sums[*]}]++))\n\t\tif [[\
    \ \"${sums[${#sums[*]} - 2]}\" -ne 0 ]]\n\t\tthen\n\t\t\treturn false\n\t\tfi\n\
    \t\tif [[ \"${sums[${#sums[*]} - 1]}\" -ne 0 ]]\n\t\tthen\n\t\t\treturn false\n\
    \t\tfi\n\tdone\n\treturn true", "  # Parse parameters\n  local x\n  for x in \
    \ $*; do\n    if [[ x == \"0\" ]]; then\n      return 0\n    fi\n  done\n\n  #\
    \ Scan the list for three elements that sum to zero\n  local i j\n  for ((i=0;\
    \ i<${#x[@]}; i++)); do\n    ((j=0))\n    for ((j=0; j<${#x[@]}; j++)); do\n \
    \     ((j+=i+1))\n      if ((${#x[@]}-j)) < ${#x[@]} && [[ ${x[${j}]} == ${x[${j+1}]}\
    \ ]]; then\n        break\n      fi\n    done\n    if [[ ${j} >= 3 ]]; then\n\
    \      return 1\n    fi\n  done\n\n  return 0", "  local sums=$(echo \"$1\" |\
    \ tr \" \" \"\\n\")\n  local n=0\n  local result=\"false\"\n  for i in $sums\n\
    \  do\n    ((n++))\n    result=\"$result\" && [ $i -eq 0 ]\n  done\n  echo \"\
    $result\"", "    local IFS=\"$1\"\n\n    local -a lines\n    local line sum=0\n\
    \n    read -r line\n    while [[ \"$line\" =~ ^-?[0-9]+$ ]]; do\n        lines+=(\"\
    $line\")\n        read -r line\n    done\n    sum=$(echo \"${lines[*]}\" | tr\
    \ ' ' '\\n' | sort -n | tail -n +2 | head -n 1 | tr -d '\\n')\n    local c\n \
    \   for (( c = 0; c < 3; c++ )); do\n        if [ \"$sum\" == \"0\" ]; then\n\
    \            return 1\n        fi\n        sum=$(( sum - lines[0] ))\n    done\n\
    \    return 0", "    local sum=0\n    for i in $*; do\n        let \"sum+=i\"\n\
    \    done\n    if [[ $sum -eq 0 ]]; then\n        return \"false\"\n    else\n\
    \        let \"sum-=sum%3\"\n        if [[ \"$sum\" -eq 0 ]]; then\n         \
    \   return \"true\"\n        else\n            return \"false\"\n        fi\n\
    \    fi", "  local list=\"$1\"\n  if [ \"$list\" == \"\" ]; then\n    echo \"\
    ERROR: Input must be given as a space-separated list.\"\n    echo \"Usage: $(basename\
    \ $0) <integers>\"\n    return 1\n  fi\n  if [ \"${#list}\" -eq 0 ]; then\n  \
    \  echo \"ERROR: Input must be given as a space-separated list.\"\n    echo \"\
    Usage: $(basename $0) <integers>\"\n    return 1\n  fi\n  local x1 x2 x3 x4 x5\
    \ x6 x7 x8 x9\n  x1 x2 x3 x4 x5 x6 x7 x8 x9=$(echo $list | tr ' ' '\\n')\n  local\
    \ sum\n  local count x3 x6 x9 z\n  local i\n  sum=$(( ${x1}+${x2}+${x3}+${x4}+${x5}+${x6}+${x7}+${x8}+${x9}\
    \ ))\n  for i in {1..9}; do\n    count=$(( $count+1 ))\n    z=$(( ${x$i} ))\n\
    \    if [ $z -eq $sum ]; then\n      return 0\n    fi\n  done\n  return 1", " \
    \ local n=$1 sum\n  for ((i=0; i<n; i++))\n    do\n      sum=$(( $i + $sum + $i\
    \ ))\n    done\n  if [ $sum = 0 ]\n      then\n    echo \"false\"\n  else\n  \
    \  echo \"true\"\n  fi", "  local list=\"$1\"\n  local sum\n  local count\n  sum=0\n\
    \  count=0\n  for e in $list; do\n    sum=$(( $sum + $e ))\n    count=$(( $count\
    \ + 1 ))\n  done\n  echo \"$count $sum\"", "    local _triples=$@\n    local _zero=0\n\
    \    local _three=0\n    local _found=0\n\n    echo \"${_triples}\" | while read\
    \ _one; do\n        _found=0\n        local _next=\"${_one} 0 ${_one} 0\"\n  \
    \      echo \"${_triples}\" | while read _next; do\n            if [ \"$(echo\
    \ \"${_next}\" | cut -d\" \" -f1)\" = \"${_one}\" ]; then\n                if\
    \ [ \"$(echo \"${_next}\" | cut -d\" \" -f3)\" = \"0\" ]; then\n             \
    \       _zero=$((_zero + 1))\n                fi\n                if [ \"$(echo\
    \ \"${_next}\" | cut -d\" \" -f3)\" = \"3\" ]; then\n                    _three=$((_three\
    \ + 1))\n                    _found=1\n                fi\n            fi\n  \
    \      done\n    done\n\n    if [ \"${_found}\" = \"1\" ]; then\n        echo\
    \ \"true\"\n    else\n        echo \"false\"\n    fi", "\tlocal list_num=\"\"\n\
    \tlocal num_list=\"\"\n\tlocal num_sum=0\n\tlocal num_distinct=0\n\tlocal num_zero=0\n\
    \tfor element in $1\n\tdo\n\t\tlist_num+=$element\n\tdone\n\tlist_num=$(echo $list_num\
    \ | tr \" \" \"\\n\")\n\n\tfor element in $list_num\n\tdo\n\t\tnum_list+=$element\n\
    \tdone\n\n\tfor element in $num_list\n\tdo\n\t\tnum_sum=$((num_sum + element))\n\
    \tdone\n\n\tfor element in $num_list\n\tdo\n\t\tnum_distinct=$((num_distinct +\
    \ 1))\n\tdone\n\n\tif (( num_distinct > 2 ))\n\tthen\n\t\techo \"false\"\n\telse\n\
    \t\techo \"true\"\n\tfi", "    local elements=( \"$@\" )\n\n    local numElements=${#elements[@]}\n\
    \    if [[ $numElements -lt 3 ]]; then\n        echo \"$0: List has less than\
    \ three elements!\"\n        exit 1\n    fi\n\n    local sumToZero=0\n    for\
    \ element in ${elements[@]}; do\n        local sum=$(echo $element | awk '{s+=$1}\
    \ END {print s}')\n        if [[ $sum -ne 0 ]]; then\n            sumToZero=false\n\
    \            break\n        fi\n    done\n\n    echo \"$sumToZero\"", "\tlocal\
    \ -n arr=$1\n\tlocal sum=0\n\n\tfor i in \"${arr[@]}\"; do\n\t\tif [ \"$sum\"\
    \ -lt 0 ]; then sum=$((sum+i)); fi\n\tdone\n\n\t[ \"$sum\" = 0 ]", "    set --\
    \ $@\n    # use an associative array to store the values\n    declare -A array\n\
    \    # initialize array variables\n    declare -A sum\n\n    # loop through the\
    \ numbers in $1 list\n    for x in $@; do\n        # split into three parts\n\
    \        # the first part is the number itself\n        # the last part is if\
    \ the number has a negative sign\n        # the middle part is if the number is\
    \ positive\n        IFS=\"- \" read a b c <<< \"$x\"\n        # set $sum[\"$a\"\
    ] to 0 if $a is not in sum\n        (( ${!a[$a]} )) && sum[$a]=0\n        # set\
    \ $sum[\"$b\"] to 0 if $b is not a positive number\n        (( ${!b[b]} )) &&\
    \ sum[$b]=0\n        # set $sum[\"$c\"] to 0 if $c is not a positive number\n\
    \        (( ${!c[c]} )) && sum[$c]=0\n        # set $sum[\"$a+$b+$c\"] to 1 if\
    \ three elements in the list sum to zero\n        (( sum[$a+$b+$c] )) && array[$a+$b+$c]=1\n\
    \    done\n    # return true if three elements in $1 sum to zero\n    ! ${#array[@]}",
  "    # declare variables\n    declare -a elements=($1)\n    local -i j=0\n    local\
    \ n=1\n    local result=\"false\"\n    local elem\n\n    # check whether there\
    \ are three elements in the list that sum to zero.\n    while [[ $n -lt ${#elements[@]}\
    \ ]]; do\n        elem=${elements[$n]} # element at position n\n        if [[\
    \ $elem == -* ]]; then\n            # negative elements are allowed\n        \
    \    ((n++))\n        elif (( elem != 0 )) && [[ $elem != $((${elements[$n]}))\
    \ ]]; then\n            # check whether all elements except the one at position\
    \ n sum to zero\n            result=\"true\"\n            break\n        fi\n\
    \        ((n++))\n    done\n\n    # return result\n    echo \"$result\"", "  local\
    \ nums=$1 sum=0 max=$((${#nums}-1)) sums=()\n  # we first sort the input list\
    \ to make sure we find triples\n  sort -n <<< \"${nums}\" >/dev/null 2>&1\n  #\
    \ we then loop over all numbers in the input list\n  # the first iteration will\
    \ cause the previous sum to go negative and\n  # we know that we will find a triple\n\
    \  while ((${max} > 0)); do\n    (( ${sum} += ${nums[$((${max}-1))]} ))\n    ((\
    \ ${max} -= 1 ))\n    (( ${sum} == 0 )); sums=( \"${sums[@]}\" \"$sum\" )\n  done\n\
    \  # we finally check the last sum, since we know that the input list has\n  #\
    \ at least three distinct elements that sum to zero\n  [[ ${#sums[@]} -eq 3 ]]\
    \ && return 0\n  return 1", "    echo $(grep -E \"[0-9]\\|-[0-9]\\|-[0-9]\\|-[0-9]\"\
    \ <<< \"$1\") | awk '{ for(i=2; i<=NF; i++) s+=$i; if(s>0) print \"true\"; else\
    \ print \"false\"}'", "    local list=\"${1:-}\"\n    local sum=$(echo \"${list}\"\
    \ | tr -d '\\n' | sed \"s/ //g\")\n    echo \"${list} contains ${#list} elements,\
    \ all of them are ${sum}\"\n    local three\n    for ((i=0; i<${#list}; i++));\
    \ do\n        three=0\n        local elem\n        for ((j=0; j<${#sum}; j++));\
    \ do\n            elem=\"${list[i]} ${list[j]}\"\n            if [[ ${sum:$j:1}\
    \ == ${elem} ]]; then\n                ((three+=$j))\n            fi\n       \
    \ done\n        if ((three==3)); then\n            echo \"true\"\n           \
    \ return 0\n        fi\n    done\n    echo \"false\"\n    return 1", "    local\
    \ -i x=0\n    local i sum\n    local sums\n    local found\n    sums=$1\n    sum=${sums:0:1}\n\
    \    while [ \"$sums\" != \"\" ]; do\n        found=false\n        for (( i=0;\
    \ i < $x; i++ )); do\n            if [ $(expr $sum + $sums$i | bc) -eq 0 ]; then\n\
    \                sums=$sums$i\n                sum=$sum\n                found=true\n\
    \                break\n            fi\n        done\n        if [ \"$found\"\
    \ == \"false\" ]; then\n            sums=${sums%?}\n            sum=${sums:0:1}\n\
    \            x=$(( $x + 1 ))\n        fi\n    done\n    if [ \"$sum\" -eq 0 ];\
    \ then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi", "  local\
    \ -r numbers=\"$1\"\n  if [[ \"$numbers\" == *\" \"* ]]; then\n    numbers=\"\
    $(echo \"$numbers\" | sed -e 's/ /\\n/g')\"\n  fi\n  local -r ret=0\n  local -a\
    \ sorted_numbers=()\n  local -r element_count=0\n  local -a counts=()\n  local\
    \ -r zeros=()\n  local -r nonzero_sum=0\n  for n in \"$numbers\"; do\n    ((element_count++))\n\
    \    nonzero_sum=$(( nonzero_sum + n ))\n    sorted_numbers+=(\"$n\")\n    counts+=(\"\
    $n\")\n  done\n  if (( element_count < 3 )); then\n    ret=0\n  else\n    for\
    \ (( i=1; i<element_count; i++ )); do\n      local curr_element=${sorted_numbers[i]}\n\
    \      if (( counts[i - 1] == 0 )); then\n        zeros[(( i - 1 ))]=$curr_element\n\
    \      else\n        counts[i - 1]=$(( counts[i - 1] + 1 ))\n      fi\n      if\
    \ (( counts[i - 1] > 1 )); then\n        (( ret++ ))\n      fi\n    done\n  fi\n\
    \  printf -v \"${FUNCNAME[1]}\" \"%s\" \"$nonzero_sum\"\n  printf -v \"${FUNCNAME[1]}\"\
    \ \"%s\" \"$ret\"\n  printf -v \"${FUNCNAME[1]}\" \"%s\" \"$zeros\"\n  printf\
    \ -v \"${FUNCNAME[1]}\" \"%s\" \"$counts\"\n  echo \"${FUNCNAME[1]}\"", "   local\
    \ tmp_list\n   tmp_list=($(echo $1 | tr ' ' '\\n' | grep -v '^#' | grep -v '^$'))\n\
    \   if (( ${#tmp_list} % 3 )); then return 1; else return 0; fi", "   local numbers=\"\
    $1\"\n   local result=0\n\n   for number in $numbers\n   do\n      ((result+=$((number))));\n\
    \   done\n\n   if (( $result == 0 )); then\n      echo \"true\";\n   else\n  \
    \    echo \"false\";\n   fi", "  local arr\n  IFS=' ' read -r -a arr <<< \"$1\"\
    \n  for ((i=0; i<${#arr[@]}; i++))\n  do\n    local sum=\"$((${arr[i]}+${arr[i+1]}))\"\
    \n    if [ \"${arr[i]}\" = \"${arr[i+1]}\" -a \"${arr[i]}\" = \"${sum}\" ]\n \
    \   then\n      echo \"true\"\n      return 0\n    fi\n  done\n  echo \"false\"\
    \n  return 0", "  local -r sum=$1\n  local count=0\n  local -a sums\n  local -r\
    \ zero=0\n  local zero1\n  local zero2\n  local -r first=$1\n  shift\n  local\
    \ -a rest\n  local -a firsts\n  local -a rests\n  rests=()\n  firsts=()\n  while\
    \ [[ $# -gt 0 ]]; do\n    local first=$1\n    shift\n    firsts+=(\"$first\")\n\
    \    rest+=($1)\n    rests+=(\"$1\")\n  done\n  # check if there is atleast two\
    \ distinct elements\n  if [[ ${#firsts[*]} -gt 1 ]]; then\n    echo \"false\"\
    \ # return as no triples\n    return 0\n  fi\n  # check if there is atleast two\
    \ distinct elements\n  if [[ ${#firsts[*]} -eq 1 ]]; then\n    if [[ \"${firsts[0]}\"\
    \ == \"0\" ]]; then\n      echo \"true\" # return as triples\n      return 1\n\
    \    fi\n  fi\n  # sort lists so that zero is always at the beginning\n  # i.e.\
    \ sort rests and firsts\n  rest=($(echo \"${rests[*]}\" | tr \" \" \"\\n\" | sort\
    \ | uniq ))\n  first=($(echo \"${firsts[*]}\" | tr \" \" \"\\n\" | sort | uniq\
    \ ))\n  if [[ \"${first[0]}\" == \"0\" ]]; then\n    zero=$first[0]\n  else\n\
    \    zero=0\n  fi\n  for i in $(seq 1 $((${#rests[*]} - 1))); do\n    if [[ \"\
    ${first[i]}\" == \"${first[i - 1]}\" ]]; then\n      first[i]=\"${first[i - 1]}\"\
    \n      firsts[$i]=\"${first[i]}\"\n    fi\n  done\n  for i in $(seq 1 $((${#rests[*]}\
    \ - 1))); do\n    for j in $(seq 1 $((${#firsts[*]} - 1))); do\n      if (( i\
    \ == j && ${firsts[i]} > ${firsts[j]}\n             && ${firsts[i]} > ${zero}\
    \ )) || \\\n         (( i < j && ${firsts[i]} > ${firsts[j]} )) || \\\n      \
    \   (( i > j && ${firsts[i]} > ${firsts[j]} )) ; then\n        zero1=$first[j]\n\
    \        zero2=$first[i]\n      fi\n    done\n  done\n  if (( ${#firsts[*]} >\
    \ 2 )); then\n    # find triples\n    for i in $(seq 0 ", "    local LIST=\"$(echo\
    \ $1 | sed 's/ /\" \"/g')\"\n    local NUMBER=$(echo \"$LIST\" | sort -n | head\
    \ -n 1)\n    local ZERO=$(echo $LIST | sed -n 's/^\\s*\\(.*\\)\\s*0$/\\1/p')\n\
    \    if [ -z \"$ZERO\" ]; then\n        echo \"false\"\n    else\n        echo\
    \ \"true\"\n    fi", "\tlocal a b c d e\n\ta=$1\n\tb=$2\n\tc=$3\n\td=$4\n\te=$5\n\
    \tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0) ? -e : e\"\n\tlet \"a = (a\
    \ < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\tlet \"c = (c < 0) ? -c :\
    \ c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0) ? -e : e\"\n\tlet \"\
    a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\tlet \"c = (c < 0) ?\
    \ -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0) ? -e : e\"\n\t\
    let \"a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\tlet \"c = (c <\
    \ 0) ? -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0) ? -e : e\"\
    \n\tlet \"a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\tlet \"c =\
    \ (c < 0) ? -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0) ? -e\
    \ : e\"\n\tlet \"a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\tlet\
    \ \"c = (c < 0) ? -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e < 0)\
    \ ? -e : e\"\n\tlet \"a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b : b\"\n\
    \tlet \"c = (c < 0) ? -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"e = (e\
    \ < 0) ? -e : e\"\n\tlet \"a = (a < 0) ? -a : a\"\n\tlet \"b = (b < 0) ? -b :\
    \ b\"\n\tlet \"c = (c < 0) ? -c : c\"\n\tlet \"d = (d < 0) ? -d : d\"\n\tlet \"\
    e = (e < 0) ? -e : e\"\n\tlet \"a = (a < 0) ? -a : a\"\n", "  # Split $1 into\
    \ its elements.\n  local list=\"$1\"\n  list=\"$list\"\n\n  # Get count of distinct\
    \ elements.\n  local count=\"$(echo \"$list\" | sort -u | wc -l)\"\n\n  # If count\
    \ is 3, then the input list contains three distinct integers\n  # that sum to\
    \ zero.\n  [[ \"$count\" -eq 3 ]]", "    local -n l=$1\n    local -n sum=0\n \
    \   local -n threeDistinct=0\n    for k in \"${l[@]}\"; do\n        (( sum +=\
    \ k ))\n        if (( sum != 0 && sum != -1 && sum != -2 )); then\n          \
    \  (( threeDistinct ++ ))\n        fi\n    done\n    if (( threeDistinct == 0\
    \ )); then\n        echo \"false\"\n    else\n        echo \"true\"\n    fi",
  "    local sum=0\n    local elems=$1\n    local three=0\n    for i in $elems; do\n\
    \        if [[ \"$sum\" == \"0\" ]]; then\n            three=0\n        elif ((\
    \ $(expr \"$sum\" + \"$i\" )) > 0 ); then\n            three=1\n        fi\n \
    \       ((sum = $i + $sum))\n    done\n    [[ \"$three\" -gt 0 ]]", "    (( $#\
    \ > 0 )) && return 0 # empty lists are always false\n    local i j x result sum\n\
    \    sum=0\n    for (( i = 1; i <= $#; i++ )); do\n        result=0\n        for\
    \ (( j=$i; j <= $#; j++ )); do\n            (( j > i )) && break\n           \
    \ result=$(( result + $j % 2 ))\n        done\n        (( sum+=result ))\n   \
    \ done\n    (( sum > 0 )) && return 0\n    return 1", "  local L=${1//[[:space:]]/}\n\
    \  for i in ${L[@]}; do\n    case $i in\n      *) ;;\n        0) return 0;;\n\
    \        -*) return 1;;\n    esac\n  done\n  return 0", "\techo \"${@}\" | awk\
    \ '{n=split($1,a,\" \"); for(i=1;i<=n;i++){ sum+=$i; if(sum>0) return 0; }}'",
  "  local IFS= # Don't try to parse spaces in strings\n  local a=$1\n  echo \"${a}\"\
    \ | tr -d '\"' | tr -d \",\" | sort -u | head -n 3 | \\\n  while read -a b; do\n\
    \    [[ \"$b\" =~ ^-[0-9]+$ ]] && echo \"$a\" == \"${b#-}\" || return 1\n  done",
  "    local input=${1%% *}\n    # echo \"$input\"\n    local inputarray=($input)\n\
    \    local unique_inputarray=($(sort <<<\"$inputarray\" | uniq))\n    local result\n\
    \    for i in \"${unique_inputarray[@]}\"; do\n        result=0\n        local\
    \ j=0\n        for j in \"${!inputarray[@]}\"; do\n            local arrayinput=(${inputarray[@]:$j:1})\n\
    \            local sum=$(echo \"${arrayinput[*]}\" | awk '{s+=$1;} END {print\
    \ s}')\n            if (( sum == 0 )); then\n                result=1\n      \
    \          break\n            fi\n        done\n        if [ \"$result\" -eq 1\
    \ ]; then\n            echo \"$i\"\n            return 0\n        fi\n    done\n\
    \    return 1", "    local i\n    for ((i=0; i < $#; i++ )); do\n        local\
    \ v=$(($i + 1))\n        local c=$(($((${#1}) % ${#v})))\n        local sum=${#1}\n\
    \        (( sum -= $c )) && return 0\n        [[ $v != ${#1} ]] && return 0\n\
    \        [[ $sum -eq 0 ]] && return 1\n    done\n    return 0", "    local -n\
    \ list=$1\n    local -n sum=0\n    local -n first_nonzeropoint=1\n    local -n\
    \ second_nonzeropoint=0\n    local -n third_nonzeropoint=0\n\n    for element\
    \ in \"${list[@]}\"; do\n        (( sum += element ))\n        if (( sum == 0\
    \ )); then\n            first_nonzeropoint=1\n            second_nonzeropoint=0\n\
    \            third_nonzeropoint=0\n        elif (( sum != 0 )) && (( $element\
    \ == 0 )); then\n            second_nonzeropoint=1\n            third_nonzeropoint=0\n\
    \        elif (( sum != 0 )) && (( $element != 0 )); then\n            third_nonzeropoint=1\n\
    \        fi\n    done\n\n    if (( $first_nonzeropoint == 1 )); then\n       \
    \ if (( $second_nonzeropoint == 1 )); then\n            if (( $third_nonzeropoint\
    \ == 1 )); then\n                echo \"true\"\n            else\n           \
    \     echo \"false\"\n            fi\n        else\n            echo \"false\"\
    \n        fi\n    else\n        echo \"false\"\n    fi", "  local _elements=(\"\
    ${@// /}\")\n  local _elements_sorted=(\"${_elements[@]}\" | sort -n | uniq)\n\
    \n  if [[ $_elements_sorted == *\"0\"* ]]; then\n    echo \"true\"\n  else\n \
    \   echo \"false\"\n  fi", "    local IFS=' '\n    local a=\"$1\"\n    echo \"\
    $a\" | grep -P -o '(?<=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\d)(?=\\\
    d)", "    local -a elements\n    local -a sums\n    local -a elements\n    local\
    \ -a elements\n    local -a elements\n    local -a elements\n    local -a elements\n\
    \n    IFS=$' \\t' read -ra elements <<< \"$1\"\n    IFS=$' \\t' read -ra sums\
    \ <<< \"$1\"\n\n    local -a results\n    results=()\n    for element in \"${elements[@]}\"\
    ; do\n        local sum\n        sum=0\n        for sum in \"${sums[@]}\"; do\n\
    \            (( sum == element )) && continue\n            (( sum += element ))\n\
    \            results[${#results[*]}]=$sum\n        done\n    done\n    local numResults\n\
    \    numResults=${#results[*]}\n    (( numResults == 3 )) && return 0\n    ((\
    \ numResults == 4 )) && return 1\n    return 0", "    local elements=$1\n    local\
    \ sum_of_elements=0\n    local count_of_elements=0\n    local true_value=0\n \
    \   local false_value=0\n    local result=0\n\n    for element in ${elements//[[:space:]]/\
    \ }; do\n        sum_of_elements+=$element\n        count_of_elements++\n    \
    \    if (( count_of_elements == 3 )); then\n            true_value=1\n       \
    \ fi\n        if (( count_of_elements > 3 )); then\n            false_value=1\n\
    \        fi\n    done\n    if (( ${sum_of_elements} == 0 )); then\n        result=1\n\
    \    else\n        result=0\n    fi\n    if (( ${true_value} )) && \\\n    ( ${false_value}\
    \ )) && \\\n    ( ${result} )) && \\\n    ( ${result} > 0 )\n    then\n      \
    \  echo \"true\"\n    else\n        echo \"false\"\n    fi", "    local input=\"\
    $1\"\n    # Using this awk command instead of 'for i; do echo $i; done' is \n\
    \    # because the input list is long and 'for i' runs out of memory \n    # if\
    \ the input is long. awk command runs in constant memory\n    local count=0\n\
    \    local out=\"$(echo \"$input\" | awk '{if ($1+$2+$3 ==0) count++}')\"\n  \
    \  echo \"$out\"", "  local sum=0\n  local array\n  local i\n\n  # Split $1 into\
    \ array\n  array=($1)\n\n  for ((i=0; i < ${#array[@]}; ++i)); do\n    sum=$((\
    \ sum + ${array[i]} ))\n  done\n\n  # If there are three distinct elements that\
    \ sum to zero, return true\n  if [ $((sum % 3)) -eq 0 ]; then\n    return 0\n\
    \  else\n    return 1\n  fi", "  local sum=0\n  for elem in $1; do\n    sum=$((\
    \ sum + elem ))\n  done\n  local n=0\n  local first=0\n  local last=0\n  local\
    \ middle=0\n  local check=0\n  local last2=0\n  local middle2=0\n  for elem in\
    \ $1; do\n    (( n++ ))\n    if [ $n -eq 1 ]; then\n      first=$elem\n    elif\
    \ [ $n -eq 2 ]; then\n      last=$elem\n      check=1\n    elif [ $n -eq 3 ];\
    \ then\n      middle=$elem\n      check=1\n    elif [ $n -eq 4 ]; then\n     \
    \ last2=$elem\n      middle2=$elem\n      check=1\n    fi\n  done\n  if [ $check\
    \ ]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi", "  local input=$1\n\
    \  local count=0\n  local sum=0\n  for i in $input; do\n    ((sum+=i))\n    ((count+=1))\n\
    \  done\n  ((count==2))", "    if [[ -z $1 ]]; then\n        echo \"ERROR: no\
    \ input file supplied\"\n        exit 1\n    fi\n    set -- $1\n    local arg\n\
    \    local j\n    local nums\n    local found\n    local result\n    nums=()\n\
    \    found=0\n    for arg in \"$@\"; do\n        ((found+=${#nums[*]})) #keep\
    \ a running count\n        for j in $arg; do\n            ((j-=found)); #count\
    \ how many times j appears in arg\n            if (( j == 0 )); then #once a 0\
    \ is found, return true\n                echo \"$found\"\n                exit\
    \ 0\n            fi\n            nums+=(\"$j\")\n        done\n    done", "\t\
    local i j k sum1 sum2 sum3 \n\tsum1=0\n\tsum2=0\n\tsum3=0\n\ti=0\n\tj=1\n\tk=1\n\
    \twhile (( $j < ${#1} ))\n\tdo\n\t\t(( k=$k % ${#1} ))\n\t\tsum1=$(( sum1 + ${1}[$j]\
    \ ))\n\t\tj=$(( j + 1 ))\n\t\tif (( $sum1 == 0 ))\n\t\tthen\n\t\t\tsum2=$(( sum2\
    \ + ${1}[$k] ))\n\t\t\t(( k=$k % ${#1} ))\n\t\t\tsum3=$(( sum3 + ${1}[$k] ))\n\
    \t\tfi\n\tdone\n\tif (( $sum3 == 0 ))\n\tthen\n\t\techo \"false\"\n\telse\n\t\t\
    echo \"true\"\n\tfi", "    set -- $1;\n    local num;\n    local i;\n\n    for\
    \ num in \"$@\"; do\n        if (( num != 0 )); then\n            i=1;\n     \
    \       while (( i <= 4 )); do\n                if (( $( echo \"$num + $(( num\
    \ + 1 )) | bc\" ) -eq 0 )); then\n                    return 0;\n            \
    \    fi\n                if (( $( echo \"$num + $(( num + i )) | bc\" ) -eq 0\
    \ )); then\n                    return 1;\n                fi\n              \
    \  if (( $( echo \"$num + $(( num - i )) | bc\" ) -eq 0 )); then\n           \
    \         return 1;\n                fi\n                i=$(( i + 1 ));\n   \
    \         done;\n        fi;\n    done;\n    return 1;", "    local list_input=\"\
    $1\"\n    # loop over the input list\n    for i in $(seq 1 \"${#list_input}\"\
    ); do\n        # get the current element from the list\n        element=\"${list_input::$i}\"\
    \n        # initialize a temporary list to hold possible sums\n        sums=()\n\
    \        # loop over all remaining elements\n        for j in $(seq \"$((i + 1))\"\
    ; do\n            sums+=(\"${list_input:$j:2}\")\n        done\n        # get\
    \ the current sum\n        sum=\"${sums[0]}\"\n        # loop over all remaining\
    \ sums\n        for j in \"${!sums[@]}\"; do\n            if (( sum == 0 )); then\n\
    \                # if the current sum is 0, the list contains three distinct elements\n\
    \                return 1\n            fi\n            sum=\"${sum+${sums[j]}+${sums[$((j\
    \ + 1))]}}\"\n        done\n    done\n    # return false as no triplets can be\
    \ summed to zero\n    return 0", "    local a b c d\n    for (( a=0 ; a<$#; a++\
    \ )); do\n        b=`echo $1 | sed -n \"$a p\"`\n        d=`echo $1 | sed -n \"\
    $a + 1 p\"`\n        c=`echo $1 | sed -n \"$a + 2 p\"`\n        d=${d:+$d}\n \
    \       echo $(( $b + $c + $d )) | bc -l\n    done", "    local list=\"$1\"\n\
    \    local sum=0\n    for i in $list; do\n        ((sum += i))\n    done\n   \
    \ ((sum > 3))", "    # Sanitize input\n    echo \"$1\" | sed 's/ //g' | sed 's/^/#!/bin/bash\\\
    n/' | \\\n        grep \"^[0-9]\\+$\" | sort | uniq -c | grep -E '^ *3 *$'", " \
    \   local i\n    local count\n    local sum\n    local three_count\n    local\
    \ three\n    local false\n\n    for i in $(echo $1 | sed -r \"s/[\\[\\] ]+/ /g\"\
    ); do\n        count=0\n        sum=0\n        while [ -n \"$i\" ] && [ \"$i\"\
    \ != -n \"$i\" ]; do\n            ((sum+=$(echo $i | sed -r \"s/^([0-9]+) *\\\
    ([0-9]+\\) *\\([0-9]+\\)/\\2/\"))) || break\n            ((count+=$(echo $i |\
    \ sed -r \"s/^([0-9]+) *\\([0-9]+\\) *\\([0-9]+\\)/1/\"))) || break\n        \
    \    i=${i%?}\n        done\n        if (( $count >= 3 )) && (( $sum == 0 ));\
    \ then\n            three=$1\n            three_count=3\n        fi\n    done\n\
    \n    if (( $three_count != 0 )); then\n        false\n    else\n        true\n\
    \    fi", "\tlocal a=\"$1\"\n\tlocal b=\"$2\"\n\tlocal c=\"$3\"\n\techo \"${a[@]:$((1+${#a[@]})):3}\"\
    \n\techo \"${a[@]:$((1+${#a[@]})):1}\"\n\techo \"${a[@]:$((1+${#a[@]})):2}\"\n\
    \techo \"${a[@]:$((1+${#a[@]})):0}\"", "    local sum_to_zero=0\n    local in_range=0\n\
    \    for arg; do\n      in_range=1\n      sum_to_zero=0\n      for i in ${arg};\
    \ do\n        if [ \"$i\" -eq \"$(( $sum_to_zero + 1 ))\" ]; then\n          in_range=0\n\
    \          break\n        fi\n        sum_to_zero=$(( $sum_to_zero + 1 ))\n  \
    \    done\n      if [ \"$in_range\" -eq \"1\" ]; then\n        break\n      fi\n\
    \    done\n    if [ \"$in_range\" -eq \"1\" ]; then\n      return 1\n    else\n\
    \      return 0\n    fi", "  local elements=(\"$@\")\n  local count=0\n  local\
    \ elements_sorted=(\"$@\")\n  local result=0\n  local last_element=0\n\n  for\
    \ element in \"${elements_sorted[@]}\"; do\n    ((count+=element))\n    if [[\
    \ \"$count\" -gt 0 ]]; then\n      if (( count == 0 )) && (( elements_sorted[$((\
    \ last_element+1 ))] -eq \"$element\" )) {\n        result=1\n        break\n\
    \      else\n        result=0\n        break\n      fi\n    fi\n    ((last_element=element))\n\
    \  done\n\n  echo \"$result\"", "    local sum\n    sum=$(echo $1 | grep -o \"\
    [0-9]*\" | sort -u | wc -c)\n    if (( $sum == 3 )); then\n        return 0\n\
    \    else\n        return 1\n    fi", "    local input=$1\n    local triples=$input\n\
    \    local triples_sum_to_zero_output=\"false\"\n    local last_element=\"\"\n\
    \    local last_element_value=0\n\n    for element in $triples; do\n        local\
    \ element_value=$(echo \"$element\" | bc)\n        local element_value_abs=$(echo\
    \ \"$element_value\" | abs)\n        local element_value_neg_abs=$(echo \"$element_value\"\
    \ | bc -l)\n        local last_element_value_abs=$(echo \"$last_element_value\"\
    \ | bc)\n\n        if [ \"$last_element_value_abs\" = \"$element_value_abs\" ];\
    \ then\n            if [ \"$last_element_value_abs\" -eq \"$element_value_neg_abs\"\
    \ ]; then\n                if [ \"$element_value_abs\" -eq 0 ]; then\n       \
    \             triples_sum_to_zero_output=\"true\"\n                    break\n\
    \                else\n                    triples_sum_to_zero_output=\"false\"\
    \n                    break\n                fi\n            else\n          \
    \      triples_sum_to_zero_output=\"false\"\n                break\n         \
    \   fi\n        else\n            last_element_value=$element_value\n        \
    \    last_element=$(echo \"$element\" | bc)\n        fi\n    done\n    echo \"\
    $triples_sum_to_zero_output\"", "  local list=\"$1\"\n  local unique_list\n  local\
    \ count=1\n  unique_list=0\n  while [[ $list =~ (^|\\s+) ]]; do\n    unique_list=$((unique_list+$count))\n\
    \    list=${list#*($(echo $list|sed 's/ //'))}\n    ((count++))\n  done\n  echo\
    \ $((${unique_list} == 3))", "    # Parse arguments as single number or list\n\
    \    local IFS=\" \" # make IFS space instead of default \\\n    local list=$($1\
    \ read) \n\n    echo \"$list\" | grep -Fv \"^0\" # grep is non-greedy, so it will\
    \ stop at the first 0", "  local list_sum=0\n  list_sum=$(echo \"$1\" |\n    \
    \         sed -e 's/^/+/g' -e 's/ $//g' -e 's/^ \\(\\([0-9]\\+\\) \\) \\(\\([0-9]\\\
    +\\) \\) \\(\\([0-9]\\+\\) \\) \\(\\([0-9]\\+\\)$/\\1 \\2 \\3 \\4 \\5/')\n  ((\
    \ $list_sum == 0 ))", "    local input=\"$1\"\n    local sum\n    local count\
    \ true\n    local -a count\n\n    sum=0\n    count=()\n\n    for number in $input;\
    \ do\n        count[$number]=1\n    done\n\n    for number in ${!count[@]}; do\n\
    \        sum=$(( $sum + $number ))\n        if [ $sum -eq 0 ]; then\n        \
    \    true\n        fi\n    done\n\n    echo $(( $count == ${!count[@]} ))", " \
    \   local -n x=\"$1\"\n    local -a sums=()\n    local -i j=0\n    local -a pairs=()\n\
    \    for v in \"${x[@]}\"; do\n        (( j++ ))\n        sums[$j]=0\n       \
    \ for (( i=1; i<j; i++ )); do\n            local v1 v2\n            v1=${sums[$i]}\n\
    \            v2=${v}\n            (( v1+=v2 ))\n            sums[$i]=$v1\n   \
    \     done\n    done\n    (( j-- ))\n    local -a elements=(${sums[@]:0:j})\n\
    \    [[ -z ${elements[0]} ]]", "    local list=\"${1:-$2}\"\n    local sum=0\n\
    \n    for element in $list\n    do\n        ((sum += $element))\n    done\n\n\
    \    [[ -z $list ]] && return 1\n    [[ -z $sum ]] && return 1\n    [[ -z \"$sum\"\
    \ ]] && return 1\n\n    local count=0\n    local max=0\n    local min=0\n    for\
    \ element in $list\n    do\n        local sum2=0\n        for n in $list\n   \
    \     do\n            ((sum2 += $n*$element))\n        done\n        if (( $sum2\
    \ == $sum ))\n        then\n            ((count ++))\n            if (( $count\
    \ >= 3 ))\n            then\n                return 0\n            fi\n      \
    \  fi\n        ((max += $element))\n        ((min += $element))\n    done\n\n\
    \    if (( $min < $max ))\n    then\n        return 0\n    fi\n    return 1",
  "  # If there are no elements, return immediately.\n  if [ -z \"$1\" ]\n  then\n\
    \    return 0\n  fi\n\n  # Create a set of integers\n  integer_set=( \"$1\" )\n\
    \n  # Create a set of triples (<triple> is a space-separated list)\n  triples_set=(\
    \ $(echo \"$integer_set\" | tr ' ' \"\\n\" ) )\n  # Create a set of triples that\
    \ sum to zero\n  triples_sum_to_zero_set=( $(echo \"$triples_set\" | tr '\\n'\
    \ ' ' | sed -E 's/^/0 /' | sort -u | tr '\\n' ' ' | sed -E 's/^/0 /' | sort -u\
    \ | tr '\\n' ' ' | sed -E 's/^/0 /' | sort -u ) )\n\n  # Check the triples_sum_to_zero_set\n\
    \  check_triples_sum_to_zero=\"$(echo \"$triples_sum_to_zero_set\" | tr '\\n'\
    \ ' ' | sed -E 's/^/0 /' | sort -u | tr '\\n' ' ' | sed -E 's/^/0 /' | sort -u\
    \ | tr '\\n' ' ' | sed -E 's/^/0 /' | sort -u | tr '\\n' ' ')\"\n  if [ \"$check_triples_sum_to_zero\"\
    \ = \"$check_triples_sum_to_zero\" ]\n  then\n    return 0\n  else\n    return\
    \ 1\n  fi", "    local i j sum sums\n    sums=\"\"\n    sum=\"$1\"\n    shift\n\
    \    for ((i=0; i<${#sum}; i++)); do\n        j=$((i+1))\n        sums=$sums\"\
    ,\"$sum\n        sum=\"$(( sum - ${sums[j]}))\"\n        if [[ $sum -eq 0 ]];\
    \ then\n            echo \"true\"\n            return 0\n        fi\n    done\n\
    \    echo \"false\"\n    return 1", "\twhile [ $# -gt 0 ]; do\n\t\t[ $1 -eq 0\
    \ ]\n\t\t[ \"$2\" -gt 0 ] && break\n\t\t(( 1 += $2 ))\n\t\t(( 2 *= $2 ))\n\t\t\
    shift\n\tdone\n\t[ \"$1\" -eq 0 ] && return 0\n\t[ \"$1\" -gt 0 ] && return 1\n\
    \treturn 0", "\tlocal list=$(echo $1 | sed 's/ /\" \"/g')\n\tlocal total=$(echo\
    \ \"$list\" | awk '{for(i=1;i<=NF;i++) sum+=$i; print sum}')\n\t(( $total != 0\
    \ && $total == 3 ))", '  echo "$1" | grep -q "[[:digit:]]" && echo "true" || echo
    "false"', "    set -- $(( $(echo \"$1\" | tr ' ' '\\n' | sed 's/^/+/g' | sed 's/\
    \ /\\+/g') ))\n    local sum first\n    local seen=()\n    while [[ $# -gt 0 ]];\
    \ do\n        local i\n        sum=0\n        IFS=$'\\n' read -r -a array <<<\
    \ \"$1\"\n        for i in \"${array[@]}\"; do\n            (( sum += i ))\n \
    \           if (( ${#seen[@]} > 0 )) && (( sum == 0 )); then\n               \
    \ return 0\n            fi\n            seen+=(\"$i\")\n        done\n       \
    \ shift\n    done\n    return 1", "    local sum=0 a=$1\n    local b=$(( ${#a}\
    \ - 1 ))\n    for (( i = 0; i <= b; i++ )); do\n        sum=$(( $sum + ${a} ))\n\
    \    done\n    echo $(( $sum == 0 ))", "\tlocal -i n x\n\tfor (( n = 0; n < ${#1};\
    \ n++ )); do\n\t\tx=$(expr $1 + ${1:$n})\n\t\tif [ ${#x} -ne 3 ]; then\n\t\t\t\
    return 0\n\t\tfi\n\t\t(( n == ${#1} ))\n\t\tif [ ${x:-0} -ne 0 ]; then\n\t\t\t\
    return 1\n\t\tfi\n\tdone\n\treturn 0", "    triples_sum_to_zero $1 \\\n      \
    \  | sed 's/^\\s*//g' \\\n        | tr '\\n' '-' \\\n        | xargs -0 -n 1 echo\
    \ > /dev/null 2>&1", "  local sum=0\n  local num=1\n  for i in $*\n  do\n    ((\
    \ sum += num ))\n    num=$(( num * 3 ))\n  done\n  [[ $sum == 0 ]]", "  IFS='\
    \ ' read -r -a array <<< \"$1\"\n\n  for ele in \"${array[@]}\"; do\n    (( ele\
    \ != 0 )) && return 0\n  done\n  return 1", "\tlocal L=$1\n\tlocal S=0\n\tlocal\
    \ F=0\n\tfor N in $L; do\n\t\t((S+=N))\n\tdone\n\tfor N in $L; do\n\t\t((F+=N))\n\
    \tdone\n\t((F==0 and S==3 and F>0))", "  local l=$1\n  local sum=$(echo $l | sed\
    \ 's/ / + /g' | bc | tr -d '\\n' | sed 's/ +$//')\n  local zero=$(echo $l | sed\
    \ 's/ / + /g' | bc | tr -d '\\n' | sed 's/ +$//')\n  local negative=$(echo $l\
    \ | sed 's/ / + /g' | bc | tr -d '\\n' | sed 's/ +$//')\n  echo $(( $sum == $zero\
    \ ))", "  local list=$1\n  local output\n  for element in $list; do\n    local\
    \ sum=$(( element + sum))\n    output=false\n    for element2 in $list; do\n \
    \     local sum2=$(( element2 + sum))\n      if [ $sum -eq $sum2 ]; then\n   \
    \     output=true\n        break\n      fi\n    done\n    if [ $output ]; then\n\
    \      break\n    fi\n  done\n  echo $output", "  declare -i n result\n  IFS=\"\
    \ \" read -ra ary <<<\"$1\"\n  for n in \"${ary[@]}\"; do\n    if [[ $n -gt 0\
    \ ]]; then\n      result=0\n      for ((i=0; i<n; i++)); do\n        result=$((result\
    \ + $i))\n      done\n      if [[ $result -eq 0 ]]; then\n        echo \"true\"\
    \n        return 1\n      fi\n    fi\n  done\n  echo \"false\"\n  return 0", " \
    \ local IFS=' '\n  local sorted\n  sorted=( $(echo ${@} | tr ' ' '\\n' | sort\
    \ -n) )\n  local c\n  local -a sums\n  local first\n  local last\n  local sum\n\
    \  local count\n  local found\n  # Sum from first to last, ignoring negatives\n\
    \  sum=0\n  for i in \"${sorted[@]}\"; do\n    (( sum += i ))\n  done\n  # Check\
    \ if three sums are equal\n  count=1\n  found=false\n  for (( first=1; first<${#sorted[@]};\
    \ first++ )); do\n    last=$(( first+count ))\n    sum=${sums[$first]}\n    if\
    \ [ \"$sum\" == \"0\" ]; then\n      found=true\n      break\n    elif [ \"$sum\"\
    \ -lt \"$sums[$last]\" ]; then\n      found=false\n      break\n    else\n   \
    \   # Increment counter\n      (( count++ ))\n    fi\n  done\n  echo $found",
  "  local set sum=0\n  local count=0\n  local max=0\n  local threes=\n  for element\
    \ in $1; do\n    local value=$element\n    sum=$(($sum+$value))\n    count=$(($count+1))\n\
    \    max=$(($max+1))\n  done\n\n  if (( $count > $max )); then\n    threes=false\n\
    \  elif (( $count == $max )); then\n    threes=true\n  else\n    threes=$(( $count\
    \ == 3 ))\n  fi\n  echo \"$threes\"", "  local xs ys zs\n  xs=$1 ys=$2 zs=$3\n\
    \  local num\n  for ((i=0; i < $#; i+=3)); do\n    num=$(( ${xs:$i} + ${ys:$i}\
    \ + ${zs:$i} ))\n    [ $num -eq 0 ] || [[ $xs == \"$num\" ]]\n  done", "     \
    \   local -i sum $2\n        for (( sum = 0; sum < $1; sum += 2 ))\n        do\n\
    \                echo \"$sum\"\n        done\n        echo \"$(( $1 + $2 + $3\
    \ + $4 ))\"\n        echo \"$(( $1 + $2 + $3 + $4 ))\" > \"$2\"", "    local -r\
    \ list_name=\"$1\"\n    local line\n    # If the list is empty, return success\n\
    \    if [ ${#list_name} -eq 0 ] ; then\n        return 0\n    fi\n    # If the\
    \ list contains more than one item, return failure\n    if [ ${#list_name} -gt\
    \ 1 ] ; then\n        return 1\n    fi\n    local -a list=(${list_name})\n   \
    \ local line\n    # If the list contains three items, return success\n    if [\
    \ ${#list[3]} -eq 3 ] ; then\n        return 0\n    fi\n    # If the list contains\
    \ more than three items, return failure\n    if [ ${#list[3]} -gt 3 ] ; then\n\
    \        return 1\n    fi\n    # Sort the list\n    list=$(IFS=,; echo \"${list[*]}\"\
    \ | sort)\n    # Iterate through the list\n    local i j\n    for ((i=0; i< ${#list};\
    \ i++)); do\n        line=\"${list[i]}\"\n        # Iterate through each item\
    \ in the list except for the i'th item\n        for ((j=0; j<i; j++)); do\n  \
    \          # If the item in the i'th list is an integer and is less than zero,\n\
    \            # then we can return failure\n            if [ ${line} -eq ${list[j]}\
    \ -a ${line} -lt 0 ] ; then\n                return 1\n            fi\n      \
    \  done\n        # If the item in the i'th list is an integer and is equal to\
    \ the sum of the\n        # three items in the i'th list plus one, return failure\n\
    \        if [ ${line} -eq ${list[i]} -a ${list[i]} -eq ${list[i]}+1 ] ; then\n\
    \            return 1\n        fi\n    done\n    # If the list contains all integers\
    \ and is greater than or equal to three, return success\n    return 0", "  local\
    \ -r list=( $1 )\n  local -n arr=list\n  local -i i\n  local -a sum=()\n  local\
    \ -n zeros=()\n  for (( i=0; i<${#arr[@]}; i++ )); do\n    sum+=( ${arr[i]} )\n\
    \    if (( i == 0 )); then\n      zeros+=( ${arr[i]} )\n    else\n      if ((\
    \ arr[i] != 0 )); then\n        zeros+=( ${arr[i]} )\n        break\n      fi\n\
    \    fi\n  done\n  for i in \"${!zeros[@]}\"; do\n    if (( sum[i] == 0 )); then\n\
    \      return 1\n    fi\n  done\n  for i in \"${!sum[@]}\"; do\n    if (( zeros[i]\
    \ == 1 )); then\n      return 0\n    fi\n  done\n  return 1", "    local l\n \
    \   # Parse the list into tokens\n    l=$1\n    shift 1\n    # Loop through the\
    \ list\n    for ii in $l; do\n        # Break out of the loop when we find an\
    \ item that doesn't sum to zero\n        if [ \"$ii\" = \"$((ii%2==0)?ii-1:ii-$((ii%2==0?ii+1:ii)))\"\
    \ ]; then\n            echo \"false\"\n            exit 0\n        fi\n    done\n\
    \    echo \"true\"", "  # We use an associative array to keep track of how many\
    \ times the number\n  # appears in $1, and we only increment the number if it's\
    \ found not to\n  # count it.\n  declare -A nums\n  # The list of integers is\
    \ split into words to keep it simple. Thus, we use\n  # \"IFS=' ' read -r -a nums_array\
    \ <<< \"$1\"\n  # to split it into words.\n  IFS=' ' read -r -a nums_array <<<\
    \ \"$1\"\n  # Iterate over each word in $1, and increase the number in $1 whenever\
    \ it\n  # appears in the list.\n  for i in \"${nums_array[@]}\"; do\n    (( nums[$i]++\
    \ ))\n  done\n  # Check whether any number in $1 appears three times in the array.\n\
    \  local count=0\n  for num in \"${nums[@]}\"; do\n    (( count++ ))\n  done\n\
    \  return $(( count > 2 ))", "  declare -i n\n  local sum=0 nsum=0 result=0\n\
    \  while read -r n; do\n    ((nsum += n))\n    if [[ \"${nsum}\" -eq \"$sum\"\
    \ ]]; then\n      result=true\n      break\n    fi\n    ((sum += n))\n  done\n\
    \  echo \"$result\"", "  local num_list=$1\n  local i\n  local sum\n  local element\n\
    \n  sum=0\n  for i in $num_list; do\n    ((sum += $i))\n  done\n  \n  if (( (sum\
    \ == 0) && ($num_list != \"\") )) ; then\n    echo \"true\"\n  else\n    echo\
    \ \"false\"\n  fi", "    local num_elements=${#1}\n    if [ $num_elements -eq\
    \ 0 ]\n    then\n        echo \"false\"\n    else\n        local num=0\n     \
    \   local num_distinct=0\n        local num_elements_sum_to_zero=0\n\n       \
    \ for ((i=1; i<$num_elements; i++))\n        do\n            if [ $((${1:i}+num))\
    \ -eq 0 ]\n            then\n                num_elements_sum_to_zero=$((num_elements_sum_to_zero+1))\n\
    \            else\n                num_distinct=$((num_distinct+1))\n        \
    \    fi\n            num=$((${1:i}+num))\n        done\n\n        if (( $num_distinct\
    \ == 3 ))\n        then\n            echo \"true\"\n        else\n           \
    \ echo \"false\"\n        fi\n    fi", "  local sum=0\n  local insum\n  local\
    \ i\n  for i in $(echo $1 | sed 's/^ *//g'); do\n    (( sum += i ))\n  done\n\
    \  insum=0\n  for i in $(echo $1 | sed 's/^ *//g'); do\n    (( insum += i ))\n\
    \  done\n  if [ $insum -eq 0 ]; then \n    echo \"false\"\n  else\n    echo \"\
    true\"\n  fi", "  local a b c\n  # Parse each input string as a space-separated\
    \ list\n  for a in \"$@\"; do\n    # Parse each element in the list as a space-separated\
    \ list\n    for b in $a; do\n      # Parse each element in the list as a space-separated\
    \ list\n      for c in $b; do\n        if (( ${#a} != ${#b} ) || ( ${#a} != ${#c}\
    \ )) ; then\n          return 1\n        fi\n      done\n    done\n  done\n  #\
    \ Return false if all three distinct elements in the list sum to\n  # zero\n \
    \ return 0", "    local -n list=$1\n    local sum=0\n    local counter=1\n   \
    \ local answer=\"false\"\n\n    list=($(echo $list | sed 's/[[:space:]]//g'))\n\
    \n    for element in ${list[*]}; do\n        if (( counter > 2 )); then\n    \
    \        answer=\"false\"\n            break\n        fi\n        sum=$(( sum\
    \ + element ))\n        counter=$(( counter + 1 ))\n    done\n\n    if (( sum\
    \ == 0 )); then\n        answer=\"true\"\n    fi\n\n    echo \"$answer\"", " \
    \ local set sum i\n  IFS=' ' read -r -a array <<< \"$1\"\n  for sum in \"${array[@]}\"\
    ; do\n    for (( i = 0; i < ${#array[@]}; i++ )); do\n      if [[ ${array[$i]}\
    \ -eq $sum && ${array[$((i+1))]} -eq $sum && \\\n          ${array[$((i+2))]}\
    \ -eq $sum ]]; then\n        echo \"true\"\n        return\n      fi\n    done\n\
    \  done\n  echo \"false\"", "    local -n numbers=$1\n    local sum=0\n    for\
    \ number in $numbers; do\n        sum=$((sum + number))\n    done\n    if [ $sum\
    \ -eq 0 ]; then \n        return false\n    else\n        return true\n    fi",
  "    local tmp=$(echo \"$1\" | sed -E 's/^(-?[0-9]+) (\\d+) (-?[0-9]+) (\\d+)$/\\\
    1 \\2\\3/')\n    if [ $(echo \"$tmp\" | sort | uniq -d) == \"0 1 2 3\" ]; then\n\
    \        echo \"true\"\n    else\n        echo \"false\"\n    fi", "  local list=\"\
    $1\"\n  local -a nums\n  nums=( ${list//,/ } )\n  local sum=\"${nums[*]}\"\n \
    \ local -a zero\n  zero=( ${list} $(( ${#nums[@]} - 1 )) )\n  for (( i=0; i<${#zero[@]};\
    \ i++ )); do\n    local j=$(( ${i} + 1 ))\n    (( \"${zero:$i}\" ) = 0 )\n   \
    \ (( \"${zero:$j}\" ) = 0 )\n    (( \"${sum:$i}\" ) = 0 )\n    (( \"${sum:$j}\"\
    \ ) = 0 )\n    (( \"${nums[$i]}\" + ${nums[$j]} ))\n  done\n  true", "  IFS='\
    \ ' read -r -a array <<< \"$1\"\n  local sum\n  local i\n  for (( i=0; i < ${#array[@]};\
    \ i++ )); do\n    sum=\"${array[$i]}\"\n    sum=\"${sum}+${array[$i+1]}\"\n  \
    \  sum=\"${sum}+${array[$i+2]}\"\n    if [ \"$sum\" -eq 0 ]; then\n      return\
    \ 1\n    fi\n  done\n  return 0", "  local L\n  L=$1\n  if [ -z \"$L\" ]; then\n\
    \    echo \"Usage: triples_sum_to_zero L\"\n    return 1\n  fi\n\n  local i\n\
    \  for ((i=1; i<${#L}-1; i++)) ; do\n    local j\n    for ((j=i+1; j<${#L}; j++))\
    \ ; do\n      local k\n      local l\n      local m\n      for ((k=0; k<${#L};\
    \ k++)) ; do\n        l=$(( $l + ${L}[k] ))\n      done\n      if [ -z \"$l\"\
    \ ]; then\n        echo \"ERROR: L[$i] has no integer sum to zero\"\n        return\
    \ 2\n      fi\n      m=$(( $m + $l ))\n    done\n    if [ $m -gt 0 ]; then\n \
    \     echo \"ERROR: L[$i] has more than one distinct sum to zero\"\n      return\
    \ 2\n    fi\n  done\n  echo \"true\"", "    IFS='' read -ra array <<< \"$1\"\n\
    \    count=0\n    for i in \"${array[@]}\"\n    do\n        count=$((count+i))\n\
    \    done\n    if [ $((count%3)) -eq 0 ]; then\n        echo \"true\"\n    else\n\
    \        echo \"false\"\n    fi", "    # convert to a map\n    declare -A map\n\
    \    # populate the map\n    for n in $*; do\n        map[\"$n\"]=\"$n\"\n   \
    \ done\n    # traverse the map\n    for k in ${!map[@]}; do\n        ((sum=map[\"\
    $k\"]+map[\"$k\"]+map[\"$k\"]))\n        if ((sum==0)); then\n            return\
    \ 1\n        fi\n    done\n    return 0", "  [[ -z \"$1\" ]] && return 1\n  \n\
    \  local IFS=\" \"\n  local -n array=\"${!1}\" #preserve name\n  local sum\n \
    \ local count\n  local count0\n  local sum0\n  \n  for sum in \"${!array[@]}\"\
    ; do\n    ((count0=count+=array[sum])) #count the occurence\n    ((sum0=sum0+sum))\
    \ #sum the occurence\n    ((sum0=sum0-sum)) #remove sum from sum0\n  done\n\n\
    \  count0=$((count0==3)) #true if 3 distinct elements have sum to zero\n\n  echo\
    \ \"$count0\"", "    local -r x=\"$1\"\n    local total=0\n    local -a list\n\
    \    for x in $x; do\n        total=$(($total + x))\n        list=(\"${list[@]}\"\
    \ $x)\n    done\n    if (( $total != 0 )); then\n        return false\n    else\n\
    \        local -n found=\n        for x in \"${list[@]}\"; do\n            if\
    \ (( ${#list[@]} > 0 )); then\n                if (( $x == ${list[*]} && ${list[@]}\
    \ != 0 ));then\n                    found=1\n                    break\n     \
    \           fi\n            fi\n        done\n        if (( $found )); then\n\
    \            return true\n        else\n            return false\n        fi\n\
    \    fi", "    local l\n    local num1=$1\n    local num2=$2\n    local num3=$3\n\
    \    local sum1=$((num1+num2))\n    local sum2=$((num2+num3))\n    local sum3=$((num3+num1))\n\
    \    local count1=0\n    local count2=0\n    local count3=0\n    local equal1=false\n\
    \    local equal2=false\n    for l in $l ; do\n        [ $l -eq $sum1 ] && { ((count1++))\
    \ || equal1=true; }\n        [ $l -eq $sum2 ] && { ((count2++)) || equal2=true;\
    \ }\n        [ $l -eq $sum3 ] && { ((count3++)) || equal2=true; }\n    done\n\
    \    if $equal1 && ! $equal2 && ! $equal3 ; then\n        echo \"$num1 plus $num2\
    \ plus $num3 = zero\"\n    else\n        echo \"$num1 plus $num2 plus $num3 !=\
    \ zero\"\n    fi", "  local sum=0 result=false\n  while IFS=$' \\t' read -r i\
    \ j; do\n    (( sum += i ))\n  done < <(echo \"$1\")\n  case \"$sum\" in\n   \
    \ 3) result=true ;;\n    *) result=false;;\n  esac\n  echo \"$result\"", "   \
    \ local n=$1 count=0\n    [[ \"$n\" =~ ^[0-9]+$ ]] || return\n    local array=(\
    \ $( echo $n | sed 's/ /\\n/g' | awk '{print $1}') )\n    for i in \"${array[@]}\"\
    ; do\n        [[ -z $i ]] && continue\n        (( count++ ))\n    done\n    [[\
    \ \"$count\" -eq 3 ]] || return\n    echo true", "  local list=\"$1\"\n  local\
    \ sum=0\n  local i\n\n  for i in $(echo $list | tr \" \" \"\\n\"); do\n    ((sum+=i))\n\
    \  done\n  (( sum == 0 )) && return 0\n  (( sum > 0 )) && return 1", "  local\
    \ sum\n  sum=\"$( echo $1 | cut -d' ' -f1 )\"\n  local nums\n  nums=\"$( echo\
    \ $1 | cut -d' ' -f2-$( echo $1 | wc -l ) )\"\n  local i\n  for (( i = 1; i <=\
    \ $( echo $nums | wc -l ); i++ )); do\n    (( sum += $( echo $nums | sed -n \"\
    $i p\" ) ))\n  done\n  echo $(( $sum == 0 ))", "    local list=\"$1\"\n    local\
    \ output=\"false\"\n\n    local numbers=$(echo \"$list\" | xargs printf '%d ')\n\
    \    local sum=$(echo $numbers | sed 's/ /+/g' | bc)\n    local number\n\n   \
    \ for number in $numbers; do\n        if (( number != 0 )); then\n           \
    \ local tmp=$(echo $sum | bc)\n            if [ $tmp -eq 0 ]; then\n         \
    \       output=\"true\"\n                break\n            fi\n        fi\n \
    \       sum=$(( $sum - $number ))\n    done\n\n    echo \"$output\"", "  local\
    \ array\n  array=( \"$@\" )\n  local i\n  for i in \"${!array[@]}\"; do\n    local\
    \ j\n    local k\n    local tmp\n    local length\n    length=$(expr $(( ${#array[@]}\
    \ - 1 )))\n    for j in $(seq 0 $(( length - 1 ))); do\n      if [[ ${array[$j]}\
    \ == *\"${array[$((j + 1))]}\"* ]]; then\n        k=$(expr $j + 1)\n        break\n\
    \      fi\n    done\n    if [[ ${array[$k]} != *\"${array[$k]}\"* ]]; then\n \
    \     tmp=\" \"\n      tmp=${array[$k]} $tmp\n      array[$k]=$tmp\n      array[$((\
    \ k + 1 ))]=$tmp\n    fi\n  done\n  if (( $(echo \"${array[@]}\" | wc -w) %3 ));\
    \ then\n    echo false\n  else\n    echo true\n  fi", "    local i j k total\n\
    \    local result=\"$1\"\n    while read -r i; do\n        total=0\n        for\
    \ j; do\n            for k; do\n                if (( i == $j && k == $k )) &&\
    \ [ \"$total\" -gt 0 ]; then\n                    result=\"$result\"\n       \
    \             break\n                fi\n                total=$(( total+$k ))\n\
    \            done\n        done\n    done < <(echo \"$result\" | xargs -n 1 shuf)\n\
    \    echo \"$result\"", "    local num_sum=0\n    for n in \"$@\"; do\n      \
    \  ((num_sum+=n))\n    done\n    local num_distinct=0\n    for n in \"$@\"; do\n\
    \        [[ $n == 0 ]] && num_distinct+=1\n    done\n    [[ $num_distinct == 3\
    \ ]] && return 0\n    return 1", "  local i\n  local sum=0\n  local count=0\n\
    \  local list=$1 count=1\n  for i in $list; do\n    ((sum+=i)); let count++\n\
    \  done\n  while [ \"$count\" -gt 3 ]; do\n    ((sum--)); let count--\n  done\n\
    \  echo \"$count\" == 0", "    local numbers=$1\n    local three\n    three=0\n\
    \    for ((i=0; i<${#numbers}; i++)); do\n        let three+=$((${numbers[i]}))\n\
    \    done\n    if [ $three -eq 0 ]; then\n        echo \"false\"\n    else\n \
    \       echo \"true\"\n    fi", "    local x\n    for x in \"$1\"; do\n      \
    \  local y z\n        y=\"$(cd \"$(dirname \"${BASH_SOURCE[@]}\")\" && pwd)\"\n\
    \        z=\"$(cd \"${y}/../..\" && pwd)\"\n        local sum\n        sum=\"\
    $(( ${x} + ${z} ))\"\n        if [[ ${sum} = 0 ]]; then\n            return 1\n\
    \        fi\n    done\n    return 0", "  local l=$( echo \"$1\" | tr '\\n' ','\
    \ | sed 's/,$//' )\n  local zero=$(echo $l | tr \"[:space:]\" \"\\n\" | sed -e\
    \ \"s/\\([[:digit:]]\\+\\) /[&]\\1/g\" -e \"s/-[[:digit:]]\\+$/[&]0/g\")\n  local\
    \ triplets=$(echo $l | tr \"[:space:]\" \"\\n\" | sed -e \"s/[[:digit:]]\\+\\\
    ([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\\
    +\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\\
    +\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\\
    +\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\\
    +\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\\
    +\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([[:digit:]]\\\
    +\\)[[:digit:]]\\+\\([[:digit:]]\\+\\)[[:digit:]]\\+\\([", "  if [[ $1 == *\"\
    -\"* ]]; then\n    numbers=( $1 )\n    shift\n    sum=$(echo ${numbers[*]} | sed\
    \ 's/-//g')\n  else\n    numbers=( $1 )\n    sum=$( echo \"${numbers[@]}\" | awk\
    \ '{s+=$1} END {if (s == 0) print \"true\" else \"false\"}' )\n  fi\n  echo \"\
    ${sum}\"", "    local list=\"$1\"\n    local sum\n\n    sum=$(echo $list | sed\
    \ 's/ //g' | sort | uniq -c | sed 's/^ *//g' | cut -d ' ' -f 1)\n    if [[ \"\
    $sum\" -gt 3 ]] ; then\n        echo \"$sum\"\n    else\n        echo \"false\"\
    \n    fi", "    local i sum zero\n    local -i n\n\n    n=$#\n    for ((i=1; i<=$n;\
    \ i++)); do\n        sum=$(( $1 + $2 ))\n        if [ $sum -eq 0 ]; then\n   \
    \         zero=true\n        elif [ $sum -gt 0 ]; then\n            zero=false\n\
    \        else\n            zero=true\n        fi\n    done\n    echo $zero", " \
    \ local a=$1 b=$2 c=$3 d=$4 e=$5\n  local e1 e2 e3\n\n  # the three elements we\
    \ want to compare\n  # are represented as a pair of numbers in a.\n  # (one element\
    \ is the negative of the other, so -a is +b)\n  e1=$(( ${#a} - 1 ))\n  e2=$((\
    \ ${#a} - 2 ))\n  e3=$(( ${#a} - 3 ))\n\n  # the first element of our pair must\
    \ be the sum of zero of the elements\n  # from a, which are (e1-1,e2-1,e3-1)\n\
    \  [ $(( ${#a} - 1 )) -gt 0 ] && [ $(( ${#a} - 1 )) -le $e1 ]\n  [ $(( ${#a} -\
    \ 2 )) -gt 0 ] && [ $(( ${#a} - 2 )) -le $e2 ]\n  [ $(( ${#a} - 3 )) -gt 0 ] &&\
    \ [ $(( ${#a} - 3 )) -le $e3 ]\n\n  # the second element of our pair must be the\
    \ sum of zero of the elements\n  # from a, which are (e1-2,e2-2,e3-2)\n  [ $((\
    \ ${#a} - 1 )) -eq 0 ] && [ $(( ${#a} - 2 )) -eq 0 ] && \\\n    [ $(( ${#a} -\
    \ 3 )) -eq 0 ] && [ $(( ${#a} - 4 )) -eq 0 ]\n  [ $(( ${#a} - 2 )) -eq 0 ] &&\
    \ [ $(( ${#a} - 3 )) -eq 0 ] && \\\n    [ $(( ${#a} - 4 )) -eq 0 ] && [ $(( ${#a}\
    \ - 5 )) -eq 0 ]\n  [ $(( ${#a} - 3 )) -eq 0 ] && [ $(( ${#a} - 4 )) -eq 0 ] &&\
    \ \\\n    [ $(( ${#a} - 5 )) -eq 0 ] && [ $(( ${#a} - 6 )) -eq 0 ]\n  [ $(( ${#a}\
    \ - 4 )) -eq 0 ] && [ $(( ${#a} - 5 )) -eq 0 ] && \\\n    [ $(( ${#a} - 6 )) -eq\
    \ 0 ] && [ $(( ${#a} - 7 )) -eq 0 ]\n  [ $(( ${#a} - 5 )) -eq 0 ] && [ $(( ${#a}\
    \ - 6 ", "    local _all=$1\n    local _sum=0\n    while [ $# -gt 0 ]; do\n  \
    \      local _item=$1\n        shift\n        _sum=$(( $_sum + $(_item) ))\n \
    \   done\n    echo $(( $_sum == 0 ))", "    local my_list=$1\n    local my_sum=0\n\
    \    local result\n    local item\n    for item in $my_list; do\n        my_sum=$((my_sum\
    \ + $item))\n    done\n    if [ $my_sum -eq 0 ]; then\n        result=\"true\"\
    \n    else\n        result=\"false\"\n    fi\n    echo \"$result\"", "    local\
    \ numbers=$1\n    local total=0\n    local count=0\n    local zeros=0\n    local\
    \ max=0\n    local min=0\n    for number in $numbers; do\n        if [ \"$number\"\
    \ -gt \"$max\" ]; then\n            max=$number\n        elif [ \"$number\" -lt\
    \ \"$min\" ]; then\n            min=$number\n        fi\n        total=$(( $total\
    \ + $number ))\n        (( count++ ))\n    done\n\n    local count2=0\n    local\
    \ sum=0\n    while [ $count -gt 0 ]; do\n        sum=$(( $sum + $count ))\n  \
    \      count=$(( $count - 1 ))\n        if [ $count -gt $zero ]; then\n      \
    \      zeros=$zeros + 1\n        fi\n    done\n    if [ $zero -gt $zeros ]; then\n\
    \        echo \"$max $min $sum $zeros\"\n    else\n        echo \"$max $min $sum\
    \ $zeros\"\n    fi", "  local list_str=$1\n  local sum zero\n  sum=0\n  zero=0\n\
    \  for list_item in $list_str; do\n    (( sum += list_item ))\n    (( zero ==\
    \ 0 )) && zero=1\n  done\n  (( zero == 1 )) && return 1\n  return 0", "    local\
    \ IFS=\"$1\"\n    local l\n    local sum\n    sum=0\n    l=( $@ )\n    local i\n\
    \    for i in \"${l[@]}\"; do\n        sum=$(( ${sum} + $i ))\n    done\n    #\
    \ count how many elements sum to zero\n    if [ $sum -eq 0 ]; then\n        echo\
    \ \"false\"\n    else\n        echo \"true\"\n    fi", "    local l=${1%% *}\n\
    \    local elements=${l// / }\n    local count=0\n    local count1=0\n    local\
    \ count2=0\n    for element in ${elements// / }; do\n        if [[ ${element}\
    \ == 0 ]]; then\n            count1=$((${count1}+1))\n        else\n         \
    \   count2=$((${count2}+1))\n        fi\n    done\n    if ((${count} >= 3)); then\n\
    \        if ((${count1} >= 3)); then\n            if ((${count2} >= 3)); then\n\
    \                return 0\n            else\n                return 1\n      \
    \      fi\n        else\n            return 1\n        fi\n    else\n        return\
    \ 0\n    fi", "    local numbers=$1\n    local sum_of_numbers=0\n    local i=2\n\
    \n    # Iterate until there are no more elements to check.\n    while [[ $i -lt\
    \ ${#numbers} ]]; do\n        # Add the current element to the sum.\n        sum_of_numbers=$(expr\
    \ $sum_of_numbers + ${numbers[$i]})\n\n        # Increment the index for the next\
    \ element to check.\n        i=$(( $i + 1 ))\n\n        # If this element equals\
    \ the sum, we found three distinct elements\n        # that sum zero and are therefore\
    \ zero.\n        if [[ $numbers[$i] == $sum_of_numbers ]]; then\n            echo\
    \ \"true\"\n            return 0\n        fi\n    done\n\n    echo \"false\"\n\
    \    return 1", "  local list=\"$1\"\n  local numbers=()\n  while read -r; do\n\
    \    numbers+=(\"$REPLY\")\n  done <<< \"$list\"\n  local sum 0\n  for element\
    \ in \"${numbers[@]}\"; do\n    (( sum += element ))\n  done\n  [[ \"$sum\" -eq\
    \ 0 ]] && return 0 || return 1", "    local i\n    local j\n    local k\n    for\
    \ (( i=1; i<=$#; i++ )); do\n        local -n first=$1\n        first=$(( ${#first}\
    \ + 1 ))\n        local -n second=$first\n        second=$(( ${#second} + 1 ))\n\
    \        local -n third=$second\n        third=$(( ${#third} + 1 ))\n        if\
    \ [ $(( ${first} + ${second} + ${third} )) -eq 0 ]; then\n            echo \"\
    true\"\n            return 0\n        fi\n    done\n    echo \"false\"\n    return\
    \ 1", "    set -- $1\n    local x\n    for x in \"${@:2}\"; do\n        local\
    \ y\n        for y in \"${@:3}\"; do\n            if [ $x -eq $y ] ; then\n  \
    \              return 0\n            fi\n        done\n    done\n    return 1",
  "    local xx yy zz zzz total\n    local IFS=$'\\t'\n    local arg1=\"$1\"\n\n \
    \   if [[ ${#arg1} -eq 0 ]]; then\n        return false\n    fi\n\n    total=0\n\
    \    for xx in $arg1; do\n        zz=$(echo \"$xx\" | sed 's/-//g' | tr '[:upper:]'\
    \ '[:lower:]')\n        yy=$(echo \"$zz\" | tr '[:upper:]' '[:lower:]')\n    \
    \    zzz=$((yy+zz))\n        echo \"$zzz\"\n        if [[ \"$zzz\" -eq 0 ]]; then\n\
    \            total=$(( ${total} + 1 ))\n        fi\n    done\n    return $(( ${total}\
    \ % 3 ))", "    local IFS=' '\n    local a b\n    local sum=0\n    for a in \"\
    $@\"; do\n        if [ \"$a\" == \"0\" ]; then\n            sum=$(( sum + 0 ))\n\
    \            continue\n        fi\n        b=$(( sum + 0 ))\n        sum=$(( sum\
    \ + 0 ))\n        if [ \"$a\" == \"$b\" ]; then\n            sum=$(( sum + 0 ))\n\
    \        fi\n    done\n    if [ \"$sum\" -gt 1 ]; then\n        return false\n\
    \    else\n        return true\n    fi", "    local arg=\"$1\"\n    local -n sum=$2\n\
    \    local nums=()\n    for n in $arg; do\n        local num=\"$(n)\"\n      \
    \  # Skip duplicate numbers in the list\n        if [[ $nums && ! grep -q \"^$num\"\
    \ <<< \"$nums\" ]]; then\n            sum=\"$(($sum + $num))\"\n            ((nums+=(\"\
    $num\")))\n        fi\n    done\n    echo $(( ${#nums[@]} > 3 ))", "  echo \"\
    $1\" | cut -d\" \" -f1 \\\n    | grep -n '^[[:space:]]*3[[:space:]]*[[:space:]]*[[:space:]]*0[[:space:]]*$'\
    \ \\\n    | grep -v \"^[[:space:]]*1$\" > /dev/null", "    local lst_of_ints=$1\n\
    \    local sum=0\n    for ele in ${lst_of_ints[*]}; do\n        let sum+=$ele\n\
    \    done\n    echo $((sum%3==0))", "    local -r numbers=$1\n    local -r sum=0\n\
    \    local -r three=1\n    local -r threetwo\n    local -r four=1\n    local -r\
    \ sumstr\n    local number\n    local -r ret\n\n    for number in $numbers; do\n\
    \        ((sum += number))\n    done\n\n    sumstr=`expr $sum - 1`\n\n    if ((\
    \ $(( sum % 3 )) )); then\n        threetwo=1\n        four=1\n    fi\n\n    if\
    \ (( $(( sum % 4 )) )); then\n        four=1\n    fi\n\n    if (( $(( sum % 2\
    \ )) )); then\n        threetwo=1\n    fi\n\n    ret=$(( three == threetwo ||\
    \ four == three ))\n\n    if (( $sumstr == 0 )); then\n        ret=$(( ret ==\
    \ 1 ))\n    fi\n\n    return $ret", "    IFS=$'\\n'\n    set -- $1 || die \"Wrong\
    \ number of arguments\" # fix for spaces in arg list\n    local i\n    local sum=0\n\
    \    for i in $@; do\n        let sum+=i\n    done\n    echo $((sum%3 != 0))",
  "    # put code here\n    for a in \"$@\"\n    do\n        if (( $a < 3 ))\n   \
    \     then\n            continue\n        elif (( $a == 3 ))\n        then\n \
    \           echo \"true\"\n        else\n            echo \"false\"\n        fi\n\
    \    done", "  local var=\"$1\"\n  local zero=0\n  local sum=0\n  local i=0\n\n\
    \  while [ \"$var\" != \"0\" ]; do\n    sum=$(( $sum + $var ))\n    var=$(( $var\
    \ - 1 ))\n    i=$(( $i + 1 ))\n  done\n\n  if [ \"$i\" -eq \"3\" ]; then\n   \
    \ return 0\n  else\n    return 1\n  fi", "    set -- $1\n    local sum=0\n   \
    \ for i in $@; do\n        sum=$((sum+i))\n    done\n    if (( $sum != 0 ))\n\
    \    then\n        return 0\n    else\n        return 1\n    fi", "    local i\n\
    \n    i=0\n    local sum\n    local elements\n    elements=$1\n\n    while [ $i\
    \ -lt $((${#elements})) ]; do\n        sum=$(echo \"${elements[$i]}\" | awk '{print\
    \ $1}')\n        if [[ ${elements[$i]} -gt 0 ]]; then\n            if [[ \"$sum\"\
    \ -eq 0 ]]; then\n                echo \"true\"\n                return 0\n  \
    \          else\n                echo \"false\"\n                return 0\n  \
    \          fi\n        fi\n        i=$(( $i + 1 ))\n    done\n\n    echo \"false\"\
    \n    return 0"]
stop_tokens:
- "\n}"
