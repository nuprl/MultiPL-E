name: HumanEval_105_by_length
language: sh
prompt: "#!/bin/bash\n# Given an array of integers, sort the integers that are between\
  \ 1 and 9 inclusive,\n# reverse the resulting array, and then replace each digit\
  \ by its corresponding name from\n# \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
  , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n# For example:\n# >>> $(by_length \"\
  2 1 1 4 5 8 2 3\")\n# ['\"Eight\"', '\"Five\"', '\"Four\"', '\"Three\"', '\"Two\"\
  ', '\"Two\"', '\"One\"', '\"One\"']\n# If the array is empty, return an empty array:\n\
  # >>> $(by_length \"\")\n# []\n# If the array has any strange number ignore it:\n\
  # >>> $(by_length \"1 -1 55\")\n# ['\"One\"']\n#\n# $1 is a space-separated list\n\
  by_length() {\n"
tests: "}\n\ncandidate() {\n    by_length \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"2 1 1 4 5 8 2 3\") = \"Eight Five Four Three Two Two One One\" ]]\n\
  \    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"1 -1 55\") = \"One\" ]]\n\
  \    [[ $(candidate \"1 -1 3 2\") = \"Three Two One\" ]]\n    [[ $(candidate \"\
  9 4 8\") = \"Nine Eight Four\" ]]\n}\n\nrun_test"
completions: ["    local list_array\n    local list_length\n    local num_array\n\
    \    local i\n    local length\n    local index\n    local tmp\n    local j\n\n\
    \    list_array=( $1 )\n    list_length=${#list_array[@]}\n    num_array=( $(\
    \ for (( i = 0; i < list_length; i++ )); do echo \"${list_array[i]}\"; done ))\n\
    \n    length=${#num_array[@]}\n    index=$(( length / 2 ))\n    \n    for (( j\
    \ = 1; j < length; j++ )); do\n        if [ $num_array[j] < 9 ]; then\n      \
    \      if [ ${num_array[j]} == 1 ]; then\n                num_array[j]=One\n \
    \           elif [ ${num_array[j]} == 2 ]; then\n                num_array[j]=Two\n\
    \            elif [ ${num_array[j]} == 3 ]; then\n                num_array[j]=Three\n\
    \            elif [ ${num_array[j]} == 4 ]; then\n                num_array[j]=Four\n\
    \            elif [ ${num_array[j]} == 5 ]; then\n                num_array[j]=Five\n\
    \            elif [ ${num_array[j]} == 6 ]; then\n                num_array[j]=Six\n\
    \            elif [ ${num_array[j]} == 7 ]; then\n                num_array[j]=Seven\n\
    \            elif [ ${num_array[j]} == 8 ]; then\n                num_array[j]=Eight\n\
    \            elif [ ${num_array[j]} == 9 ]; then\n                num_array[j]=Nine\n\
    \            fi\n        elif [ $num_array[j] > 9 ]; then\n            num_array[j]=$(by_length\
    \ ${num_array[j]:0:$(( $num_array[j] - 9 ))} ${num_array[$(( j - 1 )):$(( $j +\
    \ 1 ))]:1:1})\n        fi\n    done\n\n    for((i = 0; i < list_length; i++ ));\
    \ do\n        if [[ ${num_array[i]} == One ]] || [[ ${num_array[i]} == Two ]]\
    \ || [[ ${num_array[i]} == Three ]] || [[ ${num_array[i]} == Four ]] || [[ ${num_array[i]}\
    \ == Five ]] || [[ ${num_array[i]} == Six ]] || [[ ${num_array[i]} == Seven ]]\
    \ || [[ ${num_array[i]} == Eight ]] || [[ ${num_array[i]} == Nine ]]; then\n \
    \           num_array[i]=\"${list_array[index]}\"\n        fi\n        index=$(\
    \ (( index + 1 )) )\n    done\n\n    echo \"${num_array[@]}\"", "  local lines=($(jq\
    \ -r '.[] | select(length==1 or length==9 and (.>=1 and .<=9)) | @base64 | .[]'\
    \ <<< \"$1\"))\n  local length=${#lines[@]}\n  local i=${lines[length]}\n  local\
    \ ret=()\n  while (( i-- )); do ret+=(\"\\\"${lines[i]}\\\"\" ); done\n  printf\
    \ '%s\\n' \"${ret[@]:1}\"", "    local nums=$1\n\n    local -a result\n    for\
    \ i in ${nums}; do\n        local length=${#i}\n        if [[ $length =~ ^[0-9]+$\
    \ ]]; then\n            local digit=${i%%[0-9]}\n            if (( ${length} >\
    \ 9 )); then\n                length=9\n            else\n                length=${#i}\n\
    \            fi\n            local ones=$(printf \"One\" {1..9})\n           \
    \ result+=( ${ones:$digit:1}  )\n            result+=( ${ones:$(( ${digit} + 1\
    \ )):1} )\n        elif (( ${length} > 10 )); then\n            result+=( ${i//[0-9]/Nine}\
    \ )\n        else\n            result+=( ${i} )\n        fi\n    done\n\n    #\
    \ reverse the array\n    local tmp=${result[@]}\n    local -a tmp2\n    for ((\
    \ i = 0; i < ${#tmp}; i++ )); do\n        tmp2=${tmp:$i:1}\n        echo ${tmp2:0:1}\n\
    \        echo ${tmp2:1:1}\n        echo ${tmp2:2:1}\n        echo ${tmp2:3:1}\n\
    \        echo ${tmp2:4:1}\n        echo ${tmp2:5:1}\n        echo ${tmp2:6:1}\n\
    \        echo ${tmp2:7:1}\n        echo ${tmp2:8:1}\n        echo ${tmp2:9:1}\n\
    \    done", "    local -a array\n    local name\n\n    IFS=' ' read -r -a array\
    \ <<< \"$1\"\n\n    # Turn all single digit numbers into their corresponding name:\n\
    \    for (( i = 1 ; i <= 9 ; i++ )); do\n        if [[ \"${array[i-1]}\" -eq \"\
    $i\" ]]; then\n            name=\"$i\"\n        fi\n    done\n\n    # Do the sorting:\n\
    \    local -n sorter\n    sorter=($(sort -rn))\n\n    # Reverse and replace the\
    \ digits in each string:\n    for (( i = 1 ; i <= ${#array[@]} ; i++ )); do\n\
    \        array[i-1]=\"\\\"${sorter[i]}\\\"\"\n    done\n\n    echo \"${array[@]}\"",
  "  local input=\"$1\"\n  local lengths\n  local output\n\n  input=\"$(echo \"${input}\"\
    \ | tr '\\n' ' ')\"\n\n  lengths=\"$(echo \"${input}\" | sed -E 's/(^| )([[:digit:]])/\\\
    2 /g' | sort -n | sed 's/ \\([0-9]\\)/\"\\1\"/g')\"\n\n  if [ -z \"$lengths\"\
    \ ]; then\n    return 0\n  fi\n\n  output=\"$(echo \"${lengths}\" | rev | sed\
    \ -E 's/^([0-9]+) /\\1 /' | paste -s -d, )\"\n\n  if [ -z \"$output\" ]; then\n\
    \    return 0\n  fi\n\n  echo \"${output}\"", "    local array=$1\n    local length=\"\
    ${#array[@]}\"\n    if [[ -z \"$length\" ]]; then\n        return\n    fi\n  \
    \  local last\n    local prefix\n    local name\n    local suffix\n    local output\n\
    \    for ((i = 0; i < ${length}; i++)); do\n        if [[ -z \"${array[i]}\" ]];\
    \ then\n            return\n        fi\n        prefix=\"One\"\n        suffix=\"\
    \"\n        if [[ ${array[i]} -ge 1 ]]; then\n            prefix=\"One\"\n   \
    \         suffix=\"One\"\n        fi\n        if [[ ${array[i]} -ge 2 ]]; then\n\
    \            prefix=\"Two\"\n            suffix=\"Two\"\n        fi\n        if\
    \ [[ ${array[i]} -ge 3 ]]; then\n            prefix=\"Three\"\n            suffix=\"\
    Three\"\n        fi\n        if [[ ${array[i]} -ge 4 ]]; then\n            prefix=\"\
    Four\"\n            suffix=\"Four\"\n        fi\n        if [[ ${array[i]} -ge\
    \ 5 ]]; then\n            prefix=\"Five\"\n            suffix=\"Five\"\n     \
    \   fi\n        if [[ ${array[i]} -ge 6 ]]; then\n            prefix=\"Six\"\n\
    \            suffix=\"Six\"\n        fi\n        if [[ ${array[i]} -ge 7 ]]; then\n\
    \            prefix=\"Seven\"\n            suffix=\"Seven\"\n        fi\n    \
    \    if [[ ${array[i]} -ge 8 ]]; then\n            prefix=\"Eight\"\n        \
    \    suffix=\"Eight\"\n        fi\n        if [[ ${array[i]} -ge 9 ]]; then\n\
    \            prefix=\"Nine\"\n            suffix=\"Nine\"\n        fi\n      \
    \  last=\"${array[i-1]}\"\n        array[i-1]=\"\\\"$prefix\\\"\"\n        array[i]=\"\
    \\\"$suffix\\\"\"\n    done\n    for ((i = 1; i < ${length}; i++)); do\n     \
    \   array[i-1]=\"${array[i-1]}, \\\"$(by_replace \"${last} ${array[i]}\")\\\"\"\
    \n    done\n    output=$(printf \"%s\\n\" \"${array[@]}\")\n    echo \"$output\"",
  "    local -n arr=( \"$1\" )\n    local -a sorted\n    local len=\"$#\"\n    # If\
    \ the array is empty, return an empty array:\n    if [[ ${#arr[@]} -eq 0 ]]; then\n\
    \        echo \"[]\"\n        return\n    fi\n    # If the array has any strange\
    \ number ignore it:\n    [[ \"${arr[0]}\" -gt 0 ]] || arr[0]=0\n    [[ \"${arr[0]}\"\
    \ -le 9 ]] || arr[0]=9\n    [[ \"${arr[1]}\" -gt 0 ]] || arr[1]=0\n    [[ \"${arr[1]}\"\
    \ -le 9 ]] || arr[1]=9\n    # Convert each digit to the corresponding integer\
    \ and add it to a new array\n    local index=0\n    for ((index=0; index<len;\
    \ index++)); do\n        sorted+=($(echo \"${arr[index]}*10\" | bc | sed 's/^0*//'))\n\
    \    done\n    # Sort the new array\n    local -r array=( \"${sorted[@]}\" )\n\
    \    # Return the reversed and formatted array\n    declare -a formatted\n   \
    \ for (( index=0; index<len; index++ )); do\n        formatted+=($(echo \"${array[index]}\"\
    \ | bc | sed 's/\\..*//'))\n    done\n    echo \"${formatted[@]}\"", "  local\
    \ arr=\"$1\"\n\n  if [[ \"$arr\" =~ ^[0-9]+[+-]*[0-9]+$ ]]; then\n    # An integer\
    \ array was provided, sort the array in ascending order\n    local -n int_arr=\"\
    $arr\" int_arr_len=\"${#int_arr}\"\n    sort \"${int_arr[@]}\" | while read -r\
    \ x; do\n      # A digit is between 0 and 9, and this variable is set by the read\
    \ statement,\n      # so we have to check if it's greater than 9. Hence the need\
    \ for the $(( ... ))\n      # notation.\n      if [[ \"$x\" -gt 9 ]]; then\n \
    \       local int_arr_tmp\n        int_arr_tmp=\"One\" \"Two\" \"Three\" \"Four\"\
    \ \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\"\n        int_arr_tmp=\"${int_arr_tmp[$x]}\"\
    \n        arr=\"$(echo \"$arr\" | sed \"s/^${int_arr}/$int_arr_tmp/g\")\"\n  \
    \    fi\n    done\n  fi\n\n  # Convert each character in the string into an integer.\n\
    \  local -n str_arr=\"$arr\" str_arr_len=\"${#str_arr}\"\n  local -n int_arr=\"\
    $arr\" int_arr_len=\"${#int_arr}\"\n  local -n rev_arr=\"$arr\" rev_arr_len=\"\
    ${#rev_arr}\"\n  while read -r x; do\n    int_arr[$int_arr_len]=\"One\" \"Two\"\
    \ \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\"\n    int_arr[$((\
    \ $int_arr_len + 1 ))]=\"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"\
    Seven\" \"Eight\" \"Nine\"\n\n    rev_arr[$rev_arr_len]=\"9\" \"8\" \"7\" \"6\"\
    \ \"5\" \"4\" \"3\" \"2\" \"1\"\n    rev_arr[$(( $rev_arr_len + 1 ))]=\"9\" \"\
    8\" \"7\" \"6\" \"5\" \"4\" \"3\" \"2\" \"1\"\n\n    if [[ \"$x\" -lt \"0\" ]];\
    \ then\n      str_arr[$str_arr_len]=\"$x\"\n      str_arr[$(( $str_arr_len + 1\
    \ ))]=\"$x\"\n    elif [[ \"$x\" -gt \"9\" ]]; then\n      str_arr[$str_arr_len]=\"\
    $x\"\n      str_arr[$(( $str_arr_len + 1 ))]=\"$x\"\n    else\n      str_arr[$str_arr_len]=\"\
    ${rev_arr[$(( $x - 1 ))]}\"\n      str_arr[$(( $str_arr_", "    # Convert \"$1\"\
    \ string to an array for easier handling:\n    local array=\"$1\"\n    local length=\"\
    $2\"\n    local count=0\n    local last\n    local result\n\n    # Return an empty\
    \ array if the length is zero:\n    if [ \"${#array}\" -eq 0 ]; then\n       \
    \ echo \"[]\"\n        return\n    fi\n\n    # Sort and reverse the array:\n \
    \   for element in \"${array[@]}\"; do\n        if [ \"${#element}\" -eq \"${length}\"\
    \ ]; then\n            # Remove the last digit in the array and replace it with\
    \ the name of the\n            # digit to its left:\n            last=\"${element%?}\"\
    \n            element=${element##* }\n            element=${element:0:1}\n\n \
    \           if [ \"$count\" -eq 0 ]; then\n                result=( \"${result[@]}\"\
    \ \"$element\" )\n            else\n                result=( \"${result[@]}\"\
    \ \"$last\" \"${element%?}\" )\n            fi\n        fi\n        (( count++\
    \ ))\n    done\n\n    # Return a comma-separated array if there are any elements:\n\
    \    if [ \"${#result[@]}\" -gt 0 ]; then\n        echo \"${result[@]}\"\n   \
    \     return\n    fi\n\n    # If no elements are returned, return an empty array\
    \ instead:\n    echo \"[]\"", "  # Split $1 into multiple arguments.\n  set --\
    \ \"$1\" ; shift\n  # If the array is empty, return an empty array:\n  test -z\
    \ \"$1\" || { echo \"$0: empty argument\"; return 1; }\n  # Otherwise, reverse\
    \ the array and replace each digit by its corresponding name from\n  # \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    .\n  local -a arr=( $(sort -r -n \"$1\") )\n  local -a output=()\n  local digits=()\n\
    \  # If there is only one digit, return the name directly for that digit:\n  if\
    \ [[ ${#arr[@]} -eq 1 ]] ; then\n    digits=( \"${!arr[@]}\" )\n    return \"\
    ${digits[@]}\"\n  fi\n  # For each element, if the element is between 1 and 9\
    \ inclusive, append it to the\n  # digits array.\n  for num in \"${arr[@]}\";\
    \ do\n    if [[ $num -ge 1 ]] && [[ $num -le 9 ]]; then\n      digits+=( \"${num}\"\
    \ )\n    fi\n  done\n  # For each element, if the element is not between 1 and\
    \ 9 inclusive, append it to the\n  # output array and replace it with the name\
    \ \"Other\" for the element.\n  for i in \"${!arr[@]}\"; do\n    if [[ ${digits[*]}\
    \ != *\"${i}\"* ]]; then\n      output+=( \"${i}\" )\n      output+=( \"Other\"\
    \ )\n    fi\n  done\n  # Finally, sort the digits array and return the corresponding\
    \ array elements.\n  IFS=' ' read -a output <<< \"${digits[@]}\"\n  # Replace\
    \ all the spaces with double quotes because they cause problems with the\n  #\
    \ JSON formatting.\n  output=$(IFS=\"\\ \"; echo \"${output[*]}\")\n  output=\"\
    [${output}]\"\n  echo \"$output\"", "    local a b c d i j k l m\n\n    a=$( $(\
    \ echo $1 | tr \" \" , | tr -d \" \" ) )\n    if [ $a == \"$a\" ]; then\n    \
    \    echo \"$a\"\n        return\n    fi\n    # $( ... ) performs a command and\
    \ captures its output\n    # $* passes arguments to the command\n    d=$( $( echo\
    \ \"$a\" | sort -n -r ) ) # sort numbers in reverse\n    for i in $d; do\n   \
    \     # convert number $i to its string representation\n        b=$( printf \"\
    %d\\t\" \"$i\" )\n        # use grep to filter numbers between 1 and 9\n     \
    \   c=$( echo $b | tr \"[:lower:]\" \"[:upper:]\" | grep -E \"^[1-9]$\" )\n  \
    \      if [ $c != \"\" ]; then\n            # $* passes arguments to the command\n\
    \            j=$( echo \"$c\" | head -1 )\n            k=$( echo \"$c\" | tail\
    \ -1 )\n            l=$( printf \"%\\\"$j\\\"\\\"$k\\\"\\\" \" \"$j\" \"$k\" )\n\
    \            # replace digit by its name\n            m=$( echo \"$l\" | sed \"\
    s/$j/$k/\" )\n            m=$( echo \"$m\" | sed \"s/$/\\\"$k\\\" /\" )\n    \
    \        m=$( echo \"$m\" )\n            echo \"$m\"\n        fi\n    done", " \
    \ local -n ar=$1\n  local -a result=()\n\n  for (( i=0; i<${#ar[@]}; i++ )); do\n\
    \    if [ ${ar[$i]} -gt 0 ] && [ ${ar[$i]} -le 9 ]; then\n      result+=(\"${!ar[$i]}\"\
    )\n      ar[$i]=${ar[$i]#0}\n    fi\n  done\n\n  if [ ! \"${#result[@]}\" -eq\
    \ 0 ]; then\n    echo \"${result[@]}\"\n  fi", "    local a b\n    local -i i\
    \ j k l m\n\n    a=\"${1:-}\"\n    if [ -z \"$a\" ] ; then\n        echo \"[]\"\
    \n        return\n    fi\n\n    for b in $a; do\n        i=$(echo $b | awk '{print\
    \ length($0)}')\n        k=0\n        while (( i < 9 )); do\n            j=$((i\
    \ + 1))\n            if [ $j -gt 10 ] ; then\n                j=$(( 10 + j ))\n\
    \            fi\n            m=$(echo $j | awk '{print $0}' | sed -e 's/^0*//')\n\
    \            if [ \"$k\" -eq \"$j\" ] ; then\n                echo \"$m\"\n  \
    \          else\n                echo \"\\\"$m\\\"\"\n            fi\n       \
    \     k=$(( $k + 1 ))\n            j=$(( $j + 1 ))\n            i=$(( $i + 1 ))\n\
    \        done\n    done", "  local array names number\n  IFS=$'\\n' array=$( $1\
    \ )\n  names=(\n    \"One\"\n    \"Two\"\n    \"Three\"\n    \"Four\"\n    \"\
    Five\"\n    \"Six\"\n    \"Seven\"\n    \"Eight\"\n    \"Nine\"\n  )\n  for number\
    \ in \"${array[@]}\"; do\n    if [[ \"$number\" -lt 1 ]] \\\n        || [[ \"\
    $number\" -gt 9 ]]; then\n      continue\n    fi\n    number=$( printf '\"%s\"\
    ' \"${number}\" )\n    eval echo \"${names[${number}]}\"\n  done", "  local i\n\
    \  local list\n  local length=${1:-8}\n  local digits\n  local first=0\n  local\
    \ last=${#list[@]}\n  local max=$((10#${#list[@]}))\n  local result\n  local number\n\
    \  local tmp\n\n  list=()\n  IFS=' ' read -a list <<<\"$1\"\n  for i in \"${!list[@]}\"\
    ; do\n    case \"${list[i]}\" in\n    \"\")\n      ;;\n    *)\n      number=\"\
    ${list[i]}\"\n      digits=$(expr length -- $number)\n      first=$((first + $digits))\n\
    \      last=$((last - $digits))\n      tmp=${#first}\n      first=$(echo \"$first\"\
    \ | bc | sed \"s/^$tmp//g\")\n      last=$(echo \"$last\" | bc | sed \"s/^$tmp//g\"\
    )\n      if [ $first -gt $max ]; then\n        first=$((first - $max))\n     \
    \ fi\n      if [ $last -lt $max ]; then\n        last=$((last + $max))\n     \
    \ fi\n      result=\"$(\n        echo \"${list[first]}\" \\\n          \"${list[last]}\"\
    \ \\\n        | sed \"s/\\([0-9]\\)/'\\\"'${list[i]}'\\\"'/\" \\\n        | sed\
    \ \"s/^/$first,/g\" \\\n        | sed \"s/$/$last,/g\")\"\n      list[i]=$result\n\
    \      ;;\n    esac\n  done\n\n  printf '%s\\n' \"${list[@]}\"", "  local array=\"\
    $1\"\n  local length\n  local name\n\n  length=$(echo \"${array}\" | wc -c)\n\
    \  if [ \"${length}\" -eq 0 ]; then\n    return 0\n  fi\n  local index\n  local\
    \ sorted\n  local tmp\n  local result\n  local count\n\n  name=One\n  count=1\n\
    \  result=()\n\n  for index in $(seq 0 \"${length}\" - 1); do\n    sorted=$(echo\
    \ \"${array}\" | awk -F\" \" '{ print $index\"  \"$0 }')\n    if [ -z \"$sorted\"\
    \ ]; then\n      continue\n    fi\n    sorted=\"${sorted% *}\"\n    if [ \"${sorted:0:1}\"\
    \ == \"0\" ]; then\n      tmp=\"${name}\"\n      name=\"$(( ${count} % 10 ))\"\
    \n      count=$(( ${count} / 10 ))\n    else\n      tmp=\"$name\"\n      name=$((\
    \ ${count} % 10 ))\n      count=$(( ${count} / 10 ))\n    fi\n    result+=(\"\
    ${tmp}\")\n  done\n\n  echo \"${result[@]}\"", "  local array=\"$1\"\n\n  local\
    \ length=\"$(by_length \"${array[@]}\" | wc -l)\"\n  if [ \"$length\" -eq 0 ];\
    \ then\n    return 0\n  fi\n  local -a array\n  local result\n  local name\n \
    \ local -a names=\"One Two Three Four Five Six Seven Eight Nine\"\n  local length\n\
    \n  if ! IFS= read -d '' -ra array ; then\n    return 0\n  fi\n  result=()\n \
    \ for (( i=0; i<\"${#array[@]}\"; i++ )); do\n    length=$(expr length \"${array[i]}\"\
    )\n    if [ \"$length\" -gt 9 ]; then\n      name=\"${names[$length]}\"\n    \
    \  result+=(\"${!name}\")\n    else\n      result+=(\"${array[i]}\")\n    fi\n\
    \  done\n  printf '%s\\n' \"${result[@]}\"", "  local -a input\n\n  IFS=$'\\n'\
    \ read -r -a input <<< \"$1\"\n\n  if [ -z \"${input[0]}\" ]; then return 0; fi\n\
    \  local -a lengths\n\n  lengths=($(\n    for n in \"${input[@]:1}\"; do\n   \
    \   [[ \"$n\" =~ ^-?[0-9]+$ ]] || continue\n      local digits=$(( ${n#-} + 1\
    \ ))\n\n      # Skip any trailing zeroes\n      while [ \"$digits\" -eq 0 ]; do\n\
    \        digits=${digits%%,*}\n      done\n\n      printf \"%02d\" \"$digits\"\
    \n    done\n  ))\n\n  while read -r n || [ -n \"$n\" ]; do\n    (( \"${lengths[@]:-1}\"\
    \ >= ${#n} )) || continue\n    local result\n\n    printf -v \"${result}\" '\"\
    %s\"' \"${n:${lengths[@]:-1}}\"\n  done <<< \"${input[@]:0:${#lengths[@]}}\"",
  "    local array=\"$1\"\n    if [[ \"$array\" =~ '^' ]]; then array=(\"$array\"\
    ); fi\n    local new_array=()\n    local element\n    for element in \"${array[@]}\"\
    ; do\n        [[ ${element} =~ ^[0-9]+$ ]] || continue\n        [[ ${element}\
    \ -ge 1 ]] && [[ ${element} -le 9 ]] && new_array+=(\"${element}\")\n    done\n\
    \    if [[ -z \"$new_array\" ]]; then\n        echo \"$element\"\n    else\n \
    \       new_array+=(\"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\"\
    \ \"Eight\" \"Nine\")\n        array=(\"${new_array[@]}\")\n        local index=0\n\
    \        for element in \"${array[@]}\"; do\n            echo -n \"${array[index]}\\\
    \"${element}\"\n            ((index+=1))\n        done\n        echo \" #${index}\"\
    \n    fi", "    local arr=$1\n\n    arr=($arr)\n    # remove strange elements\n\
    \    local tmp\n    for tmp in $(echo \"${arr[@]}\" | tr \" \" \"\\n\" | sort\
    \ -n | uniq); do\n        echo \"$tmp\"\n    done\n\n    # sort and reverse elements\n\
    \    tmp=$(echo \"${arr[@]}\" | tr \" \" \"\\n\" | sort -n -r | uniq)\n    local\
    \ tmp2\n    for tmp2 in $tmp; do\n        echo \"\\\"${tmp2}\\\"\"\n    done",
  "  local IFS=$'\\n' arr=() line\n  while read -r line; do\n    # Convert to an array\n\
    \    arr+=(\"${line}\")\n  done\n  # Filter out any empty strings\n  arr=($(echo\
    \ \"${arr[@]}\" | grep -v '^$'))\n  # Sort and reverse the array\n  arr=($(echo\
    \ \"${arr[@]}\" | tr ' ' '\\n' | sort -r))\n  # Replace each digit by its name\
    \ from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"\n  arr=($(echo \"${arr[@]}\" | tr ' ' '\\n' | sed 's/^/\"${One},\"\
    /;s/$/\"${Ten},\"/;s/[0-9]\\([F|S|E|N]\\)/\"${Four},\"${Eight},\"${Nine},\"/g'))\n\
    \  # Remove a trailing comma\n  arr=($(echo \"${arr[@]}\" | tr ' ' '\\n' | sed\
    \ 's/,$//'))\n  # Remove surrounding quotes\n  arr=($(echo \"${arr[@]}\" | tr\
    \ ' ' '\\n' | sed 's/^\"\\(.*\\)\"$/\"\\2\"/'))\n  # Remove surrounding spaces\n\
    \  arr=($(echo \"${arr[@]}\" | tr ' ' '\\n' | sed 's/^\"\\([^\"]*\\)\"$/\"\\1\"\
    /'))\n  printf '%s\\n' \"${arr[@]}\"", "  local n=$1\n  shift 1\n  # n is now\
    \ the entire list of numbers. We loop over it looking for a number greater than\n\
    \  # one. By looping over it we can stop when we have found the number.\n  while\
    \ ((${n} > 1)); do\n    case \"${n}\" in\n      1|2 ) echo \"One\";;\n      3|4\
    \ ) echo \"Two\";;\n      5|6 ) echo \"Three\";;\n      7|8 ) echo \"Four\";;\n\
    \      9|10) echo \"Five\";;\n      *) echo \"${n}\"; break;;\n    esac\n    shift\n\
    \  done\n  # n is now empty when there are none left.", "  if [ -z \"$1\" ]; then\n\
    \    return 0\n  fi\n  local -r arr=( \"${1// /}\" )\n  local tmp\n  local i\n\
    \  local j\n  local res\n  local tmp2\n  local tmp3\n  local tmp4\n  local tmp5\n\
    \  local tmp6\n  local tmp7\n  local tmp8\n  local tmp9\n\n  res=\"\"\n  for ((\
    \ i = 0; i < ${#arr[@]}; i++ )); do\n    tmp=${arr[$i]}\n    tmp2=$((10#$tmp))\n\
    \    tmp3=${tmp2/$((10#$1))}\n    if [ -z \"$tmp3\" ]; then\n      tmp3=0\n  \
    \  fi\n    tmp4=${tmp3#0}\n    tmp5=(\"${tmp4//$tmp3/One}\")\n    tmp6=(\"${tmp5//$tmp3/Two}\"\
    )\n    tmp7=(\"${tmp6//$tmp3/Three}\")\n    tmp8=(\"${tmp7//$tmp3/Four}\")\n \
    \   tmp9=(\"${tmp8//$tmp3/Five}\")\n    tmp10=(\"${tmp9//$tmp3/Six}\")\n    tmp11=(\"\
    ${tmp10//$tmp3/Seven}\")\n    tmp12=(\"${tmp11//$tmp3/Eight}\")\n    tmp13=(\"\
    ${tmp12//$tmp3/Nine}\")\n    res=\"${res}'\\\"'${tmp13//$tmp/$((10#$tmp))}\n \
    \ done\n  echo ${res// /'\\\"'}", "  local array=\"$1\"\n  local name=\"One\"\
    \ Two=\"Two\" Three=\"Three\" Four=\"Four\" Five=\"Five\" Six=\"Six\" Seven=\"\
    Seven\" Eight=\"Eight\" Nine=\"Nine\"\n  local arrayLength=\"${#array}\"\n  #\
    \ convert array's elements to numbers, and sort them\n  local sortedArray=($(echo\
    \ \"${array}\" | awk '{print $1} END { print NR }' ))\n  IFS=\" \" read -a array\
    \ <<< \"${sortedArray[@]}\"\n  local sortedArrayLength=\"${#array[@]}\"\n  IFS=\"\
    \ \" read -a array <<< \"${sortedArray[@]}\"\n  local sortedArrayLength=\"${#array[@]}\"\
    \n  # reverse the array\n  local reversedArray=($(echo \"${array[@]}\" | tac))\n\
    \  # replace each element with a string from the name\n  local outputArray=\"\"\
    \n  local startIndex=0\n  # loop through the array, add one for each element and\
    \ append the name to the output\n  while [ \"${startIndex}\" -lt \"$sortedArrayLength\"\
    \ ]; do\n    local item=\"${sortedArray[startIndex]}\"\"${name}\"\n    outputArray=\"\
    ${outputArray}${item}\"\n    ((startIndex++))\n  done\n  echo \"$outputArray\"",
  "  local arr=$1 output=\"[]\"\n  for n in $arr; do\n    local digits=$(printf \"\
    %.2s\" {1..$n})\n    arr=(\"${arr[@]:0:n}\" \"${digits}\" \"${arr[@]:$n}\")\n\
    \  done\n  arr=(\"${arr[@]:1}\")\n  arr=(\"${arr[@]/%\\([0-9][0-9]*\\)/\\\"$((10#$1\
    \ +1))\\\"}\")\n  output=\"[\\\"${arr[@]}\\\"]\"", "    local lst tmp num\n  \
    \  IFS=$'\\t' lst=\"$1\" || return\n    IFS=$' \\t\\n' lst=${lst//[[:space:]]/}\n\
    \    IFS=$' \\t' num=${lst[0]} || return\n    local -i i\n    local str='[\"One\"\
    ', '\"Two\"', '\"Three\"', '\"Four\"', '\"Five\"', '\"Six\"', '\"Seven\"', '\"\
    Eight\"', '\"Nine\"]'\n    IFS=$',' tmp=$(eval \"echo \\\"${str}\\\" | awk -v\
    \ n=\\\"${num}\\\" 'NR>1{if(\\$0>=n){print \\$0;exit}}'\")\n    IFS=$',' lst=$(eval\
    \ \"echo \\\"${lst}\\\" | awk -v n=\\\"${num}\\\" 'NR>1{if(\\$0>=n){print \\$0;exit}}'\"\
    )\n    local -a ret\n    for (( i=1; i<${#lst[@]}; i++ )); do\n        if [ ${lst[i]}\
    \ -eq 1 ]; then\n            ret+=(${tmp[$((i*9))%${#tmp[@]}]})\n        else\n\
    \            ret+=(${lst[i]})\n        fi\n    done\n    echo -n \"${ret[@]}\"",
  "  local str=$1\n  local arr\n  IFS=' ' read -a arr <<< \"$str\"\n  local len=${#arr[@]}\n\
    \  local count\n  local k\n  local val\n  local newstr\n  newstr=\"[\"\n  for\
    \ (( k = 0; k < len; k++ )); do\n    count=\"${arr[k]}\"\n    case \"$count\"\
    \ in\n      1 ) val=\"One\"; break;;\n      2 ) val=\"Two\"; break;;\n      3\
    \ ) val=\"Three\"; break;;\n      4 ) val=\"Four\"; break;;\n      5 ) val=\"\
    Five\"; break;;\n      6 ) val=\"Six\"; break;;\n      7 ) val=\"Seven\"; break;;\n\
    \      8 ) val=\"Eight\"; break;;\n      9 ) val=\"Nine\"; break;;\n      *) val=\"\
    $count\"; break;;\n    esac\n    newstr+=\" '\"$val\"'\"\n  done\n  newstr+=\"\
    ]\"\n  if [ -n \"$newstr\" ]; then\n    echo \"$newstr\"\n  else\n    return 1\n\
    \  fi", "\tlocal array=\"$1\"\n\tlocal output\n\tlocal i\n\tlocal j\n\tlocal tmp\n\
    \tlocal len\n\tlocal name\n\tlocal k\n\tlocal j\n\tlocal i\n\tlocal tmp\n\tlocal\
    \ name\n\n\tarray=( ${array[@]} )\n\n\toutput=($( printf '%s\\n' \"${array[@]:0:9}\"\
    \ ))\n\tfor (( i=1; i<=9; i++ )); do\n\t\t(( j = i*10+1 ))\n\t\ttmp=${output[j]}\n\
    \t\t(( k = j-1 ))\n\t\tif [ -z \"$tmp\" ]; then\n\t\t\tname=\"\"\n\t\telse\n\t\
    \t\tname=$( printf '%s\\n' \"${array[@]:$k:1}\" ) || return 0\n\t\tfi\n\t\ttmp=${output[j]}\n\
    \t\t(( k = j-1 ))\n\t\tif [ -z \"$tmp\" ]; then\n\t\t\tname=\"\"\n\t\telse\n\t\
    \t\tname=$( printf '%s\\n' \"${array[@]:$k:1}\" ) || return 0\n\t\tfi\n\t\ttmp=${output[j]}\n\
    \t\t(( k = j-1 ))\n\t\tif [ -z \"$tmp\" ]; then\n\t\t\tname=\"\"\n\t\telse\n\t\
    \t\tname=$( printf '%s\\n' \"${array[@]:$k:1}\" ) || return 0\n\t\tfi\n\t\toutput[$j]=\\\
    \"$name\\\"\n\tdone\n\tprintf '%s\\n' \"${output[@]}\"", "  local -a a=( $1 )\n\
    \n  local -i len=${#a[@]}\n  local -i i=0\n\n  # return an empty array for empty\
    \ list\n  if [ ${#a[@]} -eq 0 ]; then\n    return ${a[@]:-}\n  fi\n\n  local -a\
    \ a=()\n  local j k\n\n  # sort array\n  while [ $len -gt 0 ]; do\n    ((i++))\n\
    \    # reverse the array\n    len=$((len-1))\n    for ((j=0; j<len; j++)) do\n\
    \      k=$(expr $i + $j)\n      a[k]=$(a[$j])\n    done\n  done\n\n  # convert\
    \ integers to characters\n  for ((j=0; j<i; j++)) do\n    a[j]=$(by_length_replace\
    \ \"${a[j]}\")\n  done\n\n  return \"${a[@]}\"", "  local sorted_list\n  IFS='\
    \ ' read -r -a sorted_list <<< \"$1\"\n  local length=\"${#sorted_list[@]}\"\n\
    \  if [ \"${#sorted_list[@]}\" -eq 0 ]; then\n    return 1\n  fi\n  local string=\"\
    \"\n  local index=0\n  local length_count\n  while [ \"$index\" -lt \"$length\"\
    \ ]; do\n    length_count=\"${sorted_list[$index]}\"\n    if [[ \"$length_count\"\
    \ =~ ^[0-9]+$ ]]; then\n      string+=\"\\\"${sorted_list[$index]::1}\\\"\"\n\
    \    else\n      echo \"${sorted_list[$index]::1}\"\n    fi\n    ((index++))\n\
    \  done\n  echo \"$string\"", "    local -n arr=$1\n    local output\n    if [[\
    \ -z \"$arr\" ]]; then\n        return\n    fi\n    while read -a line; do\n \
    \       if [[ ${#line} -lt 4 ]]; then\n            continue\n        fi\n    \
    \    if ! [[ \"${line[0]}\" -eq 1 ]]; then\n            echo \"This array has\
    \ some strange number: $line\"\n            continue\n        fi\n        output=($(sort\
    \ -rn -k1 <<<\"${line[@]}\" | tr ' ' '\\n' | cut -d ' ' -f 9))\n        for i\
    \ in ${output[@]}; do\n            arr[$i]=\"${arr[$i]}\"\n        done\n    done\
    \ < <(echo \"${arr[@]}\" | tr ' ' '\\n' | sort -rn)", "    local x\n    local\
    \ length=${#1}\n    local output\n    # If the list length is zero\n    if [[\
    \ $length -eq 0 ]]; then\n        return\n    fi\n    # If the list is just a\
    \ single number\n    if [[ $length -eq 1 ]]; then\n        output=\"\\\"${1}\\\
    \"\"\n    # If the list length is greater than 9\n    elif [[ $length -gt 9 ]];\
    \ then\n        output=\"\\\"${1}\\\"\"\n    # Otherwise loop the list\n    else\n\
    \        for x in \"${!1}\"; do\n            local digit=${x#\"${1}\"}\n     \
    \       # If the number is between 1 and 9\n            if [[ $(( 10#$length ))\
    \ -le $(( $(( $digit )) )) -a $(( $(( $digit )%10 )) -ge 1 ]]; then\n        \
    \        output+=\"\\\"${!x}\\\"\"\n            # Otherwise replace the number\
    \ with the corresponding name\n            else\n                output+=\"\\\"\
    ${!x}\\\"\"\n            fi\n        done\n        output+=\"]\"\n    fi\n   \
    \ eval \"$output\"", "    local names=\"One Two Three Four Five Six Seven Eight\
    \ Nine\"\n    local length=${#1}\n    for (( i = 1; i <= length; i++ )); do\n\
    \        local item=${1[i]}\n        local name=${names[${item}]}\n        if\
    \ [[ ${item} -ge 1 ]] && [[ ${item} -le 9 ]]; then\n            # replace item\
    \ by name in the list\n            echo \"${name}\"\n        elif [[ ${item} -eq\
    \ 0 ]]; then\n            echo \"[]\"\n        fi\n    done", "    local tmp\n\
    \    local i\n\n    local array=($@)\n    tmp=${array[@]}\n    for ((i=0; i <\
    \ ${#tmp[@]}; i++)); do\n        if [[ $tmp[$i] -lt 0 || $tmp[$i] -gt 9 ]]; then\n\
    \            continue\n        fi\n        tmp[$i]=$((${array[$i]} + 10 * ${array[$i]}\
    \ % 100))\n    done\n\n    local list\n    list=${tmp[@]}\n    while [[ ${#list[@]}\
    \ -gt 0 ]]; do\n        local a=${list[0]}\n        list=(${list[@]:1})\n    \
    \    local b=${list[0]}\n        list=(${list[@]:1})\n        local c=${list[0]}\n\
    \        list=(${list[@]:1})\n        local d=${list[0]}\n        list=(${list[@]:1})\n\
    \        local e=${list[0]}\n        list=(${list[@]:1})\n        local f=${list[0]}\n\
    \        list=(${list[@]:1})\n        local g=${list[0]}\n        list=(${list[@]:1})\n\
    \        local h=${list[0]}\n        list=(${list[@]:1})\n        local i=${list[0]}\n\
    \        list=(${list[@]:1})\n        local j=${list[0]}\n        list=(${list[@]:1})\n\
    \        local k=${list[0]}\n        list=(${list[@]:1})\n        local l=${list[0]}\n\
    \        list=(${list[@]:1})\n        local m=${list[0]}\n        list=(${list[@]:1})\n\
    \        local n=${list[0]}\n        list=(${list[@]:1})\n        local o=${list[0]}\n\
    \        list=(${list[@]:1})\n        local p=${list[0]}\n        list=(${list[@]:1})\n\
    \        local q=${list[0]}\n        list=(${list[@]:1})\n        local r=${list[0]}\n\
    \        list=(${list[@]:1})\n        local s=${list[0]}\n        list=(${list[@]:1})\n\
    \        local t=${list[0]}\n        list=(${list[@]:1})\n        local u=${list[0]}\n\
    \        list=(${list[@]:1})\n        local v=${list[0]}\n        list=(${list[@]:1})\n\
    \        local w=${list[0]}\n        list=(${list[@]:1})\n        local x=${list[0]}\n\
    \        list=(${list[@]:1})\n        local y=${list[0]}\n        list=(${list[@]:1})\n\
    \        local ", "  local array=( $1 )\n  local lengths=( ${array[@]} )\n  local\
    \ output\n  local i\n\n  for i in \"${!lengths[@]}\"; do\n    local digit=$( printf\
    \ '%02x' $( printf '%03d' ${lengths[i]} ))\n    local j=$(( ${#output[@]} - 1\
    \ ))\n    local prefix\n    while (( j >= 0 )); do\n      if (( ${lengths[j]}\
    \ == 0 )); then\n        output=(${output[@]})\n        break\n      fi\n    \
    \  prefix=\"${output[j]}\"\n      if (( digit < ${#prefix} )); then\n        output=(${output[@]:j:1})\n\
    \        break\n      fi\n      output=(${output[@]:j:1}${prefix:${#prefix}}${output[j+1]})\n\
    \      j=$(( j - 1 ))\n    done\n  done\n  echo \"${output[@]}\"", "  local numbers=$1\n\
    \  shift\n  local result\n  local i\n  result=()\n  i=0\n  while [ -n \"${numbers}\"\
    \ ]; do\n    number=\"${numbers:$i:1}\"\n    if [[ ${number:0:1} == \"-\" ]];\
    \ then\n      number=${number:1}\n      result+=(\"${numbers[$((${i}-1))]}\")\n\
    \      numbers=${numbers:${i}:${#number}}\n      ((i--))\n    else\n      result+=(\"\
    ${numbers[$i]}\")\n      ((i++))\n    fi\n  done\n  echo \"${result[@]}\"", " \
    \ local array\n  IFS=\" \" read -r -a array <<< \"$1\"\n  local -n arr=$array\n\
    \  declare -i -i len=${#arr[@]}\n  local -n item\n  local -n key\n  local -i idx\n\
    \  local -n res\n  if (( len )) ; then\n    declare -i index\n    for idx in \"\
    ${!arr[@]}\"; do\n      item=\"${arr[idx]}\"\n      key=\"$item\"\n      case\
    \ \"$item\" in\n        1)\n          key=\"One\"\n          ;;\n        2)\n\
    \          key=\"Two\"\n          ;;\n        3)\n          key=\"Three\"\n  \
    \        ;;\n        4)\n          key=\"Four\"\n          ;;\n        5)\n  \
    \        key=\"Five\"\n          ;;\n        6)\n          key=\"Six\"\n     \
    \     ;;\n        7)\n          key=\"Seven\"\n          ;;\n        8)\n    \
    \      key=\"Eight\"\n          ;;\n        9)\n          key=\"Nine\"\n     \
    \     ;;\n        *)\n          key=\"???\"\n          ;;\n      esac\n      arr[idx]=\"\
    $key\"\n    done\n    res=(${arr[@]})\n  fi\n  printf \"'%s'\\n\" \"${res[@]}\"",
  "  declare -a A=() _iter=0\n  for I in $(echo \"$1\" | tr \" \" \"\\n\")\n  do\n\
    \    case \"$I\" in\n      \"0\")\n        continue ;;\n      \"1\")\n       \
    \ A+=(\"One\") ;;\n      \"2\")\n        A+=(\"Two\") ;;\n      \"3\")\n     \
    \   A+=(\"Three\") ;;\n      \"4\")\n        A+=(\"Four\") ;;\n      \"5\")\n\
    \        A+=(\"Five\") ;;\n      \"6\")\n        A+=(\"Six\") ;;\n      \"7\"\
    )\n        A+=(\"Seven\") ;;\n      \"8\")\n        A+=(\"Eight\") ;;\n      \"\
    9\")\n        A+=(\"Nine\") ;;\n      *)\n        continue\n        ;;\n    esac\n\
    \  done\n  printf \"[%s]\" \"${A[@]}\"", "    local -n arr=$1\n\n    local -i\
    \ i\n\n    if [[ -z \"$arr\" ]]; then\n        return $2\n    elif [[ ${#arr[@]}\
    \ -eq 0 ]]; then\n        return $2\n    elif [[ \"$1\" =~ ^-?[0-9]+$ ]]; then\n\
    \        local -a length\n        for i in \"${arr[@]}\"; do\n            length+=(\"\
    $i\")\n        done\n        length=${#length[@]}\n        if [[ ${#length[@]}\
    \ -eq 0 ]]; then\n            return $2\n        fi\n\n        local -i index\n\
    \        for index in $(seq 0 $(( ${#length[@]} - 1 ))); do\n            if [[\
    \ ${length[$index]} -ge ${#arr[@]} ]]; then\n                unset length[$index]\n\
    \            fi\n        done\n        arr=(\"${length[@]}\" \"${arr[@]}\")\n\
    \        arr=(\"${arr[@]:1:$#arr[@]}\")\n        if [[ ${#arr[@]} -eq 0 ]]; then\n\
    \            return $2\n        fi\n    fi\n\n    local -n tmp=$2\n\n    if [[\
    \ ${#arr[@]} -gt 0 ]]; then\n        local -a names\n        for i in \"${arr[@]}\"\
    ; do\n            names+=($i)\n        done\n        arr=(\"${names[@]:1:$#names[@]}\"\
    )\n    fi\n\n    arr=(\"${arr[@]}\")\n\n    if [[ ${#arr[@]} -gt 0 ]]; then\n\
    \        tmp=()\n        for i in \"${arr[@]}\"; do\n            if [[ ${i} -ge\
    \ 1 && ${i} -le 9 ]]; then\n                tmp+=($i)\n            fi\n      \
    \  done\n        arr=(\"${tmp[@]}\")\n    fi\n\n    if [[ ${#arr[@]} -gt 0 ]];\
    \ then\n        tmp=()\n        for i in \"${arr[@]}\"; do\n            tmp+=($((10*($i-1))))\n\
    \        done\n        arr=(\"${tmp[@]}\")\n    fi\n\n    if [[ ${#arr[@]} -gt\
    \ 0 ]]; then\n        tmp=()\n        for i in \"${arr[@]}\"; do\n           \
    \ if [[ $((10*$i)) -le ${#arr[@]} ]]; then\n                tmp+=($((10*$i)))\n\
    \            fi\n        done\n        arr=(\"${tmp[@]}\")\n    fi\n\n    arr=(\"\
    ${arr[@]}\")\n\n    if [[ ", "    local -n arr=$1\n    local -r new=()\n    local\
    \ -r size=${#arr[@]}\n\n    if [ $size -eq 0 ]; then\n        return 0\n    fi\n\
    \n    for (( i=0; i<$size; i++ )); do\n        if [ $(( $i % 10 )) -eq 0 ]; then\n\
    \            local -n value=${arr[i]}\n            new[${#new[@]}-1]=\"\\\"${new[${#new[@]}-1]}\\\
    \"\"\n            new[${#new[@]}-1]+=\"\\\"${value}\\\"\"\n        else\n    \
    \        new+=(${arr[i]})\n        fi\n    done\n\n    if [ $(( i % 10 )) -eq\
    \ 0 ]; then\n        new[${#new[@]}-1]=\"\\\"${new[${#new[@]}-1]}\\\"\"\n    fi\n\
    \n    printf '%s\\n' \"${new[@]}\"", "  local IFS=$'\\t'\n  local -a arr=(\"$1\"\
    \ \"\")\n  for (( c=1; c<=9; c++ )); do\n    local idx=-1\n    local tmp=\n  \
    \  for (( i=0; i<${#arr[@]}; i++ )); do\n      idx=$(( idx+1 ))\n      tmp=$((\
    \ tmp*10 + ${arr[$i]} ))\n      if [ ${tmp} -gt 9 ]; then\n        tmp=\n    \
    \    break\n      fi\n    done\n    if [ \"$idx\" -gt 0 ]; then\n      tmp=$((\
    \ ${tmp} + 10 ))\n      arr[$idx]=\"$(( ${arr[$idx]} + 1 ))\"\n    fi\n  done\n\
    \  IFS=$' \\t\\n'\n  echo \"${arr[@]}\"", "\tlocal -n arr=$1\n\tlocal length\n\
    \tfor length in ${arr[@]}; do\n\t\tif [[ $length =~ ^[0-9]+$ ]]; then\n\t\t\t\
    local num=$(by_length $((${length}-${#arr[@]}+1))) 2>/dev/null\n\t\t\tif [[ -n\
    \ ${num} ]]; then\n\t\t\t\tarr=($(echo \"${num}\" | tr \" \" \"\\n\"))\n\t\t\t\
    else\n\t\t\t\tarr=()\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"${arr[@]}\"",
  "  local sorted_list\n  sorted_list=( $1 )\n  local length number\n\n  length=${#sorted_list[@]}\n\
    \  number=${sorted_list[$(( length - 1 ))]}\n\n  shift $(( length - 1 ))\n\n \
    \ while (( ${#sorted_list[@]} > 0 ))\n  do\n    if (( number >= 1 && number <=\
    \ 9 ))\n    then\n      sorted_list=(\"${sorted_list[@]:1}\" \"${sorted_list[$((\
    \ length - 1 )):$(( length - 1 ))]}\")\n      sorted_list=( \"${sorted_list[@]}\"\
    \ )\n      number=${sorted_list[$(( length - 1 ))]}\n    fi\n    shift\n  done\n\
    \n  echo \"${sorted_list[@]}\"", "  local -a numbers=(\"$@\")\n  if [ -z \"${numbers[*]}\"\
    \ ] ; then\n    return 0\n  fi\n  local -a sorted=()\n  local -a reversed=()\n\
    \  local -i n\n  for (( n=1; n<=9; n++ )); do\n    sorted+=( \"$n\" )\n  done\n\
    \  local i\n  for i in \"${sorted[@]}\"; do\n    local l=${i}\n    while (( l\
    \ > 0 )); do\n      reversed+=( \"$(( 10#$l - 1 ))\" )\n      l=$(( l-1 ))\n \
    \   done\n  done\n  local j\n  for (( j=${#sorted[@]}-1; j>=0; j-- )); do\n  \
    \  local l=${sorted[j]}\n    while (( l > 0 )); do\n      local number=${reversed[j]}\n\
    \      reversed[j]=${reversed[j]%??}\n      local length=${#reversed[j]}\n   \
    \   reversed[j]=${reversed[j]#??}\n      reversed[j]=${reversed[j]%??}\n     \
    \ reversed[j]=$(( 10#$number - $length ))\n      l=$(( l-1 ))\n    done\n  done\n\
    \  echo \"${reversed[@]}\"", "\tlocal a str=\"\\\"$@\\\";\"\n\tlocal b\n\ta=\"\
    $(awk '\n\t\tBEGIN {\n\t\t\tsplit($1,a,\" \");\n\t\t}\n\t\t{\n\t\t\tfor (i in\
    \ a) {\n\t\t\t\tgsub(/^0/,\"\\\"One\\\"\",$i);\n\t\t\t\tgsub(/^1/,\"\\\"Two\\\"\
    \",$i);\n\t\t\t\tgsub(/^2/,\"\\\"Three\\\"\",$i);\n\t\t\t\tgsub(/^3/,\"\\\"Four\\\
    \"\",$i);\n\t\t\t\tgsub(/^4/,\"\\\"Five\\\"\",$i);\n\t\t\t\tgsub(/^5/,\"\\\"Six\\\
    \"\",$i);\n\t\t\t\tgsub(/^6/,\"\\\"Seven\\\"\",$i);\n\t\t\t\tgsub(/^7/,\"\\\"\
    Eight\\\"\",$i);\n\t\t\t\tgsub(/^8/,\"\\\"Nine\\\"\",$i);\n\t\t\t}\n\t\t}\n\t\t\
    END {\n\t\t\tfor (i in b) {\n\t\t\t\tgsub(/^0/,\"\\\"One\\\"\",$i);\n\t\t\t\t\
    gsub(/^1/,\"\\\"Two\\\"\",$i);\n\t\t\t\tgsub(/^2/,\"\\\"Three\\\"\",$i);\n\t\t\
    \t\tgsub(/^3/,\"\\\"Four\\\"\",$i);\n\t\t\t\tgsub(/^4/,\"\\\"Five\\\"\",$i);\n\
    \t\t\t\tgsub(/^5/,\"\\\"Six\\\"\",$i);\n\t\t\t\tgsub(/^6/,\"\\\"Seven\\\"\",$i);\n\
    \t\t\t\tgsub(/^7/,\"\\\"Eight\\\"\",$i);\n\t\t\t\tgsub(/^8/,\"\\\"Nine\\\"\",$i);\n\
    \t\t\t}\n\t\t}\n\t' <<<\"$str\")\"\n\tlocal i\n\tb=\"\"\n\tfor i in $a; do\n\t\
    \tb=\"$b\"'\"$i\"'\n\tdone\n\techo \"$b\"", "  local -r list=$(readarray -t \"\
    $1\")\n  local -r length=${#list[@]}\n  if (( \"${#list[@]}\" )); then\n    local\
    \ -r string\n    for (( i=0; i < ${#list[@]}; i++ )); do\n      string=\"$string\
    \ \\\"${list[$i]}\\\"\"\n    done\n    string=\"($(sort --reverse <<<\"${string}\"\
    \ <<<\"${list[0]}\"))\"\n    if [ \"${string// }\" != \"$string\" ]; then\n  \
    \    echo \"${string// }\"\n    else\n      echo \"${list[@]}\"\n    fi\n  else\n\
    \    echo \"\"\n  fi", "  local IFS=' '\n  read -d '' -a lengths < <(\n    awk\
    \ -F\"[, ]\" -v OFS=: 'BEGIN{max=0; maxlen=0; for (i=1;i<=NF;i++) max=max>lengths[i]?max:lengths[i];\
    \ maxlen=lengths[max]}\n                  {printf \"%s%s\", lengths[$0], (i<NF?OFS:ORS)}'\
    \ <<< \"$1\"\n  )\n  local sorted=( )\n  local sortedlen\n  local i\n  for ((i=1;i<=max;i++));\
    \ do\n    sortedlen=\"${#lengths[@]}\"\n    for ((j=1;j<=sortedlen;j++)); do\n\
    \      if [[ ${lengths[$j]} -ge ${i} ]]; then\n        sorted+=(${lengths[$j]})\n\
    \        sortedlen=\"${#lengths[@]}\"\n      fi\n    done\n  done\n  for ((i=1;i<=sortedlen;i++));\
    \ do\n    local k\n    local j\n    for ((k=1;k<=sortedlen;k++)); do\n      local\
    \ kd\n      kd=$((k-i))\n      if [[ ${sorted[$k]} -ge ${sorted[$kd]} ]]; then\n\
    \        sorted[$k]=\"${sorted[$kd]}\"\n        sortedlen=$((k-1))\n      fi\n\
    \    done\n  done\n  local elements=()\n  local element\n  for ((i=0;i<=sortedlen;i++));\
    \ do\n    element+=\"\\\"${sorted[i]}\\\"\"\n  done\n  printf \"${elements[@]}\\\
    n\"", "    local input_arr=$1\n    local output_arr=()\n    local curr_val\n \
    \   local output_str\n\n    if [[ -n $input_arr ]]; then\n        curr_val=$input_arr\n\
    \        IFS=' '\n        while [[ $curr_val ]]; do\n            if [[ $curr_val\
    \ -gt 9 ]]; then\n                curr_val=$(( $curr_val / 10 ))\n           \
    \     output_arr+=( '\"Nine\"' )\n            else\n                output_arr+=(\
    \ $( echo \"$curr_val\" | sed -e 's/^\\([0-9]*\\)/\\1/' ) )\n            fi\n\
    \            curr_val=( $( echo \"$curr_val%10\" ) )\n        done\n    fi\n \
    \   output_str=\"\\\"${output_arr[@]//\\\"/\\\"}\\\"\"\n    echo $output_str",
  "  if [[ \"$1\" != \"\" ]]; then\n    local numlist=(\"${1//[^[:digit:]] }\")\n\
    \    local nums=()\n    for n in \"${numlist[@]}\"; do\n      local digit=(\"\
    ${n//[^[:digit:]] }\")\n      local length=${#digit[@]}\n      local reversed=()\n\
    \      while (( length > 0 )); do\n        reversed+=(\"${digit[length]}\")\n\
    \        length=${#digit[@]}\n      done\n      nums+=(\"${reversed[@]}\")\n \
    \   done\n    if [[ \"${nums[*]}\" = \"\" ]]; then\n      echo \"[]\"\n    else\n\
    \      echo \"${nums[*]}\"\n    fi\n  else\n    local nums=()\n    for n in \"\
    ${@//[^[:digit:]] }\"; do\n      local digit=(\"${n//[^[:digit:]] }\")\n     \
    \ local length=${#digit[@]}\n      local reversed=()\n      while (( length >\
    \ 0 )); do\n        reversed+=(\"${digit[length]}\")\n        length=${#digit[@]}\n\
    \      done\n      nums+=(\"${reversed[@]}\")\n    done\n    if [[ \"${nums[*]}\"\
    \ = \"\" ]]; then\n      echo \"[]\"\n    else\n      echo \"${nums[*]}\"\n  \
    \  fi\n  fi", "    local array=\"$1\"\n    if [ \"${array}\" = \"\" ]; then\n\
    \        echo \"[]\"\n    elif [[ \"${array}\" =~ ^[0-9]+$ ]]; then\n        array=($(sort\
    \ -r -n <<<\"${array}\"|head -n 1))\n        local numbers=(${array[@]})\n   \
    \     local lengths=$(wc -w <<<\"${numbers[@]}\")\n        local one=\"One\"\n\
    \        local two=\"Two\"\n        local three=\"Three\"\n        local four=\"\
    Four\"\n        local five=\"Five\"\n        local six=\"Six\"\n        local\
    \ seven=\"Seven\"\n        local eight=\"Eight\"\n        local nine=\"Nine\"\n\
    \        if [ \"${lengths}\" -le 5 ]; then\n            local output=(${one,$two,$three,$four,$five,$six,$seven,$eight,$nine})\n\
    \            local name\n            for i in \"${!output[@]}\"; do\n        \
    \        name=\"${output[$i]}\"\n                array=${array//[0-9]}/${name}\n\
    \            done\n        fi\n        echo \"${array[@]}\"\n    else\n      \
    \  echo \"${array}\"\n    fi", "\tlocal arr\n\tarr=( $1 )\n\tIFS=' '\n\tarr=(${arr[@]/#/})\n\
    \tunset IFS\n\tlocal length=0\n\tlocal count=0\n\tlocal result=()\n\tlocal item\n\
    \tfor item in \"${arr[@]}\"; do\n\t\tif [ \"$item\" == \"1\" -a \"$item\" != \"\
    \" ]; then\n\t\t\t((length++))\n\t\tfi\n\t\tif [ \"$item\" == \"9\" -a \"$item\"\
    \ != \"\" ]; then\n\t\t\t((length++))\n\t\tfi\n\tdone\n\tfor (( i = 0; i < ${#arr[@]};\
    \ i++ )); do\n\t\tlocal item\n\t\tfor (( j = 0 ; j < ${#arr[@]} ; j++ )); do\n\
    \t\t\tif [[ ${arr[j]} == $i ]]; then\n\t\t\t\tcount=$(( ${arr[j]} + 1))\n\t\t\t\
    \tarr[$j]=$count\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif [ $count -eq 10 ];\
    \ then\n\t\t\tresult+=( $(by_number \"$count\") )\n\t\tfi\n\tdone\n\techo \"${result[@]}\"",
  "\tlocal arr=($1)\n\tlocal n=0\n\tlocal lengths\n\tlocal names\n\tlocal output\n\
    \n\t# We need to convert the numbers in $arr into integers because bash can't\n\
    \t# compare ints with strings and will treat \"1\" < \"2\".\n\tarr=( $( echo ${arr[@]}\
    \ | tr ' ' '\\n' | sort -n -k 2 | tr '\\n' ' ' ) )\n\tlengths=$( echo ${arr[@]}\
    \ | tr ' ' '\\n' | awk '{print $2}' )\n\n\tfor n in $(seq 1 $((${#arr[@]}-1))\
    \ )\n\tdo\n\t\tlocal length\n\t\tlength=$(echo ${lengths} | awk \"NR==$n\")\n\t\
    \tname=$( awk \"NR==$n {print \\\\$1 }\" <<< \"$arr[$n]\" )\n\t\tarr[$n]=\"\\\"\
    $name\\\"\"\n\tdone\n\tarr=( \"${arr[@]}\" )\n\n\toutput=$( echo ${arr[@]} | tr\
    \ ' ' '\\n' | sort -n -k 2 | tr '\\n' ',' )\n\toutput=$( echo \"${output}\" |\
    \ sed -e \"s/\\\"$/ \\\"\\\"/g\" )\n\n\toutput=\"[${output}]\"\n\n\techo $output",
  "  local -n arr=(\"$@\")\n  local -i len=${#arr[*]}\n  local -i i\n  local -a res\n\
    \  for ((i=0; i<len; i++)); do\n    arr[$i]=$((len-i))\n  done\n  for ((i=0; i<len;\
    \ i++)); do\n    if (( ${#arr[$i]} > 0 )) && (( $i <= ${#arr[$i]} )); then\n \
    \     res+=(\"\\\"${arr[$i]}\\\"\")\n    fi\n  done\n  echo \"${res[@]}\"", " \
    \ local i result\n\n  if [ \"$1\" == \"\" ]; then\n    return 0\n  fi\n\n  result=()\n\
    \  i=1\n  while [ $i -le 10 ]; do\n    result+=( \"$One\" \"$Two\" \"$Three\"\
    \ \"$Four\" \"$Five\" \"$Six\" \"$Seven\" \"$Eight\" \"$Nine\" \"$i\" )\n    i=$(($i+1))\n\
    \  done\n\n  result=( \"${result[@]:0:9}\" )\n\n  for (( i=0; i<${#result[@]};\
    \ i++ )); do\n    eval ${result[$i]}=${result[$(($i-1))]}\n  done\n\n  IFS=$'\
    \ \\t\\n'\n  echo \"${result[@]}\"", "  local -i num\n  local -a result\n  IFS=$'\
    \ \\t\\n\\r' read -r -a array <<< \"$1\"\n  for num in \"${array[@]}\"; do\n \
    \   if [[ \"$num\" =~ ^([[:digit:]]*[[:space:]]*)$ ]]; then\n      array=( ${num//[[:space:]]/\
    \ } )\n      result+=($(echo \"${array[*]}\" | tr [a-z] [A-Z]))\n      result+=($(echo\
    \ \"${array[*]}\" | rev))\n    else\n      result+=(\"$num\")\n    fi\n  done\n\
    \  result=( \"${result[@]}\" )\n  echo -n \"${result[*]}\"", "  local array=\"\
    $1\"\n  local output\n  local i\n  output=$(by_length_helper \"$array\" \"\")\n\
    \  for i in \"${!output[@]}\"; do\n    output[i]=\"\\\"${output[i]}\\\"\"\n  done\n\
    \  echo \"${output[@]}\"", "\tlocal -n integers=$1\n\tintegers=${integers// /-}\n\
    \tintegers=${integers/,/\\-}\n\tintegers=${integers//\\ -/}\n\tintegers=${integers//-/}\n\
    \tintegers=${integers//,/\\\"}\n\tintegers=${integers//\\//\\\"}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//-\\\
    \"//}\n\tintegers=${integers//\\//\\\"//}\n\tintegers=${integers//\\\"//}\n\t\
    integers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//,\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//,\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\"//}\n\tintegers=${integers//\\\
    \"//}\n\t", "    local array=(\"${@//,/ }\")\n    local i=0\n    local arr=()\n\
    \n    while [ $i -lt ${#array[@]} ]; do\n        local element=${array[$i]}\n\
    \        if (( element >= 1 && element <= 9 )); then\n            local length=${#array[@]}\n\
    \            local j=$((length-1))\n            while [ \"$j\" -gt $i ] && [ \"\
    $element\" -ge ${array[$j]} ]; then\n                j=$((j-1))\n            done\n\
    \            arr=($arr \"${element//[0-9]/$((length-1))}\")\n            array[$i]=${array[$j]}\n\
    \        fi\n        i=$((i+1))\n    done\n\n    declare -p arr", "\tlocal -a\
    \ a=( )\n\tlocal b\n\n\t# Remove all space characters from the array\n\twhile\
    \ IFS= read -r b; do a+=( ${b// / } ); done\n\n\t# Remove all negative numbers\n\
    \ta=(${a[@]/#/ })\n\n\t# Sort from greatest to least by length\n\tb=( \"${a[*]##*-}\"\
    \ )\n\tb=(${b[*]})\n\n\t# Reverse the array\n\tb=(${b[@]/%/9})\n\n\t# Replace\
    \ each digit by its corresponding name from one...nine\n\tb=(\n\t\tfor ((i = 0;\
    \ i < ${#a[@]}; i++)); do\n\t\t\tb[i]=\"${b[i]#*One}\"\n\t\t\tb[i]=\"${b[i]#*Two}\"\
    \n\t\t\tb[i]=\"${b[i]#*Three}\"\n\t\t\tb[i]=\"${b[i]#*Four}\"\n\t\t\tb[i]=\"${b[i]#*Five}\"\
    \n\t\t\tb[i]=\"${b[i]#*Six}\"\n\t\t\tb[i]=\"${b[i]#*Seven}\"\n\t\t\tb[i]=\"${b[i]#*Eight}\"\
    \n\t\t\tb[i]=\"${b[i]#*Nine}\"\n\t\t\tb[i]=\"${b[i]#*0}\"\n\t\t\tb[i]=\"${b[i]#*1}\"\
    \n\t\t\tb[i]=\"${b[i]#*2}\"\n\t\t\tb[i]=\"${b[i]#*3}\"\n\t\t\tb[i]=\"${b[i]#*4}\"\
    \n\t\t\tb[i]=\"${b[i]#*5}\"\n\t\t\tb[i]=\"${b[i]#*6}\"\n\t\t\tb[i]=\"${b[i]#*7}\"\
    \n\t\t\tb[i]=\"${b[i]#*8}\"\n\t\tdone\n\t\techo \"${b[*]}\"\n\t)", "  local items=(\
    \ \"$1\" )\n  local arr=()\n  local num\n  for item in \"${items[@]}\"; do\n \
    \   if (( item < 1 || item > 9 )); then\n      continue\n    elif [ \"$item\"\
    \ -eq \"$item\" ]; then\n      arr+=( \"$item\" )\n    elif [ \"$item\" -lt 10\
    \ ]; then\n      arr+=( \"${item/0/One}\" \"${item/1/Two}\" \"${item/2/Three}\"\
    \ \"${item/3/Four}\" \"${item/4/Five}\" \"${item/5/Six}\" \"${item/6/Seven}\"\
    \ \"${item/7/Eight}\" \"${item/8/Nine}\" )\n    elif [ \"$item\" -eq 10 ]; then\n\
    \      arr+=( \"${item/0/Ten}\" \"${item/1/Nine}\" )\n    else\n      arr+=( \"\
    ${item/0/One}\" \"${item/1/Two}\" \"${item/2/Three}\" \"${item/3/Four}\" \"${item/4/Five}\"\
    \ \"${item/5/Six}\" \"${item/6/Seven}\" \"${item/7/Eight}\" \"${item/8/Nine}\"\
    \ \"${item/9/*}\" )\n    fi\n  done\n  echo \"${arr[@]}\"", "  local array=\"\
    $1\"\n  array=\"$(by_length_no_spaces \"$array\")\"\n  echo \"${array[@]}\"",
  "  local l\n  read -a l <<< \"$1\"\n  local -i j\n  for i in \"${l[@]}\"; do\n \
    \   if [[ $i =~ ^[0-9]+$ ]]; then\n      j=$((10#$i + 1))\n      printf '%s\\\
    n' \"${!j}\"\n    elif [[ $i =~ ^[[:alpha:]]+$ ]]; then\n      printf '%s\\n'\
    \ \"${!i}\"\n    fi\n  done", "\tlocal numbers=$1\n\tlocal lengths\n\tnumbers=${numbers//\
    \ /}\n\tlengths=($(seq 1 9))\n\tfor index in ${!lengths[*]}; do\n\t\tnumbers=$(printf\
    \ \"${numbers/%${lengths[index]}d}/${lengths[index]}\" ${numbers/[0-9]/})\n\t\
    done\n\tprintf \"['%s']\" \"${numbers// /}'\"", "  if [ -z \"$1\" ]; then\n  \
    \  return 0\n  fi\n  local -r arr=($(echo \"$1\" | tr ' ' '\\n' | sort -n | uniq))\n\
    \  local -r arr2=\"\"\n  local -r i=0\n  local -r num=\n  while [[ $i -lt ${#arr[*]}\
    \ ]]; do\n    local -r num=${arr[$i]}\n    arr2+=\"\\\"${num}\\\"\"\n    i=$((i\
    \ + 1))\n  done\n  echo \"${arr2}\"", "  local nums=${1//\" / }\n  local size=${#nums[@]}\n\
    \  local -a result\n\n  IFS=' ' read -r -a nums <<< \"$nums\"\n  result=()\n \
    \ for (( i=0; i<=9; i++ )); do\n    local index=$((i%size))\n    local value\n\
    \    if [[ ${nums[index]} == 1 ]]; then\n      value=\"\\\"One\\\"\"\n    elif\
    \ [[ ${nums[index]} == 2 ]]; then\n      value=\"\\\"Two\\\"\"\n    elif [[ ${nums[index]}\
    \ == 3 ]]; then\n      value=\"\\\"Three\\\"\"\n    elif [[ ${nums[index]} ==\
    \ 4 ]]; then\n      value=\"\\\"Four\\\"\"\n    elif [[ ${nums[index]} == 5 ]];\
    \ then\n      value=\"\\\"Five\\\"\"\n    elif [[ ${nums[index]} == 6 ]]; then\n\
    \      value=\"\\\"Six\\\"\"\n    elif [[ ${nums[index]} == 7 ]]; then\n     \
    \ value=\"\\\"Seven\\\"\"\n    elif [[ ${nums[index]} == 8 ]]; then\n      value=\"\
    \\\"Eight\\\"\"\n    elif [[ ${nums[index]} == 9 ]]; then\n      value=\"\\\"\
    Nine\\\"\"\n    else\n      echo \"${nums[index]}: Invalid digit. Must be 1-9\"\
    \n      return 1\n    fi\n    result+=(\"${value}\")\n  done\n  echo \"${result[@]}\"",
  "\tlocal arr=$1 len $2 key val i\n\tIFS=' ' read -ra arr <<< \"$1\"\n\tfor i in\
    \ \"${arr[@]:1}\"; do\n\t\tkey=$((i-1))\n\t\tval=$(printf \"%s\" \"$i\" | tr -d\
    \ '[[:digit:]]')\n\t\tarr[$key]=$((10#$val+$i))\n\tdone\n\tarr=( \"${arr[@]}\"\
    \ )\n\tprintf \"[%s]\" \"${arr[@]}\"", "  local length=\"$1\"\n  shift\n  local\
    \ arr=( )\n  local -i i\n  local name\n  local num\n  for ((i = 0; i < ${#length};\
    \ i++)); do\n    num=${length:$i:1}\n    if [[ ${num} -lt 1 || ${num} -gt 9 ]];\
    \ then\n      continue\n    fi\n    arr+=(\"$name\")\n  done\n  if [[ \"${#arr}\"\
    \ -eq 0 ]]; then\n    return 1\n  fi\n  for name in \"${arr[@]}\"; do\n    printf\
    \ -v \"$name\" \"\\\"${name/%\\([0-9]\\)/\\\"$((${#name} - 1)) }\\\"\\0\"\n  done\n\
    \  printf -v \"$name\" \"%.0s\" \"${arr[@]}\"", "    local numbers=()\n    local\
    \ output\n    local i\n    local j\n    for ((i=0; i<${#1}; i++)); do\n      \
    \  if (( \"${1:$i:1}\" -ge 1 )); then\n            if (( \"${1:$i:1}\" -le 9 ));\
    \ then\n                numbers+=(\"${1:$i:1}\")\n            else\n         \
    \       printf -v j \"%d\" \"${1:$i:1}\"\n                numbers+=(\"${!j}\"\
    )\n            fi\n        fi\n    done\n    for (( i=0; i<${#numbers[*]}; i++\
    \ )); do\n        local j=0\n        while (( j<${#names[*]} && numbers[$i]>0\
    \ )); do\n            printf -v j \"%d\" \"${names[$j]}\"\n            (( j++\
    \ ))\n        done\n        if (( \"${numbers[$i]}\" == 0 )); then\n         \
    \   break\n        fi\n        output+=(\"${names[j]}\")\n    done\n    printf\
    \ '%s\\n' \"${output[@]}\"", "  local arr digit\n  IFS=' ' read -r -a arr <<<\
    \ \"$1\"\n  IFS=' ' read -r -a digits <<< \"$2\"\n  for (( i = 0; i < ${#arr[@]};\
    \ i++ )); do\n    if [[ ${digits[i]} -ge 0 && ${digits[i]} -lt 10 ]]; then\n \
    \     # We need to convert each digit to its name from the digits array\n    \
    \  # and insert it into the arr array at position i\n      arr[i]=${digits[i]}\n\
    \      # Now we need to get the name of the number in the arr and insert it into\
    \ the\n      # digits array at position i\n      digits[i]=${arr[${i}]}\n    fi\n\
    \  done\n  echo \"${arr[@]}\"", "    local array names i=0 name=\"\"\n    IFS='\
    \ ' read -r -a array <<<\"$1\"\n\n    names=( ${array[@]:0:9} )\n    array=( ${array[@]:9}\
    \ )\n\n    for name in \"${names[@]}\"; do\n        # echo \"$name\"\n       \
    \ array[$((${#array[@]} - 1))]=\"$name\"\n    done\n\n    echo \"${array[@]}\"",
  "    local arr=\"$1\"\n    local res\n    if [[ \"$arr\" =~ '^ *[0-9]+$' ]]; then\n\
    \        local -a arr=(${arr// / })\n        local -a res=()\n        for i in\
    \ ${arr[@]}; do\n            if (( ${i} >= 1 && ${i} <= 9 )); then\n         \
    \       res+=(\"${i}\")\n            else\n                echo \"error: invalid\
    \ number '${i}'\" >&2\n                exit 1\n            fi\n        done\n\
    \        echo \"${res[@]}\"\n    else\n        echo \"error: invalid input format\
    \ '${arr}'\" >&2\n        exit 1\n    fi", "\tlocal arr=\"${1#*( )}\"\n\tarr=\"\
    ${arr%% }\"\n\tarr=\"${arr// * }\"\n\tarr=\"${arr// /}\"\n\tarr=\"${arr// /}\"\
    \n\tarr=\"${arr% }\"\n\tarr=\"${arr//@ }\"\n\tarr=\"${arr//:/ }\"\n\tarr=\"${arr//\\\
    `/ }\"\n\tarr=\"${arr//&/ }\"\n\tarr=\"${arr//;/ }\"\n\tarr=\"${arr//!/ }\"\n\t\
    arr=\"${arr//$/ }\"\n\tarr=\"${arr//#/ }\"\n\tarr=\"${arr//=/ }\"\n\tarr=\"${arr//\\\
    </ }\"\n\tarr=\"${arr//\\>/ }\"\n\tarr=\"${arr//[/ }\"\n\tarr=\"${arr//]/ }\"\n\
    \tarr=\"${arr//-/ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"${arr//'/ }\"\n\tarr=\"\
    ${arr//,/ }\"\n\tarr=\"${arr//\\\"/ }\"\n\tarr=\"${arr//\\ }\"\n\tarr=\"${arr//\\\
    ?/ }\"\n\tarr=\"${arr//!/ }\"\n\tarr=\"${arr//^/ }\"\n\tarr=\"${arr//,/ }\"\n\t\
    arr=\"${arr/// }\"\n\tarr=\"${arr//{/ }\"\n\tarr=\"${arr//} }\"\n\tarr=\"${arr//(/\
    \ }\"\n\tarr=\"${arr//)/ }\"\n\tarr=\"${arr//{/ }\"\n\tarr=\"${arr//(/ }\"\n\t\
    arr=\"${arr//)/ }\"\n\tarr=\"${arr//|/ }\"\n\tarr=\"${arr//} }\"\n\tarr=\"${arr///\
    \ }\"\n\tarr=\"${arr//+/ }\"\n\tarr=\"${arr//-/ }\"\n\tarr=\"${arr//\\?/ }\"\n\
    \tarr=\"${arr//$/ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"\
    ${arr//%/ }\"\n\tarr=\"${arr//@/ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"${arr//,\
    \ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"${arr//$/ }\"\n\tarr=\"${arr//'/ }\"\n\t\
    arr=\"${arr//,/ }\"\n\tarr=\"${arr//'/ }\"\n\tarr=\"${arr//,/ }\"\n\tarr=\"${arr//?/\
    \ }\"\n\tarr=\"${arr//,", "\tlocal -i i len\n\tlocal array\n\tarray=($1)\n\n\t\
    for ((i=0; i<${#array[@]}; i++)); do\n\t\tlen=$(by_length ${array[i]})\n\t\tif\
    \ [ \"${len}\" != \"0\" ]; then\n\t\t\tprintf -v \"${array[i+1]}\" '%s\\n' \"\
    ${len}\"\n\t\tfi\n\tdone\n\n\tprintf '%s\\n' \"${array[@]}\"", "\tlocal i name\
    \ value array=\"$1\"\n\tshift\n\tfor element in \"${array}\"; do\n\t\tif [[ \"\
    ${element}\" -gt \"9\" ]]; then\n\t\t\tname=$((10+${element})) #'10' because '0'\
    \ is less than '9'\n\t\telif [[ \"${element}\" -gt \"1\" ]]; then\n\t\t\tname=$((10+${element}+1))\n\
    \t\telse\n\t\t\tname=$((${element}+1))\n\t\tfi\n\t\tvalue=$(printf \"${name}\\\
    n\")\n\t\tif [[ -n ${value} ]]; then\n\t\t\tprintf '%s\\n' \"${value}\"\n\t\t\
    fi\n\tdone", "    local array=\"$1\"\n    local lengths=\n    local nums\n   \
    \ local nums_index\n    local result\n    local length\n    local digit\n    local\
    \ digit2\n    local length2\n    local i\n    for ((i = 0; i <= 9; i++)); do\n\
    \        length=\"$((${#array[@]} / 10))\"\n        length2=\"$((${#length} %\
    \ 10))\"\n        length=${#length}\n        nums=()\n        for ((nums_index\
    \ = 0; nums_index < ${#array[@]}; nums_index++)); do\n            ((digit=${array[$nums_index]}))\
    \ ; nums+=(\"$digit\")\n            if (( nums_index == 0 )); then\n         \
    \       if (( nums == \"1\" )); then\n                    nums_index=0\n     \
    \           else\n                    nums_index=$(( $nums_index * 10 ))\n   \
    \             fi\n            else\n                if (( nums == \"9\" )); then\n\
    \                    nums_index=$(( (${#array[@]} - nums_index - 1) * 10 ))\n\
    \                fi\n            fi\n        done\n        if (( \"${#nums[@]}\"\
    \ == 0 )); then\n            lengths=$lengths$length\n        else\n         \
    \   (( \"${#nums[@]}\" < \"$length\" )) && lengths=$lengths$length\n         \
    \   (( \"${#nums[@]}\" > \"$length2\" )) && lengths=$lengths$length2\n       \
    \ fi\n    done\n    array=()\n    for ((nums_index = 0; nums_index < ${#lengths};\
    \ nums_index++)); do\n        length=${lengths:$nums_index:1}\n        (( \"${#length}\"\
    \ < 10 )) && length=${length:0:1}\n        array+=($(( ${#length} - 1 )))\n  \
    \  done\n    array=(\"${array[@]:1}\")\n    local length\n    local length2\n\
    \    for ((i = 0; i <= 9; i++)); do\n        length=${#array[@]}\n        length2=\"\
    ${#length}\"\n        (( \"${#length}\" < \"$length\" )) && length=$length\n \
    \       (( \"${#length}\" > \"$length2\" )) && length=$length2\n        (( \"\
    ${#array[@]}\" < \"$length\" )) && length=$length\n        (( \"${#array[@]}\"\
    \ > \"$length2\" )) && length=$length2\n        array=(\"${array[@]:0:$length}\"\
    )\n    done\n    result=()\n    for ", "    local length=\"$1\"\n    shift\n \
    \   local result=()\n    local i j\n    for ((i=0;i<${#length};i++)); do\n   \
    \     j=$((${length} % (i+1)))\n        length=${length/%\\ $j}\n        result+=(\
    \ \"${!i%$j}\" )\n    done\n    if [[ ${#length} -gt 1 ]]; then\n        result+=(\
    \ \"$length\" )\n    fi\n    echo \"${result[@]}\"", "\tlocal x\n\tIFS=' ' read\
    \ -r -a x <<< \"$1\"\n\tlocal -i len\n\tlocal -i i\n\tlocal -i last\n\tlocal -a\
    \ output\n\tlocal -i j\n\n\toutput=$(xargs -n 1 printf '%s\\0' <<<\"$x\" |\n\t\
    \tsort -znr |\n\t\tuniq -z -d |\n\t\ttr -d '\\n' |\n\t\twhile read -r -d '' num;\
    \ do\n\t\t\tlen=$(printf '%02d' \"$num\")\n\t\t\tlast=$(printf '%02d' \"${len}\"\
    )\n\t\t\tif [ \"$last\" -eq \"0\" ]; then\n\t\t\t\tlast=\"9\"\n\t\t\telif [ \"\
    $last\" -lt \"9\" ]; then\n\t\t\t\tlast=\"$last\"\n\t\t\tfi\n\t\t\toutput+=(\"\
    $last\")\n\t\tdone)\n\tprintf \"[%s]\" \"${output[@]}\"", "  local list=\"$1\"\
    \n  local output\n  output=$(echo \"$list\" | grep -E \"^[[:digit:]]+[[:space:]]*$\"\
    \ | sort -r -n | tr -d '\\n\\r')\n  output=${output//[[:space:]]}\n  output=${output//\"\
    One\"} \"One\"\n  output=${output//\"Two\"} \"Two\"\n  output=${output//\"Three\"\
    } \"Three\"\n  output=${output//\"Four\"} \"Four\"\n  output=${output//\"Five\"\
    } \"Five\"\n  output=${output//\"Six\"} \"Six\"\n  output=${output//\"Seven\"\
    } \"Seven\"\n  output=${output//\"Eight\"} \"Eight\"\n  output=${output//\"Nine\"\
    } \"Nine\"\n  echo \"$output\"", "    local i len\n    IFS=' ' read -ra words\
    \ <<< \"$1\"\n    len=${#words[@]}\n    if [ $len == 0 ]; then\n        return\
    \ \"\"\n    fi\n    if [ $len -gt 9 ]; then\n        echo \"Too long input (>9\
    \ elements)\" >&2\n        return 1\n    fi\n    local rev name j\n    for ((i=len;\
    \ i-->1; )); do\n        name=${words[i]}\n        j=${words[i-1]}\n        rev=`echo\
    \ $name | sed \"s/$j/$name/'\"`\n        words[$i]=$rev\n    done\n    printf\
    \ '%s\\n' \"${words[@]}\"", "  local -n arr=\"$1\"\n  arr=${arr// /}\n  local\
    \ -n i=0\n  local -n length=$((${#arr} + 1))\n  local -n j=0\n  local -n result\n\
    \  result=()\n\n  for ((i = 0; i < $length; i++)); do\n    local -n arr_idx=${arr[$i]}\n\
    \    local -n arr_len=${#arr[$i]}\n    if (($arr_len > 0)); then\n      for ((j\
    \ = 0; j < $arr_len; j++)); do\n        local -n idx=$j\n        result+=(${arr[@]:$idx:1})\n\
    \      done\n    else\n      result+=(${arr[@]:0:1})\n    fi\n  done\n  if ((${#result[@]}\
    \ > 0)); then\n    result=(${result[@]:1:${#result[@]}})\n  fi\n  printf '%s\\\
    n' \"${result[@]}\"", "    local IFS=\"$1\"\n    shift\n    local output\n   \
    \ output=$(sort -zr <<<\"$@\")\n    output=$(printf \"%s\" \"${output//[0-9]/$((10#$(($(echo\
    \ \"$output\" | wc -l) - 1))))}\" | tr '[:upper:]' '[:lower:]')\n    output=$(printf\
    \ \"%s\" \"${output//[^a-z]\"}\")\n    output=$(printf \"%s\" \"${output//[\\\"\
    ']/}\")\n    output=$(echo \"$output\" | tr '[:upper:]' '[:lower:]')\n    echo\
    \ \"$output\"", "    local a b\n    IFS=$' \\t\\n'\n    a=( $1 )\n    for b in\
    \ \"${a[@]}\"; do\n        local a\n        [[ $b = -* ]] || continue\n      \
    \  for a in \"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\"\
    \ \"Nine\"; do\n            [[ $b =~ \"^${a}+\" ]] && echo \"\\\"${b}\\\"\"\n\
    \        done\n    done\n    IFS=", "  local numbers=${1//[[:space:]]/}\n  local\
    \ num\n  local name=\n  local first=1\n  local last=10\n  local length=0\n  while\
    \ read -r num; do\n    if ! [[ -z $num ]]; then\n      length=$((${#num}+1))\n\
    \    fi\n  done < <(printf '%s\\n' \"${numbers[@]}\")\n  if [[ $length -lt 10\
    \ ]]; then\n    name=One\n  elif [[ $length -lt 25 ]]; then\n    name=Two\n  elif\
    \ [[ $length -lt 45 ]]; then\n    name=Three\n  elif [[ $length -lt 65 ]]; then\n\
    \    name=Four\n  elif [[ $length -lt 85 ]]; then\n    name=Five\n  elif [[ $length\
    \ -lt 95 ]]; then\n    name=Six\n  elif [[ $length -lt 105 ]]; then\n    name=Seven\n\
    \  elif [[ $length -lt 115 ]]; then\n    name=Eight\n  elif [[ $length -lt 125\
    \ ]]; then\n    name=Nine\n  else\n    echo \"Unexpected length: $length\"\n \
    \   return 1\n  fi\n  # reverse the array\n  for i in \"${!numbers[@]}\"; do\n\
    \    local j=\"${numbers[$i]}\"\n    numbers[$i]=\"${numbers[$j]}\"\n    numbers[$j]=\"\
    $i\"\n  done\n  # reverse each number in the array\n  for i in \"${!numbers[@]}\"\
    ; do\n    local j=\"${numbers[$i]}\"\n    numbers[$i]=\"${numbers[$j]}\"\n   \
    \ numbers[$j]=\"$name\"\n  done\n  # reformat the array as a space-separated list\n\
    \  printf '%s\\n' \"${numbers[@]}\"", "  local -a arr=( )\n  IFS=$' \\t\\n' read\
    \ -r -d '' -a arr < <(echo $1 | tr ' ' '\\n' | sort --numeric-sort --reverse |\
    \ sed -e 's/^/\"/' -e 's/$/\"One\"/')\n  echo \"${arr[@]}\"", "  local arr=(\"\
    ${@}\")\n  if [ ${#arr[@]} -eq 0 ]; then\n    arr=()\n  fi\n\n  local len=0\n\
    \  local tmp=${arr[0]}\n  for ((i=1; i<${#arr[@]}; i++)); do\n    len=$((len +\
    \ ${#tmp}))\n    tmp=${arr[i]}\n  done\n\n  local names=()\n  local count=0\n\
    \  local res=\"\"\n  local digit=${tmp:0:1}\n  local digit=${digit:0:1}\n  tmp=${tmp:1}\n\
    \  while [ \"$digit\" -eq \"$digit\" ] 2> /dev/null; do\n    names+=(\"${digit}\"\
    )\n    tmp=${tmp:0:1}\n    count=$((count + 1))\n    digit=${tmp:0:1}\n  done\n\
    \n  if [ \"$count\" -gt \"$len\" ]; then\n    digit=${tmp:0:1}\n    while [ \"\
    $digit\" -eq \"$digit\" ] 2> /dev/null; do\n      names+=(\"${digit}\")\n    \
    \  tmp=${tmp:0:1}\n      count=$((count + 1))\n      digit=${tmp:0:1}\n    done\n\
    \  fi\n\n  while [ \"$count\" -gt \"$len\" ]; then\n    names+=(\"${count}\")\n\
    \    count=$((count - 1))\n  done\n\n  if [ \"$count\" -eq \"$len\" ]; then\n\
    \    names+=(\"${count}\")\n  fi\n\n  res=\"$names\"\n  res=\"$(IFS=' '; echo\
    \ \"${res[*]}\")\"\n  res=\"${res// /, }\"\n  res=\"${res//, / }\"\n  res=\"${res//,\
    \ }\"\n  res=\"${res//, }\"\n  echo \"$res\"", "  if [ -z \"$1\" ]; then return\
    \ ; fi\n  array=( $1 )\n  local i=0\n  local array2=\"\"\n  local output=\"\"\n\
    \  local num=\"\"\n  while [ \"$i\" -lt ${#array[@]} ]; do\n    num=\"$array[$i]\"\
    \n    if [ \"$num\" -gt \"9\" ] && [ \"$num\" -lt \"10\" ]; then # 1-9\n     \
    \ array2=${array2}\"One\"\n    elif [ \"$num\" -gt \"9\" ] && [ \"$num\" -ge \"\
    10\" ]; then # 10-19\n      array2=${array2}\"Ten\"\n    elif [ \"$num\" -lt \"\
    9\" ] && [ \"$num\" -ge \"10\" ]; then # 20-99\n      array2=${array2}\"Twenty\"\
    \n    elif [ \"$num\" -eq \"9\" ]; then # 100-999\n      array2=${array2}\"Hundred\"\
    \n    elif [ \"$num\" -eq \"10\" ]; then # 1000-9999\n      array2=${array2}\"\
    Thousand\"\n    elif [ \"$num\" -eq \"11\" ]; then # 10000-11999\n      array2=${array2}\"\
    OneHundred\"\n    elif [ \"$num\" -eq \"12\" ]; then # 12000-13999\n      array2=${array2}\"\
    TwoHundred\"\n    elif [ \"$num\" -eq \"13\" ]; then # 14000-14999\n      array2=${array2}\"\
    ThreeHundred\"\n    elif [ \"$num\" -eq \"14\" ]; then # 15000- 15999\n      array2=${array2}\"\
    FourHundred\"\n    elif [ \"$num\" -eq \"15\" ]; then # 16000-16999\n      array2=${array2}\"\
    FiveHundred\"\n    elif [ \"$num\" -eq \"16\" ]; then # 17000-17999\n      array2=${array2}\"\
    SixHundred\"\n    elif [ \"$num\" -eq \"17\" ]; then # 18000-18999\n      array2=${array2}\"\
    SevenHundred\"\n    elif [ \"$num\" -eq \"18\" ]; then # 19000-19999\n      array2=${array2}\"\
    EightHundred\"\n    elif [ \"$num\" -eq \"19\" ]; then # 20000-21999\n      array2=${array2}\"\
    NineHundred\"\n    elif [ \"$num\" -ge \"20\" ", "  local -n arr=$1\n  local i\
    \ j\n  local out\n  for ((i=0; i<${#arr[@]}; i++)); do\n    for ((j=0; j<${#arr[@]};\
    \ j++)); do\n      [[ ${arr[j]} -gt ${arr[i]} ]] && break\n    done\n    if [[\
    \ ${j} -eq ${#arr[@]} ]]; then\n      out+=\"\\\"${arr[i]}\\\"\"\n      arr[i]=\n\
    \      break\n    fi\n    out+=\"\\\"${arr[i]}\\\"\"\n    arr[i]=${arr[j]}\n \
    \ done\n  [[ $? -ne 0 ]] && return 1\n  echo \"${out}\"", "  local -r input=\"\
    $1\"\n  local -r maxlen=\"$2\"\n\n  local -r string=\"${maxlen//[^0-9]/}\"\n \
    \ local -r maxlen=\"$string\"\n\n  local -a arr\n  local name\n  local -a tmp\n\
    \  local -a lens\n\n  if [[ -n \"${input:-}\" ]]; then\n    arr=($(echo \"${input}\"\
    \ | awk '{print $1}'))\n  else\n    arr=()\n  fi\n\n  if [[ \"${#arr[@]}\" -eq\
    \ 0 ]]; then\n    return 0\n  fi\n\n  lens=()\n  maxlen=\"${maxlen}\" # Always\
    \ use maxlen as maxlen is not set if maxlen is empty\n\n  # Use maxlen instead\
    \ of len(input) so as to handle the case when maxlen is empty\n  for (( i = 0;\
    \ i <= maxlen; i++ )); do\n    lens[${#lens[*]}]=\"$i\"\n  done\n\n  maxlen=\"\
    ${#lens[@]}\"\n\n  for (( i = 0; i < ${#arr[@]}; i++ )); do\n    len=\"${lens[$i]}\"\
    \n    if [[ -n \"${arr[$i]}\" ]]; then\n      name=$(get_name \"${arr[$i]}\" \"\
    $i\")\n      arr[$i]=\"$name\"\n    fi\n    if [[ \"${#lens[@]}\" -eq \"${maxlen}\"\
    \ ]]; then\n      tmp=(\"${arr[@]:0:$i}\")\n      arr=(\"${tmp[@]}\")\n    fi\n\
    \  done\n\n  if [[ ${#arr[@]} -gt 0 ]]; then\n    echo \"${arr[@]}\"\n  fi", " \
    \   local i\n    local arr\n\n    arr=( $1 )\n    if [ -n \"${arr[*]}\" ] ; then\n\
    \        declare -a arr\n        arr=(${arr[@]})\n    fi\n    local -a arr2\n\
    \    arr2=( $(sort -k 1 -n \"${arr[@]}\") )\n    local -a arr3\n    arr3=( $(sort\
    \ -k 2 -n \"${arr[@]}\") )\n    local -a arr4\n    arr4=( $(sort -k 3 -n \"${arr[@]}\"\
    ) )\n    local -a arr5\n    arr5=( $(sort -k 4 -n \"${arr[@]}\") )\n    local\
    \ -a arr6\n    arr6=( $(sort -k 5 -n \"${arr[@]}\") )\n    local -a arr7\n   \
    \ arr7=( $(sort -k 6 -n \"${arr[@]}\") )\n    local -a arr8\n    arr8=( $(sort\
    \ -k 7 -n \"${arr[@]}\") )\n    local -a arr9\n    arr9=( $(sort -k 8 -n \"${arr[@]}\"\
    ) )\n    local -a arr10\n    arr10=( $(sort -k 9 -n \"${arr[@]}\") )\n    local\
    \ -a arr11\n    arr11=( $(sort -k 10 -n \"${arr[@]}\") )\n\n    for i in \"${arr[@]}\"\
    ; do\n        arr2[$i]=${arr3[$i]}\n        arr3[$i]=${arr4[$i]}\n        arr4[$i]=${arr5[$i]}\n\
    \        arr5[$i]=${arr6[$i]}\n        arr6[$i]=${arr7[$i]}\n        arr7[$i]=${arr8[$i]}\n\
    \        arr8[$i]=${arr9[$i]}\n        arr9[$i]=${arr10[$i]}\n        arr10[$i]=${arr11[$i]}\n\
    \    done\n\n    echo ${arr2[*]}", "    set -- $1 && shift\n    local len=$1;\
    \ shift\n    local digits=$(by_length '' $1)\n    local i=$((${#digits}-1))\n\
    \    while [[ $(( ${#digits} % 3 )) == 0 && $i -ge 0 ]]; do\n        (( i-- ))\n\
    \    done\n    printf -v tmp '%.0s' {${digits:$i:${#digits}}} # reverse the array\n\
    \    printf -v tmp '%.0s' '\"%s\"' \"${tmp}\"         # replace each digit by\
    \ its name\n    echo ${tmp[@]} | sed -E 's/\"([0-9])\"/'\"${!1!}\"'/' # print\
    \ the resulting array", "\tlocal array length new_array\n\tarray=\"$1\"\n\tlength=\"\
    ${#array}\"\n\tnew_array=()\n\tfor i in $(seq 1 $length); do\n\t\tnew_array+=(\
    \ \"${array[$i]}\" )\n\tdone\n\teval \"for i in $(eval echo \\\"\\${new_array[*]}\\\
    \"); do\n\t\techo \\\"$i\\\";\n\tdone\"", "    local i n names numbers\n    local\
    \ -a arr temp\n    local j\n\n    arr=( ${( )} )\n    IFS=$'\\t' read -a temp\
    \ < <(\n        IFS=' '\n        while read n; do\n            if (( ${#n} < 8\
    \ )); then\n                arr+=( ${n} \"$(n)\"; )\n            else\n      \
    \          arr+=( \"${n}\" )\n            fi\n        done\n        printf '%s\\\
    0' \"${arr[@]}\" | sort -z\n    )\n    IFS=$' \\t\\n' read -a names <<< \"${temp[@]}\"\
    \n    IFS=$' \\t\\n' read -a numbers <<< \"${arr[@]}\"\n\n    for ((i=0;i<${#arr[@]};i++));\
    \ do\n        arr[i]=\"${names[numbers[i]%${#names[@]}]}\"\n    done\n    echo\
    \ \"${arr[@]}\"", "    local arr\n    IFS=$'\\t' arr=($1)\n    # remove quotes,\
    \ tabs and double quotes\n    local -a arr2\n    for val in \"${arr[@]}\"; do\n\
    \        case \"$val\" in\n            \"\\\"*\") ;;\n            \"*\") val=\"\
    ${val//\\\"/}\"; arr2+=(\"$val\") ;;\n            *) val=\"${val//\\\"/}\"; arr2+=(\"\
    ${val// /_}\")\n        done\n    done\n    if [ \"${#arr2[@]}\" -eq 0 ]; then\
    \ return ; fi\n    echo \"${arr2[@]}\"", "  local -n arr=$1\n  local -a result=()\n\
    \n  # Convert each number into a string and append the result to result\n  local\
    \ arr\n  for arr; do\n    local string=\"${arr// / }\"\n    local digits=\"${string::${#string}}\"\
    \n    local name=$(printf '%s\\n' \"${!arr}\")\n    [[ $digits -gt 0 ]] && result+=(\"\
    ${name}\")\n  done\n\n  # Reverse the resulting array\n  local i\n  for (( i=0;\
    \ i<${#result[@]}; i++ )); do\n    local length=\"${#result[i]}\"\n    local j\n\
    \    for (( j=length; j>0; j-- )); do\n      local first=\"${result[i]}\"\n  \
    \    result[i]=\"${result[j]}\"\n      result[j]=\"${first}\"\n    done\n  done\n\
    \n  # Replace each digit by its corresponding name from \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n  for (( i=0; i<${#result[@]};\
    \ i++ )); do\n    local length=\"${#result[i]}\"\n    local j\n    for (( j=0;\
    \ j<length; j++ )); do\n      local digit=\"${result[i]}\"\n      result[i]=\"\
    ${DIGITS[$digit]}\"\n    done\n  done\n\n  printf '%s\\n' \"${result[@]}\"", " \
    \   local -n numbers=$1\n    local array=()\n    local -i start=0\n    local -i\
    \ length=0\n    local -i i\n    local str\n    local digits\n    local digit\n\
    \    local name\n\n    # Start by sorting and reversing the array\n    for ((i=1;\
    \ i<${#numbers[@]}; i++)); do\n        length=${#numbers[$i]}\n        if ((length\
    \ == 0)); then\n            continue\n        fi\n        digits=()\n        #\
    \ Build the digits into an array in reverse order\n        for ((j=${#numbers[$i]};\
    \ j > 0; j--)); do\n            digits+=( ${numbers[$i]} ${j} )\n        done\n\
    \        # Sort the digits from least to greatest\n        sort -g <<< \"${digits[@]}\"\
    \n        # Add the sorted digits to the array\n        for ((j=0; j<${#digits[@]};\
    \ j++)); do\n            array+=( \"${digits[$j]}\" )\n        done\n    done\n\
    \n    # Add \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\" to the front\n    for ((i=0; i<${#array[@]}; i++)); do\n\
    \        if ((i % 9 == 0)); then\n            array+=( \"One\" \"Two\" \"Three\"\
    \ \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\" )\n        fi\n     \
    \   name=${array[$i]}\n        if (( ${#name} < 2 )); then\n            array[$i]=${name}\"\
    0\"\n        else\n            array[$i]=${name}\n        fi\n    done\n\n   \
    \ # Return the array in double-quotes\n    echo \"${array[@]}\"", "\tlocal -a\
    \ arr\n\tfor e in \"$@\"; do\n\t\tif [[ \"$e\" =~ ^-?[0-9]+$ ]]; then\n\t\t\t\
    if (( $(echo \"$e - 1\" | bc -l) > 9 )); then\n\t\t\t\tarr+=(\"$((e - 10))\")\n\
    \t\t\telse\n\t\t\t\tarr+=(\"$e\")\n\t\t\tfi\n\t\telse\n\t\t\tarr+=(\"$e\")\n\t\
    \tfi\n\tdone\n\techo \"${arr[@]}\"", "    local -n arr=$1\n    if [[ ${#arr[@]}\
    \ -eq 0 ]]; then\n        echo \"[]\"\n        return\n    fi\n    local -a map=(\n\
    \        \"One\"\n        \"Two\"\n        \"Three\"\n        \"Four\"\n     \
    \   \"Five\"\n        \"Six\"\n        \"Seven\"\n        \"Eight\"\n        \"\
    Nine\"\n    )\n    local -i j=0\n    local -a new_arr\n    local n\n    # Fill\
    \ the new array with the original array, then swap the digits while reversing\
    \ them\n    for i in \"${arr[@]}\"; do\n        if [[ $i -lt 10 && $i -gt 1 ]];\
    \ then\n            new_arr[$j]=${map[$((10#$i))]}\n        elif [[ $i -lt 1 &&\
    \ $i -gt 9 ]]; then\n            new_arr[$j]=${map[$((10#$i))]}\n        else\n\
    \            n=$i\n            break\n        fi\n        j=$((j+1))\n    done\n\
    \    # Swap them\n    local i new_i j k new_j\n    for (( j=0; j<${#arr[@]}; j++\
    \ )); do\n        new_i=$j\n        new_j=$(( j + 1 ))\n        k=$(( j - 1 ))\n\
    \        new_k=$(( j + 1 ))\n        local tmp\n        while (( $k >= 0 )); do\n\
    \            tmp=${new_arr[$new_k]}\n            new_arr[$new_k]=${new_arr[$new_j]}\n\
    \            new_arr[$new_j]=${new_arr[$new_i]}\n            new_arr[$new_i]=${new_arr[$k]}\n\
    \            new_arr[$k]=${new_arr[$new_k]}\n            new_arr[$new_k]=${new_arr[$new_j]}\n\
    \            new_arr[$new_j]=${new_arr[$new_i]}\n            new_arr[$new_i]=${tmp}\n\
    \            (( k-- ))\n            (( j-- ))\n        done\n    done\n    local\
    \ -n arr_str=$1\n    for (( i=0; i<${#arr[@]}; i++ )); do\n        printf -v \"\
    $arr_str\" \"%s\" \"${new_arr[$i]}\"\n    done", "    local lines=(\"${@}\")\n\
    \    local empty=0\n    local length=0\n    local names=()\n    local i=0\n  \
    \  local j=0\n    local count=0\n    while IFS= read -r line || [ \"$line\" ];\
    \ do\n        (( i++ ))\n        if [ \"$i\" -lt \"$#\" ]; then\n            ((\
    \ j++ ))\n            if [ \"$j\" -eq \"$#\" ]; then\n                if [ \"\
    ${lines[$i]}\" -eq 1 ]; then\n                    names=(\"${names[@]}\" '\"\"\
    ')\n                else\n                    names=(\"${names[@]}\" '\"\"')\n\
    \                fi\n            fi\n            length=$(( length + $line ))\n\
    \        else\n            (( empty++ ))\n        fi\n    done < <(printf '%s\\\
    n' \"${lines[@]}\")\n    # Special case empty array\n    if [ \"$empty\" -eq 1\
    \ ]; then\n        names=(\"${names[@]}\" '\"\"')\n    fi\n    # Special case\
    \ with one element array\n    if [ \"$length\" -eq 1 ]; then\n        names=(\"\
    ${names[@]}\" '\"\"')\n    fi\n    # Special case with single digit array\n  \
    \  if [ \"$length\" -eq 2 ]; then\n        names=(\"${names[@]}\" '\"\"')\n  \
    \  fi\n    # Special case with single number array\n    if [ \"$length\" -eq 3\
    \ ]; then\n        names=(\"${names[@]}\" '\"\"')\n    fi\n    # Special case\
    \ with single number array\n    if [ \"$length\" -eq 4 ]; then\n        names=(\"\
    ${names[@]}\" '\"\"')\n    fi\n    # Special case with single number array\n \
    \   if [ \"$length\" -eq 5 ]; then\n        names=(\"${names[@]}\" '\"\"')\n \
    \   fi\n    # Special case with single number array\n    if [ \"$length\" -eq\
    \ 6 ]; then\n        names=(\"${names[@]}\" '\"\"')\n    fi\n    # Special case\
    \ with single number array\n    if [ \"$length\" -eq 7 ]; then\n        names=(\"\
    ${names[@]}\" '\"\"')\n    fi\n    # Special case with single number array\n \
    \   if [ \"$length\" -eq 8 ]; then\n        names=(\"${names[@]}\" '\"\"')\n \
    \   fi\n    # Special case with single number array\n    if [ \"$length\" -eq\
    \ 9 ]; then\n        names=(\"${names[@]}\" '\"\"')\n    fi\n    # Special case\
    \ with single number array\n    if [ \"$length\" -eq 10 ]; then\n        names=(\"\
    ${names[", "    local -n arr=$1\n    if [[ \"${arr[@]}\" =~ ^[0-9]+$ ]]; then\n\
    \        arr=($2)\n    fi\n    local -n result\n    local cur prev res\n    local\
    \ i\n    local len\n    len=0\n    for cur in \"${arr[@]}\"; do\n        if [[\
    \ $cur -ge 1 && $cur -le 9 ]]; then\n            ((len++))\n        fi\n    done\n\
    \    res=()\n    for i in $(seq 1 $len); do\n        prev=${arr[i-1]}\n      \
    \  arr[i-1]=${arr[i]}\n        arr[i]=$prev\n    done\n    for cur in \"${arr[@]}\"\
    ; do\n        result+=(\"$cur\")\n    done\n    echo \"${result[@]}\"", "    local\
    \ lst str\n    local -i idx\n\n    idx=0\n    while [ $# -gt 0 ]; do\n       \
    \ lst=( $1 )\n        lst=( ${lst[0]}${lst[1]} ${lst[2]} ${lst[3]} ${lst[4]} ${lst[5]}\
    \ ${lst[6]} ${lst[7]} ${lst[8]} ${lst[9]} )\n        idx=0\n        while [ $idx\
    \ -lt 10 ]; do\n            str=\"\\\"${lst[idx]}\\\"\"\n            eval eval\
    \ str=\"$str\"\n            str=\"\\\"${lst[idx]}\\\"\"\n            eval eval\
    \ str=\"${str//[0-9]/One}\"\n            str=\"${str//[0-9]/Two}\"\n         \
    \   str=\"${str//[0-9]/Three}\"\n            str=\"${str//[0-9]/Four}\"\n    \
    \        str=\"${str//[0-9]/Five}\"\n            str=\"${str//[0-9]/Six}\"\n \
    \           str=\"${str//[0-9]/Seven}\"\n            str=\"${str//[0-9]/Eight}\"\
    \n            str=\"${str//[0-9]/Nine}\"\n            str=\"${str//[0-9]/One}\"\
    \n            str=\"${str//[0-9]/Two}\"\n            str=\"${str//[0-9]/Three}\"\
    \n            str=\"${str//[0-9]/Four}\"\n            str=\"${str//[0-9]/Five}\"\
    \n            str=\"${str//[0-9]/Six}\"\n            str=\"${str//[0-9]/Seven}\"\
    \n            str=\"${str//[0-9]/Eight}\"\n            str=\"${str//[0-9]/Nine}\"\
    \n            str=\"${str//[0-9]/One}\"\n            str=\"${str//[0-9]/Two}\"\
    \n            str=\"${str//[0-9]/Three}\"\n            str=\"${str//[0-9]/Four}\"\
    \n            str=\"${str//[0-9]/Five}\"\n            str=\"${str//[0-9]/Six}\"\
    \n            str=\"${str//[0-9]/Seven}\"\n            str=\"${str//[0-9]/Eight}\"\
    \n            str=\"${str//[0-9]/Nine}\"\n            str=\"${str//[0-9]/One}\"\
    \n            str=\"${str//[0-9]/Two}\"\n            str=\"${str//[0-9]/Three}\"\
    \n            str=\"${str//[0-9]/Four}\"\n            str=\"${str//[0-9]/Five}\"\
    \n            str=\"${str//[0-9]/Six}\"\n            str=\"${str//[0-9]/Seven}\"\
    \n            str=\"${str//[0-9]/Eight}\"\n            str=\"${str//[0-9]/Nine}\"\
    \n            str=\"${str//[0-9]/", "    local digits=$1\n    if [ -z \"$digits\"\
    \ ]; then\n        digits=\"\"\n    fi\n    local digit=''\n    local result=()\n\
    \    local item=''\n    local i\n    local j\n    local length=$((${#digits}+1))\n\
    \n    for ((i=0; i<$length; i++)); do\n        item=\"${digits:$i:1}\"\n     \
    \   result+=( \"$item\" )\n    done\n    if [ $length -lt 9 ]; then\n        for\
    \ ((j=$length; j>0; j--)); do\n            item=\"${digits:$j:1}\"\n         \
    \   result+=( \"$item\" )\n        done\n    fi\n    if [ -n \"$digits\" ]; then\n\
    \        for ((j=0; j<$length; j++)); do\n            item=\"${digits:$j:1}\"\n\
    \            result+=( \"$item\" )\n        done\n    fi\n    echo ${result[@]}",
  "    local array length number\n    for array in \"$@\"; do\n        length=\"$(\
    \ printf '%s' \"$array\" | awk '{print length}' )\"\n        number=\"$( printf\
    \ '%s' \"$array\" | awk '{print length+1}' )\" # +1\n        # Replace each digit\
    \ with its name from 1 to 9.\n        array=\"$( printf '%s' \"$array\" | awk\
    \ '{for (i=1; i<=length; ++i) print $(i+2)}' )\"\n    done\n    echo \"$array\"",
  "  local i name\n  read -a ary < \"$1\"\n  if [ \"${#ary[@]}\" -gt 1 ]; then\n \
    \   echo \"$1\"\n  else\n    ary=()\n  fi\n  i=0\n  while [ \"$i\" -lt \"${#ary[@]}\"\
    \ ]; do\n    i=$((i + 1))\n    if [ \"$i\" -gt \"9\" ]; then\n      ary[${i}]=$(echo\
    \ \"${ary[${i}]}\" | rev | cut -d \" \" -f 1)\n      i=$((i - 1))\n    fi\n  done\n\
    \  local s=\n  while [ \"$i\" -ge \"0\" ]; do\n    s=\"${ary[$i]} ${s}\"\n   \
    \ i=$((i - 1))\n  done\n  echo \"$s\"", "    local list=\"${1// /-}\"\n    local\
    \ -a list=( \"${list}\" )\n    if [[ ${#list[@]} -eq 0 ]]; then\n        echo\
    \ \"[]\"\n    else\n        local -a digits=(${list[@]})\n        local -a reversed\n\
    \        reversed=()\n        local -a names=(\n            One Two Three Four\
    \ Five Six Seven Eight Nine \"One\"\n            \"Two\" \"Three\" \"Four\" \"\
    Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\"\n        )\n        local length=0\n\
    \        local index\n        for index in ${!list[@]}; do\n            ((length++))\n\
    \        done\n        ((length--))\n        local i\n        for ((i=0; i<length;\
    \ i++)); do\n            ((length--))\n            if ((i%2)); then\n        \
    \        reversed+=( \"${list[i]}\" )\n                local -a name=(\"${names[${reversed[${i}]}]}\"\
    )\n                reversed+=( \"${name[${reversed[${i}]}]}\" )\n            else\n\
    \                reversed+=( \"${list[i]}\" )\n            fi\n        done\n\
    \        echo \"${reversed[@]}\"\n    fi", "  echo \"$1\" | awk '{\n     l=length($1)\n\
    \     n=split($1,a,\"[ ]+\")\n     for(i=1;i<l;i++) if(i<=n) a[i]=a[n-i]\n   \
    \  for(i=1;i<n;i++) a[i]=reverse(a[i])\n     for(i=1;i<n;i++) a[i]=\"\\\"$i\\\"\
    \"\n     print a[1]\n   }' | tr '\\n' ' ' | sed 's/ /\",\"/g' | sed 's/^/\"$1\"\
    :\"/'", "    local arr=\"$1\"\n    IFS=' ' read -r -a arr <<<\"${arr// / }\"\n\
    \    local max_length=\"${#arr[@]}\"\n    local arr2=(\n        \"One\"\n    \
    \    \"Two\"\n        \"Three\"\n        \"Four\"\n        \"Five\"\n        \"\
    Six\"\n        \"Seven\"\n        \"Eight\"\n        \"Nine\"\n    )\n    if [[\
    \ ${#arr[@]} -eq 0 ]]; then\n        local arr3=()\n    elif (( ${#arr[@]} > max_length\
    \ )); then\n        local arr3=(${arr[@]:1:max_length})\n        local arr3[@]=(\"\
    ${arr3[@]//0/}\")\n    elif (( ${#arr[@]} < max_length )); then\n        local\
    \ arr3=(\"${arr[@]:0:max_length}\")\n        local arr3[@]=(\"${arr3[@]//0/}\"\
    )\n    else\n        local arr3=(${arr[@]:0:max_length})\n        local arr3[@]=(\"\
    ${arr3[@]//0/}\")\n    fi\n    local out=(\n        \"${arr3[@]}\"\n        \"\
    ${arr2[@]}\"\n        \"${arr[@]:(max_length+1)}\"\n    )\n    arr=()\n    local\
    \ arr_length=${#out[@]}\n    echo \"${out[@]}\"", "    local IFS=$1\n    shift\n\
    \    local array\n    array=()\n    local i\n    for ((i=0; i<${#}; i++)); do\n\
    \        array+=(\"$(by_length \"${#i}+$i\" \"$@\")\")\n    done\n    echo \"\
    ${array[*]}\"", "    local lst len\n    local name\n    local -i i lens len\n\
    \    local tmp\n    local -n arr=$1\n    local tmp2 arr\n\n    # Make sure we\
    \ have a non-empty list\n    if [ -z \"${arr}\" ]; then\n        echo \"Usage:\
    \ ${0} <space-separated integers>\" >&2\n        return 1\n    fi\n\n    # Convert\
    \ to an array\n    IFS=$'\\n' arr=($(printf '%s\\n' \"${arr[@]}\" | sort))\n\n\
    \    # Figure out how long the list is and allocate storage for the final output\n\
    \    lens=${#arr[@]}\n    lens=${#arr[@]} - 1\n    len=${lens}\n    names=()\n\
    \    for (( i = 1; i <= lens; i++ )); do\n        (( len -= i ))\n        if [\
    \ \"${arr[i]}\" -gt 9 ]; then\n            len=${lens}\n        fi\n        if\
    \ [ \"${arr[i]}\" -ge 1 ] && [ \"${arr[i]}\" -le 9 ]; then\n            names=(\
    \ \"${names[@]}\" \"$(by_name \"${arr[i]}\")\")\n        fi\n    done\n\n    #\
    \ Convert the lengths back into strings\n    for (( i = 0; i < ${#names[@]}; i++\
    \ )); do\n        if [ \"${names[$i]}\" ]; then\n            tmp2=\"$i\"\n   \
    \         if [ -n \"${names[$i]}\" ]; then\n                tmp=\"$i\"\n     \
    \           while (( tmp < lens )) && [ \"${names[$tmp]}\" -eq \"\" ]; then\n\
    \                    (( tmp++ ))\n                done\n                (( tmp2\
    \ += tmp ))\n            fi\n            while (( tmp2 < lens )) && [ \"${names[$tmp2]}\"\
    \ -eq \"\" ]; then\n                (( tmp2++ ))\n            done\n         \
    \   tmp2=\"$tmp2\"\n            tmp2=$(($tmp2 - 1))\n            while (( tmp2\
    \ < lens )) && [ \"${names[$tmp2]}\" -eq \"\" ]; then\n                (( tmp2++\
    \ ))\n            done\n            tmp2=$(($tmp2 + 1))\n            tmp2=$(($tmp2\
    \ - 1))\n            while (( tmp2 < lens )) && [ \"${names[$tmp2]}\" -eq \"\"\
    \ ]; then\n                (( tmp2++ ))\n            done\n            tmp2=$(($tmp2\
    \ + 1))\n            names=( \"${names[@]:$tmp2:1}\")\n        fi\n    done\n\n\
    \    # Construct the output\n    for (( i = 0; i < ${#names[@]}; i++ )); do\n\
    \        if [", "  local integers=$1\n  integers=$(echo $integers | tr ' ' ',')\n\
    \  integers=$(echo $integers | sed 's/^ *//g;s/ *$//g;s/^,/,/')\n  integers=$(echo\
    \ $integers | sed 's/,$//g;s/,$//g;s/ /,/g')\n  integers=$(echo $integers | tr\
    \ ',' ' ')\n  integers=$(echo $integers | sed 's/,$//g;s/,$//g;s/^ *//g;s/ *$//g;s/^\
    \ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo $integers | sed 's/^ *//g;s/ *$//g;s/^\
    \ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo $integers | sed 's/,$//g;s/,$//g;s/^\
    \ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo $integers | sed\
    \ 's/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo $integers |\
    \ sed 's/,$//g;s/,$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo\
    \ $integers | sed 's/,$//g;s/,$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n\
    \  integers=$(echo $integers | sed 's/,$//g;s/,$//g;s/^ *//g;s/ *$//g;s/^ *//g;s/\
    \ *$//g;s/,/,/')\n  integers=$(echo $integers | sed 's/,$//g;s/,$//g;s/^ *//g;s/\
    \ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n  integers=$(echo $integers | sed 's/,$//g;s/,$//g;s/^\
    \ *//g;s/ *$//g;s/^ *//g;s/ *$//g;s/,/,/')\n  ", "    local x=\"$1\"\n    local\
    \ -a ret=()\n    while [[ \" ${x} \" ]]; do\n        local -a numbers=()\n   \
    \     for x in $(echo $x | sed \"s/ [^ ]*//\"); do\n            numbers=(\"${numbers[@]}\"\
    \ $((10#$x)))\n        done\n        local -a tmp=()\n        for i in $(seq 0\
    \ 9); do\n            local -a tmp2=()\n            for j in \"${numbers[@]}\"\
    ; do\n                case \"$j\" in\n                    $((10#$i))) tmp2+=(\"\
    ${i}\"); break ;;\n                esac\n            done\n            tmp=(\"\
    ${tmp[@]}\" $tmp2)\n        done\n        for i in $(seq 0 $((${#ret[@]} - 1)));\
    \ do\n            case \"${ret[i]}\" in\n                \" \") ret+=(\"${i}\"\
    ) ;;\n                *\" \"$i) ret+=(\"${ret[i]}\" \"${i}\") ;;\n           \
    \ esac\n        done\n        x=\"${tmp[@]}\"\n    done\n    echo \"${ret[@]}\"",
  "    local nlist=\"$1\"\n    local i\n    local tmp\n    local j=0\n    local output\n\
    \    local array=()\n\n    nlist=$(echo ${nlist// / })\n    nlist=$(echo ${nlist//\
    \ / })\n\n    for n in $nlist; do\n        if [ \"$n\" -gt 9 ]; then\n       \
    \     array[$j]=\"\\\"${n#?}\\\"\"\n            j=$((j+1))\n        else\n   \
    \         array[$j]=\"\\\"${n}\\\"\"\n            j=$((j+1))\n        fi\n   \
    \ done\n\n    array=(\"${array[@]:0:$((${#array[@]}-1))}\")\n\n    IFS=$'\\n'\n\
    \    for element in ${array[@]}; do\n        tmp=`expr $element - 1`\n       \
    \ local tmp2\n        local length=$((${#array[@]}-1))\n\n        array[${tmp}]=One\n\
    \        array[${tmp2}]=Two\n        array[${tmp+1}]=Three\n        array[${length+tmp+1}]=Four\n\
    \        array[${length+tmp+2}]=Five\n        array[${length+tmp+3}]=Six\n   \
    \     array[${length+tmp+4}]=Seven\n        array[${length+tmp+5}]=Eight\n   \
    \     array[${length+tmp+6}]=Nine\n\n        tmp=`expr $element + 1`\n       \
    \ local tmp2\n        local length=$((${#array[@]}-1))\n\n        array[${tmp}]=One\n\
    \        array[${tmp2}]=Two\n        array[${tmp+1}]=Three\n        array[${length+tmp+1}]=Four\n\
    \        array[${length+tmp+2}]=Five\n        array[${length+tmp+3}]=Six\n   \
    \     array[${length+tmp+4}]=Seven\n        array[${length+tmp+5}]=Eight\n   \
    \     array[${length+tmp+6}]=Nine\n\n        tmp=`expr $element + 2`\n       \
    \ local tmp2\n        local length=$((${#array[@]}-1))\n\n        array[${tmp}]=One\n\
    \        array[${tmp2}]=Two\n        array[${tmp+1}]=Three\n        array[${length+tmp+1}]=Four\n\
    \        array[${length+tmp+2}]=Five\n        array[${length+tmp+3}]=Six\n   \
    \     array[${length+tmp+4}]=Seven\n        array[${length+tmp+5}]", "  local\
    \ n str\n  read -r -a array <<<\"$1\"\n  unset array[0]\n  while IFS= read -r\
    \ -d '' str; do\n    ((n--))\n    ((array[${#array[@]}]=\"$str\"))\n  done < <(tr\
    \ ' ' $'\\n' <<<\"${array[@]:1:9}\" | sort -n -g | tr '\\n' '\\0') && IFS= read\
    \ -r -d '' str && printf \"'%s'\" \"${array[*]:9:3}\"", "    local -n result=\"\
    $1\"\n    local length name digits digits2 digits3 digits4 digits5 digits6 digits7\
    \ digits8 digits9 digits10\n    local -a sorted\n    local -i i\n    local j\n\
    \    local m\n    # Sort by length\n    for ((i = 9; i >= 0; i--)); do\n     \
    \   digits=\"${result[i]}\"\n        if (( ${#digits} > 0 )) ; then\n        \
    \    sorted=( ${digits[@]} )\n        fi\n    done\n    # Swap in reverse order\n\
    \    for (( i = 0; i < 9; i++ )); do\n        digits2=\"${sorted[i]}\"\n     \
    \   digits3=\"${sorted[9]}\"\n        digits=\"$digits3 $digits2\"\n    done\n\
    \    # Swap in order from 1 to 9\n    for (( i = 0; i < 9; i++ )); do\n      \
    \  digits=\"${result[i]}\"\n        if (( ${#digits} > 0 )); then\n          \
    \  m=${digits%?}\n            digits=\"$m ${digits#* }\"\n        fi\n    done\n\
    \    # Swap in order from 10 to 0\n    for (( i = 0; i < 9; i++ )); do\n     \
    \   digits=\"${result[i]}\"\n        if (( ${#digits} > 0 )); then\n         \
    \   m=${digits%?}\n            digits=\"${digits#* } $m\"\n        fi\n    done\n\
    \    # Replace every number in result\n    for (( i = 0; i < ${#result[@]}; i++\
    \ )); do\n        digits=\"${result[i]}\"\n        if (( ${#digits} > 0 )); then\n\
    \            digits2=${digits%?}\n            digits3=${digits#* }\n         \
    \   digits=$digits3 $digits2\n        fi\n        result[i]=\"${digits}\"\n  \
    \  done", "  local IFS=$1; shift\n  local ary=(\"${@}\")\n\n  for (( idx=0; idx<${#ary[@]};\
    \ idx++ )); do\n    if [[ \"${ary[$idx]}\" =~ ^([[:digit:]])+$ ]]; then\n    \
    \  ary[$idx]=${BASH_REMATCH[1]}\n    fi\n  done\n\n  if [ \"${#ary[@]}\" -gt 0\
    \ ]; then\n    local i\n    for (( i=0; i<${#ary[@]}; i++ )); do\n      printf\
    \ \"\\\"%s\\\"\\n\" \"${ary[$i]}\"\n    done\n  else\n    local i\n    for ((\
    \ i=0; i<${#ary[@]}; i++ )); do\n      printf \"\\\"%s\\\"\\n\" \"\\\"\\\"\\n\"\
    \n    done\n  fi", "  local input=\"$1\"\n  local output\n\n  if [ \"$input\"\
    \ = \"\" ]\n  then\n    return 0\n  fi\n\n  IFS=$' \\t\\n\\r' read -ra array <<<\
    \ \"$input\"\n\n  # If input doesn't contain enough elements, return an empty\
    \ array\n  if [ \"${#array[@]}\" -lt 2 ]\n  then\n    return 0\n  fi\n\n  # We\
    \ have enough elements and can sort the array\n  local tmp\n\n  for index in \"\
    ${!array[@]}\"; do\n    if [ \"$index\" -ge \"1\" -a \"$index\" -le \"9\" ]\n\
    \    then\n      tmp=\"${array[$index]}\"\n      array[$index]=${array[$index-1]}\n\
    \      array[$index-1]=$tmp\n    fi\n  done\n\n  # Reverse the array, then replace\
    \ each number by its name.\n  for i in $(seq ${#array[@]}); do\n    local tmp\n\
    \    tmp=${array[$i]}\n    array[$i]=${array[${#array[@]} - 1]}\n    array[${#array[@]}\
    \ - 1]=$tmp\n  done\n\n  # Return an array of the numbers by length:\n  output=(${array[@]})\n\
    \  IFS=' ' read -ra output <<< \"${output[@]}\"\n\n  return \"${output[@]}\"",
  "    local numbers=$1\n    local names=()\n    local lengths=()\n    for n in $numbers\n\
    \    do\n        len=${#n}\n        if (( len == 1 ))\n        then\n        \
    \    local n=$n\n            names=(\"${names[@]} $name\")\n        elif (( len\
    \ > 1 ))\n        then\n            local n=$n\n            for (( j=0; j<len;\
    \ j++ ))\n            do\n                length=$(expr $j + 1)\n            \
    \    local n=$n\n                names=(\"${names[@]} $name-$length\")\n     \
    \       done\n        else\n            echo \"The number has strange length $n\"\
    \n        fi\n    done\n    echo \"${names[@]}\"", "  local -i num\n  local -i\
    \ min\n  local -i max\n  local -i count\n  local -i index\n  local -i i\n  local\
    \ -i j\n  local -i result\n\n  if [[ -n $1 ]]; then\n    num=$(echo $1 | awk '{print\
    \ $1}')\n    # Make sure $num isn't empty.\n    [[ -n $num ]] || return $(by_length\
    \ \"\")\n\n    # Extract the minimum value from the string.\n    # -1 because\
    \ awk splits on whitespace.\n    min=$(echo $num | awk '{print $1}')\n    # Extract\
    \ the maximum value from the string.\n    # +1 because awk splits on whitespace.\n\
    \    max=$(echo $num | awk '{print $2}')\n    # Count up the digits of $num.\n\
    \    count=$(echo $num | awk '{print $0}' | wc -l)\n    # Iterate over the numbers\
    \ and store the name for each one.\n    index=1\n    i=${min}\n    while [[ $((i++))\
    \ -ge $((max+1)) ]]; do\n      # For each number $i, replace it with the name\
    \ $index.\n      ((index++))\n      # Re-add $i to $1.\n      echo \"$i\"\n  \
    \  done\n  fi", "  local array=\"$1\" output\n  IFS=\" \" read -r -a array <<<\"\
    $array\"\n  output=$(\n    case \"$array[@]\" in\n      [0-9]*) sort -n -r ;;\n\
    \      *)        echo \"$array\"\n    esac\n  )\n  echo \"$output\"", "    local\
    \ array name\n    local i tmp\n    array=( $1 )\n\n    for (( i=0; i<${#array[@]};\
    \ i++ )); do\n        # if the number is between 1 and 9 use one\n        tmp=${array[i]}\n\
    \        if (( tmp>=1 && tmp<=9 )); then\n            array[i]=${tmp/10}\n   \
    \         array[i]=${array[i%10]}\n        else\n            # else use two if\
    \ number between 10 and 99\n            array[i]=${array[i%100]}\n           \
    \ array[i]=${array[i]/10}\n            array[i]=${array[i%10]}\n            array[i]=${array[i%10]}\n\
    \        fi\n    done\n    i=0\n    for (( i=0; i<${#array[@]}; i++ )); do\n \
    \       tmp=${array[i]}\n        if (( tmp>=1 && tmp<=9 )); then\n           \
    \ array[i]=${tmp/10}\n            array[i]=${array[i%10]}\n        else\n    \
    \        # else use two if number between 10 and 99\n            array[i]=${array[i%100]}\n\
    \            array[i]=${array[i]/10}\n            array[i]=${array[i%10]}\n  \
    \          array[i]=${array[i%10]}\n        fi\n    done\n    echo \"${array[*]}\"",
  "    local arr digits ndigits result\n    arr=$1\n    digits=${arr// / }\n    #\
    \ echo \"DEBUG: digits: $digits\"\n    ndigits=${#digits}\n    # echo \"DEBUG:\
    \ ndigits: $ndigits\"\n    if [ -z \"$arr\" ] || [ $ndigits -gt 9 ] || [ $ndigits\
    \ -lt 1 ]; then\n        echo []\n    else\n        result=()\n        for i in\
    \ $(seq 1 $ndigits); do\n            if [ ${digits:$i:1} = 1 ] || [ ${digits:$i:1}\
    \ = 2 ] || [ ${digits:$i:1} = 3 ] || [ ${digits:$i:1} = 4 ] || [ ${digits:$i:1}\
    \ = 5 ] || [ ${digits:$i:1} = 6 ] || [ ${digits:$i:1} = 7 ] || [ ${digits:$i:1}\
    \ = 8 ] || [ ${digits:$i:1} = 9 ]; then\n                result+=(\"${digits:$i:1}\"\
    )\n            else\n                # We don't want to use \"echo\" here because\
    \ it prints EOF instead\n                # echo ${digits:$i}\n               \
    \ ((ndigits-=1))\n                if [ $ndigits -lt 0 ]; then\n              \
    \      result+=(\"$1\")\n                else\n                    result+=(\"\
    $digits\")\n                    break\n                fi\n            fi\n  \
    \      done\n        echo ${result[@]}\n    fi", "    local -r array=\"$1\"\n\
    \    local -r output=''\n    local -r min=1\n    local -r max=9\n    local i\n\
    \    local j\n    local cur\n    local num\n    local -a array=(\"${array[@]}\"\
    )\n    for ((i = 0; i < ${#array[@]}; i++)); do\n        num=\"${array[i]}\"\n\
    \        if [[ ${num} -eq $min ]]; then\n            if (( i > 0 )); then\n  \
    \              output +=\" \"\n            fi\n            array=(\"${array[@]:0:i}\"\
    \ \"${array[@]:i+1}\")\n            cur=\"${array[0]}\"\n            num=\"${num#0}\"\
    \n            while (( \"${num}\" > $max )); do\n                array=(\"${array[@]:0:i}\"\
    \ \"${array[@]:i+1}\")\n                num=\"${num#0}\"\n            done\n \
    \           num=$(printf '%03d' \"$num\")\n            cur=\"\\\"${cur}\\\"\"\n\
    \            output+=\"${cur}\" \"\n            min=$(( $max + 1 ))\n        \
    \    (( max -= 1 ))\n        else\n            if (( i < ${#array[@]} - 1 ));\
    \ then\n                output +=\" \"\n            fi\n            (( min = max\
    \ ))\n            array=(\"${array[@]:i+1}\" \"${array[@]:i}\")\n            cur=\"\
    ${array[0]}\"\n            num=\"${num#0}\"\n            while (( \"${num}\" <\
    \ $min )); do\n                array=(\"${array[@]:0:i}\" \"${array[@]:i+1}\"\
    )\n                num=\"${num#0}\"\n            done\n            num=$(printf\
    \ '%03d' \"$num\")\n            cur=\"\\\"${cur}\\\"\"\n            output+=\"\
    ${cur}\" \"\n            max=$(( $min - 1 ))\n        fi\n    done\n    IFS=\"\
    $IFS_OLD\"\n    echo \"${output}\"", "  local numbers=${1}\n  local reverse=\n\
    \  local names=()\n  local num=\n\n  IFS=' ' read -r -a nums <<< \"$numbers\"\n\
    \  for num in \"${nums[@]}\"; do\n    (( num > 9 )) || continue\n    (( num <\
    \ 1 )) || continue\n    (( num % 10 )) || continue\n\n    local name=\n    for\
    \ (( i = 9; i > num; i-- )); do\n      name=\"${name},\"\n    done\n    name=\"\
    ${name}\"\n    local name=${name%,}\n\n    (( num == 1 )) && names+=(\"\\\"One\\\
    \"\")\n    (( num == 2 )) && names+=(\"\\\"Two\\\"\")\n    (( num == 3 )) && names+=(\"\
    \\\"Three\\\"\")\n    (( num == 4 )) && names+=(\"\\\"Four\\\"\")\n    (( num\
    \ == 5 )) && names+=(\"\\\"Five\\\"\")\n    (( num == 6 )) && names+=(\"\\\"Six\\\
    \"\")\n    (( num == 7 )) && names+=(\"\\\"Seven\\\"\")\n    (( num == 8 )) &&\
    \ names+=(\"\\\"Eight\\\"\")\n    (( num == 9 )) && names+=(\"\\\"Nine\\\"\")\n\
    \  done\n\n  for num in \"${nums[@]}\"; do\n    (( num > 9 )) || continue\n  \
    \  (( num < 1 )) || continue\n    (( num % 10 )) || continue\n\n    local name=\n\
    \    for (( i = 9; i > num; i-- )); do\n      name=\"${name},\"\n    done\n  \
    \  name=\"${name}\"\n    local name=${name%,}\n\n    (( num == 1 )) && names+=(\"\
    \\\"One\\\"\")\n    (( num == 2 )) && names+=(\"\\\"Two\\\"\")\n    (( num ==\
    \ 3 )) && names+=(\"\\\"Three\\\"\")\n    (( num == 4 )) && names+=(\"\\\"Four\\\
    \"\")\n    (( num == 5 )) && names+=(\"\\\"Five\\\"\")\n    (( num == 6 )) &&\
    \ names+=(\"\\\"Six\\\"\")\n    (( num == 7 )) && names+=(\"\\\"Seven\\\"\")\n\
    \    (( num == 8 )) && names+=(\"\\\"Eight\\\"\")\n    (( num == 9 )) && names+=(\"\
    \\\"Nine\\\"\")\n  done\n\n  printf '%s\\n' \"${names[@]}\"", "  # This awk is\
    \ so simple that I have to ask myself if it will work in all cases\n  # I guess\
    \ it will, but I don't know why.\n  awk '\n    BEGIN {\n      s1=\"One\"\n   \
    \   s2=\"Two\"\n      s3=\"Three\"\n      s4=\"Four\"\n      s5=\"Five\"\n   \
    \   s6=\"Six\"\n      s7=\"Seven\"\n      s8=\"Eight\"\n      s9=\"Nine\"\n  \
    \    while ( length($1) ) {\n        for (i=1; i<=9; i++ ) {\n          s=substr($1,i,1)\n\
    \          if ( s >= 1 && s <= 9 ) {\n            $1=$1\"'\"$s\"'\"\n        \
    \    exit\n          }\n        }\n      }\n    }\n    { print }\n  ' <<< \"$1\"",
  "  local -n arr=$1\n\n  local number\n  for number in $arr; do\n    if [ $number\
    \ -ge 1 ] && [ $number -le 9 ]; then # $number is a number between 1 and 9\n \
    \     local digits=(${number//[[:digit:]]/})\n      local digit\n      for digit\
    \ in \"${digits[@]}\"; do\n        local name\n        case \"$digit\" in\n  \
    \        \"0\"*)\n            name=One\n            ;;\n          \"1\"*)\n  \
    \          name=Two\n            ;;\n          \"2\"*)\n            name=Three\n\
    \            ;;\n          \"3\"*)\n            name=Four\n            ;;\n  \
    \        \"4\"*)\n            name=Five\n            ;;\n          \"5\"*)\n \
    \           name=Six\n            ;;\n          \"6\"*)\n            name=Seven\n\
    \            ;;\n          \"7\"*)\n            name=Eight\n            ;;\n \
    \         \"8\"*)\n            name=Nine\n            ;;\n          *)\n     \
    \       name=$digit\n            ;;\n        esac\n        digits=()\n       \
    \ local i\n        for (( i=0; i<${#name[@]}; i++ )); do\n          digits+=(\"\
    $((${#digits[@]}+i)))\" \"$name[$((${#digits[@]}+i)))]\"\n        done\n     \
    \ done\n      arr=$( IFS=' '; echo \"${digits[*]}\" )\n    fi\n  done\n  echo\
    \ \"$arr\"", "    IFS=$' \\t\\n'\n    local array\n    if [ -z \"$1\" ]; then\n\
    \        array=()\n    else\n        IFS=' '\n        array=($1)\n    fi\n   \
    \ IFS=$' \\t\\n'\n    array=(${array[@]:1})\n    IFS=$'\\n' array=($(sort -r \"\
    $array\"))\n    IFS=$'\\n' \n    for i in ${array[@]};\n    do\n        if [ -z\
    \ \"$i\" ];\n        then\n            continue\n        fi\n        case \"$i\"\
    \ in\n            1) one=One ;;\n            2) two=Two ;;\n            3) three=Three\
    \ ;;\n            4) four=Four ;;\n            5) five=Five ;;\n            6)\
    \ six=Six ;;\n            7) seven=Seven ;;\n            8) eight=Eight ;;\n \
    \           9) nine=Nine ;;\n            *) echo \"Unrecognized integer $i in\
    \ array $array\"\n                exit 1\n        esac\n    done\n    echo \"\
    $one\"\n    echo \"$two\"\n    echo \"$three\"\n    echo \"$four\"\n    echo \"\
    $five\"\n    echo \"$six\"\n    echo \"$seven\"\n    echo \"$eight\"\n    echo\
    \ \"$nine\"", "\tlocal L\n\tlocal -a x\n\tlocal xx i\n\tlocal -a a\n\n\tif [ -z\
    \ \"$1\" ]; then\n\t\treturn 0\n\tfi\n\n\tL=$(echo \"$1\" | tr \"\\t\" \"\\n\"\
    \ | wc -l)\n\n\tif [ \"$L\" -gt 9 ]; then\n\t\tL=$(echo \"$1\" | wc -l)\n\tfi\n\
    \n\ta=($(echo \"$1\" | tr \" \" \"\\n\"))\n\tx=${a[*]}\n\n\tlocal j=0\n\n\tfor\
    \ ((i=0; i<L; i++)); do\n\t\tlocal c=${x:$i:1}\n\t\txx[$j]=$c\n\t\t((j++))\n\t\
    done\n\n\t((j=0))\n\tlocal n=0\n\tlocal h=${xx[*]}\n\tlocal z=0\n\n\twhile ((z<j));\
    \ do\n\t\ta[n]=\"${a[$z]}\"\n\t\t((n++))\n\t\t((z++))\n\tdone\n\n\tb=${a[*]}\n\
    \tlocal j=0\n\tfor ((i=0; i<L; i++)); do\n\t\tlocal c=${b:$i:1}\n\t\ta[$j]=\"\
    ${h[$j]}\"\n\t\t((j++))\n\tdone\n\n\tprintf \"\\\"%s\\\"\\n\" ${a[*]}", "    local\
    \ lst vals i res val\n    lst=\"$1\"\n    vals=$( echo \"$lst\" | tr \" \" \"\\\
    n\" )\n    res=()\n    for (( i=0; i<${#vals[@]}; i++ )); do\n        val=\"${vals[i]}\"\
    \n        if [[ ${#val} -lt 9 ]]; then\n            res+=(\"\\\"${val}\\\"\" ||\
    \ printf \"\\\"%d\\\"=\" ${val})\n        else\n            res+=(\"\\\"${val:0:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:0:1})\n            res+=(\"\\\"${val:1:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:1:1})\n            res+=(\"\\\"${val:2:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:2:1})\n            res+=(\"\\\"${val:3:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:3:1})\n            res+=(\"\\\"${val:4:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:4:1})\n            res+=(\"\\\"${val:5:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:5:1})\n            res+=(\"\\\"${val:6:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:6:1})\n            res+=(\"\\\"${val:7:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:7:1})\n            res+=(\"\\\"${val:8:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:8:1})\n            res+=(\"\\\"${val:9:1}\\\
    \"\" || printf \"\\\"%d\\\"=\" ${val:9:1})\n        fi\n    done\n    echo \"\
    ${res[@]}\"", "  local -r arr=$1\n\n  arr=${arr// /}\n  arr=(${arr//[[:space:]]/\
    \ })\n  arr=(\"${arr[@]/#/#}\")\n  arr=(${arr[@]/-/})\n  arr=(${arr[@]/#/#})\n\
    \n  local -r length=\"${#arr[@]}\"\n  if [ ${#arr[@]} -eq 0 ]; then\n    return\
    \ 0\n  fi\n\n  local -r first=\"${arr[0]}\"\n  local -r last=\"${arr[${length-1]}\"\
    \n\n  local -a sorted\n  sorted=()\n\n  local key\n  for (( i = 0 ; i < ${#arr[@]}\
    \ ; i++ )); do\n    local value=\"${arr[i]}\"\n    key=$((10#$value % 10))\n\n\
    \    # reverse the result of the sorting operation, then replace each digit by\
    \ its name\n    if [ \"${key}\" -gt \"9\" ]; then\n      value=($(echo \"${value}\"\
    \ | sed 's/'\"${key}\"'/'\"${!key}\"'/g'))\n    fi\n\n    sorted+=(\"${value[@]}\"\
    )\n  done\n\n  first=${first// /}\n  first=(${first//[[:space:]]/ })\n  first=(\"\
    ${first[@]/#/#}\")\n  first=(${first[@]/-/})\n  first=(${first[@]/#/#})\n\n  last=${last//\
    \ /}\n  last=(${last//[[:space:]]/ })\n  last=(\"${last[@]/#/#}\")\n  last=(${last[@]/-/})\n\
    \  last=(${last[@]/#/#})\n\n  (( ${#first[@]} > ${#last[@]} )) && last=(\"${first[@]}\"\
    )\n\n  echo ${sorted[*]} | sed 's/'${first[@]}','${last[@]}','/\"${first[@]}\"\
    ,\"${last[@]}\",\"/g'", "    set -- $1 || (echo \"Empty list provided\" && return\
    \ 1)\n    local result=()\n    local tmp i j\n    for (( i = 0; i <= 9; i++ ));\
    \ do\n        tmp_result=()\n        for (( j = (i+1); j <= 9; j++ )); do\n  \
    \          tmp=\"${i:i:1}${j:j:1}\"\n            tmp_result+=(\"${!tmp}\")\n \
    \       done\n        result+=(\"${tmp_result[@]}\")\n    done\n    for (( i =\
    \ 0; i <= 9; i++ )); do\n        eval printf -v tmp '\"%q\" \"%s\" \"%s\" \"%s\"\
    \ \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"' \\\n            \"${!i}\" \"${!i:i:1}\"\
    \ \"${!i:i:2:1}\" \"${!i:i:4:1}\" \"${!i:i:6:1}\" \\\n            \"${!i:i:8:1}\"\
    \ \"${!i:i:10:1}\" \"${!i:i:12:1}\" \"${!i:i:14:1}\" \"${!i:i:16:1}\"\n      \
    \  result+=(\"${!tmp}\")\n    done\n    echo \"${result[@]}\"", "  # Convert the\
    \ first argument to an array\n  IFS=' ' read -a arr <<< \"$1\"\n  \n  # Convert\
    \ the array from str to int\n  for i in \"${arr[@]}\"; do\n    arr+=( $((${i}+10))\
    \ )\n  done\n  \n  # Get the length of the array\n  length=\"${#arr[@]}\"\n  \n\
    \  # Reverse the array\n  for i in \"${arr[@]}\"; do\n    arr[i]=$(expr ${i} -\
    \ $((length-1)) )\n  done\n  \n  # Convert the array from int to str\n  arr=(\
    \ \"${arr[@]}\" )\n  \n  # Replace the elements by their name\n  for i in \"${arr[@]}\"\
    ; do\n    eval printf \"%q\" \"${arr[$i]}\"\n  done", "  # Bail if any arguments\
    \ are missing\n  test $# -gt 0 && return 0\n\n  # Extract the elements into an\
    \ array\n  local -n array=$1\n\n  # If no elements, return an empty array\n  #\
    \ (technically we could also just do 'return ()' but bash won't do the expansion\
    \ of\n  # the empty string for you)\n  # Don't use 'null', it's a reserved word!\n\
    \  test -z \"$array\" && return 0\n\n  # Remove any whitespace\n  local array\
    \ i\n  for i in\n    ${array[@]}\n  ; do\n    case \"$i\" in\n      # Remove leading/trailing\
    \ quotes\n      \"\\[\\([^\\]\\)]*\\)\" |\n      # Remove leading/trailing brackets\n\
    \      \"\\{\\([^\\}]*\\)\\}\" |\n      \"^\\([[:alpha:][:punct:]]*\\)$\" |\n\
    \      \"^[[:alpha:][:punct:]]$\" |\n      *)\n        array=(${array[@]//\"${i}\"\
    /})\n        ;;\n    esac\n  done\n\n  # Reverse the array\n  local -n array_r=\"\
    ${array[@]:(-1)}\"\n\n  # Return empty array if array is empty or contains only\
    \ numeric characters\n  test -z \"${array_r}\" || return\n\n  # For each character\
    \ in the string, get its numeric value.\n  # Then reverse the resulting array\
    \ from that value.\n  local i\n  local -a array_r\n  for i in\n    ${array_r[@]}\n\
    \  ; do\n    array_r+=(\"${array_r[@]:(-1)}\")\n    array_r=(${array_r[@]//\"\
    ${i}\"/})\n  done\n\n  # For each string in the reverse array, expand out its\
    \ quotes and brackets\n  local j\n  for j in\n    ${array_r[@]}\n  ; do\n    echo\
    \ \"${j//\\\"/}\"\n  done\n\n  unset -n array\n  unset -n array_r", "    local\
    \ -r arr=(\"$@\")\n    local -i i\n    local -a tmp\n    local -a ret\n\n    for\
    \ i in \"${!arr[@]}\"; do\n        tmp=()\n        j=\"${i}\"\n        while ((j\
    \ > 0)); do\n            ((j--))\n            tmp+=(\"${arr[j]}\")\n        done\n\
    \        # sort the array in reverse order\n        sort -r \"${tmp[@]}\"\n  \
    \      # replace each element with the corresponding name\n        ret+=(\"${tmp[${#ret[@]}\
    \ - 1]}\")\n    done\n\n    echo \"${ret[@]}\"", "  local arr\n  arr=$1\n  shift\n\
    \  local max_len\n  max_len=${#arr}\n  # convert all numbers to strings and sort\
    \ them, so any string in the list will be\n  # sorted, so \"10 10 2\" < \"10 10\
    \ 3\" but \"10\" < \"11\"\n  # we sort the list so that \"11\" comes before \"\
    10\"\n  arr=$(echo \"${arr}\" | tr \"\\n\" \" \")\n  arr=$(echo \"${arr}\" | xargs\
    \ -n1 printf \"%.0s\")\n  arr=$(echo \"${arr}\" | xargs -n1 printf \"%.0s\")\n\
    \  arr=$(echo \"${arr}\" | sort -nr)\n  # Now we reverse the list to start with\
    \ the largest number and remove all the digits, and\n  # then we put the result\
    \ back together with quotes around the strings\n  arr=$(echo \"${arr}\" | rev\
    \ | sed \"s/^/\\\"/g\" | sed \"s/$/\\\"/g\")\n  arr=$(echo \"${arr}\" | tr \"\\\
    n\" \" \")\n  # Now we check to see if there are any strings in the array, and\
    \ if there are, return the\n  # result\n  if [[ ${arr} == \"\" ]]; then\n    echo\
    \ \"\"\n  else\n    echo \"${arr}\"\n  fi", "    local i\n    local length=${1:-1}\n\
    \    local array=${2:-\"\"}\n    local result=${3:-\"\"}\n    local output\n\n\
    \    if [[ -z \"$length\" ]]; then\n        return result\n    fi\n\n    if [[\
    \ \"$length\" -lt 1 ]]; then\n        echo \"Invalid length: $length\"\n     \
    \   return 1\n    fi\n\n    for i in $(echo $array | tr \" \" \"\\n\" | sort -r);\
    \ do\n        case \"$i\" in\n            [1-9]) result+=(\"$i\") ;;\n       \
    \     *) result+=(\"One\") ;;\n        esac\n    done\n\n    for ((i=${#result[@]}-1;\
    \ i>=0; i--)); do\n        output=\"${result[$i]}\"\n        if [[ $output ==\
    \ \"One\" ]]; then\n            output=\"One\"\n        elif [[ $output == \"\
    Two\" ]]; then\n            output=\"Two\"\n        elif [[ $output == \"Three\"\
    \ ]]; then\n            output=\"Three\"\n        elif [[ $output == \"Four\"\
    \ ]]; then\n            output=\"Four\"\n        elif [[ $output == \"Five\" ]];\
    \ then\n            output=\"Five\"\n        elif [[ $output == \"Six\" ]]; then\n\
    \            output=\"Six\"\n        elif [[ $output == \"Seven\" ]]; then\n \
    \           output=\"Seven\"\n        elif [[ $output == \"Eight\" ]]; then\n\
    \            output=\"Eight\"\n        elif [[ $output == \"Nine\" ]]; then\n\
    \            output=\"Nine\"\n        fi\n        result[$i]=$output\n    done\n\
    \n    printf '[%s]' \"${result[@]}\"", "  local IFS=$1\n  local arr=$2\n  local\
    \ tmp\n  local tmp2\n  local tmp3\n  local tmp4\n  local tmp5\n  local tmp6\n\
    \  local tmp7\n  local tmp8\n  local tmp9\n  local tmp10\n  local result\n\n \
    \ IFS=\" \" read -r -a arr <<< \"${arr[@]}\"\n  if [ ${#arr[@]} -eq 0 ]; then\n\
    \    return 0\n  fi\n\n  local start\n  local end\n\n  start=0\n  end=${#arr[@]}\n\
    \  while [ \"${start}\" -le \"${end}\" ]; do\n    tmp=${arr[$start]}\n    tmp2=${tmp:0:1}\n\
    \    tmp3=${tmp:1:1}\n    tmp4=${tmp:2:1}\n    tmp5=${tmp:3:1}\n    tmp6=${tmp:4:1}\n\
    \    tmp7=${tmp:5:1}\n    tmp8=${tmp:6:1}\n    tmp9=${tmp:7:1}\n    tmp10=${tmp:8:1}\n\
    \n    if [ \"$tmp\" = \"${tmp10}\" ]; then\n      arr[$start]=\"${tmp6}${tmp8}${tmp9}\"\
    \n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp8}\" ]; then\n      arr[$start]=\"\
    ${tmp7}${tmp9}\"\n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp7}\"\
    \ ]; then\n      arr[$start]=\"${tmp5}${tmp9}\"\n      start=$((start+1))\n  \
    \  elif [ \"$tmp\" = \"${tmp6}\" ]; then\n      arr[$start]=\"${tmp4}${tmp10}\"\
    \n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp5}\" ]; then\n      arr[$start]=\"\
    ${tmp3}${tmp10}\"\n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp4}\"\
    \ ]; then\n      arr[$start]=\"${tmp2}${tmp10}\"\n      start=$((start+1))\n \
    \   elif [ \"$tmp\" = \"${tmp3}\" ]; then\n      arr[$start]=\"${tmp2}${tmp10}\"\
    \n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp2}\" ]; then\n      arr[$start]=\"\
    ${tmp1}${tmp10}\"\n      start=$((start+1))\n    elif [ \"$tmp\" = \"${tmp1}\"\
    \ ]; then\n      arr[$start]=\"${tmp}\"\n      start=$((start+1))\n    else\n\
    \      arr[$", "  local -i count=${#${1}}\n  local -i last=$count\n  local -i\
    \ lastdigit=$(( $(( ${1%,*}+0 )) ))\n  local -i lastdigitindex=0\n  local -i curdigit=$((\
    \ ${1%,*}+0 ))\n  local -i curdigitindex=0\n  local -i len=${#1}\n  local -i curletter=\"\
    One\"\n  local -i lastletter=\"One\"\n  local -i count=0\n  local -i i\n  local\
    \ array\n  local string\n  local string2\n  array=()\n\n  for (( i=0;i<len;i++\
    \ )); do\n    if [[ ${1:$i} =~ ^[0-9]$ ]]; then\n      count=$(( ${1:$i} ))\n\
    \      array+=(\"\\\"$(( ${1:$i} )+1)\\\"\")\n    elif [[ ${1:$i} =~ ^\"(.*)\"\
    $ ]]; then\n      array+=(\"\\\"$1\\\"\")\n    else\n      if [[ ${#array[@]}\
    \ -eq 0 ]]; then\n        array+=(\"\\\"$last\\\"\")\n      fi\n      if [[ \"\
    ${array[$lastdigitindex]}\" -gt ${count} ]]; then\n        array[$lastdigitindex]=${array[$lastdigitindex]#*-*}\n\
    \      fi\n      if [[ ${#array[@]} -ne 0 ]]; then\n        last=${array[$(( ${#array[@]}\
    \ -1 ))]}\n      fi\n      if [[ ${#array[@]} -ne 0 ]]; then\n        curdigit=${array[$lastdigitindex]%10}\n\
    \      fi\n      if [[ ${#array[@]} -ne 0 ]]; then\n        if [[ ${array[$lastdigitindex]}\
    \ -eq 0 ]]; then\n          lastdigitindex=0\n          lastdigit=$(( ${curdigit}\
    \ ))\n        else\n          lastdigitindex=$(( ${lastdigitindex} + 1 ))\n  \
    \        lastdigit=$(( ${array[$lastdigitindex]} ))\n        fi\n      fi\n  \
    \    string=$(( ${count}+1 ))\n      if [[ ${#array[@]} -ne 0 ]]; then\n     \
    \   string=$(( ${array[$lastdigitindex]} ))\n      fi\n      array+=(\"\\\"$curletter\\\
    \"$curdigit\")\n      lastdigit=$(( ${curdigit} ))\n      lastdigitindex=$(( ${lastdigitindex}\
    \ + 1 ))\n      curdigit=$((", "  local -n arr=\"${1#* }\"\n  local -r length=${#arr}\n\
    \n  if (( ${#arr} > 0 )); then\n    echo \"${arr[@]}\" \"${arr[@]:${length - 1}:1}\"\
    \n  else\n    local -n arr=()\n  fi", "    local array len\n\n    if [[ -z \"\
    $1\" ]]; then\n        # Passing an undefined variable\n        return\n    fi\n\
    \n    IFS=' '\n    array=($1)\n    len=\"${#array[@]}\"\n    if [[ -z \"$len\"\
    \ ]]; then\n        # Passing an empty array\n        return\n    fi\n    local\
    \ index=0\n    local name\n    while [[ \"$index\" -lt \"$len\" ]]; do\n     \
    \   if [[ \"$array[$index]\" -gt \"9\" ]]; then\n            # It's a digit from\
    \ 1 to 9\n            name=$(printf \"%02d\" \"$array[$index]\")\n        else\n\
    \            name=\"$array[$index]\" # It's a letter from A to Z\n        fi\n\
    \        array[$index]=\"${array[$index]#??}\"\n        array[$index]=\"$name\"\
    \n        index=$((index+1))\n    done\n    IFS=\n    local result\n    for ((i=${#array[@]};\
    \ i--; )); do\n        if [[ $i -eq 0 ]]; then\n            result=()\n      \
    \  fi\n        result+=(\"${array[i]}\")\n    done\n    # Don't forget to reverse\
    \ the result\n    local length\n    if [[ \"$len\" -eq 1 ]]; then\n        length=${#result[@]}\n\
    \    else\n        length=\"${#result[@]}\"\n    fi\n    echo ${result[@]:$((length-1))}",
  "    local numbers=$1\n\n    if [ -n \"${numbers}\" ] && [ \"$(echo \"${numbers}\"\
    \ | wc -l)\" -eq 0 ] ; then\n        return \"\"\n    fi\n\n    local numbers_len=$(echo\
    \ \"${numbers}\" | wc -l)\n    if [ \"${numbers_len}\" = \"0\" ] ; then\n    \
    \    return \"\"\n    fi\n\n    # split numbers into array\n    local tmp\n  \
    \  local number\n    IFS=$' ' read -ra numbers <<< \"${numbers}\"\n    for ((\
    \ i = 0 ; i < numbers_len ; i++ )); do\n        number=${numbers[i]}\n       \
    \ if ! [[ \"${number}\" -ge 1 ]] && ! [[ \"${number}\" -le 9 ]]; then\n      \
    \      continue\n        fi\n        tmp=${number:${#number}-1:1}\n        if\
    \ ! [[ \"${number}\" -eq 1 ]]; then\n            tmp=${number:${#number}-2:1}\n\
    \        fi\n        numbers[i]=\"${!tmp}\"\n    done\n\n    local numbers\n \
    \   IFS=$' ' read -ra numbers <<< \"${numbers[@]}\"\n    echo \"${numbers[@]}\"",
  "  local array=\"$1\"\n  local array=( $(echo \"${array}\" | awk '{ print $1 }')\
    \ )\n  local length=\"$2\"\n  local len\n  local digit\n  local digit=\"One\"\n\
    \  local lengths\n  local len\n  local str\n\n  lengths=( $(echo \"${array[@]}\"\
    \ | awk '{ print $1 }') )\n  len=\"${#lengths[@]}\"\n  local i\n\n  for i in $(seq\
    \ 0 \"$((len - 1))\"); do\n    digit=\"${digit}${lengths[$i]}\"\n  done\n\n  str=\"\
    \\\"${digit}\\\" \"\n  str=${str%?}\n  str=${str//\\\"/\\\"\\\"}\n  str=${str//\\\
    \"\\\"/\\\"\\\"\\\"}\n  str=${str//\\\"\\\"\\\"/\\\"\\\"\\\"\\\"\\\"}\n  str=${str//\\\
    \"\\\"\\\"\\\"/\\\"\\\"\\\"\\\"\\\"\\\"}\n  str=${str//\\\"\\\"\\\"\\\"\\\"/\\\
    \"\\\"\\\"\\\"\\\"\\\"\\\"\\\"}\n\n  echo \"${str}\"", "\tlocal -n arr=$1\n\t\
    if [ -z \"${arr[0]}\" ]; then\n\t\treturn 0\n\tfi\n\tlocal -a res=()\n\tfor ((i=0;i<${#arr[@]};++i));\
    \ do\n\t\tif [[ ${arr[i]} -ge 1 && ${arr[i]} -le 9 ]]; then\n\t\t\tres+=(\"${arr[i]}\"\
    )\n\t\tfi\n\tdone\n\tIFS=' '\n\tlocal t\n\twhile IFS=$' ' read -r -a t; do\n\t\
    \tif [[ ${#t[@]} -gt ${#res[@]} ]]; then\n\t\t\tres=(${res[@]} ${t[@]})\n\t\t\
    elif [[ ${#t[@]} -lt ${#res[@]} ]]; then\n\t\t\tres=(${t[@]} ${res[@]})\n\t\t\
    fi\n\tdone <<<\"$(printf \"${res[*]}\")\"\n\tprintf -v res '%q ' \"${res[@]}\"\
    \n\tprintf '%s\\n' \"${res[@]}\"", "    local digits=($1)\n    local i=0\n   \
    \ local res=()\n    while (( i < ${#digits[@]} )); do\n        (( i++ ))\n   \
    \     if (( ${digits[$i]} < 10 )); then\n            res+=(\"One\")\n        elif\
    \ (( ${digits[$i]} < 100 )); then\n            res+=(\"Two\")\n        elif ((\
    \ ${digits[$i]} < 1000 )); then\n            res+=(\"Three\")\n        elif ((\
    \ ${digits[$i]} < 10000 )); then\n            res+=(\"Four\")\n        elif ((\
    \ ${digits[$i]} < 100000 )); then\n            res+=(\"Five\")\n        elif ((\
    \ ${digits[$i]} < 1000000 )); then\n            res+=(\"Six\")\n        elif ((\
    \ ${digits[$i]} < 10000000 )); then\n            res+=(\"Seven\")\n        elif\
    \ (( ${digits[$i]} < 100000000 )); then\n            res+=(\"Eight\")\n      \
    \  elif (( ${digits[$i]} < 1000000000 )); then\n            res+=(\"Nine\")\n\
    \        else\n            echo \"Unknown digit: $digits[$i]\"\n        fi\n \
    \   done\n    echo ${res[@]}", "    local -n arr=$1; shift\n    echo \"${arr[@]}\"\
    \ | tr \" \" \"\\n\" | sort --version-sort --reverse | tr \"\\n\" \" \"", "  if\
    \ [ -z \"$1\" ] ; then\n    return 0\n  fi\n  local -a numbers=( $1 )\n  local\
    \ names=( \"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"Seven\" \"Eight\"\
    \ \"Nine\" )\n  local -a sorted=()\n  local names_count=${#names[@]}\n  local\
    \ numbers_count=${#numbers[@]}\n  if [ \"$numbers_count\" -gt \"$names_count\"\
    \ ] ; then\n    return 0\n  elif [ \"$numbers_count\" -eq \"$names_count\" ] ;\
    \ then\n    for (( i=0; i<${#names[@]}; ++i )); do\n      sorted[$i]=${names[$i]}\n\
    \    done\n    numbers=( \"${sorted[@]}\" )\n  else\n    for (( i=0; i<${#names[@]};\
    \ ++i )); do\n      sorted[$i]=${numbers[$i]}\n    done\n  fi\n  local -a reversed=()\n\
    \  local -a number_length=()\n  for (( i=1; i<${#sorted[@]}; ++i )); do\n    local\
    \ -a digits=()\n    local -a number=$( printf '%03d' $( echo \"${sorted[$i]}\"\
    \ | tr -cd '0-9' ) )\n    local -a digit=()\n    while [ \"$number\" -ge 0 ] ;\
    \ do\n      digit+=( $( echo \"${number}\" | awk '{printf($1)}' | tr -cd '0' ))\n\
    \      number=$( echo \"${number%0*}\" )\n    done\n    number_length+=( ${#digit[@]}\
    \ )\n    local -a digits_length=()\n    for (( j=0; j<${#digit[@]}; ++j )); do\n\
    \      digits_length+=( ${#digit[j]} )\n    done\n    reversed+=( \"${number}\"\
    \ )\n  done\n  local -a output=()\n  for (( i=0; i<${#reversed[@]}; ++i )); do\n\
    \    local -a digits=()\n    local -a reversed_digit=$( printf '%03d' $( echo\
    \ \"${reversed[$i]}\" | tr -cd '0-9' ) )\n    local -a digit=()\n    for (( j=0;\
    \ j<${#number_length[@]}; ++j )); do\n      digit+=( $( echo \"${number_length[$j]}\"\
    \ | awk '{printf($1)}' | tr -cd '0' ))\n", "    local arr=( ${1} )\n    local\
    \ lengths=( ${arr[@]} )\n    local -a out=( )\n\n    local i\n    local j\n  \
    \  local tmp\n\n    for ((i=0; i<${#lengths[@]}; i++)); do\n        tmp=${lengths[$i]}\n\
    \        (( tmp > 9 )) && {\n            lengths[$i]=${tmp:0:2}${tmp:2:1}${tmp:4:1}${tmp:6:1}${tmp:8:2}\n\
    \        }\n        lengths[$i]=${lengths[$i]}\n    done\n\n    for ((i=${#lengths[@]}-1;\
    \ i>=0; i--)); do\n        out+=( \"${lengths[$i]}\" )\n    done\n\n    for ((i=0;\
    \ i<${#lengths[@]}; i++)); do\n        j=$(( 10#$i ))\n        out+=( \"${out[$j]}\"\
    \ )\n    done\n\n    out=( \"${out[@]}\" )\n\n    # sort -rn\n    local -n tmp=\n\
    \    local IFS=$'\\n' sorted=\n    IFS=$'\\n'\n    for ((i=0; i<${#out[@]}; i++));\
    \ do\n        tmp[${out[$i]}]=${i}\n    done\n    IFS=$' \\t\\n'\n\n    for ((i=0;\
    \ i<${#out[@]}; i++));\n    do\n        (( sorted[i] )) && {\n            tmp[${sorted[i]}]=${out[$i]}\n\
    \        }\n    done\n\n    IFS=$IFS\n    local key=\n    for ((i=0; i<${#out[@]};\
    \ i++));\n    do\n        key=${out[$i]}\n        (( sorted[i] )) && {\n     \
    \       out[$i]=${tmp[${sorted[i]}]}\n        }\n    done\n    unset IFS\n\n \
    \   out=( \"${out[@]}\" )\n    return out[@]", "    local i tmp\n    for ((i =\
    \ 0; i < ${#1}; i++)); do\n        local idx=$(expr ${i} + 1)\n        # Skip\
    \ empty values\n        if [ -z \"${!idx}\" ]; then continue; fi\n        # Skip\
    \ all values that are not numbers\n        if [ -z \"$(echo \"${!idx}\" | grep\
    \ -P '^[0-9]+$')\" ]; then continue; fi\n        # Skip all values that are below\
    \ 1 inclusively\n        if [ \"$(echo \"${!idx}\" | bc -l)\" -lt 1 ]; then continue;\
    \ fi\n        # Skip all values that are above 9 inclusively\n        if [ \"\
    $(echo \"${!idx}\" | bc -l)\" -gt 9 ]; then continue; fi\n        # Skip all values\
    \ that are larger than 9 inclusively\n        if [ \"$(echo \"${!idx}\" | bc -l)\"\
    \ -gt \"9\" ]; then continue; fi\n        # Skip all values that are between 1\
    \ and 9 inclusive\n        if [ \"$(echo \"${!idx}\" | bc -l)\" -lt \"9\" ]; then\
    \ continue; fi\n        # Skip all values that are less than 1 inclusively\n \
    \       if [ \"$(echo \"${!idx}\" | bc -l)\" -lt 1 ]; then continue; fi\n    \
    \    # Skip all values that are all numbers\n        if [ \"$(echo \"${!idx}\"\
    \ | grep -P '^[0-9]+$')\" ]; then continue; fi\n        local len=\"${!idx}\"\n\
    \        # Skip all values that are between 1 and 9 inclusive\n        if [ \"\
    $(echo \"${!idx}\" | bc -l)\" -lt \"9\" ]; then continue; fi\n        # Skip all\
    \ values that are greater than 9 inclusive\n        if [ \"$(echo \"${!idx}\"\
    \ | bc -l)\" -gt \"9\" ]; then continue; fi\n        local str=\"${!idx}\"\n \
    \       local digit=\"${!idx:0:1}\"\n        local strlen=\"${#str}\"\n      \
    \  # Only replace digits if all digits are different\n        if [ \"$(echo \"\
    ${str}\" | bc -l)\" -eq \"0\" ]; then continue; fi\n        # Only replace digits\
    \ if all digits are different\n        if [ \"$(echo \"${str}\" | grep -P '^[0-9]+$')\"\
    \ ]; then continue; fi\n        local result=\"\"\n        # Find all digits between\
    \ 1 and 9 inclusive\n        local idx1=0\n        local idx2=$(( ${#str} - ${#digit}\
    \ ))\n        while [ \"${idx1}\" -lt \"$idx2\" ]; do", "\tlocal array=$1\n\t\
    local names\n\tlocal result\n\tlocal length\n\tlocal i\n\tlocal j\n\tlocal n\n\
    \n\t# The names will be stored in this array, one per line in the input.\n\t#\
    \ Each name has a space after it, so to put each name on a separate line,\n\t\
    # insert a space after the name before the newline.  Then, add the\n\t# new-line\
    \ character to the end:\n\tnames=()\n\n\t# Get the length of the array, and also\
    \ the number of digits that make up the\n\t# numbers in the array:\n\tlength=${#array[@]}\n\
    \tn=0\n\n\t# For each element in the array:\n\tfor ((i = 0; i <= length; i++));\
    \ do\n\t\tnum=${array[i]}\n\t\t# If the number is a single digit, just add it\
    \ to the names array:\n\t\tif [[ $num != [0-9] ]]; then\n\t\t\tnames+=(\"${num}\
    \ \")\n\t\telse\n\t\t\t# Get the position of the current digit in the array:\n\
    \t\t\tj=$((${#num}-1))\n\t\t\t# If the number is less than ten, just add it to\
    \ the names array:\n\t\t\tif [[ ${num} -le 10 ]]; then\n\t\t\t\tnames+=(\"${num}\
    \ \")\n\t\t\telse\n\t\t\t\t# Otherwise, reverse the digits, and add it to the\
    \ names array:\n\t\t\t\trev=$(${array[@]} ${i} ${j} ${length})\n\t\t\t\tnames+=(\"\
    ${rev:0:$((${#rev}-1))} \")\n\t\t\tfi\n\t\tfi\n\tdone\n\n\t# Reverse the array:\n\
    \tarray=( \"${names[@]}\" )\n\tresult=\"\"\n\tfor ((i = ${#array[@]}; i >= 1;\
    \ i--)); do\n\t\tresult=\"${result}${array[i-1]}\"\n\tdone\n\tresult+=\"\\n\"\n\
    \n\t# Replace each digit in the array by the corresponding name\n\tfor ((i = ${#result};\
    \ i >= 1; i--)); do\n\t\tn=$(expr $i \\* 10)\n\t\tresult=\"${result//${n:0:1}\\\
    }\\\"${!n}\\\"\"\n\tdone\n\n\t# Remove the space after the name before the last\
    \ new-line character:\n\tresult=\"${result%?}\"\n\tresult+=\"\\n\"\n\n\t# Add\
    \ the new-line character to the end:\n\tresult+=\"\\n\"\n\n\t# Return the result\
    \ array:\n\techo \"$result\"", "    local -n arr=$1\n    local -i len=${#arr[@]}\n\
    \    local -r digits=\"One Two Three Four Five Six Seven Eight Nine\"\n    local\
    \ -r digits_num=$(echo \"$digits\" | tr ' ' '\\n' | sort -n -k 1 -r | head -1)\n\
    \    local -i len_to_return=-1\n    local -i i\n    for ((i=0; i < len; i++ ));\
    \ do\n        local -n val=${arr[i]}\n        if [[ ${#val} -eq 1 ]]; then\n \
    \           len_to_return=$i\n            break\n        fi\n    done\n    if\
    \ [[ $len_to_return -eq -1 ]]; then\n        echo \"$arr\"\n    else\n       \
    \ local -i c\n        for ((c=0; c < len; c++ )); do\n            local -n val=${arr[c]}\n\
    \            local -i len_of_val=${#val}\n            if ((len_of_val == 1)) then\n\
    \                arr[$c]=\"${digits[${digits_num}+$(($c - 1))]}\"\n          \
    \  elif ((len_of_val > 1)) && ((len_of_val % 2) == 0) && [[ $((len_of_val / 2))\
    \ -eq 0 ]]; then\n                local -i j\n                local -i k\n   \
    \             for ((j=0; j < len_of_val; j++ )); do\n                    local\
    \ -n val=${arr[j]}\n                    local -i len_of_val=${#val}\n        \
    \            for ((k=0; k < len_of_val; k++ )); do\n                        arr[$c]=\"\
    ${arr[$c]}${digits[$((len_of_val - j))]}\"\n                    done\n       \
    \         done\n            fi\n        done\n        echo \"${arr[@]}\"\n   \
    \ fi", "  local i arr len\n  IFS=' ' read -r -a arr <<< \"$1\"\n  for ((i = 0;\
    \ i < \"${#arr[@]}\"; ++i)); do\n    if (( \"${arr[i]}\" >= 1 && \"${arr[i]}\"\
    \ <= 9 )); then\n      arr[i]=\"${!arr[i]}\"\n    fi\n  done\n  IFS=' ' read -r\
    \ -a arr <<< \"${arr[@]}\"\n  IFS='' arr=(${arr[@]/#//})\n  for ((i = 0; i < \"\
    ${#arr[@]}\"; ++i)); do\n    echo \"${name[$i]}\"\n  done", "    local array=$1\n\
    \    # Make sure all digits are between 1 and 9\n    local length=${#array[@]}\n\
    \    for ((i=0; i<length; i++)); do\n        if [[ ${array[$i]} =~ ^[0-9]+$ ]];\
    \ then\n            if [[ ${#array[$i]} -eq 1 ]]; then\n                array[$i]=\"\
    One\"\n            elif [[ ${#array[$i]} -eq 2 ]]; then\n                array[$i]=\"\
    Two\"\n            elif [[ ${#array[$i]} -eq 3 ]]; then\n                array[$i]=\"\
    Three\"\n            elif [[ ${#array[$i]} -eq 4 ]]; then\n                array[$i]=\"\
    Four\"\n            elif [[ ${#array[$i]} -eq 5 ]]; then\n                array[$i]=\"\
    Five\"\n            elif [[ ${#array[$i]} -eq 6 ]]; then\n                array[$i]=\"\
    Six\"\n            elif [[ ${#array[$i]} -eq 7 ]]; then\n                array[$i]=\"\
    Seven\"\n            elif [[ ${#array[$i]} -eq 8 ]]; then\n                array[$i]=\"\
    Eight\"\n            elif [[ ${#array[$i]} -eq 9 ]]; then\n                array[$i]=\"\
    Nine\"\n            else\n                array[$i]=\"\"\n            fi\n   \
    \     fi\n    done\n    # Convert the array back to a string (including spaces)\n\
    \    local string=${array[@]}\n    # Replace each digit by its corresponding name\
    \ from One, Two, Three, Four, Five, Six,\n    # Seven, Eight, Nine\n    # For\
    \ example: 2 becomes Two, 1 becomes One, etc.\n    string=$(echo $string | tr\
    \ \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"One\"\\1/g')\n    string=$(echo $string\
    \ | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"Two\"\\1/g')\n    string=$(echo $string\
    \ | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"Three\"\\1/g')\n    string=$(echo\
    \ $string | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"Four\"\\1/g')\n    string=$(echo\
    \ $string | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"Five\"\\1/g')\n    string=$(echo\
    \ $string | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/\"Six\"\\1/g')\n    string=$(echo\
    \ $string | tr \" \" \"\\n\" | sed 's/\\([0-9]\\)/", "    local array=\"$1\"\n\
    \    local output\n\n    # Strip leading and trailing spaces (if any)\n    array=\"\
    $(echo \"$array\" | tr \" \" \"\")\"\n\n    # Convert to a list of integer numbers,\
    \ ignore any strange input\n    array=\"$(echo \"$array\" | tr -d \"[[:space:]]\"\
    )\"\n    array=\"$(echo \"$array\" | tr \" \" \"\" | sed 's/^ *//;s/ *$//;s/^\
    \ *//')\"\n\n    # Sort the list\n    array=\"$(echo \"$array\" | tr \" \" \"\"\
    \ | sort -n | tr -d \"[[:space:]]\")\"\n\n    # Replace the digits of each number\
    \ by the corresponding letter\n    array=\"$(echo \"$array\" | sed 's/^ *//;s/\
    \ *$//;s/^ *//' | tr \"0 1 2 3 4 5 6 7 8 9\" \" \" \"One\" \"Two\" \"Three\" \"\
    Four\" \"Five\" \"Six\" \"Seven\" \"Eight\" \"Nine\")\"\n\n    # Restore the trailing\
    \ spaces (if any)\n    array=\"$(echo \"$array\" | tr \" \" \" \")\"\n\n    #\
    \ Return output\n    echo \"$array\"", "    local -n array=\"$1\"\n    local i=0\n\
    \    local -a out=()\n    local digit\n    while IFS= read -r digit; do\n    \
    \    ((i++))\n        out+=(\"\\\"${digit}\\\"\" \"${#out[@]}\")\n    done < <(\n\
    \        # Sort an array numerically, and then reverse it.\n        # Pipe output\
    \ to a while loop that reads one digit at a time.\n        # Using read without\
    \ -r avoids problems with backslashes in filenames.\n        sort -n --reverse\
    \ <<<\"${array[*]}\"\n    )\n    # Assign the array to a variable, ignoring any\
    \ empty elements.\n    # ${array[@]:i} returns the sorted array, and ${#array[@]}\
    \ returns the length of\n    # that array.\n    local -i j=\"${#out[@]}\"\n  \
    \  for ((j; j <= ${#array[@]}; j++)); do\n        ((i--))\n        array=\"${out[j]}\"\
    \n        ((j--))\n        out[${#out[@]}]=\"\\\"${array}\\\"\"\n    done\n  \
    \  echo \"${out[@]:i}\"", "    local -a ints\n    local -a names\n    local i=0\
    \ l=$1\n    while [ $l -ge 1 ] && [ $l -lt 9 ]; do\n        ints[$((i-1))]=$((l-1))\n\
    \        l=$(expr $l / 10)\n        ((i++))\n    done\n    ints=($(l))\n    local\
    \ -a tmp len=$i\n    local j=0\n    for i in ${ints[@]}; do\n        if [ \"$i\"\
    \ -eq \"$i\" -a \"$i\" -eq \"$i\" ]; then\n            names[j]=${names[@]:$((j-1))}\n\
    \        else\n            tmp[$j]=\"$names[j++]\"\n        fi\n    done\n   \
    \ names=($(l${tmp[@]}))", "  # Return empty array if arguments are empty\n  [[\
    \ -z \"$1\" ]] && return 1\n  # Return empty array if there are no non-negative\
    \ integers\n  [[ ! -z \"$1\" ]] && [[ ! \"$(echo $1 | awk '{print $1}')\" =~ ^[0-9]+$\
    \ ]] && return 1\n  # Split the string into an array of ints, excluding leading\
    \ spaces, then sort\n  IFS=' ' read -ra array <<< \"$1\"\n  sorted=$(IFS=' ';\
    \ echo \"${array[@]}\"; unset IFS)\n  (( ${#sorted[@]} > 9 )) && return 1\n  ((\
    \ ${#sorted[@]} < 9 )) && sorted+=(\"$((${#sorted[@]} - 9))\" \"One\" \"Nine\"\
    )\n  # Reverse the array\n  reversed=(\"${sorted[@]}\" | tac | xargs)\n  # Replace\
    \ each digit with its corresponding name\n  result=\"$(IFS=' '; echo \"${reversed[@]}\"\
    ; unset IFS)\"\n  # Return sorted array with names replaced by their corresponding\
    \ numbers\n  [[ -z \"$result\" ]] && return 1 || printf '%s\\n' \"$result\"",
  "    local arr=\"$1\"\n    local len\n    local i\n    local result\n    local j\n\
    \    for ((i = 0; i < ${#arr}; i++)); do\n        arr=\"${arr:$i:1}\"\n      \
    \  if [[ -z $arr ]]; then\n            return 0;\n        fi\n        case \"\
    ${arr}\" in\n            ^[0-9]+$) continue;;\n            *) continue;;\n   \
    \     esac\n        ((len = $(expr length \"$arr\")));\n        arr=\"$(echo \"\
    $arr\" | sed 's/^/\"/;s/$/\"/;s/^[0-9]*$/'\"$len\"'/;s/^0*$/'\"$len\"'/;s/^ *[0-9]+$/'\"\
    $len\"'/;s/^ *0*$/'\"$len\"'/;s/^ * *[0-9]+$/'\"$len\"'/;s/^ *0*$/'\"$len\"'/;s/^\
    \ * * *[0-9]+$/'\"$len\"'/;s/^ * *0*$/'\"$len\"'/;s/^ * * * *[0-9]+$/'\"$len\"\
    '/;s/^ * * *0*$/'\"$len\"'/;s/^ * * * * *[0-9]+$/'\"$len\"'/;s/^ * * * *0*$/'\"\
    $len\"'/;s/^ * * * * * *[0-9]+$/'\"$len\"'/;s/^ * * * * *0*$/'\"$len\"'/;s/^ *\
    \ * * * * * *[0-9]+$/'\"$len\"'/;s/^ * * * * *0*$/'\"$len\"'/;s/^ * * * * * *\
    \ *0*$/'\"$len\"'/;s/^ * * * * * * * *$/'\"$len\"'/')\"\n        result+=(\"${arr//[^\
    \ A-Za-z0-9]/}\")\n    done\n    echo \"${result[@]}\"", "  local -r n=$1\n  shift\n\
    \  local -r array=( \"${@}\" )\n  local -r length=${#array[@]}\n  local -r output=(${array[@]:1:$length})\n\
    \  local i\n  for ((i = 0; i <= $((length / 2)); i++)); do\n    local val=${array[i]}\n\
    \    local val2=${array[$((length - i - 1))]}\n    if (( $(echo \"$val < $val2\"\
    \ | bc -l) ));then\n      output[$i]=\"${val2}\"\n    fi\n  done\n  output=\"\
    ${output[@]:1:${#output[@]}}\" # get rid of the trailing zeroes\n  printf '%s\\\
    n' \"${output[@]}\" | sort -u | tr '[:upper:]' '[:lower:]'", "  local l=$1\n \
    \ local numbers=()\n  local i=0\n  while [ \"$i\" -lt \"${#l}\" ]; do\n    numbers+=(\
    \ ${l:$i:1} )\n    i=$((i+1))\n  done\n  if [[ \"${#numbers[@]}\" -eq 0 ]]; then\n\
    \    echo []\n  else\n    local n=${#numbers[@]}\n    for (( i=${n-1}; i>0; i--\
    \ )); do\n      local number=${numbers[i]}\n      local num=$((${number/./${number[0]}}))\n\
    \      number=${number:0:1}\n      local str=\"${numbers[$((num-1))]}\"\n    \
    \  numbers+=($str)\n    done\n  fi", "\tlocal line\n\tlocal array\n\tlocal result\n\
    \n\tarray=\"$1\"\n\tresult=()\n\twhile IFS=\" \" read -r -a line; do\n\t\t((${#line[@]}\
    \ > 0)) || continue\n\t\tlocal length=\"${#line[@]}\"\n\t\t((length >= 1)) &&\
    \ result+=(\"${line[@]:0:1}\")\n\t\t((length >= 2)) && result+=(\"${line[@]:1:1}\"\
    )\n\t\t((length >= 3)) && result+=(\"${line[@]:2:1}\")\n\t\t((length >= 4)) &&\
    \ result+=(\"${line[@]:3:1}\")\n\t\t((length >= 5)) && result+=(\"${line[@]:4:1}\"\
    )\n\t\t((length >= 6)) && result+=(\"${line[@]:5:1}\")\n\t\t((length >= 7)) &&\
    \ result+=(\"${line[@]:6:1}\")\n\t\t((length >= 8)) && result+=(\"${line[@]:7:1}\"\
    )\n\t\t((length >= 9)) && result+=(\"${line[@]:8:1}\")\n\tdone <<< \"$array\"\n\
    \n\t# Reverse the result.\n\tresult=(\"${result[@]:1}\")\n\tresult=(${result[@]#\"\
    ${result[0]}\"})\n\tresult=(${result[@]%\"${result[0]}\"})\n\n\t# Replacing the\
    \ results with its name from the \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\" list.\n\tlocal i\n\tfor i in \"${!result[@]}\"\
    ; do\n\t\tresult[i]=\"${result[i]// /One}\"\n\tdone\n\n\tprintf '\"%s\"\\n' \"\
    ${result[@]}\"", "  local i\n  local len\n  local str\n  local result\n\n  # Remove\
    \ all spaces\n  local -n arr=$1\n\n  # Convert the list to an array\n  IFS=' '\
    \ read -ra arr <<< \"$1\"\n\n  # Calculate the number of digits\n  len=\"${#arr[@]}\"\
    \n\n  # If there's no elements, return the empty array\n  if [[ \"$len\" -gt 0\
    \ ]]; then\n    # Reverse the array\n    arr=(${arr[@]:1})\n\n    # Sort it\n\
    \    sort -n <<<\"${arr[*]}\"\n\n    # Map it to our names\n    str=\"${arr[*]}\"\
    \n    for ((i=0; i<$len; i++)); do\n      str[$i]=\"$($REPLY[$i])\"\n    done\n\
    \    result=$(echo \"${str[*]}\")\n\n    # Restore the original IFS settings\n\
    \    IFS=\"$IFS_OLD\"\n  else\n    # Return an empty array\n    result=\n  fi\n\
    \n  # Remove quotes\n  echo ${result//\\\"}", "\tlocal array=\"$1\"\n\tlocal length_array=()\n\
    \tfor (( i=0; i<${#array[@]}; i++ )); do\n\t\tlocal item=${array[i]}\n\t\tlocal\
    \ len=${#item}\n\t\tif [[ $len > 0 && $len < 9 ]]; then\n\t\t\tlength_array+=(\n\
    \t\t\t\t$(echo \"${item}\" | sed -e 's/^.//g' -e 's/^..//g' -e 's/^.\\{1,9\\}//g'\
    \ -e \"s/^0/${item[0]}/g\" -e \"s/^1/${item[1]}/g\" -e \"s/^2/${item[2]}/g\" -e\
    \ \"s/^3/${item[3]}/g\" -e \"s/^4/${item[4]}/g\" -e \"s/^5/${item[5]}/g\" -e \"\
    s/^6/${item[6]}/g\" -e \"s/^7/${item[7]}/g\" -e \"s/^8/${item[8]}/g\" -e \"s/^9/${item[9]}/g\"\
    )\n\t\t\t)\n\t\tfi\n\tdone\n\techo ${length_array[@]}", "    local -r array=\"\
    $1\"\n    local name\n    local -i count\n    local -i position\n    local element\n\
    \n    for (( position = 0; position < ${#array}; ++position )); do\n        element=${array[position]}\n\
    \        if [[ \"${element}\" =~ ^([[:digit:]]|0) ]]; then\n            count=$((\
    \ ${element} + 1 ))\n            if [[ \"${count}\" -ge 10 ]]; then\n        \
    \        count=\"0${count}\"\n            fi\n            array=\"${array// /${count}}\"\
    \n        else\n            if [[ \"${element}\" =~ ^[[:alpha:]]$ ]]; then\n \
    \               name=\"${element}\"\n            else\n                array=\"\
    ${array// /${element}}\"\n            fi\n        fi\n    done\n\n    local result\n\
    \    result=$(IFS=\",\"; echo \"${array}\" | tr '\\n' ' ')\n    echo ${result[@]}",
  "    local array=\"$1\"\n    if [ -z \"${array}\" ]; then\n        echo \"[]\"\n\
    \        return\n    fi\n    local lengths=()\n    while read line; do\n     \
    \   # echo \"$line\" | grep -Eo \"[0-9]{1,2}\"\n        if [ -z \"$line\" ]; then\n\
    \            continue\n        fi\n        local length=0\n        for digit in\
    \ $line; do\n            ((length+=1))\n        done\n        ((lengths[length]+=1))\n\
    \    done < <(printf '%s\\n' \"${array[@]}\" | sort -u | tr ' ' $'\\n' | sed -E\
    \ 's/([0-9]{1,2})/\"$1/g')\n    local result=()\n    for length in ${!lengths[*]};\
    \ do\n        local length_name=${lengths[$length]}\n        local number=${length_name%?}\n\
    \        result+=(\"\\\"${!number}\\\"\")\n    done\n    echo \"${result[@]}\"",
  "  local array i\n  array=( $1 )\n  if [ ${#array[@]} -eq 0 ]\n  then\n    return\
    \ ()\n  fi\n  for i in ${!array[@]}\n  do\n    array[ $i ]=$(( ${array[$i]} +\
    \ 1 ))\n  done\n  i=1\n  while [ $i -le 10 ]\n  do\n    local digit=( \"${array[$i]}\"\
    \ )\n    array[$i]=${!digit}\n    i=$(( $i + 1 ))\n  done\n  for i in ${!array[@]}\n\
    \  do\n    if [ \"${array[$i]}\" -eq 0 ]\n    then\n      array[$i]='One'\n  \
    \  fi\n  done\n  return ( \"${array[@]}\" )", "    local -n a=$1\n    local -a\
    \ tmp\n\n    for tmp in \"${a[@]}\"; do\n        if [ -z \"$tmp\" ]; then\n  \
    \          continue\n        fi\n\n        local tmp2\n        tmp2=$(\n     \
    \       echo -n \"$tmp\"\n            cut -d ' ' -f 2\n            sed -r \"s/([1-9][0-9]|0)/$(cat\
    \ <<-EOF\n                echo \"One\"\n                echo \"Two\"\n       \
    \         echo \"Three\"\n                echo \"Four\"\n                echo\
    \ \"Five\"\n                echo \"Six\"\n                echo \"Seven\"\n   \
    \             echo \"Eight\"\n                echo \"Nine\"\n            EOF\n\
    \            )/\" <<< \"$tmp\")\n        echo \"$tmp2\"\n    done", "\tlocal -r\
    \ array=\"$1\"\n\tlocal -r nums=()\n\tlocal i\n\n\tIFS=' ' read -ra nums < <(\n\
    \t\tawk '\n\t\t{\n\t\t\tfor (i = 1; i <= NF; i++) {\n\t\t\t\tif ($i >= 1 && $i\
    \ <= 9) {\n\t\t\t\t\tnums[NF-i+1] = $(printf \"%03d\" $i)\n\t\t\t\t}\n\t\t\t}\n\
    \t\t}\n\t\tEND {\n\t\t\tprint \"\"\n\t\t\tfor (i = 1; i <= length(nums); i++)\
    \ {\n\t\t\t\tprint nums[length(nums)-i-1]\n\t\t\t}\n\t\t}\n\t\t' <<<\"$array\"\
    \n\t)\n\tprintf \"%s\\n\" \"${nums[@]}\"", "    IFS=\" \" read -r -a array <<<\
    \ \"$1\"\n\n    # Sort the array in descending order\n    local -a sorted_array\n\
    \    for i in \"${array[@]}\"; do\n        case \"$i\" in\n            1|2|3|4|5|6|7|8|9)\n\
    \                sorted_array+=(\"$i\")\n                ;;\n            *)\n\
    \                echo \"$i\" | awk -v ORS=\" \" '{ for (i = 1; i <= NF; ++i) printf\
    \ \"\\\"%s\\\", \" $i; print \"\" }' | sort -n -r\"\\\\n\"\n                sorted_array+=(\"\
    $i\")\n                ;;\n        esac\n    done\n\n    # Remove all odd length\
    \ elements and reverse the array\n    local -a sorted_array_reversed\n    for\
    \ i in \"${sorted_array[@]}\"; do\n        case \"$i\" in\n            1)\n  \
    \              sorted_array_reversed+=(\"$i\")\n                ;;\n         \
    \   *)\n                sorted_array_reversed+=(\"$i\")\n                ;;\n\
    \        esac\n    done\n    sorted_array_reversed=(\"${sorted_array_reversed[@]}\"\
    \ )\n    unset IFS\n\n    # Replace all even length elements by their corresponding\
    \ names\n    for i in \"${sorted_array_reversed[@]}\"; do\n        case \"$i\"\
    \ in\n            One)\n                echo \"\\\"One\\\"\"\n               \
    \ ;;\n            Two)\n                echo \"\\\"Two\\\"\"\n               \
    \ ;;\n            Three)\n                echo \"\\\"Three\\\"\"\n           \
    \     ;;\n            Four)\n                echo \"\\\"Four\\\"\"\n         \
    \       ;;\n            Five)\n                echo \"\\\"Five\\\"\"\n       \
    \         ;;\n            Six)\n                echo \"\\\"Six\\\"\"\n       \
    \         ;;\n            Seven)\n                echo \"\\\"Seven\\\"\"\n   \
    \             ;;\n            Eight)\n                echo \"\\\"Eight\\\"\"\n\
    \                ;;\n            Nine)\n                echo \"\\\"Nine\\\"\"\n\
    \                ;;\n            *)\n                echo \"$i\"\n           \
    \     ;;\n        esac\n    done", "  # Convert all arguments to strings\n  local\
    \ -a lengths=(\"${(@s//,/ )}\")\n  # Convert all arguments to integers\n  local\
    \ -a ints=(\"${(@s/[0-9]// )}\")\n  if [ -n \"${ints[*]}\" ]; then\n    # Sort\
    \ it\n    local -r array=(\"${(@s/ /)}\")\n    local -r sorted_length=(\"${(by_length\
    \ \"${array[@]}\" | sort -r)}\")\n    # Now reverse it\n    local -r sorted_ints=(\"\
    ${(@s/ /)}\")\n    local -r sorted_length=(\"${(@s/ /)}\")\n    # And now replace\
    \ each digit with a string from the array\n    for i in \"${sorted_length[@]}\"\
    ; do\n      local -a temp=(\"${sorted_ints[@]:$i:1}\")\n      sorted_ints[@]=(\"\
    ${(@s/ /)}\")\n      local -r index=${sorted_length[$i]}\n      sorted_ints[$i]=\"\
    ${temp[$index-1]}\"\n    done\n    # And finally print it out\n    IFS=\" \" read\
    \ -r -a array <<< \"${sorted_ints[@]}\"\n  else\n    # Nothing to do\n    return\n\
    \  fi\n  # Return it\n  echo \"${array[@]}\"", "    local l=$1\n\n    if [ -z\
    \ \"$l\" ]; then\n        echo \"[]\"\n        return\n    fi\n\n    local numbers=()\n\
    \    for n in $l; do\n        local i=\n        if [[ $n =~ (^[[:digit:]]+) ]];\
    \ then\n            local i=\"${BASH_REMATCH[1]}\"\n            (( i %= 10 ))\n\
    \            (( i != 0 )) && numbers+=(\"\\\"$i\\\"\")\n        else\n       \
    \     numbers+=(\"\\\"$n\\\"\")\n        fi\n    done\n\n    echo \"${numbers[@]}\"\
    \ | \\\n        sort -r -k 1,1 \\\n        | xargs printf '%s\\n' | \\\n     \
    \   xargs printf '\"%s\"' | \\\n        sed 's/\\\\/\\\\\\\\/g' | \\\n       \
    \ sed 's/\"/\\\\\"/g' | \\\n        sed 's/^/\"/g' | \\\n        sed 's/$/\"/g'\
    \ | \\\n        sed 's/\"/\\\\\"/g' | \\\n        sed 's/\\\\/\\\\\\\\/g' | \\\
    \n        sed 's/\\[/\\\\\\[/g' | \\\n        sed 's/\\]/\\\\\\]/g' | \\\n   \
    \     sed 's/\\([^\"]*\\)/\"&\"/g'", "    local numbers=$1\n    local lengths\n\
    \    local -a sorted\n    local -i i\n    lengths=($(echo \"${numbers}\"|tr \"\
    \ \" \"\\n\"|sort -r))\n    if [ \"${#lengths[@]}\" -eq 0 ]; then\n        sorted=()\n\
    \    else\n        sorted=(\"${numbers[@]}\")\n    fi\n    for i in \"${!sorted[@]}\"\
    ; do\n        if [[ $i -ge 1 ]]; then continue; fi\n        sorted[i]=$(echo \"\
    ${sorted[i]}\"|sed \"s/^${i}//;s/^0//;s/ //g;s/^1/$(by_string_for_length $lengths)/;s/^0$//;s/\
    \ 0$//\")\n    done\n    IFS=$'\\n'\n    echo \"${sorted[@]}\"", "    local IFS=\
    \ read -r -d '' -a array <<<\"$1\"\n    local i\n\n    if [ -z \"${array[0]}\"\
    \ ]; then\n        return 0\n    fi\n    IFS=' '\n    for ((i = 0; i < ${#array[@]};\
    \ i++)); do\n        if ((i < 9 && ${array[i]} <= 9 && ${array[i]} >= 1)); then\n\
    \            array[$i]=\"One\"\n        elif ((i < 99 && ${array[i]} <= 99 &&\
    \ ${array[i]} >= 10)); then\n            array[$i]=\"Two\"\n        elif ((i <\
    \ 999 && ${array[i]} <= 999 && ${array[i]} >= 100)); then\n            array[$i]=\"\
    Three\"\n        elif ((i < 9999 && ${array[i]} <= 9999 && ${array[i]} >= 1000));\
    \ then\n            array[$i]=\"Four\"\n        elif ((i < 99999 && ${array[i]}\
    \ <= 99999 && ${array[i]} >= 10000)); then\n            array[$i]=\"Five\"\n \
    \       elif ((i < 999999 && ${array[i]} <= 999999 && ${array[i]} >= 100000));\
    \ then\n            array[$i]=\"Six\"\n        elif ((i < 9999999 && ${array[i]}\
    \ <= 9999999 && ${array[i]} >= 1000000)); then\n            array[$i]=\"Seven\"\
    \n        elif ((i < 99999999 && ${array[i]} <= 99999999 && ${array[i]} >= 10000000));\
    \ then\n            array[$i]=\"Eight\"\n        elif ((i < 9999999999 && ${array[i]}\
    \ <= 9999999999 && ${array[i]} >= 100000000)); then\n            array[$i]=\"\
    Nine\"\n        else\n            echo \"${array[*]}\" >&2\n            echo \"\
    Only numbers 1 to 9999 are accepted, array is ${array[*]}\"\n        fi\n    done\n\
    \    IFS=$'\\n'\n    echo \"${array[*]}\"", "    local array=$1\n\n    local names=(\n\
    \        \"One\"\n        \"Two\"\n        \"Three\"\n        \"Four\"\n     \
    \   \"Five\"\n        \"Six\"\n        \"Seven\"\n        \"Eight\"\n        \"\
    Nine\"\n    )\n    local lengths=()\n    for (( i=0; i<${#array[@]}; i++ )); do\n\
    \        local length=${array[$i]}\n        if (( length>0 && length<9 )); then\n\
    \            lengths+=(\"${length}\")\n        fi\n    done\n\n    local length=${#lengths[@]}\n\
    \    if [ $length -gt 0 ]; then\n        for (( i=0; i<$length; i++ )); do\n \
    \           local index=${i}\n            local name=${names[$index]} \n     \
    \       local tmp=${array[$index]} \n            for (( j=i+1; j<$length; j++\
    \ )); do\n                tmp=${tmp} ${names[j]}\n            done\n         \
    \   array[$i]=${tmp}\n        done\n    fi\n    echo -n \"${array[@]}\"", "\t\
    local -n _list=\"$1\"\n\tlocal size=0\n\tlocal -a _list_result\n\t_list_result=()\n\
    \tIFS=$'\\t' read -r -d '' -a _list <<<\"$_list\"\n\tfor _item in \"${_list[@]}\"\
    ; do\n\t\t((size++))\n\t\tif (( size > 9 )); then\n\t\t\tIFS=$'\\t' read -r -d\
    \ '' -a _list_result <<<\"${_list_result[@]}\" <<<\"${_item}\"\n\t\t\t_list_result=()\n\
    \t\t\t((size--))\n\t\telse\n\t\t\t_list_result+=(\"\\\"${_item#* }\\\"\" )\n\t\
    \tfi\n\tdone\n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"${_list_result[@]}\"\
    \n\tIFS=$' ' _list_result=(${_list_result[@]})\n\tIFS=$'\\t' read -r -d '' -a\
    \ _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result\
    \ <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"\
    ${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"${_list_result[@]}\"\
    \n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\\
    t' read -r -d '' -a _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read\
    \ -r -d '' -a _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d\
    \ '' -a _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a\
    \ _list_result <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result\
    \ <<<\"${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"\
    ${_list_result[@]}\"\n\tIFS=$'\\t' read -r -d '' -a _list_result <<<\"${_list_result[@",
  "    if [[ \"$#\" -eq 0 ]]; then\n        echo \"[]\"\n        return\n    fi\n\n\
    \    local arr=\"$(IFS=\" \" ; echo \"$1\")\"\n    echo \"$arr\" | sort -R | sed\
    \ -e 's/[^a-zA-Z]//g' | sed -e 's/^\"//' -e 's/\"$//'", "\tlocal arr=()\n\tlocal\
    \ str\n\tlocal i\n\tlocal j\n\tlocal len\n\tlocal num\n\tlocal t\n\tlocal tnum\n\
    \tlocal s\n\tlocal c\n\tlocal slen\n\tlocal snum\n\tlocal sname\n\tlocal sfirst\n\
    \tlocal sl\n\tlocal name\n\tlocal first\n\n\tfor ((i = 0; i < ${#1}; i++)); do\n\
    \t\tlocal c=$(echo \"${1:$i}\" | cut -d ' ' -f 1)\n\t\tarr=( \"${arr[@]}\" \"\
    $c\" )\n\tdone\n\n\tif [[ ${#arr[@]} -eq 0 ]]; then\n\t\tarr=()\n\tfi\n\n\twhile\
    \ read -r str; do\n\t\tnum=$(echo \"$str\" | cut -d ' ' -f 1)\n\t\ttnum=$(echo\
    \ \"$str\" | cut -d ' ' -f 2)\n\t\tsnum=$(echo \"$str\" | cut -d ' ' -f 3)\n\t\
    \tname=$(echo \"$str\" | cut -d ' ' -f 4)\n\t\tfirst=$(echo \"$str\" | cut -d\
    \ ' ' -f 5)\n\t\tlen=\"${#num}\"\n\t\tif [[ $num -gt 0 ]]; then\n\t\t\tj=0\n\t\
    \t\tfor ((j = 0; j < len; j++)); do\n\t\t\t\tif ((num[j] == 0)); then\n\t\t\t\t\
    \tarr=( \"${arr[@]}\" \"$name\" )\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\t\t\t\t((num[j]--))\n\
    \t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone <<< \"$1\"\n\n\tarr=( \"${arr[@]}\" \"\
    $name\" )\n\tlocal sfirst=$(echo \"${arr[0]}\" | cut -d '\"' -f 2)\n\tlocal sl=\"\
    ${#arr[@]}\"\n\tsname=$(echo \"$first\")\n\tif [[ $sfirst -eq 0 ]]; then\n\t\t\
    arr=()\n\tfi\n\tfor ((i = 1; i < sl; i++)); do\n\t\tlocal c=\"${arr[$i]}\"\n\t\
    \tif [[ \"$c\" == *\"\\\"$sname\\\"\"* ]]; then\n\t\t\tarr[$i]=\"${c#*\\\"}\"\n\
    \t\telse\n\t\t\tarr[$i]=$sname\n\t\tfi\n\tdone\n\n\twhile (( ${#arr[@]} > 0 ));\
    \ do\n\t\tread -r str; do\n\t\t\tsname=$(echo \"$str\" | cut -d ' ' -f 1)\n\t\t\
    \ttnum=$(echo \"$str\" | cut -d ' ' -f 2)\n\t\t\tsnum=$(echo \"$str\" | cut -d\
    \ ' ' -f 3)\n\t\t\tname=$(echo \"$str\" | cut -d ' ' -f ", "    local -a nums=(\"\
    ${1//\\\"/}\")\n    local -a out\n    local -a keys\n    local i j k\n    local\
    \ -a max\n    local -a min\n    max=-1\n    min=9\n    while ((${#nums[@]}>0));\
    \ do\n        if ((${#nums[@]} > max)); then\n            max=${#nums[@]}\n  \
    \      fi\n        if ((${#nums[@]} < min)); then\n            min=${#nums[@]}\n\
    \        fi\n    done\n    max=$((max + 1))\n    min=$(expr ${min} - 1)\n    out=()\n\
    \    keys=()\n    keys=(\"One\" \"Two\" \"Three\" \"Four\" \"Five\" \"Six\" \"\
    Seven\" \"Eight\" \"Nine\")\n    for ((i=1; i <= min; i++)) ; do\n        for\
    \ ((j=0; j < ((max - i)); j++)); do\n            out+=($((i * 10 + j))) #\"${keys[${nums[(${i}\
    \ * 10 + j)}]}\"\n        done\n    done\n    echo \"${out[@]}\"", "  local arr=$1\n\
    \  local num=${#arr[@]}\n  local str=\n  local result=()\n  local i=\n  local\
    \ j=\n  local name=\n\n  if [ \"$num\" -lt 1 ]; then\n    return 0\n  fi\n\n \
    \ # Get rid of the spaces\n  arr=(${arr[@]/#/ })\n\n  # Split into individual\
    \ numbers\n  for i in $(seq 0 $((num - 1))); do\n    j=$(printf \"%02d\" ${arr[$i]})\n\
    \    name=${str:-\"$name\"}\n    arr[$i]=${arr[$i]#0} # Drop the leading zero\n\
    \    arr[$i]=\"${name#\"$j\"}\"\n    str=$j\n  done\n\n  # Reverse the array\n\
    \  for i in $(seq 0 $((num - 1))); do\n    arr[$i]=${arr[$i]#0} # Drop the leading\
    \ zero\n    result+=( \"${arr[$i]}\" )\n  done\n\n  # Return array of strings\n\
    \  printf '%s\\n' \"${result[@]}\"", "  if [[ -z \"$1\" ]]; then\n    return 0\n\
    \  fi\n  IFS=' ' read -r -a array <<< \"$1\"\n  local -n max=\"${array[0]}\"\n\
    \  local -n min=\"${max}\"\n  local -n digit=\"${max}\"\n  local -n index=\"${#array[@]}\"\
    \n  local -n length=\"${#array[@]}\"\n  for (( index = 1; index < length; index++\
    \ )); do\n    digit=\"${max}\"\n    for (( i = 1; i <= 9; i++ )); do\n      if\
    \ [[ ${array[index]} -gt \"${max}\" ]]; then\n        digit=\"$i\"\n        max=\"\
    ${array[index]}\"\n      elif [[ ${array[index]} -lt \"${min}\" ]]; then\n   \
    \     digit=\"$i\"\n        min=\"${array[index]}\"\n      fi\n    done\n    array[index]=\"\
    ${digit}\"\n  done\n  printf -v ret '%s' \"${array[@]}\"\n  printf -v ret \"'%s'\"\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n  printf -v ret '[%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%%%%s]' \"${ret[@]}\"\n  printf -v ret '[%%%%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n  printf -v ret '[%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%%s]' \"${ret[@]}\"\n  printf -v ret '[%%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n  printf -v ret '[%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n  printf -v ret '[%%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%%s]' \"${ret[@]}\"\n  printf -v ret '[%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n  printf -v ret '[%%%%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%%%%s]' \"${ret[@]}\"\n  printf -v ret '[%s]'\
    \ \"${ret[@]}\"\n  printf -v ret '[%s]' \"${ret[@]}\"\n", "  local array=\"$1\"\
    \n  local length\n  local numbers\n  local tmp\n\n  numbers=( $(echo $array |\
    \ sed \"s/^ *//g\" | tr -s ' ' | tr '\\n' ' ') )\n\n  # sort and reverse the array\n\
    \  length=${#numbers[@]}\n  length=${#numbers[@]}\n  for ((i = 0; i < length;\
    \ i++)); do\n    ((j = i + 1))\n    if ((numbers[$i] < numbers[$j])); then\n \
    \     tmp=${numbers[$i]}\n      numbers[$i]=${numbers[$j]}\n      numbers[$j]=${tmp}\n\
    \    fi\n  done\n  # replace each number by its corresponding name from \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    \n  for ((i = 0; i < length; i++)); do\n    numbers[$i]=\"${One[$i]}\"\n  done\n\
    \  # return the result as a space-separated list\n  echo \"${numbers[*]}\"", " \
    \   local IFS=,\n    local -r -a ary\n    IFS=$'\\n'\n    ary=($*)\n    local\
    \ j=0\n    for (( i=1; i<=9; i++ )); do\n        local -a tmp\n        tmp=()\n\
    \        for (( j=0; j<${#ary[@]}; j++ )); do\n            tmp+=( \"${ary[j]}\"\
    \ )\n        done\n        case \"${tmp[1]}\" in\n            ${i}* ) ary[j]=${i};\
    \ break;;\n        esac\n    done\n    printf '\"%s\"\\n' \"${ary[@]}\"", "  \
    \  local -n arr=$1\n    local tmp=${arr[0]}\n    local i=1\n    local length\n\
    \    for length in \"${arr[@]:1}\"; do\n        if (( ${#length} > 0 )) && [[\
    \ $length == [0-9] ]]; then\n            tmp=${tmp// /\"${by_length_digits_name[i]}\"\
    }\n            ((++i))\n        fi\n    done\n    echo \"$tmp\"", "    if [[ -z\
    \ \"$1\" ]]; then\n        echo \"empty array\"\n        return\n    fi\n\n  \
    \  local array name\n    array=$1\n    name=$(IFS=$'\\n'; echo \"${array[@]}\"\
    \ | sort -n -r | sed 's/^[ ]*//;s/ *$//;s/\"One\"/Eight/g;s/\"Two\"/Six/g;s/\"\
    Three\"/Four/g;s/\"Four\"/Three/g;s/\"Five\"/Two/g;s/\"Six\"/One/g;s/\"Seven\"\
    /Five/g;s/\"Eight\"/Four/g;s/\"Nine\"/Three/g;s/\"Ten\"/Two/g;s/\"Eleven\"/One/g;s/\"\
    Twelve\"/Twelve/g;s/\"Thirteen\"/Thirteen/g;s/\"Fourteen\"/Fourteen/g;s/\"Fifteen\"\
    /Fifteen/g;s/\"Sixteen\"/Sixteen/g;s/\"Seventeen\"/Seventeen/g;s/\"Eighteen\"\
    /Eighteen/g;s/\"Nineteen\"/Nineteen/g;s/\"Twenty\"/Twenty/g;s/\"Twenty-one\"/Twenty-one/g;s/\"\
    Twenty-two\"/Twenty-two/g;s/\"Twenty-three\"/Twenty-three/g;s/\"Twenty-four\"\
    /Twenty-four/g;s/\"Twenty-five\"/Twenty-five/g;s/\"Twenty-six\"/Twenty-six/g;s/\"\
    Twenty-seven\"/Twenty-seven/g;s/\"Twenty-eight\"/Twenty-eight/g;s/\"Twenty-nine\"\
    /Twenty-nine/g;s/\"Thirty\"/ Thirty/g;s/\"Thirty-one\"/Thirty-one/g;s/\"Thirty-two\"\
    /Thirty-two/g;s/\"Thirty-three\"/Thirty-three/g;s/\"Thirty-four\"/Thirty-four/g;s/\"\
    Thirty-five\"/Thirty-five/g;s/\"Thirty-six\"/Thirty-six/g;s/\"Thirty-seven\"/Thirty-seven/g;s/\"\
    Thirty-eight\"/Thirty-eight/g;s/\"Thirty-nine\"/Thirty-nine/g;s/\"Forty\"/ Forty/g;s/\"\
    For", "\tlocal -n arr=\"$1\"\n\tlocal i j k\n\tlocal -a result=()\n\tfor (( i=0;\
    \ i < ${#arr[@]}; i++ )); do\n\t\tlocal arr2=\"${arr[i]}\"\n\t\tif [[ -n \"$arr2\"\
    \ ]] && [[ \"$arr2\" =~ ^[0-9]+$ ]]; then\n\t\t\tarr2=\"${arr2#?}\"\n\t\t\tarr2=\"\
    ${arr2%?}\"\n\t\t\tlocal -n val=\"$(by_number \"$arr2\")\"\n\t\t\tlocal -n max=\"\
    $(by_max \"$arr2\")\"\n\t\t\tif [[ ! \"$val\" ]]; then\n\t\t\t\techo \"'${arr2#?}'\
    \ is not a number!\"\n\t\t\t\tcontinue\n\t\t\tfi\n\t\t\techo \"$val\"\n\t\t\t\
    result+=(\"$val\")\n\t\telif [[ -z \"$arr2\" ]]; then\n\t\t\techo \"'$arr2' is\
    \ an empty string!\"\n\t\telse\n\t\t\techo \"'$arr2' is neither a number nor a\
    \ string\"\n\t\tfi\n\tdone\n\tprintf -v a '\\%q ' \"${result[@]}\"\n\techo \"\
    ${a[@]}\"", "    local -a arr=($1)\n    local -i arrlen=0\n    local i lastindex\
    \ name count\n    local tmp tmplen\n    tmp=$(printf -- \"%d \" \"${arr[@]}\"\
    )\n    arrlen=${#tmp}\n    if [ $arrlen -gt 0 ]; then\n        lastindex=${arrlen}\n\
    \        count=${arrlen}\n        local j=0\n        local maxi\n        while\
    \ [ $j -le $lastindex ]; do\n            if (( $count > 1 )); then\n         \
    \       local max\n                max=\"${arr[$j]}\"\n                (( maxi\
    \ = j ))\n                while [ $j -lt $maxi ]; do\n                    if [\
    \ \"$max\" == \"${arr[$j]}\" ]; then\n                        max=\"${arr[$j+1]}\"\
    \n                    fi\n                    (( j++ ))\n                done\n\
    \            else\n                max=\"${arr[$j]}\"\n            fi\n      \
    \      (( count-- ))\n            arr[$j]=\"\\\"$max\\\"\"\n        done\n   \
    \     arrlen=${#arr[@]}\n        while [ $i -le $arrlen ]; do\n            tmplen=${#arr[$i]}\n\
    \            if [ $tmplen -gt 0 ]; then\n                arr[$i]=\"\\\"${arr[$i]/%/One}\\\
    \"\"\n            else\n                arr[$i]=\"\\\"${arr[$i]}\\\"\"\n     \
    \       fi\n            (( i++ ))\n        done\n        arr=(${arr[@]/#/\"${arr[0]}\"\
    })\n    fi\n    echo \"${arr[@]}\"", "    local IFS=\" \"\n    local x\n    local\
    \ length\n\n    IFS=$'\\n' x=($1)\n\n    local -a sorted=()\n\n    for ((length=0;\
    \ length<${#x[@]}; length++)); do\n        local x\n        for ((i=0; i<${#x[@]};\
    \ i++)); do\n            case \"${x[$i]}\" in\n                \"1\") sorted+=(one\
    \ two)\n                        ;;\n                \"2\") sorted+=(two three)\n\
    \                        ;;\n                \"3\") sorted+=(three four)\n   \
    \                     ;;\n                \"4\") sorted+=(four five)\n       \
    \                 ;;\n                \"5\") sorted+=(five six)\n            \
    \            ;;\n                \"6\") sorted+=(six seven)\n                \
    \        ;;\n                \"7\") sorted+=(seven eight)\n                  \
    \      ;;\n                \"8\") sorted+=(eight nine)\n                     \
    \   ;;\n                \"9\") sorted+=(nine one)\n                        ;;\n\
    \                *) sorted+=(${x[$i]})\n            fi\n        done\n    done\n\
    \n    local -a reversed=()\n    for ((length=${#sorted[@]}; length>0; length--));\
    \ do\n        reversed+=(${sorted[length-1]})\n    done\n\n    local -a replaced=()\n\
    \    for ((length=${#reversed[@]}; length>0; length--)); do\n        replaced+=(${reversed[$((${#reversed[@]}\
    \ - ${length} ))]})\n    done\n\n    printf '%s\\n' \"${replaced[@]}\"", "   \
    \ local -n items=$1\n    local len\n    local line\n    local i\n    local k\n\
    \    local name\n    local c\n    local len\n    local s\n    local arr\n\n  \
    \  arr=()\n    items=( ${items//,/ } )\n\n    for (( i=1; i<${#items[*]}; i++\
    \ )); do\n        len=${#items[$i]}\n        if (( len < 8 )); then\n        \
    \    arr+=( ${items[$i]} )\n        fi\n    done\n\n    arr=($(sort -n <<<\"${arr[*]}\"\
    \ | tr -d '\\n'))\n\n    for (( i=0; i<${#arr[@]}; i++ )); do\n        len=${#arr[$i]}\n\
    \        if (( len < 8 )); then\n            name=$( echo \"${arr[$i]}\" | sed\
    \ 's/^0//g')\n            s=0\n            k=10\n            while (( k<10 ));\
    \ do\n                c=$(echo \"${arr[$i]}\" | sed 's/^0//g')\n             \
    \   if [ \"$c\" == \"$k\" ]; then\n                    name=$( echo \"${arr[$i]}\"\
    \ | sed 's/^0//g')\n                    ((s++))\n                else\n      \
    \              name=$( echo \"$name\" | sed \"s/${c}/${k}/g\" )\n            \
    \        ((k++))\n                fi\n            done\n            name=$( echo\
    \ \"$name\" | sed \"s/${c}/${k}/g\" )\n            arr[$i]=$( echo \"$name\" )\n\
    \        fi\n    done\n\n    for (( i=1; i<${#arr[@]}; i++ )); do\n        arr[$i]=\"\
    '$( echo \"${arr[$i]}\" | sed \"s/'/''/g\" )'\"\n    done\n\n    echo \"${arr[@]}\"",
  "  local array=\"$1\"\n  # If array is empty or has strange number ignore it\n \
    \ [[ -z \"${array}\" ]] && return 1\n  # Remove all \"\n  array=\"${array//\\\"\
    }\"\n  # Remove all leading spaces\n  array=\"${array#* }\"\n  IFS=\" \" read\
    \ -r -a array <<<\"$array\"\n\n  # If the integer is greater than 9, swap with\
    \ the next integer\n  for i in \"${!array[@]}\"; do\n    (( array[i] = (( array[i]\
    \ > 9 )) )) || break\n  done\n\n  mapfile -t array < <(printf '%s\\n' \"${array[@]}\"\
    )\n  printf '[%s]\\n' \"${array[*]}\"", "    local nums=${1//[[:space:]]/}\n \
    \   local str=\n    local arr=()\n    for num in $nums; do\n        arr+=($num)\n\
    \    done\n    if [ -z \"$nums\" ]; then\n        return $arr\n    fi\n    for\
    \ (( i=0; i<${#arr[@]}-1; i++ )); do\n        if [ $(( arr[i]+1 )) -le 9 ]; then\n\
    \            str+=$(( arr[i]+1 )) \"\\\"${arr[i]}\\\"\"\n        else\n      \
    \      str+=$(( arr[i]+1 )) \"\\\"${arr[i]}-9\\\"\"\n        fi\n    done\n  \
    \  echo -n $str", "    local -n arr=$1\n\n    if [ \"${#arr}\" -eq 0 ]\n    then\n\
    \        return $([]);\n    elif [ \"${#arr}\" -eq 1 ]\n    then\n        local\
    \ -n arr2=$arr\n        local -n out=$(by_digit \"${arr2[0]}\")\n        arr2=$(echo\
    \ $arr2 | sed 's/ //g' | sort -n)\n        local -n out2=$(by_length \"${arr2}\"\
    )\n        out=$(echo $out $out2)\n        arr=${arr2[0]}\n    else\n        local\
    \ -n arr2=$arr\n        local -n out=$(by_length \"${arr2[0]}\" \"${arr2[@]:1}\"\
    )\n        arr2=$(echo $arr2 | sed 's/ //g' | sort -n)\n        local -n out2=$(by_length\
    \ \"${arr2[@]:1}\")\n        out=$(echo $out $out2)\n        arr=$(echo $arr2[0])\n\
    \    fi\n\n    echo \"$out\"", "  local -n arr=$1\n  echo \"${arr[@]}\"\n  local\
    \ -n arr2=\"$( sort -g <<<\"${arr[@]}\" )\"\n  echo \"${arr2[@]}\"\n  echo \"\
    ${arr2[@]/#/One,Two,Three,Four,Five,Six,Seven,Eight,Nine}\"", "    local -r input=\"\
    ${1}\"; shift\n\n    local -r output=($(echo \"${input}\" | awk '{for(i=1;i<=NF;i++)\
    \ if ($i < 10) { print $i; exit;}}'))\n    if [[ -z \"${output[*]}\" ]]; then\n\
    \        echo \"[]\"\n        return\n    fi\n\n    local -r output_length=$(echo\
    \ \"${output[*]}\" | wc -l)\n    if [[ \"${output_length}\" == \"${#output[*]}\"\
    \ ]]; then\n        echo \"${output[*]}\"\n        return\n    fi\n    IFS=$'\\\
    n' read -r -a names <<<\"$(sort -n <<<\"${output[*]}\")\"\n    IFS=$' ' read -r\
    \ -a output <<< \"${names[@]}\"\n    IFS=$'\\n' read -r -a output_names <<< \"\
    ${output[*]}\"\n\n    if [[ \"${output_length}\" != \"${#output_names[@]}\" ]];\
    \ then\n        echo \"${output[*]}\"\n        return\n    fi\n    IFS=$'\\n'\
    \ read -r -a names_as_strings <<< \"${output_names[@]}\"\n    IFS=$' ' read -r\
    \ -a output_as_strings <<< \"${output[@]}\"\n    IFS=$'\\n' read -r -a output_as_strings_sorted\
    \ <<< \"${output_as_strings[@]}\"\n    IFS=$'\\n' read -r -a output_as_strings_sorted_reversed\
    \ <<< \"${output_as_strings_sorted[@]}\"\n    IFS=$' ' read -r -a output_as_strings_sorted_reversed_names\
    \ <<< \"${output_as_strings_sorted_reversed[@]}\"\n    IFS=$'\\n' read -r -a output_as_strings_sorted_reversed_names_sorted\
    \ <<< \"${output_as_strings_sorted_reversed_names[@]}\"\n\n    local -r output\n\
    \    output=$(\n        printf '%s\\0' \"${output_as_strings_sorted_reversed_names_sorted[@]}\"\
    \n    )\n    echo \"${output}\"", "    local arr=\"$1\"\n    local i=0\n    local\
    \ -a names=( )\n    local -a new=( )\n    while IFS= read -r line; do\n      \
    \  names[i++]=\"$line\"\n    done < <(sort -n \"$arr\")\n    for name in \"${names[@]:$((${#names[*]}\
    \ - 1))}\"; do\n        (( i < 9 )) && new+=(\"$name\" || \"$name\")\n    done\n\
    \    IFS= read -r line; echo \"$line\"", "    local array=\"$1\"\n    if [ -z\
    \ \"$array\" -o -z \"$array[0]\" ]; then\n        echo \"\"\n        return\n\
    \    fi\n    local element\n    local result\n    local i\n    local j\n    local\
    \ length\n    local count\n    local start\n    local end\n    local last\n  \
    \  local prev\n    local index\n    local array2\n    local name\n    local char\n\
    \    local tmp\n    local value\n    length=${#array[@]}\n    array2=()\n    prev=0\n\
    \    for i in $(seq 0 \"$((length-1)\")); do\n        element=${array[$i]}\n \
    \       if [ $((i-1)) -eq \"$prev\" -a \"$i\" -eq \"$((length-1))\" ]; then\n\
    \            array2=$array2\n        else\n            array2=(\"${array2[@]}\"\
    \ \"$element\")\n        fi\n        prev=$i\n    done\n    index=0\n    while\
    \ [ $index -lt \"$length\" ]; do\n        element=${array2[$index]}\n        start=$(echo\
    \ $element | cut -d\" \" -f1)\n        end=$(echo $element | cut -d\" \" -f2)\n\
    \        count=$(echo $element | cut -d\" \" -f3)\n        name=$(cat <<EOF\n\
    One\nTwo\nThree\nFour\nFive\nSix\nSeven\nEight\nNine\nEOF\n        )\n       \
    \ if [ \"$count\" -eq 1 ]; then\n            array2[$index]=\"\\\"$name\\\"\"\n\
    \        elif [ \"$count\" -ge 2 ] && [ \"$count\" -le 9 ]; then\n           \
    \ array2[$index]=\"\\\"$name\\\"\"\n        elif [ \"$count\" -eq 10 ]; then\n\
    \            array2[$index]=\"\\\"$name\\\"\"\n        fi\n        index=$((index+1))\n\
    \    done\n    array2=\"$array2[@]\"\n    result=()\n    for element in \"${array2[@]}\"\
    ; do\n        result+=($element)\n    done\n    echo \"${result[@]}\"", "    #\
    \ $1 is space-separated list\n    local -a num=( ${1//[[:blank:]]/ } )\n    local\
    \ -a len=( \"${#num[@]}\" )\n    local -a num=( \"${num[@]:1}\" )\n    local -i\
    \ j=0\n    local -i end=0\n    local -a result=()\n\n    while [ $j -le $len ];\
    \ do\n        if [ $j -eq 0 ]; then\n            end=$(expr index \"$num\" 1)\n\
    \        fi\n        if [ $j -gt $end ]; then\n            end=$j\n        fi\n\
    \        if [ $j -eq $end ]; then\n            result+=( \"\\\"${num[$j]}\\\"\"\
    \ ) # $1 is a space-separated list\n        else\n            result+=( \"\\\"\
    ${num[$j]}\\\" \" )\n        fi\n        j=$(( j + 1 ))\n    done\n    echo ${result[@]}",
  "    local numbers=$1\n    local names=\"${numbers// /|}\"\n    local i=0\n    while\
    \ [[ \"$i\" -lt \"${#numbers}\" ]]; do\n        if [[ \"${numbers[$i]}\" -ge 1\
    \ -a \"${numbers[$i]}\" -le 9 ]]; then\n            numbers[$i]=\"\\\"${names[${numbers[$i]}]}\\\
    \"\"\n        fi\n        i=$((i+1))\n    done\n    echo \"${numbers[*]}\"", " \
    \ local nl i\n  read -a array <<< \"$1\"\n  for ((i = 0; i < ${#array[@]}; ++i));\
    \ do\n    nl=\"$(printf \"%03d\" ${array[$i]})\"\n    if [[ $nl -ge 9 ]]; then\n\
    \      array[$i]=\"Five\"\n      array[$i]=\"Four\"\n      array[$i]=\"Three\"\
    \n      array[$i]=\"Two\"\n      array[$i]=\"Two\"\n      array[$i]=\"One\"\n\
    \      array[$i]=\"One\"\n    elif [[ $nl -ge 7 ]]; then\n      array[$i]=\"Six\"\
    \n      array[$i]=\"Seven\"\n      array[$i]=\"Eight\"\n      array[$i]=\"Nine\"\
    \n      array[$i]=\"Nine\"\n      array[$i]=\"Nine\"\n      array[$i]=\"Nine\"\
    \n      array[$i]=\"Nine\"\n      array[$i]=\"Nine\"\n      array[$i]=\"Nine\"\
    \n    elif [[ $nl -ge 5 ]]; then\n      array[$i]=\"Four\"\n      array[$i]=\"\
    Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"\
    Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"\
    Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"Five\"\n      array[$i]=\"\
    Five\"\n    fi\n  done\n  printf \"%s\" \"${array[@]}\"", "  local -a arr\n  arr=(\
    \ $(echo -n \"$1\") )\n  local -a output\n  output=($((\n    local IFS=\",\";\
    \ echo \"${arr[@]}\" | awk -F\" \" '{\n      for (i=1; i<=NF; i++) print $i\n\
    \    }' | sort -n | sed \"s/ /\\\"/g;s/$/\\\"/g;s/,/\\\"$\\\"/g;s/\\\"//g;s/$/,/;s/\
    \ $//g\" | tr -d '\"'\n  )))\n  echo \"${output[@]}\"", "  local i j k name nums\n\
    \  IFS=\" \" read -r -a nums <<< \"$1\"\n  # remove all \"bad\" values\n  nums=(\"\
    ${nums[@]/#/}\")\n  # add \"one\" and \"two\"\n  nums+=(\"one\" \"two\")\n  #\
    \ sort the numbers\n  nums=(\"${nums[@]}\")\n  (( ${#nums[@]} > 1 )) && return\
    \ \"Invalid input.\"\n  # reverse the array\n  i=${#nums[@]}\n  (( ${#nums[@]}\
    \ > 0 )) && shift\n  j=${#nums[@]}\n  (( ${#nums[@]} > 0 )) && shift\n  (( ${#nums[@]}\
    \ > 0 )) && shift\n  (( ${#nums[@]} > 0 )) && shift\n  for ((k=0; k<j; k++));\
    \ do\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n\
    \    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    ((\
    \ ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]}\
    \ > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0\
    \ )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) &&\
    \ shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n\
    \    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    ((\
    \ ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]}\
    \ > 0 )) && shift\n    (( ${#nums[@]} > 0 )) && shift\n    (( ${#nums[@]} > 0\
    \ )) && shift\n    (( ${#nums[@]} > 0 ", "  local array=\"$1\"\n  shift\n  local\
    \ sorted\n  local reverse\n  local ret\n  # If there's nothing in the array, just\
    \ return an empty array\n  [[ $array ]] || return 0\n  # The array has at least\
    \ one element\n  ret=()\n  # Split the array into sorted and reverse sorted parts\n\
    \  sorted=$(IFS=' ' echo \"$array\" | sort -n)\n  reverse=$(IFS=' ' echo \"$array\"\
    \ | sort -R | tr '[:upper:]' '[:lower:]')\n  # For each item in the array and\
    \ each character in the string, replace it by the\n  # appropriate name\n  printf\
    \ -v ret '%s' \"${sorted}\" | while read item; do\n    # Strip whitespace\n  \
    \  item=\"${item#\"${item%%[![:space:]]*}\"}\"\n    # Replace all digits by \"\
    Nine\", \"Eight\", \"Seven\", etc.\n    item=\"${item//[0-9]/'Nine'\"\n    item=\"\
    ${item//[![:digit:]]/'Eight'\"\n    item=\"${item//[![:digit:]]/'Seven'\"\n  \
    \  item=\"${item//[![:digit:]]/'Six'\"\n    item=\"${item//[![:digit:]]/'Five'\"\
    \n    item=\"${item//[![:digit:]]/'Four'\"\n    item=\"${item//[![:digit:]]/'Three'\"\
    \n    item=\"${item//[![:digit:]]/'Two'\"\n    item=\"${item//[![:digit:]]/'One'\"\
    \n    echo \"$item\"\n  done\n  # Add the reverse sorted array to the end\n  ret+=$(IFS='\
    \ ' echo \"$reverse\")\n  echo \"${ret[@]}\"", "  local digits=( $1 )\n  local\
    \ length=0\n  local maxlength=0\n  local tmp\n  local new=()\n  while [ ${#digits[@]}\
    \ -gt 0 ]; do\n    length=${#digits[@]}\n    maxlength=${#new[@]}\n    length=$((\
    \ ${length} - 1 ))\n    length=${length:0:1}\n    for (( i = 0; i < ${length};\
    \ i++ )); do\n      tmp=${digits[$i]}\n      digits[$i]=$(printf \"%s\", ${tmp})\n\
    \    done\n    new+=( ${digits[@]} )\n    digits=( \"${new[@]:$(( ${#new[@]} -\
    \ 1 ))}\" )\n  done\n  if [ ${#digits[@]} -eq 0 ]; then\n    return 0\n  fi\n\
    \  local i=0\n  local last=()\n  while [ ${i} -lt ${#digits[@]} ]; do\n    local\
    \ last\n    if [ $(( ${i} % 2 )) -eq 0 ]; then\n      last+=( ${digits[$(( ${i}\
    \ / 2 ))] } )\n    else\n      last+=( ${digits[$(( ${i} / 2 )) + 1] } )\n   \
    \ fi\n    (( i++ ))\n  done\n  if [ ${#digits[@]} -eq ${#last[@]} ]; then\n  \
    \  last+=( ${digits[$(( ${#digits[@]} - 1 ))] } )\n  fi\n  for (( i = 1; i < ${#last[@]};\
    \ i++ )); do\n    echo \"${last[$i]}\"\n  done", "  local -r number=$1\n\n  #\
    \ Get an array of digits sorted by length\n  local -r sorted_digits=$(sort -n\
    \ <<<\"$(IFS=; echo \"$number\" | sed 's/ /, /g')\")\n\n  # Get the length of\
    \ the longest number\n  local -r max_length=${#number}\n\n  # Reverse the order\
    \ of the numbers\n  local -r reversed_numbers=$(IFS=; echo \"${sorted_digits[@]}\"\
    \ | xargs -0 rev | sed 's/ /, /g')\n\n  # Replace each digit by its name\n  local\
    \ -r number_string=\"\"\n  for ((i=0; i < max_length; i++)); do\n    local -r\
    \ digit=\"${reversed_numbers[i]}\"\n    local -r index=\"${i}\"\n    number_string+=\"\
    \\\"${sorted_digits[index]}\\\"\"\n  done\n\n  # Return an array of strings\n\
    \  printf \"%s\\n\" \"${number_string}\""]
stop_tokens:
- "\n}"
