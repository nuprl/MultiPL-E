name: HumanEval_53_add
language: sh
prompt: "#!/bin/bash\n# Add two numbers x and y\n# >>> $(add \"2\" \"3\")\n# \"5\"\
  \n# >>> $(add \"5\" \"7\")\n# \"12\"\n#\n# $1 is an integer\n# $2 is an integer\n\
  add() {\n"
tests: "}\n\ncandidate() {\n    add \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"0\" \"1\") = \"1\" ]]\n    [[ $(candidate \"1\" \"0\") = \"1\" ]]\n    [[ $(candidate\
  \ \"2\" \"3\") = \"5\" ]]\n    [[ $(candidate \"5\" \"7\") = \"12\" ]]\n    [[ $(candidate\
  \ \"7\" \"5\") = \"12\" ]]\n}\n\nrun_test"
completions: ["  local number1=$1\n  local number2=$2\n  echo \"$(($number1 + $number2))\"",
  '  echo "$(($1 + $2))"', "  local x=$1\n  local y=$2\n\n  if (( $x >  0)) ; then\n\
    \    let \"x = x + y\"\n  else\n    let \"y = y + x\"\n  fi\n  echo $y", "   \
    \ # Convert the integers to strings\n    local result=$(echo $1 | bc)\n    result=$((\
    \ $result + $2 ))\n    # Convert the result back into an integer\n    echo $result\
    \ | bc", "    local a=$1\n    local b=$2\n\n    # Handle zero\n    if [ $a -eq\
    \ 0 ]\n    then\n        echo \"0\"\n    elif [ $b -eq 0 ]\n    then\n       \
    \ echo \"0\"\n    else\n        echo $(($a + $b))\n    fi", "  echo $1\n  echo\
    \ $(expr $1 + $2)\n  echo $(expr $1 - $2)", '    echo "$(( $1 + $2 ))"', "   \
    \ if [[ \"$1\" == \"$2\" ]]; then\n        echo 0\n    elif [[ $(( $1 + $2 ))\
    \ -gt $(( $2 * $2 )) ]]; then\n        echo $(( $1 + $2 ))\n    else\n       \
    \ echo $(( $2 * $2 + $1 ))\n    fi", "    local x=$1\n    local y=$2\n    (( x\
    \ ))\n    (( y ))\n    [[ $x -eq 0 ]] && x=1 || x=$(( $x +1 ))\n    [[ $y -eq\
    \ 0 ]] && y=1 || y=$(( $y +1 ))\n    echo \"$(($x + $y))\"", "    local i=\"$1\"\
    \n    local j=\"$2\"\n    echo \"$(( i + j ))\"", "    local x y\n    x=${1:-$1}\n\
    \    y=${2:-$2}\n    echo $(( ${x} + ${y} ))", "\texpr \"$1\" \"$2\" + 0", " \
    \ (( $1 == 0 )) && return $2\n  (( $2 == 0 )) && return $1\n  (( $1 == $2 )) &&\
    \ return 0\n  (( $(add $1 $2) )); return $(( $1 + $2 ))", "  expr \"$1\" \"$2\"\
    \ : '\\(.*\\)$'", '  echo "$(($1 + $2))"', "  local a=$1 b=$2 c=$((a + b)) d=$((b\
    \ + c)) e=$((c + d))\n  printf \"%d\\n\" $((e)) | bc -l", "\tlocal x=$1; shift\n\
    \tlocal y=$1; shift\n\techo $(( $x + $y ))", "    [ $# -ne 2 ] && echo \"Usage:\
    \ add x y\" >&2 && return 1\n    local x=\"$1\"\n    local y=\"$2\"\n    echo\
    \ $(( x + y ))", "  # We don't want to return any error when the values aren't\
    \ valid, so check\n  # that we're not returning an error by simply running the\
    \ command\n\n  local x=$1 && shift\n  local y=$2 && shift\n  [[ $x -gt 0 ]] ||\
    \ return 1\n  [[ $y -gt 0 ]] || return 1\n  # Use + instead of + 2\n  echo $((\
    \ $x + $y ))", "    local _retval_ _result_ _command_\n    if [ \"${#}\" -ne 2\
    \ ]; then\n        _retval_='{\"error\": \"Wrong argument count\"}'\n        return\
    \ _retval_\n    fi\n    _result_=$(\n        echo -n \"${1+1}\"\n        echo\
    \ -n \"${2+1}\"\n    )\n    _command_=\"echo \\\"${_result_}\\\"\"\n    eval \"\
    ${_command_}\"", "    local n1=${1}; shift\n    local n2=${1}; shift\n    local\
    \ sum\n    if [ $n1 -gt $n2 ]; then\n        sum=$n1\n    else\n        sum=$n2\n\
    \    fi\n    while [ $n1 -lt $n2 ]; do\n        ((n1+=1))\n        sum=$((sum+n1))\n\
    \    done\n    echo \"$sum\"", "  local x=\"$1\"\n  local y=\"$2\"\n  printf \"\
    %d\" \"$(( x + y ))\"", "    local sum=\"$(($1 + $2))\"\n    if [ $sum -gt 0 ];\
    \ then\n        echo \"$sum\"\n    else\n        echo \"0\"\n    fi", "    local\
    \ arg1=\"$1\"\n    local arg2=\"$2\"\n    local ret=\"$(( $arg1 + $arg2 ))\"\n\
    \    printf '%s\\n' \"$ret\"", "    local -r a=$1; shift\n    local -r b=$1; shift\n\
    \    echo \"$(( $a + $b ))\"", "  local x\n  local y\n  x=$1\n  y=$2\n  echo $((x\
    \ + y))", "    (( $#2 != 0 && $#1 != 0 )) && echo \"Invalid Argument\" && exit\
    \ 1\n    test -z \"$3\" && echo \"$2 $1\" | bc", "    local i sum\n\n    i=$1\n\
    \    sum=$(( $1 + $2 ))\n\n    return $sum", "  local sum=0\n  for i in $@; do\n\
    \    (( sum += i ))\n  done\n  echo $sum", "    (( ${1#-} )) && return\n    [[\
    \ $2 = +([[:digit:]]) ]] || return\n    [[ $1 = +([[:digit:]]) ]] || return\n\
    \    IFS=\"-\" read -r x y <<< \"$(( ${1#-} + ${2#-} ))\"\n    echo \"$x$y\"",
  "  local var1=$1\n  local var2=$2\n  local sum=0\n  local i\n\n  echo \"$var1\"\n\
    \  echo \"$var2\"\n  for (( i=1; i<=$var1; i++ )); do\n    sum=$(( sum + $var2\
    \ ))\n  done\n  echo \"$sum\"", "  local n1 n2\n  read n1 n2 <<< \"$@\"\n  echo\
    \ $(( n1 + n2 ))", "    local a=$1\n    local b=$2\n    # Convert to a positive\
    \ integer\n    if [[ -z \"$a\" ]]; then\n        echo \"$b\"\n    elif [[ -z \"\
    $b\" ]]; then\n        echo \"$a\"\n    else\n        echo \"$(($a + $b))\"\n\
    \    fi", "    local x=\"$1\"\n    local y=\"$2\"\n\n    # check that both numbers\
    \ are integers\n    [ \"$x\" != \"$y\" ] && return 1\n\n    # check that both\
    \ numbers have the same sign\n    [[ \"$x\" != \"$y\" ]] && return 1\n\n    #\
    \ add the two numbers and return it\n    expr \"$x\" + \"$y\"", "    (($# > 2))\
    \ && echo \"Illegal number of arguments\"\n    echo $(( $1 + $2 ))", "    if [\
    \ $# != 2 ]; then\n        echo \"Usage: $(basename $0) <integer> <integer>\"\n\
    \        return 1\n    fi\n\n    local x=$1; shift\n    local y=$1; shift\n\n\
    \    echo \"$(( x + y ))\"", "    local a b\n    a=\"$1\"\n    b=\"$2\"\n    echo\
    \ $(( $a + $b ))", "  x=\"$1\"\n  y=\"$2\"\n  (( x + y ))", "   local num1=$1\n\
    \   local num2=$2\n   local sum=0\n   while [ \"$num1\" -gt 0 ] || [ \"$num2\"\
    \ -gt 0 ]; do\n      (( sum+=${num1}+${num2}))\n      (( num1--))\n      (( num2--))\n\
    \   done\n   echo $sum", "    if [ $1 -eq $2 ]; then\n        echo $1\n    else\n\
    \        echo $(( $1 + $2 ))\n    fi", "\tlocal x=\"$1\"\n\tlocal y=\"$2\"\n\t\
    (( (x + y) < 10 )) && echo \"$(( x + y ))\"", "    local sum=$(($1 + $2))\n  \
    \  printf '%s\\n' \"$sum\"", "\tlocal num1=$1\n\tlocal num2=$2\n\t\n\tif [ $num1\
    \ -lt $num2 ]; then\n\t\techo $(( $num1 + $num2 ))\n\telse\n\t\techo $(( $num1\
    \ - $num2 ))\n\tfi", "\tlet a=\"$1\"\n\tlet b=\"$2\"\n\n\t(( a + b ))", "    local\
    \ x=$1; shift\n    local y=$1; shift\n    echo $(( $x + $y ))", "    local i1\
    \ i2\n    i1=$1; i2=$2\n    [[ $i1 =~ ^[0-9]+$ ]] || { echo \"$1 is not a number\"\
    \ >&2; return 1; }\n    [[ $i2 =~ ^[0-9]+$ ]] || { echo \"$2 is not a number\"\
    \ >&2; return 1; }\n    echo \"$(($i1 + $i2))\"\n    return 0", "\tlocal sum=\"\
    $(($1 + $2))\"\n\techo \"$sum\"", "    local IFS=.\n    local x\n    local y\n\
    \    local result\n    read x y <<<\"$((${1%%[!0-9]*}+${2%%[!0-9]*}))\"\n    if\
    \ [ \"${x}\" -eq \"${y}\" ]; then\n        result=\"${x}\"\n    else\n       \
    \ result=\"${x}+${y}\"\n    fi\n    echo $result", "  # Make sure both arguments\
    \ are integers\n  test \"$1\" -eq \"$1\" || return 1\n  test \"$2\" -eq \"$2\"\
    \ || return 1\n  # Use bc to perform the operation\n  # This will be slower, but\
    \ it will catch errors more easily\n  echo \"$(($1 + $2))\"", '        echo $((
    $1 + $2 ))', "\techo \"$(($1 + $2))\"", "  local int1=$1\n  local int2=$2\n  #\
    \ Make sure we have the correct amount of arguments, otherwise return error\n\
    \  [ $# -eq 2 ] && [ \"$1\" -ge 0 ] && [ \"$1\" -le $(( $# - 1 )) ] || return\
    \ 1\n  # Make sure the first argument is an integer\n  [ $# -eq 1 ] && [ \"$1\"\
    \ -ge 0 ] || return 1\n  # Make sure the second argument is an integer\n  [ $#\
    \ -eq 2 ] && [ \"$2\" -ge 0 ] && [ \"$2\" -le $(( $# - 1 )) ] || return 1\n  #\
    \ Make sure we have the correct amount of arguments, otherwise return error\n\
    \  [ $# -eq 2 ] && [ \"$1\" -ge 0 ] || return 1\n  # Make sure the first argument\
    \ is an integer\n  [ $# -eq 1 ] && [ \"$1\" -ge 0 ] || return 1\n  # Make sure\
    \ the second argument is an integer\n  [ $# -eq 2 ] && [ \"$2\" -ge 0 ] && [ \"\
    $2\" -le $(( $# - 1 )) ] || return 1\n  # Convert the first argument to a string\n\
    \  local int1_str=`echo $int1`\n  # Convert the second argument to a string\n\
    \  local int2_str=`echo $int2`\n  # The sum of these two numbers is simply the\
    \ sum of their string representations\n  local sum=`echo \"$int1_str + $int2_str\"\
    \ | bc`\n  # Return the sum\n  echo $sum", "  local x=\"$1\"\n  local y=\"$2\"\
    \n  echo $(expr \"$x\" + \"$y\") | bc", "    local var1 var2\n    if [[ $# -lt\
    \ 2 ]]; then\n        echo \"Usage: $(basename $0) <number> <number>\" >&2\n \
    \       return 1\n    fi\n    local num1=$1\n    local num2=$2\n    var1=$((num1\
    \ + num2))\n    echo \"$var1\"", "  local x=\"$1\"\n  local y=\"$2\"\n\n  echo\
    \ $(($x + $y))", "        local num1=$1\n        local num2=$2\n        local\
    \ sum\n\n        sum=$((num1+num2))\n        echo $sum", "\tlocal number1=$1\n\
    \tlocal number2=$2\n\t(( number1 + number2 ))", "    local IFS= # Reset the Internal\
    \ Field Separator to nothing\n    printf -v $1 '%s\\n' \"$(( ${1#} + ${2#} ))\"",
  "  (( x=$1 ))\n  (( y=$2 ))\n  (( $#2 ))\n  (( $#1 ))\n\n  (( ret=$x ))\n  (( x--\
    \ ))\n\n  while (( y-- )) ; do\n    (( ret+=$x ))\n    (( x++ ))\n  done\n\n \
    \ echo \"$ret\"", '    echo "$(($1 + $2))"', "  (( sum += $1 ))\n  (( sum += $2\
    \ ))\n  echo $sum", "  x=$1\n  y=$2\n  sum=$(echo $((x+y)))\n  echo $(echo $sum)",
  "  (( $# < 2 )) && return -1\n  local x=\"$1\"\n  local y=\"$2\"\n  (( $# > 2 ))\
    \ && return -1\n  (( x > y )) && return -1\n  (( x < y )) && return -1\n  local\
    \ a=$(( x - y ))\n  echo $a", "\tlocal x=\"$1\"\n\tlocal y=\"$2\"\n\techo $(($x+$y))",
  '    expr $1 + $2', '    expr $1 + $2', "\t# If both arguments are integers, return\
    \ their sum\n\tif [[ $1 =~ \"^[0-9]+$\" && $2 =~ \"^[0-9]+$\" ]]; then\n\t\techo\
    \ \"$((${1##* }+${2##* }))\"\n\t# If the first argument is an integer, but the\
    \ second argument is not an integer, return the second argument\n\telif  [[ $1\
    \ =~ \"^[0-9]+$\" && $2 =~ \"^[^0-9]+$\" ]]; then\n\t\techo \"$2\"\n\t# If the\
    \ first argument is not an integer, but the second argument is an integer, return\
    \ the second argument\n\telif [[ $1 =~ \"^[^0-9]+$\" && $2 =~ \"^[0-9]+$\" ]];\
    \ then\n\t\techo \"$2\"\n\t# If neither of both arguments are integers, return\
    \ an error message\n\telse\n\t\techo \"Usage: add <first int> <second int>\"\n\
    \tfi", '  (( ${#1} > 0 && ${#2} > 0 )) && echo $(( ${1} + ${2} ))', "    local\
    \ x=\"$1\"\n    local y=\"$2\"\n    echo $(( $x + $y ))", "  local x=\"$1\"\n\
    \  local y=\"$2\"\n  echo $(( $(expr \"$x + $y\") ))", "  (( a = $1 + $2 ))\n\
    \  echo \"$a\"", "    local a b\n    a=$1\n    b=$2\n    echo \"$((a + b))\"",
  '  (( $1 == $2 )) && return $1 || return $2', "\tsum=$(( $1 + $2 ))\n\techo $sum",
  "  local x=\"$1\"\n  local y=\"$2\"\n  echo \"$(( x + y ))\"", "    local IFS=+\n\
    \    local a=$1\n    local b=$2\n    echo $(($a + $b))", '  echo $(( $1 + $2 ))',
  "    if [ $1 -lt $2 ]; then\n        echo $(($1 + $2))\n    elif [ $1 -gt $2 ];\
    \ then\n        echo $(($1 - $2))\n    elif [ $1 -eq $2 ]; then\n        echo\
    \ $(($1 + $2))\n    fi", "  if [[ \"$1\" =~ ^[0-9]+$ ]] || [[ \"$2\" =~ ^[0-9]+$\
    \ ]]; then\n    echo $(( $1 + $2 ))\n  else\n    echo \"add arguments must be\
    \ integers\"\n  fi", "  local sum\n  local i\n  local val\n  val=$(( $1 + $2 ))\n\
    \  sum=$(( $sum + $val ))\n  ((i++))\n  if [ \"$i\" -ge \"10\" ] && [ \"$i\" -le\
    \ \"20\" ] || [ \"$i\" -ge \"100\" ] && [ \"$i\" -le \"200\" ]; then\n    echo\
    \ \"$sum\"\n    return\n  fi\n  echo \"$sum\"\n  return", "\tlocal a=$1\n\tlocal\
    \ b=$2\n\techo \"$(($a + $b))\"", "    # $1 is the first number\n    # $2 is the\
    \ second number\n    # $3 is the sum of $1 and $2\n\n    # $1 is an integer\n\
    \    if [ -z \"$1\" ]; then\n        echo \"Error - first number must be an integer\"\
    \n        return 1\n    fi\n\n    # $2 is an integer\n    if [ -z \"$2\" ]; then\n\
    \        echo \"Error - second number must be an integer\"\n        return 1\n\
    \    fi\n\n    # $3 is the sum of the two numbers\n    # $4 = $1 + $2\n    # $5\
    \ = $3 + $4\n    # $6 = $5\n    if [ $# -lt 3 ]; then\n        echo \"Error -\
    \ must have 3 parameters\"\n        return 1\n    fi\n    let sum=$1 + $2\n  \
    \  let last=$3 + $4\n    let final=$5\n    echo $final", "  (( sum += $1 ))\n\
    \  (( sum += $2 ))\n  echo $sum", "    local x=\"$1\"\n    local y=\"$2\"\n  \
    \  echo $(($x + $y))", "  local num1=$1\n  local num2=$2\n  echo $(( $num1 + $num2\
    \ ))", "    local x=\"$1\"\n    local y=\"$2\"\n    echo $(( $x + $y ))", '    local
    sum=$(( ${1+x} + ${2+y} ))', "    local x=\"$1\"\n    local y=\"$2\"\n    echo\
    \ $(( x + y ))", "  if [ $# != 2 ]\n  then\n    return 1\n  fi\n  [ $1 -gt $2\
    \ ] && return 1 || return 0", "  awk -v x=\"$1\" -v y=\"$2\" '{print $1+$2}' <<<\
    \ \"$3\"", "\tdeclare -i x y sum\n\tx=$1\n\ty=$2\n\tsum=$((x+y))\n\techo \"$sum\"",
  "    local x=$1; shift\n    local y=$1; shift\n    echo \"$((x+y))\"", "  x=$1\n\
    \  y=$2\n  echo $(($x+$y))", "\tsum=$(($1 + $2));\n\techo $sum", '  printf "%s\n"
    "$(( ${1#-} + ${2#-} ))"', '    expr $1 + $2', '    echo $(( $(eval echo {$1}
    + ${2}) ))', "    local a b\n    a=$1\n    b=$2\n    echo `expr $a + $b`", " \
    \   if [ $1 -le $2 ]\n    then\n        echo $(($1 + $2))\n    else\n        echo\
    \ $(($1 - $2))\n    fi", "    local x=\"$1\"\n    local y=\"$2\"\n    echo \"\
    $((x+y))\"", "  local sum\n  local n1 n2\n  read n1 n2\n  sum=$((n1 + n2))\n \
    \ echo \"$sum\"", "    if [ $1 -lt $2 ]\n    then\n        echo $(( $1 + $2 ))\n\
    \    else\n        echo $(( $2 - $1 ))\n    fi", "    local first=\"$1\"\n   \
    \ local second=\"$2\"\n    echo $((first + second))", "\tlocal -r a=$1\n\tshift\n\
    \tlocal -r b=$1\n\tshift\n\techo $(($a+$b))", '  echo "$(($1$2))"', "\tlocal i\n\
    \ti=\"$1\"\n\t((i++))\n\ti=\"$i$2\"\n\t((i++))\n\techo \"$i\"", "    local x=\"\
    $1\"\n    local y=\"$2\"\n    [ \"$x\" -eq \"0\" ] && x=1 || x=$(( x - 1 ))\n\
    \    [ \"$y\" -eq \"0\" ] && y=1 || y=$(( y - 1 ))\n    echo $(($x + $y))", '    echo
    $(($1 + $2))', "   local x=\"$1\"\n   local y=\"$2\"\n   echo \"$(( $x + $y ))\"",
  "  printf '%s' \"$(($1 + $2))\"", "  if [[ -z \"$2\" ]]; then\n    echo \"Usage:\
    \ $0 <n> <m>\"\n    return 1\n  fi\n  echo \"$(( $1 + $2 ))\"", "\tlocal x=$1\n\
    \tlocal y=$2\n\techo $(( x + y ))", "\tlet result=$(($1+$2))\n\techo ${result}",
  "    local -i ret=\"$1\"\n    local -i a=$2\n    if (( ret < 0 )); then\n      \
    \  ret=\"$(( ret + a ))\"\n    else\n        ret=\"$(( a + ret ))\"\n    fi\n\
    \    return $ret", "  result=$(echo \"$1 + $2\" | bc)\n  echo $result", "  local\
    \ x=$1\n  local y=$2\n  echo $(( x + y ))", "    local x=\"$1\"\n    local y=\"\
    $2\"\n    echo $(expr \"$x\" + \"$y\") | bc -l > /dev/null", "\tlet $1 += $2",
  "  result=$(echo \"$1 + $2\" | bc)\n  echo \"$result\"", "    local IFS= # Hack\
    \ to make sure IFS is unset during eval below\n    local -n x=\"$1\"; shift\n\
    \    local -n y=\"$1\"; shift\n    local -n result\n    result=$(( x+y ))\n  \
    \  # Only return result if result is a non-zero integer\n    # Otherwise return\
    \ empty string\n    [ \"$result\" -eq \"$result\" ]", '  echo $(expr $1 + $2)',
  "    local result=$(expr $(expr $1) + $(expr $2))\n    echo -n $result", "    local\
    \ sum\n    sum=$(($1 + $2))\n    echo \"$sum\"", "  if [ $# -lt 2 ]; then\n  \
    \  echo \"Usage: $(basename ${0}) <integer> <integer>\"\n    return -1\n  fi\n\
    \  local num1=$1\n  local num2=$2\n  local num3=$(( num1 + num2 ))\n  echo $num3",
  "  # Use arithmetic expansion to avoid issues with unquoted + in argument expansion.\n\
    \  # Avoid issues with unquoted spaces (see example below)\n  eval echo \"$(($1\
    \ + $2))\"", "    local x=\"$1\" y=\"$2\"\n    echo \"$(( $x + $y ))\"", "\techo\
    \ \"$(( $1 + $2 ))\"", '    echo "$(($1 + $2))"', "  local x=\"$1\"\n  local y=\"\
    $2\"\n  echo $(( ${x} + ${y} ))", "    python -c \"\ntry:\n    import sys\n  \
    \  import math\n    x, y = sys.argv[1], sys.argv[2]\n    sum = int(x) + int(y)\n\
    except ValueError:\n    print('Usage: $(add 2 3)')\nelse:\n    print(sum)\n\"\
    \ \"$@\"", "    local x=\"$1\"\n    local y=\"$2\"\n    echo $(( $x + $y ))",
  "  # get arguments\n  (( $# < 2 )) && { echo \"Missing arguments\" && return 1;\
    \ }\n  x=$1\n  y=$2\n\n  # handle errors\n  if (( x != y )); then\n    echo \"\
    One of the numbers is not an integer\"\n    return 1\n  fi\n\n  echo $(( $x +\
    \ $y ))", "\techo \"$(($1 + $2))\"", "    local IFS=\"$1\"; shift\n    local IFS=\"\
    $1\"; shift\n    echo $(( $1 + $2 ))", "  if [[ -z \"$2\" ]]; then\n    echo \"\
    0\";\n  else\n    echo $(($1 + $2));\n  fi", '    echo "$(($1 + $2))"', "    local\
    \ IFS='+'\n    eval $1=$(( $1 + $2 ))", '  (( $1 + $2 ))', '    echo "$(($1 +
    $2))"', "  local val1=$1\n  local val2=$2\n  local sum=0\n  if [ \"$val1\" -gt\
    \ \"$val2\" ]; then\n    sum=$(( $val1 + $val2 ))\n  else\n    sum=$(( $val2 -\
    \ $val1 ))\n  fi\n  echo -n \"$sum\"", '    echo "$(($1+$2))"', "  (( $1 != $2\
    \ )) && printf '%s' \"$(($1 + $2))\"", "\tx=\"$1\"; y=\"$2\"; sum=\"$(( $x + $y\
    \ ))\"\n\tif [[ $sum -gt 100 ]] ; then\n\t\techo \"$sum is greater than 100\"\n\
    \telse\n\t\techo \"$sum is less than 100\"\n\tfi", "   local res\n   res=$(eval\
    \ echo \\${${1} \\} \\${${2} \\} \\${${3} \\} \\${${4} \\} \\${${5} \\} \\${${6}\
    \ \\} \\${${7} \\} \\${${8} \\} \\${${9} \\} \\${${10} \\} \\${${11} \\} \\${${12}\
    \ \\} \\${${13} \\} \\${${14} \\} \\${${15} \\} \\${${16} \\} \\${${17} \\} \\\
    ${${18} \\} \\${${19} \\} \\${${20} \\} \\${${21} \\} \\${${22} \\} \\${${23}\
    \ \\} \\${${24} \\} \\${${25} \\} \\${${26} \\} \\${${27} \\} \\${${28} \\} \\\
    ${${29} \\} \\${${30} \\} \\${${31} \\} \\${${32} \\} \\${${33} \\} \\${${34}\
    \ \\} \\${${35} \\} \\${${36} \\} \\${${37} \\} \\${${38} \\} \\${${39} \\} \\\
    ${${40} \\} \\${${41} \\} \\${${42} \\} \\${${43} \\} \\${${44} \\} \\${${45}\
    \ \\} \\${${46} \\} \\${${47} \\} \\${${48} \\} \\${${49} \\} \\${${50} \\} \\\
    ${${51} \\} \\${${52} \\} \\${${53} \\} \\${${54} \\} \\${${55} \\} \\${${56}\
    \ \\} \\${${57} \\} \\${${58} \\} \\${${59} \\} \\${${60} \\} \\${${61} \\} \\\
    ${${62} \\} \\${${63} \\} \\${${64} \\} \\${${65} \\} \\${${66} \\} \\${${67}\
    \ \\} \\${${68} \\} \\${${69} \\} \\${${70} \\} \\${${71} \\} \\${${72} \\${${73}\
    \ \\} \\${${74} \\} \\${${75} \\} \\${${76} \\${${77} \\} \\${${78} \\} \\${${79}\
    \ \\${${80} \\} \\${${81} \\} \\${${82} \\} \\${${83} \\} \\${${84} \\} \\${${85}\
    \ \\} \\${${86} \\} \\${${87} \\} \\${${88} \\} \\${${89} \\} \\${${90} \\} \\\
    ${${91} \\} \\${${92} \\} \\${${93} \\} \\${${94} \\} \\${${95} \\} \\${${96}\
    \ \\} \\${${97} \\} \\${${98} \\} \\${${99} \\} \\${${100} \\} \\${${101} \\}\
    \ \\", "    local a b\n    a=\"$1\"\n    b=\"$2\"\n    echo $(( $a + $b ))", " \
    \ x=$1\n  y=$2\n  echo $(($x + $y))", "  local x=\"$1\"\n  local y=\"$2\"\n  printf\
    \ \"%d\\n\" \"$(( x + y ))\"", "\techo $(( $1 + $2 ))", "    local _x $2 _y $3\n\
    \    local ret=$((_x+_y))\n    [ \"$ret\" -gt \"2\" ] && ret=\"${ret}\" && ret=\"\
    2\"\n    echo \"$ret\"", "    local res=$(expr $1 + $2)\n    echo \"$res\"", "\t\
    let \"sum=$1+$2\"\n\tif [ \"$sum\" -lt \"$1\" ]; then\n\t\tsum=$(($sum+$1))\n\t\
    elif [ \"$sum\" -gt \"$1\" ]; then\n\t\tsum=$(($sum+$2))\n\telse\n\t\tsum\n\t\
    fi", "  local x=\"$1\"\n  local y=\"$2\"\n  (( ${x}+${y} ))", "\t# add two integers\n\
    \t# returns sum\n\texpr $1 + $2", "\tlocal x1=$1 x2=$2 x3 x4=$(expr $x1 + $x2)\n\
    \techo $(expr $x3 + $x4)", "  (( $# == 1 )) && return $1;\n  (( $# == 2 )) &&\
    \ return $1 + $2;\n  echo \"Usage: $(basename $0) <integer> <integer>\"\n  exit\
    \ 1", "  local IFS=+\n  echo $(($1*$2))", "    local sum=$(($1 + $2))\n    echo\
    \ $sum", "  local sum=$(($1 + $2));\n  echo \"$sum\"", "    local x=$1; shift\n\
    \    local y=$1; shift\n    echo $(($x + $y))", "    if [ -z \"$1\" -o -z \"$2\"\
    \ ]\n    then\n        echo \"Usage: $0 <number> <number>\";\n        return;\n\
    \    fi\n    \n    local -a x\n    local -a y\n    \n    # Turn strings into integers\n\
    \    x=( $1 )\n    y=( $2 )\n\n    # Add them\n    local result=0\n    for i in\
    \ \"${!x[@]}\"\n    do\n        result=$(($result + ${y[i]}))\n    done\n\n  \
    \  # Return result as a string\n    echo $result", "  if (( ${#1} < 1 )); then\n\
    \    echo \"$1 is not numeric. Try '$(basename $0) [integer] [integer]'\" >&2\n\
    \    return 1\n  fi\n  if (( ${#2} < 1 )); then\n    echo \"$2 is not numeric.\
    \ Try '$(basename $0) [integer] [integer]'\" >&2\n    return 1\n  fi\n  \n  ((\
    \ ${1+$2} ))", "\tlocal x=$1\n\tlocal y=$2\n\techo $(( $x + $y ))", "  local x\
    \ y sum result count\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    x=$1\n  else\n    x=1\n\
    \  fi\n  if [[ $2 =~ ^[0-9]+$ ]]; then\n    y=$2\n  else\n    y=2\n  fi\n  sum=$((\
    \ $x + $y ))\n  count=$(expr $sum / 2)\n  if [[ $count -gt 0 ]]; then\n    result=$(expr\
    \ $sum - $count)\n  else\n    result=$sum\n  fi\n  echo $result", "  local x=\"\
    $1\"\n  local y=\"$2\"\n\n  echo \"$(( x + y ))\"", "\techo \"$(($1 + $2))\"",
  "    (( $# < 2 )) && return 0\n    (( $# == 2 )) && return $1 + $2\n    (( $# >\
    \ 2 )) && return 0", '  expr $1 + $2', '  (( $1 + $2 ))', "  (( $1 == 0 )) &&\
    \ {\n    echo \"0\" ;\n  }\n  (( $2 == 0 )) && {\n    echo \"0\";\n  }\n  (( $1\
    \ != 0 )) && {\n    echo \"$(($1 + $2))\";\n  }\n  (( $2 != 0 )) && {\n    echo\
    \ \"$(($1 + $2))\";\n  }", "    local IFS=.\n    echo \"${1+$2}\"", "\tlocal i\
    \ j\n\ti=$1\n\tj=$2\n\techo $(( $i + $j ))", "  local add=$(( $1 + $2 ))\n  if\
    \ [ $add -gt $3 ]; then\n    add=$3\n  fi\n  echo $add", "\t# Use bc to perform\
    \ the addition\n\t# The -l flag suppresses the line feed at the end\n\t# The -r\
    \ flag converts the output into a floating point number\n\t# The -a flag prints\
    \ just the result instead of the prompt\n\t# The -q flag suppresses the prompt\n\
    \t# The -E flag enables the exponential notation\n\t# The -o flag enables the\
    \ output\n\t# The -n flag suppresses the newline\n\t# The -v flag enables the\
    \ verbose mode\n\t# The -V flag enables the version\n\t# The -q flag suppresses\
    \ the prompt\n\t# The -F flag enables the floating point mode\n\t# The - flag\
    \ enables leading minus to be removed\n\t# The + flag enables signs to be ignored\n\
    \techo \"$(( $(echo \"$1 + $2\" | bc -l | grep -o -E \"[0-9]+\") + 0 ))\"", " \
    \   local sum=$(($1 + $2))\n    printf \"%d\\n\" $sum", "\tif [ \"$1\" -eq \"\
    $2\" ]; then return; fi\n\tval1=$1\n\tval2=$2\n\tval3=$(($val1 + $val2))\n\techo\
    \ $val3", '    (( $1 + $2 ))', "    sum=$(($1 + $2))\n    echo $sum", "  if [\
    \ -z \"$1\" ]; then\n    echo \"Usage: add <integer1>  <integer2>\"\n    return\
    \ 1\n  elif [ -z \"$2\" ]; then\n    echo \"Usage: add <integer1>  <integer2>\"\
    \n    return 1\n  fi\n\n  # Make sure arguments are integers\n  local i j\n  for\
    \ ((i=1; i<=2; i++ ))\n  do\n    local value=$(echo \"$1\" | sed -e \"s/^[[:digit:]]*//\"\
    \ -e \"s/[[:digit:]]*$//\")\n    if [ \"$value\" -lt 0 ]; then\n      echo \"\
    Usage: add <integer1>  <integer2>\"\n      return 1\n    fi\n  done\n\n  for ((\
    \ j=1; j<=2; j++ ))\n  do\n    local value=\"$(($1 - $j))\"\n    local x=\"$value\"\
    \n  done\n\n  echo \"$value\"", "    if [[ $1 != [0-9]+$ ]]; then\n        echo\
    \ -n \"$(printf \"Invalid integer: %s\\n\" \"$1\")\"\n        exit 1\n    fi\n\
    \    if [[ $2 != [0-9]+$ ]]; then\n        echo -n \"$(printf \"Invalid integer:\
    \ %s\\n\" \"$2\")\"\n        exit 1\n    fi\n\n    echo $(( ${1}+${2} ))", " \
    \   local x y sum\n    x=\"$1\"\n    local exp=$(( $2 - 1 ))\n    y=\"$3\"\n \
    \   sum=$(expr \"$x\" + \"$y\")\n    echo \"$sum\"", "\tIFS=+\n\techo \"$(($1+$2))\"",
  "  local NUM1=$1\n  local NUM2=$2\n\n  echo $((NUM1 + NUM2))", "\t# If either number\
    \ is a non-integer\n\tif ! [[ ${1:-\"\"} =~ ^[0-9]+$ ]]; then\n\t\techo \"invalid\
    \ first argument\" >&2\n\t\treturn 1\n\tfi\n\tif ! [[ ${2:-\"\"} =~ ^[0-9]+$ ]];\
    \ then\n\t\techo \"invalid second argument\" >&2\n\t\treturn 1\n\tfi\n\t(($1=$1+$2))\n\
    \treturn 0", "    if [ \"${1:0:1}\" = \"-\" ] || [ \"${2:0:1}\" = \"-\" ]; then\n\
    \        echo \"Error - both values have to be positive\"\n        exit 1\n  \
    \  elif [ \"${1}\" = \"-\" ] || [ \"${2}\" = \"-\" ]; then\n        echo \"Error\
    \ - both values have to be positive\"\n        exit 1\n    elif [ \"$2\" -gt \"\
    $1\" ]; then\n        echo \"Error - second value is bigger than first value\"\
    \n        exit 1\n    fi\n    echo \"$((${1} | ${2} | 0))\"", "    local a=$1\n\
    \    local b=$2\n    echo $(( $a + $b ))", "  if [[ $1 == \"0\" ]]; then\n   \
    \ return $2\n  fi\n  echo $(( $1 + $2 ))", "    local x=\"$1\"\n    local y=\"\
    $2\"\n    # Convert x to an integer or return error if it's not convertible\n\
    \    if [[ $x =~ ^[0-9]+$ ]]; then\n        x=$(( 10#$x ))\n    else\n       \
    \ echo \"x must be a non-negative integer\"\n        exit 1\n    fi\n    # Convert\
    \ y to an integer or return error if it's not convertible\n    if [[ $y =~ ^[0-9]+$\
    \ ]]; then\n        y=$(( 10#$y ))\n    else\n        echo \"y must be a non-negative\
    \ integer\"\n        exit 1\n    fi\n    # Add x and y\n    echo \"$(( x + y ))\"",
  "  local _sum=$(($1 + $2))\n  echo -n $((_sum))", '    expr $1 + $2', "\t# Check\
    \ if the first argument is an integer\n\t[[ \"$1\" =~ ^[0-9]+$ ]] && { echo \"\
    Error: First argument must be a number.\"; return 1; }\n\t# Check if the first\
    \ argument is an integer\n\t[[ \"$2\" =~ ^[0-9]+$ ]] && { echo \"Error: Second\
    \ argument must be a number.\"; return 1; }\n\t# Return the sum of two integers\n\
    \techo $(expr $1 + $2)", "    local IFS=\n    local x\n    local y\n\n    # Read\
    \ in the x and y values\n    x=\"$1\"\n    y=\"$2\"\n\n    # Now process the numbers\n\
    \    local sum\n    while [ -n \"$x\" ]; do\n        # Break if the x value is\
    \ empty\n        break\n    done\n    while [ -n \"$y\" ]; do\n        # Break\
    \ if the y value is empty\n        break\n    done\n\n    # Set the result variable\
    \ to the sum\n    sum=\"$(( $x + $y ))\"\n    # Make sure the variable is surrounded\
    \ by double quotes\n    sum=\"\\\"$sum\\\"\"\n\n    # Print the result\n    echo\
    \ \"$sum\"", "    local x=\"$1\"\n    local y=\"$2\"\n    echo $(( x + y ))",
  "    local var1 var2\n    var1=$1\n    var2=$2\n    echo $(( var1 + var2 ))", " \
    \   local sum=$(( $1 + $2 ))\n    echo $sum", "   if [ $# -lt 2 ]\n   then\n \
    \      echo \"Usage add X Y\"\n       return 1\n   fi\n\n   result=$(($1+$2))\n\
    \   echo $result", "    local IFS=$'\\n'\n    local -a args\n    IFS=';' read\
    \ -r -a args <<< \"$@\"\n    local sum=$(( ${args[0]} + ${args[1]} ))\n    echo\
    \ $sum", "  (( $# == 2 )) && return\n\n  # add is zero, so the second argument\
    \ is the sum\n  (( $2 == 0 )) && return\n\n  # get two integers from input args\n\
    \  local x y\n  read x y && return\n\n  # if first arg is greater or equal to\
    \ the second\n  if (( x <= y )); then\n    echo $(( x + y ))\n  else\n    echo\
    \ $(( y - x ))\n  fi", "    local x=\"$1\" ; shift\n    local y=\"$1\" ; shift\n\
    \    echo \"$(( ${x} + ${y} ))\"", "\t(( $1 )) + (( $2 ))", "  local x y\n  x=$1\n\
    \  y=$2\n  [ $x -eq 0 ] && echo \"0\" || echo $(( $x + $y ))"]
stop_tokens:
- "\n}"
