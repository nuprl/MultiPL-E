name: HumanEval_84_solve
language: sh
prompt: "#!/bin/bash\n# Given a positive integer N, return the total sum of its digits\
  \ in binary.\n# Example\n# >>> $(solve \"1000\")\n# \"1\"\n# >>> $(solve \"150\"\
  )\n# \"110\"\n# >>> $(solve \"147\")\n# \"1100\"\n# Variables:\n# @N integer\n#\
  \ Constraints: 0 \u2264 N \u2264 10000.\n# Output:\n# a string of binary number\n\
  #\n# $1 is an integer\nsolve() {\n"
tests: "}\n\ncandidate() {\n    solve \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"1000\") = \"1\" ]]\n    [[ $(candidate \"150\") = \"110\" ]]\n    [[ $(candidate\
  \ \"147\") = \"1100\" ]]\n    [[ $(candidate \"333\") = \"1001\" ]]\n    [[ $(candidate\
  \ \"963\") = \"10010\" ]]\n}\n\nrun_test"
completions: ["  local res=\n  local num=\n  local str1=\n  local str2=\n  local i=\n\
    \n  for ((i = 1; i <= $1; i++)); do\n    num=$(calc $i 2)\n    str1=$(calc $num\
    \ 4)\n    str2=$(calc $num 8)\n\n    res=$($str1 + $str2)\n  done\n\n  echo $res",
  "  echo \"$1\"\n  N=\"$1\"\n  declare -i sum=0\n  while [ $N ]; do\n    case \"\
    $N\" in\n      \"0\")\n        sum=\"01\"\n        ;;\n      \"1\")\n        sum=\"\
    11\"\n        ;;\n      *)\n        sum=\"${sum}${N:0:1}\"\n        ((N % 2))\n\
    \        ;;\n    esac\n    N=\"${N:2}\"\n  done\n  echo $sum", "  [[ $1 =~ ^[0-9]+$\
    \ ]] || return 1\n  local N=\"${1#*}\"\n  echo \"$(( (N % 2) + N % 10 ))\"", " \
    \   [[ $1 =~ ^[0-9]+$ ]] || return 1\n    local N=$1\n    local -a s\n    s=(${(N--)%.*}${N})\n\
    \    [[ $N ]] || return 1\n    echo ${(I:${#s[@]}-1)}${s[@]}", "  local n i sum\n\
    \  read n && [[ $n -gt 0 && $n -lt 10000 ]] || return 1\n  sum=0\n  i=1\n  while\
    \ [ $i -le $n ]\n  do\n    sum=$((sum+i))\n    ((i++))\n  done\n  echo $sum",
  "  local N=\"$1\"\n  local total\n  local num\n\n  if (( $N == 0 )); then\n    echo\
    \ 0\n  else\n    total=0\n    while (( $N > 0 )); do\n      num=$(echo \"$N\"\
    \ | awk '{print $1}')\n      total=$(( total + ( num % 2 ) ))\n      N=$(( N -\
    \ num % 2 ))\n    done\n    echo $total\n  fi", "\tlocal N=\"$1\"\n\tlocal ans=0\n\
    \n\twhile [ \"$N\" -gt 0 ]; do\n\t\tans=\"$(echo \"$ans\" | bc | awk '{ printf(\"\
    %${#ans}d\", $1 & 0); }')\"\n\t\tN=\"$(( $N / 2 ))\"\n\tdone\n\tif [ \"$N\" -gt\
    \ 0 ]; then echo \"0\"; else echo \"0\"; fi", "  local N=\"${1}\"\n  local sum=\"\
    1\"\n  while ((N > 0)); do\n    (( sum += N % 2 ))\n    (( N = (N / 2 )))\n  done\n\
    \  printf \"%b\" $sum", "    local n=$1 x\n    if [ $n -eq 0 ]; then\n       \
    \ echo \"0\"\n    else\n        while [ $n -gt 1 ]; do\n            x=$((n%2))\
    \ n=$(($n/2)) done\n        echo -n \"$x\"\n    fi", "        local n=$1\n   \
    \     local sum=0\n        while [[ $n -gt 0 ]]; do\n                if [[ $n\
    \ -lt 10 ]]; then\n                        sum=$((sum + $n))\n               \
    \         n=$(expr ${n%$n} + 1)\n                else\n                      \
    \  sum=$((sum + $n % 2))\n                        n=$(expr ${n%$n} / 2)\n    \
    \            fi\n        done\n        echo $(( sum % 2 ))", "    local N=$1\n\
    \    local sum\n    sum=$(echo $N|sed -r 's/(^|(?<=\\\\))([0-9])/\\1/g')\n   \
    \ while [ $sum -gt 1 ]\n    do\n        sum=$((sum-1))\n        echo \"1\"\n \
    \   done", "\tN=\"$1\"\n\t[[ $N -gt 10000 ]] && echo \"Value of N is too large\"\
    \ && return 1\n\t[[ $N -gt 0 ]] && echo \"Value of N is negative\" && return 1\n\
    \t[[ $N -eq 0 ]] && echo \"Value of N is zero\" && return 1\n\techo $(echo \"\
    $N\" | sed -E 's/(.*)/\\1/g' | sed -E 's/^0+\\([^0]*\\)/\\1/' | sed -E 's/^0*(.)(.)/\\\
    1\\2/g' | sed -E 's/^0*(.)(.)(.)(.)(.)(.)(.)/\\1\\2\\3\\4\\5\\6\\7/g')", "  if\
    \ [ $1 -lt 1 ]; then\n    echo \"Input is less than 1\"\n    exit 1\n  fi\n  local\
    \ N sum\n  N=$1\n  sum=0\n  while [ $N -gt 0 ]; do\n    sum=$(($sum + $(printf\
    \ '%b' $(echo \"$((N % 2))\" | bc)))\n    N=$((N / 2))\n  done\n  echo $sum",
  "  local N=\"${1:?}\"\n  echo \"${N}\" | awk '{\n    n=0\n    while ($0 > 0) {\n\
    \      n+=$(\n        echo \"${N%10}\"\n        N=N/10\n      )\n    }\n    print\
    \ n\n  }'", "    local N=\"${1}\"\n    if [ \"${N}\" -eq 0 ] ; then\n        echo\
    \ \"0\"\n        return 0\n    fi\n    # Convert N to binary\n    local N=`printf\
    \ \"%b\" \"$N\"`\n    # Count digits in N\n    local N_CNT=`printf \"%d\" \"$N\"\
    \ | wc -w`\n    # Compute sum\n    local SUM=\"1\"\n    for (( i=1; i<=$(( N_CNT-1\
    \ )); i++ )); do\n        SUM=\"${SUM}${N:$i}\"\n    done\n    # Trim leading\
    \ zeros to get a string\n    SUM=\"${SUM#0}${SUM}\"\n    # Return string with\
    \ leading zeros\n    echo \"$SUM\"", "    local N=$1\n    local B=$(printf \"\
    %b\" $N)\n    echo \"${B//[!0-9]}\"", '  echo $1', "  echo $1 | while read -r\
    \ number; do\n    sum=$(($(($sum + $number)) % 2)\n  done\n  echo $sum", "  N=$1\n\
    \  s=\n  while [ \"$N\" -gt 0 ] ; do\n    s=$(echo \"$N%2\" | bc) \"$s\"\n   \
    \ N=$(echo \"$N/2\" | bc)\n  done\n  echo $s", "    local N=$1\n    local s=0\n\
    \    local digit=0\n    local remainder=1\n    local power=1\n\n    while (( N\
    \ != 0 )); do\n        digit=N % 10\n        s=${s:-\"0\"}${digit:+\"0\"}\n  \
    \      (( N = N/10 ))\n    done\n    while (( remainder != 0 )); do\n        remainder=$((\
    \ $remainder * $power ))\n        s=${s:-\"0\"}${remainder:+\"0\"}\n        ((\
    \ power *= 10 ))\n    done\n    echo $s", "  local n=$1\n  echo $(( ( ( ( n /\
    \ 10 ) % 2 ) ) ))", "    local N=\"${1}\"\n    local S=\"0\"\n    local BASE=\"\
    1\"\n    # print N-2 digits\n    while (( \"$N\" > 0 ))\n    do\n        local\
    \ N_MINUS=\"$(( $N - 1 ))\"\n        local N_PLUS=\"$(( $N + 1 ))\"\n        local\
    \ C=\"$(( 2 * $N ))\"\n        local D=\"$(( 2 * $N_MINUS ))\"\n        local\
    \ M=\"$(( 2 * $N_PLUS ))\"\n        local N=\"$(( $N // 2 ))\"\n        S=\"$S$BASE\"\
    \n        BASE=\"$(( BASE * 2 ))\"\n        (( S+=( \"$C\" )) )\n        (( S+=(\
    \ \"$D\" )) )\n        (( S+=( \"$M\" )) )\n    done\n    # print N-2 digits in\
    \ reverse order\n    (( S=\"${S##*0\" }\" ))\n    echo \"$S\"", "  local n=$1\n\
    \  local sum=0\n  local digits=\"\"\n\n  for (( i=1; i<n; i++ )); do\n    sum=$((\
    \ sum + $(echo $(( n % 2 )) | bc) ))\n    digits=$( echo $(( n / 2 )) | sed 's/^0*//'\
    \ )\n  done\n\n  echo \"$(( sum + $(echo $(( n % 2 )) | bc) ))$digits\"", "  \
    \      local N=\"${1:-100}\"\n        echo \"$(bc <<< \"$N\")\"", "  local n=$1\n\
    \  echo $(echo $n | sed \"s/^\\([0-9]*\\).*/\\1/\")", "    local N=$1\n    local\
    \ numsum=0\n    local binarysum=0\n    local ones=0\n    local tens=0\n\n    while\
    \ [[ ${N} != 0 ]] ; do\n        if [[ ${N} -eq 0 ]]; then\n            echo \"\
    0\"\n            break\n        fi\n        binarysum=$(( ${binarysum} + ${N}%2\
    \ ))\n        ones=$(( ${ones} + ${N}%10 ))\n        tens=$(( ${tens} + ${N}%100\
    \ ))\n        (( ${N} /= 10 ))\n    done\n    numsum=$(( ${binarysum} * 2 ))\n\
    \    numsum=$(( ${numsum} + ${ones} ))\n    numsum=$(( ${numsum} + ${tens} ))\n\
    \    echo ${numsum}", "  if [ $1 -gt 10000 ]; then\n    echo \"Sorry, N is too\
    \ big to solve in this language.\"\n  else\n    local N=$1\n    local sum=0\n\
    \    for (( i=1; i<N; i++ )); do\n      local digit=$(echo $i | bc)\n      sum=$(($sum\
    \ + $digit))\n    done\n    echo $sum\n  fi", "    local answer\n    local N=$1\n\
    \    local sum\n    local i\n    local x\n    local digits\n    local decimal\n\
    \    local binary\n    local c\n    local n\n    local d\n    local s\n    local\
    \ f\n\n    sum=10000000000000000000000000000\n    digits=${N}\n\n    while ((\
    \ ${#digits} )); do\n        decimal=$(( ${digits:0:9} - $(( ${digits:9} % 10\
    \ )) ))\n        binary=${digits:0:9}\n        for c in ${decimal}; do\n     \
    \       binary=$(cycle ${binary})\n        done\n        binary=${binary:1}\n\
    \        for (( i = 1; i <= ${#binary}; i++ )); do\n            x=${binary:$i:1}\n\
    \            d=$(( ${#x} % 2 ))\n            binary=${x:0:$(( ${#x} - $d )):1}\n\
    \            s=$(( ${sum} * ${x} + ${s} )); sum=$(( ${s} * ${sum} - ${sum} ))\n\
    \        done\n        digits=${digits:0:$(( ${#digits} - 1 ))}\n    done\n  \
    \  answer=$(( ${sum} % 10 ))\n    if [[ ${answer} -gt ${#answer} ]]; then\n  \
    \      answer=${answer:0:${#answer}}\n    fi\n    echo ${answer}", "  local N=$1\n\
    \  local s\n  local x\n  local i\n\n  s=\"0\"\n  x=$(( N % 2 ))\n  while [ $x\
    \ -gt 0 ]; do\n    s=\"0$s\"\n    x=$(( x / 2 ))\n  done\n\n  echo \"$s\"", " \
    \   echo \"$1\" | perl -pe 's/(\\d+)/my $r = $1; $r < 1 ? \"\" : $r + 0 * $r,\
    \ \"\"/'", "  if [[ $# -eq 0 ]]; then\n    echo $(solve $2)\n    return\n  fi\n\
    \  # declare $1 as a string\n  local N=$1\n  # initialize a variable to hold the\
    \ sum\n  local sum=0\n  # loop while there are digits in $N\n  while [[ $N !=\
    \ 0 ]]; do\n    local rem=$((N % 2))\n    sum=$((sum + (rem*10)))\n    N=$((N/2))\n\
    \  done\n  # return the result\n  echo ${sum}", "  local i\n  local result\n \
    \ local sum\n  for i in $(seq 1 $1) ; do\n    sum=$(echo \"obase=2; $(( N / $i\
    \ ))\" | bc )\n    if [ ${sum} -eq 1 ] ; then\n      result=\"$result${i}\"\n\
    \    else\n      result=\"$result${i}0\"\n    fi\n  done\n  echo \"$result\"",
  "    echo \"$1\"\n    echo \"$1\"", "    [[ $1 =~ ^[0-9]+$ ]] || return 1\n    s=0\n\
    \    while ((N=$1%2)); do N=$(($N-1)); let s=$s+${s:+\"1\"};  done\n    echo -n\
    \ $s", "    local N=$1\n    local S=$2\n    local S1=$3\n    local S2=$4\n   \
    \ local S3=$5\n    local S4=$6\n    local S5=$7\n    local S6=$8\n    local S7=$9\n\
    \    local S8=$10\n    local S9=$11\n    local S10=$12\n    local S11=$13\n  \
    \  local S12=$14\n    local S13=$15\n    local S14=$16\n    local S15=$17\n  \
    \  local S16=$18\n    local S17=$19\n    local S18=$20\n    local S19=$21\n  \
    \  local S20=$22\n    local S21=$23\n    local S22=$24\n    local S23=$25\n  \
    \  local S24=$26\n    local S25=$27\n    local S26=$28\n    local S27=$29\n  \
    \  local S28=$30\n    local S29=$31\n    local S30=$32\n    local S31=$33\n  \
    \  local S32=$34\n    local S33=$35\n    local S34=$36\n    local S35=$37\n  \
    \  local S36=$38\n    local S37=$39\n    local S38=$40\n    local S39=$41\n  \
    \  local S40=$42\n    local S41=$43\n    local S42=$44\n    local S43=$45\n  \
    \  local S44=$46\n    local S45=$47\n    local S46=$48\n    local S47=$49\n  \
    \  local S48=$50\n    local S49=$51\n    local S50=$52\n    local S51=$53\n  \
    \  local S52=$54\n    local S53=$55\n    local S54=$56\n    local S55=$57\n  \
    \  local S56=$58\n    local S57=$59\n    local S58=$60\n    local S59=$61\n  \
    \  local S60=$62\n    local S61=$63\n    local S62=$64\n    local S63=$65\n  \
    \  local S64=$66\n    local S65=$67\n    local S66=$68\n    local S67=$69\n  \
    \  local S68=$70\n    local S69=$71\n    local S70=$72\n    local S71=$73\n  \
    \  local S", "  let \"bin = N / 2 ;\"\n  echo \"$(let \"rem = $N - $bin*2\"; echo\
    \ \"$(echo \"($bin + $(let \"rem = 0 ; \")\"*$bin)/2\" | bc))\"", "    if [ \"\
    $1\" -lt 0 || \"$1\" -gt 10000 ]; then echo \"invalid input\" 1>&2; exit 1; fi\n\
    \    local N=\"$1\"\n    local S\n    local B\n    local I\n    local L\n    local\
    \ O\n    local J\n    local OJ\n    local S\n    local I\n    local J\n    local\
    \ O\n\n    B=$(printf \"%b\" \"$N\" | tr -d '[:space:]')\n\n    while [ \"$B\"\
    \ != \"\" ]; do\n        S=0\n        for I in $B; do\n            L=$(echo \"\
    $I\" | cut -c1-1)\n            O=$(echo \"$I\" | cut -c2-1)\n            J=$(echo\
    \ \"$I\" | cut -c3-1)\n            OJ=$(echo \"$J\" | cut -c1-1)\n           \
    \ S=$((S+O+OJ))\n        done\n        B=$(echo \"$B\" | cut -c4- | tr -d '[:space:]')\n\
    \    done\n\n    echo \"$S\"", "  local N=$1\n  local sum\n  local zero=0\n  local\
    \ one=0\n  local two=0\n  local three=0\n  local four=0\n  local five=0\n  local\
    \ six=0\n  local seven=0\n  local eight=0\n  local nine=0\n  sum=$(echo $N | sed\
    \ 's/^0*//g')\n  N=$(echo $N | sed 's/^0*//g')\n  while [[ $N >1 ]]; do\n    local\
    \ digit=$(echo $N | cut -d'0' -f 1)\n    local remaining=$(echo $N | cut -d'0'\
    \ -f 2)\n    local sum=$(echo $sum + $digit)\n    local N=$remaining\n  done\n\
    \  if [[ $N =1 ]]; then\n    local sum=$(echo $sum + $N)\n    zero=1\n  else\n\
    \    local digit=$(echo $sum | cut -d'1' -f 1)\n    local remaining=$(echo $sum\
    \ | cut -d'1' -f 2)\n    local sum=$(echo $sum + $digit)\n    local N=$remaining\n\
    \  fi\n  while [[ $N >2 ]]; do\n    local digit=$(echo $N | cut -d'1' -f 1)\n\
    \    local remaining=$(echo $N | cut -d'1' -f 2)\n    local sum=$(echo $sum +\
    \ $digit)\n    local N=$remaining\n  done\n  while [[ $N >3 ]]; do\n    local\
    \ digit=$(echo $N | cut -d'1' -f 1)\n    local remaining=$(echo $N | cut -d'1'\
    \ -f 2)\n    local sum=$(echo $sum + $digit)\n    local N=$remaining\n  done\n\
    \  while [[ $N >4 ]]; do\n    local digit=$(echo $N | cut -d'1' -f 1)\n    local\
    \ remaining=$(echo $N | cut -d'1' -f 2)\n    local sum=$(echo $sum + $digit)\n\
    \    local N=$remaining\n  done\n  while [[ $N >5 ]]; do\n    local digit=$(echo\
    \ $N | cut -d'1' -f 1)\n    local remaining=$(echo $N | cut -d'1' -f 2)\n    local\
    \ sum=$(echo $sum + $digit)\n    local N=$remaining\n  done\n  while [[ $N >6\
    \ ]]; do\n    local digit=$(echo $N | cut -d'1' -f 1)\n    local remaining=$(echo\
    \ $N | cut -d'1' -f 2)\n    local ", "  local result=0\n  local count=0\n  local\
    \ N=$1\n  while ((N>=1)); do\n    result=`expr $result + $((N%2))`\n    N=`expr\
    \ $N/2`\n    count=$((count+1))\n  done\n  echo -n \"$((count>1?$count:1))\"\n\
    \  return $result", "  local input;\n  local output;\n  local sum;\n\n  input=$1;\n\
    \  output=$(echo $input | sed -e 's/./ &/g');\n  sum=$(echo $output | awk '{sum+=$1}\
    \ END {print sum}');\n  echo $sum;", "    local n=$1\n    local tmp\n    local\
    \ sum\n    local res\n    local count\n    local i\n    res=\"$(n)\"\n    sum=$(echo\
    \ $n|awk '{printf \"%0${#n}b\\n\", $0}')\n    sum=${sum#0}\n    for ((i=$((${#sum}-1)/2));\
    \ i>=1; i--); do\n        count=$((${#sum}%2))\n        tmp=$((${sum:0:$i}${count}${sum:$i:1}))\n\
    \        sum=$(echo $tmp|awk '{printf \"%s \", $0}')\n    done\n    sum=$(echo\
    \ $sum|awk '{printf \"%s \", $0}')\n    sum=${sum#0}\n    echo $sum", "    local\
    \ n=\"$1\"\n    if [ \"$n\" = \"0\" ]; then\n        return 1\n    fi\n    local\
    \ sum=$(echo $n | sed -re 's/0*$//; s/(0*)//;')\n    for (( i=1; i<=10; i++ ));\
    \ do\n        if [ \"$n\" -eq \"$sum\" ]; then\n            break\n        fi\n\
    \        sum=$(echo $(( 10#$sum + $i )) | bc)\n    done\n    echo $sum", "  N=$1\n\
    \  if ((N == 0)) then\n    echo \"0\"\n  else\n    local sum\n    for ((i = 1;\
    \ i <= N; i++ )) do\n      sum=$((sum + $i))\n    done\n    echo \"$sum\"\n  fi",
  "  # Part 1\n  N=$1\n  result=$(echo \"$N\" | grep -o \"^(0*[1-9][0-9]*|0)*$\" |\
    \ wc -l)\n  if [[ $result -eq 1 ]]; then\n    echo 1\n  else\n    echo 0\n  fi\n\
    \  # Part 2\n  N=$2\n  result=$(echo \"$N\" | grep -o \"^(0*[1-9][0-9]*|0)*$\"\
    \ | wc -l)\n  if [[ $result -eq 1 ]]; then\n    echo 1\n  else\n    echo 0\n \
    \ fi\n  # Part 3\n  N=$3\n  result=$(echo \"$N\" | grep -o \"^(0*[1-9][0-9]*|0)*$\"\
    \ | wc -l)\n  if [[ $result -eq 1 ]]; then\n    echo 1\n  else\n    echo 0\n \
    \ fi", "    local N N i n sum\n    read N\n    local numStr sumStr\n\n    while\
    \ ((N>0)); do\n        read N\n        ((numStr=N))\n        ((n=numStr))\n  \
    \      ((sum=sum+n))\n        ((N=N-1))\n    done\n    sumStr=$((sum%2))\n   \
    \ sum=$((sum/2))\n    if [ \"$sum\" -gt 1 ];then\n        sumStr=$((sumStr+1))\n\
    \        sum=$((sum-1))\n    fi\n    echo \"$sumStr$sum\"", '    [[ $1 =~ ^[0-9]+$
    ]] && echo "${1/([0-9]*)/\$(sum 1 $1)}" || echo "Invalid Number"', "  if [ $#\
    \ -ne 1 ]\n    then\n    echo \"Usage: $(basename $0) n\"\n    exit 1\n  fi\n\
    \  N=$1\n  if [ $(echo \"$N\" | grep -c '^[0-9]+$') -eq 0 ]\n    then\n    echo\
    \ \"Input must be an integer.\"\n    exit 1\n  fi\n  echo $(( $N % 2 != 0 ))\n\
    \  echo $(( $N % 3 != 0 ))\n  echo $(( $N % 4 != 0 ))\n  echo $(( $N % 5 != 0\
    \ ))\n  echo $(( $N % 6 != 0 ))\n  echo $(( $N % 7 != 0 ))\n  echo $(( $N % 8\
    \ != 0 ))\n  echo $(( $N % 9 != 0 ))", "    local N=$1\n    echo $N\n    echo\
    \ $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n\
    \    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N\
    \ >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n   \
    \ echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N &\
    \ 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo\
    \ $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n\
    \    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N\
    \ >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n   \
    \ echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N &\
    \ 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo\
    \ $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n\
    \    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N\
    \ >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n   \
    \ echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N &\
    \ 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo\
    \ $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n\
    \    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N\
    \ >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n   \
    \ echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> 1))\n    echo $((N &\
    \ 1))\n    echo $((N >> 1))\n    echo $((N & 1))\n    echo $((N >> ", "    local\
    \ N=\"$1\"\n    local sum=0\n    if [ ! \"$N\" ]; then\n        echo \"Usage:\
    \ $0 n\"\n        exit 1\n    fi\n    while [ $N -gt 0 ]; do\n        (( sum+=(\
    \ $N %% 2 )) )\n        (( N-=( $N %$2 )) )\n    done\n    echo \"$sum\"", " \
    \ local i j\n  i=1\n  while [ $i -lt $1 ]; do\n    i=$((i+1))\n    j=1\n    while\
    \ [ $j -lt $i ]; do\n      j=$((j+1))\n    done\n  done\n  echo $i", "  local\
    \ N=$1\n  if (( ! $N )) ; then\n    echo \"Error: Problem is missing input\"\n\
    \    return 1\n  fi\n  # This code below is based on the example code from Knuth\n\
    \  # Hence, it is copied from the above link\n  local B=00\n  local C=00\n  local\
    \ D=00\n  local L=0\n\n  if [ $N -gt 99 ]; then\n    echo $1\n    return 0\n \
    \ fi\n  while [ $L -lt $N ]; do\n    B=$(( B + $(expr $N mod 2) ))\n    N=$((\
    \ $N / 2 ))\n    (( $L ))\n  done\n  echo \"$B\"\n  while [ $D -lt $N ]; do\n\
    \    echo $(expr $B %% 2)\n    C=$(( C + $(expr $B mod 2) ))\n    B=$(( $B / 2\
    \ ))\n    (( $D ))\n  done\n  echo \"$C\"\n  echo \"$D\"", "  (( $# == 1 )) &&\
    \ return $1 || echo \"Wrong number of arguments\"\n  local N=$1\n  (( $N < 0))\
    \ && return 1 || echo \"Wrong arguments\"\n  # Convert to binary digits\n  local\
    \ a=\"$(echo \"$N\" | bc)\"\n  local b=\"$(echo \"$a\" | awk '{printf \"%0${#a}b%s\"\
    , length($0), $0}' )\"\n  # Convert to decimal\n  local s=\"$(echo \"$b\" | awk\
    \ '{printf \"%0${#b}d\", $0}')\"\n  echo \"$s\"", "    local N=$1\n    if [ $N\
    \ -lt 0 ] || [ $N -lt 10000 ] ; then\n        return \"0\"\n    fi\n    # Count\
    \ leading zeros in a binary number\n    local Z=0\n    while [ $Z -le $N ]; do\n\
    \        Z=$((Z*2))\n    done\n\n    # Sum digits\n    local S=0\n    while [\
    \ $N -gt 0 ]; do\n        S=$((S+$((N%2))))\n        ((N=N/2))\n    done\n\n \
    \   # Return binaray number\n    return $((Z*S+S))", "    echo -n \"Solving $1\
    \ ...\"\n    declare -i N=\"$1\"\n    declare -i S=\"0\"\n    local NUMBITS\n\
    \    # Get the number of bits needed to represent the given number\n    if [ \"\
    ${N#0}\" = \"$N\" ]; then\n        NUMBITS=\"8\"\n    else\n        NUMBITS=\"\
    ${#N}\"\n    fi\n    local LEFT\n    # Divide the given number by 2 until the\
    \ remainder is 0\n    while [ \"${N#0}\" = \"$N\" ]; do\n        N=\"$(printf\
    \ \"%0${NUMBITS}b\" \"$N\")\"\n        LEFT=\"$(expr \"${N#0} / 2\")\"\n     \
    \   (( S+=$LEFT ))\n    done\n    echo \"$S\"", "    echo $1 >> \"$2\"\n    while\
    \ read -r line; do\n        IFS= read -r -n 1 -d '' num\n        num=${num:0:1}\n\
    \        sum=${num}${sum:+1}\n    done < \"$2\"\n    echo \"$sum\"", "    local\
    \ n=$1\n    if [ $n -lt 0 ]; then\n        echo \"ERROR: function 'solve' called\
    \ with N < 0\"\n        return 1\n    fi\n    local s=0\n    while [ $n -gt 0\
    \ ]; do\n        s=$(( $s << 1 ))\n        s=$(( $s + $(( $n % 2 )) ))\n     \
    \   n=$(( $n / 2 ))\n    done\n    echo $s", "    local -n arr=(\"${!1}\")\n \
    \   local sum=$(printf \"%b\" \"${arr[@]}\" | wc -w)\n    echo $sum", "  if [\
    \ \"$#\" -lt 1 ]; then\n    echo \"Incorrect number of arguments\"\n    echo \"\
    $0 <N>\"\n    echo \"Example usage:\"\n    echo \"$0 1000\"\n    echo \"$0 150\"\
    \n    echo \"$0 147\"\n    exit 1\n  fi\n\n  # convert input to integer\n  local\
    \ N=$1\n  N=$((10#$N))\n\n  # check if N is a valid solution\n  if [ \"$N\" -lt\
    \ \"0\" -o \"$N\" -gt \"10000\" ]; then\n    echo \"No valid solution\"\n    exit\
    \ 1\n  fi\n\n  # convert to binary and add leading zeros to string\n  local S=\"\
    \"\n  local L=1\n  while [ $L -lt $N ]; do\n    local M=$((2**$L))\n    local\
    \ M=`expr $M % 2`\n    local S=$S${M}\n    ((L++))\n  done\n\n  # return string\
    \ and exit\n  echo \"$S\"", "    local n=$1\n\n    # Using a for loop so we can\
    \ add digits one at a time\n    local s=0\n    for (( digit=1; digit<=n; digit++\
    \ ))\n    do\n        (( s = s + digit ))\n    done\n    echo $s", "    local\
    \ n=\"$1\" b\n    (( n > 0 && n < 10000))\n\n    local sum=\"0\"\n    local nStr\n\
    \    while (( n > 0 ))\n    do\n        nStr=\"0\"\n        while (( n % 2 ))\n\
    \        do\n            nStr=$(( nStr + 1 ))\n            n=$(( n / 2 ))\n  \
    \      done\n        sum=$(( sum + nStr ))\n        n=$(( n - 1 ))\n    done\n\
    \    echo $sum", "  local n=$1\n  (( $# > 1 )) && return 0\n  [ \"$n\" -lt 1 ]\
    \ && return 0\n  (( $# == 1 )) && return $(echo \"$n\" | sed 's/^\\([0-9]*\\).*\\\
    ([0-9]*\\)/\\1\\2/')\n  (( $# == 2 )) && return $(echo \"$n\" | sed 's/^\\([0-9]*\\\
    ).*\\([0-9]*\\)/\\1\\2/')\n  (( $# == 3 )) && return $(echo \"$n\" | sed 's/^\\\
    ([0-9]*\\).*\\([0-9]*\\)/\\1\\2/')\n  (( $# == 4 )) && return $(echo \"$n\" |\
    \ sed 's/^\\([0-9]*\\).*\\([0-9]*\\)/\\1\\2/')", "    local N=\"${1:-}\"\n   \
    \ if [[ \"$N\" == *[!0-9]* ]]; then\n        echo \"${N}\"\n        return 0;\n\
    \    fi\n    local S=\"$(\n        echo \"$N\" |\n        awk '\n        {\n \
    \           for (i = 1; i <= NF; i++) {\n                if ($i == 0)\n      \
    \              continue;\n                s = s + $i;\n                printf(\"\
    %0*d\", length($i) - lengths(s), $i);\n            }\n        }\n        END {\n\
    \            printf(\"%0*d\", length(s), s)\n        }\n        '\n    )\"\n \
    \   echo \"$S\"", "    # Write your code here.\n    echo $(( ($1%1) > 0 ? $((\
    \ $1/(2**$((${#1}%${#1}))) )) : 2**($((${#1}%${#1})) ) ))", "  test \"$1\" -eq\
    \ 0 && return 1\n  local sum=$1\n  local n=0\n  while [ $n -lt 4 ]; do\n    sum=$((\
    \ sum * 2 + $1 ))\n    n=$(( n+1 ))\n  done\n  echo \"${sum:-0}\"", "    N=$1\n\
    \    if [ $N -gt 10000 ]; then\n      echo \"The number $N can't be solved\"\n\
    \      exit 0\n    fi\n    sum=$(echo $((N % 2))|bc|sed \"s/^0*//\")\n    for\
    \ i in $(seq 1 $((N % 2)|bc))\n    do\n        sum=$(($sum + $(echo $((N % 2))|bc|sed\
    \ \"s/^0*//\")));\n    done\n    echo \"$sum\"", "    local N=\"$1\"\n    local\
    \ digit\n    local dsum=0\n    local d\n    local b\n    local res\n\n    if [[\
    \ $N == 0 ]]; then\n        return 1\n    fi\n\n    for d in $(seq 0 9); do\n\
    \        digit=\"$N % 2\"\n        b=\"$d${digit}\"\n        N=\"$N / 2\"\n  \
    \      if [[ \"$d\" != 0 ]]; then\n            dsum=\"$dsum + $digit\"\n     \
    \   fi\n    done\n    res=\"$dsum\"\n    echo \"$res\"", "  declare -i i N\n \
    \ N=\"${1:-$(echo $1 | cut -d - -f 1)}\"\n  echo \"$((N % 2)) | $((N / 2))\" |\
    \ bc -l | xargs printf \"%d\\n\"", "  N=$1\n  B=$(echo $(($(echo \"scale=4; ($N\
    \ >> 1) | bc\")))\n  B=$(echo $(($(echo \"scale=4; ($N & 1) | bc\")))\n  B=$(($(echo\
    \ \"$B + $B\")))\n  B=$(echo $(($(echo \"scale=4; ($B >> 1) | bc\")))\n  B=$(echo\
    \ $(($(echo \"scale=4; ($B & 1) | bc\")))\n  B=$(($(echo \"$B + $B\")))\n  B=$(echo\
    \ $(($(echo \"scale=4; ($B >> 1) | bc\")))\n  B=$(echo $(($(echo \"scale=4; ($B\
    \ & 1) | bc\")))\n  B=$(($(echo \"$B + $B\")))\n  echo $B", "  local N=\"$1\"\n\
    \  if [[ $N == \"\" ]]; then\n    echo \"\"\n    return 0\n  fi\n  echo \"$N\"\
    \n  local sum\n  local i\n  local j\n  local k\n  local n\n  local tmp\n  local\
    \ t\n  local res\n\n  sum=\"0\"\n  i=\"0\"\n  j=\"0\"\n  k=\"0\"\n  n=\"$N\"\n\
    \  while [ $n -gt 0 ]; do\n    res=\"$res$(( $n % 2 ))\"\n    (( n /= 2 ))\n \
    \   (( j++ ))\n  done\n  while [ $j -lt 8 ]; do\n    t=$(echo \"$res\" | cut -c\
    \ -$j -s)\n    tmp=\"$(echo \"$sum + $t\" | bc -w)\"\n    (( sum = $tmp ))\n \
    \   res=\"$res$(( $t ))\"\n    (( j-- ))\n  done\n  (( k++ ))\n  while [ $k -lt\
    \ 8 ]; do\n    t=$(echo \"$res\" | cut -c -$k -s)\n    tmp=\"$(echo \"$sum + $t\"\
    \ | bc -w)\"\n    (( sum = $tmp ))\n    res=\"$res$(( $t ))\"\n    (( k-- ))\n\
    \  done\n  echo \"$res\"", "    local N=$1\n    local s=$(echo \"N=\\$(python\
    \ -c \"print(N%2)\")\n    N=\\$(echo \"N\\$\\(cat <<EOF\n\\$(python -c \"print(N%2)\"\
    )\nEOF\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python\
    \ -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c\
    \ \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\"\
    )\n\\$(python -c \"print(N%2)\")\n\\$(python -c \"print(N%2)\")\n", "    declare\
    \ -i N=$1\n\n    echo -n \"N: $N\"\n\n    # initialize result to 0\n    result=\"\
    0\"\n\n    count=0\n    while ((N>0)); do\n        ((N=N/2)) # right shift\n \
    \       ((count++))\n    done\n\n    echo -n \" count: $count\"\n\n    while ((count>0));\
    \ do\n        ((N/=2))\n        ((count--))\n        ((result=$result$((count%2)?1:0)))\n\
    \    done\n\n    echo -n \" result: $result\"\n\n    echo \" final result: $((N%2?1:0)$result)\"\
    \n\n    exit 0", "  N=$1\n  N=`echo $N|sed 's/^0*//g'`\n  (( N % 2 == 0 )) ||\
    \ { echo \"N is odd\"; exit 10; }\n  (( N < 10000 )) || { echo \"N is too small\"\
    ; exit 10; }\n  echo $(( N / 2 ))", "    let N=$1\n    echo $((N%2))\n    let\
    \ N=$((N/2))\n    echo $((N%2))\n    let N=$((N/2))\n    echo $((N%2))\n    let\
    \ N=$((N/2))\n    echo $((N%2))\n    let N=$((N/2))\n    echo $((N%2))\n    let\
    \ N=$((N/2))\n    echo $((N%2))", "\tN=$1\n\techo $(($N % 10)) $(($N / 10))",
  "  N=\"$1\"\n  O=\"$(echo \"obase=2; ibase=10; ${N}\" | bc)\"\n  echo ${O}", " \
    \   local N=\"$1\"\n    local Nstr=\"\"\n    local Carry=1\n    local Digits\n\
    \    local total\n    local x\n    local y\n    while [ \"${N}\" -gt 0 ]; do\n\
    \        Digits=$((N % 2))\n        total=total+${Digits} ${Carry}\n        N=$((\
    \ N / 2 ))\n        Carry=${Carry}\n    done\n    total=$((${total} + ${Carry}))\n\
    \    totalstr=\"$(printf '%b' ${total})\"\n    echo $totalstr", "    local n=$1\
    \ bc output\n    if [ $n -lt 0 -o $n -gt 10000 ] ; then return; fi\n    bc=$(bc\
    \ -l <<< \"scale=4; $n\")\n    for (( i=1; i <= 32; i++ )); do\n        output=$(echo\
    \ \"$bc * 2\" | bc -l)\n        bc=$(bc -l <<< \"$output / 2\")\n        output=$(bc\
    \ -l <<< \"$output % 2\")\n        bc=$(bc -l <<< \"$bc * 10\")\n        if [\
    \ $output -eq 1 ] ; then break; fi\n    done\n    echo \"$output\"", "  N=\"${1}\"\
    \n  declare -a arr\n  arr=()\n  count=0\n  while [[ $((N % 2)) -eq 0 ]]; do\n\
    \    arr+=(\"0\")\n    N=\"${N/2}\";\n    count=$((count + 1))\n  done\n  if [[\
    \ $((N % 2)) -eq 0 ]]; then\n    arr+=(\"1\")\n  fi\n  echo \"${arr[*]}\"", " \
    \   echo -n \"$1\"\n    local N=$1\n    local s=0\n    while [ ${N} -gt 0 ]; do\n\
    \        s=`expr ${s} + \\( ${N} % 2 \\)`\n        N /= 2\n    done\n    echo\
    \ \"${s:=0}\"", '    echo $(sum $1)', '  # Your code here', "  declare -i N Ns\
    \ i\n  # Convert N to binary\n  Ns=$(echo \"$1\" | bc)\n  N=${N#0} && echo \"\
    $N\"\n  if [ -z \"$N\" ]; then\n    echo -1\n    return\n  fi\n  for (( i=1; i<$N;\
    \ i++ )); do\n    Ns=$(echo \"$Ns\" | sed \"s/^\\([01]\\)/\\1\\1/g\")\n  done\n\
    \  echo \"$Ns\"", "    let N=$1\n    let digits=$(perl -e 'print map { $_ !~ /^0/\
    \ ? 0 : $_ } reverse($_) for reverse (split(//,$N))')\n    let res=$(echo ${digits[@]:0:1})\n\
    \    let carry=0\n    for d in $(seq 0 $#digits)\n    do\n        res+=$((digits[d]+$carry))\n\
    \        carry=$((digits[d]+$carry))>0\n    done\n    res+=$carry\n    res=${res:0:1}\n\
    \    echo $res", "    echo \"$1\" | awk -F, '{\n      s = 0 \n      while ($1\
    \ > 0) {\n        s = $1 % 2 + s\n        $1 = $1 / 2\n      }\n      print s\n\
    \    }'", "    local n=\"${1:-1000}\"\n    echo \"$(($n%2?1:0))$(($n/2%2?1:0))$(($n/4%2?1:0))$(($n/8%2?1:0))$(($n/16%2?1:0))$(($n/32%2?1:0))$(($n/64%2?1:0))$(($n/128%2?1:0))$(($n/256%2?1:0))$(($n/512%2?1:0))$(($n/1024%2?1:0))$(($n/2048%2?1:0))$(($n/4096%2?1:0))$(($n/8192%2?1:0))$(($n/16384%2?1:0))\"",
  "  local N=$1\n  local d\n  local total\n  local sum\n  local answer\n  local count\n\
    \  local decimal\n  local i\n  local j\n  total=\"0\"\n  decimal=\"$((N % 10))\"\
    \n  if [ \"$decimal\" -ne 0 ]; then\n    for (( i = 0; i < decimal; i++ )); do\n\
    \      total=\"$total$((N / 10) % 2)\"\n      N=\"$((N / 10))\"\n    done\n  fi\n\
    \  sum=\"$total$decimal\"\n  answer=\"\"\n  for i in {000..100}; do\n    answer=\"\
    $answer$((sum % 2))\"\n    sum=\"$((sum / 2))\"\n  done\n  echo $answer", "  \
    \  echo \"$1\" | awk '{for(i=1;i<=length($1);i++) printf \"%i\",($1[i] + $i)%2\
    \ }'", "  local n=$1 i\n  local sum=\"\"\n  local digit\n\n  for (( i=8; i>=0;\
    \ i-- )); do\n    (( digit=$n % 2 ))\n    (( sum=$digit+sum ))\n    (( n//=2 ))\n\
    \  done\n  echo $sum", "    # Write your code in JavaScript (Node.js 8.9.4)\n\
    \    # Return the output", "\t[ \"$#\" -ne 1 ] && return 1\n\tlocal n=\"$1\" ||\
    \ return 1\n\tlocal result\n\tresult=$(echo \"obase=2; ibase=10; $(expr ${n}%2)\"\
    \ | bc)\n\t[ \"$result\" -eq 0 ] && return 1\n\techo \"${result}\"\n\t[ \"$result\"\
    \ -eq 1 ] && echo \"0\"", "    local N=$1\n    if [[ $N == 0 ]]; then\n      \
    \  echo \"0\"\n    elif [[ $N == 1 ]]; then\n        echo \"1\"\n    elif [[ $N\
    \ == 2 ]]; then\n        echo \"10\"\n    elif [[ $N == 3 ]]; then\n        echo\
    \ \"11\"\n    elif [[ $N == 4 ]]; then\n        echo \"100\"\n    elif [[ $N ==\
    \ 5 ]]; then\n        echo \"101\"\n    elif [[ $N == 6 ]]; then\n        echo\
    \ \"110\"\n    elif [[ $N == 7 ]]; then\n        echo \"111\"\n    elif [[ $N\
    \ == 8 ]]; then\n        echo \"1000\"\n    elif [[ $N == 9 ]]; then\n       \
    \ echo \"1001\"\n    elif [[ $N == 10 ]]; then\n        echo \"1010\"\n    elif\
    \ [[ $N == 11 ]]; then\n        echo \"1011\"\n    elif [[ $N == 12 ]]; then\n\
    \        echo \"1100\"\n    elif [[ $N == 13 ]]; then\n        echo \"1101\"\n\
    \    elif [[ $N == 14 ]]; then\n        echo \"1110\"\n    elif [[ $N == 15 ]];\
    \ then\n        echo \"1111\"\n    else\n        echo \"${N} is out of range (0\
    \ to 9999)\"\n    fi", "    local n r\n    if [ -z \"$1\" ]\n    then\n      echo\
    \ \"Error: Invalid argument. Usage: $0 <N>\" >&2\n      exit 1\n    fi\n    n=\"\
    $1\"\n    if [ $n -lt 0 -o $n -gt 10000 ]\n    then\n      echo \"Error: Invalid\
    \ argument. Usage: $0 <N>\" >&2\n      exit 1\n    fi\n    if [ $n -lt 10 ]\n\
    \    then\n      r=\"${n%?}\"\n      echo ${r}\n      exit 0\n    fi\n    r=\"\
    0\"\n    while [ $n -gt 0 ]\n    do\n      r=\"${r}1\"\n      n=$(echo \"$n%2\"\
    \ | bc)\n    done\n    echo ${r}", "  declare -a number\n  declare -i sum\n\n\
    \  if (( $# != 1 )) || (( $1 != $1 )) || (( $1 >  10000 )) || (( $1 < 0 )) ||\
    \ (( $1 !~ ^[0-9]+$ )); then\n    echo \"wrong number of arguments\"\n    return\
    \ 1\n  fi\n\n  number=$1\n  sum=0\n\n  for (( n=0 ; n<10 ; n++ )); do\n    if\
    \ [[ $n -eq $(( ${#number} - 1 )) ]]; then\n      sum=$(( ${sum} + ${number:n}\
    \ ))\n      break\n    fi\n    sum=$(( ${sum} + ${number:$n} ))\n  done\n\n  echo\
    \ \"$sum\"", "    # Make sure you use read -r to prevent shell expansion attacks.\n\
    \    read -r -d '' _solve_script\n    local result\n    result=$(echo $_solve_script\
    \ | ruby -e 'puts ARGF.read.to_s.scan(/\\d+/).sum.to_s(2)')\n    echo \"$result\"",
  "    local N=$1\n    if [ \"$N\" = \"0\" ]; then\n        echo \"0\"\n    elif [\
    \ \"$N\" = \"1\" ]; then\n        echo \"1\"\n    else\n        local M=$(( 10#$N\
    \ ))\n        local N=$(( M%2 ))\n        if [ \"$N\" -gt 0 ]; then\n        \
    \    solve $(( M - 1 ))\n        else\n            solve $(( M + 1 ))\n      \
    \  fi\n    fi", "  read N <= \"$(echo \"$1\" | sed 's/^\\./0\\./')\"\n  echo $((N\
    \ % 2): >> result\n  N=$((N / 2))\n  while [ \"$N\" -gt 0 ]; do\n    echo $((N\
    \ % 2): >> result\n    N=$((N / 2))\n  done\n  echo $((N % 2): >> result\n  echo\
    \ )\n  rm -f result", "  N=$1\n  declare -i total=0\n  while [ $N > 0 ]\n  do\n\
    \      total=$(($total + $(echo \"$N % 2\" | bc)))\n      N=$(echo \"$N / 2\"\
    \ | bc)\n  done\n  echo \"$total\"", "\tlocal n=$1\n\tlocal s=0\n\tlocal d=$((2**${#n}))\n\
    \n\tfor ((i=0;i<$d;i+=$d)); do\n\t\tif [ $(($i % $d)) -eq 0 ]; then\n\t\t\ts=$((s*2))\
    \ $n\n\t\t\tn=$((n-1))\n\t\tfi\n\tdone\n\treturn $s", "  echo \"$1\" | grep -q\
    \ '^[[:digit:]]$' && echo \"1\" && return\n  echo \"$1\" | grep -q '^[[:digit:]]+$'\
    \ && echo \"$1\" && return\n  N=${1##*/}\n  for i in $(seq 0 9); do\n    echo\
    \ $(echo \"$N\" | sed \"s/^\\(${i}\\)\\([[:digit:]]*\\)\\([0-9]\\)/\\1\\11\\2/\"\
    \ | bc)\n  done", "  local n res\n  res=$(echo \"$1\" | sed -e 's/\\(.*\\)\\(.\\\
    )\\(.*\\)/\\1\\2\\3/' -e 's/\\(.\\)/\\1\\1/')\n  printf \"$res\\n\"", "  echo\
    \ \"$1\" | tr ' ' \"\\n\" | awk '{printf \"%d%n\", $1, $0;}'\n  echo -en \"\\\
    n\"", "    if [ $1 -lt 0 || $1 -gt 10000 ]\n    then\n        echo \"Invalid input\
    \ N\"\n    else\n        local N\n        N=$1\n        local res\n        res=$(echo\
    \ $N|tr ' ' '0') && echo \"$res\"\n        local counter\n        counter=0\n\
    \        while [ $counter -lt $N ]\n        do\n            res=$(echo $res|tr\
    \ ' ' '0') && echo \"$res\"\n            res=$(echo $res|tr ' ' '1') && echo \"\
    $res\"\n            (( counter = counter + 1 ))\n        done\n        res=$(echo\
    \ $res|tr ' ' '1') && echo \"$res\"\n        res=$(echo $res|tr ' ' '0') && echo\
    \ \"$res\"\n    fi", "    local N=\"$1\"\n    [[ \"$N\" =~ ^[0-9]+$ ]] || return\
    \ 1\n    local sum=0\n    while (( N > 0 )); do\n        (( sum += (N % 10)))\n\
    \        (( N /= 10 ))\n    done\n    echo \"$sum\"", "  echo \"$1\" | grep -oP\
    \ '(?<=^|-)(?=[0-9])[0-9]+'", "  local res=\"${1}\"\n  (( $# > 0 )) || return\
    \ 1\n  (( $1 )) || return 1\n  local d=0\n  local b\n  res+=\"1\"\n  while ((\
    \ ${#res} < 8 )) ; do\n    res+=\"0\"\n  done\n  local j=0\n  while (( ${#res}\
    \ > 0 )) ; do\n    d=$(( $(( ${#res} / 2 )) ))\n    b=$(( ${res:${j}:1} ))\n \
    \   (( j++ ))\n    res=${res:0:${j}}\n    (( $(( $(( $d )) )) )) && res+=\"${b}\"\
    \n    (( $(( $j % 2 )) )) && res+=\"${b}\"\n  done\n  (( $#res > 0 )) && return\
    \ 1\n  return ${res}", "  echo \"$1\"\n  N=\"$1\"\n\n  S=\"0\"\n  while [ \"$N\"\
    \ -gt 0 ]; do\n    S=\"$S$((N & 1))\"\n    ((N>>=1))\n  done\n\n  echo \"$S\"",
  "    local i N sum res\n    N=\"$1\"\n    res=$(printf \"%b\" $((N&255))) # print\
    \ binary number\n    sum=0\n    for ((i=0; i<${#res}; i++)); do\n        sum=$((sum\
    \ + $(echo \"${res: -$i: 1}\" | bc -l )))\n    done\n    echo $sum", "    local\
    \ -a arr\n    arr=()\n    local a b i len\n    len=${#1}\n    read a b <<< \"\
    $1\"\n    for ((i=0; i<len; i++))\n    do\n        arr=( \"${arr[@]}\" $(echo\
    \ \"$((b%2))\" | bc) )\n        b=$((b / 2))\n    done\n    echo -n \"${arr[@]}\"",
  "  local N=\"$1\"\n  local i=1\n  local sum=0\n\n  while (( i < N )); do\n    ((\
    \ sum += (N % 10)))\n    (( N /= 10 ))\n    (( i++ ))\n  done\n\n  if (( N > 0\
    \ )); then\n    (( sum += (N % 10)))\n    (( N /= 10 ))\n  fi\n\n  return \"${sum}\"",
  "  local N=\"${1}\"\n  if [[ \"${N}\" =~ \"^[[:digit:]]+$\" ]]; then\n    local\
    \ -n result=\"+\"\n    for ((i=${N}; i>0; i-=10)) ; do\n      result=\"$(echo\
    \ \"${result}${i%%:*}\" | bc)\"\n    done\n    echo \"${result}\"\n  else\n  \
    \  echo \"ERROR: Number must be an integer.\"\n  fi", "    local N=\"$1\"\n  \
    \  local str=''\n    local lastdigit=0\n    local i\n    local len\n    len=\"\
    ${#N}\"\n    if [ \"$len\" -ne \"2\" ]; then\n        echo \"Usage: $(basename\
    \ $0) n\"\n        return 1\n    fi\n    lastdigit=\"${N%%.*}\"\n    read -p \"\
    Binary number: \" -a str <<<\"$N\"\n    for ((i = 0; i <= len-1; i++)); do\n \
    \       local digit=${str[$i]}\n        # Only need to go through each time if:\n\
    \        # 1. lastdigit was 0 because it's a leading zero\n        # 2. the digit\
    \ is more than the lastdigit (because of the leading zero)\n        if [ \"$lastdigit\"\
    \ -eq \"0\" ] && [ \"$digit\" -gt \"$lastdigit\" ]; then\n            # add the\
    \ digit\n            digit=$((lastdigit*10+digit))\n            # remember the\
    \ new lastdigit\n            lastdigit=$digit\n            # add it\n        \
    \    str+=$digit\n        fi\n    done\n    echo \"$str\"", "  local n=\"$1\"\n\
    \  echo \"${n:0:5}\" | sed \"s/[^01]*/0/g\"", "  local N=$1\n  # declare -a number\n\
    \  # declare -i i\n  # declare -i d\n  # number=(${N//${N//./ }})\n  # for i in\
    \ ${number[@]}\n  # do\n  #   if [ $i -gt ${#number[@]} ]\n  #   then\n  #   \
    \    return \"0\"\n  #   fi\n  #   d=$(echo $i | bc -l)\n  #   echo $d\n  # done\n\
    \  echo \"$((N % 2))\"", "\tlocal NUM=$1\n\tlocal N\n\n\tN=0\n\tlocal i\n\tfor\
    \ i in $(seq 0 $(( 10#$NUM - 1 ))); do\n\t\t((N += (10#$N % $i) ))\n\tdone\n\t\
    echo $N", "    local N=\"$1\"\n    local S\n    local T\n    local F\n    local\
    \ G\n    local H\n    local I\n    local J\n    local K\n    local L\n    local\
    \ M\n    local N\n    local O\n    local P\n    local Q\n    local R\n    local\
    \ S\n    local T\n    local U\n    local V\n    local W\n    local X\n    local\
    \ Y\n    local Z\n\n    for (( i = 1 ; i <= N ; i++ )); do\n        O=\"$(echo\
    \ \"$i\" | bc|tr '0123' '123456789')\"\n        P=\"$(echo \"$i\" | bc|tr '0123'\
    \ '123456790')\"\n        Q=\"$(echo \"$i\" | bc|tr '0123' '123456791')\"\n  \
    \      R=\"$(echo \"$i\" | bc|tr '0123' '123456792')\"\n        O=\"$(echo \"\
    $O\" | bc|tr '0123' '123456789')\"\n        P=\"$(echo \"$P\" | bc|tr '0123' '123456790')\"\
    \n        Q=\"$(echo \"$Q\" | bc|tr '0123' '123456791')\"\n        R=\"$(echo\
    \ \"$R\" | bc|tr '0123' '123456792')\"\n        O=\"$(echo \"$O\" | bc|tr '0123'\
    \ '123456789')\"\n        P=\"$(echo \"$P\" | bc|tr '0123' '123456790')\"\n  \
    \      Q=\"$(echo \"$Q\" | bc|tr '0123' '123456791')\"\n        R=\"$(echo \"\
    $R\" | bc|tr '0123' '123456792')\"\n        O=\"$(echo \"$O\" | bc|tr '0123' '123456789')\"\
    \n        P=\"$(echo \"$P\" | bc|tr '0123' '123456790')\"\n        Q=\"$(echo\
    \ \"$Q\" | bc|tr '0123' '123456791')\"\n        R=\"$(echo \"$R\" | bc|tr '0123'\
    \ '123456792')\"\n        O=\"$(echo \"$O\" | bc|tr '0123' '123456789')\"\n  \
    \      P=\"$(echo \"$P\" | bc|tr '0123' '123456790')\"\n        Q=\"$(echo \"\
    $Q\" | bc|tr '0123' '123456791')\"\n        R=\"$(echo \"$R\" | bc|tr '0123' '123456792')\"\
    \n        O=\"$(echo \"$O\" | ", "    local N=\"${1}\"\n\n    while [ \"$N\" -gt\
    \ 0 ]; do\n        local sum=\"0\"\n        local N=\"${N//$(( ${N}-1 ))}\"\n\
    \        local i=${#sum}\n        while [ \"$N\" -gt 0 ]; do\n            local\
    \ remainder=\"$(( ${N} % 2 ))\"\n            sum=\"$(( $sum + ${remainder} ))\"\
    \n            N=\"${N//$(( ${N}-1 ))}\"\n        done\n        echo \"$sum\"\n\
    \    done", "  local number=\"$1\"\n  local binary=\"\"\n  local sum=0\n\n  #\
    \ Convert to binary and then sum the numbers\n  local n=0\n  local x=0\n  while\
    \ [ $n -lt ${#number} ]; do\n    local digit=\"${number:$n:1}\"\n    binary=\"\
    $binary$(( $(echo \"$digit\" | bc | sed 's/^0*//') ))\"\n    sum=$(( ${sum} +\
    \ ${digit} ))\n    let n=$n+1\n  done\n\n  # Add leading zeros\n  local x=0\n\
    \  while [ $x -lt ${#sum} ]; do\n    local digit=\"${sum:$x:1}\"\n    binary=\"\
    $(( ${binary} + $digit ))\"\n    let x=$x+1\n  done\n  echo \"$binary\"", "  N=$1\n\
    \  sum=0\n  while [ ${N} -le ${#N} ]\n  do\n    sum=$(($sum + ${N:$(($N-3))}))\n\
    \    N=$(($N - ${N:$(($N-3))}))\n  done\n  echo \"$sum\"", "\tN=\"$1\"\n\n\tif\
    \ [ $N -gt 10000 ]; then\n\t\techo -1\n\tfi\n\n\tdeclare -i B\n\tdeclare -i i\n\
    \tdeclare -i sum\n\tB=0\n\tsum=0\n\ti=1\n\twhile [ $i -le $N ]; do\n\t\tB=$(($B\
    \ + $(( ${N%/}*$i ))) )\n\t\tsum=$(($sum + $i) )\n\t\ti=$(($i + 1))\n\tdone\n\t\
    echo \"$sum\"", "    local N=$1\n    local result=\"\"\n    local num=0\n    if\
    \ [[ \"$N\" =~ ^[0-9]+$ ]]; then\n        local numString=$(printf %b \"$N\")\n\
    \        for (( i=0; i<${#numString}; i++ )); do\n            num+=${numString:$i:1}\n\
    \        done\n        result=$(printf \"%b\" $num)\n        echo \"$result\"\n\
    \    else\n        echo \"Invalid input\"\n    fi", "  local num=$1\n\n  echo\
    \ \"$num\" | awk '{print toupper(sprintf(\"%0.*s\", length($0), $0));}'", "  \
    \  (( $# == 1 )) && {\n        echo \"Usage: $(basename $0) n\"\n        return\
    \ 1\n    }\n    [[ $1 =~ ^[+-]?[0-9]+$ ]] || {\n        echo \"Usage: $(basename\
    \ $0) n\"\n        return 1\n    }\n    \n    local N=$1\n    local num\n    local\
    \ sum\n    local j\n    \n    for (( j = 1; j <= $(( N / 2 )); j++ )); do\n  \
    \      if [[ ${#N} == 1 ]]; then\n            echo \"0\"\n        else\n     \
    \       num=${N%:}\n            num=${num:0:$(( ${#num} - 1 ))}\n            sum=$((\
    \ ${sum:-0} + num ))\n        fi\n        (( N /= 2 ))\n    done\n    (( N <=\
    \ 1 )) && {\n        echo \"0\"\n    }\n    \n    echo \"${sum:-0}\"", '    local
    N N1 N2 N3 N4 N5 N6 N7 N8 N9 N10 N11 N12 N13 N14 N15 N16 N17 N18 N19 N20 N21 N22
    N23 N24 N25 N26 N27 N28 N29 N30 N31 N32 N33 N34 N35 N36 N37 N38 N39 N40 N41 N42
    N43 N44 N45 N46 N47 N48 N49 N50 N51 N52 N53 N54 N55 N56 N57 N58 N59 N60 N61 N62
    N63 N64 N65 N66 N67 N68 N69 N70 N71 N72 N73 N74 N75 N76 N77 N78 N79 N80 N81 N82
    N83 N84 N85 N86 N87 N88 N89 N90 N91 N92 N93 N94 N95 N96 N97 N98 N99 N100 N101
    N102 N103 N104 N105 N106 N107 N108 N109 N110 N111 N112 N113 N114 N115 N116 N117
    N118 N119 N120 N121 N122 N123 N124 N125 N126 N127 N128 N129 N130 N131 N132 N133
    N134 N135 N136 N137 N138 N139 N140 N141 N142 N143 N144 N145 N146 N147 N148 N149
    N150 N151 N152 N153 N154 N155 N156 N157 N158 N159 N160 N161 N162 N163 N164 N165
    N166 N167 N168 N169 N170 N171 N172 N173 N174 N175 N176 N177 N178 N179 N180 N181
    N182 N183 N184 N185 N', "  local i\n  for i in $(seq 1 $1); do\n    printf -v\
    \ $1 \"%d\" $i\n  done", "\tN=$1\n\tresult=$(echo -n $N|bc)\n\twhile (( N > 0\
    \ )); do\n\t\tsum=$(echo $result|bc -l | grep -oP '.{${#result}}')\n\t\tresult=${result/$sum}\n\
    \t\tN=$((N-1))\n\tdone\n\techo $result", "    local n=\"$1\"\n    local answer=\"\
    $(solve \"$(addDigits $n)\")\"\n    echo $answer", "    local i n sum\n    read\
    \ n <&1\n    while [[ $n -lt 0 || $n -gt 10000 ]]; do\n        echo 1>&2 \"$0:\
    \ illegal input\"\n        read -r n <&1\n    done\n    sum=$((10#$n))\n    i=1\n\
    \    while [[ $i -lt $((n-1)) ]]; do\n        sum=$((10#$sum + $((10#$(((n-1)$i))))))\n\
    \        i=$((i + 1))\n    done\n    echo $sum", "  local n=${1}\n  local s=0\n\
    \  for ((i=1;i<=n;i++)); do\n    let \"s = s + ($(echo $(($i)) | bc))\"\n  done\n\
    \  echo $s", "  local -n NUM=\"$1\" \n  local -n BIN=\n  local -n RESULT\n  local\
    \ -n DIGITS\n\n  RESULT=$(echo \"${NUM}\" | awk '{printf \"%i\\n\",$1; exit }')\n\
    \n  while (( ${#RESULT} > 0 )); do\n    BIN=${RESULT:0:1}\n    RESULT=$(echo \"\
    ${RESULT}\" | awk '{printf \"%i\\n\",$1}')\n  done\n\n  (( NUM > 0 )) && printf\
    \ \"%s\\n\" \"${BIN}${BIN}${BIN}\"", "    local N=$1\n    # Convert N to binary\n\
    \    local n=0\n    while [ $n -lt $((2**N)) ]; do\n        local d=$((($n*$((N-1)*n+1))\
    \ >> 1))\n        echo -ne \"$d$(($(echo $d | bc | sed 's/^\\./\\n&/'))\"\n  \
    \      n=$((n+1))\n    done", "\tN=$1\n\t((N%=1)) && return 0\n\tN=$((N<<1))\n\
    \t((N%=1)) && return 0\n\t((N%=2)) && return 0\n\t((N%=4)) && return 0\n\t((N%=8))\
    \ && return 0\n\t((N%=16)) && return 0\n\t((N%=32)) && return 0\n\t((N%=64)) &&\
    \ return 0\n\t((N%=128)) && return 0\n\t((N%=256)) && return 0\n\t((N%=512)) &&\
    \ return 0\n\t((N%=1024)) && return 0\n\t((N%=2048)) && return 0\n\t((N%=4096))\
    \ && return 0\n\t((N%=8192)) && return 0\n\t((N%=16384)) && return 0\n\t((N%=32768))\
    \ && return 0\n\t((N%=65536)) && return 0\n\t((N%=131072)) && return 0\n\t((N%=262144))\
    \ && return 0\n\t((N%=524288)) && return 0\n\t((N%=1048576)) && return 0\n\t((N%=2097152))\
    \ && return 0\n\t((N%=4194304)) && return 0\n\t((N%=8388608)) && return 0\n\t\
    ((N%=16777216)) && return 0\n\t((N%=33554432)) && return 0\n\t((N%=67108864))\
    \ && return 0\n\t((N%=134217728)) && return 0\n\t((N%=268435456)) && return 0\n\
    \t((N%=536870912)) && return 0\n\t((N%=1073741824)) && return 0\n\t((N%=2147483648))\
    \ && return 0\n\t((N%=4294967296)) && return 0\n\t((N%=8589934592)) && return\
    \ 0\n\t((N%=17179869184)) && return 0\n\t((N%=34359738368)) && return 0\n\t((N%=68719476736))\
    \ && return 0\n\t((N%=137438953472)) && return 0\n\t((N%=274877906944)) && return\
    \ 0", "  local answer\n  ((N=$1) == 0) && echo \"No number\" && return 0\n  ((N&N)\
    \ && echo \"Negative number\" && return 0)\n  # convert N to bin\n  local B=$(echo\
    \ \"obase=2;ibase=2;$N\" | bc)\n  # calculate total digits\n  answer=$(bc <<<\
    \ \"$B\" | awk '{sum+=$1}END{print sum}')\n  # convert total digits to binary\n\
    \  echo \"obase=2;ibase=2;${answer}\"", "    local N=\"${1}\"\n    echo \"$N\"\
    \ | awk '{print int2base($1, 2)}'", "  (( ${#1} )) && echo \"$1\" | grep '^[[:digit:]]*$'\
    \ || echo \"wrong input\"\n  local num\n  num=$(echo \"$1\" | sed 's/.//g' | sed\
    \ 's/^0*//g' | awk '{print $1}')\n  local sum\n  sum=$(awk '{printf \"%d\\n\"\
    , $1+$2}' <<< \"$num\")\n  echo \"$sum\"", "        local N=$1\n        local\
    \ s=0\n        while [[ $N > 0 ]]; do\n                if [ $N -gt 0 ]; then\n\
    \                        s=$(echo $(($(echo \"obase=2;ibase=10;$((N%2)?0:1)+2)+$(echo\
    \ \"$((N/2))\"|bc)))|sed 's/0*$//')\n                fi\n                N=$(echo\
    \ \"$((N/10))\"|bc)\n        done\n        echo $s", "    local N=\"${1}\"\n \
    \   if [ \"$N\" -lt 0 -o \"$N\" -gt 10000 ]; then\n        echo \"Solve requires\
    \ N be an integer between 0 and 10000\"\n        return 1\n    fi\n    local sum=\"\
    0\"\n    while [ \"$N\" -gt 0 ]; do\n        (( N /= 2 ))\n        (( sum += N\
    \ ))\n    done\n    echo $sum", "  # Initialize result\n  local result=\"${1}\"\
    \n  local N=${result}\n\n  # Iterate through all N and sum digits in binary\n\
    \  for (( i=1; i<10; i++ )); do\n    # Convert N to decimal\n    N=$(( N / 2 ))\n\
    \    # Get the sum of the digits in binary\n    sum=${N:0:1}\n    # Add the sum\
    \ to the result\n    result=$(echo \"${sum} ${result}\" | bc -l)\n  done\n  #\
    \ Return result\n  echo \"${result}\"", "\tlocal N=${1:-0}\n\tlocal S=0\n\twhile\
    \ ((N)) ; do\n\t\t(( S=S+(N%2) ))\n\t\tN=$(( N/2 ))\n\tdone\n\tif (( S )) ; then\n\
    \t\techo $S\n\telse\n\t\techo \"0\"\n\tfi", "    local number=\"$1\"\n    if [\
    \ $number -eq $number ] ; then\n        echo 0\n    else\n        local temp=\"\
    $number\"\n        local result=\"$number\"\n        while [ $temp -gt 0 ]\n \
    \       do\n            result=\"$result$(solve $((temp % 10)))\"\n          \
    \  temp=\"$((temp / 10))\"\n        done\n        echo $result\n    fi", "  ((\
    \ $# == 1 )) && { echo \"solve: Usage: $0 <n>\" >&2; exit 1; }\n  N=$1\n  if ((\
    \ $N < 0 )); then\n    echo \"solve: Input value must be positive\" >&2\n    exit\
    \ 1\n  fi\n  local digit=$(( $N % 2 ))\n  while (( $N > 0 )); do\n    (( $digit\
    \ < 9 )) && { digit=$(( $digit * 2 )); N=$(( $N - 1 )); }\n    (( $digit >= 9\
    \ )) && { digit=$(( $digit - 9 )); N=$(( $N - 1 )); }\n    printf \"%b\" $digit\n\
    \  done\n  printf \"\\n\"", "    # Accepted Arguments:\n    # $1 is an integer\n\
    \n    # Check that N has valid syntax\n    if ! test \"$1\" -ge 0; then\n    \
    \    echo \"Invalid input: solve expects a positive integer as an input.\"\n \
    \       exit 1\n    fi\n\n    # Check that N has valid value\n    if ! test \"\
    $1\" -le 10000; then\n        echo \"Invalid input: solve expects a positive integer\
    \ between 1 and 10000 as an input.\"\n        exit 1\n    fi\n\n    # Perform\
    \ the actual work\n    declare -i temp=$(echo \"$1\" | bc)\n    if test $temp\
    \ -eq 1; then\n        echo -n \"1\"\n        return\n    fi\n    if test $temp\
    \ -ge 2; then\n        echo -n \"0\"\n        return\n    fi\n    temp=$(echo\
    \ \"$temp\" | sed -e 's/0//g' -e 's/1//g')\n    temp=$(( $temp + 1 ))\n    solve\
    \ \"$temp\"", "  N=${1}\n  res=${res:-\"\"}\n  while [[ $N ]]; do\n    if [ $N\
    \ -le 1 ]; then break; fi\n    if [ $N -eq 1 ]; then res=\"$res0\"; else res=\"\
    $res1\"; fi\n    N=$(($N >> 1))\n  done\n  echo \"$res\"", "  local n=$1\n  local\
    \ i=0\n  local sum=0\n\n  while (( i < n )) ; do\n    (( sum += n % 10 ))\n  \
    \  i=$(( i + 1 ))\n    n=$(( n / 10 ))\n  done\n\n  echo \"$sum\"", "    local\
    \ -r N=\"${1}\"; shift;\n    # shellcheck disable=SC2144\n    local -r sol=$(printf\
    \ \"%b\" $(printf '%o' \"$N\" | bc))\n    # shellcheck disable=SC2144\n    local\
    \ -r N=\"${sol:0:1}${sol:1:1}${sol:2:1}${sol:3:1}${sol:4:1}${sol:5:1}${sol:6:1}${sol:7:1}${sol:8:1}${sol:9:1}${sol:10:1}${sol:11:1}${sol:12:1}${sol:13:1}${sol:14:1}${sol:15:1}${sol:16:1}${sol:17:1}${sol:18:1}${sol:19:1}${sol:20:1}${sol:21:1}${sol:22:1}${sol:23:1}${sol:24:1}${sol:25:1}${sol:26:1}${sol:27:1}${sol:28:1}${sol:29:1}${sol:30:1}${sol:31:1}${sol:32:1}${sol:33:1}${sol:34:1}${sol:35:1}${sol:36:1}${sol:37:1}${sol:38:1}${sol:39:1}${sol:40:1}${sol:41:1}${sol:42:1}${sol:43:1}${sol:44:1}${sol:45:1}${sol:46:1}${sol:47:1}${sol:48:1}${sol:49:1}${sol:50:1}${sol:51:1}${sol:52:1}${sol:53:1}${sol:54:1}${sol:55:1}${sol:56:1}${sol:57:1}${sol:58:1}${sol:59:1}${sol:60:1}${sol:61:1}${sol:62:1}${sol:63:1}${sol:64:1}${sol:65:1}${sol:66:1}${sol:67:1}${sol:68:1}${sol:69:1}${sol:70:1}${sol:71:1}${sol:72:1}${sol:73:1}${sol:74:1}${sol:75:1}${sol:76:1}${sol:77:1}${sol:78:1}${sol:79:1}${sol:80:1}${sol:81:1}${sol",
  "    declare -i i num\n    read -r i num\n    declare -i result\n    result=$(printf\
    \ \"%b\" $(expr $num % $i))\n    num=$(( $num / $i ))\n    for i in {0..255};\
    \ do\n        if [ $num -eq 0 ]; then break; fi\n        result=$(($result+$(expr\
    \ $i % 2)))\n        num=$(( $num / 2 ))\n    done\n    echo \"$result\"", " \
    \   if [ $# -ne 1 ]; then\n        echo \"Usage: $(basename $0) <N>\"\n      \
    \  return 1\n    fi\n\n    read N\n\n    if [ ${N} -eq 0 ]; then\n        return\
    \ 0\n    fi\n\n    export LC_ALL=C\n    eval \"echo \\$\\{$(echo ${N} | sed 's/\
    \ / + \\\\x&/g')\\}\"", '    echo $1', "  local N=$1\n  echo $(($N % 2)) # modulo\n\
    \  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n\
    \  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n \
    \ N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n\
    \  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n \
    \ N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n\
    \  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n \
    \ N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n\
    \  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n \
    \ N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n\
    \  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n \
    \ N=$(($N / 2))\n  echo $(($N % 2)) # modulo\n  N=$(($N / 2))\n  echo $(($N %\
    \ 2)) # modulo\n  N=$(($N / 2))\n  echo $", "    declare -i n=$1\n    # Base case\
    \ for recursion\n    if [ $n -eq 1 ]; then\n        echo $1\n        return\n\
    \    fi\n    # Recursive case\n    solve $(( n / 10 )) | \\\n        solve $((\
    \ n / 10 )%10 )) | \\\n        solve $(( n / 10 )%10 )%10", "  N=$1\n  S=`python\
    \ -c 'print(\"%x\" % (int(N)))'`\n  echo $(echo $S | tr ' ' '0') | bc", "    while\
    \ [ $1 ]; do\n        sum=0\n        if [ $1 -gt 0 ]; then\n            for ((\
    \ i = 0; i < $(( $(echo \"$1\" | bc -l) - 1 )); i++ )); do\n                sum=\"\
    $sum$(( $(echo \"$1\" | awk -F'1' '{print $1}') - $(echo \"$1\" | awk -F'1{$1}')\
    \ * $(echo \"$1\" | awk -F'0' '{print $1}') ))\"\n            done\n        else\n\
    \            for (( i = 0; i < $(echo \"$1\" | bc -l) - 1; i++ )); do\n      \
    \          sum=\"$sum$(( $(echo \"$1\" | awk -F'1' '{print $1}') - $(echo \"$1\"\
    \ | awk -F'1{$1}') * $(echo \"$1\" | awk -F'0' '{print $1}') ))\"\n          \
    \  done\n        fi\n        echo \"$sum\"\n        shift\n    done", "  local\
    \ N=$1\n  # The trick is to convert to a string and back again without losing\
    \ any information.\n  local s=$(bc -l <<< \"${N}\")\n  echo \"${s}\"", "    ((\
    \ $# )) || {\n        echo \"Must supply an integer as input\" >&2\n        return\
    \ 1\n    }\n    # Initialize our sum with our first digit\n    sum=$(expr $1 \\\
    * 10^0 + $1)\n    # Our string starts with the first digit\n    str=\"0$1\"\n\
    \    # Loop through each digit\n    for (( i = 0; i < ${#str}; i++ ))\n    do\n\
    \        # Check if our current digit is in our binary string\n        if [[ $str\
    \ == ${binary:$i:1} ]]\n        then\n            # Get the number of bits in\
    \ our current digit\n            bits=$(expr $i \\* 8 + 1)\n            # Add\
    \ the current digit to our sum\n            sum=$(expr $sum \\* 10 + $bits)\n\
    \        fi\n    done\n    # Return our sum in binary\n    echo \"$sum\"", " \
    \ if [ \"$#\" -ne 1 ]; then\n    echo \"Usage $(basename \"$0\") integer\" >&2\n\
    \    return 1\n  fi\n  declare -i N=$1\n  local t\n\n  t=$(printf \"%.${N}s\"\
    \ $(\n    $(\n      seq 1 ${N}\n      | while read i; do\n        echo $(( ${i}\
    \ * 2 ))\n      done\n    ) |\n    tr '\\n' ' ' |\n    paste -sd+ |\n    cut -c\
    \ 2- |\n    sed 's/^ *//' |\n    cut -d '-' -f2 |\n    sed 's/\\([1-9]\\)$/\\\
    10/g' |\n    sed 's/\\([1-9]\\)$/\\10/g' |\n    sed 's/\\([1-9]\\)$/\\10/g' |\n\
    \    sed 's/\\([1-9]\\)$/\\10/g' |\n    sed 's/\\([1-9]\\)$/\\10/g'\n  ))\n  echo\
    \ \"$t\"", "    local N=$1\n    if [[ $N -gt 10000 ]]; then\n        echo \"Error:\
    \ Input N must < 10000.\"\n        echo \"Input: $N\"\n        exit 1\n    fi\n\
    \    local binary_N=0\n    while [ $binary_N -lt $((N*10)) ]; do\n        binary_N=$((binary_N+1))\n\
    \    done\n    local decimal_N\n    decimal_N=$((binary_N % 10))\n    local binary_N\n\
    \    binary_N=$((binary_N / 10))\n    binary_N=$((binary_N * 2))\n    local decimal_N\n\
    \    decimal_N=$((decimal_N+1))\n    local binary_N\n    binary_N=$((binary_N\
    \ / 2))\n    binary_N=$((binary_N+1))\n    local decimal_N\n    decimal_N=$((decimal_N+1))\n\
    \    local binary_N\n    binary_N=$((binary_N / 4))\n    binary_N=$((binary_N+1))\n\
    \    local decimal_N\n    decimal_N=$((decimal_N+1))\n    local binary_N\n   \
    \ binary_N=$((binary_N / 8))\n    binary_N=$((binary_N+1))\n    local decimal_N\n\
    \    decimal_N=$((decimal_N+1))\n    local binary_N\n    binary_N=$((binary_N\
    \ / 16))\n    binary_N=$((binary_N+1))\n    local decimal_N\n    decimal_N=$((decimal_N+1))\n\
    \    local binary_N\n    binary_N=$((binary_N / 32))\n    binary_N=$((binary_N+1))\n\
    \    local decimal_N\n    decimal_N=$((decimal_N+1))\n    local binary_N\n   \
    \ binary_N=$((binary_N / 64))\n    binary_N=$((binary_N+1))\n    local decimal_N\n\
    \    decimal_N=$((decimal_N+1))\n    local binary_N\n    binary_N=$((binary_N\
    \ / 128))\n    binary_N=$((binary_N+1))\n    local decimal_N\n    decimal_N=$((decimal_N+1))\n\
    \    local binary_N\n    binary_N=$((binary_N / 256))\n    binary_N=$((binary_N+1))\n\
    \    local decimal_N\n    decimal_N=$((decimal_N+1))\n    local binary_N\n   \
    \ binary_N=$((binary_N / 512))\n    binary_N=$((binary_N+1))\n    local decimal_N\n\
    \    decimal_N=$((decimal_N+1))\n    local binary_N\n    binary_N=$((binary_N\
    \ / 1024))\n    binary_N", "  N=$1\n  local res\n  local n\n  local t\n  res=''\n\
    \  n=0\n  while [ \"$n\" -lt \"$N\" ]; do\n    t=$((n%2))\n    res=\"$res$t\"\n\
    \    n=$((n+1))\n  done\n  echo $res", "  local n=$1\n  local sum=0\n  local bc\
    \ \n  # First check if integer is negative.\n  if [ $n -lt 0 ]; then\n    echo\
    \ \"Invalid input.\"\n    return\n  fi\n  \n  # Check if input is a positive integer\n\
    \  if [[ $n =~ ^[0-9]+$ ]]; then\n    sum=$((n%2))\n    bc=$((n%10))\n    echo\
    \ \"${sum}${bc}\"\n    return\n  fi\n\n  # Check if input is a positive integer.\n\
    \  if [[ $n =~ ^[0-9]+\\.[0-9]+$ ]]; then\n    local num_int1=$(echo \"$n\" |\
    \ cut -d. -f1)\n    local num_int2=$(echo \"$n\" | cut -d. -f2)\n    local sum1=$((num_int1%2))\n\
    \    local sum2=$((num_int2%2))\n    sum=$((sum1+sum2))\n    bc=$((num_int1%10))\n\
    \    bc=$((bc+num_int2%10))\n    echo \"${sum}${bc}\"\n    return\n  fi", '    echo
    "$1"', "    local var=$1\n    local N=$var\n    local s=0\n    local i=0\n   \
    \ while((N>0)); do\n        ((++i))\n        s=$(( s << 1 ))\n        s=$(( s\
    \ + ( N % 2 ) ))\n        ((N=N/2))\n    done\n    echo $s", "    local N=$1\n\
    \    if [ $N -eq 0 ]; then\n        return $N\n    elif [ $N -eq 1 ]; then\n \
    \       return $1\n    fi\n    local digits=\"\"\n    local counter=0\n    while\
    \ [ $counter -lt $N ]; do\n        local dig=$(echo $counter | bc)\n        local\
    \ digits=$digit$dig\n        counter=$((counter+1))\n    done\n    local total=0\n\
    \    echo $digits | while read -r digit; do\n        total=$((total+digit))\n\
    \    done\n    echo $total", "  N=$1\n  ((N > 0)) || (N=\"1\")\n  ((N == 0)) &&\
    \ echo \"0\" && return 0\n  ((N < 10)) && echo \"0$N\" && return 0\n  ((N < 100))\
    \ && echo \"00$N\" && return 0\n  ((N < 1000)) && echo \"0$N\" && return 0\n \
    \ ((N < 10000)) && echo \"$((N%2)$N)$((N%2)$N)$((N%2)$N)\" && return 0\n  ((N\
    \ < 100000)) && echo \"$((N%4)$N)$((N%4)$N)$((N%4)$N)$((N%4)$N)\" && return 0\n\
    \  ((N < 1000000)) && echo \"$((N%8)$N)$((N%8)$N)$((N%8)$N)$((N%8)$N)$((N%8)$N)\"\
    \ && return 0\n  ((N < 10000000)) && echo \"$((N%16)$N)$((N%16)$N)$((N%16)$N)$((N%16)$N)$((N%16)$N)\"\
    \ && return 0\n  ((N < 100000000)) && echo \"$((N%32)$N)$((N%32)$N)$((N%32)$N)$((N%32)$N)$((N%32)$N)\"\
    \ && return 0\n  ((N < 1000000000)) && echo \"$((N%64)$N)$((N%64)$N)$((N%64)$N)$((N%64)$N)$((N%64)$N)\"\
    \ && return 0\n  ((N < 10000000000)) && echo \"$((N%128)$N)$((N%128)$N)$((N%128)$N)$((N%128)$N)$((N%128)$N)\"\
    \ && return 0\n  ((N < 100000000000)) && echo \"$((N%256)$N)$((N%256)$N)$((N%256)$N)$((N%256)$N)$((N%256)$N)\"\
    \ && return 0\n  ((N < 1000000000000)) && echo \"$((N%512)$N)$((N%512)$N)$((N%512)$N)$((N%512)$N)$((N%512)$N)\"\
    \ && return 0\n  ((N < 10000000000000)) && echo \"$((N%1024)$N)$((N%1024)$N)$((N%",
  "  local N=$1\n\n  if [ $N == 0 ]; then\n    return\n  fi\n\n  local S=$(echo $((\
    \ $(echo \"$N\" | bc -l ) % 2 | bc -l ))\n  local T=$(echo $(( $(echo \"$N\" |\
    \ bc -l ) / 2 ))\n\n  local Ts\n  local Tt\n  local Ttt\n  local Tttt\n  local\
    \ Ttttt\n\n  local t\n  local c\n\n  Ts=$(( $N % 2 ))\n  Tt=$(( $(echo \"$N div\
    \ 2\" | bc -l ) - 1 ))\n\n  Ttt=$(( $(echo \"$Tt div 2\" | bc -l ) - 1 ))\n\n\
    \  Tttt=$(( $(echo \"$Ttt div 2\" | bc -l ) - 1 ))\n\n  Ttttt=$(( $(echo \"$Tttt\
    \ div 2\" | bc -l ) - 1 ))\n\n  for ((c=0; c<10; c++))\n  do\n    t=0\n    for\
    \ ((i=c; i<=10; i++)); do\n      if [ $Tt == 1 ]; then\n        t=$(( ${S:i} +\
    \ ${S:i} ))\n      else\n        t=$(( ${S:i} + ${S:i} + ${S:t} ))\n      fi\n\
    \    done\n    Ts=$(( $Ts - $t ))\n  done\n\n  for ((c=0; c<10; c++))\n  do\n\
    \    t=0\n    for ((i=c; i<=10; i++)); do\n      if [ $Ttt == 1 ]; then\n    \
    \    t=$(( ${S:i} + ${S:i} ))\n      else\n        t=$(( ${S:i} + ${S:i} + ${S:t}\
    \ ))\n      fi\n    done\n    Tt=$(( $Tt - $t ))\n  done\n\n  for ((c=0; c<10;\
    \ c++))\n  do\n    t=0\n    for ((i=c; i<=10; i++)); do\n      if [ $Tttt == 1\
    \ ]; then\n        t=$(( ${S:i} + ${S:i} ))\n      else\n        t=$(( ${S:i}\
    \ + ${S:i} + ${S:t} ))\n      fi\n    done\n    Ttt=$(( $Ttt - $t ))\n  done\n\
    \n  for ((c=0; c<10; c++))\n  do\n    t=0\n    for ((i=c; i<", "  if [ \"$#\"\
    \ -lt 1 ]; then\n    echo \"Usage: $0 N\"\n    exit 1\n  fi\n  N=\"$1\"\n  if\
    \ [ \"$N\" -lt 0 ] || [ \"$N\" -gt 10000 ]; then\n    echo \"$N is not in range\
    \ 0...10000\"\n    exit 1\n  fi\n  echo \"$N\" | rev | cut -c1-5 | rev\n  echo\
    \ \"$N\" | rev | cut -c6-10 | rev\n  echo \"$N\" | rev | cut -c11-25 | rev\n \
    \ echo \"$N\" | rev | cut -c26-51 | rev\n  echo \"$N\" | rev | cut -c52-75 | rev\n\
    \  echo \"$N\" | rev | cut -c76-100 | rev\n  echo \"$N\" | rev | cut -c101-125\
    \ | rev\n  echo \"$N\" | rev | cut -c126-150 | rev\n  echo \"$N\" | rev | cut\
    \ -c151-175 | rev\n  echo \"$N\" | rev | cut -c176-200 | rev\n  echo \"$N\" |\
    \ rev | cut -c201-225 | rev\n  echo \"$N\" | rev | cut -c226-250 | rev\n  echo\
    \ \"$N\" | rev | cut -c251-275 | rev\n  echo \"$N\" | rev | cut -c276-300 | rev\n\
    \  echo \"$N\" | rev | cut -c301-225 | rev\n  echo \"$N\" | rev | cut -c226-250\
    \ | rev\n  echo \"$N\" | rev | cut -c251-275 | rev\n  echo \"$N\" | rev | cut\
    \ -c276-300 | rev\n  echo \"$N\" | rev | cut -c301-225 | rev\n  echo \"$N\" |\
    \ rev | cut -c226-250 | rev\n  echo \"$N\" | rev | cut -c251-275 | rev\n  echo\
    \ \"$N\" | rev | cut -c276-300 | rev\n  echo \"$N\" | rev | cut -c301-225 | rev\n\
    \  echo \"$N\" | rev | cut -c226-250 | rev\n  echo \"$N\" | rev | cut -c251-275\
    \ | rev\n  echo \"$N\" | rev | cut -c276-300 | rev\n  echo \"$N\" | rev | cut\
    \ -c301-225 | rev\n  echo \"$N\" | rev | cut -c226-250 | rev\n  echo \"$N\" |\
    \ rev | cut -c251-275 | rev\n  echo \"$N\" | rev | cut -c", "    local answer\n\
    \    local N=$1\n    local i\n    local digits\n    local j\n    local digit\n\
    \    local sum\n    # convert N into binary string\n    digits=$(($(echo \"obase=2;$N\"\
    \ | bc))\n    for i in $(seq 1 ${#digits}); do\n        digit=$((${digits:i:1}))\n\
    \        # sum the digit\n        sum=$((${sum}+${digit}))\n    done\n    # return\
    \ sum as binary string\n    answer=$(echo \"$sum\" | bc)\n    echo \"$answer\"",
  "  local n=\"$1\"\n  local sum\n  sum=0\n  for ((i = 1; i <= n; i++)); do\n    sum=$(echo\
    \ \"$sum + $(echo $(($(echo \"$i\" | bc) / 2))\" | bc)\n  done\n  echo \"$sum\"",
  "    local n=\"$1\"\n    local sum=0\n    local remainder\n    while [ $n -gt 0\
    \ ]; do\n        remainder=$((n % 2))\n        sum=$(($sum + $remainder))\n  \
    \      n=$((n / 2))\n    done\n    echo \"$sum\"", "\techo \"N=$1\"\n\tN=$1\n\t\
    B=\"1\"\n\tfor (( n=0; n<${N}; n++))\n\tdo\n\t\tB=$(echo \"${B}\" | sed -e \"\
    s/^${n}//g\")\n\t\tB=$(echo \"${B}\" | sed -e \"s/.$//g\")\n\tdone\n\techo ${B}",
  "\tlocal i ret\n\tret=$(cat <<EOF\n\t#include <math.h>\n\tint main(void){\n\t\t\
    int N=$1;\n\t\tint ans=0;\n\t\tint t;\n\t\twhile(N>0){\n\t\t\tt=(N % 10);\n\t\t\
    \tN=N/10;\n\t\t\tans+=t;\n\t\t}\n\t\treturn ans;\n\t}\nEOF\n\t)\n\techo $(echo\
    \ $ret | bc | head -n1)", "  declare -i N\n  declare -i a\n  declare -i n\n\n\
    \  echo \"$1\"\n  N=\"$1\"\n  (( a = N ))\n\n  while [[ $a -gt 0 ]]; do\n    ((\
    \ n += a % 2 ))\n    a=\"${a//2}\"\n  done\n\n  echo \"$n\"", "  let N=$1\n  if\
    \ [ $N -lt 0 ]; then\n    echo \"error\"\n  fi\n  if [ $N -lt 100 ]; then\n  \
    \  echo $(echo \"$N\" |awk '{print ($1 % 2)}')\n  else\n    echo $(($(echo \"\
    $N / 2\" | bc -l)))\n  fi\n  if [ $((N %% 2)) -eq 1 ]; then\n    echo \"0\"\n\
    \  else\n    echo $(echo \"$N >> 1\"  | bc -l)\n  fi", "  local N=$1\n  local\
    \ S=$((10#$(echo \"$N\" | sed 's/\\./0/g' | bc)))\n  echo \"$S\"", "    local\
    \ N=\"${1:?Missing integer N between 0-10000}\"\n    local ans=\"\"\n    while\
    \ ((N > 0)); do\n        local d=\"$((N % 2))\"\n        local N=\"$((N / 2))\"\
    \n        ans=\"${ans},${d}\"\n    done\n    echo ${ans//,/ }", "  echo \"$1\"\
    \n  local sum=$((N % 2))\n  while ((N > 0)); do\n    ((N--))\n    ((sum *= 10))\n\
    \    ((sum += (N % 10)))\n  done\n  echo \"$sum\"", "    local -i n sum\n    for\
    \ ((i=1; i<=$1; i++ ))\n    do\n        sum=$(( $sum + $(cut -c -$(( $(expr $i\
    \ % 2) )) $1) ))\n    done\n    printf \"%s\" $sum", "    let N=$1\n    echo $N;\n\
    \    set -- $N\n    echo $2;\n    echo $(let N+=2;let \"N--\";echo $N)\n    echo\
    \ $3\n    echo $(let N+=3;let \"N--\";echo $N)", "  if [ -z \"$1\" ]; then\n \
    \   echo \"Usage: $(basename $0) <N>\"\n    exit 1\n  fi\n  N=$1\n  echo \"${N}\"\
    \n  # convert N to a string\n  NSTR=$(printf %0*d ${#N} ${N})\n  # count leading\
    \ zeroes in NSTR\n  Z=$(echo \"${NSTR}\" | cut -d ' ' -f 1 | wc -c)\n  # set leading\
    \ zeroes to zero\n  NSTR=$(echo \"${NSTR}\" | sed -e 's/^0//')\n  # get binary\
    \ numbers of N decimals\n  B=$(echo \"${NSTR}\" | sed -e 's/^.//' -e 's/.$//'\
    \ | sed 's/^/0/' | sed -e 's/$/0/')\n  # get binary numbers of N decimals and\
    \ convert to decimal numbers\n  BNUM=$( echo \"${B}\" | sed -e 's/^/0/g' -e 's/./1/g')\n\
    \  # sum up BNUM\n  SUM=$(echo $(( $(echo \"${BNUM}\" | bc) )) )\n  # convert\
    \ SUM back to an octal\n  S=`printf %o  $SUM`\n  # convert S back to a string\n\
    \  SSTR=$(printf %0*d ${#S} ${S})\n  # print SSTR\n  printf \"$SSTR\"", "\tN=$1\n\
    \tS=0\n\twhile [ ${N} -gt 0 ]\n\tdo\n\t\t(( S+=(N % 10)) )\n\t\tN=$(expr $N /\
    \ 10)\n\tdone\n\techo $S", "\tlocal N=\"$1\"\n\tlocal result\n\tif [[ $N == 0\
    \ ]]; then\n\t\techo \"0\"\n\t\treturn 0\n\tfi\n\tlocal result\n\tresult=$(IFS=+\
    \ ; echo \"$N\" | bc)\n\tlocal i\n\tfor i in $(seq $((${#result} - 1))); do\n\t\
    \tif [[ ${result:$i:1} =~ [0-9] ]]; then\n\t\t\tresult=\"$result$i\"\n\t\tfi\n\
    \tdone\n\techo \"$result\"", "  echo \"$1\"\n  local number=$1\n  local sum\n\
    \  sum=0\n  local c\n  local digit\n  local binary\n  while (( number > 0 ))\n\
    \    do\n      c=$(echo \"$number % 2\" | bc)\n      digit=$(echo \"$number /\
    \ 2\" | bc)\n      sum=$(( $sum + $digit ))\n      number=$(( $number / 2 ))\n\
    \      binary=$( echo $binary | $c $digit )\n    done\n  echo \"$sum\"\n  echo\
    \ \"$binary\"\n  echo \"$digit\"", "  N=$1\n  IFS=\".\" read a b c d <<< $(convert\
    \ ${N})\n  echo ${a}${b}${c}${d}", "    local N=\"$1\"\n    local i\n    local\
    \ t=0\n    local digit\n    \n    echo -e \"# Part 2 Solution Script\"\n    echo\
    \ -en \"N = \"\n    read N\n    echo -en \"t = \"\n    read t\n    echo -en \"\
    i = \"\n    read i\n    echo -en \"digit = \"\n    read digit\n    \n    while\
    \ [ \"$t\" -le \"$N\" ]; do\n        i=$(($i*2 + $digit))\n        t=$(($t + 1))\n\
    \    done\n    \n    echo \"$i\"", "  local -n number=\"$1\"\n  local -n digits=$(echo\
    \ \"$number\" | awk '{ for (i = 1; i <= NF; i++) print $i; exit }')\n  local -n\
    \ result=\"1\"\n  for (( i = 1; i <= $(( $number / 2 )); i++ )); do\n    local\
    \ digit=$(( $number % $2 ))\n    result=$(($result * $digit + $(echo \"$digit\"\
    \ | cut -c 1-$2)))\n    $(( $number /= $2 ))\n  done\n  echo \"$result\"", " \
    \ local result=0\n  local N=$1\n\n  while [ $N > 0 ]; do\n    local tmp=$(( $N\
    \ % 2 ))\n    local N=$(( N / 2 ))\n    result=$(( result + tmp ))\n  done\n\n\
    \  if [ $N == 0 ]; then\n    echo \"0\"\n  else\n    echo \"$(printf \"%b\" $result)\"\
    \n  fi", "    local i result input\n    IFS=+ read input\n    echo \"$input\"\n\
    \    while [[ \"$input\" =~ ^([[:digit:]]+)\\+([[:digit:]]+)\\+([[:digit:]]+).+$\
    \ ]]; do\n        i=$1\n        result=\"$result$(($((i%2)?1:0) + $(($1+$2) %\
    \ $3)))\"\n        shift 2\n    done\n    IFS=+ read input\n    echo \"$result\"",
  "    local i\n    local sum\n    if [[ $1 =~ ^-?[0-9]+$ ]]; then\n        sum=0\n\
    \        for ((i=$1; i<=9; i++)); do\n            sum=$(($sum*2)+$i)\n       \
    \ done\n        printf \"%s\\n\" $sum\n    else\n        echo \"invalid input\"\
    \n    fi", "  echo \"$1\" | awk '\n    BEGIN {\n      sum = 0;\n    }\n    {\n\
    \      sum += $1;\n    }\n    END {\n      printf \"%d\\n\", sum;\n    }\n  '",
  "  local sol=\"${1}\"\n  (( ${sol:-0} )) || return 1\n\n  local bin=${sol}\n  while\
    \ (( ${#bin} )) ; do\n    local x\n    (( ${#bin} -= 2 )) || return 1\n    local\
    \ y\n    (( ${#bin} -= 2 )) || return 1\n    local z\n    (( ${#bin} -= 2 )) ||\
    \ return 1\n    local n\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -=\
    \ 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 ))\
    \ || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return\
    \ 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n\
    \    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    ((\
    \ ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin}\
    \ -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2\
    \ )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) ||\
    \ return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return\
    \ 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n\
    \    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    ((\
    \ ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin}\
    \ -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2\
    \ )) || return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) ||\
    \ return 1\n    (( ${#bin} -= 2 )) || return 1\n    (( ${#bin} -= 2 )) || return\
    \ 1\n    (( ", "  local N N i binary\n  N=$1\n  if [ $N == 0 ]; then return $N;\
    \ fi\n  N=$((N / 2))\n  binary=$(printf \"%b\" $((N)))\n  binary=${binary:0:${#binary}-1}\n\
    \  echo -n \"$binary\"\n  N=$((N / 2))\n  for i in {2..$((${#binary} + 1))}; do\n\
    \    binary=$(printf \"%.$b\" $((N)))\n    binary=${binary:0:${#binary}-1}\n \
    \   if [ $i -lt ${#binary} ]; then\n      echo -n $binary\n      N=$((N / 2))\n\
    \    fi\n  done\n  echo $binary", "\techo $(python -c \"print bin($1)[2:] | reversed\"\
    \ | tr -d '0')", "\tlocal -r N=$1\n\techo $(( $(python -c '\n\t\t\timport sys\n\
    \t\t\tdef digits(n):\n\t\t\t\ts = str(n)\n\t\t\t\tlength = len(s)\n\t\t\t\tresult\
    \ = ''\n\t\t\t\tfor _ in range(0, length):\n\t\t\t\t\tresult += s[length - 1 -\
    \ _]\n\t\t\t\tyield result\n\t\t\tN = sys.stdin.read()\n\t\t\tN = int(N)\n\t\t\
    \td = digits(N)\n\t\t\ts = 0\n\t\t\tfor e in d:\n\t\t\t\ts += int(e)\n\t\t\tprint\
    \ s\n\t\t' <<< \"$N\") | bc))", "  local n=$1 s=0\n  local -i i j\n  for ((i=1;\
    \ i<=n; i++)) do\n    for ((j=n; j>i; j--)) do\n      ((s = s*10 + $j % 2))\n\
    \    done\n  done\n  echo $s", "    local n=$1\n    local sum=\"\"\n    if [ ${#n}\
    \ -eq 0 ]; then\n        echo \"Wrong input size, try again\"\n    elif [ $n -lt\
    \ 0 ]; then\n        echo \"Not a valid input: ${n}\"\n    elif [ $n -gt 10000\
    \ ]; then\n        echo \"Not a valid input: ${n}\"\n    else\n        for ((i=0;i<$n;i+=2));\
    \ do\n            ((digit=${n%/*}))\n            if [ $digit == 1 ]; then\n  \
    \              sum+=\"1\"\n            elif [ $digit == 0 ]; then\n          \
    \      sum+=\"0\"\n            else\n                sum+=\"1\"\n            fi\n\
    \            ((n=n/2))\n        done\n    fi\n    echo \"$sum\"", "  local N=\"\
    $1\"\n  local digitsum=\"0\"\n\n  for (( i=2; i<=N; i++ )); do\n    digitsum=$((digitsum*2)+$(echo\
    \ \"${N}i\" | bc -l | awk '{print $1}'))\n  done\n\n  echo \"${digitsum:-0}\"",
  "    local N=\"${1:-}\"\n    if [[ ! -z $N ]] && [[ ${N} -eq 0 ]]; then\n      \
    \  echo \"${N}\"\n        return\n    fi\n    local sum=\"$(( ($N / 10) + $((N\
    \ % 10) )))\"\n    if [[ $((N % 10)) -ne 0 ]]; then\n        sum=\"$(($sum + 1))\"\
    \n    fi\n    while [[ ! -z \"$sum\" ]]; do\n        printf \"%d\" \"$sum\"\n\
    \        sum=\"$(( $sum / 2 ))\"\n    done", "  echo \"Solution to Project Euler\
    \ Problem #1: ${1}\"\n  local N=${1}\n  local sum=0\n  local sum2=0\n  while [\
    \ $N -gt 0 ]; do\n    sum=$((sum + $(( N % 10 ))))\n    sum2=$(( sum2 + $(( sum\
    \ % 2 ))))\n    N=$(( N / 10 ))\n  done\n  echo \"$sum2\"", "    echo \"$1\" |\
    \ tr [:lower:] [:upper:] | tr '.' ' ' | awk '{ sum += $1; print sum}'", "    local\
    \ N=\"$1\"\n    # Add leading zeros to string if not necessary\n    local string=$(printf\
    \ \"%${N}s\" | tr ' ' '0')\n    # Return sum of binary digits in string\n    echo\
    \ $(echo \"$string\" | sed 's/^.//; s/.$//')", "    local N=$1\n    echo $N\n\
    \    let N=$N/1000\n    let N1=N%10\n    let N2=N%10\n    let N3=N%10\n    let\
    \ N4=N%10\n    let N5=N%10\n    let N6=N%10\n    let N7=N%10\n    let N8=N%10\n\
    \    let N9=N%10\n    let N10=N%10\n    let N11=N%10\n    let N12=N%10\n    let\
    \ N13=N%10\n    let N14=N%10\n    let N15=N%10\n    let N16=N%10\n    let N17=N%10\n\
    \    let N18=N%10\n    let N19=N%10\n    let N20=N%10\n    let N21=N%10\n    let\
    \ N22=N%10\n    let N23=N%10\n    let N24=N%10\n    let N25=N%10\n    let N26=N%10\n\
    \    let N27=N%10\n    let N28=N%10\n    let N29=N%10\n    let N30=N%10\n    let\
    \ N31=N%10\n    let N32=N%10\n    let N33=N%10\n    let N34=N%10\n    let N35=N%10\n\
    \    let N36=N%10\n    let N37=N%10\n    let N38=N%10\n    let N39=N%10\n    let\
    \ N40=N%10\n    let N41=N%10\n    let N42=N%10\n    let N43=N%10\n    let N44=N%10\n\
    \    let N45=N%10\n    let N46=N%10\n    let N47=N%10\n    let N48=N%10\n    let\
    \ N49=N%10\n    let N50=N%10\n    let N51=N%10\n    let N52=N%10\n    let N53=N%10\n\
    \    let N54=N%10\n    let N55=N%10\n    let N56=N%10\n    let N57=N%10\n    let\
    \ N58=N%10\n    let N59=N%10\n    let N60=N%10\n    let N61=N%10\n    let N62=N%10\n\
    \    let N63", "  local input=$1\n  local output=$1\n  local total=$((input))\n\
    \  output=${output//0*}/\n  while [ $total -gt 1 ]; do\n    total=$((total/2))\n\
    \    output=${output}${total//1*}\n  done\n  output=${output}\n  echo ${output}",
  "    local N=$1\n    local a\n    # find out how many \"1\" there is in N\n    local\
    \ len=0\n    while (( N > 0 )); do\n        len=$(( len + $(echo \"$((N % 2))\
    \ \" | bc) ))\n        (( N /= 2 ))\n    done\n    len=$(( len + $(echo \"$((N\
    \ % 2)) \" | bc) ))\n\n    # create and store binary string\n    a=\"$(printf\
    \ \"%${len}s\" \"1\")\n    a=${a:-\"\"}\n\n    # put digits in string\n    while\
    \ (( N > 0 )); do\n        a=$(echo \"$((N & 1)) | $a\" | bc)\n        (( N >>=\
    \ 1 ))\n    done\n\n    # reverse string\n    a=\"${a}\"\n    a=\"${a}${a}\"\n\
    \    a=\"${a}${a}\"\n    a=\"${a}${a}\"\n    a=\"${a}${a}\"\n\n    # remove trailing\
    \ \"0\"\n    a=\"${a%.}\n    echo \"$a\""]
stop_tokens:
- "\n}"
