name: HumanEval_132_is_nested
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a string as input which contains\
  \ only square brackets.\n# The function should return true if and only if there\
  \ is a valid subsequence of brackets \n# where at least one bracket in the subsequence\
  \ is nested.\n# >>> $(is_nested \"[[]]\")\n# \"true\"\n# >>> $(is_nested \"[]]]]]]][[[[[]\"\
  )\n# \"false\"\n# >>> $(is_nested \"[][]\")\n# \"false\"\n# >>> $(is_nested \"[]\"\
  )\n# \"false\"\n# >>> $(is_nested \"[[][]]\")\n# \"true\"\n# >>> $(is_nested \"\
  [[]][[\")\n# \"true\"\n#\n# $1 is a string\nis_nested() {\n"
tests: "}\n\ncandidate() {\n    is_nested \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"[[]]\") = \"true\" ]]\n    [[ $(candidate \"[]]]]]]][[[[[]\") =\
  \ \"false\" ]]\n    [[ $(candidate \"[][]\") = \"false\" ]]\n    [[ $(candidate\
  \ \"[]\") = \"false\" ]]\n    [[ $(candidate \"[[[[]]]]\") = \"true\" ]]\n    [[\
  \ $(candidate \"[]]]]]]]]]]\") = \"false\" ]]\n    [[ $(candidate \"[][][[]]\")\
  \ = \"true\" ]]\n    [[ $(candidate \"[[]\") = \"false\" ]]\n    [[ $(candidate\
  \ \"[]]\") = \"false\" ]]\n    [[ $(candidate \"[[]][[\") = \"true\" ]]\n    [[\
  \ $(candidate \"[[][]]\") = \"true\" ]]\n    [[ $(candidate \"\") = \"false\" ]]\n\
  \    [[ $(candidate \"[[[[[[[[\") = \"false\" ]]\n    [[ $(candidate \"]]]]]]]]\"\
  ) = \"false\" ]]\n}\n\nrun_test"
completions: ["\tlocal opening_square_brackets\n\tlocal closing_brackets\n\tlocal\
    \ valid\n\topening_square_brackets=$(echo $1 | sed 's/\\[\\[\\[/\\[/g' | sed 's/\\\
    ]\\]\\]/\\]/g')\n\tclosing_brackets=$(echo $1 | sed 's/\\[/\\]/g' | sed 's/\\\
    ]\\[\\[/\\[/g')\n\tvalid=$(echo $1 | grep -E \"(\\[.*\\]\\])$opening_square_brackets$closing_brackets\"\
    \ | grep -vE \"(\\[.*\\])$opening_square_brackets$closing_brackets\")\n\techo\
    \ $valid", "    local -n line=\"${1}\"\n    local count=0\n    local openBrackets=''\n\
    \    local closeBrackets=''\n    local brackets=''\n\n    while [ -n \"$line\"\
    \ ]; do\n        if [[ $line == \\[* ]]; then\n            openBrackets=$((openBrackets+1))\
    \ \n        elif [[ $line == \\]* ]]; then\n            closeBrackets=$((closeBrackets+1))\
    \ \n        elif [[ $openBrackets -ge 1 ]] && [[ $closeBrackets -ge 1 ]]; then\n\
    \            brackets=$((brackets+1))\n        elif [[ $openBrackets -ge 1 ]];\
    \ then\n            brackets=$((brackets+1))\n        elif [[ $closeBrackets -ge\
    \ 1 ]]; then\n            brackets=$((brackets+1))\n        else\n           \
    \ brackets=$((brackets+1))\n        fi\n        line=\"${line//\\[\\([[:alpha:]]\\\
    )\\]/\\[\\\\$brackets\\\\]}\"\n    done\n\n    # echo \"$brackets\"\n    [[ $brackets\
    \ -ge 2 ]]", "    # remove square brackets\n    local string=${1:-}\n    # loop\
    \ over all characters in the string\n    for (( i=0; $i -lt ${#string}; i++ ));\
    \ do\n        # if we met a closing bracket, increment i\n        if [[ ${string[$i]}\
    \ == [\\] ]]; then\n            i=$(( i + 1 ))\n        fi\n        # if we met\
    \ a opening bracket, decrement i\n        if [[ ${string[$i]} == [\\[]]; then\n\
    \            i=$(( i - 1 ))\n        fi\n        # if i equals 0, we met the end\
    \ of the string\n        if [[ $i -eq 0 ]]; then\n            true\n        #\
    \ otherwise we met a bracket, but are no longer in range\n        elif [[ $i -lt\
    \ 0 ]]; then\n            false\n        fi\n    done", "    local char=\"$1\"\
    \ open=\"[\" close=\"]\" nest=\"\"\n    local count=0\n    local brackets=\"$1\"\
    \n\n    while [ $char ]; do\n        char=\"${char#?}\"\n        if [ $char ==\
    \ \"[\" ]; then\n            brackets=\"$brackets${open}\"\n            let count++\n\
    \        elif [ $char == \"]\" ]; then\n            brackets=\"$brackets${close}\"\
    \n            let count--\n            if [ $count -eq 0 ]; then\n           \
    \     nest=\"$brackets\"\n                break\n            fi\n        fi\n\
    \    done\n    echo $nest", "  local stack=\"[]\"\n  local i=\"1\"\n  local n\n\
    \  local s\n  local open=false\n  \n  for (( i=0; i<$1; i++ )); do\n    s=\"${1:$i:1}\"\
    \n    n=\"1\"\n    for (( j=i+1; j<$i && n; j++ )); do\n      if [[ \"${s:$j:1}\"\
    \ == [ ]]; then\n        n=\"0\"\n      elif [[ \"${s:$j:1}\" == \"[\" ]]; then\n\
    \        n=\"1\"\n        open=true\n      fi\n    done\n    \n    if [[ \"${n}\"\
    \ == \"1\" ]]; then\n      if [[ \"${open}\" == \"true\" ]]; then\n        stack=\"\
    ${stack:0:${#stack}-1}${stack:${#stack}+1}\"\n      fi\n    fi\n  done\n\n  if\
    \ [[ \"${stack}\" =~ ^\"[]\" ]]; then\n    echo \"true\"\n  else\n    echo \"\
    false\"\n  fi", "\tlocal brackets=0\n\tlocal char=0\n\tlocal bracket_count=0\n\
    \tlocal char_count=0\n\tlocal bracket_in_string=0\n\tlocal bracket_in_array=0\n\
    \tlocal bracket_in_object=0\n\tlocal bracket_in_array=2\n\tlocal bracket_in_object=3\n\
    \tlocal bracket_in_string=1\n\tlocal bracket_in_object=2\n\tlocal bracket_in_array=4\n\
    \tlocal bracket_in_string=2\n\tlocal bracket_in_object=4\n\tlocal bracket_in_string=3\n\
    \tlocal bracket_in_object=3\n\tlocal bracket_in_string=4\n\tlocal bracket_in_object=4\n\
    \tlocal bracket_in_string=5\n\tlocal bracket_in_object=5\n\tlocal bracket_in_string=6\n\
    \tlocal bracket_in_object=6\n\tlocal bracket_in_string=7\n\tlocal bracket_in_object=7\n\
    \tlocal bracket_in_string=8\n\tlocal bracket_in_object=8\n\tlocal bracket_in_string=9\n\
    \tlocal bracket_in_object=9\n\tlocal bracket_in_string=10\n\tlocal bracket_in_object=10\n\
    \tlocal bracket_in_string=11\n\tlocal bracket_in_object=11\n\tlocal bracket_in_string=12\n\
    \tlocal bracket_in_object=12\n\tlocal bracket_in_string=13\n\tlocal bracket_in_object=13\n\
    \tlocal bracket_in_string=14\n\tlocal bracket_in_object=14\n\tlocal bracket_in_string=15\n\
    \tlocal bracket_in_object=15\n\tlocal bracket_in_string=16\n\tlocal bracket_in_object=16\n\
    \tlocal bracket_in_string=17\n\tlocal bracket_in_object=17\n\tlocal bracket_in_string=18\n\
    \tlocal bracket_in_object=18\n\tlocal bracket_in_string=19\n\tlocal bracket_in_object=19\n\
    \tlocal bracket_in_string=20\n\tlocal bracket_in_object=20\n\tlocal bracket_in_string=21\n\
    \tlocal bracket_in_object=21\n\tlocal bracket_in_string=22\n\tlocal bracket_in_",
  "  local pattern=\"$1\"\n  # Make sure the pattern has at least 1 character.\n \
    \ if [ -z \"$pattern\" ]\n  then\n    echo \"Error: string provided cannot be\
    \ empty.\"\n    return 1\n  fi\n  # Remove trailing square bracket\n  pattern=\"\
    ${pattern%?]}\"\n  # Remove leading square bracket\n  pattern=\"${pattern#?[}\"\
    \n  # Remove all square brackets\n  pattern=\"${pattern#\\[}\"\n  pattern=\"${pattern%\\\
    ]}\"\n  # Find where we start in the string\n  local start=\"${pattern%[*}\"\n\
    \  local end=\"${pattern#*[*}\"\n  # Make sure that we can remove all the brackets.\n\
    \  if [ -z \"$end\" ]\n  then\n    echo \"Error: no closing bracket found in string.\"\
    \n    return 1\n  fi\n  # Make sure that the starting and ending brackets are\
    \ matched.\n  if [ \"${start}\" != \"$end\" ]\n  then\n    echo \"Error: no closing\
    \ bracket found in string.\"\n    return 1\n  fi\n  # Make sure that the ending\
    \ bracket is closed\n  if [ $(expr length \"$pattern\") - \"$end\" -gt 1 ]\n \
    \ then\n    echo \"Error: closing bracket unclosed at end of string.\"\n    return\
    \ 1\n  fi\n  # Make sure that the string contains only square brackets.\n  if\
    \ [ $(expr length \"$pattern\") - \"$start\" -gt 1 ]\n  then\n    echo \"Error:\
    \ string contains more than one closing bracket.\"\n    return 1\n  fi\n  # We\
    \ have matched all the brackets\n  return 0", "\tlocal brackets=$1\n\tlocal last_bracket=-1\n\
    \tlocal inside_brackets=0\n\n\twhile [ ${#brackets} -gt 0 ]; do\n\t\tlocal bracket=${brackets:(-1)}\n\
    \t\tlocal i=${#bracket}-1\n\t\twhile [ ${bracket:(i)} != \"[]\" ]; do\n\t\t\t\
    let i++\n\t\tdone\n\t\tlet i++\n\t\tinside_brackets=$i\n\t\tlet brackets=${brackets:0:i}\n\
    \t\tif [[ $inside_brackets -eq $brackets ]]; then\n\t\t\treturn 1\n\t\tfi\n\t\t\
    let last_bracket=$brackets\n\tdone\n\n\treturn 0", "    local bracket_counter\n\
    \    bracket_counter=0\n    local bracket_stack\n    bracket_stack=()\n    local\
    \ bracket_open\n    bracket_open=()\n    local open_bracket\n    open_bracket=''\n\
    \n    for bracket in $1 \n    do\n        if [ $bracket == ']' ]\n        then\n\
    \            bracket_stack=( \"${bracket_stack[@]}\" $bracket )\n            bracket_counter=$((\
    \ ${bracket_counter} - 1 ))\n        else\n            if [ ${bracket_counter}\
    \ -eq 0 ]\n            then\n                bracket_open=( \"${bracket_open[@]}\"\
    \ $bracket )\n            else\n                open_bracket=( \"${open_bracket[@]}\"\
    \ $bracket )\n            fi\n        fi\n    done\n    \n    if [ $bracket_counter\
    \ -ne 0 ]\n    then\n        return 0\n    else\n        if [ -n \"${open_bracket}\"\
    \ ]\n        then\n            return 1\n        else\n            return 0\n\
    \        fi\n    fi", "    local STR=\"$1\"\n    local EXPR='\\\\[\\\\[.*\\\\\
    ]\\\\]'\n    local MATCH=$(echo \"${STR}\" | grep -o \"${EXPR}\")\n    if [[ -n\
    \ \"${MATCH}\" ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\
    \n    fi", "\tlocal i\n\tlocal str=$1\n\tstr=${str//[\\[\\]]/}\n\ti=1\n\twhile\
    \ [[ \"$str\" =~ \"[[]\" ]]\n\tdo\n\t\tlet i++\n\t\tstr=${str//[[\\]]/}\n\tdone\n\
    \treturn $i", "  local str=$1\n  local open_brackets=0\n  local close_brackets=0\n\
    \  local invalid_brackets=0\n  local depth=0\n  for ((i=0; i < ${#str}; i++));\
    \ do\n    [[ \"${str:$i:1}\" == \"[\" ]]\n    [[ \"${str:$i:1}\" == \"]\" ]]\n\
    \    [[ \"${str:$i:1}\" == \"(\" ]\n    [[ \"${str:$i:1}\" == \")\" ]]\n    [[\
    \ \"${str:$i:1}\" == \"{\" ]\n    [[ \"${str:$i:1}\" == \"}\" ]]\n    [[ \"${str:$i:1}\"\
    \ == \"<\" ]]\n    [[ \"${str:$i:1}\" == \">\" ]]\n    [[ \"${str:$i:1}\" == \"\
    '\" ]]\n    [[ \"${str:$i:1}\" == \"\\\"\" ]]\n    if [[ \"${str:$i:1}\" == \"\
    ~\" ]]; then\n      depth=$((depth + 1))\n    fi\n  done\n  if ((depth < 1));\
    \ then\n    invalid_brackets=$((invalid_brackets + 1))\n    return 1\n  fi\n \
    \ for ((i=0; i < ${#str}; i++)); do\n    [[ \"${str:$i:1}\" == \"[\" ]]\n    [[\
    \ \"${str:$i:1}\" == \"]\" ]]\n    if [[ \"${str:$i:1}\" == \"(\" ]\n    [[ \"\
    ${str:$i:1}\" == \")\" ]]\n    [[ \"${str:$i:1}\" == \"{\" ]\n    [[ \"${str:$i:1}\"\
    \ == \"}\" ]]\n    [[ \"${str:$i:1}\" == \"<\" ]]\n    [[ \"${str:$i:1}\" == \"\
    >\" ]]\n    [[ \"${str:$i:1}\" == \"'\" ]]\n    [[ \"${str:$i:1}\" == \"\\\"\"\
    \ ]]\n    if [[ \"${str:$i:1}\" == \"~\" ]]; then\n      close_brackets=$((close_brackets\
    \ + 1))\n    fi\n  done\n  if ((close_brackets < 1)); then\n    invalid_brackets=$((invalid_brackets\
    \ + 1))\n    return 1\n  fi\n  if ((invalid_brackets > 0)); then\n    return 0\n\
    \  fi\n  if ((open_brackets != close_brackets)); then\n    return 1\n  fi\n  return\
    \ 0", "\tregex='\\[(\\[[^\\[]*\\]|[^\\]]*)\\]'\n\t[[ $1 =~ $regex ]] ", "  local\
    \ _var=$1\n  local _start=$2\n  local _end=$3\n  local _nest=0\n  _var=${_var:0:${#_var}}\n\
    \  \n  while [ \"${_start}\" != \"${#_var}\" ]\n  do\n    if [ \"${_var:$_start}\"\
    \ = \"${_var:$_start+1}\" ]\n    then\n      ((_nest++))\n      _start=$(($_start\
    \ + 1))\n    else\n      break\n    fi\n  done\n  \n  if [ $_nest -eq 0 ]\n  then\n\
    \    echo \"false\"\n  else\n    echo \"true\"\n  fi", "    # Remove outer braces\n\
    \    string=\"${1#\\{\\}\"}\n\n    # Remove inner brackets\n    string=\"${string#\\\
    [}\"\n    string=\"${string#\\]}\"\n\n    # Remove empty inner brackets\n    string=\"\
    ${string#\\[\\]}\"\n\n    # Remove nested brackets\n    string=\"${string#\\[\\\
    [\\]\\]}\"\n\n    # Remove outer brackets\n    string=\"${string#\\[\\]}\"\n\n\
    \    # Remove all square brackets\n    string=\"${string#\\[\\]}\"\n\n    if [[\
    \ $string ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n\
    \    fi", "  # Your code here\n  str=\"$1\"\n  while [[ $str != \"\" ]]; do\n\
    \    if [[ $str == *\\[*\\]* ]]; then\n      return 0;\n    fi\n    str=\"${str#*[}\"\
    \n    str=\"${str%]}\"\n  done\n  return 1", '    [[ "$1" =~ (^|\[\[)([[])]*\(\(\)\))+$
    ]]', "   local string=$1\n   local open_brackets=0\n   local i\n   local nested\n\
    \   local valid\n   \n   for ((i=0; i<${#string}; i++ )); do\n      if [[ ${string:$i:1}\
    \ == ${string:$i:1}[*] ]]; then\n         if [[ -z $nested ]]; then\n        \
    \    open_brackets=$((open_brackets + 1))\n         fi\n         nested=$((nested\
    \ + 1))\n      else\n         if [[ -z $nested ]]; then\n            open_brackets=$((open_brackets\
    \ - 1))\n         elif [[ -z $open_brackets ]]; then\n            valid=false\n\
    \            break\n         fi\n         nested=0\n      fi\n   done\n   echo\
    \ \"$valid\"", "    local arr=( $1 )\n    # find indices of unclosed brackets\n\
    \    local opens=()\n    local closes=()\n    local open_idx=0\n    local close_idx=0\n\
    \    local len=${#arr[@]}\n    local i\n    local open_bracket_idx\n    local\
    \ close_bracket_idx\n\n    for ((i=0; i<len; i++)); do\n        if [[ $arr[$i]\
    \ == \"[\" ]]; then\n            if [ $i -eq 0 ]; then\n                opens=(\
    \ \"${opens[@]}\" $i )\n            else\n                opens=( \"${opens[@]}\"\
    \ $i )\n                closes=( \"${closes[@]}\" $open_idx )\n            fi\n\
    \            open_idx=$i\n        elif [[ $arr[$i] == \"]\" ]]; then\n       \
    \     if [ $open_idx -eq 0 ]; then\n                opens=( \"${opens[@]}\" $i\
    \ )\n            else\n                closes=( \"${closes[@]}\" $close_idx )\n\
    \            fi\n            close_idx=$i\n        fi\n    done\n\n    # if no\
    \ nested brackets found, return false\n    if [ ${#opens[@]} -eq 0 ] && [ ${#closes[@]}\
    \ -eq 0 ]; then\n        return 0\n    fi\n\n    # otherwise we return true\n\
    \    if [ ${#opens[@]} -gt 0 ]; then\n        open_bracket_idx=${opens[${#opens[@]}\
    \ - 1]}\n    else\n        open_bracket_idx=0\n    fi\n\n    if [ ${#closes[@]}\
    \ -gt 0 ]; then\n        close_bracket_idx=${closes[${#closes[@]} - 1]}\n    else\n\
    \        close_bracket_idx=0\n    fi\n\n    # return true if open_bracket_idx\
    \ and close_bracket_idx are within valid ranges\n    if [ $open_bracket_idx -le\
    \ $close_bracket_idx ]; then\n        return 0\n    else\n        return 1\n \
    \   fi", "  # if input is a string\n  if [ \"$1\" = \"$1\" ]; then\n    # if string\
    \ starts with \"[[\"\n    if [[ $1 = \"[[\" ]]; then\n      # if string starts\
    \ with \"[[\"\n      if [[ $1 = \"[[\"  ]]; then\n        # if the string contains\
    \ at least one nested square bracket\n        if [[ $(echo $1 | grep -o '[[[]')\
    \ ]]; then\n          return 1\n        else\n          return 0\n        fi\n\
    \      else\n        return 0\n      fi\n    fi\n  else\n    return 0\n  fi",
  "    local -n arr=$1\n    local -i cnt=0\n    local bracket_count=${#arr[@]}\n \
    \   while [[ $cnt -lt $bracket_count ]]; do\n        local -i cnt=0\n        while\
    \ [[ $cnt -lt $bracket_count ]] && [[ ${arr[$cnt]} == '[' ]]; do\n           \
    \ cnt=$((cnt+1))\n        done\n        if [[ $cnt -eq $bracket_count ]]; then\n\
    \            return 0\n        fi\n        local -i cnt=0\n        while [[ $cnt\
    \ -lt $bracket_count ]] && [[ ${arr[$cnt]} == '[' ]] && [[ ${arr[$((cnt+1))]}\
    \ == ']' ]]; do\n            cnt=$((cnt+1))\n        done\n        if [[ $cnt\
    \ -eq $bracket_count ]]; then\n            return 0\n        fi\n        local\
    \ -i cnt=0\n        while [[ $cnt -lt $bracket_count ]] && [[ ${arr[$cnt]} ==\
    \ '[' ]] && [[ ${arr[$((cnt+1))]} == '[' ]]; do\n            cnt=$((cnt+1))\n\
    \        done\n        if [[ $cnt -eq $bracket_count ]]; then\n            return\
    \ 0\n        fi\n        local -i cnt=0\n        while [[ $cnt -lt $bracket_count\
    \ ]] && [[ ${arr[$cnt]} == '[' ]] && [[ ${arr[$((cnt+1))]} == '[' ]] && [[ ${arr[$((cnt+2))]}\
    \ == ']' ]]; do\n            cnt=$((cnt+2))\n        done\n        if [[ $cnt\
    \ -eq $bracket_count ]]; then\n            return 0\n        fi\n        local\
    \ -i cnt=0\n        while [[ $cnt -lt $bracket_count ]] && [[ ${arr[$cnt]} ==\
    \ '[' ]] && [[ ${arr[$((cnt+1))]} == '[' ]] && [[ ${arr[$((cnt+2))]} == ']' ]]\
    \ && [[ ${arr[$((cnt+3))]} == ']' ]]; do\n            cnt=$((cnt+3))\n       \
    \ done\n        if [[ $cnt -eq $bracket_count ]]; then\n            return 0\n\
    \        fi\n        local -i cnt=0\n        while [[ $cnt -lt $bracket_count\
    \ ]] && [[ ${arr[$cnt]} == '[' ]] && [[ ${arr[$((cnt+1))]} == '[' ]] && [[ ${arr[$((cnt+2))]}",
  "  local string=\"$1\"\n  local stack\n  local i\n  local found\n  stack=()\n  found=false\n\
    \  for i in ${string//[}; do\n    if [[ \"${stack}\" =~ $i ]]; then\n      found=true\n\
    \    else\n      stack+=(\"$i\")\n    fi\n  done\n  echo \"${found}\"", '    [[
    "$1" =~ (?<=^\[\[\[)(?=\]\]\]]+$) ]] && echo "true" || echo "false"', "    # Check\
    \ for empty string\n    if [[ -z \"$1\" ]]\n    then\n        echo \"$1 is an\
    \ empty string\"\n        return\n    fi\n    # Remove all brackets and newline\n\
    \    local brackets=$(echo \"$1\" | sed -e 's/[][]//g' -e 's/[[\\]\\[\\]]//g'\
    \ -e 's/[\\n]//g')\n    # Check for empty list\n    if [[ -z \"$brackets\" ]]\n\
    \    then\n        echo \"$1 is an empty list\"\n        return\n    fi\n    #\
    \ Check for balanced brackets\n    local num=$(( $(echo \"$brackets\" | wc -l)\
    \ - 1 ))\n    if [[ -z \"$num\" ]]\n    then\n        echo \"$1 has no balanced\
    \ brackets\"\n        return\n    fi\n    # Check for valid nesting of brackets\n\
    \    local count=0\n    local last=\n    local lastlast=\n    for char in $brackets\n\
    \    do\n        if [[ \"$last\" != \"$char\" ]]\n        then\n            if\
    \ [[ \"$last\" == \"]\" ]]\n            then\n                (( count++ ))\n\
    \            else\n                if [[ \"$last\" == \"[\" ]]\n             \
    \   then\n                    (( count-- ))\n                else\n          \
    \          echo \"$1 contains invalid nesting\"\n                    return\n\
    \                fi\n            fi\n        fi\n        last=\"$char\"\n    \
    \    if [[ \"$lastlast\" != \"$last\" ]]\n        then\n            if [[ \"$lastlast\"\
    \ == \"[\" ]]\n            then\n                (( count-- ))\n            else\n\
    \                if [[ \"$lastlast\" == \"]\" ]]\n                then\n     \
    \               (( count++ ))\n                else\n                    echo\
    \ \"$1 contains invalid nesting\"\n                    return\n              \
    \  fi\n            fi\n        fi\n        lastlast=\"$last\"\n    done\n    #\
    \ Check for valid nesting of brackets\n    (( count >= 0 )) || echo \"$1 contains\
    \ invalid nesting\"", "  local input=$1\n  local brackets=$(echo \"$input\" |\
    \ grep -o '[^[][]')\n  [[ \"$input\" =~ (^|$) ]]\n  [[ -n \"$brackets\" ]]", " \
    \ echo \"${1:0:1}\" == \"[\" && \\\n        echo \"${1:1:1}\" == \"[\" && \\\n\
    \        echo \"${1:2:1}\" == \"[\" && \\\n        echo \"${1:3:1}\" == \"[\"\
    \ && \\\n        echo \"${1:4:1}\" == \"[\" && \\\n        echo \"${1:5:1}\" ==\
    \ \"[\" && \\\n        echo \"${1:6:1}\" == \"[\" && \\\n        echo \"${1:7:1}\"\
    \ == \"[\" && \\\n        echo \"${1:8:1}\" == \"[\" && \\\n        echo \"${1:9:1}\"\
    \ == \"[\" && \\\n        echo \"${1:10:1}\" == \"[\" && \\\n        echo \"${1:11:1}\"\
    \ == \"[\" && \\\n        echo \"${1:12:1}\" == \"[\" && \\\n        echo \"${1:13:1}\"\
    \ == \"[\" && \\\n        echo \"${1:14:1}\" == \"[\" && \\\n        echo \"${1:15:1}\"\
    \ == \"[\" && \\\n        echo \"${1:16:1}\" == \"[\" && \\\n        echo \"${1:17:1}\"\
    \ == \"[\" && \\\n        echo \"${1:18:1}\" == \"[\" && \\\n        echo \"${1:19:1}\"\
    \ == \"[\" && \\\n        echo \"${1:20:1}\" == \"[\" && \\\n        echo \"${1:21:1}\"\
    \ == \"[\" && \\\n        echo \"${1:22:1}\" == \"[\" && \\\n        echo \"${1:23:1}\"\
    \ == \"[\" && \\\n        echo \"${1:24:1}\" == \"[\" && \\\n        echo \"${1:25:1}\"\
    \ == \"[\" && \\\n        echo \"${1:26:1}\" == \"[\" && \\\n        echo \"${1:27:1}\"\
    \ == \"[\" && \\\n        echo \"${1:28:1}\" == \"[\" && \\\n        echo \"${1:29:1}\"\
    \ == \"[\" && \\\n        echo \"${1:30:1}\" == \"[\" && \\\n        echo \"${1:31:1}\"\
    \ == \"[\" && \\\n        echo \"${1:32:1}\" == \"[\" && \\\n        echo \"${1:33:1}\"\
    \ == \"[\" && \\\n        echo \"${1:34:1}\" == \"[\" && \\\n        echo \"${1:35:1}\"\
    \ == \"[\" && \\\n        echo \"${1:36:1}\" == \"[\" && \\\n        echo \"${1:37:1}\"\
    \ == \"[\" && \\\n        echo \"${1:38:1}\" == \"[\" && \\\n        echo \"${1:39:1}\"\
    \ == \"[\" && \\\n        echo \"${1:40:1}\" == \"[\" && \\\n        echo \"${1:4",
  "\tlocal str=\"${1}\"\n\tlocal opens=\"(\"\n\tlocal closes=\")\"\n\tlocal chars=(\"\
    ${str//[\\]\\\\}<>|:@=+`[]\")\n\n\tfor char in \"${chars[@]}\"; do\n\t\tif [[\
    \ ${char} =~ (^[\\[\\]\\)\\]]+$) ]]; then\n\t\t\tlocal first=\"${char%[^[]}\"\n\
    \t\t\tlocal second=\"${char#*[^[]}\"\n\t\t\tif [[ ${second} =~ (^[\\[\\]]+$) ]];\
    \ then\n\t\t\t\tif [[ ${first} != ${second} ]]; then\n\t\t\t\t\treturn 1\n\t\t\
    \t\tfi\n\t\t\telse\n\t\t\t\treturn 1\n\t\t\tfi\n\t\tfi\n\tdone\n\treturn 0", "\t\
    local s=$1\n\tlocal open_brackets=0\n\tlocal close_brackets=0\n\tlocal bracket_level=0\
    \ \n\n\tlocal i=1\n\tlocal j=1\n\tlocal c\n\twhile [ $i -le $((${#s}+1)) ]; do\n\
    \t\tc=${s:$i:1}\n\t\tcase \"$c\" in\n\t\t\t[[ ])\n\t\t\t\topen_brackets=$((${open_brackets}+1))\n\
    \t\t\t\tclose_brackets=$((${close_brackets}+1))\n\t\t\t;;\n\t\t\t[()|{[]}])\n\t\
    \t\t\topen_brackets=$((${open_brackets}+1))\n\t\t\t\tclose_brackets=$((${close_brackets}+1))\n\
    \t\t\t\tbracket_level=$((${bracket_level}+1))\n\t\t\t;;\n\t\t\t*)\n\t\t\t\tif\
    \ [[ $bracket_level -ge 0 ]]; then \n\t\t\t\t\topen_brackets=$((${open_brackets}+1))\n\
    \t\t\t\t\tclose_brackets=$((${close_brackets}+1))\n\t\t\t\t\tbracket_level=$((${bracket_level}-1))\n\
    \t\t\t\tfi\n\t\t\t;;\n\t\tesac\n\t\ti=$((i+1))\n\tdone\n\n\tif [[ $close_brackets\
    \ -eq 1 ]]; then\n\t\techo \"true\"\n\telse\n\t\techo \"false\"\n\tfi", "    local\
    \ input=${1}\n    local last=\n    local match=\n    local depth=1\n    local\
    \ output=0\n\n    while [ -n \"${input:0:1}\" ]\n    do\n        match=${input:0:1}\n\
    \        if [[ $output == 1 ]]; then\n            depth=$((${depth}+1))\n    \
    \    fi\n\n        [[ \"${match}\" = '[' && ${last} = ']' ]] && output=1\n   \
    \     [[ \"${match}\" = '{' && ${last} = '}' ]] && output=1\n\n        last=${match}\n\
    \    done\n    return ${output}", "  echo \"$1\" | grep '^\\[.*\\]\\(\\[[^][]*\\\
    ]*\\)*$' > /dev/null", "  # A variable whose name is $1 is initialized to empty\
    \ string.\n  # The first time it is used it will be empty string.\n  local emptyvar=\"\
    \"\n  # The variable is set to empty string if there are no [ in the input\n \
    \ if ! grep -Eo \"\\[.*\\]\" <<< \"$1\" > /dev/null; then\n    return 0\n  fi\n\
    \  # We need to check if there is any left over in the input that are not []\n\
    \  # and if so return true\n  if ! grep -Eo \"\\[.*\\]\" <<< \"$1\" | grep -v\
    \ \"\\[$emptyvar\\]\" > /dev/null; then\n    return 1\n  fi\n  # We need to check\
    \ if there is any left over in the input that are not []\n  # and if so return\
    \ true\n  if ! grep -Eo \"\\[.*\\]\" <<< \"$1\" | grep -v \"\\[$emptyvar\\]\"\
    \ | grep -v \"\\[$emptyvar\\]\" > /dev/null; then\n    return 1\n  fi\n  # We\
    \ need to check if there is any left over in the input that are not []\n  # and\
    \ if so return true\n  if ! grep -Eo \"\\[.*\\]\" <<< \"$1\" | grep -v \"\\[$emptyvar\\\
    ]\" | grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" > /dev/null; then\n\
    \    return 1\n  fi\n  # We need to check if there is any left over in the input\
    \ that are not []\n  # and if so return true\n  if ! grep -Eo \"\\[.*\\]\" <<<\
    \ \"$1\" | grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" | grep -v\
    \ \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" > /dev/null; then\n    return\
    \ 1\n  fi\n  # We need to check if there is any left over in the input that are\
    \ not []\n  # and if so return true\n  if ! grep -Eo \"\\[.*\\]\" <<< \"$1\" |\
    \ grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\\
    ]\" | grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" > /dev/null; then\n\
    \    return 1\n  fi\n  # We need to check if there is any left over in the input\
    \ that are not []\n  # and if so return true\n  if ! grep -Eo \"\\[.*\\]\" <<<\
    \ \"$1\" | grep -v \"\\[$emptyvar\\]\" | grep -v \"\\[$emptyvar\\]\" | grep -v\
    \ \"", "  local str=$1\n\n  local depth=0\n  local idx=0\n  local lastIdx=-1\n\
    \  local lastCount=0\n  local nextCount=0\n\n  while [ $idx -lt ${#str} ]; do\n\
    \    if [[ ${str:$idx} == [\\] ]]; then\n      if [ $(( $(expr $nextCount - 1\
    \ )) -eq 0 ]; then\n        depth=$(expr $depth + 1 )\n      else\n        depth=$(expr\
    \ $depth - 1 )\n      fi\n      nextCount=0\n      idx=$(( idx + 1 ))\n    else\n\
    \      if [ $(( $(expr $nextCount - 1 )) -gt 0 ]; then\n        depth=$(expr $depth\
    \ + 1 )\n      else\n        depth=$(expr $depth - 1 )\n      fi\n      nextCount=$((\
    \ nextCount + 1 ))\n    fi\n\n    lastIdx=$idx\n    lastCount=$nextCount\n   \
    \ idx=$(( idx + 1 ))\n  done\n\n  # if we didn't find the closing bracket and\
    \ count is odd, return false\n  if [ $(( $(expr $lastCount - 1 )) -lt 2 )] &&\
    \ [[ ${str:$lastIdx} == [\\] ]]; then\n    return 0\n  else\n    return 1\n  fi",
  "    local string=$1\n    local open=false\n    local close=false\n    local result=true\n\
    \    local stack\n    local idx\n    stack=()\n\n    for ((idx=0; idx<${#string};\
    \ idx++)); do\n        if [[ \"${string[idx]}\" = \"[\" ]]; then\n           \
    \ open=true\n        elif [[ \"${string[idx]}\" = \"]\" ]]; then\n           \
    \ close=true\n        elif [[ $open && $close ]]; then\n            stack+=(\"\
    $string[idx]\")\n        elif [[ $open ]]; then\n            stack+=(\"$string[idx]\"\
    )\n        elif [[ $close ]]; then\n            if [[ ${stack[@]} == *[${string[idx]}*\
    \ ]]; then\n                stack=()\n            else\n                result=false\n\
    \            fi\n        fi\n    done\n\n    if [[ $result ]]; then\n        echo\
    \ \"true\"\n    else\n        echo \"false\"\n    fi", "    local string=\"$1\"\
    \n    if [[ $string == *\\[ ]]; then\n        echo \"true\"\n    else\n      \
    \  echo \"false\"\n    fi", '  grep -qE "^([[]|[[][][]]|[[][]]|[[][][][]])$" <<<
    "$1"', "\tlocal string=\"${1}\"\n\tlocal open=\"[[\"\n\tlocal close=\"]]]\"\n\n\
    \twhile [ -n \"$string\" ]; do\n\t\tif [[ $string == $open ]]; then\n\t\t\tif\
    \ [[ $open ]]; then \n\t\t\t\topen=\"${open}${open}\"\n\t\t\telse\n\t\t\t\topen=\"\
    []\"\n\t\t\tfi\n\t\telse\n\t\t\tif [[ $string == $close ]]; then\n\t\t\t\tif [[\
    \ $close ]]; then \n\t\t\t\t\tclose=\"${close}${close}\"\n\t\t\t\telse\n\t\t\t\
    \t\tclose=\"[]\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\t\
    done\n\n\tif [[ $string == $open ]]; then\n\t\tif [[ $open ]]; then \n\t\t\topen=\"\
    ${open}${open}\"\n\t\telse\n\t\t\topen=\"[]\"\n\t\tfi\n\telse\n\t\tif [[ $string\
    \ == $close ]]; then\n\t\t\tif [[ $close ]]; then \n\t\t\t\tclose=\"${close}${close}\"\
    \n\t\t\telse\n\t\t\t\tclose=\"[]\"\n\t\t\tfi\n\t\telse\n\t\t\tbreak\n\t\tfi\n\t\
    fi\n\t\n\techo \"$open\"\n\techo \"$close\"", "    [ -z \"$1\" ] && return 1\n\
    \    [[ $1 =~ (\\[[^\\[\\]]+\\]){2,}( ) ]] && return 0 || return 1", "  local\
    \ in_string in_brackets in_substring in_brackets_count in_nested_brackets in_nested_brackets_count\
    \ start_pos end_pos\n  in_string=$1\n  in_brackets=\"[\"\n  in_substring=\"\"\n\
    \  in_brackets_count=0\n  in_nested_brackets=\"[\"\n  in_nested_brackets_count=0\n\
    \  start_pos=0\n  end_pos=0\n  while [[ ${in_string: -1} != \"]]\" ]] \n  do\n\
    \    # if the current character is a bracket increase the brackets counter\n \
    \   if [[ ${in_string: -1} = ${in_brackets} ]]\n    then\n      in_brackets_count=${in_brackets_count}+1\n\
    \    # if the current character is a bracket, decrease the brackets counter\n\
    \    elif [[ ${in_string: -1} = ${in_nested_brackets} ]]\n    then\n      in_nested_brackets_count=${in_nested_brackets_count}-1\n\
    \    # if the current character is a bracket, check for nested brackets\n    elif\
    \ [[ ${in_string: -1} == ${in_brackets} ]]\n    then\n      if [[ ${in_nested_brackets_count}\
    \ -eq 0 ]]\n      then\n        echo \"true\"\n        exit\n      else\n    \
    \    echo \"false\"\n        exit\n      fi\n    # if the current character is\
    \ a closing bracket, if the brackets counter is 0 then there \n    # is no nested\
    \ brackets\n    elif [[ ${in_string: -1} == ${in_brackets} \\\n            &&\
    \ ${in_brackets_count} -eq 0 ]]\n    then\n      echo \"false\"\n      exit\n\
    \    # if the current character is a closing bracket, if the brackets counter\
    \ is 0 then there \n    # is no nested brackets\n    elif [[ ${in_string: -1}\
    \ == ${in_brackets} \\\n            && ${in_brackets_count} -eq 0 ]]\n    then\n\
    \      echo \"false\"\n      exit\n    fi\n    # if the current character is a\
    \ closing bracket, if the brackets counter is 0 then there \n    # is no nested\
    \ brackets\n    elif [[ ${in_string: -1} == ${in_brackets} \\\n            &&\
    \ ${in_brackets_count} -eq 0 ]]\n    then\n      echo \"false\"\n      exit\n\
    \    # if the current character is not a bracket, add the character to the substring\n\
    \    elif [[ ${in_string: -1} != ${in_brackets} ]]\n    then\n      in_substring=\"\
    ${in_substring}${in_string:-1}\"\n    fi\n    # if the current character is a\
    \ bracket, add the character to the substring\n    if [[ ${in_", "    local bracket_depth=0\n\
    \    local i\n\n    for i in $(echo $1 | grep -E \"^\\[[^]]*\\]$\"); do\n    \
    \    if [[ ${bracket_depth} -gt 0 ]]; then\n            bracket_depth=$(expr ${bracket_depth}\
    \ + 1)\n        fi\n\n        if [[ \"$i\" == *\"$2\"* ]]; then\n            if\
    \ [[ \"${#i}\" -eq \"$((${#1}-bracket_depth))\" ]]; then\n                echo\
    \ \"true\"\n            else\n                echo \"false\"\n            fi\n\
    \        else\n            echo \"false\"\n        fi\n    done", "\tlocal str=$1\n\
    \tlocal open=(\"[[]\")\n\tlocal close=(\"][]\")\n\tlocal inside=\"\"\n\tfor i\
    \ in $str; do\n\t\tif [[ $i == $open || $i == $close ]]; then\n\t\t\tif [[ $i\
    \ == $open ]]; then\n\t\t\t\tinside=$inside\"[\"\n\t\t\telse\n\t\t\t\tinside=$inside\"\
    ]\"\n\t\t\tfi\n\t\telse\n\t\t\tinside=$inside$i\n\t\tfi\n\tdone\n\tif [[ \"$inside\"\
    \ =~ ^$open ]] || [[ \"$inside\" =~ ^$close ]]; then\n\t\techo \"true\"\n\telse\n\
    \t\techo \"false\"\n\tfi", "        local a=\"$1\"\n        local b=()\n     \
    \   local i\n        for i in \"${!a[@]}\"; do\n                if [[ $i -ne 0\
    \ ]]; then\n                        if [[ \"${a[i]}\" == \"[\" ]]; then\n    \
    \                            b[${#b[@]}]=\"${a[i]}\"\n                       \
    \ elif [[ \"${a[i]}\" == \"]\" ]]; then\n                                b[${#b[@]}]=\"\
    ${a[i]}\"\n                                let i+=1\n                        else\n\
    \                                b[${#b[@]}]=\"${a[i]}\"\n                   \
    \     fi\n                fi\n        done\n        [[ ${#b[@]} -gt 0 ]]", '    echo
    "$1"|grep -E "(\[\[\[)*[^[]*]](\]\]\])*"', "  local str=$1\n\n  local bracket=\"\
    []\"\n  local bracket_found=0\n\n  echo \"$str\" | grep -Eq \"$bracket\"\n  while\
    \ [ ! -z \"$str\" ] && [ \"$str\" != \"$bracket\" ] && [ \"$str\" != \"\" ]; do\n\
    \    bracket_found=1\n    echo -n \"$bracket \"\n    str=$(echo \"$str\" | sed\
    \ \"s/$bracket/$bracket$bracket/\")\n  done\n  echo \"$bracket_found\"", '    [[
    "$1" =~ (?<=^\[)(?<=^\]]+\]$) ]]', "\tlocal brackets=$1 count=0\n\tlocal bracket_type=$2\n\
    \tlocal bracket_found=false\n\tlocal next_bracket\n\tlocal in_brackets=0\n\tlocal\
    \ in_inside_brackets=0\n\tlocal last_bracket=0\n\n\t# if $brackets contains only\
    \ [, return true to indicate that brackets are nested.\n\tif [[ \"$brackets\"\
    \ == *[* ]]; then\n\t\treturn 1\n\tfi\n\n\tfor next_bracket in \"$brackets\" ;\
    \ do\n\t\tif [[ \"$next_bracket\" == \"[\" ]]; then\n\t\t\tin_brackets=$((in_brackets\
    \ + 1))\n\t\telse\n\t\t\tin_brackets=$((in_brackets - 1))\n\t\tfi\n\n\t\tif [[\
    \ \"$in_brackets\" -eq 0 ]]; then\n\t\t\tif [[ \"$bracket_type\" == \"$next_bracket\"\
    \ ]]; then\n\t\t\t\tbracket_found=true\n\t\t\tfi\n\t\telse\n\t\t\tif [[ \"$in_inside_brackets\"\
    \ -eq 0 ]]; then\n\t\t\t\tif [[ \"$bracket_type\" == \"$next_bracket\" ]]; then\n\
    \t\t\t\t\tin_inside_brackets=1\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [[ \"$in_inside_brackets\"\
    \ -eq 1 ]]; then\n\t\t\t\t\tin_inside_brackets=0\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\
    \n\t\tif [[ \"$bracket_found\" == \"true\" ]]; then\n\t\t\tbracket_found=false\n\
    \t\tfi\n\tdone\n\n\tif [[ \"$bracket_found\" == \"false\" ]]; then\n\t\treturn\
    \ 0\n\tfi\n\n\treturn 1", "    string=$1\n    # remove all whitespace and brackets\
    \ from the string\n    string=${string//[[:space:]]/}\n    string=${string//\\\
    [/}\n    string=${string//\\]/}\n    string=${string//\\{/}\n    string=${string//\\\
    }/}\n    # check for valid nesting\n    # a bracket must not appear inside another\
    \ bracket\n    for bracket in $string; do\n        if [ $(bracket in $string)\
    \ ]; then \n            echo \"true\"; \n        fi; \n    done", "    # A regex\
    \ that checks there is an open bracket before a close bracket.\n    # A negative\
    \ lookahead checks that there is no close bracket before an open bracket.\n  \
    \  # A negative lookbehind checks that there is no open bracket before a close\
    \ bracket.\n    # Positive lookahead checks that there is an open bracket before\
    \ a close bracket.\n    # Positive lookbehind checks that there is an close bracket\
    \ before an open bracket.\n    if [[ $1 =~ (^\\[[^\\]]*\\](?<!\\[[^\\]]*\\])$)\
    \ ]]; then\n        echo true\n    else\n        echo false\n    fi", "  expr='^(\\\
    [\\])$';\n  [[ \"$1\" =~ $expr ]] || return 0;\n  for i in $(seq 1 $(expr length\
    \ \"$1\")); do\n    [[ \"$1\" =~ ([[]])($i) ]] && return 0;\n  done\n  return\
    \ 1;", "\tlocal string=\"$1\"\n\tlocal brackets=\"${string//[//g}\"\n\tlocal nestings=${brackets//[[]/}\n\
    \tlocal valid=${nestings//[^]}//g}\n\techo \"${valid}\"", "    local string=\"\
    $1\"\n    # Strip the leading and trailing brackets\n    string=\"${string#?[[]}\"\
    \n    string=\"${string%]}\"\n    # Strip any left over nesting\n    string=\"\
    ${string#??}\"\n    string=\"${string?}\"\n    \n    # If string is empty\n  \
    \  if [[ -z \"$string\" ]] ; then\n        echo \"false\"\n        return\n  \
    \  fi\n    # Replace all instances of the left bracket with a left bracket (a\
    \ literal left bracket)\n    string=\"$(echo \"$string\" | sed 's/[][]/\\[/g')\"\
    \n    # Replace all instances of the right bracket with a right bracket (a literal\
    \ right bracket)\n    string=\"$(echo \"$string\" | sed 's/[]/\\]/g')\"\n    \n\
    \    if [[ \"$string\" = \"[]\" ]] ; then\n        echo \"true\"\n        return\n\
    \    fi\n    \n    # Recurse on the remaining string\n    is_nested \"$string\"",
  "\tlocal s=$1\n\tlocal i=0\n\tlocal t=0\n\tlocal n=0\n\tlocal c=0\n\tlocal s=$(echo\
    \ ${s}|sed 's/\\[//g;s/\\]//g')\n\tfor n in ${!s}; do\n\t\tif [ ${n} -eq 0 ];\
    \ then\n\t\t\tc=1\n\t\telse\n\t\t\tif [ ${s:$n:1} == [] ]; then\n\t\t\t\tc=0\n\
    \t\t\telif [ ${s:$n:1} == ( ] || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=1\n\t\t\
    \telif [ ${s:$n:1} == ( ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=0\n\t\t\telif\
    \ [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=0\n\t\t\telif [ ${s:$n:1} == [ ] ]; then\n\
    \t\t\t\tc=1\n\t\t\telif [ ${s:$n:1} == ( ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\
    \t\tc=1\n\t\t\telif [ ${s:$n:1} == ( ] || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\t\
    c=1\n\t\t\telif [ ${s:$n:1} == ( ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=0\n\
    \t\t\telif [ ${s:$n:1} == [ ] || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=0\n\t\t\
    \telif [ ${s:$n:1} == [ ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=1\n\t\t\telif\
    \ [ ${s:$n:1} == ( ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=1\n\t\t\telif [\
    \ ${s:$n:1} == ( ] || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=1\n\t\t\telif [ ${s:$n:1}\
    \ == [ ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=0\n\t\t\telif [ ${s:$n:1} ==\
    \ [ ] || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=0\n\t\t\telif [ ${s:$n:1} == [\
    \ ] || [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=1\n\t\t\telif [ ${s:$n:1} == ( ]\
    \ || [ ${s:$n:1} == ( ] ]; then\n\t\t\t\tc=1\n\t\t\telif [ ${s:$n:1} == ( ] ||\
    \ [ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=1\n\t\t\telif [ ${s:$n:1} == [ ] || [\
    \ ${s:$n:1} == [ ] ]; then\n\t\t\t\tc=1\n\t\t\t", "    local STR=$1\n    # Check\
    \ if STR contains only square brackets.\n    if [[ \"$STR\" =~ ^\\[([^][]*\\)\\\
    ]$ ]]; then\n        return 1\n    else\n        return 0\n    fi", "    local\
    \ -r pattern=$1\n    local -r pattern2=\"${pattern//[\\[\\]]/}\"\n    local -r\
    \ pattern3=\"$(echo \"${pattern2}\" | sed 's/[][]//g')\"\n    local -r pattern4=\"\
    $(echo \"${pattern2}\" | sed 's/[]//g')\"\n    local -r string=\"${pattern3}\"\
    \n    local -r string2=\"${string//[\\[\\]]/}\"\n    local -r string3=\"$(echo\
    \ \"${string2}\" | sed 's/[][]//g')\"\n    local -r string4=\"$(echo \"${string2}\"\
    \ | sed 's/[]//g')\"\n    echo \"${string3} && ${pattern4} && ${string4}\"", "\t\
    local i\n\tlocal opened_brackets\n\tlocal closed_brackets\n\tlocal current_depth\n\
    \tlocal result\n\n\tcurrent_depth=0\n\topened_brackets=0\n\tclosed_brackets=0\n\
    \n\tfor i in $1; do\n\t\tif [ \"$opened_brackets\" -gt \"$current_depth\" ]; then\n\
    \t\t\tcurrent_depth=\"$opened_brackets\"\n\t\tfi\n\n\t\tif [ \"$closed_brackets\"\
    \ -ge \"$current_depth\" ]; then\n\t\t\tresult=$(expr match  \"[]]\" $i)\n\t\t\
    \tif [ \"$result\" -eq \"0\" ]; then\n\t\t\t\tresult=$(expr match  \"[[\" $i)\n\
    \t\t\t\tif [ \"$result\" -eq \"0\" ]; then\n\t\t\t\t\tresult=$(expr match  \"\
    [\" $i)\n\t\t\t\t\tif [ \"$result\" -eq \"0\" ]; then\n\t\t\t\t\t\tresult=$(expr\
    \ match  \"{\" $i)\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\n\t\topened_brackets=$((opened_brackets+1))\n\
    \n\t\tif [ \"$closed_brackets\" -ge \"$current_depth\" ]; then\n\t\t\tclosed_brackets=$((closed_brackets+1))\n\
    \t\tfi\n\n\tdone\n\n\treturn $result", '  [[ $1 =~ (^\[\[.*\]\]$)$ ]] && return
    1 || return 0', "    string=\"$1\"\n    [[ \"$string\" =~ ^(\\[[^[\\]]*\\])+$\
    \ ]] && echo $string", "  local string \n  string=\"$1\"\n\n  local length count\n\
    \  length=${#string}\n  count=0\n\n  while [ \"$count\" -lt \"$length\" ] \n \
    \ do \n    if (( $( echo \"$string\" | grep -c '[' )) -eq 0 )\n    then \n   \
    \   return 0\n    else \n      string=\"${string:1:$(( $length-1 ))}\"\n     \
    \ count=$(( $count + 1 ))\n    fi\n  done\n  return 1", "  local substring=$1\n\
    \  local brackets='{{}[]}'\n  local bracketscount=${#brackets}\n  local charcount=0\n\
    \  local charmatch=0\n  local lastchar=$substring[$((${#substring}-1))]\n  local\
    \ openbrackets=0\n\n  # check if last char is open\n  if [[ ${#substring} -gt\
    \ 1 && ${lastchar} != \"[\" ]]; then\n    charmatch=$((charmatch+1))\n  fi\n\n\
    \  # count opens\n  for (( i=0; i<${#substring}; i++ )); do\n    if [[ \"${brackets}\"\
    \ =~ \"${substring:i:1}\" ]]; then\n      openbrackets=$((openbrackets+1))\n \
    \   fi\n  done\n\n  # check closing brackets\n  for (( i=0; i<${#substring}; i++\
    \ )); do\n    if [[ \"${brackets}\" =~ \"${substring:i:1}\" ]]; then\n      openbrackets=$((openbrackets-1));\n\
    \      if [[ \"${openbrackets}\" -lt 1 ]]; then\n        charmatch=$((charmatch+1))\n\
    \        openbrackets=0\n      fi\n    fi\n  done\n\n  if (( ${charmatch} > ${bracketscount}\
    \ )); then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi", "    local bracket_count=0\n\
    \    local ins=$1\n    local i\n    local count\n    local is_nested\n    local\
    \ open_bracket\n    local close_bracket\n    # Count number of open and close\
    \ brackets\n    while (( bracket_count < 2 )); do\n        (( bracket_count+=1\
    \ ))\n        ins=${ins:0:(-1)}\n    done\n    # Check for balanced brackets\n\
    \    for i in $(seq 0 $(( bracket_count - 1 ))); do\n        (( ins=${ins:0:(-1)}\
    \ ))\n        if [[ $ins == ([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([{([",
  '    [[ "$1" =~ \[\]\] ]] && [[ "$1" =~ \[\[\]\] ]]', "\t\n\tregex='\\[\\[\\[((\\\
    {\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\\
    |)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\\
    |\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\\
    [((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\\
    |\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\\
    }|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\\
    ]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\\
    }\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\\
    {|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\\
    ]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\\
    {\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\\
    |)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\\
    |\\|)\\]\\]\\]\\[\\[((\\{\\{|\\}\\}|\\|\\|)(\\{\\{|\\}\\}|\\|\\|)\\]\\]\\]\\[\\\
    [((\\{\\{|\\}\\}|\\|\\|", "\tlocal brackets=$1 \n\tlocal inside_brackets=0\n\t\
    local outside_start_bracket=0\n\tlocal outside_end_bracket=0\n\tlocal num_brackets=${#brackets}\n\
    \n\twhile [[ $num_brackets -gt 0 ]]; do\n\t\tbracket=${brackets:$((num_brackets-1))}\n\
    \t\tinside_brackets=${inside_brackets}:$((inside_brackets-1))\n\t\toutside_start_bracket=${outside_start_bracket}:\"\
    \\[$inside_brackets\\]\"\n\t\toutside_end_bracket=${outside_end_bracket}:\"\\\
    [$((num_brackets-1))\\]\"\n\t\tbrackets=${brackets:0:$((num_brackets-1))}\n\t\t\
    num_brackets=${num_brackets-1}\n\n\t\tif [[ $inside_brackets -ge 0 ]]; then\n\t\
    \t\t[[ \"$bracket\" =~ $outside_start_bracket* ]] && inside_brackets=$((inside_brackets\
    \ - 1))\n\t\t\t[[ \"$bracket\" =~ $outside_end_bracket* ]] && inside_brackets=$((inside_brackets\
    \ + 1))\n\t\telse\n\t\t\t[[ \"$bracket\" =~ $outside_start_bracket* ]] && inside_brackets=$((inside_brackets\
    \ + 1))\n\t\tfi\n\tdone\n\n\t[[ \"$brackets\" =~ $outside_start_bracket* ]] &&\
    \ inside_brackets=$((inside_brackets + 1))\n\n\t[[ \"$brackets\" =~ $outside_end_bracket*\
    \ ]] && inside_brackets=$((inside_brackets - 1))\n\n\tif [[ \"$inside_brackets\"\
    \ -eq \"0\" ]]; then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi", "    if [[ $(expr\
    \ length \"$1\") == 0 ]] ; then\n        echo \"false\"\n    else\n        set\
    \ -- \"$1\"\n        for (( i=2 ; i <= $(expr length \"$1\")-2 ; i++ )) ; do\n\
    \            if [[ $(awk \"{ print \\$1 }\" <<< $i) == \"[[]\" ]] ; then\n   \
    \             echo \"true\"\n                break\n            else\n       \
    \         echo \"false\"\n            fi\n        done\n    fi", "\tlocal _array=($(echo\
    \ $1 | tr \"[]\" \"()\") )\n\tlocal _return=\"false\"\n\tfor _item in \"${_array[@]}\"\
    \ ; do\n\t\tif (( $(_item | grep -o \"[[]\"| wc -l ) >0 )); then\n\t\t\t_return=\"\
    true\"\n\t\tfi\n\tdone\n\techo $_return", "  while [ $# -gt 0 ]; do\n    if [\
    \ \"$1\" == \"[]\" ]\n    then\n      echo \"true\"\n      return\n    fi\n  \
    \  shift\n  done\n  echo \"false\"", "    local bracket_stack\n\n    if [[ $1\
    \ =~ ([^[]*\\[\\[\\([^[]*\\)[[]*) ]]; then\n        bracket_stack=( \"${BASH_REMATCH[@]:1}\"\
    \ )\n    elif [[ $1 =~ (\\[\\[\\[([^[]*\\)*)\\[\\[\\[([^]]*\\)\\]\\]\\]) ]]; then\n\
    \        bracket_stack=( \"${BASH_REMATCH[@]:2}\" )\n    elif [[ $1 =~ (\\[\\\
    [[^\\[\\]\\[]*\\)\\[\\[\\[([^]]*\\)\\]\\]\\]) ]]; then\n        bracket_stack=(\
    \ \"${BASH_REMATCH[@]:1}\" )\n    elif [[ $1 =~ (\\[\\[\\[([^[]*\\)*)\\[\\[([^]]*\\\
    )\\]\\]\\]) ]]; then\n        bracket_stack=( \"${BASH_REMATCH[@]:2}\" )\n   \
    \ else\n        echo true\n        return 0;\n    fi\n\n    local len=\"${#bracket_stack[@]}\"\
    \n\n    for ((i=0; i<$len; i++)) ; do\n        if (( ${bracket_stack[i]} == ${bracket_stack[i+1]}\
    \ )) ; then\n            echo false\n            return 0\n        fi\n    done\n\
    \n    echo true\n    return 0", "\tlocal string=\"$1\"\n\tlocal length=0\n\tlocal\
    \ i\n\tlocal j\n\tlocal brackets=0\n\tlocal count=0\n\tlocal inside_brackets=0\n\
    \tlocal first\n\tlocal last\n\tlocal temp\n\n\tlength=${#string//[]}\n\n\tfor((i=0;i<length;i++))\n\
    \tdo\n\t\tinside_brackets=0\n\t\tfirst=${string:$i:1}\n\t\tlast=${string:$(($i+1)):$((length-1))}\n\
    \t\ttemp=${string:$(($i+1)):$((length-1))}\n\t\t\n\t\tif  [ \"${first}\" == \"\
    [\" ] && [ \"${last}\" == \"]\" ]; then\n\t\t\tbrackets=$((brackets+1))\n\t\t\t\
    inside_brackets=$((inside_brackets+1))\n\t\tfi\n\t\t\n\t\tif [ \"${inside_brackets}\"\
    \ == \"0\" ]; then\n\t\t\tcount=$(expr $count + 1)\n\t\tfi\n\t\t\n\tdone\n\t\n\
    \tif [ \"${count}\" == 0 ]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi", " \
    \   local char=\"${1:0:1}\"\n    local string=\"${1:1}\"\n\n    local inside_bracket=false\n\
    \    local count_brackets=0\n    local open_brackets=0\n    local inside_string=false\n\
    \    local open_strings=0\n\n    for (( i=0;i<${#string};i++ )); do\n        local\
    \ char=\"${string[i]}\"\n        if [[ \"$char\" == \"$char\" ]]; then\n     \
    \       inside_string=false\n            open_strings=$(( open_strings+1 ))\n\
    \        fi\n        if [[ \"$char\" == \"[\"]]; then\n            inside_bracket=true\n\
    \            count_brackets=$(( count_brackets+1 ))\n        fi\n        if [[\
    \ \"$char\" == \"]\" ]]; then\n            inside_bracket=false\n            count_brackets=$((\
    \ count_brackets-1 ))\n        fi\n        if [[ \"$inside_bracket\" == \"true\"\
    \ ]]; then\n            open_brackets=$(( open_brackets+1 ))\n        fi\n   \
    \     if [[ \"$inside_string\" == \"true\" ]]; then\n            open_strings=$((\
    \ open_strings-1 ))\n        fi\n    done\n\n    if [[ \"$count_brackets\" -eq\
    \ 0 ]]; then\n        if [[ \"$open_strings\" -eq 0 ]]; then\n            if [[\
    \ \"$open_brackets\" -eq 0 ]]; then\n                echo \"true\"\n         \
    \   else\n                echo \"false\"\n            fi\n        else\n     \
    \       echo \"false\"\n        fi\n    else\n        echo \"true\"\n    fi",
  "    echo \"$1\"|grep -oE '\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\]\\[[^]]*\\\
    ]\\[[^]]*\\]\\[[^]]*\\]", "    if [[ \"$1\" =~ (\\[\\[\\])+$ ]]; then\n      \
    \  echo \"true\"\n    else\n        echo \"false\"\n    fi", "  local brackets=${1//\\\
    [/}\n  local last=`echo ${brackets} | tail -n 1`\n  if [ \"${last}\" == \"[\"\
    \  ]; then\n    local inside=false\n    local open=1\n    local i=0\n    while\
    \ (( i < ${#brackets} )) ; do\n      if [ ${brackets:i:1} == \"]\" ]; then\n \
    \       if [ ${open} -eq 0 ]; then\n          inside=false\n        else\n   \
    \       inside=true\n          open=0\n        fi\n      else\n        open=$(($open+1))\n\
    \      fi\n      i=$(($i+1))\n    done\n    echo $inside\n  else\n    echo false\n\
    \  fi", "  local str=\"${1}\"\n  [[ \"${str}\" =~ \\[*\\]\\] ]] && return 0\n\
    \  return 1", "    local pattern=\"${1}\"\n    local bracket_count=\"$(expr \"\
    ${pattern}\" : '\\[*\\]\\+')\"\n    local open_count=\"$(expr \"${pattern}\" :\
    \ '\\[*\\]')\"\n    local close_count=\"$(expr \"${pattern}\" : '\\*]')\"\n  \
    \  local bracket_open=\"$(expr \"${bracket_count}\" : '\\([0-9]*\\)')\"\n    local\
    \ bracket_close=\"$(expr \"${open_count}\" : '\\([0-9]*\\)')\"\n    local bracket_nesting=\"\
    $(expr \"${bracket_open}\" : '\\([[:digit:]]*\\)')\"\n    local bracket_closing=\"\
    $(expr \"${close_count}\" : '\\([[:digit:]]*\\)')\"\n    local bracket_opening=\"\
    $(expr \"${open_count}\" : '\\([[:digit:]]*\\)')\"\n    if [ ! -z \"${bracket_nesting}\"\
    \ -a ! -z \"${bracket_closing}\" -a ! -z \"${bracket_opening}\" ]; then\n    \
    \    echo \"true\"\n    else\n        echo \"false\"\n    fi", "    local brackets=\"\
    ${1:-[]}\"\n\n    # Return false if there are no brackets\n    if [[ \"${brackets}\"\
    \ == \"[]\" ]]; then\n        return 0\n    fi\n    \n    local num_brackets=${#brackets-1}\n\
    \    \n    # Return false if there are no nested brackets\n    if [[ ${num_brackets}\
    \ -eq 0 ]]; then\n        return 0\n    fi\n    \n    # Check for nested brackets\n\
    \    local index=0\n    local opens=0\n    local closes=0\n    local bracket=\"\
    \"\n    while [[ ${index} -lt ${num_brackets} ]]; do\n        bracket=\"${brackets:$index:1}\"\
    \n        if [[ \"${bracket}\" == \"[\" ]]; then\n            opens=\"$opens +\
    \ 1\"\n        elif [[ \"${bracket}\" == \"]\" ]]; then\n            closes=\"\
    $closes + 1\"\n        fi\n        index=$(( ${index} + 1 ))\n    done\n    \n\
    \    # Return true if and only if all brackets are open\n    return $(( ${opens}\
    \ -eq ${closes} ))", "    local bracket=$1\n    local bracket_count=$(expr length\
    \ \"$bracket\")\n    local counter=0\n\n    while [ $counter -lt $bracket_count\
    \ ]; do\n        if [ $counter == $bracket_count ]; then\n            (( counter\
    \ < $bracket_count ))\n        else\n            [[ \"$bracket\" =~ \\[$(( counter\
    \ + 1 ))\\] ]]\n        fi\n        (( counter++ ))\n    done", "    local brackets=$1\n\
    \    local validbrackets=0\n    local openbrackets=0\n    local closebrackets=0\n\
    \    local nestingstack\n    while [[ $brackets =~ (\\[|\\{) ]]\n    do\n    \
    \    if [[ $brackets =~ \\] ]]\n        then\n            if [[ $nestingstack\
    \ == *\"$brackets\"* ]]\n            then\n                nestingstack=$(( nestingstack\
    \ + 1 ))\n            else\n                return 0\n            fi\n       \
    \ else\n            if [[ $nestingstack != *\"$brackets\"* ]]\n            then\n\
    \                return 0\n            else\n                nestingstack=$((\
    \ nestingstack + 1 ))\n            fi\n        fi\n        if [[ $brackets =~\
    \ \\] ]]\n        then\n            if [[ $openbrackets != 0 && $openbrackets\
    \ != $closebrackets ]]\n            then\n                return 0\n         \
    \   else\n                openbrackets=$(( openbrackets + 1 ))\n            fi\n\
    \        else\n            if [[ $openbrackets != 0 && $openbrackets != $closebrackets\
    \ ]]\n            then\n                return 0\n            else\n         \
    \       openbrackets=$(( openbrackets + 1 ))\n            fi\n        fi\n   \
    \     if [[ $brackets =~ \\] ]]\n        then\n            if [[ $openbrackets\
    \ == 0 && $closebrackets != 0 ]]\n            then\n                return 0\n\
    \            else\n                closebrackets=$(( closebrackets + 1 ))\n  \
    \          fi\n        else\n            if [[ $openbrackets == 0 && $closebrackets\
    \ != 0 ]]\n            then\n                return 0\n            else\n    \
    \            closebrackets=$(( closebrackets + 1 ))\n            fi\n        fi\n\
    \    done\n    return 1", "        local result=0\n        local index=0\n   \
    \     local char\n        for (( index=0; index<${#1}; index++ )); do\n      \
    \          char=${1:$index:1}\n                if [[ $char =~ ([^[]*\\[([^]]*\\\
    ])?) ]]; then\n                        result=1\n                        break\n\
    \                fi\n        done\n        echo $result", "  local input=$1\n\n\
    \  [[ \"$input\" =~ ^\\[.*\\]$ ]]", "    local bracket_count\n    bracket_count=$(echo\
    \ $1 | grep -o '[]*' | wc -w)\n    if [ $bracket_count -gt 0 ] ; then\n\techo\
    \ \"true\"\n    else\n\techo \"false\"\n    fi", "    local bracket_count=0\n\
    \    local open_brackets=0\n    local close_brackets=0\n    local nesting_depth=0\n\
    \    local stack=()\n\n    for char in $1 \n    do\n        if [[ \"$char\" ==\
    \ \"[\" ]]\n        then\n            open_brackets=$((open_brackets + 1))\n \
    \       elif [[ \"$char\" == \"]\" ]]\n        then\n            close_brackets=$((close_brackets\
    \ + 1))\n        fi\n\n        if [[ \"$char\" == \"[\" ]]\n        then\n   \
    \         stack+=(\"$((open_brackets + 1))\")\n        elif [[ \"$char\" == \"\
    ]\" ]]\n        then\n            if ((open_brackets != close_brackets))\n   \
    \         then\n                nesting_depth=`expr $close_brackets - $open_brackets`\n\
    \            else\n                nesting_depth=`expr $close_brackets - $close_brackets`\n\
    \            fi\n            open_brackets=$((open_brackets - 1))\n          \
    \  stack+=(\"$((open_brackets + 1))\")\n        fi\n    done\n\n    if ((close_brackets\
    \ == open_brackets))\n    then\n        nesting_depth=`expr $close_brackets -\
    \ $close_brackets`\n    else\n        nesting_depth=`expr $open_brackets - $open_brackets`\n\
    \    fi\n\n    if [[ \"$nesting_depth\" -eq 0 ]]\n    then\n        echo true\n\
    \    else\n        echo false\n    fi", "    local string=\"$1\"\n    local nesting=\"\
    ^\\[([^]]*[\\]]{0,1})*[^]]*\\]\"\n    while true; do\n        if [[ \"$string\"\
    \ =~ $nesting ]]; then\n            echo \"true\"\n            return\n      \
    \  fi\n    done", "    local s=$1\n    local b\n    local open_brackets=$(grep\
    \ -o '[' -v <<<\"$s\")\n    if [ -z \"$open_brackets\" ]\n    then\n        echo\
    \ \"false\"\n        return 0;\n    fi\n    for b in ${open_brackets}; do\n  \
    \      ((b++ )) #Count brackets\n        s=$(sed \"s/^[${b}]*//\" <<< \"$s\")\n\
    \        open_brackets=$(grep -o '[' -v <<<\"$s\")\n        if [ -z \"$open_brackets\"\
    \ ]\n        then\n            echo \"false\"\n            return 0;\n       \
    \ fi\n    done\n    echo 'true'\n    return 1", "\tlocal string=$1\n\tlocal opens='('\n\
    \tlocal closes='['\n\n\tfor i in $(seq 0 $((${#string}-1)))\n\tdo\n\t\tlocal char=$((${string:$i:1}))\n\
    \n\t\tif [[ $opens == \"$char\" ]]; then\n\t\t\topens=\"${opens},\"\n\t\t\tclosed=\"\
    ]\"\n\t\tfi\n\n\t\tif [[ $closes == \"$char\" ]]; then\n\t\t\topens=\"${opens})\"\
    \n\t\t\tclosed=\"${closed},\"\n\t\tfi\n\tdone\n\n\tif [[ ${#opens} -eq 0 ]] ;\
    \ then\n\t\techo \"true\"\n\telse\n\t\techo \"false\"\n\tfi", "    local STRING=\"\
    $1\"\n    # Create a counter variable\n    local NUM=0\n    # Iterate through\
    \ all characters in the string until we reach the closing bracket\n    for ((NUM=0;\
    \ NUM<\"${#STRING}\"; NUM++)); do\n        local CHAR=${STRING:$NUM}\n       \
    \ case \"$CHAR\" in\n            # If the current character is an opening bracket\n\
    \            [(  ;;  )]  ) NUM=$((NUM+1)); break\n            # If the current\
    \ character is a closing bracket\n            [[  ;;  ]]  ) NUM=$((NUM+1)); break\n\
    \        default ) break\n        fi\n    done\n    # If we reach the end of the\
    \ string, then there are no nested brackets\n    if [ $NUM -eq $((${#STRING}/2))\
    \ ] ; then\n        return 0\n    else\n        return 1\n    fi", "\t# Remove\
    \ spaces to compare against each other\n\tlocal string=${1//[[:space:]]/}\n\t\n\
    \t# Count number of opening-brackets and closing-brackets\n\tlocal opening_brackets=0\n\
    \tlocal closing_brackets=0\n\t\n\t# Iterate through each char in string\n\tfor\
    \ (( i=0; i<${#string}; i++ )); do\n\t\t\n\t\t# Check if the current char is opening-bracket\n\
    \t\tif [[ ${string:$i:1} == '[' ]]; then\n\t\t\topening_brackets=$((opening_brackets+1))\
    \ \n\t\telse\n\t\t\topening_brackets=$((opening_brackets-1)) \n\t\tfi\n\t\t\n\t\
    \t# Check if the current char is closing-bracket\n\t\tif [[ ${string:$i:1} ==\
    \ ']' ]]; then\n\t\t\tclosing_brackets=$((closing_brackets+1)) \n\t\telse\n\t\t\
    \tclosing_brackets=$((closing_brackets-1)) \n\t\tfi\n\tdone\n\n\t# Check if string\
    \ contains at least 2 opening-brackets and at least 2 closing-brackets\n\tif ((\
    \ opening_brackets >= 2 && closing_brackets >= 2 )); then\n\t\techo \"true\"\n\
    \telse\n\t\techo \"false\"\n\tfi", "\tlocal brackets=\"$1\"\n\tlocal nesting=0\n\
    \tlocal open_bracket='['\n\tlocal close_bracket=']'\n\tlocal depth=0\n\n\twhile\
    \ IFS=$'\\n' read -r line; do\n\t\tif [ \"$line\" != \"$open_bracket\" ] && [\
    \ \"$line\" != \"$close_bracket\" ]; then\n\t\t\techo \"ERROR: Not a valid nested\
    \ bracket\" >&2\n\t\t\texit 1\n\t\tfi\n\n\t\tif [ \"$line\" != \"$open_bracket\"\
    \ ]; then\n\t\t\techo \"ERROR: Not a valid nested bracket\" >&2\n\t\t\texit 1\n\
    \t\tfi\n\t\t\n\t\tif [ \"$line\" == \"$close_bracket\" ]; then\n\t\t\tdepth=$(($depth\
    \ - 1))\n\t\t\tif [[ $depth -lt 1 ]]; then\n\t\t\t\techo \"ERROR: Not a valid\
    \ nested bracket\" >&2\n\t\t\t\texit 1\n\t\t\tfi\n\t\telse\n\t\t\tdepth=$(($depth\
    \ + 1))\n\t\tfi\n\n\t\tif [[ \"$nesting\" -eq 0 ]]; then\n\t\t\tif [ \"$line\"\
    \ == $open_bracket ]; then\n\t\t\t\tnesting=$(($nesting + 1))\n\t\t\telse\n\t\t\
    \t\tnesting=$(($nesting - 1))\n\t\t\tfi\n\t\tfi\n\tdone <<< \"$brackets\"\n\n\t\
    if [ \"$nesting\" -eq 0 ]; then\n\t\techo \"$brackets\" | grep -q \"[$close_bracket]\"\
    \ && echo \"true\" || echo \"false\"\n\telse\n\t\techo \"$brackets\" | grep -q\
    \ \"$open_bracket\" && echo \"true\" || echo \"false\"\n\tfi", "  local bracket_count=0\n\
    \  local brackets=()\n  local bracket_opens=()\n  local bracket_closes=()\n  local\
    \ bracket_count=0\n  local brackets=()\n  local bracket_opens=()\n  local bracket_closes=()\n\
    \  local bracket_count=0\n  local brackets=()\n  local bracket_opens=()\n  local\
    \ bracket_closes=()\n  local bracket_count=0\n  local brackets=()\n  local bracket_opens=()\n\
    \  local bracket_closes=()\n\n  while [ \"$1\" ]\n  do\n    local bracket=\"${1%%[}\"\
    \n    local bracket_open=\"${1#*[\"}\"\n    local bracket_close=\"${1%]}\"\n \
    \   brackets+=($bracket)\n    bracket_opens+=($bracket_open)\n    bracket_closes+=($bracket_close)\n\
    \    local bracket_count=$(( bracket_count + 1 ))\n    local brackets=($(\n  \
    \    printf '%q ' \"${brackets[@]}\"\n      printf '%q '\n      printf '%q '\n\
    \      printf '%q '\n    ))\n  done\n\n  if [ \"$bracket_count\" -eq \"0\" ]\n\
    \  then\n    return 0\n  fi\n\n  local brackets_count=$(( ${#brackets[@]} - 1\
    \ ))\n  for (( i = 0; i < $brackets_count; i++ ))\n  do\n    if [ \"${brackets[i]}\"\
    \ = \"$1\" ]\n    then\n      return 0\n    fi\n  done\n  return 1", "    local\
    \ -r string=\"${1}\"\n    local -r result\n\n    result=\"$(grep -E \"^\\[\\[[^][]*\\\
    ]\\]$\" <<< \"$string\" > /dev/null)\"\n\n    [[ -z \"$result\" ]] || return 0\n\
    \n    echo \"true\"", "    local string=\"$1\"\n\n    # No brackets means there\
    \ are no nested brackets\n    if [ \"$string\" == \"[[]]\" ]; then\n        return\
    \ \"true\"\n    fi\n    \n    local count=0\n    local opening_bracket=\"[[\"\n\
    \    local closing_bracket=\"]]]\"\n    local new_string=\"$(echo \"$string\"\
    \ | sed 's/[]/\\\\&/g' | sed 's/'\"$opening_bracket\"'/\\\\&/g' | sed 's/'\"$closing_bracket\"\
    '/\\\\&/g' | sed 's/\\\\&/'\"$opening_bracket\"'/g' | sed 's/\\\\&/'\"$closing_bracket\"\
    '/g')\"\n\n    # Keep count of brackets and keep going until there is no more\
    \ brackets \n    # to close\n    while [ \"$string\" == \"$new_string\" ]; do\n\
    \        count=\"$(( count+1 ))\"\n        local newstring=\"$(echo \"$string\"\
    \ | sed 's/'\"$opening_bracket\"'/\\\\&/g' | sed 's/'\"$closing_bracket\"'/\\\\\
    &/g' | sed 's/\\\\&/'\"$opening_bracket\"'/g' | sed 's/\\\\&/'\"$closing_bracket\"\
    '/g')\"\n        opening_bracket=\"$(( $opening_bracket+1 ))\"\n        closing_bracket=\"\
    $(( $closing_bracket+1 ))\"\n        new_string=\"$(echo \"$newstring\" | sed\
    \ 's/'\"$opening_bracket\"'/\\\\&/g' | sed 's/'\"$closing_bracket\"'/\\\\&/g'\
    \ | sed 's/\\\\&/'\"$opening_bracket\"'/g' | sed 's/\\\\&/'\"$closing_bracket\"\
    '/g')\"\n    done\n\n    # Return true if and only if there are more closing brackets\n\
    \    [[ \"$count\" -ge \"$(( $closing_bracket+1 ))\" ]]", "\tlocal string=\"$1\"\
    \n\tlocal open=\"\\[[\"\n\tlocal close=\"\\]\"\n\n\t[[ $string =~ $open ]] &&\
    \ [[ $string =~ $close ]] || return 1\n\tlocal first=${BASH_REMATCH[1]}\n\tlocal\
    \ last=${BASH_REMATCH[${#BASH_REMATCH[@]}-1]}\n\tlocal middle=`echo $string |\
    \ sed -e 's/$first/$close/g'`\n\t[[ $middle =~ $open ]] && [[ $middle =~ $close\
    \ ]] || return 1\n\treturn 0", "  local -i num_nested=0\n  local -i prev_pos=0\n\
    \n  local brackets=$1;\n\n  while [[ \"${brackets:$prev_pos:1}\" == \"[\" ]] ;\
    \ do\n    prev_pos=$(( prev_pos + 1 ))\n    local pos\n    local i\n    local\
    \ is_bracket\n    for (( i=0;i<=num_nested;i++ )) ; do\n      pos=${brackets:$((\
    \ prev_pos + num_nested + i )):$(( num_nested + i + 1 ))}\n      if [[ $pos ==\
    \ [\\] ]]; then\n        is_bracket=true\n        break\n      fi\n    done\n\
    \    (( num_nested += is_bracket ))\n  done\n\n  echo \"$num_nested\" == \"$num_nested\"\
    \ ", "\tlocal -r string=$1\n\tlocal -r braces='[{}]'\n\n\t# if string is empty,\
    \ return true\n\tif [[ ${#string} -eq 0 ]]; then\n\t\treturn true\n\tfi\n\n\t\
    local index\n\tindex=0\n\twhile [[ ${string:${#string}-$index} != \"$braces\"\
    \ ]]; do\n\t\t# if we have a nested set of brackets, go ahead and return\n\t\t\
    if [[ (($index>0) && [[ ${string:${#string}-$index} == \"${string#${string%:*}}\"\
    \ ]]) || $index -eq 0 ]]; then\n\t\t\treturn true\n\t\tfi\n\n\t\t((index++))\n\
    \tdone\n\t# if we didn't find the end of a nested set of brackets, return false\n\
    \treturn false", "  local s=$1\n  # Check for empty string\n  if [[ $s =~ \"[]\"\
    \ ]]; then\n    return 0\n  else\n    # Find the first bracket\n    local i\n\
    \    local j\n    # Find the first nesting level by counting the number of closing\
    \ brackets\n    # until we reach the beginning of the string\n    for ((i=0; i\
    \ < ${#s}; i++)); do\n      # If this character is closed, increment the number\
    \ of brackets\n      if [[ ${s:i:1} =~ \"]\" ]]; then\n        j=$((j+1))\n  \
    \    fi\n      # If this character is opened, decrement the number of brackets\n\
    \      if [[ ${s:i:1} =~ \"[\" ]]; then\n        j=$((j-1))\n      fi\n      #\
    \ If we are back at the beginning, exit the loop\n      if [[ ${i} == 0 ]]; then\n\
    \        break\n      fi\n    done\n    # Check to see if we have opened any more\
    \ brackets\n    if [[ ${j} > 0 ]]; then\n      return 1\n    else\n      return\
    \ 0\n    fi\n  fi", "  local open_brackets=\"$(sed 's/[][]//g' <<< \"$1\")\"\n\
    \  local close_brackets=\"$(sed 's/[][]//g' <<< \"$1\")\"\n\n  # If there are\
    \ no open brackets, we are done.\n  if [ -z \"$open_brackets\" ]; then\n     \
    \ return 1\n  fi\n\n  # If there are no close brackets, we are done.\n  if [ -z\
    \ \"$close_brackets\" ]; then\n      return 0\n  fi\n\n  # If there are nested\
    \ brackets, we can't recurse.\n  if [[ \"$open_brackets\" == *\"[][]\"* ]]; then\n\
    \      return 0\n  fi\n\n  # If there are nested brackets, we can't recurse.\n\
    \  if [[ \"$close_brackets\" == *\"[][]\"* ]]; then\n      return 0\n  fi\n\n\
    \  # If the last character of the open brackets is an opening bracket\n  # and\
    \ the last character of the close brackets is an opening bracket,\n  # then we\
    \ can recurse.\n  if [[ \"$open_brackets\" == *\"$close_brackets\"* ]]; then\n\
    \      return 1\n  fi\n\n  # If the last character of the open brackets is an\
    \ opening bracket\n  # and the last character of the close brackets is a closing\
    \ bracket,\n  # then we can recurse.\n  if [[ \"$open_brackets\" == *\"$close_brackets[]\"\
    * ]]; then\n      return 1\n  fi\n\n  # If the last character of the open brackets\
    \ is an closing bracket\n  # and the last character of the close brackets is an\
    \ opening bracket,\n  # then we can recurse.\n  if [[ \"$close_brackets\" == *\"\
    $open_brackets\"* ]]; then\n      return 1\n  fi\n\n  # If the last character\
    \ of the open brackets is an opening bracket\n  # and the last character of the\
    \ close brackets is a closing bracket,\n  # then we can recurse.\n  if [[ \"$close_brackets\"\
    \ == *\"$open_brackets[]\"* ]]; then\n      return 1\n  fi\n\n  # If the last\
    \ character of the open brackets is an opening bracket\n  # and the last character\
    \ of the close brackets is a closing bracket,\n  # then we can recurse.\n  if\
    \ [[ \"$open_brackets\" == *\"$close_brackets\"* ]]; then\n      return 1\n  fi\n\
    \n  # If the last character of the open brackets is an closing bracket\n  # and\
    \ the last character of the close brackets is an opening bracket,\n  # then we\
    \ can recurse.\n  if [[ \"$close_brackets\" == *\"$open_brackets[]\"* ]]; then\n\
    \      return 1\n  fi\n\n  # If the last character of the open bracket", "  local\
    \ string=\"$1\"\n  local substring=\"\"\n  local brackets=0\n  local valid=${string//[$brackets]/}\n\
    \  for character in ${valid}; do\n    if [[ $string == $substring* ]]; then\n\
    \      brackets++\n    fi\n    substring+=\"${character}\"\n  done\n  [[ \"$brackets\"\
    \ > 0 ]]", "    local open_brackets='[[]'\n    local close_brackets='[]]'\n  \
    \  local open_brackets_count=$(echo $open_brackets | grep -c '\\[')\n    local\
    \ close_brackets_count=$(echo $close_brackets | grep -c '\\]')\n    local string=\"\
    $1\"\n\n    if [ \"$open_brackets_count\" -gt \"$close_brackets_count\" ] || [\
    \ \"$open_brackets_count\" -eq 0 ] || [ \"$close_brackets_count\" -eq 0 ]; then\n\
    \        return $string\n    fi\n    local count=0\n    local match=false\n\n\
    \    # Iterate over string in reverse order\n    for i in $(seq ${#string} -1\
    \ 1); do\n        local char=${string[$i]}\n        if [ \"$char\" = \"$open_brackets\"\
    \ ]; then\n            (( count++ ))\n        fi\n        if [ \"$char\" = \"\
    $close_brackets\" ]; then\n            (( count-- ))\n        fi\n        if [\
    \ \"$count\" = 0 ]; then\n            match=true\n            break\n        fi\n\
    \    done\n    if [ \"$match\" = true ]; then\n        echo true\n    else\n \
    \       echo false\n    fi", "  local expr=$1\n\n  # if our first character is\
    \ a left bracket then we return false\n  [[ \"${expr:0:1}\" = '[' ]] && return\
    \ 0\n  [[ \"${expr:0:1}\" = '{' ]] && return 0\n\n  # count the number of left\
    \ brackets\n  local left_brackets=${#expr}\n  if (( $left_brackets > 0 )); then\n\
    \      # count the number of right brackets\n      local right_brackets=$(( ${#expr}\
    \ - left_brackets ))\n      if (( $right_brackets == 1 )); then\n          # we\
    \ only have a left bracket\n          # return true if there is at least one right\
    \ bracket\n          [[ \"${expr:$(( left_brackets + 1 ))}\" = '[' ]] && return\
    \ 0\n      else\n          # we found a right bracket\n          # return true\
    \ if there is more than one left bracket\n          [[ \"${expr:$(( left_brackets\
    \ + 1 ))}\" = '{' ]] && return 0\n      fi\n  fi\n\n  # if we get here then our\
    \ expression has no nested brackets\n  return 1", "  local string=$1\n  local\
    \ valid=$(echo \"$string\" | grep -Eo \"[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]",
  "    # Regex to find pairs of brackets \n    # \\[{2}\n    # \\}\\]{2}\n    # or\
    \ [[[[ ...]]]]]\n    local REGEX=\"\\\\[${1}\\\\|${1}\\\\]\\\\[${1}\\\\|${1}\\\
    \\]\\\\[${1}\\\\|${1}\\\\]\\\\[${1}\\\\]\\\\[${1}\\\\|${1}\\\\]\\\\[${1}\\\\]\\\
    \\[${1}\\\\]\"\n    # $0 contains the command\n    # Match a pair of brackets\n\
    \    if [[ \"$0\" =~ $REGEX ]]; then \n        # $2 contains the second pair of\
    \ brackets\n        if [[ \"$2\" =~ $REGEX ]]; then \n            # $3 contains\
    \ the third pair of brackets\n            if [[ \"$3\" =~ $REGEX ]]; then \n \
    \               # $4 contains the fourth pair of brackets\n                if\
    \ [[ \"$4\" =~ $REGEX ]]; then \n                    # $5 contains the fifth pair\
    \ of brackets\n                    if [[ \"$5\" =~ $REGEX ]]; then \n        \
    \                # $6 contains the sixth pair of brackets\n                  \
    \      if [[ \"$6\" =~ $REGEX ]]; then \n                            # $7 contains\
    \ the seventh pair of brackets\n                            if [[ \"$7\" =~ $REGEX\
    \ ]]; then \n                                return 0\n                      \
    \      fi\n                        fi\n                    fi\n              \
    \  fi\n            fi\n        fi\n    fi\n    return 1", "\techo $1 | awk -F\"\
    [][]\" '{\n\t\tif ($3 == \"[\") {\n\t\t\tgsub(/\\[/,\"\",$1)\n\t\t\tgsub(/\\]/,\"\
    &\",$1)\n\t\t\tgsub(/\\[/,\"[&\",$1)\n\t\t\tgsub(/\\]/,\"&\",$1)\n\t\t}\n\t\t\
    print $1 }'", "  local n=$1\n  local c=0\n  local s=0\n  local open_brackets_count=0;\n\
    \  local close_brackets_count=0;\n  local last_bracket=0;\n  local last_closed=0;\n\
    \  local char=0\n  local bracket=0\n  \n  while (( $n )); do\n    char=${n:$(($c+1)):1}\n\
    \    bracket=${char:$((${#char}-1)):1}\n    \n    if (( ${open_brackets_count}\
    \ == 0 )); then\n      if (( ${close_brackets_count} > 0 )); then\n        if\
    \ (( ${close_brackets_count} > ${open_brackets_count} )); then\n          echo\
    \ \"false\"\n          return\n        fi\n      fi\n    fi\n    \n    if (( ${char}\
    \ != ${bracket} )); then\n      if (( ${last_bracket} != ${bracket} )); then\n\
    \        if (( ${open_brackets_count} > 0 )); then\n          open_brackets_count=$(($open_brackets_count+1))\n\
    \        fi\n        last_bracket=${bracket}\n      else\n        if (( ${close_brackets_count}\
    \ > 0 )); then\n          close_brackets_count=$(($close_brackets_count+1))\n\
    \        fi\n      fi\n    fi\n    \n    if (( ${char} == ${bracket} )); then\n\
    \      if (( ${close_brackets_count} > 0 )); then\n        close_brackets_count=$(($close_brackets_count+1))\n\
    \      fi\n      if (( ${open_brackets_count} == 0 )); then\n        echo \"true\"\
    \n        return\n      fi\n    fi\n    \n    if (( $open_brackets_count > ${close_brackets_count}\
    \ )); then\n      open_brackets_count=$(($open_brackets_count-1))\n    fi\n  \
    \  \n    if (( $close_brackets_count < ${open_brackets_count} )); then\n     \
    \ close_brackets_count=$(($close_brackets_count+1))\n    fi\n    \n    if (( $close_brackets_count\
    \ == ${open_brackets_count} )); then\n      if (( $close_brackets_count > 0 ));\
    \ then\n        open_brackets_count=$(($open_brackets_count+1))\n      fi\n  \
    \    last_closed=$(($last_closed+1))\n    fi\n    \n    if (( $last_closed !=\
    \ $last_bracket )); then\n      echo \"false\"\n      return", "    # remove $1\
    \ from string\n    local -n str=$1\n    local -n brackets='[[[[]'\n\n    # initialize\
    \ result to true (no nesting)\n    result=\"true\"\n\n    # remove all brackets\n\
    \    str=\"${str//\\\"/$brackets}\"\n\n    # remove all nested brackets\n    while\
    \ [[ $str ]]; do\n        local -n str=$str\n        result=\"${result}${str#*($brackets)}\"\
    \n        local -n str=$str\n        result=\"${result}${str%*($brackets)}\"\n\
    \    done\n    \n    # return true if and only if result contains at least one\
    \ nesting bracket\n    return [[ \"$result\" = *\"$brackets\"* ]]", "\tlocal line=\"\
    $1\" index=0\n\twhile [ \"$line\" != \"[]\" ] && [ \"$line\" != \"\" ] ; do\n\t\
    \tindex=$((index+1))\n\t\tline=\"${line:$((index)):1}\"\n\tdone\n\tif [ \"$line\"\
    \ == \"[]\" ]; then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi", "    local string=\"\
    $1\"\n    local result=0\n    local opening=${string[0]}\n    local closing=${string[1]}\n\
    \    local opening_counter=1\n    local closing_counter=1\n    local start_counter=1\n\
    \    for chars in $string; do\n        if [ \"$chars\" == \"$opening\" ] ; then\n\
    \            opening_counter=$(($opening_counter+1))\n        elif [ \"$chars\"\
    \ == \"$closing\" ] ; then\n            closing_counter=$(($closing_counter+1))\n\
    \        elif [ \"$opening_counter\" -gt \"$closing_counter\" ] ; then\n     \
    \       result=$(($result+1))\n            opening_counter=1\n            closing_counter=1\n\
    \            start_counter=1\n        elif [ \"$chars\" == \"$opening\" ] || [\
    \ \"$chars\" == \"$closing\" ] ; then\n            opening_counter=$(($opening_counter+1))\n\
    \            closing_counter=$(($closing_counter+1))\n        elif [ \"$start_counter\"\
    \ -ge \"$closing_counter\" ] ; then\n            result=$(($result+1))\n     \
    \       opening_counter=$((start_counter+1))\n            closing_counter=1\n\
    \            start_counter=1\n        elif [ \"$chars\" == \"[\" ] ; then\n  \
    \          start_counter=$(($start_counter+1))\n        elif [ \"$chars\" == \"\
    ]\" ] ; then\n            opening_counter=$(($opening_counter-1))\n        elif\
    \ [ \"$opening_counter\" -gt \"$start_counter\" ] ; then\n            result=$(($result+1))\n\
    \            opening_counter=1\n        elif [ \"$chars\" == \"$closing\" ] ;\
    \ then\n            opening_counter=$(($opening_counter-1))\n        fi\n    done\n\
    \    echo $result", "    # $2 is a string to be tested\n    local tststmp=\"${1//[$2]/}\"\
    \n    local valid=\"${tststmp##*/}\"\n    local brackets=\"${tststmp%/*}\"\n \
    \   local left=\"${brackets##*[}\"\n    local right=\"${brackets%%*]}\"\n    [\
    \ \"$left\" == \"$right\" ] || [ \"$left\" != \"$valid\" ]", "    local bracket_count=$(echo\
    \ $1 | grep -o \"[^]]*\" | wc -w)\n    local open_bracket_count=$(echo $1 | grep\
    \ -o \"[[*]*\" | wc -w)\n    local close_bracket_count=$(echo $1 | grep -o \"\
    [*]\" | wc -w)\n    local open_bracket_positions=$(echo $1 | grep -o \"[[*]*\"\
    \ | cut -c2-)\n    local close_bracket_positions=$(echo $1 | grep -o \"[*]\" |\
    \ cut -c2-)\n\n    # return true if $1 contains any brackets at all with \n  \
    \  # both an open and close bracket \n    # in the correct position \n    if [\
    \ $open_bracket_count = $close_bracket_count -eq 0 ]; then\n        return 1\n\
    \    fi\n\n    # if $1 contains only square brackets\n    # then there must be\
    \ at least one nested one\n    if [ $bracket_count -eq 0 ]; then\n        return\
    \ 0\n    fi\n\n    # check if $1 contains a bracket in the correct position\n\
    \    # for each open bracket\n    for index in $(seq 0 $open_bracket_count-1)\n\
    \    do\n        if [ $(expr index - 1) -le $open_bracket_positions ] && [ $(expr\
    \ index + 1) -le $close_bracket_positions ]; then\n            local found_bracket=false\n\
    \            for character in $(echo $1 | cut -c$((index+1))-$((index-1)))\n \
    \           do\n                if [ \"$character\" = \"$open_bracket\" ]; then\n\
    \                    found_bracket=true\n                    break\n         \
    \       fi\n            done\n            if [ $found_bracket -eq true ]; then\n\
    \                return 0\n            fi\n        fi\n    done\n    return 1",
  "\tlocal n\n\tlocal t\n\tlocal bracket_count\n\tbracket_count=0\n\twhile read -r\
    \ n; do\n\t\tif [[ \"$n\" =~ (^[[*]).*([[][)] ]]; then\n\t\t\tbracket_count=$((${bracket_count}+1))\n\
    \t\tfi\n\tdone <<< \"$1\"\n\tt=$((${bracket_count}==0))\n\treturn \"$t\"", " \
    \   local brackets=${1:-\\[\\]} \\\n    local open=0 \\\n    local closed=0\n\
    \    local open_brackets=0\n    local closed bracket_count=0\n    while [[ $1\
    \ ]]; do \n        if [[ $1 == $brackets ]]; then\n            bracket_count=$((bracket_count\
    \ + 1))\n        fi\n        open=$((open + 1))\n        closed=$((closed))\n\
    \        if [[ $1 == [$brackets ]]; then\n            open_brackets=$((open_brackets\
    \ + 1))\n        fi\n        open=$((open - 1))\n        closed=$((closed - 1))\n\
    \    done \\\n    if [[ $((open_brackets + closed)) = *[([] ]]; then\n       \
    \ return \"true\"\n    else\n        return \"false\"\n    fi", "    local b=\"\
    []\"\n    local c=\"$1\"\n    local bidx=0\n    local cidx=0\n    while [ $[ $cidx\
    \  -le $( ${#c} ) ] ]\n        do\n            local bidx=$(expr ${bidx} + 1)\n\
    \            local b=${b:0:$bidx}\n            local bidx=$(expr ${bidx} + $[\
    \ ${#b} ])\n            c=${c:$[$cidx]}\n            local cidx=$(expr ${cidx}\
    \ + 1)\n        done\n    [[ $( $bidx  -eq $( ${#b} ) ) ]] && return 0\n    return\
    \ 1", "    [ -z \"$1\" ] && return 1\n    # remove square brackets\n    local\
    \ stripped=$(echo \"$1\" | sed 's/\\[//g' | sed 's/\\]//g')\n    # find the length\
    \ of the original string\n    local length=\"${#stripped}\"\n    # find all nested\
    \ brackets\n    local count=$(echo \"$stripped\" | grep -o '[^\\]]*' | wc -l)\n\
    \    echo $(( length != $count ))", "  local brackets=\"$(echo \"$1\" | sed 's/[][]//g')\"\
    \ # remove all brackets\n  local bracket_count=\"$(echo \"$brackets\" | wc -c)\"\
    \n  local bracket_is_nested=\"false\"\n  local i\n\n  for i in $(seq 0 \"$((${#brackets}-1))\"\
    ); do\n    if [[ \"${brackets:i:1}\" == \"[\" ]]; then\n      bracket_is_nested=\"\
    true\"\n    fi\n  done\n  if [[ \"$bracket_count\" -gt \"0\" ]]; then\n    echo\
    \ \"true\"\n  else\n    echo \"false\"\n  fi", "\tlocal open=0 closed=0\n\tlocal\
    \ arr=$(echo \"$1\" | sed 's/[][*]//g')\n\t\n\tfor (( i=1; i<${#arr}; i++ ));\
    \ do\n\t\tif [ ${arr:$i:1} == \"[\" ]; then\n\t\t\tlet open+=1\n\t\telse\n\t\t\
    \tlet closed+=1\n\t\tfi\n\tdone\n\t\n\tif (( $open == $closed )); then\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tfi", "\t# Create a counter\n\ta=0\n\n\t# Iterate\
    \ over all characters in string\n\tfor (( i=1; i<=$#1; i++ ))\n\t\t# If the character\
    \ at index \"$i\" is a square bracket, increment the counter\n\t\t[ \"$1\" = \"\
    [[$1\" ] ]] && let \"a++\"\n\t\n\t# Return the result of the test\n\t[ \"$a\"\
    \ = \"$#1\" ]", "    local bracket_str=\"$1\"\n    local depth=0\n    local inside_str=\"\
    \"\n    local inside_type=\"\"\n    local last_bracket_type=\"\"\n    local is_valid_str=false\n\
    \    local valid_str=\"\"\n    local valid_type=\"\"\n\n    # Initialize starting\
    \ variables\n    depth=0\n    inside_str=\"\"\n    inside_type=\"\"\n    last_bracket_type=\"\
    \"\n    is_valid_str=false\n    valid_str=\"\"\n    valid_type=\"\"\n    \n  \
    \  # Iterate through the string and increase depth every time we see a [\n   \
    \ while [[ ${bracket_str} == \"[\" ]]; do\n        depth=$((depth+1))\n      \
    \  bracket_str=\"${bracket_str#\\[}\"\n    done\n    \n    # Iterate through the\
    \ string until we see the closing bracket\n    while [[ ${bracket_str} != \"]\"\
    \ ]]; do\n        bracket_str=\"${bracket_str#\\]}\"\n    done\n    \n    # If\
    \ the string is empty, then return false\n    [[ ${bracket_str} == \"\" ]] &&\
    \ return 0\n\n    depth=$((depth-1))\n    # Iterate through the string and check\
    \ if we find nested brackets\n    for ((i=1; i<${depth}; i++)); do\n        if\
    \ [[ -z ${bracket_str} ]]; then\n            # If we find an empty string, then\
    \ the string is invalid\n            return 0\n        elif [[ \"${bracket_str}\"\
    \ == \"[\" ]]; then\n            if [[ ${last_bracket_type} != \"(\" ]]; then\n\
    \                # If the type of the current bracket is not \"(\" then it's not\
    \ nested\n                is_valid_str=false\n                valid_type=\"$(get_bracket_type\
    \ ${bracket_str})\"\n                if [[ ${depth} -gt 0 ]]; then\n         \
    \           # If the depth is greater than 0, then the string is valid\n     \
    \               is_valid_str=true\n                    valid_str=\"${bracket_str}\"\
    \n                fi\n                bracket_str=\"\"\n                break\n\
    \            fi\n            bracket_str=\"${bracket_str#\\[}\"\n        elif\
    \ [[ \"${bracket_str}\" == \"]\" ]]; then\n            if [[ ${last_bracket_type}\
    \ != \"(\" ]]; then\n                # If the type of the current bracket is not\
    \ \"(\" then it's not nested\n                is_valid_str=false\n           \
    \     valid_type=\"$(get_bracket_type ${bracket_str})\"\n                if [[\
    \ ${depth} -gt 0 ]]; then\n                    # If the depth is greater than\
    \ 0, then the string is valid\n                    is_valid_str=true\n       \
    \             valid_str=\"${bracket_", "    local STRING=$1\n    local COUNT=0\n\
    \    local STRING_LEN=${#STRING}\n\n    while [ $COUNT -lt $STRING_LEN ]; do\n\
    \        if [[ ${STRING:$COUNT:1} == \"[\" ]]; then\n            COUNT=$((COUNT\
    \ + 1))\n        elif [[ ${STRING:$COUNT:1} == \"]\" ]]; then\n            COUNT=$((COUNT\
    \ + 1))\n        else\n            return 0\n        fi\n    done\n    return\
    \ 1", "  # $2 is the opening bracket [ or ] which is an optional argument and\
    \ must be supplied\n  # $3 is the closing bracket ] which is an optional argument\
    \ and must be supplied\n  # $4 is the optional argument ]] which is an optional\
    \ argument and must be supplied\n  # $5 is the optional argument [[[[ which is\
    \ an optional argument and must be supplied\n  # $6 is the optional argument [[[\
    \ which is an optional argument and must be supplied\n  # $7 is the optional argument\
    \ [[] which is an optional argument and must be supplied\n  \n  # test if $2 is\
    \ set\n  [[ ! -z $2 ]] || {\n    echo \"$FUNCNAME: No opening bracket is supplied\"\
    \n    return 1\n  }\n\n  # test if $3 is set\n  [[ ! -z $3 ]] || {\n    echo \"\
    $FUNCNAME: No closing bracket is supplied\"\n    return 1\n  }\n\n  # test if\
    \ $4 is set\n  [[ ! -z $4 ]] || {\n    echo \"$FUNCNAME: No optional ']' is supplied\"\
    \n    return 1\n  }\n\n  # test if $5 is set\n  [[ ! -z $5 ]] || {\n    echo \"\
    $FUNCNAME: No optional '[[' is supplied\"\n    return 1\n  }\n\n  # test if $6\
    \ is set\n  [[ ! -z $6 ]] || {\n    echo \"$FUNCNAME: No optional '[[[' is supplied\"\
    \n    return 1\n  }\n\n  # test if $7 is set\n  [[ ! -z $7 ]] || {\n    echo \"\
    $FUNCNAME: No optional '[[]' is supplied\"\n    return 1\n  }\n\n  # test if $2\
    \ has valid syntax\n  # test if $2 has brackets\n  # test if $3 is open\n  # test\
    \ if $4 is close\n  # test if $5 is open\n  # test if $6 is open\n  # test if\
    \ $7 is close\n  # test if $7 has brackets\n  [[ \"$2\" =~ ^\\[?[^\\[\\]]*\\]?[^\\\
    [\\]]*$3 =~ ^\\[?[^\\[\\]]*\\]?[^\\[\\]]*$4 =~ ^\\[?[^\\[\\]]*\\]?[^\\[\\]]*$5\
    \ =~ ^\\[?[^\\[\\]]*\\]?[^\\[\\]]*$6 =~ ^\\[?[^\\[\\]]*\\]?[^\\[\\]]*$7 =~ ^\\\
    [?[^\\[\\]]*\\]?[^\\[\\]]", "   if [[ \"$1\" =~ \\[([[:space:]]*)(\\[\\[\\[([[:space:]]*)\\\
    )|\\][[:space:]]*)\\]\\] ]]; then\n      echo \"true\"\n   else\n      echo \"\
    false\"\n   fi", "    # Remove the first and last character from the string\n\
    \    local str=\"${1:1:${#1}-1}\"\n    # Strip all inner brackets\n    str=\"\
    ${str//[[]/}\"\n    str=\"${str//][]/}\"\n    # Remove all nested brackets\n \
    \   str=\"${str//]]/}\"\n    # Return true\n    echo \"true\"", "    local string=\"\
    $1\"\n    local index=0\n    local count=0\n    local brackets=0\n    local open_brackets=0\n\
    \n    while [ $count -le ${#string} ]; do\n        if [ \"${string:$index:1}\"\
    \ = \"[\" ]; then\n            brackets+=1 # count the brackets in the input string\n\
    \            open_brackets+=1 # count the brackets opened in the current string\n\
    \        fi\n\n        if [ \"${string:$index:1}\" = \"{\" ] && [ ${open_brackets}\
    \ -gt 0 ]; then\n            brackets+=1 # count the brackets in the input string\n\
    \            open_brackets+=1 # count the brackets opened in the current string\n\
    \        fi\n\n        if [ \"${string:$index:1}\" = \"}\" ] && [ ${open_brackets}\
    \ -gt 0 ]; then\n            brackets-=1 # count the brackets opened in the current\
    \ string\n            open_brackets-=1 # count the brackets opened in the current\
    \ string\n        fi\n\n        index=$((index+1)) # move to the next character\n\
    \n        if [ \"${string:$index:1}\" = \"]\" ] && [ ${brackets} -gt 0 ]; then\n\
    \            brackets-=1 # count the brackets in the input string\n        fi\n\
    \n        if [ \"${string:$index:1}\" = \"]\" ] && [ ${brackets} -lt 0 ]; then\n\
    \            brackets+=1 # count the brackets in the input string\n        fi\n\
    \n        if [ \"${string:$index:1}\" = \"}\" ] && [ ${brackets} -eq 0 ]; then\n\
    \            brackets+=1 # count the brackets in the input string\n        fi\n\
    \n        if [ \"${string:$index:1}\" = \"}\" ]; then\n            brackets-=1\
    \ # count the brackets in the input string\n        fi\n\n        ((count++))\n\
    \    done\n\n    echo \"$((brackets > 0))\"", "  local brackets_check='[[]]'\n\
    \  local bracket_count=0\n  local open_brackets=0\n  local close_brackets=0\n\n\
    \  local open_brackets_flag=0\n  local close_brackets_flag=0\n\n  local bracket_flag=0\n\
    \  local valid_flag=0\n\n  local string=$1\n  local string_count=$((${#string}\
    \ - 1))\n\n  for (( i = 0; i < $string_count; i++ )); do\n    bracket_flag=0\n\
    \    if [[ $string =~ $brackets_check ]]; then\n      bracket_flag=1\n      bracket_count=$((${#string}\
    \ - i))\n      open_brackets=$(expr $open_brackets + ${#string})\n      open_brackets_flag=1\n\
    \    elif [[ ( $string =~ \"[]\" ) ]]; then\n      bracket_flag=1\n      close_brackets_flag=1\n\
    \      close_brackets=$(expr $close_brackets + ${#string})\n      close_brackets_flag=1\n\
    \    else\n      if [[ $bracket_flag == 1 ]]; then\n        open_brackets=$(expr\
    \ $open_brackets - 1)\n      else\n        close_brackets=$(expr $close_brackets\
    \ - 1)\n      fi\n    fi\n  done\n\n  if [[ $open_brackets_flag == 1 ]]; then\n\
    \    valid_flag=1\n  fi\n\n  if [[ $close_brackets_flag == 1 ]]; then\n    valid_flag=1\n\
    \  fi\n\n  if [[ $valid_flag == 1 ]]; then\n    echo \"$1\"\n  else\n    echo\
    \ \"false\"\n  fi", "    local s=$1\n    # Replace all brackets with a single\
    \ character\n    s=$(echo \"${s}\" | sed 's/[][][]/\\[\\]/g')\n    \n    # Iterate\
    \ through the characters\n    for (( i=0; i<${#s}; i++ )); do\n        # If the\
    \ character at position i is not a closing bracket, continue\n        if [[ ${s:$i:1}\
    \ != \"[]\" ]]; then\n            continue\n        fi\n        # Otherwise, if\
    \ the character is opening bracket, increase count of open\n        # brackets\
    \ and decrease count of closed brackets\n        if [[ ${s:$i:1} == \"[\" ]];\
    \ then\n            (( ${#_open_brackets[@]} += 1 ))\n        elif [[ ${s:$i:1}\
    \ == \"]\" ]]; then\n            (( ${#_closed_brackets[@]} -= 1 ))\n        fi\n\
    \        # If count of open brackets is equal to count of closed brackets, return\
    \ true\n        if [[ ${#_open_brackets[@]} -eq ${#_closed_brackets[@]} ]]; then\n\
    \            echo true\n            return\n        fi\n    done\n    echo false",
  "    local bracket_count=1\n    local brackets=$( echo $1 | grep -E '^\\[+\\]' |\
    \ tr '[:upper:]' '[:lower:]')\n    for bracket in $brackets; do\n        if [\
    \ \"$bracket\" = \"[\\]\\]\" ] && [ \"$bracket_count\" -gt \"0\" ]; then\n   \
    \         bracket_count=$(( $bracket_count - 1 ))\n        fi\n    done\n    if\
    \ [ \"$bracket_count\" = \"0\" ]; then\n        echo true\n    else\n        echo\
    \ false\n    fi", "    local -r arg=\"$1\"\n    local -r found=''\n    local -r\
    \ count=0\n\n    for (( i=0; i < ${#arg}; i++ )); do\n        if [[ ${arg:i:1}\
    \ != \"[\" ]]; then\n            found=\"${arg:i:1}\"\n            break\n   \
    \     fi\n        (( count++ ))\n    done\n\n    if [[ $count -gt 0 ]]; then\n\
    \        echo \"${arg} is nested\"\n    else\n        echo \"${arg} is not nested\"\
    \n    fi", "  local first=\"[${1#\\[}\"\n  local last=\"[${1#*\\[}\"\n  if [[\
    \ $first == $last ]] ; then\n    echo \"false\"\n  else\n    echo \"true\"\n \
    \ fi", "  \n  local string=$1\n  \n  # remove bracket pairs with empty nests [[]]\n\
    \  # keep [[]] bracket pairs with non-empty nests [[][]]\n  string=${string//[][]}\n\
    \  \n  # remove empty brackets []\n  # keep [[]] bracket pairs with non-empty\
    \ nests [[]]\n  string=${string//[]}\n  \n  # remove empty brackets []\n  # keep\
    \ [[]] bracket pairs with non-empty nests []\n  string=${string//[]}\n  \n  #\
    \ remove brackets []\n  # keep [[]] bracket pairs with non-empty nests []\n  string=${string//[]}\n\
    \  \n  # Remove all square brackets \n  # keep [[]] bracket pairs with non-empty\
    \ nests []\n  string=${string//[\\[\\]]}\n  \n  # Remove all brackets \n  # keep\
    \ [[]] bracket pairs with non-empty nests []\n  string=${string//[\\[\\]]}\n \
    \ \n  # Remove all brackets \n  # keep [[]] bracket pairs with non-empty nests\
    \ []\n  string=${string//[\\[\\]]}\n  \n  # Remove all brackets \n  # keep [[]]\
    \ bracket pairs with non-empty nests []\n  string=${string//[\\[\\]]}\n  \n  #\
    \ Remove all brackets \n  # keep [[]] bracket pairs with non-empty nests []\n\
    \  string=${string//[\\[\\]]}\n  \n  # Remove all brackets \n  # keep [[]] bracket\
    \ pairs with non-empty nests []\n  string=${string//[\\[\\]]}\n  \n  # Remove\
    \ all brackets \n  # keep [[]] bracket pairs with non-empty nests []\n  string=${string//[\\\
    [\\]]}\n  \n  # Remove all brackets \n  # keep [[]] bracket pairs with non-empty\
    \ nests []\n  string=${string//[\\[\\]]}\n  \n  # Remove all brackets \n  # keep\
    \ [[]] bracket pairs with non-empty nests []\n  string=${string//[\\[\\]]}\n \
    \ \n  # Remove all brackets \n  # keep [[]] bracket pairs with non-empty nests\
    \ []\n  string=${string//[\\[\\]]}\n  \n  # Remove all brackets \n  # keep [[]]\
    \ bracket pairs with non-empty nests []\n  string=${string//[\\[\\]]}\n  \n  #\
    \ Remove all brackets \n  # keep [[]] bracket pair", "  declare -i start=0\n \
    \ declare -i end=0\n  declare -i len=$#\n  declare -i nest=0\n  \n  # find first\
    \ \"[\" after $start\n  while [ $start -lt $len ] && [ $1 -eq \"[$start]\" ];\
    \ do start=$(($start+1)); done\n  # find first \"]\" after $start\n  while [ $end\
    \ -lt $len ] && [ $1 -eq \"[$end]\" ]; do end=$(($end+1)); done\n  # check if\
    \ there is another \"]\" inside $1 to see if $1 contains at least one nested \"\
    [\" \n  if [ $start -eq $end ]; then return 1; fi\n\n  # check substring\n  while\
    \ [ $start -lt $end ]; do\n    if [ $1 -eq \"[$start]\" ]; then \n      nest=1\n\
    \      # find next \"[\" and increment $start\n      while [ $start -lt $len ]\
    \ && [ $1 -eq \"[$start]\" ]; do start=$(($start+1)); done\n    else \n      #\
    \ find next \"]\" and decrement $end\n      while [ $end -ge $len ] && [ $1 -eq\
    \ \"[$end]\" ]; do end=$(($end-1)); done\n    fi\n  done\n  return 0", "\tlocal\
    \ input=${1:-}\n\tlocal brackets=0\n\tlocal i\n\tfor i in $(seq 0 $((${#input}-1)));\
    \ do\n\t\tif [[ ${input:$i:1} =~ ^\\[\\[\\]\\] ]]; then\n\t\t\tlet brackets=$brackets+1\n\
    \t\tfi\n\tdone\n\tif [[ $brackets -gt 0 ]]; then\n\t\treturn 0\n\telse\n\t\treturn\
    \ 1\n\tfi", "    local bracket_count\n    bracket_count=0\n    local bracket_index\n\
    \    local bracket_length\n    local bracket_string\n    local bracket_start\n\
    \    local bracket_end\n    local bracket_char\n    bracket_string=\"${1}\"\n\
    \    while [[ $bracket_string =~ \\[([^\\[\\]]*)(?<![\\\\])\\] ]]; do\n      \
    \  bracket_index=\"${BASH_REMATCH[1]}\"\n        bracket_char=\"${BASH_REMATCH[2]}\"\
    \n        if [[ \"$bracket_count\" -lt \"$bracket_index\" ]]; then\n         \
    \   bracket_count=$(( bracket_count+1 ))\n        else\n            bracket_end=$((\
    \ bracket_index+1 ))\n            if (( bracket_end > bracket_count )) ; then\n\
    \                return 0\n            else\n                bracket_count=$((\
    \ bracket_count ))\n            fi\n        fi\n    done\n    return 1", "\tlocal\
    \ brackets=$(sed -e 's/[][]//g' <<< \"$1\")\n\n\tlocal len=0\n\twhile [[ \"$len\"\
    \ -lt \"${#brackets}\" ]]; do\n\t\tlocal index=0\n\t\twhile [[ ! -z \"${brackets[$index]}\"\
    \ ]] && [[ ! \"$brackets[$index]\" =~ \"]]\" ]]; do\n\t\t\tindex=$((index+1))\n\
    \t\tdone\n\t\tlet index=$((index+1))\n\t\tif [[ \"$index\" -eq \"${#brackets}\"\
    \ ]]; then\n\t\t\treturn 0\n\t\tfi\n\tdone\n\treturn 1", "  # Return true if the\
    \ string contains any square brackets\n  [[ $1 =~ [\\[\\] ]] ] || return 0\n \
    \ # Return true if the string contains a valid nesting of square brackets\n  [[\
    \ $(eval echo '\\\n    # Create a regular expression that matches square brackets\n\
    \    [\\[\\]]+\n    # Make sure there is at least one matching pair of brackets\n\
    \    (?=(?:[^\\[\\]]*\\[\\[\\])*[^\\[\\]])\n    # Make sure all closing brackets\
    \ are matched\n    \\g') =~ [^\\[\\]]* ]] || return 0\n  return 1", "    local\
    \ str=\"$1\"\n    local opens='[[]'\n    local closes='[]]'\n    local in_string=false\n\
    \    local in_bracket=false\n    local level=0\n    local num_open=0\n    local\
    \ num_close=0\n    local strlen=$#\n    while [[ $strlen -ge 1 ]]; do\n      \
    \  strlen=$(($strlen-1))\n        local c=\"$str[$strlen]\"\n        if [[ \"\
    $c\" == \"$opens\" ]]; then\n            in_string=true\n            level=$(($level+1))\n\
    \            num_open=$(($num_open+1))\n        elif [[ \"$c\" == \"$closes\"\
    \ ]]; then\n            in_string=false\n            level=$(($level-1))\n   \
    \         num_close=$(($num_close+1))\n        else\n            if [[ \"$in_string\"\
    \ == \"true\" ]]; then\n                if [[ \"$c\" == \"$opens\" ]]; then\n\
    \                    num_open=$(($num_open-1))\n                elif [[ \"$c\"\
    \ == \"$closes\" ]]; then\n                    num_close=$(($num_close-1))\n \
    \               fi\n            fi\n            if [[ \"$in_bracket\" == \"true\"\
    \ ]]; then\n                if [[ \"$c\" == \"$opens\" ]]; then\n            \
    \        level=$(($level+1))\n                elif [[ \"$c\" == \"$closes\" ]];\
    \ then\n                    level=$(($level-1))\n                fi\n        \
    \    fi\n        fi\n    done\n    local result=false\n    if [[ \"$num_open\"\
    \ -ge 1 ]]; then\n        if [[ \"$num_close\" -ge 1 ]]; then\n            result=true\n\
    \        fi\n    fi\n    echo \"$result\"", "\tlocal substring=$1 \n\tlocal open_brackets=''\
    \ \n\tlocal close_brackets=''\n\tlocal nested_brackets=''\n\tlocal count=0\n\t\
    local open_brackets_count=0\n\tlocal close_brackets_count=0\n\tlocal is_valid=true\n\
    \n\twhile [ \"$substring\" != \"\" ]; do\n\t\topen_brackets=\"$open_brackets$substring\"\
    \n\t\tsubstring=${substring:(-1)}\n\t\tclose_brackets=\"$close_brackets$substring\"\
    \n\n\t\topen_brackets_count=$((open_brackets_count+1))\n\t\tclose_brackets_count=$((close_brackets_count+1))\n\
    \t\tcount=$((count+1))\n\n\t\tif [ \"$open_brackets\" != \"$close_brackets\" ];\
    \ then \n\t\t\tif [ \"$open_brackets_count\" -eq \"1\" ]; then\n\t\t\t\tif [ \"\
    $close_brackets_count\" -eq \"0\" ]; then\n\t\t\t\t\tis_valid=false\n\t\t\t\t\t\
    break\n\t\t\t\telse\n\t\t\t\t\tis_valid=true\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\
    \telse\n\t\t\t\tis_valid=true\n\t\t\t\tbreak\n\t\t\tfi\n\t\telse\n\t\t\tis_valid=false\n\
    \t\t\tbreak\n\t\tfi\n\tdone\n\n\treturn $is_valid", "\tlocal string=$1\n\tlocal\
    \ count=0\n\tlocal brackets=0\n\t\n\t# Count the brackets\n\twhile [ $string ];\
    \ do\n\t\tif [[ \"$string\" =~ [^\\[\\]]* ]]; then\n\t\t\tbrackets=$((brackets\
    \ + 1))\n\t\tfi\n\t\tstring=${string//\\[\\]}\n\tdone\n\t\n\tif [ \"$brackets\"\
    \ -gt 1 ]; then\n\t\treturn false\n\telse\n\t\treturn true\n\tfi", "    local\
    \ str=\"$1\"\n\n    local i=0;\n    local inside=0;\n\n    while [ \"$i\" -lt\
    \ \"${#str}\" ]; do\n        if [[ \"$str\" == \"[\" || \"$str\" == \"[[]\" ||\
    \ \"$str\" == \"[[\" || \"$str\" == \"[][]\" || \"$str\" == \"[]\" || \"$str\"\
    \ == \"[][\" || \"$str\" == \"[[][]\" || \"$str\" == \"[[][][\" || \"$str\" ==\
    \ \"[[][][]\" || \"$str\" == \"[[][][][\" ]]]]\" ]]]]\" ]]]]]]\" ]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\"\
    \ ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ]]]]]]\" ", "    [[ \"\
    $1\" =~ ^\\[\\[*\\]\\]+$ ]] || return 1\n    return 0", "   local STR=\"$1\"\n\
    \   local STR2=\"$(echo \"$STR\" | tr -d '[]')\"\n   while [[ \"$STR2\" != \"\"\
    \ ]]; do\n      if [[ \"$STR2 == \"[\" ]]; then\n         return 0\n      fi\n\
    \      if [[ \"$STR2 == \"]\" ]]; then\n         return 1\n      fi\n      STR2=\"\
    $(echo \"$STR2\" | tr -d '[]')\"\n   done\n   return 0", "  # Only accept a string\n\
    \  [[ -z \"$1\" ]] && return 1\n  # Return true if nested brackets are present\n\
    \  [[ $1 =~ \\[*\\] ]] && return 1\n  [[ $1 =~ \\[*\\]\\] ]] && return 0\n  [[\
    \ $1 =~ \\[]\\]* ]] && return 1\n  [[ $1 =~ \\[*\\]\\] ]] && return 0\n  [[ $1\
    \ =~ \\[]* ]] && return 1\n  [[ $1 =~ \\[]* ]] && return 0\n  return 0", '    [[
    "$1" =~ \[*\]\] ]]', "    local str=\"$1\"\n    local brackets=$2\n    local depth=0\n\
    \n    # Loop through every character in the string\n    for ((i=1; i<=${#str};\
    \ i=i+1)); do\n        if [[ \"${str:$i:1}\" == \"[\" ]]; then\n            #\
    \ Increase depth\n            ((depth+=1))\n\n            # Loop through every\
    \ character in the string\n            for ((j=${#str}; j>i; j--)); do\n     \
    \           if [[ \"${str:$j:1}\" == \"[\" ]]; then\n                    # Increase\
    \ depth\n                    ((depth+=1))\n                fi\n            done\n\
    \            \n            # Check if the depth is less than the length of the\
    \ brackets\n            if ((${depth} < ${#brackets})); then\n               \
    \ return 0\n            else\n                return 1\n            fi\n     \
    \   fi\n    done", "  local input_string=\"$1\"\n  local depth=0\n  local bracket_count=0\n\
    \  local bracket_depth=1\n\n  while [[ \"$input_string\" =~ (\\[\\[\\[\\[\\[.*\\\
    ]\\]\\]\\]\\])(.*)$ ]]; do\n    bracket_count=$((bracket_count+1))\n    bracket_depth=$((bracket_depth+1))\n\
    \    if [[ \"$bracket_depth\" -eq \"1\" ]]; then\n      if [[ -z \"$input_string\"\
    \ ]]; then\n        break\n      fi\n    fi\n    depth=$((depth+1))\n    bracket_depth=$((bracket_depth-1))\n\
    \    input_string=\"${BASH_REMATCH[2]}\"\n  done\n\n  if [[ \"$bracket_count\"\
    \ -eq \"0\" ]]; then\n    return 1\n  else\n    return 0\n  fi", "  local brackets=0\n\
    \  local open_brackets=0\n  local close_brackets=0\n  local open_brackets_stack=\"\
    [\" close_brackets_stack=\"]\"\n  local close_brackets_stack=\"]\"\n  local bracket_nesting_limit=${2:-4}\n\
    \n  while [[ ${#1} != 0 ]]\n  do\n    local open_brackets_position=\"${1:0:1}\"\
    \n    local close_brackets_position=\"${1:1:1}\"\n    local open_brackets_position_stack=\"\
    ${open_brackets_stack}${open_brackets_position}\"\n    local close_brackets_position_stack=\"\
    ${close_brackets_stack}${close_brackets_position}\"\n\n    if [[ \"${open_brackets_position_stack}${close_brackets_position_stack}\"\
    \ == \"${open_brackets_stack}${close_brackets_stack}\" ]]\n    then\n      brackets=${brackets}/2\n\
    \      open_brackets=${open_brackets-1}\n      close_brackets=${close_brackets-1}\n\
    \      open_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n   \
    \   close_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n     \
    \ open_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n      close_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n\
    \    elif [[ \"${open_brackets_position_stack}${close_brackets_position_stack}\"\
    \ == \"${open_brackets_stack}${close_brackets_stack}${close_brackets_stack}\"\
    \ ]]\n    then\n      brackets=${brackets}/3\n      open_brackets=${open_brackets-1}\n\
    \      close_brackets=${close_brackets-1}\n      open_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n\
    \      close_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n  \
    \    open_brackets_stack=${open_brackets_stack}${close_brackets_stack}\n     \
    \ close_brackets_stack=${open_bracket", "    local stack=\"()\"\n    local i\n\
    \    local j\n    local bracket_count\n    bracket_count=0\n    for ((i = 0; i\
    \ < $1; i++)); do\n        if [[ $1 = \"[$stack\"* ]]; then\n            bracket_count=$((${bracket_count}+1))\n\
    \        elif [[ $1 = \"[]$stack\"* ]]; then\n            if [[ ${bracket_count}\
    \ -eq 0 ]]; then\n                return 0\n            else\n               \
    \ bracket_count=0\n            fi\n        else\n            stack=\"$stack $1\"\
    \n        fi\n    done\n    return 1", "  \n  # The string passed to is_nested\
    \ can contain more than one bracket sequence. \n  # The function returns true\
    \ when there is at least one valid subsequence\n  # where at least one bracket\
    \ is nested.\n  local string=\"$1\"\n  \n  # The function returns true when the\
    \ string contains only one opening bracket sequence.\n  # Otherwise, return false.\n\
    \  local opening_brackets=\"\\[[\"\n  local closing_brackets=\"\\]\"\n\n  # If\
    \ the string contains no opening and closing brackets, return false\n  if ! grep\
    \ -E \"$opening_brackets.*\\$closing_brackets\" <<< \"$string\"; then\n    echo\
    \ \"false\"\n  else\n    echo \"true\"\n  fi", "  local string=\"$1\"\n  local\
    \ index=0\n  local depth=0\n  while [ $index -lt ${#string} ]; do\n    if [[ \"\
    ${string[$index]}\" = \"]\" ]]; then\n      depth=$(($depth-1))\n      index=$(($index+1))\n\
    \      continue\n    fi\n    if [[ \"${string[$index]}\" = \"[\" ]]; then\n  \
    \    depth=$(($depth+1))\n      index=$(($index+1))\n      continue\n    fi\n\
    \    index=$(($index+1))\n  done\n  [[ \"$depth\" -gt 0 ]] && return 1 || return\
    \ 0", "\tlocal string=$1\n\techo \"${string//[\\[\\]]}\"", "    local string=$1\n\
    \    # $2 and $3 are for recursion purposes only\n    # $2 is for when there is\
    \ no more closing bracket\n    # $3 is for when there is no more openning bracket\n\
    \    while [[ ${#string} -gt 0 ]] && [[ ${#string} -gt $3 ]]; do\n        local\
    \ opening_brackets=$(expr ${#string} / 2)\n        local closing_brackets=$(expr\
    \ ${#string} % 2)\n        local brackets=$opening_brackets\n        local bracket_counter=$opening_brackets\n\
    \        local closed_brackets=0\n        while [ $bracket_counter -le $opening_brackets\
    \ ]; do\n            # If the current character in the string is equal to a bracket\
    \ (ie. a opening bracket)\n            if [[ $string =~ ^.\\[${brackets}\\]$ ]];\
    \ then\n                # Increment the bracket counter\n                brackets++\n\
    \                # Increment the number of closed brackets\n                if\
    \ [ $brackets -gt $closing_brackets ]; then\n                    closed_brackets+=1\n\
    \                fi\n            fi\n        done\n        local final_brackets=$brackets-$closed_brackets\n\
    \        # Check if the number of brackets matches with $closing_brackets and\
    \ $final_brackets\n        if [ $final_brackets -ne $closing_brackets ]; then\n\
    \            echo \"false\"\n            return 0\n        fi\n        string=$(expr\
    \ ${#string} - $final_brackets)\n        # Decrease the number of opening brackets\n\
    \        if [ $brackets -ne $opening_brackets ]; then\n            opening_brackets=$brackets\n\
    \        fi\n    done\n    # Check if the number of opening brackets is equal\
    \ to the number of closing brackets\n    if [ $opening_brackets -ne $closing_brackets\
    \ ]; then\n        echo \"false\"\n        return 0\n    fi\n    echo \"true\"\
    \n    return 1", "    local bracket_count=0\n    local bracket_position=0\n  \
    \  for (( i=0; i < ${#1}; i++ )); do\n        if [[ \"${1:$i:1}\" == \"[\" ]];\
    \ then\n            bracket_count=$(( bracket_count+1 ))\n        elif [[ \"${1:$i:1}\"\
    \ == \"]\" ]]; then\n            bracket_count=$(( bracket_count-1 ))\n      \
    \  fi\n        if [[ $bracket_count == 0 ]]; then\n            bracket_position=$((\
    \ bracket_position+1 ))\n        fi\n    done\n    if [[ $bracket_count == 1 ]];\
    \ then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi", "  \
    \  local brackets=\"$1\"\n    local char\n    local inside_brackets=0\n    local\
    \ start_char\n    local count\n    local found\n    \n    for char in \"${brackets//[\\\
    [\\]]/}\"; do\n        if [[ $char == [\\] ]]; then\n            if ((inside_brackets\
    \ == 0)); then\n                inside_brackets+=1\n            else\n       \
    \         inside_brackets-=1\n            fi\n        fi\n        if ((inside_brackets\
    \ > 0)); then\n            found=\"false\"\n            count=0\n            start_char=${char}\n\
    \            inside_brackets=0\n            while ((inside_brackets > 0)); do\n\
    \                ((inside_brackets-=1))\n                if [[ \"${start_char}\"\
    \ == \"$char\" ]]; then\n                    count+=1\n                else\n\
    \                    found=\"true\"\n                    ((inside_brackets+=1))\
    \ # don't count the closing bracket\n                fi\n            done\n  \
    \          if ((count > 0)); then\n                return 0\n            else\n\
    \                return 1\n            fi\n        else\n            if [[ \"\
    $char\" == \"$char\" ]]; then\n                count=0\n                start_char=$char\n\
    \                while ((count < 2)); do\n                    if [[ \"$start_char\"\
    \ == \"$char\" ]]; then\n                        count+=1\n                  \
    \  else\n                        found=\"true\"\n                        ((count+=1))\
    \ # count the opening bracket\n                    fi\n                done\n\
    \                if ((count > 1)); then\n                    return 0\n      \
    \          else\n                    return 1\n                fi\n          \
    \  else\n                return 1\n            fi\n        fi\n    done", "  \
    \  string=$1\n    count=0\n    firstbracket_count=0\n    lastbracket_count=0\n\
    \    lastlastbracket_count=0\n    while [ $string != \"\" ]; do\n        if [\
    \ \"$string\" == \"[\" ];then\n            count=$(($count + 1))\n        elif\
    \ [ \"$string\" == \"]\" ];then\n            count=$(($count - 1))\n        elif\
    \ [ \"$string\" == \"[[]\" ];then\n            firstbracket_count=$(($firstbracket_count\
    \ + 1))\n        elif [ \"$string\" == \"[]]\" ];then\n            firstbracket_count=$(($firstbracket_count\
    \ - 1))\n        elif [ \"$string\" == \"[][]\" ];then\n            lastbracket_count=$(($lastbracket_count\
    \ + 1))\n        elif [ \"$string\" == \"[]\" ];then\n            lastbracket_count=$(($lastbracket_count\
    \ - 1))\n        elif [ \"$string\" == \"[[][]\" ];then\n            lastlastbracket_count=$(($lastlastbracket_count\
    \ + 1))\n        elif [ \"$string\" == \"[][]\" ];then\n            lastlastbracket_count=$(($lastlastbracket_count\
    \ - 1))\n        elif [ \"$string\" == \"[][][]\" ];then\n            lastlastlastbracket_count=$(($lastlastlastbracket_count\
    \ + 1))\n        fi\n        firstbracket_count=$(($firstbracket_count - 1))\n\
    \        lastbracket_count=$(($lastbracket_count - 1))\n        lastlastbracket_count=$(($lastlastbracket_count\
    \ - 1))\n        lastlastlastbracket_count=$(($lastlastlastbracket_count - 1))\n\
    \        firstbracket_count=$(($firstbracket_count + 1))\n        lastbracket_count=$(($lastbracket_count\
    \ + 1))\n        lastlastbracket_count=$(($lastlastbracket_count + 1))\n     \
    \   lastlastlastbracket_count=$(($lastlastlastbracket_count + 1))\n        string=$(($string\
    \ - 1))\n    done\n    if [ $firstbracket_count == $lastlastlastbracket_count\
    \ ];then\n        echo $false\n    else\n        echo $true\n    fi", "    local\
    \ i bracket_count=0\n    local str=${1:-[[]]}\n    local brackets=$(echo ${str}\
    \ | sed 's/[][]//g')\n    for ((i=0;i<${#brackets};i++));do\n        bracket_count=$(expr\
    \ ${bracket_count} + ${#brackets}-i)\n        if [[ ${brackets[i]} == ${brackets[$((i+1))]}\
    \ ]]; then\n            ((i++))\n        fi\n    done\n    echo ${bracket_count}",
  "    local string=$1\n    local count=0\n    local opening_count=0\n    local closings=0\n\
    \    local depth=0\n    local brackets=${#string}\n    while [ $count -lt $brackets\
    \ ]; do\n        if [ $((opening_count)) -gt 0 ]; then\n            local opening=${string:$count:1}\n\
    \            opening_count=$(expr expr opening_count + 1)\n            closings=$(expr\
    \ expr closings + 1)\n            if [ \"$opening\" = \"[\" ]; then\n        \
    \        opening_count=$(expr expr opening_count + 1)\n            fi\n      \
    \      \n            if [ $((closings)) -gt 0 ]; then\n                local closing=${string:$(($count+1)):1}\n\
    \                if [ \"$closing\" = \"]\" ]; then\n                    closings=$(expr\
    \ expr closings - 1)\n                    if [ \"$closing\" = \"[\" ]; then\n\
    \                        closings=$(expr expr closings - 1)\n                \
    \    fi\n                fi\n            fi\n        fi\n        if [ $((opening_count))\
    \ -eq 0 ]; then\n            depth=$(( depth + 1 ))\n        fi\n        count=$(($count\
    \ + 1))\n    done\n    if [ $((opening_count)) -gt 0 ]; then\n        if [[ ${#string}\
    \ -gt 0 ]]; then\n            echo \"true\"\n        else\n            echo \"\
    false\"\n        fi\n    else\n        if [[ ${#string} -gt 0 ]]; then\n     \
    \       echo \"false\"\n        else\n            echo \"true\"\n        fi\n\
    \    fi", "\tlocal brackets\n\tbrackets=\"${1//[\\[\\]]/}\"\n\tif [[ -n $brackets\
    \ ]]; then\n\t\tbrackets=\"$brackets\"\n\telse\n\t\tbrackets=\"[]\"\n\tfi\n\t\
    local bracketsCount=$(echo \"$brackets\" | wc -c)\n\tif [[ \"$bracketsCount\"\
    \ -ne 1 ]]; then\n\t\treturn 1\n\tfi\n\tlocal bracketIndex=0\n\tlocal bracketIndexCount=1\n\
    \twhile [[ \"$bracketIndex\" -lt \"$bracketsCount\" ]]; do\n\t\tlocal char=\"\
    $brackets$bracketIndex\"\n\t\tif [[ \"$bracketIndex\" -eq \"$bracketIndexCount\"\
    \ ]]; then\n\t\t\tbracketIndexCount=$(( bracketIndexCount + 1 ))\n\t\telse\n\t\
    \t\tbracketIndex=$(( bracketIndex + 1 ))\n\t\tfi\n\t\tif [[ \"$char\" != \"[\"\
    \ ]]; then\n\t\t\treturn 0\n\t\tfi\n\tdone\n\treturn 1", "    local x=\"$1\"\n\
    \    while [[ \"$x\" =~ ([^\\[\\]]*\\[\\[\\[[^\\[\\]]*\\]\\][^\\[\\]]*\\]) ]];\
    \ do\n        x=\"${BASH_REMATCH[1]}\"\n    done\n    [[ \"$x\" =~ ([^\\[\\]]*\\\
    [\\[\\[[^\\[\\]]*\\]\\]) ]] && echo \"true\" || echo \"false\"", "    local string=$1\n\
    \    local nested=0\n    local len=0\n    for char in $string; do\n        if\
    \ [ \"$char\" = \"[\" ] || [ \"$char\" = \"{\" ] || [ \"$char\" = \"(\" ]; then\n\
    \            if [ \"$nested\" -eq 0 ]; then\n                nested=1\n      \
    \          len=$((len+1))\n            else\n                if [ \"$char\" =\
    \ \"[\" ] || [ \"$char\" = \"{\" ] || [ \"$char\" = \"(\" ]; then\n          \
    \          len=$((len+1))\n                else\n                    len=$((len-1))\n\
    \                fi\n            fi\n        else\n            if [ \"$char\"\
    \ = \"]\" ] || [ \"$char\" = \"}\" ] || [ \"$char\" = \")\" ]; then\n        \
    \        len=$((len+1))\n                nested=0\n            else\n        \
    \        if [ \"$char\" = \"]\" ] || [ \"$char\" = \"}\" ] || [ \"$char\" = \"\
    )\" ]; then\n                    len=$((len-1))\n                    nested=0\n\
    \                else\n                    len=$((len-1))\n                fi\n\
    \            fi\n        fi\n    done\n    if [ \"$nested\" = 1 ]; then\n    \
    \    echo $((len>0))\n    else\n        echo $((len<1))\n    fi", "    local string=\"\
    ${1}\"\n    # return true if and only if there is a valid subsequence of brackets\
    \ \n    # where at least one bracket in the subsequence is nested.\n    local\
    \ brackets=\"[]\"\n    while [[ \"$string\" =~ (^|$)\"${brackets}\" ]];\n    do\n\
    \        brackets=\"$brackets${1}\"\n    done\n    echo \"$brackets\"\n    return\
    \ 0", "    local brackets=\"${1}\"\n    local stack=\"${brackets//[[]/}\"\n  \
    \  while [[ \"$stack\" != \"\" ]]; do\n        local next_brackets=\"${stack//[[]/}\"\
    \n        # No nested brackets\n        if [[ \"$next_brackets\" == \"\" ]]; then\n\
    \            echo \"false\"\n            return 0\n        fi\n        # Nested\
    \ brackets\n        if [[ \"$next_brackets\" != \"$brackets\" ]]; then\n     \
    \       echo \"true\"\n            return 0\n        fi\n        stack=\"${next_brackets//[[]/}\"\
    \n    done\n    echo \"false\"\n    return 0", "    local string=\"$1\"\n    if\
    \ [[ \"$string\" = *]* ]]]] ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]",
  "  local brackets='('\n  local open_brackets=0\n  local close_brackets=0\n  local\
    \ valid=false\n\n  for char in $1; do\n    if [[ $char == \"]\" ]] || [[ $char\
    \ == \"[\" ]]; then\n      open_brackets=$((open_brackets+1))\n      if [[ $open_brackets\
    \ == $close_brackets ]]; then\n        close_brackets=$((close_brackets+1))\n\
    \      else\n        valid=true\n      fi\n    else\n      if [[ $open_brackets\
    \ > $close_brackets ]]; then\n        valid=true\n      fi\n      brackets=$((brackets+1))\n\
    \    fi\n  done\n\n  echo \"$valid\"", "  local str=$1\n  local count=0\n  local\
    \ bracket_stack=()\n  local match=''\n  local bracket='['\n  local opening='['\n\
    \  local closing=']'\n  local nested_brackets=''\n  local in_quotes=''\n  local\
    \ quotes=''\n  local invalid=''\n  local bracket_count=0\n\n  str=`echo ${str}`\n\
    \n  while [ \"$str\" != \"\" ]; do\n    if [ $bracket_count -gt 0 ]; then\n  \
    \    bracket_stack=(\"${bracket_stack[@]}\")\n    fi\n    bracket_count=`echo\
    \ $bracket_stack | wc -l | grep -o \"^[0-9][0-9]*$\"`\n    if [ $bracket_count\
    \ -gt 1 ]; then\n      bracket_stack=()\n    fi\n    bracket_count=`echo $bracket_stack\
    \ | wc -l | grep -o \"^[0-9][0-9]*$\"`\n    if [ $bracket_count -gt 1 ]; then\n\
    \      invalid=true\n    fi\n    if [ \"$match\" != \"\" ]; then\n      if [ $bracket_count\
    \ -gt 1 ]; then\n        invalid=true\n      fi\n      if [ $invalid != true ];\
    \ then\n        invalid=true\n      fi\n    fi\n    if [ \"$invalid\" != true\
    \ ]; then\n      opening=`echo ${str} | awk -F'\"' '{print $1}'`\n      if [ \"\
    $opening\" != \"\" ]; then\n        opening=`echo ${opening} | awk -F'[' '{print\
    \ $1}'`\n        closing=`echo ${str} | awk -F'\"' '{print $2}'`\n        if [\
    \ \"$closing\" != \"\" ]; then\n          closing=`echo ${closing} | awk -F'['\
    \ '{print $1}'`\n          if [ \"$opening\" != \"$closing\" ]; then\n       \
    \     match=`echo $str | awk -F'\"' '{print $2}'`\n            if [ \"$match\"\
    \ != \"\" ]; then\n              if [ $bracket_count -gt 1 ]; then\n         \
    \       invalid=true\n              fi\n              if [ \"$invalid\" != true\
    \ ]; then\n                in_quotes=`echo $match | awk -F'[' '{print $2}'`\n\
    \                if [ \"$in_quotes\" != \"\" ]; then\n                  match=`echo\
    \ $match | awk -F'[' '{print $2}'`\n                  if [ \"$match\" != \"\"\
    \ ]; then\n                    if [ $bracket_count -gt 1 ]; then\n           \
    \           invalid=true\n                    fi\n                    if [ \"\
    $invalid\" != ", "    local s=$1\n    local i=2 # skip the opening [\n    while\
    \ [ $i -lt ${#s} ]; do\n        if [[ $${s:$i:1} == [$({\n            echo \"\
    $i\"\n        }:)] ]]; then\n            echo \"true\"\n            return 0\n\
    \        fi\n        ((i++))\n    done\n    echo \"false\"\n    return 1", " \
    \   if [ $# -ne 1 ]\n    then\n        echo \"Illegal number of parameters (${#1})\"\
    \n        exit 1\n    fi\n    local arr=\"$1\"\n    local bracket_cnt\n    local\
    \ open_bracket\n    local close_bracket\n    local open_bracket_count\n    local\
    \ close_bracket_count\n    # initialize variables\n    bracket_cnt=0\n    open_bracket=\"\
    [\"\n    close_bracket=\"]\"\n    open_bracket_count=0\n    close_bracket_count=0\n\
    \    # loop over the brackets\n    for bracket in \"${arr[@]}\"; do\n        #\
    \ increment the count of open brackets\n        open_bracket_count=$((open_bracket_count\
    \ + 1))\n        # increment the count of close brackets\n        close_bracket_count=$((close_bracket_count\
    \ + 1))\n        # if the bracket is open\n        if [[ $bracket = $open_bracket\
    \ ]]; then\n            # increment the bracket count\n            bracket_cnt=$((bracket_cnt\
    \ + 1))\n        else\n            # decrement the bracket count\n           \
    \ bracket_cnt=$((bracket_cnt - 1))\n            # if the bracket count is zero\n\
    \            if [ $bracket_cnt = 0 ]; then\n                # if the bracket is\
    \ the close bracket\n                if [[ $bracket = $close_bracket ]]; then\n\
    \                    # check if the open brackets are the same as the close brackets\n\
    \                    if [[ $open_bracket_count = $close_bracket_count ]]; then\n\
    \                        # return the string\n                        echo \"\
    true\"\n                    else\n                        echo \"false\"\n   \
    \                 fi\n                else\n                    echo \"false\"\
    \n                fi\n            fi\n        fi\n    done", "    # Initialize\
    \ variables\n    local open_brackets=0\n    local close_brackets=0\n    local\
    \ valid=\"\"\n    # Loop through characters in string\n    for (( c=0; c<${#1};\
    \ c++ )); do\n        # Increment open brackets by 1\n        (( open_brackets++\
    \ ))\n        # Loop through open brackets\n        for (( o=0; o<open_brackets;\
    \ o++ )); do\n            # Look for matching closing bracket\n            if\
    \ [[ ${1:c+1} == '[' ]]; then\n                # Increment close brackets by 1\n\
    \                (( close_brackets++ ))\n            fi\n        done\n      \
    \  # Print result\n        if (( close_brackets > 0 )); then\n            valid+=\"\
    true\"\n        else\n            valid+=\"false\"\n        fi\n    done\n   \
    \ echo $valid", "    # Check for the correct number of arguments\n    [ $# -lt\
    \ 1 ] && return 1\n    # Check for all opening brackets\n    [ ${1:0:1} != [ -z\
    \ \"${1:0:1}\" ] && return 1\n    # Check that each closing bracket is followed\
    \ by an opening bracket\n    [[ \"${1:1}\" != [[ ]]* ]] && return 1\n    # Look\
    \ for any nested braces\n    # e.g. [[[[]]]] or [[[[[[]]]]]]\n    local braces=\"\
    ${1:1}\"\n    local nested=0\n    local length=\"${#braces}\"\n    while [ ${nested}\
    \ -lt ${length} ]\n    do\n        [[ \"${braces:$nested}:${braces:$((nested+1))}\"\
    \ == \"[$((nested+1))]\" ]] &&\n            nested=$((nested+1))\n    done\n \
    \   [[ -n ${braces:$nested} ]] && return 0\n    return 1", "    local bracket_open=0\n\
    \    local bracket_close=0\n    local bracket_nesting=0\n    local bracket_found=0\n\
    \    local bracket_open_stack=( )\n\n    # Iterate through all characters\n  \
    \  for (( index = 0; index < ${#1}; index++ )); do\n        # Increment bracket\
    \ open\n        (( bracket_open += ${1:index} == \\[ )) && bracket_open_stack+=(\
    \ ${1:index} )\n        # Increment bracket close\n        (( bracket_close +=\
    \ ${1:index} == \\] )) && bracket_open_stack+=( ${1:index} )\n        # Increment\
    \ bracket nesting by 1\n        (( bracket_nesting += ${1:index} == \\[ )) &&\
    \ bracket_open_stack+=( ${1:index} )\n\n        # If opening bracket is found\
    \ and is nested within brackets, increment the bracket found\n        if (( bracket_open\
    \ > 0 && bracket_open_stack[${#bracket_open_stack[@]}-1] == \\[ )); then\n   \
    \         (( bracket_found++ )) && bracket_found\n        fi\n\n        # If closing\
    \ bracket is found and is nested within brackets, increment the bracket found\n\
    \        if (( bracket_close > 0 && bracket_open_stack[${#bracket_open_stack[@]}-1]\
    \ == \\] )); then\n            (( bracket_found++ )) && bracket_found\n      \
    \  fi\n\n        # If closing bracket is found and is nested within brackets,\
    \ increment the bracket found\n        if (( bracket_close > 0 && bracket_open_stack[${#bracket_open_stack[@]}-1]\
    \ == \\] )); then\n            (( bracket_found++ )) && bracket_found\n      \
    \  fi\n    done\n\n    return $(bracket_found)", "    local i\n    for ((i=0;\
    \ i<${#1}; i++)); do\n        if [[ \"${1:i:1}\" = \"[\" ]]; then\n          \
    \  local j\n            for ((j=i+1; j<${#1}; j++)); do\n                if [[\
    \ \"${1:j:1}\" = \"[\" ]]; then\n                    echo \"true\"\n         \
    \           return\n                fi\n            done\n        fi\n    done\n\
    \    echo \"false\"", "    local open\n    open=$(expr \"[\" $1)\n    if [[ \"\
    $open\" == \"$open\" ]]; then\n        local close\n        close=$(expr \"$open\"\
    \ +1 \"[\" $1)\n        [[ \"$close\" == \"\" ]] && return 1\n        close=$(expr\
    \ \"$close\" +1 \"]\" $1)\n        [[ \"$close\" == \"\" ]] && return 1\n    \
    \    return 0\n    fi\n    return 1", "\tlocal n=1\n\tlocal xs=$2\n\tlocal brackets=\"\
    ()\"\n\n\tfor ((i=0; i < ${#xs}; i++)); do\n\t\tlocal c=${xs:$i:1}\n\t\tif [[\
    \ \"$c\" == \"$brackets\" ]]; then\n\t\t\t(( n++ ))\n\t\tfi\n\tdone\n\n\tif [[\
    \ \"$n\" -gt 0 ]]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi", "    local\
    \ brackets=\"${1}\"\n\n    echo \"${brackets}\"| sed 's/\\[.*\\]/\\[/\\1\\]/'\
    \ | sed 's/\\(\\(.*\\)\\(\\(.*\\)\\(\\(.*\\)\\)\\(.*\\)\\)\\)/\\1\\3\\4\\5\\6/'\n\
    \    echo \"${brackets}\"| sed 's/\\(.*\\)\\(\\(.*\\)\\(\\(.*\\)\\)\\(.*\\)\\\
    )\\(.*\\)/\\1\\3\\4\\5\\6/'", "    local brackets=\"[\"\n    local open_brackets=\"\
    [\"\n    local closed_brackets=\"]\"\n    local result=0\n    local c=0\n    local\
    \ t\n    while [ $c -lt ${#1} ]; do\n        t=${1[$c]}\n        if [ $t == \"\
    [\" -o $t == \"{\" ]; then\n            if [ $open_brackets -eq 0 ]; then\n  \
    \              open_brackets=$t\n            elif [ $open_brackets -ne $t ]; then\n\
    \                echo \"invalid input: $1\"\n                result=1\n      \
    \          break\n            fi\n        elif [ $t == \"]\" -o $t == \"]\" ];\
    \ then\n            if [ $open_brackets -ne 0 ]; then\n                open_brackets=0\n\
    \            fi\n            if [ $closed_brackets -ne 0 ]; then\n           \
    \     closed_brackets=0\n            fi\n        elif [ $t == \"]\" -a $t == \"\
    ]\" ]; then\n            if [ $open_brackets -eq 0 ]; then\n                open_brackets=0\n\
    \            elif [ $open_brackets -ne $t ]; then\n                echo \"invalid\
    \ input: $1\"\n                result=1\n                break\n            fi\n\
    \        elif [ $t == \"}\" -a $t == \"}\" ]; then\n            if [ $closed_brackets\
    \ -ne 0 ]; then\n                closed_brackets=0\n            fi\n         \
    \   if [ $open_brackets -eq 0 ]; then\n                open_brackets=$t\n    \
    \        elif [ $open_brackets -ne $t ]; then\n                echo \"invalid\
    \ input: $1\"\n                result=1\n                break\n            fi\n\
    \        elif [ $t == \"}\" -a $t == \"]\" ]; then\n            if [ $closed_brackets\
    \ -ne 0 ]; then\n                closed_brackets=0\n            fi\n         \
    \   if [ $open_brackets -eq 0 ]; then\n                open_brackets=$t\n    \
    \        elif [ $open_brackets -ne $t ]; then\n                echo \"invalid\
    \ input: $1\"\n                result=1\n                break\n            fi\n\
    \        else\n            echo \"invalid input: $1\"\n            result=1\n\
    \            break\n        fi\n        c=$(( $c + 1 ))\n    done\n    if [ $open_brackets\
    \ -eq 0 ]; then\n        open_brackets=$closed_brackets\n    fi\n    if [ $closed_brackets\
    \ -eq 0 ]; then\n        closed_brackets=$open_brackets\n    fi\n    if [ $result\
    \ -eq 1 ]; then\n        echo \"invalid input: $1\"\n        result=1\n    fi\n\
    \    echo $result", "    local result=\"false\"\n    if [ \"$1\" = \"[]\" ]; then\n\
    \        result=\"true\"\n    elif [ $(expr $1 : '[[]') = \"false\" ]; then\n\
    \        result=\"false\"\n    elif [ $(expr $1 : '[[]') -eq \"true\" ]; then\n\
    \        result=\"true\"\n    fi\n    echo \"$result\"", "    local str=\"$1\"\
    \n    echo \"${str}\" | grep -P \"\\[\\[[\\[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]",
  "\techo \"$1\" | grep -o \"^\\(\\[[^][]*\\]*\\[[^][]*\\]*\\)*[^][][^][]*$\" ", "\t\
    local -i n i\n\techo \"$1\" | grep -E \"^\\[[^]]*\\]*\\[[^]]*\\]*\\[[^]]*\\]*\\\
    [[^]]*\\]*$\" > /dev/null 2>&1", "  local STR=\"${1}\"\n  local NESTED_STR=\"\
    ${STR}${STR}[[][]\"\n  local NESTED_STR=\"${NESTED_STR}${STR}[[]\"\n  local NESTED_STR=\"\
    ${NESTED_STR}${STR}[]\"\n  local NESTED_STR=\"${NESTED_STR}${STR}]\"\n  local\
    \ NESTED_STR=\"${NESTED_STR}${STR}\"\n\n  [[ \"$STR\" == \"$NESTED_STR\" ]] &&\
    \ return 0\n  return 1", "    local pattern=$1\n\n    # if the pattern begins\
    \ with an opening square-bracket then it must be ended by the closing one\n  \
    \  local -n string=\"${pattern}\"\n    [[ \"${string::${#pattern}-1} != ${#string}\
    \ ]] || return 1\n\n    # if the pattern consists of only closing square-brackets\
    \ then its an open subsequence\n    [[ ${#pattern} == ${#string} ]] || return\
    \ 0\n\n    # if the pattern consists of only opening square-brackets then its\
    \ an open subsequence\n    [[ ${#pattern} == ${#string} | grep \"^\\\\(\" ]]",
  "    # Remove all leading and trailing whitespace from string\n    local string=\"\
    $1\"\n    string=${string#* }\n    string=${string% * }\n\n    # Remove all leading\
    \ and trailing brackets\n    string=${string//[[]*/}\n    string=${string//[]]/}\n\
    \n    echo \"$string\"", "\tset +o pipefail\n\tlocal string=\"$1\" \n\tset -o\
    \ pipefail\n\tset +o noclobber\n\tif [[ $string =~ \\[([^\\]]*+)\\] ]] || [[ $string\
    \ =~ \\([^\\]]+\\)\\] ]] || [[ $string =~ \\[[^\\]]+\\]] ]] || [[ $string =~ \\\
    [([^\\]]*+)\\] ]]]] ]] || [[ $string =~ \\([^\\]]+\\)\\] ]]]] ]] || [[ $string\
    \ =~ \\[[^\\]]+\\]] ]]]] ]] || [[ $string =~ \\[([^\\]]*+)\\] ]]]]] ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]",
  "\techo \"$1\" | grep -q \"(\\[[^]]*\\])\"", "  local stack=\"()\"\n  local opening=\"\
    [[\"\n  local closing=\"]]\"\n  local close=\"]]\"\n  local open=\"[\"\n  local\
    \ close=\"]\"\n\n  if [ $# -lt 2 ] ; then\n    echo \"Usage: $0 <string>\"\n \
    \   echo \"Description: $0 returns true if and only if there is a valid subsequence\
    \ of brackets \\\n    where at least one bracket in the subsequence is nested\"\
    \n    return 1\n  fi\n\n  local pattern=\"$1\"\n  local str=\"${pattern//[/$close}${close}/${open}/${close}\"\
    \n\n  while [ $# -gt 1 ]\n  do\n    local c=\"$1\"\n    local n=\"$2\"\n\n   \
    \ if [ $c = \"${close}\" ]\n    then\n      local open=\"${stack##*$open}\"\n\
    \      local close=\"${stack%%$open*}\"\n\n      if [ \"$open\" != \"\" ] && [\
    \ \"$close\" != \"\" ]\n      then\n        local stack=\"${open}${stack}\"\n\
    \      else\n        echo \"$pattern is nested but not balanced\"\n        return\
    \ 1\n      fi\n      shift\n    elif [ $c = \"${open}\" ]\n    then\n      local\
    \ close=\"${stack%%$close*}\"\n      local open=\"${stack#$close}\"\n\n      if\
    \ [ \"$close\" != \"\" ] && [ \"$open\" != \"\" ]\n      then\n        local stack=\"\
    ${close}${open}${stack}\"\n      else\n        echo \"$pattern is nested but not\
    \ balanced\"\n        return 1\n      fi\n      shift\n    else\n      local open=\"\
    ${stack##*$open}\"\n      local close=\"${stack%%$open*}\"\n\n      if [ \"$open\"\
    \ != \"\" ] && [ \"$close\" != \"\" ]\n      then\n        local stack=\"${open}${close}${stack}\"\
    \n      else\n        echo \"$pattern is nested but not balanced\"\n        return\
    \ 1\n      fi\n      shift\n    fi\n\n  done\n  return 0", "  string=\"${1}\"\n\
    \  start=\"${string#*\\[}\"\n  end=\"${string*\\]}\"\n  echo \"$start\"\n  echo\
    \ \"$end\"\n  start=\"${start/\\[\\[\\]/}\"\n  start=\"${start/\\[\\]/}\"\n  start=\"\
    ${start/]]/}\"\n  echo \"$start\"\n  echo \"$end\"\n  start=\"${start/]]/}\"\n\
    \  start=\"${start/\\]\\]/}\"\n  start=\"${start/[^}]/}\"\n  echo \"$start\"\n\
    \  echo \"$end\"\n  start=\"${start/\\[/}\"\n  echo \"$start\"\n  echo \"$end\"\
    \n  start=\"${start/\\]/}\"\n  start=\"${start/[^}]/}\"\n  echo \"$start\"\n \
    \ echo \"$end\"\n  echo \"$start\"\n  echo \"$end\"\n  start=\"${start/[^}]/}\"\
    \n  start=\"${start/[]/}\"\n  start=\"${start/\\]/}\"\n  start=\"${start/[^}]/}\"\
    \n  echo \"$start\"\n  echo \"$end\"\n  start=\"${start/[]/}\"\n  start=\"${start/\\\
    ]/}\"\n  start=\"${start/[^}]/}\"\n  echo \"$start\"\n  echo \"$end\"\n  start=\"\
    ${start/[^}]/}\"\n  start=\"${start/[]/}\"\n  start=\"${start/[^}]/}\"\n  start=\"\
    ${start/[]/}\"\n  start=\"${start/\\]/}\"\n  start=\"${start/[^}]/}\"\n  echo\
    \ \"$start\"\n  echo \"$end\"\n  start=\"${start/[]/}\"\n  start=\"${start/[^}]/}\"\
    \n  start=\"${start/[]/}\"\n  start=\"${start/[^}]/}\"\n  start=\"${start/\\]/}\"\
    \n  start=\"${start/[^}]/}\"\n  echo \"$start\"\n  echo \"$end\"\n  start=\"${start/[]/}\"\
    \n  start=\"${start/[^}]/}\"\n  start=\"${start/[]/}\"\n  start=\"${start/\\]/}\"\
    \n  start=\"${start/[^}]/}\"\n  echo \"$start\"\n  echo \"$end\"\n  start=\"${start/[^}]/}\"\
    \n  start=\"${start/[]/}\"\n  start=\"${start/[^}]/}\"\n  start=\"${start/[]/}\"\
    \n  start=\"${start/\\]/}\"\n  start=\"${start/", "    local string=\"${1}\"\n\
    \    local i\n    local count\n\n    count=0\n\n    while [ $i -lt ${#string}\
    \ ]; do\n        if [[ ${string[$i]} == \"[\" ]]; then\n            ((count++))\n\
    \        elif [[ ${string[$i]} == \"]\" ]]; then\n            ((count--))\n  \
    \      fi\n        ((i++))\n    done\n\n    (( $count >= 0 ))", "\tlocal string=$1\n\
    \tlocal valid_substring=false\n\tlocal valid_count=${#string}\n\n\tlocal count=0\n\
    \tlocal current_char\n\tlocal current_index=0\n\n\twhile [ $count -lt $valid_count\
    \ ]; do\n\t\tcurrent_char=${string:$current_index:1}\n\n\t\tif [[ $current_char\
    \ == '[' ]]\n\t\tthen\n\t\t\t(( count += 1 ))\n\t\telse\n\t\t\tif [ $current_char\
    \ == ']' ]\n\t\t\tthen\n\t\t\t\t(( count -= 1 ))\n\t\t\telse\n\t\t\t\t(( count\
    \ += 1 ))\n\t\t\tfi\n\t\tfi\n\n\t\tcurrent_index=$(( $current_index + 1 ))\n\t\
    done\n\n\tif [ $count -eq 0 ]\n\tthen\n\t\tvalid_substring=true\n\tfi\n\n\techo\
    \ $valid_substring", "\tlocal str=\"$1\"\n\tlocal n=0\n\tlocal cnt=0\n\tlocal\
    \ open_brackets=''\n\tlocal close_brackets=''\n\n\t# Count how many opening brackets\
    \ are in the string\n\tfor char in $str; do\n\t\tif [[ \"$char\" = $(printf '\\\
    %c' \"$char\") ]]; then\n\t\t\topen_brackets=$((open_brackets + 1))\n\t\telse\n\
    \t\t\topen_brackets=$((open_brackets - 1))\n\t\tfi\n\tdone\n\n\t# Count how many\
    \ closing brackets are in the string\n\tfor char in $str; do\n\t\tif [[ \"$char\"\
    \ = $(printf '\\%c' \"$char\") ]]; then\n\t\t\tclose_brackets=$((close_brackets\
    \ + 1))\n\t\telse\n\t\t\tclose_brackets=$((close_brackets - 1))\n\t\tfi\n\tdone\n\
    \n\t# Check if we have an opening and closing bracket in both strings\n\tif [[\
    \ \"$open_brackets\" -eq \"0\" ]] ||\n\t\t[[ \"$close_brackets\" -eq \"0\" ]];\
    \ then\n\t\techo \"false\"\n\telse\n\t\t# Check if we have an opening bracket\
    \ in one string and a\n\t\t# closing bracket in the other.\n\t\tif [[ \"$open_brackets\"\
    \ -eq \"$close_brackets\" ]]; then\n\t\t\techo \"true\"\n\t\telse\n\t\t\techo\
    \ \"false\"\n\t\tfi\n\tfi", "\tlocal bs=\"${1//\\\"/}\"\n\tlocal bsp=\"$(echo\
    \ \"$bs\" | wc -m)\"\n\tif [ \"$bsp\" -lt 3 ]; then\n\t\techo \"false\"\n\telse\n\
    \t\techo \"true\"\n\tfi", "  local str=\"$1\"\n  local last=${str#?}\n  local\
    \ count=${#str}\n  for ((i=0; i < count; i++ )); do\n    local b=${str[$i]}\n\
    \    local l=${last}\n    [[ $b == $l ]] && [[ -n ${str[((i+1)..count)#$b]} ]]\
    \ && return 0\n    last=$b\n  done\n  return 1", "\tlocal str=\"$1\"\n\tlocal\
    \ brackets=0\n\tlocal closing_bracket=0\n\tlocal nested_brackets=0\n\tfor ((i=1;\
    \ i<${#str}; i++)); do\n\t\tlocal c=$(echo \"${str}\" | sed \"s/.$i//g\")\n\t\t\
    if [[ \"${c}\" == \"[\" ]]; then\n\t\t\tbrackets+=1\n\t\telse\n\t\t\tclosing_bracket=$((brackets-${c}))\n\
    \t\tfi\n\t\tif [[ \"${c}\" == \"]\" ]]; then\n\t\t\tbrackets-=1\n\t\telse\n\t\t\
    \tnested_brackets=$((nested_brackets+1))\n\t\t\tif [[ \"${closing_bracket}\" -gt\
    \ 0 ]]; then\n\t\t\t\tnested_brackets=$((nested_brackets-${closing_bracket}))\n\
    \t\t\tfi\n\t\tfi\n\tdone\n\tif [[ \"${nested_brackets}\" -gt 0 ]]; then\n\t\t\
    return false\n\telse\n\t\treturn true\n\tfi", "  local -r string=$1\n  local -r\
    \ stack=()\n  local -r stack_len=0\n  local -r nesting_count=0\n  local -r in_square_brackets=false\n\
    \  \n  while [ -n \"$string\" ]; do\n    stack+=(\"$string\")\n    stack_len=$((stack_len\
    \ + 1))\n    string=${string#*\\[]}\n    in_square_brackets=false\n    \n    for\
    \ (( i=0; i<stack_len; i++ )); do\n      local -r item=\"${stack[i]}\"\n     \
    \ if [[ \"${item}\" == \"[]\" ]] && ! in_square_brackets; then\n        in_square_brackets=true\n\
    \        continue\n      fi\n      \n      if [[ \"${item}\" == \"[]\" && \"${stack[i+1]}\"\
    \ == \"[\" ]]; then\n        in_square_brackets=false\n        continue\n    \
    \  fi\n      \n      if [[ \"${item}\" == \"[\" && \"${stack[i+1]}\" == \"[\"\
    \ ]]; then\n        nesting_count=$((nesting_count + 1))\n      fi\n      \n \
    \     if [[ \"${item}\" == \"]\" && \"${stack[i+1]}\" == \"[\" ]]; then\n    \
    \    nesting_count=$((nesting_count - 1))\n        if (( nesting_count == 0 ));\
    \ then\n          in_square_brackets=false\n          break\n        fi\n    \
    \  fi\n      \n      if [[ \"${item}\" == \"[\" && \"${stack[i+1]}\" == \"[\"\
    \ ]]; then\n        nesting_count=$((nesting_count + 1))\n      fi\n      \n \
    \     if [[ \"${item}\" == \"]\" && \"${stack[i+1]}\" == \"[\" ]]; then\n    \
    \    nesting_count=$((nesting_count - 1))\n        if (( nesting_count == 0 ));\
    \ then\n          in_square_brackets=false\n          break\n        fi\n    \
    \  fi\n      \n      if [[ \"${item}\" == \"]\" && \"${stack[i+1]}\" == \"[\"\
    \ ]]; then\n        in_square_brackets=false\n        break\n      fi\n      \n\
    \      if [[ \"${item}\" == \"[\" ]]; then\n        in_square_brackets=true\n\
    \      fi\n    done\n  done\n  \n  return $(( in_square_brackets ))", "  # We\
    \ need some extra variables to keep track of where we are in the string.\n  #\
    \ We need the length of the string as that is what we will use to keep track \n\
    \  # of where we are in the string\n  # We need two extra variables to keep track\
    \ of the number of opening and \n  # closing brackets we see in our string\n \
    \ local i j n open_brackets\n  local string=$1\n  # If our string starts with\
    \ an opening bracket and no closing brackets, it \n  # is an empty string\n  [[\
    \ \"${string}\" =~ ^\\[([^\\]]*)\\] ]] || return 1\n  # We need to count the number\
    \ of brackets to determine how many are open in our string\n  open_brackets=$(expr\
    \ $(expr ${#string} - 1) + 1)\n  # If our string starts with a closing bracket\
    \ and no opening brackets, it \n  # is an empty string\n  [[ \"${string}\" =~\
    \ ^([^\\]]*)\\] ]] || return 1\n  # We need to count the number of brackets to\
    \ determine how many are open in our string\n  open_brackets=$(expr ${open_brackets}\
    \ - 1)\n  # If we see an opening bracket, we increment our open bracket count\
    \ \n  (( open_brackets++ ))\n  # We will keep track of how many brackets we have\
    \ seen and stop incrementing \n  # the counter if we see an opening bracket\n\
    \  (( open_brackets=${open_brackets} > 0 ? open_brackets++ : open_brackets=1 ))\n\
    \  # If we see a closing bracket, we decrement our open bracket count\n  (( open_brackets--\
    \ ))\n  # We will keep track of how many brackets we have seen and stop decrementing\
    \ \n  # the counter if we see a closing bracket\n  (( open_brackets=${open_brackets}\
    \ < 0 ? open_brackets-- : open_brackets=0 ))\n  # If the number of brackets is\
    \ even, we have a nested set of brackets\n  (( open_brackets % 2 == 0 )) && return\
    \ 0\n  # If the number of brackets is odd, we do not have a nested set of brackets\n\
    \  (( open_brackets % 2 == 1 )) && return 1\n  # Otherwise, we are in an unnested\
    \ set of brackets\n  return 0", "\tlocal string=\"$1\" # string containing brackets\n\
    \t[[ \"$string\" =~ \\[([[:space:]]*)\\]([[:space:]]*)\\] ]] && echo \"true\"\
    \ || echo \"false\"", "  local brackets='('\n  local result=\"false\"\n  while\
    \ [[ \"$1\" != \"\" ]]\n  do\n    if [[ \"$1\" = *[$brackets* ]]\n    then\n \
    \     brackets=\"$brackets+\"\n      if [[ $brackets == *]$brackets* ]]\n    \
    \  then\n        result=\"true\"\n        break\n      fi\n    fi\n    shift\n\
    \  done\n  echo $result", "    # Check that there is at least one square bracket\
    \ in $1.\n    if [ ! \"$1\" ]; then\n        return false\n    fi\n    \n    local\
    \ bracketCount=1\n    local bracketsFound=1\n    local count=0\n    local lastBracket=1\n\
    \    local lastBracketIndex=1\n    local lastBracketDepth=1\n\n    # Count how\
    \ many brackets are in $1.\n    for (( i=1; i<= ${#1}; i++ )) do\n        if [[\
    \ \"${1:i}\" == [\\[*\\]] ]]; then\n            bracketCount=$((bracketCount+1))\n\
    \        fi\n    done\n\n    # Check if all brackets in $1 are nested.\n    while\
    \ [ $((bracketCount)) -gt 0 ]; do\n        bracketCount=0\n        \n        #\
    \ Find the next pair of brackets. \n        for (( i=lastBracketIndex; i<=${#1};\
    \ i++ )) do\n            if [[ \"${1:i}\" == [\\[*\\]] ]]; then\n            \
    \    bracketCount=$((bracketCount+1))\n            fi\n        done\n        \n\
    \        # Find the next set of brackets that enclose a single bracket in the\
    \ $1 string.\n        (( bracketsFound = bracketsFound + bracketCount ))\n   \
    \ done\n\n    # Check if $1 is nested with at least one nested bracket.\n    if\
    \ [ $((bracketsFound)) -eq 1 ]; then\n        return 1\n    else\n        return\
    \ 0\n    fi", "    # Check if there is at least one closing bracket\n    local\
    \ closing=\"$(echo \"$1\" | grep -E \"\\\\[\")\"\n    if [ -z \"$closing\" ];\
    \ then\n        return 0;\n    fi\n    # Count brackets\n    local brackets=$(echo\
    \ \"$1\" | grep -E \"\\\\[\")\n    local opening=$(echo \"$1\" | grep -E \"\\\\\
    [\")\n    while [ \"$opening\" != \"\" ]; do\n        closing=\"$(echo \"$closing\"\
    \ | grep -E \"\\\\[\")\"\n        opening=$(echo \"$opening\" | grep -E \"\\\\\
    [\")\n    done\n    # Return true if we found at least one nested bracket\n  \
    \  if [ \"$brackets\" != \"$closing\" ]; then\n        return 0;\n    fi\n   \
    \ return 1;", "    local string=\"$1\"\n    if [[ $string =~ (\\[[\\[\\[[^\\]\\\
    ]]\\]\\]\\]\\])$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
  "    local string=$1\n    local brackets=${string//]//}\n    local brackets=${brackets//[//}\n\
    \    local nested=$(bracket_count $brackets)\n    if [[ \"$nested\" -gt 1 ]];\
    \ then\n        echo true\n    else\n        echo false\n    fi", '    [[ "$1"
    = *[[ ]] ]]', "    local S=\"$1\"\n    local t=\"]\"\n    local e=\"]\"\n    local\
    \ f=\"]\"\n    local g=\"]\"\n    local i=\"]\"\n    local j=\"]\"\n    local\
    \ k=\"]\"\n    local l=\"]\"\n    local m=\"]\"\n    local n=\"]\"\n    local\
    \ o=\"]\"\n    local p=\"]\"\n    local q=\"]\"\n    local r=\"]\"\n    local\
    \ s=\"]\"\n    local t=\"]\"\n    local u=\"]\"\n    local v=\"]\"\n    local\
    \ w=\"]\"\n    local x=\"]\"\n    local y=\"]\"\n    local z=\"]\"\n    local\
    \ A=\"]\"\n    local B=\"]\"\n    local C=\"]\"\n    local D=\"]\"\n    local\
    \ E=\"]\"\n    local F=\"]\"\n    local G=\"]\"\n    local H=\"]\"\n    local\
    \ I=\"]\"\n    local J=\"]\"\n    local K=\"]\"\n    local L=\"]\"\n    local\
    \ M=\"]\"\n    local N=\"]\"\n    local O=\"]\"\n    local P=\"]\"\n    local\
    \ Q=\"]\"\n    local R=\"]\"\n    local S=\"]\"\n    local T=\"]\"\n    local\
    \ U=\"]\"\n    local V=\"]\"\n    local W=\"]\"\n    local X=\"]\"\n    local\
    \ Y=\"]\"\n    local Z=\"]\"\n    local a=\"]\"\n    local b=\"]\"\n    local\
    \ c=\"]\"\n    local d=\"]\"\n    local e=\"]\"\n    local f=\"]\"\n    local\
    \ g=\"]\"\n    local h=\"]\"\n    local i=\"]\"\n    local j=\"]\"\n    local\
    \ k=\"]\"\n    local l=\"]\"\n    local m=\"]\"\n    local n=\"]\"\n    local\
    \ o=\"]\"\n    local p=\"]\"\n    local q=\"]\"\n    local r=\"]\"\n    local\
    \ s=\"]\"\n    local t=\"]\"\n    local u=\"]\"\n    local v=\"]\"\n    local\
    \ w=\"]\"\n    local x=\"]\"\n    local y=\"]\"\n    local z=\"]\"\n    local\
    \ A=\"]\"\n    local B=\"]\"\n    local C=\"]\"\n    local D=\"]\"\n    local\
    \ E=\"]\"\n    local F=\"]\"\n    local G=\"]\"\n    local H=\"]\"\n    local\
    \ I=\"]\"\n    local J=\"]\"\n    local K=\"]\"\n", "    local string=$1\n   \
    \ local opening_count=0\n    local closed_count=0\n    local opening_brackets=($string|grep\
    \ -Eq '^\\[.+\\]')\n    local closed_brackets=($string|grep -Eq '^\\[[.+\\]]')\n\
    \    local is_nested=\"false\"\n\n    for bracket in ${opening_brackets[*]}; do\n\
    \        opening_count=$((opening_count+1))\n        for closed_bracket in ${closed_brackets[*]};\
    \ do\n            closed_count=$((closed_count+1))\n            if [[ \"${opening_brackets[$opening_count]}\"\
    \ == \"${closed_brackets[$closed_count]}\" ]]; then\n                is_nested=\"\
    true\"\n                break\n            fi\n        done\n    done\n    \n\
    \    return $is_nested", "    local -r string=\"$1\"\n    local -r nest_level=$2\n\
    \n    local open_brackets=\"[{\"\n    local close_brackets=\"}]\"\n    local open_par=\"\
    (\"\n    local close_par=\")\" \n    local open_par2=\"((\"\n    local close_par2=\"\
    ))\"\n    local open_brackets2=\"{{{\"\n    local close_brackets2=\"}}\"\n   \
    \ local open_brackets3=\"{{{{{\"\n    local close_brackets3=\"}}}}\"\n\n    #\
    \ Check to see if there's only one character\n    if [[ ${#string} -gt 1 ]]; then\n\
    \        # Check to see if there are brackets within the string\n        if [[\
    \ \"${string}\" =~ \"${open_brackets}${open_brackets}\"*${close_brackets}\" ]];\
    \ then\n            echo \"${nest_level}: ${string}\"\n        elif [[ \"${string}\"\
    \ =~ \"${open_par}${open_brackets2}${open_brackets2}\"*${close_par}${close_brackets2}\"\
    \ ]]; then\n            echo \"${nest_level}: ${string}\"\n        elif [[ \"\
    ${string}\" =~ \"${open_par2}${open_brackets3}${open_brackets3}\"*${close_par2}${close_brackets3}\"\
    \ ]]; then\n            echo \"${nest_level}: ${string}\"\n        fi\n    fi",
  "    local -r string=$1\n    local -r nested_braces=${string#*[}\n    [[ \"$nested_braces\"\
    \ =~ ^[^[]*[[][^]]*$ ]]", "    local string=$1\n    local brackets=$2\n\n    local\
    \ count=0\n    local string_brackets_brackets=0\n    local string_brackets_nest_brackets=0\n\
    \    local string_brackets_nest=0\n\n    # Count brackets\n    local bracket_count=$(echo\
    \ $string | grep -o \"[\\[\\]\\{\\}]\" | wc -l)\n\n    # Count brackets in brackets\n\
    \    for i in $(seq 0 $((${#string} - 1)));\n    do\n        local bracket_count_brackets=$(echo\
    \ $string | grep -o \"[\\[\\]\\{\\}]\" | wc -l)\n        local bracket_count_nest_brackets=$(echo\
    \ $string | grep -o \"[\\[\\]\\{\\}]\" | grep -o \"[[]]\" | wc -l)\n\n       \
    \ # If brackets in brackets, brackets in brackets nested\n        if [ $((string_brackets_brackets\
    \ % 2)) -eq 0 ]; then\n            if [ $((string_brackets_brackets + bracket_count_brackets\
    \ - bracket_count_nest_brackets)) -eq 0 ]; then\n                if [ $((string_brackets_brackets\
    \ + bracket_count_brackets - 1)) -eq 0 ]; then\n                    if [ $((string_brackets_brackets\
    \ + 1)) -eq 0 ]; then\n                        if [ $((string_brackets + 1)) -eq\
    \ 0 ]; then\n                            count=$((count + 1))\n              \
    \          fi\n                    fi\n                fi\n            fi\n  \
    \      fi\n\n        # If brackets in nest, brackets in nest nested\n        if\
    \ [ $((string_brackets_nest_brackets % 2)) -eq 0 ]; then\n            if [ $((string_brackets_nest_brackets\
    \ + bracket_count_nest_brackets - bracket_count_brackets)) -eq 0 ]; then\n   \
    \             if [ $((string_brackets_nest_brackets + bracket_count_nest_brackets\
    \ - 1)) -eq 0 ]; then\n                    if [ $((string_brackets_nest_brackets\
    \ + 1)) -eq 0 ]; then\n                        count=$((count + 1))\n        \
    \            fi\n                fi\n            fi\n        fi\n\n        # If\
    \ brackets in nest, brackets in nest not nested\n        if [ $((string_brackets_nest\
    \ % 2)) -eq 0 ]; then\n            if [ $((string_brackets_nest + bracket_count_nest\
    \ - bracket_count_brackets)) -eq 0 ]; then\n                count=$((count + 1))\n\
    \            fi\n        fi\n\n        local "]
stop_tokens:
- "\n}"
