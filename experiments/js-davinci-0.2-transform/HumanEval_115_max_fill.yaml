name: HumanEval_115_max_fill
language: js
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid, capacity){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0,\
  \ 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n\
  \  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"
completions: ["    // your code here\n}\n", "    let max_fill = 0;\n    let wells\
    \ = grid.length;\n    let well_length = grid[0].length;\n    let bucket = capacity;\n\
    \    let bucket_count = 0;\n    for(let i = 0; i < wells; i++){\n        for(let\
    \ j = 0; j < well_length; j++){\n            if(grid[i][j] === 1){\n         \
    \       bucket -= 1;\n                if(bucket === 0){\n                    bucket\
    \ = capacity;\n                    bucket_count += 1;\n                }\n   \
    \         }\n        }\n    }\n    return bucket_count;\n}\n", "    // your code\
    \ here\n}\n", "    // your code here\n}\n", "    let count = 0;\n    let wells\
    \ = [];\n    for(let i = 0; i < grid.length; i++){\n        wells.push(grid[i].reduce((acc,\
    \ curr) => acc + curr));\n    }\n    while(wells.length > 0){\n        let max\
    \ = Math.max(...wells);\n        let index = wells.indexOf(max);\n        if(max\
    \ > capacity){\n            wells[index] -= capacity;\n        } else {\n    \
    \        wells.splice(index, 1);\n        }\n        count++;\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                count += capacity;\n            }\n        }\n    }\n \
    \   return count;\n}\n", "    let count = 0;\n    let max = 0;\n    for(let i\
    \ = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                max = Math.max(max, j);\n \
    \           }\n        }\n    }\n    for(let i = 0; i < grid.length; i++){\n \
    \       for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                count += capacity;\n            }\n            if(j ==\
    \ max){\n                count -= capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\n", "    let count = 0;\n    let row = grid.length;\n  \
    \  let col = grid[0].length;\n    let max = 0;\n    for(let i = 0; i < row; i++){\n\
    \        for(let j = 0; j < col; j++){\n            if(grid[i][j] === 1){\n  \
    \              count++;\n            }\n        }\n        if(count > max){\n\
    \            max = count;\n        }\n        count = 0;\n    }\n    return max\
    \ * capacity;\n}\n", "    // your code here\n}\n", "    let count = 0;\n    let\
    \ max = 0;\n    let max_index = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        let sum = 0;\n        for(let j = 0; j < grid[i].length; j++){\n    \
    \        sum += grid[i][j];\n        }\n        if(sum > max){\n            max\
    \ = sum;\n            max_index = i;\n        }\n    }\n    let bucket = capacity;\n\
    \    for(let i = 0; i < grid[max_index].length; i++){\n        if(grid[max_index][i]\
    \ === 1){\n            bucket--;\n            if(bucket === 0){\n            \
    \    count++;\n                bucket = capacity;\n            }\n        }\n\
    \    }\n    return count;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                count++;\n                grid[i][j] = 0;\n       \
    \         if(i > 0 && grid[i-1][j] === 1){\n                    grid[i-1][j] =\
    \ 0;\n                }\n                if(j > 0 && grid[i][j-1] === 1){\n  \
    \                  grid[i][j-1] = 0;\n                }\n                if(i\
    \ < grid.length - 1 && grid[i+1][j] === 1){\n                    grid[i+1][j]\
    \ = 0;\n                }\n                if(j < grid[i].length - 1 && grid[i][j+1]\
    \ === 1){\n                    grid[i][j+1] = 0;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                count += capacity;\n     \
    \       }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n  \
    \  for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                grid[i][j] = 0;\n\
    \                count++;\n                let bucket = capacity;\n          \
    \      while(bucket > 0){\n                    if(i - 1 >= 0 && grid[i - 1][j]\
    \ === 1){\n                        grid[i - 1][j] = 0;\n                     \
    \   bucket--;\n                    }\n                    if(i + 1 < grid.length\
    \ && grid[i + 1][j] === 1){\n                        grid[i + 1][j] = 0;\n   \
    \                     bucket--;\n                    }\n                    if(j\
    \ - 1 >= 0 && grid[i][j - 1] === 1){\n                        grid[i][j - 1] =\
    \ 0;\n                        bucket--;\n                    }\n             \
    \       if(j + 1 < grid[i].length && grid[i][j + 1] === 1){\n                \
    \        grid[i][j + 1] = 0;\n                        bucket--;\n            \
    \        }\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "    let result = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let bucket = capacity;\n    for(let i = 0; i < row; i++){\n        for(let\
    \ j = 0; j < col; j++){\n            if(grid[i][j] === 1){\n                if(bucket\
    \ > 0){\n                    bucket--;\n                    grid[i][j] = 0;\n\
    \                }else{\n                    bucket = capacity;\n            \
    \        result++;\n                    j--;\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\n", "    let count = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                grid[i][j] = 0;\n        \
    \        count++;\n                for(let k = i; k < grid.length; k++){\n   \
    \                 if(grid[k][j] === 1){\n                        grid[k][j] =\
    \ 0;\n                        count++;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return count;\n}\n", "  let count =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count++;\n\
    \        if (i > 0) {\n          grid[i - 1][j] = 0;\n        }\n        if (i\
    \ < grid.length - 1) {\n          grid[i + 1][j] = 0;\n        }\n        if (j\
    \ > 0) {\n          grid[i][j - 1] = 0;\n        }\n        if (j < grid[i].length\
    \ - 1) {\n          grid[i][j + 1] = 0;\n        }\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "    let count = 0;\n    let wells = grid.length;\n    let length\
    \ = grid[0].length;\n    let buckets = [];\n    for(let i = 0; i < wells; i++){\n\
    \        buckets.push(0);\n    }\n    for(let i = 0; i < length; i++){\n     \
    \   for(let j = 0; j < wells; j++){\n            if(grid[j][i] === 1){\n     \
    \           buckets[j]++;\n                if(buckets[j] > capacity){\n      \
    \              count++;\n                    buckets[j] = 0;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}\n", "    let count\
    \ = 0;\n    let max = 0;\n    let max_index = 0;\n    let max_row = 0;\n    let\
    \ max_col = 0;\n    let max_row_index = 0;\n    let max_col_index = 0;\n    let\
    \ max_row_count = 0;\n    let max_col_count = 0;\n    let max_row_index_count\
    \ = 0;\n    let max_col_index_count = 0;\n    let max_row_index_count_2 = 0;\n\
    \    let max_col_index_count_2 = 0;\n    let max_row_index_count_3 = 0;\n    let\
    \ max_col_index_count_3 = 0;\n    let max_row_index_count_4 = 0;\n    let max_col_index_count_4\
    \ = 0;\n    let max_row_index_count_5 = 0;\n    let max_col_index_count_5 = 0;\n\
    \    let max_row_index_count_6 = 0;\n    let max_col_index_count_6 = 0;\n    let\
    \ max_row_index_count_7 = 0;\n    let max_col_index_count_7 = 0;\n    let max_row_index_count_8\
    \ = 0;\n    let max_col_index_count_8 = 0;\n    let max_row_index_count_9 = 0;\n\
    \    let max_col_index_count_9 = 0;\n    let max_row_index_count_10 = 0;\n   \
    \ let max_col_index_count_10 = 0;\n    let max_row_index_count_11 = 0;\n    let\
    \ max_col_index_count_11 = 0;\n    let max_row_index_count_12 = 0;\n    let max_col_index_count_12\
    \ = 0;\n    let max_row_index_count_13 = 0;\n    let max_col_index_count_13 =\
    \ 0;\n    let max_row_index_count_14 = 0;\n    let max_col_index_count_14 = 0;\n\
    \    let max_row_index_count_", "    let count = 0;\n    let row = grid.length;\n\
    \    let col = grid[0].length;\n    let bucket = capacity;\n    for(let i = 0;\
    \ i < row; i++){\n        for(let j = 0; j < col; j++){\n            if(grid[i][j]\
    \ === 1){\n                if(bucket > 0){\n                    bucket--;\n  \
    \                  grid[i][j] = 0;\n                }else{\n                 \
    \   bucket = capacity;\n                    count++;\n                    bucket--;\n\
    \                    grid[i][j] = 0;\n                }\n            }\n     \
    \   }\n    }\n    return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
