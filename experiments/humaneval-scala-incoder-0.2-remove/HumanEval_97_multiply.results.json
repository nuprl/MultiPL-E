{
  "language": "scala",
  "name": "HumanEval_97_multiply",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map { case (digit1, digit2) => digit1 * digit2 }\n        val unitDigits = unitDigits.toList\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptffkjqnl.scala:40:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(_.toString.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDig",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits = b % 10\n        unitDigits * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf4eeqhv1.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_5).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_6).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_7).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_8).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_9).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_10).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        unitDigits_10.foldLeft(0)(_ * _)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0sj89oqx.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp0sj89oqx.scala:12:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((digit2 : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0sj89oqx.scala:14:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0sj89oqx.scala:15:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue * is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix th",
      "stdout": "",
      "timestamp": 1660009553
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toArray.map(_.toInt)\n        val unitDigits_1 = b.toString.toArray.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val product = unitDigits_2.sum\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpals66k1n.scala:18)\n\tat Problem.main(tmpals66k1n.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009552
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.toInt\n        val unitDigits = unitDigits.toInt\n        val unitDigits2 = unitDigits2.to\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeufujqr0.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeufujqr0.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeufujqr0.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeufujqr0.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeufujqr0.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        val unitDigits = a.toString.split(\"\\\\D\").map(_.toInt)\n        val unitDigits2 = b.toString.split(\"\\\\D\").map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.map(x => x.toString.toLong)\n        unitDigits.reduce((x, y) => x * y)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaspjszbb.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaspjszbb.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => x.toString.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009549
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits2 = b.toString.toInt\n        val product = unitDigits * unitDigits2\n        return product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpp2yfiz4m.scala:15)\n\tat Problem.main(tmpp2yfiz4m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val product = unitDigits.zip(unitDigits_1).map { case (a, b) => a * b}\n        product.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwujqp9p5.scala:15)\n\tat Problem.main(tmpwujqp9p5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_h2bfrqs.scala:17)\n\tat Problem.main(tmp_h2bfrqs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigits = unitDigits * unitDigits2\n        val remainder = remainder * remainder2\n        val unitDigits = unitDigits + remainder\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp26brm04s.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp26brm04s.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp26brm04s.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits + remainder\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val remainder = a % Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val remainder2 = b % Math.pow(10, b.toInt)\n        unitDigits * unitDigits * unitDigits + remainder * remainder * remainder2 + unitDigits2 * unitDigits2 * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9q3514fm.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        unitDigits * unitDigits * unitDigits + remainder * remainder * remainder2 + unitDigits2 * unitDigits2 * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigits = unitDigits * unitDigits2\n        val remainder = remainder * remainder2\n        unitDigits + remainder\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpode7mp7g.scala:17)\n\tat Problem.main(tmpode7mp7g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        val product = a.toString.toLong * b.toString.toLong\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd_sbdw6d.scala:14)\n\tat Problem.main(tmpd_sbdw6d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toArray.map(_.toInt)\n        val unitDigits2 = b.toString.toArray.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.map(x => if (x == 0) 1 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else x)\n        val unitDigits = unitDigits.map(x => if (x == 0) 0 else \n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmph9vf1aac.scala:38:63 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph9vf1aac.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph9vf1aac.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph9vf1aac.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m0\u001b[0m) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m x)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the sam",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits + remainder\n        val unit\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7d8myhec.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7d8myhec.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7d8myhec.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits + remainder\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7d8myhec.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7d8myhec.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits + remainder\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7d8myhec.scala:16:12 ----------------",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val remainder = a % Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val remainder2 = b % Math.pow(10, b.toInt)\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyq02ilyx.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        product + product2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigits = unitDigits * unitDigits2\n        val remainder = remainder * remainder2\n        unitDigits + remainder\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product + remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpleq9dnkk.scala:17)\n\tat Problem.main(tmpleq9dnkk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        unitDigits.reduce((x, y) => x * y)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp817po0fb.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009554
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigit3 = remainder2 / 10\n        val remainder3 = remainder2 % 10\n        val unitDigit4 = remainder3 / 10\n        val remainder4 = remainder3 % 10\n        val unitDigit5 = remainder4 / 10\n        val remainder5 = remainder4 % 10\n        val unitDigit6 = remainder5 / 10\n        val remainder6 = remainder5 % 10\n        val unitDigit7 = remainder6 / 10\n        val remainder7 = remainder6 % 10\n        val unitDigit8 = remainder7 / 10\n        val remainder8 = remainder7 % 10\n        val unitDigit9 = remainder8 / 10\n        val remainder9 = remainder8 % 10\n        val unitDigit10 = remainder9 / 10\n        val remainder10 = remainder9 % 10\n        val unitDigit11 = remainder10 / 10\n        val remainder11 = remainder10 % 10\n        val unitDigit12 = remainder11 / 10\n        val remainder12 = remainder11 % 10\n        val unitDigit13 = remainder12 / 10\n        val remainder13 = remainder12 % 10\n        val unitDigit14 = remainder13 / 10\n        val remainder14 = remainder13 % 10\n        val unitDigit15 = remainder14 / 10\n        val remainder15 = remainder14 % 10\n        val unitDigit16 = remainder15 / 10\n        val remainder16 = remainder15 % 10\n        val unitDigit17 = remainder16 / 10\n        val remainder17 = remainder16 % 10\n        val unitDigit18 = remainder17 / 10\n        val remainder18 = remainder17 % 10\n        val unitDigit19 = remainder18 / 10\n        val remainder19 = remainder18 % 10\n        val unitDigit20 = remainder19 / 10\n        val remainder20 = remainder19 % 10\n        val unitDigit21 = remainder20 / 10\n        val remainder21 = remainder20 % 10\n        val unitDigit22 = remainder21 / 10\n        val remainder22 = remainder21 % 10\n        val unitDigit23 = remainder22 / 10\n        val remainder23 = \n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi6vniv8a.scala:54:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder23\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi6vniv8a.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009560
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_2).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_3).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        unitDigits_4.foldLeft(0) {\n            case (acc, digit) => acc * digit\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsk1n3y9f.scala:25)\n\tat Problem.main(tmpsk1n3y9f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits + unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits * b\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpna_6to5_.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits + unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpna_6to5_.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009556
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        unitDigits.reduce((x, y) => x * y)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp817po0fb.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009554
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplfhsl1n0.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplfhsl1n0.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplfhsl1n0.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplfhsl1n0.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplfhsl1n0.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNo",
      "stdout": "",
      "timestamp": 1660009560
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_h2bfrqs.scala:17)\n\tat Problem.main(tmp_h2bfrqs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits2 = b.toString.toInt\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * 10\n        val unitDigits = unitDigits / 10\n        val unitDigit\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbqxwsdtn.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbqxwsdtn.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbqxwsdtn.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbqxwsdtn.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbqxwsdtn.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbqxwsdtn.scala:15:12 -----------------",
      "stdout": "",
      "timestamp": 1660009560
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val product = unitDigits * unitDigits\n        return product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyj6bs5_5.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b.toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map { case (digit1, digit2) => digit1 * digit2 }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map { case (digit1, digit2) => digit1 * digit2 }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map { case (digit1, digit2) => digit1 * digit2 }\n        unitDigits_4.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu_np3_od.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpu_np3_od.scala:11:96 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((digit2 : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu_np3_od.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu_np3_od.scala:12:96 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigit",
      "stdout": "",
      "timestamp": 1660009562
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product + remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpleq9dnkk.scala:17)\n\tat Problem.main(tmpleq9dnkk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        \n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqgkr4f79.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqgkr4f79.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqgkr4f79.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqgkr4f79.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqgkr4f79.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        val product = a.toString.toLong * b.toString.toLong\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd_sbdw6d.scala:14)\n\tat Problem.main(tmpd_sbdw6d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits2 = b.toString.toInt\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits / 10\n        val unitDigits = unitDigits * unit\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp22zowh8z.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp22zowh8z.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp22zowh8z.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp22zowh8z.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp22zowh8z.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map { case (digit1, digit2) => digit1 * digit2 }\n        val unitDigits = unitDigits.toList\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(_.toString.toInt)\n        val unitDigits = unitDigits.map(\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptffkjqnl.scala:40:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(_.toString.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptffkjqnl.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDig",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map { case (digit1, digit2) => digit1 * digit2 }\n        val product = unitDigits_2.foldLeft(1L) { (product, digit) => product * digit }\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgqjci40f.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpgqjci40f.scala:11:96 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2 }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((digit2 : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpgqjci40f.scala:12:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mproduct\u001b[0m = unitDigits_2.foldLeft(\u001b[31m1L\u001b[0m) { (\u001b[36mproduct\u001b[0m, \u001b[36mdigit\u001b[0m) => product * digit }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mall match arguments ((digit : Nothing))\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660009558
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits_2 = b.toString.toInt\n        val unitDigits_3 = unitDigits * unitDigits_2\n        val unitDigits_4 = unitDigits * unitDigits_3\n        val unitDigits_5 = unitDigits * unitDigits_4\n        val unitDigits_6 = unitDigits * unitDigits_5\n        val unitDigits_7 = unitDigits * unitDigits_6\n        val unitDigits_8 = unitDigits * unitDigits_7\n        val unitDigits_9 = unitDigits * unitDigits_8\n        val unitDigits_10 = unitDigits * unitDigits_9\n        val unitDigits_11 = unitDigits * unitDigits_10\n        val unitDigits_12 = unitDigits * unitDigits_11\n        val unitDigits_13 = unitDigits * unitDigits_12\n        val unitDigits_14 = unitDigits * unitDigits_13\n        val unitDigits_15 = unitDigits * unitDigits_14\n        val unitDigits_16 = unitDigits * unitDigits_15\n        val unitDigits_17 = unitDigits * unitDigits_16\n        val unitDigits_18 = unitDigits * unitDigits_17\n        val unitDigits_19 = unitDigits * unitDigits_18\n        val unitDigits_20 = unitDigits * unitDigits_19\n        val unitDigits_21 = unitDigits * unitDigits_20\n        val unitDigits_22 = unitDigits * unitDigits_21\n        val unitDigits_23 = unitDigits * unitDigits_22\n        val unitDigits_24 = unitDigits * unitDigits_23\n        val unitDigits_25 = unitDigits * unitDigits_24\n        val unitDigits_26 = unitDigits * unitDigits_25\n        val unitDigits_27 = unitDigits * unitDigits_26\n        val unitDigits_28 = unitDigits * unitDigits_27\n        val unitDigits_29 = unitDigits * unitDigits_28\n        val unitDigits_30 = unitDigits * unitDigits_29\n        val unitDigits_31 = unitDigits * unitDigits_30\n        val unitDigits_32 = unitDigits * unitDigits_31\n        val unitDigits_33 = unitDigits * unitDigits_32\n        val unit\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp56rsk43i.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp56rsk43i.scala:43:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu6ete1id.scala:15)\n\tat Problem.main(tmpu6ete1id.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val remainder = a % Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val remainder2 = b % Math.pow(10, b.toInt)\n        unitDigits * unitDigits2 * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfag6ycyv.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        unitDigits * unitDigits2 * remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_h2bfrqs.scala:17)\n\tat Problem.main(tmp_h2bfrqs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        val unitDigits = unitDigits * 10\n        unitDigits + product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpopkb54xf.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009558
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        var sum = 0\n        var product = 1\n        while(a > 0){\n            sum += a%10\n            a /= 10\n        }\n        while(b > 0){\n            product *= b%10\n            b /= 10\n        }\n        sum * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp04czsgcj.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            sum += a%\u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp04czsgcj.scala:14:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            a /= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean a.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp04czsgcj.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            product *= b%\u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp04czsgcj.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            b /= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean b.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009563
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu6ete1id.scala:15)\n\tat Problem.main(tmpu6ete1id.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_11 = unitDigits_10.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_12 = unitDigits_11.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_13 = unitDigits_12.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_14 = unitDigits_13.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_15 = unitDigits_14.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_16 = unitDigits_15.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgc_p3iyd.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgc_p3iyd.scala:54:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: digit\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgc_p3iyd.scala:67:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpgc_p3iyd.scala:56:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m56 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009563
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map { case (a, b) => a * b}\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_2).map { case (a, b) => a * b}\n        unitDigits_3.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz7e42ygs.scala:16)\n\tat Problem.main(tmpz7e42ygs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009565
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map(x => x._1 * x._2)\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map(x => x._1 * x._2)\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map(x => x._1 * x._2)\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_5).map(x => x._1 * x._2)\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_6).map(x => x._1 * x._2)\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_7).map(x => x._1 * x._2)\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_8).map(x => x._1 * x._2)\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_9).map(x => x._1 * x._2)\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_10).map(x => x._1 * x._2)\n        val unitDigits_11 = unitDigits_10.zip(unitDigits_11).map(x => x._1 * x._2)\n        val unitDigits_12 = unitDigits_11.zip(unitDigits_12).map(x => x._1 * x._2)\n        val unitDigits_13 = unitDigits_12.zip(unitDigits_13).map(x => x._1 * x._2)\n        val unitDigits_14 = unitDigits_13.zip(unitDigits_14).map(x => x._1 * x._2)\n        val unitDigits_15 = unitDigits_14.zip(unitDigits_15).map(x => x._1 * x._2)\n        val unitDigits_16 = unitDigits_15.zip(unitDigits_16).map(x => x._1 * x._2)\n        val unitDigits_17 = unitDigits_16.zip(unitDigits_17).map(x => x._1 * x._2)\n        val unitDigits_18 = unitDigits_17.zip(unitDigits_18).map(x => x._1 * x._2)\n        val unitDigits_19 = unitDigits_18.zip(unitDigits_19).map(x => x._1 * x._2)\n        val unitDigits_20\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9uncoeo2.scala:30:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9uncoeo2.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp9uncoeo2.scala:11:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((x._2 : => Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9uncoeo2.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9uncoeo2.scala:12:72 ------------------------\u001b[0m\u001b[",
      "stdout": "",
      "timestamp": 1660009570
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigits = unitDigits * unitDigits2\n        val remainder = remainder * remainder2\n        unitDigits + remainder\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplzm2j2bd.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toArray.map(_.toInt)\n        val unitDigits_1 = b.toString.toArray.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map{case (a,b) => a*b}\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map{case (a,b) => a*b}\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map{case (a,b) => a*b}\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_5).map{case (a,b) => a*b}\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_6).map{case (a,b) => a*b}\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_7).map{case (a,b) => a*b}\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_8).map{case (a,b) => a*b}\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_9).map{case (a,b) => a*b}\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_10).map{case (a,b) => a*b}\n        unitDigits_10.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn2p5qarg.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map{\u001b[33mcase\u001b[0m (a,b) => a*b}\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpn2p5qarg.scala:11:77 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map{\u001b[33mcase\u001b[0m (a,b) => a*b}\n\u001b[31m\u001b[31m   |\u001b[0m                                                                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((b : Any))\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn2p5qarg.scala:11:80 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map{\u001b[33mcase\u001b[0m (a,b) => a*b}\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009566
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product + remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpleq9dnkk.scala:17)\n\tat Problem.main(tmpleq9dnkk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map { case (a,b) => a*b }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map { case (a,b) => a*b }\n        unitDigits_3.foldLeft(0)(_+_)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu4rk4cjq.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpu4rk4cjq.scala:11:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((b : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu4rk4cjq.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu4rk4cjq.scala:12:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                 ",
      "stdout": "",
      "timestamp": 1660009567
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map { case (a,b) => a*b }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map { case (a,b) => a*b }\n        unitDigits_3.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0vwu6dzk.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp0vwu6dzk.scala:11:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((b : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0vwu6dzk.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0vwu6dzk.scala:12:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                 ",
      "stdout": "",
      "timestamp": 1660009569
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map{case (a,b) => a*b}\n        unitDigits_2.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4f8xpra7.scala:15)\n\tat Problem.main(tmp4f8xpra7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009571
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toArray.map(_.toInt)\n        val unitDigits2 = b.toString.toArray.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).product)\n        val unitDigits = unitDigits.map(x => x.toString.toArray.map(_.toInt).sum)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfcrndmsy.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfcrndmsy.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => x.toString.toArray.map(_.toInt).sum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfcrndmsy.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => x.toString.toArray.map(_.toInt).product)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfcrndmsy.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.map(\u001b[36mx\u001b[0m => x.toString.toArray.map(_.toInt).sum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined ",
      "stdout": "",
      "timestamp": 1660009570
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map { case (a,b) => a*b }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map { case (a,b) => a*b }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map { case (a,b) => a*b }\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_5).map { case (a,b) => a*b }\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_6).map { case (a,b) => a*b }\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_7).map { case (a,b) => a*b }\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_8).map { case (a,b) => a*b }\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_9).map { case (a,b) => a*b }\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_10).map { case (a,b) => a*b }\n        unitDigits_10.foldLeft(0)(_*(_+_))\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7kt8n7od.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp7kt8n7od.scala:11:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((b : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7kt8n7od.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7kt8n7od.scala:12:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map { \u001b[33mcase\u001b[0m (a,b) => a*b }\n\u001b[31m\u001b[31m   |\u001b[0m                                 ",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val unitDigits = unitDigits * unitDigits2\n        val remainder = (remainder * remainder2) % 10\n        unitDigits * remainder\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uzi9wfw.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uzi9wfw.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mremainder\u001b[0m = (remainder * remainder2) % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mremainder is already defined as \u001b[33mvalue\u001b[0m \u001b[35mremainder\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009565
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = b / 10\n        val unitDigits = b % 10\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits * unitDigits\n        val unitDigits = unitDigits \n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps3r3wvad.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps3r3wvad.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps3r3wvad.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps3r3wvad.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps3r3wvad.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b",
      "stdout": "",
      "timestamp": 1660009570
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_2).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        unitDigits_3.foldLeft(0)(_ * _)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_y02ssda.scala:20)\n\tat Problem.main(tmp_y02ssda.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product + remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpleq9dnkk.scala:17)\n\tat Problem.main(tmpleq9dnkk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val product = remainder * b\n        product + unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbm2uyp9u.scala:15)\n\tat Problem.main(tmpbm2uyp9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product * unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2muxdx2u.scala:17)\n\tat Problem.main(tmp2muxdx2u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_2).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_3).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        unitDigits_4.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptahwjvz_.scala:23)\n\tat Problem.main(tmptahwjvz_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toArray.map(_.toInt)\n        val unitDigits_1 = b.toString.toArray.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map{case (a,b) => a*b}\n        val unitDigits_3 = unitDigits.zip(unitDigits_2).map{case (a,b) => a*b}\n        val unitDigits_4 = unitDigits.zip(unitDigits_3).map{case (a,b) => a*b}\n        unitDigits_4.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu0wa0kvk.scala:17)\n\tat Problem.main(tmpu0wa0kvk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + product*remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg57od87q.scala:17)\n\tat Problem.main(tmpg57od87q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009572
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        var sum = 0\n        var product = 1\n        for(i <- 0 until a){\n            sum += i\n        }\n        for(j <- 0 until b){\n            product *= j\n        }\n        sum * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9meqb892.scala:12:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until a){\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (a : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9meqb892.scala:15:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mfor\u001b[0m(j <- \u001b[31m0\u001b[0m until b){\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (b : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009572
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + product*remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg57od87q.scala:17)\n\tat Problem.main(tmpg57od87q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009572
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a / 10\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp30hnizlf.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp30hnizlf.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp30hnizlf.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp30hnizlf.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp30hnizlf.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloade",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map(x => x._1 * x._2)\n        unitDigits_2.foldLeft(0)(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmppqv5erz6.scala:11:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmppqv5erz6.scala:11:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((x._2 : => Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmppqv5erz6.scala:12:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        unitDigits_2.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((_$4 : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009570
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n        val unitDigits2 = unitDigits2.filter(_ > 0)\n        val unitDigits = unitDigits.filter(_ < 10)\n        val unitDigits2 = unitDigits2.filter(_ < 10)\n        val unitDigits = unitDigits.filter(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm2n0yfbd.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm2n0yfbd.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm2n0yfbd.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.filter(_ < \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm2n0yfbd.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2.filter(_ < \u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm2n0yfbd.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[3",
      "stdout": "",
      "timestamp": 1660009572
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val product = unitDigits * unitDigits2\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8q8jabr_.scala:15)\n\tat Problem.main(tmp8q8jabr_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc4qym4yr.scala:17)\n\tat Problem.main(tmpc4qym4yr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val remainder = a % Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val remainder2 = b % Math.pow(10, b.toInt)\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyq02ilyx.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        product + product2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009557
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits = b % 10\n        val product = unitDigits * unitDigits\n        product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1btclj7r.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009569
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / Math.pow(10, a.toInt)\n        val remainder = a % Math.pow(10, a.toInt)\n        val unitDigits2 = b / Math.pow(10, b.toInt)\n        val remainder2 = b % Math.pow(10, b.toInt)\n        unitDigits * unitDigits2 * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfag6ycyv.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        unitDigits * unitDigits2 * remainder * remainder2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Double\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009561
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder * remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_h2bfrqs.scala:17)\n\tat Problem.main(tmp_h2bfrqs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa3_kdhm6.scala:17)\n\tat Problem.main(tmpa3_kdhm6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n        val unitDigits = a % 10\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgsjbt59a.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgsjbt59a.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgsjbt59a.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgsjbt59a.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgsjbt59a.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloade",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        val product2 = remainder * remainder2\n        product + product2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6p07wjqa.scala:18)\n\tat Problem.main(tmp6p07wjqa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009551
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits.zip(unitDigits_1).map { case (a,b) => a*b }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_2).map { case (a,b) => a*b }\n        unitDigits_3.sum\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5to443dw.scala:16)\n\tat Problem.main(tmp5to443dw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009574
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.toString.toInt\n        val unitDigits = b.toString.toInt\n        val unitDigits = a.\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsg11bogi.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsg11bogi.scala:10:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b.toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsg11bogi.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a.toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsg11bogi.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = b.toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsg11bogi.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = a.toString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsg11bogi.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 ",
      "stdout": "",
      "timestamp": 1660009573
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = remainder * remainder2\n        product + unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpccv6w_wm.scala:17)\n\tat Problem.main(tmpccv6w_wm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        // Write your code here\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits_1 = b.toString.toList.map(_.toInt)\n        val unitDigits_2 = unitDigits_1.zip(unitDigits_2).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_3 = unitDigits_2.zip(unitDigits_3).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_4 = unitDigits_3.zip(unitDigits_4).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_5 = unitDigits_4.zip(unitDigits_5).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_6 = unitDigits_5.zip(unitDigits_6).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_7 = unitDigits_6.zip(unitDigits_7).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_8 = unitDigits_7.zip(unitDigits_8).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_9 = unitDigits_8.zip(unitDigits_9).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_10 = unitDigits_9.zip(unitDigits_10).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_11 = unitDigits_10.zip(unitDigits_11).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_12 = unitDigits_11.zip(unitDigits_12).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_13 = unitDigits_12.zip(unitDigits_13).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_14 = unitDigits_13.zip(unitDigits_14).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_15 = unitDigits_14.zip(unitDigits_15).map {\n            case (digit1, digit2) => digit1 * digit2\n        }\n        val unitDigits_16 = unitDigits_15.\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3mux0sb.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk3mux0sb.scala:12:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_2\u001b[0m = unitDigits_1.zip(unitDigits_2).map {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpk3mux0sb.scala:13:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0m (x: Char): Int\n\u001b[31m   |\u001b[0m (x: Short): Int\n\u001b[31m   |\u001b[0m (x: Byte): Int\n\u001b[31m   |\u001b[0mall match arguments ((digit2 : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk3mux0sb.scala:15:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits_3\u001b[0m = unitDigits_2.zip(unitDigits_3).map {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Recursive \u001b[33mvalue\u001b[0m \u001b[35munitDigits_3\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk3mux0sb.scala:16:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mcase\u001b[0m (digit1, digit2) => digit1 * digit2\n\u001b[31m\u001b[31m   |\u001b[0m                  ",
      "stdout": "",
      "timestamp": 1660009575
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val remainder = a % 10\n        val unitDigits2 = b / 10\n        val remainder2 = b % 10\n        val product = unitDigits * unitDigits2\n        product * remainder + remainder2 * product\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt3e8157k.scala:17)\n\tat Problem.main(tmpt3e8157k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009550
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a / 10\n        val unitDigits2 = b / 10\n        val unitDigits = unitDigits * unitDigits2\n        val unitDigits = unitDigits % 10\n        unitDigits\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits * unitDigits2\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpggv4ggrt.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009547
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toList.map(_.toInt)\n        val unitDigits2 = b.toString.toList.map(_.toInt)\n        val unitDigits = unitDigits.zip(unitDigits2).map(x => x._1 * x._2)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.toList.map(_.toInt)\n        val unitDigits = unitDigits.to\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2kenkfcn.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.zip(unitDigits2).map(\u001b[36mx\u001b[0m => x._1 * x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2kenkfcn.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2kenkfcn.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2kenkfcn.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits.toList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2kenkfcn.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b",
      "stdout": "",
      "timestamp": 1660009574
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Complete the function that takes two integers and returns \n    // the product of their unit digits.\n    // Assume the input is always valid.\n    // Examples:\n    def multiply(a : Long, b : Long) : Long = {\n        val unitDigits = a.toString.toInt\n        val unitDigits2 = b.toString.toInt\n        val unitDigits = unitDigits / 10\n        val unitDigits2 = unitDigits2 / 10\n        val unitDigits = unitDigits % 10\n        val unitDigits2 = unitDigits2 % 10\n        unitDigits * unitDigits2\n    }\n    def main(args: Array[String]) = {\n    assert(multiply((148l), (412l)) == (16l));\n    assert(multiply((19l), (28l)) == (72l));\n    assert(multiply((2020l), (1851l)) == (0l));\n    assert(multiply((14l), (-15l)) == (20l));\n    assert(multiply((76l), (67l)) == (42l));\n    assert(multiply((17l), (27l)) == (49l));\n    assert(multiply((0l), (1l)) == (0l));\n    assert(multiply((0l), (0l)) == (0l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgkencei.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgkencei.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2 / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgkencei.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits\u001b[0m = unitDigits % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvgkencei.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36munitDigits2\u001b[0m = unitDigits2 % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0munitDigits2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35munitDigits2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009573
    }
  ]
}