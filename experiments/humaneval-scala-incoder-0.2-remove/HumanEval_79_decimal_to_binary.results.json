{
  "language": "scala",
  "name": "HumanEval_79_decimal_to_binary",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpprkwk47c.scala:15)\n\tat Problem.main(tmpprkwk47c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.drop(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdoe566in.scala:15)\n\tat Problem.main(tmpdoe566in.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0, binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc1hn9wso.scala:15)\n\tat Problem.main(tmpc1hn9wso.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\".toBinaryString\n        val result = binary.dropRight(binary.length + 2)\n        result + db + result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmhin5cr5.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdb\u001b[0m = \u001b[31m\"db\"\u001b[0m.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toBinaryString is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length, binary.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmplvfmno92.scala:13)\n\tat Problem$.main(tmplvfmno92.scala:17)\n\tat Problem.main(tmplvfmno92.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStr",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length) + db + binary.drop(binary.length)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3qkyxeo5.scala:17)\n\tat Problem.main(tmp3qkyxeo5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.drop(1).dropRight(1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzhchc_qz.scala:15)\n\tat Problem.main(tmpzhchc_qz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 3)\n        result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 3)\n        result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        result + db + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStr",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        result + db + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0) {\n            binary += remainder % 2\n            remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:16:12 ---------------------------\u001b[0",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.dropRight(binary.length + db.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpllgcqr65.scala:16)\n\tat Problem.main(tmpllgcqr65.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n        val extraCharsLength = extraChars.length\n        val binaryLength = binary.length\n        val binaryStringLength = binaryLength + extraCharsLength\n        val binaryString = new Array[Char](binaryStringLength)\n        val extraCharsArray = new Array[Char](extraCharsLength)\n        val extraCharsArrayIndex = 0\n        val binaryArrayIndex = 0\n        val binaryStringIndex = 0\n        while (binaryArrayIndex < binaryLength) {\n            binaryString(binaryStringIndex) = binary(binaryArrayIndex)\n            extraCharsArray(extraCharsArrayIndex) = extraChars(extraCharsArrayIndex)\n            extraCharsArrayIndex += 1\n            binaryArrayIndex += 1\n            binaryStringIndex += 1\n        }\n        val binaryStringBuilder = new StringBuilder\n        binaryStringBuilder.append(extraCharsArray(0))\n        binaryStringBuilder.append(binaryString(0))\n        binaryStringBuilder.toString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6932ekk.scala:24:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            extraCharsArrayIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value += is not a member of Int - did you mean extraCharsArrayIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6932ekk.scala:25:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            binaryArrayIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value += is not a member of Int - did you mean binaryArrayIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6932ekk.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            binaryStringIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of Int - did you mean binaryStringIndex.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0){\n            binary += (decimal % 2).toChar\n            remainder = decimal / 2\n        }\n        binary += remainder.toChar\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmply2cxk62.scala:22)\n\tat Problem.main(tmply2cxk62.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.replace(\"0\",\"db\")\n        val binary = binary.replace(\"1\",\"0\")\n        binary.substring(2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl1khcbzl.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"0\"\u001b[0m,\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl1khcbzl.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"1\"\u001b[0m,\u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009418
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length, binary.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmplvfmno92.scala:13)\n\tat Problem$.main(tmplvfmno92.scala:17)\n\tat Problem.main(tmplvfmno92.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length) + db + binary.take(binary.length)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb_4itmvo.scala:17)\n\tat Problem.main(tmpb_4itmvo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsLength = extraChars.length\n        val extraCharsString = \"db\" + extraChars\n        val binaryLength = binary.length\n        val binaryString = \"0\" * (binaryLength - extraCharsLength) + binary + extraCharsString\n        binaryString.substring(0,binaryString.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpwgnrpq58.scala:12)\n\tat Problem$.main(tmpwgnrpq58.scala:20)\n\tat Problem.main(tmpwgnrpq58.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009429
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0,1) + binary.substring(1,binary.length-1) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmpnt_27dug.scala:12)\n\tat Problem$.main(tmpnt_27dug.scala:15)\n\tat Problem.main(tmpnt_27dug.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length - extraChars.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd_on7z8z.scala:16)\n\tat Problem.main(tmpd_on7z8z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt01styv6.scala:16)\n\tat Problem.main(tmpt01styv6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzb3s9grr.scala:16)\n\tat Problem.main(tmpzb3s9grr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        binary.toCharArray\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpp3zsx_0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp3zsx_0l.scala:14:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Array[Char]\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded metho",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        result + db + binary.dropLeft(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value dropLeft is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.dropRight(binary.length + db.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpllgcqr65.scala:16)\n\tat Problem.main(tmpllgcqr65.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbz1d0pch.scala:16)\n\tat Problem.main(tmpbz1d0pch.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary.toUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.concat(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length, binary.length)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0) {\n            binary += remainder % 2\n            remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.concat(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009428
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStr",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.toCharArray\n        val binary = binary.map(_ + \"\")\n        val binary = binary.mkString(\"db\")\n        binary.toString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(_ + \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.mkString(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m",
      "stdout": "",
      "timestamp": 1660009428
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:16:12 ---------------------------\u001b[0",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == \"1\") \"db\" else \"\"\n        binary.dropRight(binary.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm5z0iv57.scala:16)\n\tat Problem.main(tmpm5z0iv57.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n        val extraCharsLen = extraChars.length\n        val binLen = binary.length\n        val result = new StringBuilder(binLen)\n        val remainder = decimal.asInstanceOf[Long] % 2\n        val remainderChar = if (remainder == 0) \"0\" else \"1\"\n        val remainderLen = remainderChar.length\n        result.append('b').append(remainderChar)\n        val remainderIndex = binLen - remainderLen - 1\n        val remainderCharIndex = binLen - remainderLen - remainderIndex - 1\n        val remainderCharIndex2 = binLen - remainderLen - remainderIndex - 2\n        val remainderCharIndex3 = binLen - remainderLen - remainderIndex - 3\n        val remainderCharIndex4 = binLen - remainderLen - remainderIndex - 4\n        val remainderCharIndex5 = binLen - remainderLen - remainderIndex - 5\n        val remainderCharIndex6 = binLen - remainderLen - remainderIndex - 6\n        val remainderCharIndex7 = binLen - remainderLen - remainderIndex - 7\n        val remainderCharIndex8 = binLen - remainderLen - remainderIndex - 8\n        val remainderCharIndex9 = binLen - remainderLen - remainderIndex - 9\n        val remainderCharIndex10 = binLen - remainderLen - remainderIndex - 10\n        val remainderCharIndex11 = binLen - remainderLen - remainderIndex - 11\n        val remainderCharIndex12 = binLen - remainderLen - remainderIndex - 12\n        val remainderCharIndex13 = binLen - remainderLen - remainderIndex - 13\n        val remainderCharIndex14 = binLen - remainderLen - remainderIndex - 14\n        val remainderCharIndex15 = binLen - remainderLen - remainderIndex - 15\n        val remainderCharIndex16 = binLen - remainderLen - remainderIndex - 16\n        val remainderCharIndex17 = binLen - remainderLen - remainderIndex - 17\n        val remainderCharIndex18 = binLen - remainderLen - remainderIndex - 18\n        val remainderCharIndex19 = binLen - remainderLen - remainderIndex - 19\n        val remainderCharIndex20\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyd5sso83.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyd5sso83.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzb3s9grr.scala:16)\n\tat Problem.main(tmpzb3s9grr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33m",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl6_qmrly.scala:12)\n\tat Problem$.main(tmpl6_qmrly.scala:15)\n\tat Problem.main(tmpl6_qmrly.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33m",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStr",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2, binary.length) + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmp_ijt4r37.scala:12)\n\tat Problem$.main(tmp_ijt4r37.scala:15)\n\tat Problem.main(tmp_ijt4r37.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (decimal == 0) \"\" else s\"db${decimal.toBinaryString}\"\n        binary.dropRight(binary.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq5i6bcsd.scala:16)\n\tat Problem.main(tmpq5i6bcsd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val result = binary.reverse.dropWhile(_ == '0').dropWhile(_ == '1').mkString\n        result + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpeyewijsc.scala:16)\n\tat Problem.main(tmpeyewijsc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009437
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length + 2)\n        result + db + binary.drop(binary.length + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcoiwiy1z.scala:17)\n\tat Problem.main(tmpcoiwiy1z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009438
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.drop(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp369vl_sm.scala:17)\n\tat Problem.main(tmp369vl_sm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.takeRight(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgy8xid0q.scala:17)\n\tat Problem.main(tmpgy8xid0q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33m",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\".toBinaryString\n        val result = binary.padTo(binary.length, \"0\")\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmsbv7trt.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdb\u001b[0m = \u001b[31m\"db\"\u001b[0m.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toBinaryString is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmsbv7trt.scala:14:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        result + db\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of IndexedSeq[Matchable], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 3)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpu_h2vutg.scala:13)\n\tat Problem$.main(tmpu_h2vutg.scala:17)\n\tat Problem.main(tmpu_h2vutg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val result = binary.substring(binary.length - 2)\n        result + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp08hvo39f.scala:12)\n\tat Problem$.main(tmp08hvo39f.scala:16)\n\tat Problem.main(tmp08hvo39f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        binary.toCharArray\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa_rwnp77.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa_rwnp77.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa_rwnp77.scala:14:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Array[Char]\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n        val extraCharsLength = extraChars.length\n        val result = binary.padToLength(binary.length + extraCharsLength, \"0\")\n        result + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnwqvz70z.scala:14:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = binary.padToLength(binary.length + extraCharsLength, \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value padToLength is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2) +\n            binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpdtpni03q.scala:12)\n\tat Problem$.main(tmpdtpni03q.scala:16)\n\tat Problem.main(tmpdtpni03q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0) {\n            binary += remainder % 2\n            remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0){\n            binary += remainder % 2\n            remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu14t70nl.scala:21)\n\tat Problem.main(tmpu14t70nl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val result = binary.substring(binary.length - 2)\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsLength = extraChars.length\n        val extraCharsString = extraChars.substring(0, extraCharsLength)\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength = extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringLength\u001b[0m = extraCharsString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringLength\u001b[0m = extraCharsString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringLength\u001b[0m = extraCharsString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringLength\u001b[0m = extraCharsString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:21:",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == \"11111111\") \"db\" else \"\"\n        binary.substring(1) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcl719ogm.scala:16)\n\tat Problem.main(tmpcl719ogm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\".toBinaryString\n        binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgy2rg7q6.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdb\u001b[0m = \u001b[31m\"db\"\u001b[0m.toBinaryString\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toBinaryString is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,1) + db + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpps1q97c4.scala:16)\n\tat Problem.main(tmpps1q97c4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009438
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 3)\n        result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:16:12 ---------------------------\u001b[0",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbz1d0pch.scala:16)\n\tat Problem.main(tmpbz1d0pch.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpprkwk47c.scala:15)\n\tat Problem.main(tmpprkwk47c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        val result = result + db\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo3si9cwq.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result + db\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.concat(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009428
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary.length < 8) {\n            Array(binary.charAt(0), binary.charAt(binary.length - 1))\n        } else {\n            Array(binary.charAt(0), binary.charAt(binary.length - 1), binary.charAt(binary.length - 2))\n        }\n        extraChars.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpn5w_g76c.scala:20)\n\tat Problem.main(tmpn5w_g76c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.toCharArray\n        val binary = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\")\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m'0'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'1'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = ",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        result + db + binary.dropLeft(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value dropLeft is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db + binary.substring(0, binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\".toCharArray\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx5a5bz2y.scala:17)\n\tat Problem.main(tmpx5a5bz2y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009420
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsDb = \"db\" + extraChars\n        binary.substring(1) + extraCharsDb + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp3gzetacw.scala:12)\n\tat Problem$.main(tmp3gzetacw.scala:17)\n\tat Problem.main(tmp3gzetacw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length, binary.length)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedLength = extraCharsReversed.length\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraChar\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx2n5sb_5.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedLength\u001b[0m = extraCharsReversedLength + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedLength\u001b[0m = extraCharsReversedLength + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedLength\u001b[0m = extraCharsReversedLength + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedLength\u001b[0m = extraCharsReversedLength + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660009446
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        result + db + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.drop(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary.length < 8) \"db\" else \"\"\n        binary.padTo(8, extraChars)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp18x6vs_m.scala:13:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        binary.padTo(\u001b[31m8\u001b[0m, extraChars)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (extraChars : String)\n\u001b[31m   |\u001b[0m                        Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009447
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length - 2) +\n            binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpdtpni03q.scala:12)\n\tat Problem$.main(tmpdtpni03q.scala:16)\n\tat Problem.main(tmpdtpni03q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.replace(\"0\",\"db\")\n        val binary = binary.replace(\"1\",\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl7a4s2b8.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl7a4s2b8.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl7a4s2b8.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"0\"\u001b[0m,\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl7a4s2b8.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"1\"\u001b[0m,\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660009444
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStr",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.toCharArray\n        val binary = binary.map(_ + 48)\n        val binary = binary.toList\n        val binary = binary.toString.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp06kdow51.scala:73:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp06kdow51.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp06kdow51.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp06kdow51.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp06kdow51.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(_ + \u001b[31m48\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp06k",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary.toUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.concat(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009427
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.replace(\"0\",\"db\")\n        val binary = binary.replace(\"1\",\"0\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_vgod8k.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"0\"\u001b[0m,\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpq_vgod8k.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.replace(\u001b[31m\"1\"\u001b[0m,\u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009444
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length - extraChars.length) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd_on7z8z.scala:16)\n\tat Problem.main(tmpd_on7z8z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2, binary.length)\n        val extraCharsString = extraChars.toUpperCase\n        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringWithDb = extraCharsString + extraCharsString.substring(0, extraCharsStringLength - 1) + extraCharsString.substring(extraCharsStringLength - 1, extraCharsStringLength)\n        val extraCharsStringWithDbLength = extraCharsStringWithDb.length\n        val extraCharsStringWithDbWithDb = extraCharsStringWithDb + extraCharsStringWithDb.substring(0, extraCharsStringWithDbLength - 1) + extraCharsStringWithDb.substring(extraCharsStringWithDbLength - 1, extraCharsStringWithDbLength)\n        val extraCharsStringWithDbWithDbLength = extraCharsStringWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDb = extraCharsStringWithDbWithDb + extraCharsStringWithDbWithDb.substring(0, extraCharsStringWithDbWithDbLength - 1) + extraCharsStringWithDbWithDb.substring(extraCharsStringWithDbWithDbLength - 1, extraCharsStringWithDbWithDbLength)\n        val extraCharsStringWithDbWithDbWithDbLength = extraCharsStringWithDbWithDbWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDbWithDb = extraCharsStringWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDb.substring(0, extraCharsStringWithDbWithDbWithDbWithDbLength - 1) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength - 1, extraCharsStringWithDbWithDbWithDbLength)\n        val extraCharsStringWithDbWithDbWithDbWithDbLength = extraCharsStringWithDbWithDbWithDbWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDbWithDbWithDb = extraCharsStringWithDbWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDbWithDb.substring(0, extraCharsStringWithDbWithDbWithDbWithDbWithDbWithDbLength - 1) + extraCharsStringWithDbWithDbWithDbWithDbWithDb.substring(extraCharsStringWith\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkm2ksupk.scala:24:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:21:92 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringWithDbWithDbWithDbWithDb\u001b[0m = extraCharsStringWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDb.substring(\u001b[31m0\u001b[0m, extraCharsStringWithDbWithDbWithDbWithDbLength - \u001b[31m1\u001b[0m) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength - \u001b[31m1\u001b[0m, extraCharsStringWithDbWithDbWithDbLength)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m     Recursive \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringWithDbWithDbWithDbWithDb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:21:200 --------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsStringWithDbWithDbWithDbWithDb\u001b[0m = extraCharsStringWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDb.substring(\u001b[31m0\u001b[0m, extraCharsStringWithDbWithDbWithDbWithDbLength - \u001b[31m1\u001b[0m) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength - \u001b[31m1\u001b[0m, extraCharsStringWithDbWithDbWithDbLength)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m     Recursive \u001b[33mvalue\u001b[0m \u001b[35mextraCharsStringWithDbWithDbWithDbWithDb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:23:104 --------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mext",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\".toCharArray\n        val result = binary.dropRight(binary.length - db.length) + db + binary.take(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnniqh67s.scala:17)\n\tat Problem.main(tmpnniqh67s.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        result + db + binary.dropLeft(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value dropLeft is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n        binary += \"db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpw7z8jsxy.scala:120:18 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m120 |\u001b[0m        binary += \"db\n\u001b[31m\u001b[31m    |\u001b[0m                  ^\u001b[0m\n\u001b[31m    |\u001b[0m                  unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpw7z8jsxy.scala:122:34 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m122 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m    |\u001b[0m                                  ^\u001b[0m\n\u001b[31m    |\u001b[0m                               end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:14:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:36:20 ------------------------\u001b[0m",
      "stdout": "",
      "timestamp": 1660009451
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsLen = extraChars.length\n        val extraCharsStr = \"db\" + extraChars\n        val binaryLen = binary.length\n        val binaryStr = \"db\" + binary\n        val result = extraCharsStr + binaryStr\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpcmikjr09.scala:12)\n\tat Problem$.main(tmpcmikjr09.scala:21)\n\tat Problem.main(tmpcmikjr09.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length, binary.length)\n        result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - 2)\n        val result = db + result\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9k4_2j1_.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = db + result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009446
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n        val extraCharsLen = extraChars.length\n        val extraCharsLen2 = extraCharsLen / 2\n        val extraCharsLen3 = extraCharsLen - extraCharsLen2\n        val extraCharsLen4 = extraCharsLen - extraCharsLen2 - extraCharsLen3\n        val extraCharsLen5 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4\n        val extraCharsLen6 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5\n        val extraCharsLen7 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6\n        val extraCharsLen8 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7\n        val extraCharsLen9 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8\n        val extraCharsLen10 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8 - extraCharsLen9\n        val extraCharsLen11 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8 - extraCharsLen9 - extraCharsLen10\n        val extraCharsLen12 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8 - extraCharsLen9 - extraCharsLen10 - extraCharsLen11\n        val extraCharsLen13 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf11w0xy5.scala:25:114 -----------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsLen13\u001b[0m = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extra\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Not found: extra\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf11w0xy5.scala:26:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0,1) + binary.substring(1,binary.length-1) + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.decimalToBinary(tmplccgndwi.scala:12)\n\tat Problem$.main(tmplccgndwi.scala:15)\n\tat Problem.main(tmplccgndwi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009431
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsLength = extraChars.length\n        val extraCharsLengthInt = extraCharsLength.toInt\n        val extraCharsLengthString = extraChars.substring(extraCharsLengthInt - 1)\n        val extraCharsLengthStringInt = extraCharsLengthString.toInt\n        val extraCharsLengthStringString = extraCharsLengthString.substring(extraCharsLengthStringInt - 1)\n        val extraCharsLengthStringIntString = extraCharsLengthStringString.toInt\n        val extraCharsLengthStringStringString = extraCharsLengthStringString.substring(extraCharsLengthStringIntString - 1)\n        val extraCharsLengthStringIntStringString = extraCharsLengthStringStringString.toInt\n        val extraCharsLengthStringIntStringStringString = extraCharsLengthStringIntStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringString = extraCharsLengthStringIntStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbe1ixzlp.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:21:58 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsLengthStringIntStringStringString\u001b[0m = extraCharsLengthStringIntStringStringString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m  Recursive \u001b[33mvalue\u001b[0m \u001b[35mextraCharsLengthStringIntStringStringString\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:22:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsLengthStringIntStringStringStringString\u001b[0m = extraCharsLengthStringIntStringStringStringString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mextraCharsLengthStringIntStringStringStringString\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:23:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsLengthStringIntStringStringStringStringString\u001b[0m = extraCharsLengthStringIntStringStringStringStringString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mextraCharsLengthStringIntStringStringStringStringString\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbe1ixzlp.scala:24:76 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsLengthStringIntStringStringStringStringStringString\u001b[0m = extraCharsLengthStringIntStringStringStringStri",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.toCharArray\n        val binary = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\")\n        val binary = binary.concat(\"db\")\n        val binary = binary.concat(\"db\")\n        binary.toString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m'0'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'1'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = ",
      "stdout": "",
      "timestamp": 1660009447
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        result + db + binary.dropLeft(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value dropLeft is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(binary.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is ",
      "stdout": "",
      "timestamp": 1660009449
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33m",
      "stdout": "",
      "timestamp": 1660009430
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val result = binary.substring(binary.length - 2)\n        result + binary.substring(0, binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp9ligp8o6.scala:12)\n\tat Problem$.main(tmp9ligp8o6.scala:16)\n\tat Problem.main(tmp9ligp8o6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcvjcs0_z.scala:15)\n\tat Problem.main(tmpcvjcs0_z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        val dbResult = binary.substring(binary.length-1)\n        result + db + dbResult\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzs577bpf.scala:18)\n\tat Problem.main(tmpzs577bpf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n        val db = \"db\" + extraChars\n        binary.dropRight(binary.length - extraChars.length) + db + binary.takeRight(binary.length - extraChars.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_dohmwbd.scala:17)\n\tat Problem.main(tmp_dohmwbd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.dropRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        val extra = binary.substring(binary.length-1)\n        result + db + extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwq18ir3a.scala:18)\n\tat Problem.main(tmpwq18ir3a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009451
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n        result + db + binary.substring(binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009421
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extraCharsReversedStringLength = extraCharsReversedString.length\n        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mextraCharsReversedStringLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mextraCharsReversedStringLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mextraCharsReversedStringLength\u001b[0m = extraCharsReversedString.length\n\u001b[31m\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1660009438
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0, binary.length - 2)\n        val binary = binary.toCharArray\n        val binary = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\")\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.substring(\u001b[31m0\u001b[0m, binary.length - \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m'0'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'1'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = ",
      "stdout": "",
      "timestamp": 1660009439
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n        result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n        var remainder2 = decimal\n        while(decimal != 0) {\n            decimal /= 2\n            remainder2 = remainder * 2\n            binary = remainder2 + binary\n            remainder = decimal % 2\n        }\n        binary = binary + \"db\"\n        return binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx4zgd5uc.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            decimal /= \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean decimal.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0, bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = bin.substring(\u001b[31m0\u001b[0m, bin.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinary\u001b[0m = binary.concat(\u001b[31m\"db\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbinary is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbinary\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660009428
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val db = \"db\"\n        val result = binary.substring(binary.length - db.length) + db\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj0kwa20o.scala:13)\n\tat Problem$.main(tmpj0kwa20o.scala:17)\n\tat Problem.main(tmpj0kwa20o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009451
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = binary.substring(binary.length - 2)\n        val extraCharsDb = \"db\" + extraChars\n        binary.substring(0,binary.length - 2) + extraCharsDb + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpq4lgj71b.scala:12)\n\tat Problem$.main(tmpq4lgj71b.scala:17)\n\tat Problem.main(tmpq4lgj71b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660009450
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val extraChars = if (binary.length < 8) \"db\" else \"\"\n        binary.padToLength(8) + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpudqmhkcz.scala:13:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        binary.padToLength(\u001b[31m8\u001b[0m) + extraChars\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value padToLength is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009451
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You will be given a number in decimal form and your task is to convert it to\n    // binary format. The function should return a string, with each character representing a binary\n    // number. Each character in the string will be '0' or '1'.\n    // There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    // The extra characters are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal : Long) : String = {\n        val binary = decimal.toBinaryString\n        val bin = binary.dropRight(binary.length-1)\n        val bin2 = bin.dropRight(bin.length-1)\n        val bin3 = bin2.dropRight(bin2.length-1)\n        val bin4 = bin3.dropRight(bin3.length-1)\n        val bin5 = bin4.dropRight(bin4.length-1)\n        val bin6 = bin5.dropRight(bin5.length-1)\n        val bin7 = bin6.dropRight(bin6.length-1)\n        val bin8 = bin7.dropRight(bin7.length-1)\n        val bin9 = bin8.dropRight(bin8.length-1)\n        val bin10 = bin9.dropRight(bin9.length-1)\n        val bin11 = bin10.dropRight(bin10.length-1)\n        val bin12 = bin11.dropRight(bin11.length-1)\n        val bin13 = bin12.dropRight(bin12.length-1)\n        val bin14 = bin13.dropRight(bin13.length-1)\n        val bin15 = bin14.dropRight(bin14.length-1)\n        val bin16 = bin15.dropRight(bin15.length-1)\n        val bin17 = bin16.dropRight(bin16.length-1)\n        val bin18 = bin17.dropRight(bin17.length-1)\n        val bin19 = bin18.dropRight(bin18.length-1)\n        val bin20 = bin19.dropRight(bin19.length-1)\n        val bin21 = bin20.dropRight(bin20.length-1)\n        val bin22 = bin21.dropRight(bin21.length-1)\n        val bin23 = bin22.dropRight(bin22.length-1)\n        val bin24 = bin23.dropRight(bin23.length-1)\n        val bin25 = bin24.dropRight(bin24.length-1)\n        val bin26 = bin25.dropRight(bin25.length-1)\n        val bin27 = bin26.dropRight(bin26.length-1)\n        val bin28 = bin27.dropRight(bin27.length-1)\n        val bin29 = bin28.dropRight(bin28.length-1)\n        val bin30 = bin29.dropRight(bin29.length-1)\n        val bin31 = bin30.dropRight(bin30.length-1)\n        val bin32 = bin31.dropRight(bin31.length-1)\n        val bin33 = bin32.dropRight(bin32.length-1)\n        val bin34 = bin33.dropRight(bin33.length-1)\n        val bin35 = bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp86yvb03_.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660009451
    }
  ]
}